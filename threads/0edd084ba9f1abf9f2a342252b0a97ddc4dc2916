<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0f163c0be9c7f32231614d28b2ceccab?s=50"></div><header><strong>Prototyping what Swift can look like in educational settings</strong> from <string>Donald Pinckney</string> &lt;djpinckney at ucdavis.edu&gt;<p>January  5, 2016 at 10:00:00pm</p></header><div class="content"><p>Hi all,<br>Personally, I love Swift, and I am curious to see if it will be used in educational settings, not necessarily even CS education.  As something of an experiment to see how Swift could currently look in education, I coded a Swift playground (sorry, very Mac specific right now!) that is a rewriting of a lab activity we did in my 3rd quarter of physics.  For those who are interested in educational aspects of Swift, and have a Mac to run this code, feel free to check out my attached playground, and give any sort of feedback, with respect to either the code or more philosophically where you think Swift could go with education.<br></p><p>Cheers,<br>Donald Pinckney<br></p><p>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: Schro?dinger.playground.zip<br>Type: application/zip<br>Size: 293880 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160105/0edd2916/attachment-0001.zip&gt;<br>-------------- next part --------------<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/936a6a8c18cd1a181cae5de7b818a24d?s=50"></div><header><strong>Prototyping what Swift can look like in educational settings</strong> from <string>Dru Satori</string> &lt;dru at druware.com&gt;<p>January  6, 2016 at 05:00:00pm</p></header><div class="content"><p>There is a huge potential here. The weakness, today at least, is that with Swift 2.0, there remain some difficulties in terms of being dependent upon reaching out to Objective C to accomplish some tasks. Looking at what is coming with Swift 3.0, and the work done on the Linux port, I think there is a clear roadmap that makes many of these issues go away, but right now, today, I think it is a tough sell into the edu market.<br></p><p><br></p><p><br></p><p>On 1/6/16, 1:42 AM, &quot;swift-users-bounces at swift.org on behalf of Donald Pinckney via swift-users&quot; &lt;swift-users-bounces at swift.org on behalf of swift-users at swift.org&gt; wrote:<br></p><p>&gt;Hi all,<br>&gt;Personally, I love Swift, and I am curious to see if it will be used in educational settings, not necessarily even CS education.  As something of an experiment to see how Swift could currently look in education, I coded a Swift playground (sorry, very Mac specific right now!) that is a rewriting of a lab activity we did in my 3rd quarter of physics.  For those who are interested in educational aspects of Swift, and have a Mac to run this code, feel free to check out my attached playground, and give any sort of feedback, with respect to either the code or more philosophically where you think Swift could go with education.<br>&gt;<br>&gt;Cheers,<br>&gt;Donald Pinckney<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d258a22a520c13772442666364207fa?s=50"></div><header><strong>Prototyping what Swift can look like in educational settings</strong> from <string>Don Wills</string> &lt;don.wills at portablesoftware.com&gt;<p>January  6, 2016 at 10:00:00am</p></header><div class="content"><p>[soapbox]<br></p><p>Coming from the perspective of business applications market (Java and C#), I see major problems in moving to Swift.  It&#39;s simple too different.  The String class is a disaster.  Optionals present a giant spider web of interconnectedness and syntax idiosyncrasy that does not provide any real advantage compared with Java/C#.  The fact that Ints, etc. are not really primitives (unwrapping is required, sometimes explicit, sometimes implicit) is a major dislocation for those coming from all C-syntax-based languages.  The lack of non-checked exceptions (that is exceptions not declared with a throws clause on the func def) is problem.  The lack of packages and/or namespaces is another giant gaping hole.<br></p><p>I had high hopes when I first looked into Swift.  Those hopes have been dashed, and I don&#39;t see anything in my limited view of the plans for Swift 3.0 that addresses any of these concerns or several others that I did not mention.<br></p><p>[/soapbox]<br></p><p>Don Wills<br></p><p><br>&gt; On Jan 6, 2016, at 10:15 AM, Dru Satori via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; There is a huge potential here. The weakness, today at least, is that with Swift 2.0, there remain some difficulties in terms of being dependent upon reaching out to Objective C to accomplish some tasks. Looking at what is coming with Swift 3.0, and the work done on the Linux port, I think there is a clear roadmap that makes many of these issues go away, but right now, today, I think it is a tough sell into the edu market.<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; On 1/6/16, 1:42 AM, &quot;swift-users-bounces at swift.org on behalf of Donald Pinckney via swift-users&quot; &lt;swift-users-bounces at swift.org on behalf of swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Hi all,<br>&gt;&gt; Personally, I love Swift, and I am curious to see if it will be used in educational settings, not necessarily even CS education.  As something of an experiment to see how Swift could currently look in education, I coded a Swift playground (sorry, very Mac specific right now!) that is a rewriting of a lab activity we did in my 3rd quarter of physics.  For those who are interested in educational aspects of Swift, and have a Mac to run this code, feel free to check out my attached playground, and give any sort of feedback, with respect to either the code or more philosophically where you think Swift could go with education.<br>&gt;&gt; <br>&gt;&gt; Cheers,<br>&gt;&gt; Donald Pinckney<br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ccbc60826cca6a6f9c527b671cdad531?s=50"></div><header><strong>Prototyping what Swift can look like in educational settings</strong> from <string>Loïc Lecrenier</string> &lt;loiclecrenier at icloud.com&gt;<p>January  6, 2016 at 06:00:00pm</p></header><div class="content"><p>Hi Don,<br></p><p>I don’t understand these complaints.<br></p><p>The String class is complicated, but it is not a disaster, it just needs more convenience methods. See: https://www.mikeash.com/pyblog/friday-qa-2015-11-06-why-is-swifts-string-api-so-hard.html for an explanation of the String API.<br></p><p>Optionals is an essential feature for writing safe code. I don’t see how it presents a giant spider web of interconnectedness. Plenty of languages have optionals (Rust, Haskell) and it has brought nothing but advantages.<br></p><p>Swift does not have primitives, but I consider that a plus: every type has access to the same features. It makes the language more consistent and more flexible. Also note that there is no performance cost to the way Swift represents Int. They are just as efficient as C’s int. <br>I also don’t understand what you mean by “unwrapping is required, sometimes explicit, sometimes implicit”.<br></p><p>I won’t comment on non-checked exceptions. But I’m not convinced this is a very valuable feature.<br></p><p>Maybe I’m misunderstanding what you mean by “package”, but isn&#39;t the Swift Package Manager a good solution for packages?<br>Namespaces also exist, although it is quite rudimentary. There is a proposal draft for “beefing up” import that tries to improve that.<br></p><p>Honestly, it seems like you haven’t given Swift a fair shot, and wanted to see a Java/C# clone instead.<br>It is also evolving very quickly, so I wouldn’t lose hope :-)<br></p><p>Regards,<br></p><p>Loïc<br></p><p>&gt; On Jan 6, 2016, at 6:34 PM, Don Wills via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; [soapbox]<br>&gt; <br>&gt; Coming from the perspective of business applications market (Java and C#), I see major problems in moving to Swift.  It&#39;s simple too different.  The String class is a disaster.  Optionals present a giant spider web of interconnectedness and syntax idiosyncrasy that does not provide any real advantage compared with Java/C#.  The fact that Ints, etc. are not really primitives (unwrapping is required, sometimes explicit, sometimes implicit) is a major dislocation for those coming from all C-syntax-based languages.  The lack of non-checked exceptions (that is exceptions not declared with a throws clause on the func def) is problem.  The lack of packages and/or namespaces is another giant gaping hole.<br>&gt; <br>&gt; I had high hopes when I first looked into Swift.  Those hopes have been dashed, and I don&#39;t see anything in my limited view of the plans for Swift 3.0 that addresses any of these concerns or several others that I did not mention.<br>&gt; <br>&gt; [/soapbox]<br>&gt; <br>&gt; Don Wills<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 6, 2016, at 10:15 AM, Dru Satori via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; There is a huge potential here. The weakness, today at least, is that with Swift 2.0, there remain some difficulties in terms of being dependent upon reaching out to Objective C to accomplish some tasks. Looking at what is coming with Swift 3.0, and the work done on the Linux port, I think there is a clear roadmap that makes many of these issues go away, but right now, today, I think it is a tough sell into the edu market.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On 1/6/16, 1:42 AM, &quot;swift-users-bounces at swift.org on behalf of Donald Pinckney via swift-users&quot; &lt;swift-users-bounces at swift.org on behalf of swift-users at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt; Personally, I love Swift, and I am curious to see if it will be used in educational settings, not necessarily even CS education.  As something of an experiment to see how Swift could currently look in education, I coded a Swift playground (sorry, very Mac specific right now!) that is a rewriting of a lab activity we did in my 3rd quarter of physics.  For those who are interested in educational aspects of Swift, and have a Mac to run this code, feel free to check out my attached playground, and give any sort of feedback, with respect to either the code or more philosophically where you think Swift could go with education.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt; Donald Pinckney<br>&gt;&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ccbc60826cca6a6f9c527b671cdad531?s=50"></div><header><strong>Prototyping what Swift can look like in educational settings</strong> from <string>Loïc Lecrenier</string> &lt;loiclecrenier at icloud.com&gt;<p>January  6, 2016 at 07:00:00pm</p></header><div class="content"><p>Oops, I just noticed (thanks Jen) that I replied to an off-topic comment. Sorry, Donald Pinckney :(<br></p><p>Back on topic!<br></p><p>I love the playground. You should look into the XCPlayground framework to display graphics in the timeline instead of in-line, I think it would be nicer.<br>I see that you used pdf files for the formulas, and that didn’t render well on a dark background. It would be great if the markup language for playground supported mathematical notation. It is almost a necessity for using it in an educational settings.<br></p><p>Loïc<br></p><p><br>&gt; On Jan 6, 2016, at 6:58 PM, Loïc Lecrenier via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi Don,<br>&gt; <br>&gt; I don’t understand these complaints.<br>&gt; <br>&gt; The String class is complicated, but it is not a disaster, it just needs more convenience methods. See: https://www.mikeash.com/pyblog/friday-qa-2015-11-06-why-is-swifts-string-api-so-hard.html for an explanation of the String API.<br>&gt; <br>&gt; Optionals is an essential feature for writing safe code. I don’t see how it presents a giant spider web of interconnectedness. Plenty of languages have optionals (Rust, Haskell) and it has brought nothing but advantages.<br>&gt; <br>&gt; Swift does not have primitives, but I consider that a plus: every type has access to the same features. It makes the language more consistent and more flexible. Also note that there is no performance cost to the way Swift represents Int. They are just as efficient as C’s int. <br>&gt; I also don’t understand what you mean by “unwrapping is required, sometimes explicit, sometimes implicit”.<br>&gt; <br>&gt; I won’t comment on non-checked exceptions. But I’m not convinced this is a very valuable feature.<br>&gt; <br>&gt; Maybe I’m misunderstanding what you mean by “package”, but isn&#39;t the Swift Package Manager a good solution for packages?<br>&gt; Namespaces also exist, although it is quite rudimentary. There is a proposal draft for “beefing up” import that tries to improve that.<br>&gt; <br>&gt; Honestly, it seems like you haven’t given Swift a fair shot, and wanted to see a Java/C# clone instead.<br>&gt; It is also evolving very quickly, so I wouldn’t lose hope :-)<br>&gt; <br>&gt; Regards,<br>&gt; <br>&gt; Loïc<br>&gt; <br>&gt;&gt; On Jan 6, 2016, at 6:34 PM, Don Wills via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; [soapbox]<br>&gt;&gt; <br>&gt;&gt; Coming from the perspective of business applications market (Java and C#), I see major problems in moving to Swift.  It&#39;s simple too different.  The String class is a disaster.  Optionals present a giant spider web of interconnectedness and syntax idiosyncrasy that does not provide any real advantage compared with Java/C#.  The fact that Ints, etc. are not really primitives (unwrapping is required, sometimes explicit, sometimes implicit) is a major dislocation for those coming from all C-syntax-based languages.  The lack of non-checked exceptions (that is exceptions not declared with a throws clause on the func def) is problem.  The lack of packages and/or namespaces is another giant gaping hole.<br>&gt;&gt; <br>&gt;&gt; I had high hopes when I first looked into Swift.  Those hopes have been dashed, and I don&#39;t see anything in my limited view of the plans for Swift 3.0 that addresses any of these concerns or several others that I did not mention.<br>&gt;&gt; <br>&gt;&gt; [/soapbox]<br>&gt;&gt; <br>&gt;&gt; Don Wills<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 6, 2016, at 10:15 AM, Dru Satori via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There is a huge potential here. The weakness, today at least, is that with Swift 2.0, there remain some difficulties in terms of being dependent upon reaching out to Objective C to accomplish some tasks. Looking at what is coming with Swift 3.0, and the work done on the Linux port, I think there is a clear roadmap that makes many of these issues go away, but right now, today, I think it is a tough sell into the edu market.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 1/6/16, 1:42 AM, &quot;swift-users-bounces at swift.org on behalf of Donald Pinckney via swift-users&quot; &lt;swift-users-bounces at swift.org on behalf of swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt;&gt; Personally, I love Swift, and I am curious to see if it will be used in educational settings, not necessarily even CS education.  As something of an experiment to see how Swift could currently look in education, I coded a Swift playground (sorry, very Mac specific right now!) that is a rewriting of a lab activity we did in my 3rd quarter of physics.  For those who are interested in educational aspects of Swift, and have a Mac to run this code, feel free to check out my attached playground, and give any sort of feedback, with respect to either the code or more philosophically where you think Swift could go with education.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt; Donald Pinckney<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt; swift-users at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>&quot;business applications market&quot; flame</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>January  6, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 6, 2016, at 9:34 AM, Don Wills via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Coming from the perspective of business applications market (Java and C#), I see major problems in moving to Swift.<br></p><p>Did you intend to hijack an unrelated thread instead of starting your own? If so, that’s bad netiquette. I’ve retitled the reply for you, to hopefully split off this thread.<br></p><p>&gt; The String class is a disaster.  <br></p><p>Flaming: Again, bad netiquette. How about offering some concrete examples of what you dislike about strings? (Bonus points for showing that you understand Unicode and aren’t just pining for an outdated array-of-UTF16 model like Java&#39;s.)<br></p><p>&gt; Optionals present a giant spider web of interconnectedness and syntax idiosyncrasy that does not provide any real advantage compared with Java/C#.  <br></p><p>How about “no more NullPointerExceptions?” And again, “no real advantage” is just opinion with nothing behind it. Optionals have a long history in functional languages and a lot of users of said languages who feel that they’re beneficial.<br></p><p>&gt; The fact that Ints, etc. are not really primitives (unwrapping is required, sometimes explicit, sometimes implicit) is a major dislocation for those coming from all C-syntax-based languages.  <br></p><p>Integers are primitives. More so than in Java, C# or other “managed” languages, since Swift compiles directly to machine code.<br></p><p>&gt; The lack of non-checked exceptions (that is exceptions not declared with a throws clause on the func def) is problem.  <br></p><p>Swift doesn’t have exceptions at all; its error handling is fundamentally different, despite reusing some common names like “throw”. I suspect you haven’t really understood how error handling in Swift works, since “non-checked” isn’t an attribute that has any meaning in Swift’s model.<br></p><p>&gt; The lack of packages and/or namespaces is another giant gaping hole.<br></p><p>I agree with this, but I think it’s something that’s going to be addressed in the future (see the current work on the package manager.)<br></p><p>—Jens<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d258a22a520c13772442666364207fa?s=50"></div><header><strong>&quot;business applications market&quot; flame</strong> from <string>Don Wills</string> &lt;don.wills at portablesoftware.com&gt;<p>January  6, 2016 at 11:00:00am</p></header><div class="content"><p>Points well taken.<br></p><p>&gt; On Jan 6, 2016, at 11:02 AM, Jens Alfke &lt;jens at mooseyard.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 6, 2016, at 9:34 AM, Don Wills via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Coming from the perspective of business applications market (Java and C#), I see major problems in moving to Swift.<br>&gt; <br>&gt; Did you intend to hijack an unrelated thread instead of starting your own? If so, that’s bad netiquette. I’ve retitled the reply for you, to hopefully split off this thread.<br>&gt; <br>&gt;&gt; The String class is a disaster.  <br>&gt; <br>&gt; Flaming: Again, bad netiquette. How about offering some concrete examples of what you dislike about strings? (Bonus points for showing that you understand Unicode and aren’t just pining for an outdated array-of-UTF16 model like Java&#39;s.)<br></p><p>I didn&#39;t want to post a tome about String, but here&#39;s a basic list of features/methods missing in String:<br></p><p>1. The lack a Character type that are the constituent elements of a String<br>2. Missing methods (Java names used):  valueOf, charAt, trim(), length(), getBytes(), toUpperCase(), toLowerCase()<br>3. The lack of the + operator for appending<br>4. The lack of a StringBuilder (Java again) class<br></p><p>&gt; <br>&gt;&gt; Optionals present a giant spider web of interconnectedness and syntax idiosyncrasy that does not provide any real advantage compared with Java/C#.  <br>&gt; <br>&gt; How about “no more NullPointerExceptions?” And again, “no real advantage” is just opinion with nothing behind it. Optionals have a long history in functional languages and a lot of users of said languages who feel that they’re beneficial.<br></p><p>The cost of !, ? and ?? everywhere in the language is a huge coding and maintenance inconvenience for the programmer error condition referencing a variable that contains the value null.<br></p><p>&gt; <br>&gt;&gt; The fact that Ints, etc. are not really primitives (unwrapping is required, sometimes explicit, sometimes implicit) is a major dislocation for those coming from all C-syntax-based languages.  <br>&gt; <br>&gt; Integers are primitives. More so than in Java, C# or other “managed” languages, since Swift compiles directly to machine code.<br></p><p>The fact that you claim Ints are primitives and Loïc Lecrenier in an email three minutes prior writes &quot;Swift does not have primitives, but I consider that a plus...&quot;  Which is it?<br></p><p>In addition, memory management (your reference to &quot;language management&quot;) has nothing to do with whether or not integers are primitives.  In Java, &quot;int&quot; is a primitive and &quot;Integer&quot; is not.<br></p><p>&gt; <br>&gt;&gt; The lack of non-checked exceptions (that is exceptions not declared with a throws clause on the func def) is problem.  <br>&gt; <br>&gt; Swift doesn’t have exceptions at all; its error handling is fundamentally different, despite reusing some common names like “throw”. I suspect you haven’t really understood how error handling in Swift works, since “non-checked” isn’t an attribute that has any meaning in Swift’s model.<br></p><p>Swift doesn&#39;t have exceptions?  What are the &quot;throws&quot; clause on funcs and the try and throw statements?<br></p><p>&gt;&gt; The lack of packages and/or namespaces is another giant gaping hole.<br>&gt; <br>&gt; I agree with this, but I think it’s something that’s going to be addressed in the future (see the current work on the package manager.)<br>&gt; <br>&gt; —Jens<br></p><p>I come from the perspective of 45 years of experience in dozens of programming languages.  Swift seems to be trying to be everything to everybody - a bridge from Obj-C, functional, imperative, procedural, object-oriented with a somewhat Java and C-like syntax.  I&#39;ve seen this movie before - it was called PL/I and was the IBM answer to merging COBOL and FORTRAN.  Survivors:  COBOL and FORTRAN.  It appears to me that Swift is today&#39;s PL/I.<br></p><p>Don<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>&quot;business applications market&quot; flame</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>January  6, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 6, 2016, at 10:30 AM, Don Wills &lt;don.wills at portablesoftware.com&gt; wrote:<br>&gt; <br>&gt; 1. The lack a Character type that are the constituent elements of a String<br>&gt; 2. Missing methods (Java names used):  valueOf, charAt, trim(), length(),<br></p><p>No offense, but it sounds like you haven’t read the justifications in the Swift book or on the web. The short form: Unicode is complicated, necessarily so because human writing is complicated. Even the notion of a “character” is problematic. To quote from objc.io&#39;s (prerelease) Advanced Swift book: &quot;But even when encoded using 32-bit code units, what a user might consider &#39;a single character&#39; — as displayed on the screen — might require multiple code points composed together. Most string manipulation code exhibits a certain level of denial about Unicode’s variable-width nature. This can lead to some unpleasant bugs.”<br></p><p>charAt isn’t available because a String is not just a simple “array of characters” as in older / more simplistic languages. Ditto with length.<br>valueOf IIRC is for converting to/from integers — there are methods on the integer types for that.<br>trim is one of those methods that is supplied in the Foundation framework, which hasn’t been ported to a Swift-native version yet so isn’t available outside Apple platforms.<br></p><p>&gt; getBytes(), toUpperCase(), toLowerCase()<br></p><p>getBytes is basically a UTF-8 view.<br>Upper/lowercase conversions are again part of Foundation.<br></p><p>&gt; 3. The lack of the + operator for appending<br></p><p>You can add this in a couple of lines of code if it’s important to you.<br></p><p>&gt; 4. The lack of a StringBuilder (Java again) class<br></p><p>Apples and oranges. Java needs StringBuilder/StringBuffer because its String is always immutable. In Swift mutability is an aspect of the variable containing the String, so the String class itself contains mutating methods.<br></p><p>—Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160106/9355abaf/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be09ed656d5d90501c958b001261f218?s=50"></div><header><strong>&quot;business applications market&quot; flame</strong> from <string>Jeremy Pereira</string> &lt;jeremy.j.pereira at googlemail.com&gt;<p>January  6, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On 6 Jan 2016, at 18:30, Don Wills via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Points well taken.<br>&gt; <br>&gt;&gt; On Jan 6, 2016, at 11:02 AM, Jens Alfke &lt;jens at mooseyard.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; I didn&#39;t want to post a tome about String, but here&#39;s a basic list of features/methods missing in String:<br>&gt; <br>&gt; 1. The lack a Character type that are the constituent elements of a String<br>&gt; 2. Missing methods (Java names used):  valueOf, charAt, trim(), length(), getBytes(), toUpperCase(), toLowerCase()<br>&gt; 3. The lack of the + operator for appending<br>&gt; 4. The lack of a StringBuilder (Java again) class<br></p><p>In Swift, String is intended to be Unicode correct. This means that the concept of “character” is actually quite complex. It’s impossible to define charAt and length without doing a linear search through the string.<br></p><p>getBytes() in Java is a disaster, although the variants where you specify an explicit character set are fine and for UTF8 and UTF16 have an explicit equivalent in Swift e.g.<br></p><p>let foo = Array(&quot;föo&quot;.utf8) // Array of UInt8 [102, 195, 182, 111]<br></p><p>valueOf() is covered by string interpolation e.g.<br></p><p>let number = “\(myDoubleVariable)”<br></p><p>trim() and toWhateverCase() are missing but are discriminatory to non latin alphabets.<br></p><p>The + operator does exist for strings and StringBuilder is unnecessary because a var string can be mutated.<br></p><p>var foo = “gfds”<br>foo += “fgfd&quot;<br></p><p>Oh look += works for strings too.<br></p><p>&gt; <br>&gt; <br>&gt; The cost of !, ? and ?? everywhere in the language is a huge coding and maintenance inconvenience for the programmer error condition referencing a variable that contains the value null.<br></p><p>Actually, I think the optional syntax is great. It forces you to think about and deal with the equivalent of null pointers. Or put it this way, if Java programmers were forced to handle all the possible cases where they might have a null pointer instead of sweeping it under the carpet as they do, the maintenance overhead and inconvenience would be far worse than with Swift. Swift provides compiler support for answering the question “could this value be nil”. Java doesn’t, which probably explains why the logs of many large Java systems frequently contain stack dumps from null pointer exceptions.<br></p><p>&gt; <br>&gt; <br>&gt; The fact that you claim Ints are primitives and Loïc Lecrenier in an email three minutes prior writes &quot;Swift does not have primitives, but I consider that a plus...&quot;  Which is it?<br></p><p>The concept of “primitive” has no meaning in Swift. In Swift, there are value types and reference types and user defined types and “built in” types are of equal rank. Clever compiler optimisation allows some types to compile down to CPU native types, but that is an implementation detail.<br></p><p>&gt; <br>&gt; Swift doesn&#39;t have exceptions?  What are the &quot;throws&quot; clause on funcs and the try and throw statements?<br></p><p>In Swift, you throw errors, not exceptions. The word exception is (more or less) reserved for conditions that terminate the process. <br></p><p>There are no unchecked errors but then why would you not want to handle an error condition if it occurs? Why would you not want to know that an API can throw an error?<br></p><p>I think Java’s checked exceptions are fine, but it really should not be possible to catch an unchecked exception.<br></p><p>&gt; <br>&gt;&gt;&gt; The lack of packages and/or namespaces is another giant gaping hole.<br>&gt;&gt; <br>&gt;&gt; I agree with this, but I think it’s something that’s going to be addressed in the future (see the current work on the package manager.)<br>&gt;&gt; <br>&gt;&gt; —Jens<br>&gt; <br>&gt; I come from the perspective of 45 years of experience in dozens of programming languages.  Swift seems to be trying to be everything to everybody - a bridge from Obj-C, functional, imperative, procedural, object-oriented with a somewhat Java and C-like syntax.  I&#39;ve seen this movie before - it was called PL/I and was the IBM answer to merging COBOL and FORTRAN.  Survivors:  COBOL and FORTRAN.  It appears to me that Swift is today&#39;s PL/I.<br></p><p>Having programmed in it quite a bit (a statement that, with respect, I think does not apply to you) I can tell you that it is a joy to use. I love the fact that I can pick the programming paradigm that is best suited to the problem I am trying to solve. Furthermore, it has the advantage of being the language of choice for the most successful mobile platform in terms of actual money. Now that the toolchain is open source, I can only see its sphere of influence expanding. <br></p><p><br>&gt; <br>&gt; Don<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>&quot;business applications market&quot; flame</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>January  6, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jan 6, 2016, at 11:40 AM, Jeremy Pereira via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; In Swift, you throw errors, not exceptions. The word exception is (more or less) reserved for conditions that terminate the process. <br>&gt; <br>&gt; There are no unchecked errors but then why would you not want to handle an error condition if it occurs? Why would you not want to know that an API can throw an error?<br></p><p>The bigger point is that in Swift you always know at the call site whether something can fail. That is, you can see the possible flows of control by inspecting the code. <br></p><p>Consider this block of code:<br>	{ foo(); bar(); endFoo(); }<br>If foo is called, will endFoo() also be called? <br></p><p>In C++/Java/C# it’s not possible to tell without doing extensive analysis of the implementation of bar (and everything that bar calls), because bar might throw an exception and derail this flow of control. (And worse, some later code change far away might add an unchecked exception, making your analysis wrong!) This then requires adding noise in the form of a ‘finally’ block or a helper class implementing RAII, if it’s really important that endFoo be called. In a lot of cases this is “too much trouble” so a lot of code gets left like above, and will break some invariant if the endFoo call gets skipped.<br></p><p>In Swift you can be sure that, if this block is entered, all three functions will be called. (Unless the process hits a fatal exception like an assertion failure or bus error and exits.) If it’s possible for bar to fail, then<br>(a) the call to bar will have to be prefixed with ‘try’, which is a yellow flag to the programmer noting the possibility*; and<br>(b) the block will have to be inside a `do … catch` block, in the same function, to handle the error. An error in bar() can’t just abort the function silently. Any cleanup that has to be done will be explicit.<br></p><p>—Jens<br></p><p>* The requirement of the ‘try’ prefix means that if a function that isn’t failable later gets modified to be failable, every call site will now trigger a compile error due to the missing ‘try’ keyword. This means the programmer who made the change will have to go through the codebase and consider the possibility of failure and adjust the call site accordingly. This is a really good thing!<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160106/aa8462c7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d258a22a520c13772442666364207fa?s=50"></div><header><strong>&quot;business applications market&quot; flame</strong> from <string>Don Wills</string> &lt;don.wills at portablesoftware.com&gt;<p>January  6, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jan 6, 2016, at 1:15 PM, Jens Alfke &lt;jens at mooseyard.com&gt; wrote:<br>&gt; <br>&gt; * The requirement of the ‘try’ prefix means that if a function that isn’t failable later gets modified to be failable, every call site will now trigger a compile error due to the missing ‘try’ keyword. This means the programmer who made the change will have to go through the codebase and consider the possibility of failure and adjust the call site accordingly. This is a really good thing!<br></p><p>It also means that every third party API provider will *never* be able to change any method signature from failable to non-failable or vice-versa.  That is a really bad thing!  This concern is why Microsoft rightly chose to have *only* non-checked exceptions in C# (Java has both checked and non-checked).<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>&quot;business applications market&quot; flame</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>January  6, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jan 6, 2016, at 1:12 PM, Don Wills via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 6, 2016, at 1:15 PM, Jens Alfke &lt;jens at mooseyard.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; * The requirement of the ‘try’ prefix means that if a function that isn’t failable later gets modified to be failable, every call site will now trigger a compile error due to the missing ‘try’ keyword. This means the programmer who made the change will have to go through the codebase and consider the possibility of failure and adjust the call site accordingly. This is a really good thing!<br>&gt; <br>&gt; It also means that every third party API provider will *never* be able to change any method signature from failable to non-failable or vice-versa.  That is a really bad thing!  This concern is why Microsoft rightly chose to have *only* non-checked exceptions in C# (Java has both checked and non-checked).<br></p><p>Swift&#39;s error system does put some burden on careful API design. The API author does need to choose &quot;throwing&quot; vs &quot;not throwing&quot; correctly up front.<br></p><p>On the other hand, the API author does not need to predict *which* errors might be thrown in the future. That avoids most of the difficulty for most API.<br></p><p>The API author&#39;s loss is the API client&#39;s gain. For anything that does not throw, the API client does not need to defensively assume that everything could throw in the future. This is good because writing exception-safe code is hard, especially if you can&#39;t test it.<br></p><p>We decided this was the right distribution of pain. The API author needs to plan ahead a little bit (but not as much as in a pure checked-exception system). The API client is safe almost everywhere against the threat of unusual control flow, and the presence of unusual control flow is always marked `try` when it is necessary.<br></p><p><br>-- <br>Greg Parker     gparker at apple.com     Runtime Wrangler<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d258a22a520c13772442666364207fa?s=50"></div><header><strong>Optionals and method overloading with Any</strong> from <string>Don Wills</string> &lt;don.wills at portablesoftware.com&gt;<p>January  6, 2016 at 08:00:00pm</p></header><div class="content"><p>I really don&#39;t understand optionals.  This code fails with &quot;Call can throw, but is not marked with try ...&quot; on the program line:    t1.mth(&quot;abc&quot;, s1);<br></p><p>class Test {<br>	private var s1 : String!<br></p><p>	func tst() {<br>		let t1 : Test1 = Test1()<br>		t1.mth(&quot;abc&quot;, s1)<br>	}<br>}<br></p><p>class Test1 {<br>	func mth(p1 : String, _ p2 : String) -&gt; String {<br>		return p1<br>	}<br></p><p>	func mth(p1 : String, _ p2 : Any) throws -&gt; String {<br>		return p1<br>	}<br>}<br></p><p>but the program compiles fine if I change the code in either of these two manners:<br></p><p>1. I define s1 as non-optional like this:  private var s1 = &quot;&quot;, or<br></p><p>2. I remove the second overloaded mth method (the one with &quot;_ p2 : Any&quot; as the second parameter and the throws clause)<br></p><p>Swift method lookup obviously chose the second mth func if it exists, but why?<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Optionals and method overloading with Any</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January  6, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Jan 6, 2016, at 7:16 PM, Don Wills via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; I really don&#39;t understand optionals.  This code fails with &quot;Call can throw, but is not marked with try ...&quot; on the program line:    t1.mth(&quot;abc&quot;, s1);<br>&gt; <br>&gt; class Test {<br>&gt; 	private var s1 : String!<br>&gt; <br>&gt; 	func tst() {<br>&gt; 		let t1 : Test1 = Test1()<br>&gt; 		t1.mth(&quot;abc&quot;, s1)<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; class Test1 {<br>&gt; 	func mth(p1 : String, _ p2 : String) -&gt; String {<br>&gt; 		return p1<br>&gt; 	}<br>&gt; <br>&gt; 	func mth(p1 : String, _ p2 : Any) throws -&gt; String {<br>&gt; 		return p1<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; but the program compiles fine if I change the code in either of these two manners:<br>&gt; <br>&gt; 1. I define s1 as non-optional like this:  private var s1 = &quot;&quot;, or<br>&gt; <br>&gt; 2. I remove the second overloaded mth method (the one with &quot;_ p2 : Any&quot; as the second parameter and the throws clause)<br>&gt; <br>&gt; Swift method lookup obviously chose the second mth func if it exists, but why?<br></p><p>Seems like a bug to me. I&#39;d expect overload resolution to favor the (String, String) overload over the Any overload even if using an implicitly-unwrapped optional like this.<br></p><p>-Joe<br></p><p>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>Optionals and method overloading with Any</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>January  6, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jan 6, 2016, at 7:16 PM, Don Wills via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Swift method lookup obviously chose the second mth func if it exists, but why?<br></p><p>From the behavior here, it looks like the compiler is first looking for a matching method, then if it can’t find one it unwraps the optional parameter and looks for a match again. So in this case it immediately finds a match (the second mth) and doesn’t try unwrapping the String! parameter.<br></p><p>I have no idea whether that’s correct/intentional behavior, or a bug. I do know that function overloading can create weird situations in any language that supports it (notably C++), so I’m not surprised that there are some edge cases in Swift too.<br></p><p>&gt; I really don&#39;t understand optionals.<br></p><p>Well, think of the declaration of s1 as being<br>	private var s1 : Optional&lt;String&gt;<br>which is what it actually is under the hood. That makes it pretty clear that the 2nd mth method is the one that will get called. The confusion comes in when you also consider that the compiler will implicitly deref an Optional&lt;String&gt; to String if it’s been declared using “!”, in which case the first mth can be called. Now it’s sort of ambiguous which is preferable.<br></p><p>—Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160106/4b398ed0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be09ed656d5d90501c958b001261f218?s=50"></div><header><strong>Optionals and method overloading with Any</strong> from <string>Jeremy Pereira</string> &lt;jeremy.j.pereira at googlemail.com&gt;<p>January  7, 2016 at 04:00:00pm</p></header><div class="content"><p>I think it’s a bug.<br></p><p>This (in which s1 is explicitly unwrapped instead of implicitly unwrapped)<br></p><p>class Test {<br>    private var s1 : String?<br></p><p>    func tst() {<br>        let t1 : Test1 = Test1()<br>        t1.mth(&quot;abc&quot;, s1!)<br>    }<br>}<br></p><p>compiles just fine and should be equivalent to Don’s original code in which s1 is optional but implicitly unwrapped.<br></p><p>I think you should raise a bug, Don.<br></p><p><br>&gt; On 7 Jan 2016, at 04:53, Jens Alfke via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 6, 2016, at 7:16 PM, Don Wills via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Swift method lookup obviously chose the second mth func if it exists, but why?<br>&gt; <br>&gt; From the behavior here, it looks like the compiler is first looking for a matching method, then if it can’t find one it unwraps the optional parameter and looks for a match again. So in this case it immediately finds a match (the second mth) and doesn’t try unwrapping the String! parameter.<br>&gt; <br>&gt; I have no idea whether that’s correct/intentional behavior, or a bug. I do know that function overloading can create weird situations in any language that supports it (notably C++), so I’m not surprised that there are some edge cases in Swift too.<br>&gt; <br>&gt;&gt; I really don&#39;t understand optionals.<br>&gt; <br>&gt; Well, think of the declaration of s1 as being<br>&gt; 	private var s1 : Optional&lt;String&gt;<br>&gt; which is what it actually is under the hood. That makes it pretty clear that the 2nd mth method is the one that will get called. The confusion comes in when you also consider that the compiler will implicitly deref an Optional&lt;String&gt; to String if it’s been declared using “!”, in which case the first mth can be called. Now it’s sort of ambiguous which is preferable.<br>&gt; <br>&gt; —Jens<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d258a22a520c13772442666364207fa?s=50"></div><header><strong>Optionals and method overloading with Any</strong> from <string>Don Wills</string> &lt;don.wills at portablesoftware.com&gt;<p>January  7, 2016 at 10:00:00am</p></header><div class="content"><p>OK, I&#39;ll raise a bug.  But it brings up a bigger question - what are the rules for overloading method resolution in the context of optionals?  Is that a separate bug, or just a documentation issue?<br></p><p>&gt; On Jan 7, 2016, at 9:59 AM, Jeremy Pereira &lt;jeremy.j.pereira at googlemail.com&gt; wrote:<br>&gt; <br>&gt; I think it’s a bug.<br>&gt; <br>&gt; This (in which s1 is explicitly unwrapped instead of implicitly unwrapped)<br>&gt; <br>&gt; class Test {<br>&gt;    private var s1 : String?<br>&gt; <br>&gt;    func tst() {<br>&gt;        let t1 : Test1 = Test1()<br>&gt;        t1.mth(&quot;abc&quot;, s1!)<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; compiles just fine and should be equivalent to Don’s original code in which s1 is optional but implicitly unwrapped.<br>&gt; <br>&gt; I think you should raise a bug, Don.<br>&gt; <br>&gt; <br>&gt;&gt; On 7 Jan 2016, at 04:53, Jens Alfke via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 6, 2016, at 7:16 PM, Don Wills via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift method lookup obviously chose the second mth func if it exists, but why?<br>&gt;&gt; <br>&gt;&gt; From the behavior here, it looks like the compiler is first looking for a matching method, then if it can’t find one it unwraps the optional parameter and looks for a match again. So in this case it immediately finds a match (the second mth) and doesn’t try unwrapping the String! parameter.<br>&gt;&gt; <br>&gt;&gt; I have no idea whether that’s correct/intentional behavior, or a bug. I do know that function overloading can create weird situations in any language that supports it (notably C++), so I’m not surprised that there are some edge cases in Swift too.<br>&gt;&gt; <br>&gt;&gt;&gt; I really don&#39;t understand optionals.<br>&gt;&gt; <br>&gt;&gt; Well, think of the declaration of s1 as being<br>&gt;&gt; 	private var s1 : Optional&lt;String&gt;<br>&gt;&gt; which is what it actually is under the hood. That makes it pretty clear that the 2nd mth method is the one that will get called. The confusion comes in when you also consider that the compiler will implicitly deref an Optional&lt;String&gt; to String if it’s been declared using “!”, in which case the first mth can be called. Now it’s sort of ambiguous which is preferable.<br>&gt;&gt; <br>&gt;&gt; —Jens<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Optionals and method overloading with Any</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January  7, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jan 7, 2016, at 9:12 AM, Don Wills via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; OK, I&#39;ll raise a bug.  But it brings up a bigger question - what are the rules for overloading method resolution in the context of optionals?  Is that a separate bug, or just a documentation issue?<br></p><p>When you use an implicitly-unwrapped optional type like String! here, it can implicitly convert to String, or it can convert to a supertype such as Any. When more than one conversion is possible, the type checker currently always scores the String! to String conversion lower than other conversions, since it would rather perform a safe upcast than a potentially-trapping String! to String conversion, leading to the behavior you&#39;re seeing now.<br></p><p>We plan to rework how T! types work soon in order to make their behavior more predictable. I think the plan is to make expressions involving T! always immediately convert to T unless they&#39;re in an immediately Optional context, which would give you the behavior you expect in this case. cc&#39;ing Joe Pamer, who&#39;s working on the design here.<br></p><p>-Joe<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>&quot;business applications market&quot; flame</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January  6, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jan 6, 2016, at 1:12 PM, Don Wills via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 6, 2016, at 1:15 PM, Jens Alfke &lt;jens at mooseyard.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; * The requirement of the ‘try’ prefix means that if a function that isn’t failable later gets modified to be failable, every call site will now trigger a compile error due to the missing ‘try’ keyword. This means the programmer who made the change will have to go through the codebase and consider the possibility of failure and adjust the call site accordingly. This is a really good thing!<br>&gt; <br>&gt; It also means that every third party API provider will *never* be able to change any method signature from failable to non-failable or vice-versa.  That is a really bad thing!  This concern is why Microsoft rightly chose to have *only* non-checked exceptions in C# (Java has both checked and non-checked).<br></p><p>You can resiliently go from failable to not failable just fine without recompiling code; the compiler will warn about redundant try&#39;s, but it isn&#39;t an error, and the try keywords can be cleaned up easily. Introducing failability to non-failable APIs fundamentally requires all of your users to now audit their code for error safety; some languages choose not to let the compiler help you with this. Note that unlike Java, we intentionally don&#39;t restrict errors to a particular type, so you can introduce new failure modes without breaking your API.<br></p><p>-Joe<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>&quot;business applications market&quot; flame</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>January  6, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jan 6, 2016, at 1:12 PM, Don Wills &lt;don.wills at portablesoftware.com&gt; wrote:<br>&gt; <br>&gt; It also means that every third party API provider will *never* be able to change any method signature from failable to non-failable or vice-versa.  That is a really bad thing!<br></p><p>API consistency is a good thing. A method that can fail is fundamentally different than the same method without failure — it’s comparable to adding another return value, or an ‘out’ parameter, both of which we would expect to be a breaking API change. Sneaking in unchecked exceptions is like saying “oh yeah, starting in version 3.5, calling this method might suddenly abort your flow of control and take you to back the nearest catch block, even though you didn’t think it could do that. I hope that’s not a problem.” (Reminds me of the way PHP introduces catastrophic API behavior changes under the hood in minor releases…)<br></p><p>If you do end up needing to add errors to an API method, you can do it by adding a new variant of the method that throws, deprecating the old version, and then removing the old one once clients have migrated.<br></p><p>—Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160106/ac1b2574/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be09ed656d5d90501c958b001261f218?s=50"></div><header><strong>&quot;business applications market&quot; flame</strong> from <string>Jeremy Pereira</string> &lt;jeremy.j.pereira at googlemail.com&gt;<p>January  7, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On 6 Jan 2016, at 21:12, Don Wills via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 6, 2016, at 1:15 PM, Jens Alfke &lt;jens at mooseyard.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; * The requirement of the ‘try’ prefix means that if a function that isn’t failable later gets modified to be failable, every call site will now trigger a compile error due to the missing ‘try’ keyword. This means the programmer who made the change will have to go through the codebase and consider the possibility of failure and adjust the call site accordingly. This is a really good thing!<br>&gt; <br>&gt; It also means that every third party API provider will *never* be able to change any method signature from failable to non-failable or vice-versa.  That is a really bad thing!  This concern is why Microsoft rightly chose to have *only* non-checked exceptions in C# (Java has both checked and non-checked).<br></p><p>An API is a contract between the caller and callee. If you change it from non failable to failable, you are breaking the contract and likely introducing bugs into the code that calls it. As a consumer of your API, I absolutely do need to know if it has been changed to throw an error/exception just as much as I need to know if you add or remove parameters or change the return type.<br></p><p>The C# approach is brain dead in that, I have to assume every API can throw and put the error handling boiler plate in everywhere and the temptation is to ignore it. I think the Swift approach provides a much better balance.<br></p><p><br></p><p>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be09ed656d5d90501c958b001261f218?s=50"></div><header><strong>&quot;business applications market&quot; flame</strong> from <string>Jeremy Pereira</string> &lt;jeremy.j.pereira at googlemail.com&gt;<p>January  7, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On 6 Jan 2016, at 20:15, Jens Alfke &lt;jens at mooseyard.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 6, 2016, at 11:40 AM, Jeremy Pereira via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; In Swift, you throw errors, not exceptions. The word exception is (more or less) reserved for conditions that terminate the process. <br>&gt;&gt; <br>&gt;&gt; There are no unchecked errors but then why would you not want to handle an error condition if it occurs? Why would you not want to know that an API can throw an error?<br>&gt; <br>&gt; The bigger point is that in Swift you always know at the call site whether something can fail. That is, you can see the possible flows of control by inspecting the code. <br></p><p>Absolutely and I think this is critical to successfully handling errors. In Java, there is compiler support for telling if a checked exception can happen at the call site (although you can’t tell just by looking at the line of code), but the callee can also throw a RuntimeException which is ignored by the compiler but can be caught if you want to catch it. This is a recipe for disaster much like propagating an Objective-C exception through a stack frame that is not exception safe. You cannot safely catch a RuntimeException because you do not know if functions higher up the chain properly cleaned up after themselves.<br></p><p>&gt; <br>&gt; Consider this block of code:<br>&gt; 	{ foo(); bar(); endFoo(); }<br>&gt; If foo is called, will endFoo() also be called? <br>&gt; <br>&gt; In C++/Java/C# it’s not possible to tell without doing extensive analysis of the implementation of bar (and everything that bar calls), <br>&gt; because bar might throw an exception and derail this flow of control. (And worse, some later code change far away might add an unchecked exception, making your analysis wrong!) This then requires adding noise in the form of a ‘finally’ block or a helper class implementing RAII, if it’s really important that endFoo be called. In a lot of cases this is “too much trouble” so a lot of code gets left like above, and will break some invariant if the endFoo call gets skipped.<br></p><p>+1 million for the “too much trouble” bit. I’ve even seen Java libraries where the rule was that all exceptions have to be RuntimeExceptions so that the caller doesn’t have to bother with error checking. It’s a disaster.<br></p><p>&gt; <br>&gt; * The requirement of the ‘try’ prefix means that if a function that isn’t failable later gets modified to be failable, every call site will now trigger a compile error due to the missing ‘try’ keyword. This means the programmer who made the change will have to go through the codebase and consider the possibility of failure and adjust the call site accordingly. This is a really good thing!<br></p><p>You are preaching to the choir.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d258a22a520c13772442666364207fa?s=50"></div><header><strong>&quot;business applications market&quot; flame</strong> from <string>Don Wills</string> &lt;don.wills at portablesoftware.com&gt;<p>January  7, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jan 7, 2016, at 2:45 AM, Jeremy Pereira &lt;jeremy.j.pereira at googlemail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 6 Jan 2016, at 20:15, Jens Alfke &lt;jens at mooseyard.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 6, 2016, at 11:40 AM, Jeremy Pereira via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In Swift, you throw errors, not exceptions. The word exception is (more or less) reserved for conditions that terminate the process. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are no unchecked errors but then why would you not want to handle an error condition if it occurs? Why would you not want to know that an API can throw an error?<br>&gt;&gt; <br>&gt;&gt; The bigger point is that in Swift you always know at the call site whether something can fail. That is, you can see the possible flows of control by inspecting the code. <br>&gt; <br>&gt; Absolutely and I think this is critical to successfully handling errors. In Java, there is compiler support for telling if a checked exception can happen at the call site (although you can’t tell just by looking at the line of code), but the callee can also throw a RuntimeException which is ignored by the compiler but can be caught if you want to catch it. This is a recipe for disaster much like propagating an Objective-C exception through a stack frame that is not exception safe. You cannot safely catch a RuntimeException because you do not know if functions higher up the chain properly cleaned up after themselves.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Consider this block of code:<br>&gt;&gt; 	{ foo(); bar(); endFoo(); }<br>&gt;&gt; If foo is called, will endFoo() also be called? <br>&gt;&gt; <br>&gt;&gt; In C++/Java/C# it’s not possible to tell without doing extensive analysis of the implementation of bar (and everything that bar calls), <br>&gt;&gt; because bar might throw an exception and derail this flow of control. (And worse, some later code change far away might add an unchecked exception, making your analysis wrong!) This then requires adding noise in the form of a ‘finally’ block or a helper class implementing RAII, if it’s really important that endFoo be called. In a lot of cases this is “too much trouble” so a lot of code gets left like above, and will break some invariant if the endFoo call gets skipped.<br>&gt; <br>&gt; +1 million for the “too much trouble” bit. I’ve even seen Java libraries where the rule was that all exceptions have to be RuntimeExceptions so that the caller doesn’t have to bother with error checking. It’s a disaster.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; * The requirement of the ‘try’ prefix means that if a function that isn’t failable later gets modified to be failable, every call site will now trigger a compile error due to the missing ‘try’ keyword. This means the programmer who made the change will have to go through the codebase and consider the possibility of failure and adjust the call site accordingly. This is a really good thing!<br>&gt; <br>&gt; You are preaching to the choir.<br></p><p>Not this singer.  Given the antipathy from posters here to unchecked exceptions, it seems amazing to me that C# has been successful at all, since unchecked exceptions are the only type available.  IMO, Java has it right - let the API designer decide which approach to take.  The Swift designers attitude of &quot;we know best, do it the way we tell you&quot; will not play well with many programmers.  An example of that coming in Swift 3 is the removal of pre and post increment and decrement operators.  And yes, C++ is a horrible language.  I&#39;m with Linus on that.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>&quot;business applications market&quot; flame</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>January  7, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jan 7, 2016, at 8:37 AM, Don Wills via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; IMO, Java has it right - let the API designer decide which approach to take.  <br></p><p>One more time: Swift does not have exceptions at all (checked or not). You are comparing apples and oranges here, based on a surface similarity in syntax (keywords like “try” and “catch”), which indicates you haven’t paid attention to what the actual semantics are. If you want to make credible arguments about error handling, you’ll need a better understanding of it.<br></p><p>I note that Go — a language you profess to like a lot — has no exceptions either, and its error handling support is much more primitive and clumsy to use than Swift’s. (I say this having spent about a man-year coding in Go.)<br></p><p>&gt; The Swift designers attitude of &quot;we know best, do it the way we tell you&quot; will not play well with many programmers.  <br></p><p>Go is pretty much the ultimate in that philosophy — Rob Pike and others are very up-front that they know what features are best and they will decide the right way to do things and if you disagree you are wrong. (Pike’s blog post about error handling from about a year ago is a great example of this arrogance.) I see the Swift developers being a lot more open about this, instituting a very open process for proposing and debating changes.<br></p><p>—Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160107/d86a9d6c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d258a22a520c13772442666364207fa?s=50"></div><header><strong>&quot;business applications market&quot; flame</strong> from <string>Don Wills</string> &lt;don.wills at portablesoftware.com&gt;<p>January  7, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 7, 2016, at 10:13 AM, Jens Alfke &lt;jens at mooseyard.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 7, 2016, at 8:37 AM, Don Wills via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; IMO, Java has it right - let the API designer decide which approach to take.  <br>&gt; <br>&gt; One more time: Swift does not have exceptions at all (checked or not). You are comparing apples and oranges here, based on a surface similarity in syntax (keywords like “try” and “catch”), which indicates you haven’t paid attention to what the actual semantics are. If you want to make credible arguments about error handling, you’ll need a better understanding of it.<br>&gt; <br>&gt; I note that Go — a language you profess to like a lot — has no exceptions either, and its error handling support is much more primitive and clumsy to use than Swift’s. (I say this having spent about a man-year coding in Go.)<br>&gt; <br>&gt;&gt; The Swift designers attitude of &quot;we know best, do it the way we tell you&quot; will not play well with many programmers.  <br>&gt; <br>&gt; Go is pretty much the ultimate in that philosophy — Rob Pike and others are very up-front that they know what features are best and they will decide the right way to do things and if you disagree you are wrong. (Pike’s blog post about error handling from about a year ago is a great example of this arrogance.) I see the Swift developers being a lot more open about this, instituting a very open process for proposing and debating changes.<br>&gt; <br>&gt; —Jens<br></p><p>Yes, I recognize that the &quot;my way or the highway&quot; attitude is issue among many language designers today.  But, IMO, the dictators at Go made a few better decisions.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160107/a27f9cda/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>&quot;business applications market&quot; flame</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January  7, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; IMO, Java has it right - let the API designer decide which approach to take.<br></p><p>That&#39;s a frankly laughable misreading of the Java story. The Java story is that they wanted everyone to use checked exceptions, but the users loathed them so much that they found hacks to get around the checked exception system, from subclassing `RuntimeException` or `Error` to labeling everything `throws Exception`. This is hardly a shining model of good language design.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>&quot;business applications market&quot; flame</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>January  7, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jan 7, 2016, at 12:27 PM, Brent Royal-Gordon via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; IMO, Java has it right - let the API designer decide which approach to take.<br>&gt; <br>&gt; That&#39;s a frankly laughable misreading of the Java story. The Java story is that they wanted everyone to use checked exceptions, but the users loathed them so much that they found hacks to get around the checked exception system<br></p><p>+1. Been there, done that :)<br></p><p>Another factor is that in the Java (and C++) environment, nearly anything can fail, since ‘new’ can throw an OutOfMemoryError*, and programmer mistakes like out-of-range array indexes or failed type-casts are treated as theoretically-recoverable exceptions. Therefore nearly any nontrivial method can potentially throw, so having unchecked exceptions is a requirement or else all of those methods would have to be labeled as ‘throws’.<br></p><p>This is in contrast with Swift (and Go) where errors are higher-level — things like I/O errors — while assertion failures will unconditionally abort. This makes program logic a lot easier to follow, since the jumps caused by exceptions are notoriously unintuitive (being a form of invisible goto.)<br></p><p>—Jens<br></p><p>* This was reasonable in the 1990s, but makes little sense in the OSs most of us code for today, on which malloc() will pretty much never return NULL. (Embedded OSs are an exception.)<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160107/d5845faa/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d258a22a520c13772442666364207fa?s=50"></div><header><strong>&quot;business applications market&quot; flame</strong> from <string>Don Wills</string> &lt;don.wills at portablesoftware.com&gt;<p>January  7, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt;&gt; On Jan 7, 2016, at 12:27 PM, Brent Royal-Gordon via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; IMO, Java has it right - let the API designer decide which approach to take.<br>&gt;&gt; <br>&gt;&gt; That&#39;s a frankly laughable misreading of the Java story. The Java story is that they wanted everyone to use checked exceptions, but the users loathed them so much that they found hacks to get around the checked exception system<br></p><p>Do you really believe that you can stop the &quot;users&quot; who &quot;loathed them so much&quot; from doing what they want to do with Swift?  Hubris isn&#39;t a strong enough word to describe that attitude.<br></p><p>FWIW, I&#39;ve already started down the path of dealing with the lack of unchecked &lt;whatever-you-call-em&gt;s by using the following code:<br></p><p>func add(p1: String, _ p2 Any) {<br>    try! addWithThrows(p1, p2)<br>}<br></p><p>private func addWithThrows(p1: String, _ p2 Any) throws {<br>    // code that handles many types for p2, followed by return for each of the valid types<br>    throw Exception(&quot;Invalid type&quot;)  /* for those types not supported which is a programmer error */<br>}<br></p><p>public class Exception: ErrorType {<br>    init() {<br>    }<br>    init(_ msg: String) {<br>    }<br>}<br></p><p>You can laugh all you at my OPINION about Java&#39;s checked and unchecked, but in the end, the great unwashed masses of programmers do whatever they believe is best to build their software, regardless of what programming languages designers believe or try to force upon them.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160107/d288db14/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>&quot;business applications market&quot; flame</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>January  7, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jan 7, 2016, at 2:33 PM, Don Wills &lt;don.wills at portablesoftware.com&gt; wrote:<br>&gt; <br>&gt; Do you really believe that you can stop the &quot;users&quot; who &quot;loathed them so much&quot; from doing what they want to do with Swift?  Hubris isn&#39;t a strong enough word to describe that attitude.<br></p><p>It’s impossible to implement unchecked exceptions in Swift because it lacks any form of stack-unwinding. For example, if A calls B calls C, and B is not marked as ‘throws’, then there is no way for C to return an error back to A. (Unless the error is stored externally, like as an object property, instead of being directly returned.)<br></p><p>&gt; FWIW, I&#39;ve already started down the path of dealing with the lack of unchecked &lt;whatever-you-call-em&gt;s by using the following code:<br></p><p>“try!” isn’t anything like an unchecked exception. It simply ignores the error. It’s the equivalent of the unfortunate Java idiom:<br>	try {<br>		somethingThatMightThrowAnException();<br>	} catch(Exception e) { /* la la la I can’t hear you */ }<br>Back in my Java days I tracked several mysterious bugs down to usage of this idiom. Internally something was failing, but the exception was ignored so there was no indication of the failure. That made it much harder for me to find.<br></p><p>&gt;     throw Exception(&quot;Invalid type&quot;)  /* for those types not supported which is a programmer error */<br></p><p>The correct way to signal a programmer error in Swift is with assert() or fatalError() [sp?]. Which removes your need to use the above workaround, because the method no longer needs to be marked as throws.<br></p><p>—Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160107/926d291a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d258a22a520c13772442666364207fa?s=50"></div><header><strong>&quot;business applications market&quot; flame</strong> from <string>Don Wills</string> &lt;don.wills at portablesoftware.com&gt;<p>January  7, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jan 7, 2016, at 3:56 PM, Jens Alfke &lt;jens at mooseyard.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 7, 2016, at 2:33 PM, Don Wills &lt;don.wills at portablesoftware.com &lt;mailto:don.wills at portablesoftware.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Do you really believe that you can stop the &quot;users&quot; who &quot;loathed them so much&quot; from doing what they want to do with Swift?  Hubris isn&#39;t a strong enough word to describe that attitude.<br>&gt; <br>&gt; It’s impossible to implement unchecked exceptions in Swift because it lacks any form of stack-unwinding. For example, if A calls B calls C, and B is not marked as ‘throws’, then there is no way for C to return an error back to A. (Unless the error is stored externally, like as an object property, instead of being directly returned.)<br></p><p>Actually, that is circular logic.  &quot;It is impossible to do A in B because B lacks the thingies necessary to do A.&quot;  Regardless of that twisted logic, of course Swift could have implemented the stack unwinding stuff.  Such support is an integral feature of LLVM.  See http://llvm.org/docs/ExceptionHandling.html#exception-handling-intrinsics &lt;http://llvm.org/docs/ExceptionHandling.html#exception-handling-intrinsics&gt;<br>&gt;&gt; FWIW, I&#39;ve already started down the path of dealing with the lack of unchecked &lt;whatever-you-call-em&gt;s by using the following code:<br>&gt; <br>&gt; “try!” isn’t anything like an unchecked exception. It simply ignores the error. It’s the equivalent of the unfortunate Java idiom:<br>&gt; 	try {<br>&gt; 		somethingThatMightThrowAnException();<br>&gt; 	} catch(Exception e) { /* la la la I can’t hear you */ }<br>&gt; Back in my Java days I tracked several mysterious bugs down to usage of this idiom. Internally something was failing, but the exception was ignored so there was no indication of the failure. That made it much harder for me to find.<br>&gt; <br>&gt;&gt;     throw Exception(&quot;Invalid type&quot;)  /* for those types not supported which is a programmer error */<br>&gt; <br>&gt; The correct way to signal a programmer error in Swift is with assert() or fatalError() [sp?]. Which removes your need to use the above workaround, because the method no longer needs to be marked as throws.<br></p><p>assert() is of no use because it disappears if optimization is turned on.  And fatalError() is also of no use for complex, multi-threaded systems like HTTP servers - systems in which a thread can croak but that you don&#39;t want to take down the entire process.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160107/6a1d0e62/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>&quot;business applications market&quot; flame</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January  7, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jan 7, 2016, at 2:56 PM, Jens Alfke via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 7, 2016, at 2:33 PM, Don Wills &lt;don.wills at portablesoftware.com &lt;mailto:don.wills at portablesoftware.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Do you really believe that you can stop the &quot;users&quot; who &quot;loathed them so much&quot; from doing what they want to do with Swift?  Hubris isn&#39;t a strong enough word to describe that attitude.<br>&gt; <br>&gt; It’s impossible to implement unchecked exceptions in Swift because it lacks any form of stack-unwinding. For example, if A calls B calls C, and B is not marked as ‘throws’, then there is no way for C to return an error back to A. (Unless the error is stored externally, like as an object property, instead of being directly returned.)<br>&gt; <br>&gt;&gt; FWIW, I&#39;ve already started down the path of dealing with the lack of unchecked &lt;whatever-you-call-em&gt;s by using the following code:<br>&gt; <br>&gt; “try!” isn’t anything like an unchecked exception. It simply ignores the error. It’s the equivalent of the unfortunate Java idiom:<br>&gt; 	try {<br>&gt; 		somethingThatMightThrowAnException();<br>&gt; 	} catch(Exception e) { /* la la la I can’t hear you */ }<br>&gt; Back in my Java days I tracked several mysterious bugs down to usage of this idiom. Internally something was failing, but the exception was ignored so there was no indication of the failure. That made it much harder for me to find.<br></p><p>FYI, try! aborts if an error is thrown.  It is more analogous to:<br></p><p>try {<br>	somethingThatMightThrowAnException();<br>} catch(Exception e) {<br>	abort(); // this better not happen<br>}<br></p><p>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160107/da578ac0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/14477c366d6ee4e41adf14837bc4f2f9?s=50"></div><header><strong>&quot;business applications market&quot; flame</strong> from <string>Ryan Lovelett</string> &lt;swift-dev at ryan.lovelett.me&gt;<p>January  7, 2016 at 08:00:00pm</p></header><div class="content"><p>I’m a fan of the Freakonomics folks [1]. They have this mantra that goes something like: trying to persuade people who don&#39;t want to be persuaded is a big mistake. When you have this urge to try to persuade people of things that the best thing to do is just to take a deep breath and ask yourself: &quot;Why do I need to persuade them? What&#39;s my real reason for wanting to persuade them?&quot;<br></p><p>I took the message to heart a few years back. It has really lowered my<br>blood pressure and some how the sunny Florida weather just seems<br>sunnier. You know what I mean?<br></p><p>I digress. Cheers! 🍻<br></p><p>[1]http://freakonomics.com<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160107/fbd849ee/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fc6a5ffc8e5732ec719d2dd9a0fd9d43?s=50"></div><header><strong>&quot;business applications market&quot; flame</strong> from <string>Joe DeCapo</string> &lt;snoogansbc at gmail.com&gt;<p>January  7, 2016 at 09:00:00pm</p></header><div class="content"><p>That sort of perspective is something I can only aspire to. Still, I did enjoy this discourse, and learned a few things along the way :)<br></p><p>&gt; On Jan 7, 2016, at 7:02 PM, Ryan Lovelett via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; I’m a fan of the Freakonomics folks [1]. They have this mantra that goes something like: trying to persuade people who don&#39;t want to be persuaded is a big mistake. When you have this urge to try to persuade people of things that the best thing to do is just to take a deep breath and ask yourself: &quot;Why do I need to persuade them? What&#39;s my real reason for wanting to persuade them?&quot;<br>&gt;  <br>&gt; I took the message to heart a few years back. It has really lowered my blood pressure and some how the sunny Florida weather just seems sunnier. You know what I mean?<br>&gt;  <br>&gt; I digress. Cheers! 🍻<br>&gt;  <br>&gt; [1] http://freakonomics.com<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f79a7909dfca0088f4fdc01f109f497e?s=50"></div><header><strong>&quot;business applications market&quot; flame</strong> from <string>Isaac Gouy</string> &lt;igouy2 at yahoo.com&gt;<p>January  7, 2016 at 10:00:00pm</p></header><div class="content"><p>On Thursday, January 7, 2016 2:33 PM, Don Wills wrote:<br></p><p>&gt;You can laugh all you at my OPINION about Java&#39;s checked and unchecked, but in the end, the great unwashed masses of programmers do whatever they believe is best to build their software, regardless of what programming languages designers believe or try to force upon them. <br></p><p><br>There will be those who shoe-horn idioms known from previous programming languages into their Swift programs. <br></p><p><br>That is not an argument in favor of those idioms being provided in Swift.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>&quot;business applications market&quot; flame</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January  7, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt;&gt;&gt;&gt; IMO, Java has it right - let the API designer decide which approach to take.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That&#39;s a frankly laughable misreading of the Java story. The Java story is that they wanted everyone to use checked exceptions, but the users loathed them so much that they found hacks to get around the checked exception system<br>&gt; <br>&gt; Do you really believe that you can stop the &quot;users&quot; who &quot;loathed them so much&quot; from doing what they want to do with Swift?  Hubris isn&#39;t a strong enough word to describe that attitude.<br></p><p>No, but I think we can design a system that fewer users will hate so much that they actively seek to thwart it. That&#39;s why Swift has you mark throwing functions, but doesn&#39;t make you declare which errors they can throw—this is seen as a good balance between the anything-goes world of unchecked exceptions and the annoyingly-specific world of checked exceptions.<br></p><p>&gt; FWIW, I&#39;ve already started down the path of dealing with the lack of unchecked &lt;whatever-you-call-em&gt;s by using the following code:<br>&gt; <br>&gt; func add(p1: String, _ p2 Any) {<br>&gt;     try! addWithThrows(p1, p2)<br>&gt; }<br>&gt; <br>&gt; private func addWithThrows(p1: String, _ p2 Any) throws {<br>&gt;     // code that handles many types for p2, followed by return for each of the valid types<br>&gt;     throw Exception(&quot;Invalid type&quot;)  /* for those types not supported which is a programmer error */<br>&gt; }<br>&gt; <br>&gt; public class Exception: ErrorType {<br>&gt;     init() {<br>&gt;     }<br>&gt;     init(_ msg: String) {<br>&gt;     }<br>&gt; }<br></p><p>That&#39;s great! You&#39;re clearly indicating that addWithThrows(_:_:) can throw, and at the call site you assert non-failure. This may not be the best way to handle errors—a more descriptive ErrorType and some do/catch code could probably give a better error experience, or if all errors should crash you could just use precondition()—but that&#39;s your choice. What&#39;s important is that the error-handling behavior of your code is obvious to anyone who reads it.<br></p><p>&gt; You can laugh all you at my OPINION about Java&#39;s checked and unchecked, but in the end, the great unwashed masses of programmers do whatever they believe is best to build their software, regardless of what programming languages designers believe or try to force upon them.<br></p><p>&quot;Laughable&quot; was unkind; I apologize for using that word. What I was trying to get at was that Java&#39;s designers never intended for users to use unchecked exceptions very often—this was an unintended consequence of their design.<br></p><p>The design of the language inescapably shapes the code written in it, though not always in the direction the language&#39;s designers intend. Java&#39;s design was intended to shape code into robustly handling errors; instead, it shaped code to circumvent its safety checks and ignore errors. Swift is trying to learn from those mistakes, by using a less burdensome form of checked errors, and by making it easier to crash when there&#39;s an error (using `try!`) than ignore an error (using an empty `catch` clause).<br></p><p>Undoubtedly some people will still find ways to use Swift&#39;s error system in unintended ways, but hopefully they will do so less often than they would if we had slavishly copied another language&#39;s error handling.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5f6cba1dba694e74dc891489a2a4d921?s=50"></div><header><strong>&quot;business applications market&quot; flame</strong> from <string>Kate Stone</string> &lt;katherine_stone at apple.com&gt;<p>January  8, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jan 7, 2016, at 12:27 PM, Brent Royal-Gordon via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; IMO, Java has it right - let the API designer decide which approach to take.<br>&gt; <br>&gt; That&#39;s a frankly laughable misreading of the Java story. The Java story is that they wanted everyone to use checked exceptions, but the users loathed them so much that they found hacks to get around the checked exception system<br></p><p><br>As someone who shipped significant Java codebases, I actually found significant value in having readily identifiable anti-patterns that marked bad code.  Anywhere API that caught all exceptions, transparently passed all exceptions along, or attempted to catch runtime errors was immediately suspect.<br></p><p>Kate Stone k8stone at apple.com &lt;mailto:k8stone at apple.com&gt;<br> Xcode Low Level Tools<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160108/fd803194/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5a72880ffed1a30cb9b8e3f372507145?s=50"></div><header><strong>&quot;business applications market&quot; flame</strong> from <string>Rob Mayoff</string> &lt;mayoff at dqd.com&gt;<p>January  8, 2016 at 04:00:00pm</p></header><div class="content"><p>Why are you even using throw and try-bang here? It looks like, instead of<br>throw, you should be using preconditionFailure: “Use this function to stop<br>the program when control flow can only reach the call if your API was<br>improperly used.”<br></p><p>https://developer.apple.com/library/ios/documentation/Swift/Reference/Swift_StandardLibrary_Functions/index.html#//apple_ref/swift/func/s:FSs19preconditionFailureFTKT_SS4fileVSs12StaticString4lineSu_T_<br></p><p><br>On Thu, Jan 7, 2016 at 4:33 PM, Don Wills via swift-users &lt;<br>swift-users at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; *func add(p1: String, _ p2 Any) {*<br>&gt; *    try! addWithThrows(p1, p2)*<br>&gt; *}*<br>&gt;<br>&gt; *private func addWithThrows(p1: String, _ p2 Any) throws {*<br>&gt; *    // code that handles many types for p2, followed by return for each<br>&gt; of the valid types*<br>&gt; *    throw Exception(&quot;Invalid type&quot;)  /* for those types not supported<br>&gt; which is a programmer error */*<br>&gt; *}*<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160108/52d43eb8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d258a22a520c13772442666364207fa?s=50"></div><header><strong>&quot;business applications market&quot; flame</strong> from <string>Don Wills</string> &lt;don.wills at portablesoftware.com&gt;<p>January  8, 2016 at 04:00:00pm</p></header><div class="content"><p>My particular situation was a conversion from Java.  There are about 10 different add() methods with different parameters in its containing class.  Only one of the add() overloads could cause a RuntimeException.  In Java, we use a subclass of RuntimeException as the ReallyBadError indicator that is catchable near the top of the call stack, and possibly recoverable, such as by restarting a thread.  The problem is that the calling code is spread across dozens of classes in several different products.  Trying to figure out which of the add calls need to be enclosed with this:<br>  do {<br>     try add()<br>  }<br>  catch()...<br>is a giant hunt for needles in a haystack, and even if we could find them all would be a maintenance nightmare.<br></p><p>The fact that I bumped into this situation converting a bunch of code from Java is irrelevant.  The programming language feature I desire (unchecked thingies that unwind the stack until running into a relevant try/catch) is simply absent in Swift.<br></p><p>Here is a more in depth description of why that feature is important.  I need a non-checked &lt;whateveryoucallit&gt; for the *almost* fatal situations that are recoverable at a very high level.  NullPointer is the prime example of a non-checked exception in Java.  Letting the programmer write code that decides how to deal with such a situation is all I want in Swift.  Unfortunately, assert() is irrelevant to the problem and fatalError() is not acceptable.  The server needs to stay up, even in the face of latent bugs causing NullPointer exceptions and user-defined versions of similar errors.<br></p><p>The Swift requirement that all throw &lt;struct&gt; statenments must be declared with &quot;throws&quot; in the containing method s a real deal killer for big APIs that want to provide the option for the programmer to build some type of recovery mechanism.<br></p><p>Specifically, the “Use this function to stop the program...&quot; approach you suggest is simply unacceptable.  I can&#39;t live with the *entire* program to stopping.  Think of a program such as Apache Server and you will understand what I&#39;m talking about.<br> <br></p><p>&gt; On Jan 8, 2016, at 3:28 PM, Rob Mayoff via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Why are you even using throw and try-bang here? It looks like, instead of throw, you should be using preconditionFailure: “Use this function to stop the program when control flow can only reach the call if your API was improperly used.”<br>&gt; <br>&gt; https://developer.apple.com/library/ios/documentation/Swift/Reference/Swift_StandardLibrary_Functions/index.html#//apple_ref/swift/func/s:FSs19preconditionFailureFTKT_SS4fileVSs12StaticString4lineSu_T_ &lt;https://developer.apple.com/library/ios/documentation/Swift/Reference/Swift_StandardLibrary_Functions/index.html#//apple_ref/swift/func/s:FSs19preconditionFailureFTKT_SS4fileVSs12StaticString4lineSu_T_&gt;<br>&gt; <br>&gt; <br>&gt; On Thu, Jan 7, 2016 at 4:33 PM, Don Wills via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; func add(p1: String, _ p2 Any) {<br>&gt;     try! addWithThrows(p1, p2)<br>&gt; }<br>&gt; <br>&gt; private func addWithThrows(p1: String, _ p2 Any) throws {<br>&gt;     // code that handles many types for p2, followed by return for each of the valid types<br>&gt;     throw Exception(&quot;Invalid type&quot;)  /* for those types not supported which is a programmer error */<br>&gt; }<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160108/6608f5a6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>&quot;business applications market&quot; flame</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>January  8, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jan 8, 2016, at 3:01 PM, Don Wills via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; The server needs to stay up, even in the face of latent bugs causing NullPointer exceptions and user-defined versions of similar errors.<br></p><p>Hold on. Swift doesn’t run in a virtual machine, doesn’t have a true garbage collector, and doesn’t (to my knowledge) have the same safety guarantees as “managed” languages like Java or C#. It’s a lot safer than C or C++, but buggy Swift programs can crash.<br></p><p>For example, my understanding is that dereferencing an implicitly-unwrapped optional (e.g. an “Int!”) that contains nil really does dereference a null pointer and causes a bus error. Otherwise every such dereference would have to have code in it to preflight the pointer, which is inefficient. Even if I’m wrong and Swift does preflight, it’s response is to trigger a fatalError that crashes the program. (Go is able to catch such a deref and turn it into a recoverable panic, but only because it installs a SIGBUS signal handler in the process, which is part of Go’s “we take over the entire process and do everything our way” philosophy.)<br></p><p>If you have a server process that needs to stay running even if modules fail, then you’ll probably have to run those modules as child processes and monitor them.<br></p><p>Again: apples and oranges.<br></p><p>I see now what you’re asking for, but you’ve been confusing matters by talking about checked vs. unchecked exceptions. As I’ve said many times, Swift has neither. What you want is basically a per-thread fatal error that terminates the thread but leaves the  process running. Maybe this can be added in the future, but currently Swift has no intrinsic notion of threads so there’s nowhere to put such a mechanism.<br></p><p>—Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160108/1c9c5dbe/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d258a22a520c13772442666364207fa?s=50"></div><header><strong>&quot;business applications market&quot; flame</strong> from <string>Don Wills</string> &lt;don.wills at portablesoftware.com&gt;<p>January  8, 2016 at 07:00:00pm</p></header><div class="content"><p>On Jan 8, 2016, at 6:47 PM, Jens Alfke &lt;jens at mooseyard.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 8, 2016, at 3:01 PM, Don Wills via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The server needs to stay up, even in the face of latent bugs causing NullPointer exceptions and user-defined versions of similar errors.<br>&gt; <br>&gt; Hold on. Swift doesn’t run in a virtual machine, doesn’t have a true garbage collector, and doesn’t (to my knowledge) have the same safety guarantees as “managed” languages like Java or C#. It’s a lot safer than C or C++, but buggy Swift programs can crash.<br>&gt; For example, my understanding is that dereferencing an implicitly-unwrapped optional (e.g. an “Int!”) that contains nil really does dereference a null pointer and causes a bus error. Otherwise every such dereference would have to have code in it to preflight the pointer, which is inefficient. Even if I’m wrong and Swift does preflight, it’s response is to trigger a fatalError that crashes the program. (Go is able to catch such a deref and turn it into a recoverable panic, but only because it installs a SIGBUS signal handler in the process, which is part of Go’s “we take over the entire process and do everything our way” philosophy.)<br></p><p>My understanding of null references with forced unwrapping of optionals in Swift corresponds with what you say.  But that&#39;s not what I am talking about.  All I am asking for is that the &quot;throws&quot; keyword on a method definition be optional - that is, a method can throw a &lt;thingy&gt; with the throw statement without specifying &quot;throws&quot;, and it can be caught by a matching try/catch clause up the stack.  That is perfectly possible with LLVM and does not entail any ill-defined behavior.  LLVM is capable of and well defined for supporting exactly what I&#39;m looking for.<br></p><p>You first sentence concerns me though.  What &quot;safety guarantees&quot; does Swift lack that Java and C# have (other than possible memory leaks because of ARC)?  Part of our communication problem is that I don&#39;t believe we agree on what the word &quot;managed&quot; means.  To me it means &quot;memory management&quot;, that is, garbage collection and dynamic class loaders.  I suspect you are using it as per Microsoft&#39;s definition - a section of code that runs in the CLR that is type and pointer safe, vs. a section of code that is not (ie. &quot;unmanaged&quot;).  FWIW, I believe that Microsoft&#39;s .NET/CLR is the only place in the computer industry that uses the word &quot;managed&quot; like that.<br></p><p>&gt; If you have a server process that needs to stay running even if modules fail, then you’ll probably have to run those modules as child processes and monitor them.<br></p><p>That&#39;s really ugly and defeats the whole idea of GCD.<br></p><p>&gt; Again: apples and oranges.<br>&gt; <br>&gt; I see now what you’re asking for, but you’ve been confusing matters by talking about checked vs. unchecked exceptions. As I’ve said many times, Swift has neither. What you want is basically a per-thread fatal error that terminates the thread but leaves the  process running. Maybe this can be added in the future, but currently Swift has no intrinsic notion of threads so there’s nowhere to put such a mechanism.<br></p><p>A per-thread fatal error handler is not the answer though.  A full fledged unchecked try/catch handler is what I am looking for, which can be implemented in Swift without any changes to LLVM.<br></p><p>Don<br></p><p>PS. I&#39;ll stop calling the object of a throw an exception.  Words matter, and yes, Swift documentation does not use the word exception.  It is unfortunate that Swift designers decided to use the keywords try, catch and throw and then decided to call what those statements deal with by a name that is different from all other programming languages, AFAIK.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160108/f17b4924/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>&quot;business applications market&quot; flame</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January  8, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt;&gt;&gt; The server needs to stay up, even in the face of latent bugs causing NullPointer exceptions and user-defined versions of similar errors.<br>&gt;&gt; <br>&gt;&gt; Hold on. Swift doesn’t run in a virtual machine, doesn’t have a true garbage collector, and doesn’t (to my knowledge) have the same safety guarantees as “managed” languages like Java or C#. It’s a lot safer than C or C++, but buggy Swift programs can crash.<br>&gt;&gt; For example, my understanding is that dereferencing an implicitly-unwrapped optional (e.g. an “Int!”) that contains nil really does dereference a null pointer and causes a bus error. Otherwise every such dereference would have to have code in it to preflight the pointer, which is inefficient. Even if I’m wrong and Swift does preflight, it’s response is to trigger a fatalError that crashes the program. (Go is able to catch such a deref and turn it into a recoverable panic, but only because it installs a SIGBUS signal handler in the process, which is part of Go’s “we take over the entire process and do everything our way” philosophy.)<br>&gt; <br>&gt; All I am asking for is that the &quot;throws&quot; keyword on a method definition be optional - that is, a method can throw a &lt;thingy&gt; with the throw statement without specifying &quot;throws&quot;, and it can be caught by a matching try/catch clause up the stack.  That is perfectly possible with LLVM and does not entail any ill-defined behavior.  LLVM is capable of and well defined for supporting exactly what I&#39;m looking for.<br></p><p>Swift made a conscious choice not to include exceptions thrown through arbitrary stack frames not because it was technically impossible, but because its designers judged the costs to be too high.<br></p><p>The problem is this: if a piece of code is going to exit early because of an error, it has to be written to handle that early exit. Otherwise it will misbehave—fail to deallocate memory, fail to close file handles/sockets/database connections/whatever, fail to release locks, etc. In a language like Java, writing truly exception-safe code requires a ridiculous quantity of try/finally blocks. That&#39;s why nobody does it. They make judgements about which exceptions they&#39;re likely to see and which resources are dangerous to leak, and only protect their code against those specific anticipated conditions. Then something unforeseen happens and their program breaks.<br></p><p>This is even worse in a reference-counted language like Swift because correctly balancing the reference counts in the presence of exceptions basically requires every function to include an implicit finally block to balance all the retain counts. This means the compiler has to generate lots of extra code on the off chance that some call or another throws an exception. The vast majority of this code is never, ever used, but it has to be there, bloating the process.<br></p><p>Because of these problems, Swift chose not to support traditional exceptions; instead, it only allows you to throw errors in specially-marked regions of code. But as a corollary, that means that, if something goes really wrong in code that can&#39;t throw, all it can really do to prevent a disaster is crash. And currently, the only thing you can crash is the entire process.<br></p><p>Eventually it may become possible to create some kind of self-contained unit of code within a process; a failed precondition would only crash the unit it&#39;s in, and since that code&#39;s side effects could only be within that unit, the rest of the process could safely continue running. But right now, no such feature exists.<br></p><p>&gt; You first sentence concerns me though.  What &quot;safety guarantees&quot; does Swift lack that Java and C# have (other than possible memory leaks because of ARC)?  Part of our communication problem is that I don&#39;t believe we agree on what the word &quot;managed&quot; means.  To me it means &quot;memory management&quot;, that is, garbage collection and dynamic class loaders.  I suspect you are using it as per Microsoft&#39;s definition - a section of code that runs in the CLR that is type and pointer safe, vs. a section of code that is not (ie. &quot;unmanaged&quot;).  FWIW, I believe that Microsoft&#39;s .NET/CLR is the only place in the computer industry that uses the word &quot;managed&quot; like that.<br></p><p>The CLR and especially the JVM try to create a safe, hermetically-sealed environment where, to a first approximation, nothing bad can ever happen. You can&#39;t crash a process without it causing a catchable exception. You can&#39;t get a reference to memory unless it&#39;s part of a properly-allocated, correctly-initialized, and still-present object. You can&#39;t cause the garbage collector to free an object that&#39;s still accessible, or leak an object that isn&#39;t anymore. You literally can&#39;t express unsafe constructs in their bytecodes. There are some escape hatches, particularly in the CLR, and of course there are bugs that make it possible to do things that shouldn&#39;t be allowed, but the goal is to create safety guarantees that are literally impossible to subvert, so that it&#39;s safe to run code from an untrusted source.<br></p><p>Swift is not like that. Compiled Swift code is machine code; there&#39;s just no validating it. The standard library includes constructs that can access arbitrary memory addresses. Memory management is done with reference counting, and the Unmanaged type in the library can subvert it. You can call freely into arbitrary machine code. And a crash is a crash, not an exception. There&#39;s simply no attempt to provide the level of complete safety that the CLR and JVM attempt to achieve.<br></p><p>&gt;&gt; If you have a server process that needs to stay running even if modules fail, then you’ll probably have to run those modules as child processes and monitor them.<br>&gt; <br>&gt; That&#39;s really ugly and defeats the whole idea of GCD.<br></p><p>GCD is meant for lightweight concurrency in a shared memory space. Though it provides tools to help mediate between activities on different queues, it makes no attempt to *prevent* activity on one queue from screwing up another queue.<br></p><p>&gt; A per-thread fatal error handler is not the answer though.  A full fledged unchecked try/catch handler is what I am looking for, which can be implemented in Swift without any changes to LLVM.<br></p><p>Again, not in a fully safe way, and not without significant costs that Swift&#39;s designers judged to not be worth it.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>&quot;business applications market&quot; flame</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>January  8, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jan 8, 2016, at 6:38 PM, Don Wills &lt;don.wills at portablesoftware.com&gt; wrote:<br>&gt; <br>&gt; All I am asking for is that the &quot;throws&quot; keyword on a method definition be optional - that is, a method can throw a &lt;thingy&gt; with the throw statement without specifying &quot;throws&quot;, and it can be caught by a matching try/catch clause up the stack.<br></p><p>That’s asking for much, much, much more than making a keyword optional. You’re asking for the underlying error handling mechanism to be something completely different than what it is, i.e. stack-unwinding exceptions rather than returning an error value.<br></p><p>&gt; That is perfectly possible with LLVM and does not entail any ill-defined behavior. <br></p><p>There is a vast difference between machine code supporting something, and a language supporting it. You could say the same thing about nearly any language feature that Swift decided not to support. “But LLVM allows multiple inheritance!” “There’s nothing in LLVM preventing making all value bindings immutable!” “LLVM supports goto statements!&quot;<br></p><p>The designers of Swift do not like exceptions. They decided not to include them in the language. Arguing for exceptions here is a tiresome religious war. When I worked at Apple I had some arguments about exceptions with people on the Cocoa and compiler teams. I definitely prefer exceptions to plain old return values (as in C or Go or Swift 1.x), but the compromise in Swift 2 is good enough that I’m happy with it, and I appreciate arguments like Brent’s about the overhead it saves. (If you’ve looked t the disassembly of exception-heavy C++ code, you can see all the code-size overhead it adds.)<br></p><p>All language designers have features they dislike and won’t add. Try arguing for late-binding dynamic dispatch to C++ gurus. Try arguing for explicit “free” calls in a Java forum. Tell the Haskell maintainers that mutable variables make coding so much easier. If you think language designers should give in and add every feature someone thinks is important, then you get the real kitchen sink you keep saying Swift is.<br></p><p>That’s the last I’m going to write about this. It’s stopped having any value. I’ve been around long enough to be sick of language flame wars, and that’s about all this is.<br></p><p>—Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160108/50b28c92/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d258a22a520c13772442666364207fa?s=50"></div><header><strong>&quot;business applications market&quot; flame</strong> from <string>Don Wills</string> &lt;don.wills at portablesoftware.com&gt;<p>January  8, 2016 at 11:00:00pm</p></header><div class="content"><p>Jens -<br></p><p>I apologize for having annoyed you, but this thread has been very informative for me.<br></p><p>I was under the misconception that Swift was more similar to Java and .NET than to C, C++ and Obj-C.  Your statement - The designers of Swift do not like exceptions. - clears up some of my misunderstanding of fundamental principles guiding Swift design.  And thank you Brent Royal-Gordon - your explanation was of great help in furthering my understanding of those design decisions.<br></p><p>I was seriously considering moving toward the use of Swift as the programming language of the future for my companies&#39; mission-critical business application systems, but the knowledge I&#39;ve gained in this thread has disabused me of that.<br></p><p>Sincerely,<br>Don Wills<br>owner, Produce Pro, Inc. and Portable Software Company<br></p><p><br>&gt; On Jan 8, 2016, at 10:55 PM, Jens Alfke &lt;jens at mooseyard.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 8, 2016, at 6:38 PM, Don Wills &lt;don.wills at portablesoftware.com &lt;mailto:don.wills at portablesoftware.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; All I am asking for is that the &quot;throws&quot; keyword on a method definition be optional - that is, a method can throw a &lt;thingy&gt; with the throw statement without specifying &quot;throws&quot;, and it can be caught by a matching try/catch clause up the stack.<br>&gt; <br>&gt; That’s asking for much, much, much more than making a keyword optional. You’re asking for the underlying error handling mechanism to be something completely different than what it is, i.e. stack-unwinding exceptions rather than returning an error value.<br>&gt; <br>&gt;&gt; That is perfectly possible with LLVM and does not entail any ill-defined behavior. <br>&gt; <br>&gt; There is a vast difference between machine code supporting something, and a language supporting it. You could say the same thing about nearly any language feature that Swift decided not to support. “But LLVM allows multiple inheritance!” “There’s nothing in LLVM preventing making all value bindings immutable!” “LLVM supports goto statements!&quot;<br>&gt; <br>&gt; The designers of Swift do not like exceptions. They decided not to include them in the language. Arguing for exceptions here is a tiresome religious war. When I worked at Apple I had some arguments about exceptions with people on the Cocoa and compiler teams. I definitely prefer exceptions to plain old return values (as in C or Go or Swift 1.x), but the compromise in Swift 2 is good enough that I’m happy with it, and I appreciate arguments like Brent’s about the overhead it saves. (If you’ve looked t the disassembly of exception-heavy C++ code, you can see all the code-size overhead it adds.)<br>&gt; <br>&gt; All language designers have features they dislike and won’t add. Try arguing for late-binding dynamic dispatch to C++ gurus. Try arguing for explicit “free” calls in a Java forum. Tell the Haskell maintainers that mutable variables make coding so much easier. If you think language designers should give in and add every feature someone thinks is important, then you get the real kitchen sink you keep saying Swift is.<br>&gt; <br>&gt; That’s the last I’m going to write about this. It’s stopped having any value. I’ve been around long enough to be sick of language flame wars, and that’s about all this is.<br>&gt; <br>&gt; —Jens<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160108/46858275/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/936a6a8c18cd1a181cae5de7b818a24d?s=50"></div><header><strong>&quot;business applications market&quot; flame</strong> from <string>Dru Satori</string> &lt;dru at druware.com&gt;<p>January  9, 2016 at 01:00:00pm</p></header><div class="content"><p>Funny thing. I was moving towards swift and this discussion has helped me mcommit to more swift not less. I don&#39;t mind limitations if I understand them going in<br></p><p>Sent from Outlook Mobile&lt;https://aka.ms/qtex0l&gt;<br></p><p><br></p><p><br>On Fri, Jan 8, 2016 at 10:28 PM -0800, &quot;Don Wills via swift-users&quot; &lt;swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br></p><p>Jens -<br></p><p>I apologize for having annoyed you, but this thread has been very informative for me.<br></p><p>I was under the misconception that Swift was more similar to Java and .NET than to C, C++ and Obj-C.  Your statement - The designers of Swift do not like exceptions. - clears up some of my misunderstanding of fundamental principles guiding Swift design.  And thank you Brent Royal-Gordon - your explanation was of great help in furthering my understanding of those design decisions.<br></p><p>I was seriously considering moving toward the use of Swift as the programming language of the future for my companies&#39; mission-critical business application systems, but the knowledge I&#39;ve gained in this thread has disabused me of that.<br></p><p>Sincerely,<br>Don Wills<br>owner, Produce Pro, Inc. and Portable Software Company<br></p><p><br>On Jan 8, 2016, at 10:55 PM, Jens Alfke &lt;jens at mooseyard.com&lt;mailto:jens at mooseyard.com&gt;&gt; wrote:<br></p><p><br>On Jan 8, 2016, at 6:38 PM, Don Wills &lt;don.wills at portablesoftware.com&lt;mailto:don.wills at portablesoftware.com&gt;&gt; wrote:<br></p><p>All I am asking for is that the &quot;throws&quot; keyword on a method definition be optional - that is, a method can throw a &lt;thingy&gt; with the throw statement without specifying &quot;throws&quot;, and it can be caught by a matching try/catch clause up the stack.<br></p><p>That&#39;s asking for much, much, much more than making a keyword optional. You&#39;re asking for the underlying error handling mechanism to be something completely different than what it is, i.e. stack-unwinding exceptions rather than returning an error value.<br></p><p>That is perfectly possible with LLVM and does not entail any ill-defined behavior.<br></p><p>There is a vast difference between machine code supporting something, and a language supporting it. You could say the same thing about nearly any language feature that Swift decided not to support. &quot;But LLVM allows multiple inheritance!&quot; &quot;There&#39;s nothing in LLVM preventing making all value bindings immutable!&quot; &quot;LLVM supports goto statements!&quot;<br></p><p>The designers of Swift do not like exceptions. They decided not to include them in the language. Arguing for exceptions here is a tiresome religious war. When I worked at Apple I had some arguments about exceptions with people on the Cocoa and compiler teams. I definitely prefer exceptions to plain old return values (as in C or Go or Swift 1.x), but the compromise in Swift 2 is good enough that I&#39;m happy with it, and I appreciate arguments like Brent&#39;s about the overhead it saves. (If you&#39;ve looked t the disassembly of exception-heavy C++ code, you can see all the code-size overhead it adds.)<br></p><p>All language designers have features they dislike and won&#39;t add. Try arguing for late-binding dynamic dispatch to C++ gurus. Try arguing for explicit &quot;free&quot; calls in a Java forum. Tell the Haskell maintainers that mutable variables make coding so much easier. If you think language designers should give in and add every feature someone thinks is important, then you get the real kitchen sink you keep saying Swift is.<br></p><p>That&#39;s the last I&#39;m going to write about this. It&#39;s stopped having any value. I&#39;ve been around long enough to be sick of language flame wars, and that&#39;s about all this is.<br></p><p>-Jens<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160109/d0a6ce60/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/094f3e16a9a1276cde39096860496ad8?s=50"></div><header><strong>&quot;business applications market&quot; flame</strong> from <string>Joshua Scott Emmons</string> &lt;skia at skia.net&gt;<p>January  9, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jan 9, 2016, at 12:28 AM, Don Wills via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Your statement - The designers of Swift do not like exceptions. - clears up some of my misunderstanding of fundamental principles guiding Swift design.<br></p><p><br>You don&#39;t have to take Jens&#39;s word for it. The fundamental principles guiding Swift design are all there for you to peruse at your leisure:  https://github.com/apple/swift/tree/master/docs<br></p><p>The document entitled &quot;Error Handling Rationale&quot;, for example, feels particularly apropos: https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst<br></p><p><br>-- <br>Cheers,<br>-jemmons<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>&quot;business applications market&quot; flame</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January  9, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jan 8, 2016, at 10:28 PM, Don Wills via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Jens -<br>&gt; <br>&gt; I apologize for having annoyed you, but this thread has been very informative for me.<br>&gt; <br>&gt; I was under the misconception that Swift was more similar to Java and .NET than to C, C++ and Obj-C.  Your statement - The designers of Swift do not like exceptions. - clears up some of my misunderstanding of fundamental principles guiding Swift design.  And thank you Brent Royal-Gordon - your explanation was of great help in furthering my understanding of those design decisions.<br></p><p>Hi Don,<br></p><p>The other folks on this thread are essentially correct, though the tone wasn’t always helpful.  It strikes me that you may not have seen the error handling rationale document.  If that is the case, you should take a look, it describes many of these tradeoffs, including a number of specific mentions of the Java model and why we decided to go with something different:<br>https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst &lt;https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst&gt;<br></p><p>Overall, I think the Swift model has worked out really well.  The only thing that I’m aware of that we’re seriously considering changing is to allow the ability to throw a single specific error type, instead of having type erasure take it all away.  This is blocked on the resilience work landing, but it would be great to see it get implemented shortly after that.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160109/492f8af0/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>&quot;business applications market&quot; flame</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>January  6, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jan 6, 2016, at 10:30 AM, Don Wills &lt;don.wills at portablesoftware.com&gt; wrote:<br>&gt; <br>&gt; The cost of !, ? and ?? everywhere in the language is a huge coding and maintenance inconvenience for the programmer error condition referencing a variable that contains the value null.<br></p><p>It’s not so much about null, as it is about whether a variable definitely contains a value or not. (You can have optionals for non-pointer types like ints.) It’s not what you’re used to. Some Mac/iOS programmers have been complaining because the bindings to Cocoa APIs were suboptimal and exposed a lot of optionals where they didn’t need to.<br></p><p>Basically this argument is like a JavaScript or Python programmer looking at Java or C# and complaining that static typing adds a huge coding and maintenance inconvenience with all those type declarations and casts. No, not really, and it has a ton of benefits to safety; it’s just not what they’re used to.<br></p><p>&gt; The fact that you claim Ints are primitives and Loïc Lecrenier in an email three minutes prior writes &quot;Swift does not have primitives, but I consider that a plus...&quot;  Which is it?<br></p><p>I’m not sure what Loïc meant; maybe he can explain. Ints are primitives in that they are basically the same as ints in C or C++. They’re inline values of 1 to 8 bytes size that can be stored on the stack or inside structs/classes. I believe there’s some transparent boxing that goes on if you cast an int type to an Any value, but it’s more common to use generics for this.<br></p><p>Note that an Array&lt;Int&gt; is vastly more efficient than the Java equivalent, because the generated code will store the int values directly instead of boxing them up as objects. That is, a Swift Array&lt;Int&gt; is comparable in implementation and performance to a C++ std::vector&lt;int&gt; or a C int[].<br></p><p>&gt; Swift doesn&#39;t have exceptions?  What are the &quot;throws&quot; clause on funcs and the try and throw statements?<br></p><p>Please read the book! Swift error handling is syntactic sugar around the practice of having a function return a flag value on failure (false / nil / 0 / etc) combined with an ‘out’ parameter that will store an error object describing the failure. There is no stack unwinding going on.<br></p><p> This convention has been used for a long time in the Cocoa frameworks and Swift basically bakes it into the language syntax, with some improvements. I think it’s an excellent compromise — the typical try/catch exception mechanism is very flexible but makes exceptions very expensive to throw and bloats the code to add all the metadata tables to handle recovery.<br></p><p>&gt; I come from the perspective of 45 years of experience in dozens of programming languages.  Swift seems to be trying to be everything to everybody - a bridge from Obj-C, functional, imperative, procedural, object-oriented with a somewhat Java and C-like syntax.<br></p><p>*Shrug* If we’re comparing, I’ve got about 38 years’ experience if you count Tiny BASIC as a language. I don’t see Swift as having a kitchen-sink approach at all; keep in mind that it’s designed by people with a lot of experience designing and implementing languages that are heavily used for very pragmatic application and system programming.<br></p><p>I don’t know if you’ve been following the field of statically-compiled languages, but there’s been a lot of innovation recently after a long drought. Look at Rust and Go, for example. Both are subject to the same objections you made above. I just see it as language designers learning from the past and adopting new techniques that prove valuable.<br></p><p>Anyway, if there’s one thing I can leave you with, it’s: Read The Fine Manual. Swift came equipped from day one with a very well-written book that explains the language quite well. I don’t think you’ve read it, or if you did, it was much too quickly, because you’ve missed some fundamental points. There’s nothing wrong with skimming, but it doesn’t give you the authority to dismiss a language outright or make pronouncements about why it’s broken.<br></p><p>—Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160106/7dd3cde3/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/936a6a8c18cd1a181cae5de7b818a24d?s=50"></div><header><strong>&quot;business applications market&quot; flame</strong> from <string>Dru Satori</string> &lt;dru at druware.com&gt;<p>January  6, 2016 at 10:00:00pm</p></header><div class="content"><p>See, while discussing applicability to the Edu world, I think you can really dissect the languages themselves, and create compelling cases.  The problem you guys have flipped this too, the business development world is a ton more complex.<br></p><p>I love Swift as a language. I enjoy working with Xcode. But as a business developer, Swift the language is fine. Swift the development platform isn’t there yet, and for the most part, it has nothing to do with the issues raised to this point in this discussion. Hence the reason I am even speaking up, something I would not normally do in this phase of a discussion.<br></p><p>When discussing languages in a business development context, the language itself is such a small part of the puzzle. In so many cases, the choice of language is dictated by pressures outside the scope of this discussion, but there are some factors that directly influence these decisions that are language as a platform limitations.<br></p><p>One of the key questions is always one of developer competencies. Swift, as a language is a departure from the languages most business developers are comfortable in. It may use LLVM, but it is not a “C” style language, in fact, it feels more like a scripting language than many languages at this level. If you look at the business world, you see a lot of Java, C#, some VB.net, and a good bit of C/C++. Each of these languages has strengths and weaknesses, but all of them are, at this point, mature languages. Fundamental syntax is static and slow to change.  Rich libraries of tools are purpose built, well understood (bugs and all), and these platforms are ready to go for business usage, complete with developer competencies.<br></p><p>Swift, right now, today, isn’t. <br></p><p>- Is it a good language? Absolutely. <br>- Is it a mature language? Not yet. The basics feel like they are solidifying, the supporting libraries are coming along, but not quite there yet.<br>- Does it have rich libraries? Sort of. It let’s you build upon existing C libraries, though there can be some tap-dancing involved in order to make things work exactly as expected but in terms of Swift native libraries? That ball is *just* getting rolling.<br>- Does the business development developer have competency in the language? Not many, and those that do, it is heavily focused on the iOS toolkits and subsets.<br></p><p>For example, say medium size business with a dev team of say 3 developers for their internal applications already has a product, but then need to make it mobile. Let’s assume that they have a really progressive architecture. Today, the server side is MySQL with an Apache interface serving up a REST JSON interface to a ‘rich’ client application running on Windows machines. IT is probably a mix of C# and PHP, perhaps even all C#. Choosing Swift for the iOS platform is a tough sell, today. Objective C is an easier jump, it has richer libraries, and the language is closer to C# than Swift is. <br></p><p>And, that is a best case scenario. Think worst case, and unfortunately, I think this is far more prevalent than the above best case.<br></p><p>Worst case? The application is client server, fat client written in VB6, using ODBC or RDO.NET for direct data access to a Microsoft SQL Server database. The whole stack has been held together with duct tape, sure glue and bailing wire for the last 4 years. They know they have to start over. How do you sell Swift in that environment? You need to sell a single stack, with libraries and tools. Right now, Swift can’t offer that. Truth be told, out of the box neither can Objective-C.<br></p><p>There needs to be growth in the library department, and that work isn’t going to come from Apple (exclusively). That’s where open source Swift 2 and 3 come into play, and it *can* become a compelling sell, even if it is not quite there yet.<br></p><p>If you dig and poke at Swift on OS X, what you quickly figure out is that it can be used as both programming language and scripting language fairly easily. You can see the beginnings of a language that could readily be used as both server side language, and client side consumption language, all with the things that Swift is trying to bring to the table to address one standing issues that exist in both Objective-C and it’s underlying C heritage that make writing good, difficult to exploit code, hard.<br></p><p>I’ll use my own small business as an example. We have an aging client server environment. A wholesale move to cloud ready technologies is not in the budget (we like eating). A slow migration however, is. We fully understand the limitations, and have been slowly building our server stack in Swift, and believe me, we are tracking Swift.org closely, for the possibility of running that stack on Linux servers. But right now, the challenges that Swift faces just doing seemingly basic things, like reading environment variables in order to process a CGI interface request is a challenge to do in a platform neutral manner in Swift. Try database access, or other similar “business” activities. It isn’t there yet.<br></p><p>Sorry for the wall of text. The summary is simple, the potential is there, but no, today, Swift is not a prime business development environment. <br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br>On 1/6/16, 1:30 PM, &quot;Don Wills&quot; &lt;don.wills at portablesoftware.com&gt; wrote:<br></p><p>&gt;Points well taken.<br>&gt;<br>&gt;&gt; On Jan 6, 2016, at 11:02 AM, Jens Alfke &lt;jens at mooseyard.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 6, 2016, at 9:34 AM, Don Wills via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Coming from the perspective of business applications market (Java and C#), I see major problems in moving to Swift.<br>&gt;&gt; <br>&gt;&gt; Did you intend to hijack an unrelated thread instead of starting your own? If so, that’s bad netiquette. I’ve retitled the reply for you, to hopefully split off this thread.<br>&gt;&gt; <br>&gt;&gt;&gt; The String class is a disaster.  <br>&gt;&gt; <br>&gt;&gt; Flaming: Again, bad netiquette. How about offering some concrete examples of what you dislike about strings? (Bonus points for showing that you understand Unicode and aren’t just pining for an outdated array-of-UTF16 model like Java&#39;s.)<br>&gt;<br>&gt;I didn&#39;t want to post a tome about String, but here&#39;s a basic list of features/methods missing in String:<br>&gt;<br>&gt;1. The lack a Character type that are the constituent elements of a String<br>&gt;2. Missing methods (Java names used):  valueOf, charAt, trim(), length(), getBytes(), toUpperCase(), toLowerCase()<br>&gt;3. The lack of the + operator for appending<br>&gt;4. The lack of a StringBuilder (Java again) class<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; Optionals present a giant spider web of interconnectedness and syntax idiosyncrasy that does not provide any real advantage compared with Java/C#.  <br>&gt;&gt; <br>&gt;&gt; How about “no more NullPointerExceptions?” And again, “no real advantage” is just opinion with nothing behind it. Optionals have a long history in functional languages and a lot of users of said languages who feel that they’re beneficial.<br>&gt;<br>&gt;The cost of !, ? and ?? everywhere in the language is a huge coding and maintenance inconvenience for the programmer error condition referencing a variable that contains the value null.<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; The fact that Ints, etc. are not really primitives (unwrapping is required, sometimes explicit, sometimes implicit) is a major dislocation for those coming from all C-syntax-based languages.  <br>&gt;&gt; <br>&gt;&gt; Integers are primitives. More so than in Java, C# or other “managed” languages, since Swift compiles directly to machine code.<br>&gt;<br>&gt;The fact that you claim Ints are primitives and Loïc Lecrenier in an email three minutes prior writes &quot;Swift does not have primitives, but I consider that a plus...&quot;  Which is it?<br>&gt;<br>&gt;In addition, memory management (your reference to &quot;language management&quot;) has nothing to do with whether or not integers are primitives.  In Java, &quot;int&quot; is a primitive and &quot;Integer&quot; is not.<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; The lack of non-checked exceptions (that is exceptions not declared with a throws clause on the func def) is problem.  <br>&gt;&gt; <br>&gt;&gt; Swift doesn’t have exceptions at all; its error handling is fundamentally different, despite reusing some common names like “throw”. I suspect you haven’t really understood how error handling in Swift works, since “non-checked” isn’t an attribute that has any meaning in Swift’s model.<br>&gt;<br>&gt;Swift doesn&#39;t have exceptions?  What are the &quot;throws&quot; clause on funcs and the try and throw statements?<br>&gt;<br>&gt;&gt;&gt; The lack of packages and/or namespaces is another giant gaping hole.<br>&gt;&gt; <br>&gt;&gt; I agree with this, but I think it’s something that’s going to be addressed in the future (see the current work on the package manager.)<br>&gt;&gt; <br>&gt;&gt; —Jens<br>&gt;<br>&gt;I come from the perspective of 45 years of experience in dozens of programming languages.  Swift seems to be trying to be everything to everybody - a bridge from Obj-C, functional, imperative, procedural, object-oriented with a somewhat Java and C-like syntax.  I&#39;ve seen this movie before - it was called PL/I and was the IBM answer to merging COBOL and FORTRAN.  Survivors:  COBOL and FORTRAN.  It appears to me that Swift is today&#39;s PL/I.<br>&gt;<br>&gt;Don<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>&quot;business applications market&quot; flame</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>January  6, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jan 6, 2016, at 2:49 PM, Dru Satori &lt;dru at druware.com&gt; wrote:<br>&gt; <br>&gt; It may use LLVM, but it is not a “C” style language, in fact, it feels more like a scripting language than many languages at this level.<br></p><p>I disagree. Scripting languages are pretty universally dynamically-typed, interpreted, and have no visible compile/link stage. Swift isn’t like that at all. The clear ancestors are the C family (including Obj-C), Haskell (IIRC), and to a lesser degree Rust and Go. I don’t see any resemblance to Perl, Ruby, Python, etc.<br></p><p>I agree with the rest of what you’re saying, but it’s pretty obvious. The kinds of business you’re describing are conservative and just use what everyone else uses, and what every developer learns in school. 20 years ago they were probably using C or Pascal, 30 years ago it was probably COBOL. These are not early adopters.<br></p><p>Newer languages tend to fly under the radar for a while. There’s a growing use of Go, for example. (My employer, Couchbase, is using it in several shipping products.) Inside big tech companies like Facebook and Twitter there are all sorts of interesting languages being used internally, from Scala to Haskell. (Go is of course an obvious case of that.)<br></p><p>At this point Swift doesn’t even have a robust cross-platform standard library, so it’s way too early to start trying to sell it as a replacement for Java to enterprise coders. Right now Swift’s practical uses are for building iOS and Mac applications, period. But that’s going to change.<br></p><p>—Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160106/7c86711e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/936a6a8c18cd1a181cae5de7b818a24d?s=50"></div><header><strong>&quot;business applications market&quot; flame</strong> from <string>Dru Satori</string> &lt;dru at druware.com&gt;<p>January  7, 2016 at 12:00:00am</p></header><div class="content"><p>Jens,<br></p><p>Pretty sure that we aren’t far apart here, but it is more a matter of perspective. I should preface this next bit by the statement that I was heavily invested in personally in getting Mono running on OS X, and today, I consider it a steaming pile of dung for OS X development because somewhere along the way, many of the business development things that needed to happen slipped by the way side.<br></p><p>The thing that I see about Swift is that right now, today, on Linux or OS X, if Swift is installed, I can open a terminal:<br></p><p>Touch hello.swift<br>vim hello.swift<br>i<br></p><p>print(&quot;Hello Swift&quot;);<br></p><p>Esc<br>:wq<br>swift hello.swift<br></p><p>And it runs, and behaves exactly like php, perl, ruby, etc. This makes it approachable like a scripting language.  REPL and Playgrounds give it an interactivity that is reminiscent of Visual Basic, which sucked as language at it’s inception, but a very good case can be made, that Windows ascended to dominance over GEM, Mac and later the Amiga, entirely on the shoulders of Visual Basic and the Hobby Developers with it’s low barrier of entry.  They cut their teeth on BASIC, and graduated to the GUI with VB.<br></p><p>From a technical perspective, Swift is much more C like, but at the same time, yes, it is a strongly typed language, but for the casual user, my example above:<br></p><p><br>let hello = &quot;Hello Swift&quot;;<br></p><p>print(&quot;\(hello)&quot;);<br></p><p>Works exactly the same as:<br></p><p><br>let hello : String = &quot;Hello Swift&quot;;<br></p><p>print(&quot;\(hello)”);<br></p><p>Removing that typing and the language is indistinguishable from many of the modern scripting languages.<br></p><p><br></p><p>From: Jens Alfke &lt;jens at mooseyard.com&lt;mailto:jens at mooseyard.com&gt;&gt;<br>Date: Wednesday, January 6, 2016 at 6:37 PM<br>To: Andy Satori &lt;dru at druware.com&lt;mailto:dru at druware.com&gt;&gt;<br>Cc: Don Wills &lt;don.wills at portablesoftware.com&lt;mailto:don.wills at portablesoftware.com&gt;&gt;, Donald Pinckney &lt;djpinckney at ucdavis.edu&lt;mailto:djpinckney at ucdavis.edu&gt;&gt;, &quot;swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&quot; &lt;swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&gt;<br>Subject: Re: [swift-users] &quot;business applications market&quot; flame<br></p><p><br>On Jan 6, 2016, at 2:49 PM, Dru Satori &lt;dru at druware.com&lt;mailto:dru at druware.com&gt;&gt; wrote:<br></p><p>It may use LLVM, but it is not a “C” style language, in fact, it feels more like a scripting language than many languages at this level.<br></p><p>I disagree. Scripting languages are pretty universally dynamically-typed, interpreted, and have no visible compile/link stage. Swift isn’t like that at all. The clear ancestors are the C family (including Obj-C), Haskell (IIRC), and to a lesser degree Rust and Go. I don’t see any resemblance to Perl, Ruby, Python, etc.<br></p><p>I agree with the rest of what you’re saying, but it’s pretty obvious. The kinds of business you’re describing are conservative and just use what everyone else uses, and what every developer learns in school. 20 years ago they were probably using C or Pascal, 30 years ago it was probably COBOL. These are not early adopters.<br></p><p>Newer languages tend to fly under the radar for a while. There’s a growing use of Go, for example. (My employer, Couchbase, is using it in several shipping products.) Inside big tech companies like Facebook and Twitter there are all sorts of interesting languages being used internally, from Scala to Haskell. (Go is of course an obvious case of that.)<br></p><p>At this point Swift doesn’t even have a robust cross-platform standard library, so it’s way too early to start trying to sell it as a replacement for Java to enterprise coders. Right now Swift’s practical uses are for building iOS and Mac applications, period. But that’s going to change.<br></p><p>—Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160107/9c7634a4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>&quot;business applications market&quot; flame</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>January  6, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jan 6, 2016, at 4:27 PM, Dru Satori &lt;dru at druware.com&gt; wrote:<br>&gt; <br>&gt; The thing that I see about Swift is that right now, today, on Linux or OS X, if Swift is installed, I can open a terminal: <br>&gt; <br>&gt; Touch hello.swift<br>&gt; vim hello.swift<br>&gt; i <br>&gt; print(&quot;Hello Swift&quot;);<br>&gt; Esc<br>&gt; :wq<br>&gt; swift hello.swift<br></p><p>You can do that with C too:<br></p><p>	touch hello.c<br>	vim hello.c<br>	i<br>	#include &lt;stdio.h&gt;<br>	int main() {printf(“Hello World!”); return 0;}<br>	Esc<br>	:wq<br>	cc hello.c &amp;&amp; ./a.out<br></p><p>Does that make C a scripting language? :)<br></p><p>Having a REPL or playgrounds doesn’t really change what the language itself is; it just indicates good integration of the compiler into the development tools.<br></p><p>To me, what defines a scripting language is a forgiving syntax that lets you bang stuff out fast without worrying about types, and super high level libraries for doing file and text manipulation and running other processes. By contrast, even if I had a C REPL and playgrounds, it would still be a pain to use C to process a directory full of text files and transform their contents and pass that to another tool. Whereas I could do it in minutes with Ruby or bash.<br></p><p>—Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160106/ef7581df/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/936a6a8c18cd1a181cae5de7b818a24d?s=50"></div><header><strong>&quot;business applications market&quot; flame</strong> from <string>Dru Satori</string> &lt;dru at druware.com&gt;<p>January  7, 2016 at 12:00:00am</p></header><div class="content"><p>I would argue that the language syntax is forgiving though, as my follow examples demonstrated.<br></p><p>The funny thing, is that your point about minutes versus hours is the very reason BASIC came to be ( easier math language ). But I think to a degree, we are discussing semantics. It seems we agree on the principle, that Swift is good, but it isn’t there as general purpose business dev language. :)<br></p><p><br></p><p>From: Jens Alfke &lt;jens at mooseyard.com&lt;mailto:jens at mooseyard.com&gt;&gt;<br>Date: Wednesday, January 6, 2016 at 7:40 PM<br>To: Andy Satori &lt;dru at druware.com&lt;mailto:dru at druware.com&gt;&gt;<br>Cc: Don Wills &lt;don.wills at portablesoftware.com&lt;mailto:don.wills at portablesoftware.com&gt;&gt;, Donald Pinckney &lt;djpinckney at ucdavis.edu&lt;mailto:djpinckney at ucdavis.edu&gt;&gt;, &quot;swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&quot; &lt;swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&gt;<br>Subject: Re: [swift-users] &quot;business applications market&quot; flame<br></p><p><br>On Jan 6, 2016, at 4:27 PM, Dru Satori &lt;dru at druware.com&lt;mailto:dru at druware.com&gt;&gt; wrote:<br></p><p>The thing that I see about Swift is that right now, today, on Linux or OS X, if Swift is installed, I can open a terminal:<br></p><p>Touch hello.swift<br>vim hello.swift<br>i<br>print(&quot;Hello Swift&quot;);<br>Esc<br>:wq<br>swift hello.swift<br></p><p>You can do that with C too:<br></p><p>touch hello.c<br>vim hello.c<br>i<br>#include &lt;stdio.h&gt;<br>int main() {printf(“Hello World!”); return 0;}<br>Esc<br>:wq<br>cc hello.c &amp;&amp; ./a.out<br></p><p>Does that make C a scripting language? :)<br></p><p>Having a REPL or playgrounds doesn’t really change what the language itself is; it just indicates good integration of the compiler into the development tools.<br></p><p>To me, what defines a scripting language is a forgiving syntax that lets you bang stuff out fast without worrying about types, and super high level libraries for doing file and text manipulation and running other processes. By contrast, even if I had a C REPL and playgrounds, it would still be a pain to use C to process a directory full of text files and transform their contents and pass that to another tool. Whereas I could do it in minutes with Ruby or bash.<br></p><p>—Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160107/0711bd88/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d925583c31aac9732e2993c42f648380?s=50"></div><header><strong>&quot;business applications market&quot; flame</strong> from <string>Dave Fenton</string> &lt;sirdavidfenton at gmail.com&gt;<p>January  6, 2016 at 07:00:00pm</p></header><div class="content"><p>So far it seems to me that Swift is a powerful &quot;c&quot; type language that can also be used in a script-like way. Definitely a win.  <br></p><p>Hopefully as version 3 gets closer there will have emerged some useful pure swift modules for DB access (Oracle, SQL Server/MongoDB etc)  as well as other middleware.  I&#39;m expecting that IBM will have some good involvement here.<br></p><p>-Dave <br></p><p><br></p><p>&gt; On Jan 6, 2016, at 7:45 PM, Dru Satori via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; I would argue that the language syntax is forgiving though, as my follow examples demonstrated.<br>&gt; <br>&gt; The funny thing, is that your point about minutes versus hours is the very reason BASIC came to be ( easier math language ). But I think to a degree, we are discussing semantics. It seems we agree on the principle, that Swift is good, but it isn’t there as general purpose business dev language. :)<br>&gt; <br>&gt; <br>&gt; <br>&gt; From: Jens Alfke &lt;jens at mooseyard.com&gt;<br>&gt; Date: Wednesday, January 6, 2016 at 7:40 PM<br>&gt; To: Andy Satori &lt;dru at druware.com&gt;<br>&gt; Cc: Don Wills &lt;don.wills at portablesoftware.com&gt;, Donald Pinckney &lt;djpinckney at ucdavis.edu&gt;, &quot;swift-users at swift.org&quot; &lt;swift-users at swift.org&gt;<br>&gt; Subject: Re: [swift-users] &quot;business applications market&quot; flame<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 6, 2016, at 4:27 PM, Dru Satori &lt;dru at druware.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The thing that I see about Swift is that right now, today, on Linux or OS X, if Swift is installed, I can open a terminal: <br>&gt;&gt; <br>&gt;&gt; Touch hello.swift<br>&gt;&gt; vim hello.swift<br>&gt;&gt; i <br>&gt;&gt; print(&quot;Hello Swift&quot;);<br>&gt;&gt; Esc<br>&gt;&gt; :wq<br>&gt;&gt; swift hello.swift<br>&gt; <br>&gt; You can do that with C too:<br>&gt; <br>&gt; touch hello.c<br>&gt; vim hello.c<br>&gt; i<br>&gt; #include &lt;stdio.h&gt;<br>&gt; int main() {printf(“Hello World!”); return 0;}<br>&gt; Esc<br>&gt; :wq<br>&gt; cc hello.c &amp;&amp; ./a.out<br>&gt; <br>&gt; Does that make C a scripting language? :)<br>&gt; <br>&gt; Having a REPL or playgrounds doesn’t really change what the language itself is; it just indicates good integration of the compiler into the development tools.<br>&gt; <br>&gt; To me, what defines a scripting language is a forgiving syntax that lets you bang stuff out fast without worrying about types, and super high level libraries for doing file and text manipulation and running other processes. By contrast, even if  I had a C REPL and playgrounds, it would still be a pain to use C to process a directory full of text files and transform their contents and pass that to another tool. Whereas I could do it in minutes with Ruby or bash.<br>&gt; <br>&gt; —Jens<br>&gt;  <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160106/d36c4925/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/936a6a8c18cd1a181cae5de7b818a24d?s=50"></div><header><strong>&quot;business applications market&quot; flame</strong> from <string>Dru Satori</string> &lt;dru at druware.com&gt;<p>January  7, 2016 at 01:00:00am</p></header><div class="content"><p>Oh, on OS X, swift works fine with PostgreSQL and ODBC datasources via Obj-C frameworks, that isn’t the challenge.<br></p><p>I’ve started porting both of those frameworks to Swift already. There are some ‘challenges’ that are slowing that process down, and even more so, there are some decisions to be made with regards to exception handling and optionals that I am still feeling my way through.<br></p><p>What I’m doing is using those frameworks as a base and building one for TDS databases (Sybase/MSSQL) from the ground up. It is time consuming, and honestly, I’ve made no decision on if I’ll make the code available (as I’ll have a bit of time invested in it, and as a rule DB libraries don’t generate revenue, but sure do generate support requests!)<br></p><p><br>From: Dave Fenton &lt;sirdavidfenton at gmail.com&lt;mailto:sirdavidfenton at gmail.com&gt;&gt;<br>Date: Wednesday, January 6, 2016 at 7:59 PM<br>To: Andy Satori &lt;dru at druware.com&lt;mailto:dru at druware.com&gt;&gt;<br>Cc: Jens Alfke &lt;jens at mooseyard.com&lt;mailto:jens at mooseyard.com&gt;&gt;, &quot;swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&quot; &lt;swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&gt;<br>Subject: Re: [swift-users] &quot;business applications market&quot; flame<br></p><p>So far it seems to me that Swift is a powerful &quot;c&quot; type language that can also be used in a script-like way. Definitely a win.<br></p><p>Hopefully as version 3 gets closer there will have emerged some useful pure swift modules for DB access (Oracle, SQL Server/MongoDB etc)  as well as other middleware.  I&#39;m expecting that IBM will have some good involvement here.<br></p><p>-Dave<br></p><p><br></p><p>On Jan 6, 2016, at 7:45 PM, Dru Satori via swift-users &lt;swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br></p><p>I would argue that the language syntax is forgiving though, as my follow examples demonstrated.<br></p><p>The funny thing, is that your point about minutes versus hours is the very reason BASIC came to be ( easier math language ). But I think to a degree, we are discussing semantics. It seems we agree on the principle, that Swift is good, but it isn’t there as general purpose business dev language. :)<br></p><p><br></p><p>From: Jens Alfke &lt;jens at mooseyard.com&lt;mailto:jens at mooseyard.com&gt;&gt;<br>Date: Wednesday, January 6, 2016 at 7:40 PM<br>To: Andy Satori &lt;dru at druware.com&lt;mailto:dru at druware.com&gt;&gt;<br>Cc: Don Wills &lt;don.wills at portablesoftware.com&lt;mailto:don.wills at portablesoftware.com&gt;&gt;, Donald Pinckney &lt;djpinckney at ucdavis.edu&lt;mailto:djpinckney at ucdavis.edu&gt;&gt;, &quot;swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&quot; &lt;swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&gt;<br>Subject: Re: [swift-users] &quot;business applications market&quot; flame<br></p><p><br>On Jan 6, 2016, at 4:27 PM, Dru Satori &lt;dru at druware.com&lt;mailto:dru at druware.com&gt;&gt; wrote:<br></p><p>The thing that I see about Swift is that right now, today, on Linux or OS X, if Swift is installed, I can open a terminal:<br></p><p>Touch hello.swift<br>vim hello.swift<br>i<br>print(&quot;Hello Swift&quot;);<br>Esc<br>:wq<br>swift hello.swift<br></p><p>You can do that with C too:<br></p><p>touch hello.c<br>vim hello.c<br>i<br>#include &lt;stdio.h&gt;<br>int main() {printf(“Hello World!”); return 0;}<br>Esc<br>:wq<br>cc hello.c &amp;&amp; ./a.out<br></p><p>Does that make C a scripting language? :)<br></p><p>Having a REPL or playgrounds doesn’t really change what the language itself is; it just indicates good integration of the compiler into the development tools.<br></p><p>To me, what defines a scripting language is a forgiving syntax that lets you bang stuff out fast without worrying about types, and super high level libraries for doing file and text manipulation and running other processes. By contrast, even if I had a C REPL and playgrounds, it would still be a pain to use C to process a directory full of text files and transform their contents and pass that to another tool. Whereas I could do it in minutes with Ruby or bash.<br></p><p>—Jens<br></p><p>_______________________________________________<br>swift-users mailing list<br>swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;<br>https://lists.swift.org/mailman/listinfo/swift-users<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160107/60043308/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>&quot;business applications market&quot; flame</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>January  6, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jan 6, 2016, at 5:04 PM, Dru Satori &lt;dru at druware.com&gt; wrote:<br>&gt; <br>&gt; Oh, on OS X, swift works fine with PostgreSQL and ODBC datasources via Obj-C frameworks, that isn’t the challenge.<br></p><p>It would be interesting to see how far Swift’s syntax can be pushed to create a cleaner syntax for queries. I’m thinking of C#’s LINQ, which is really sweet. Some LINQ stuff can be replicated in Swift, I believe, but there are parts of it that rely on a super-powerful C# feature where a function can receive a parameter in the form of a parse tree of the expression. (Sort of like LISP macros.)<br></p><p>—Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160106/ec70281e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/936a6a8c18cd1a181cae5de7b818a24d?s=50"></div><header><strong>&quot;business applications market&quot; flame</strong> from <string>Dru Satori</string> &lt;dru at druware.com&gt;<p>January  7, 2016 at 01:00:00am</p></header><div class="content"><p>Believe it or not, it is on my list of things to explore. I’ve already partially implemented a very rudimentary DataObject for hiding some of the medium lifting in PG (and TSQL, though it’s not public at this time). I’ve been poking at LINQ and thinking about possible ways to implement something similar.<br></p><p><br>From: Jens Alfke &lt;jens at mooseyard.com&lt;mailto:jens at mooseyard.com&gt;&gt;<br>Date: Wednesday, January 6, 2016 at 8:10 PM<br>To: Andy Satori &lt;dru at druware.com&lt;mailto:dru at druware.com&gt;&gt;<br>Cc: Dave Fenton &lt;sirdavidfenton at gmail.com&lt;mailto:sirdavidfenton at gmail.com&gt;&gt;, &quot;swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&quot; &lt;swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&gt;<br>Subject: Re: [swift-users] &quot;business applications market&quot; flame<br></p><p><br>On Jan 6, 2016, at 5:04 PM, Dru Satori &lt;dru at druware.com&lt;mailto:dru at druware.com&gt;&gt; wrote:<br></p><p>Oh, on OS X, swift works fine with PostgreSQL and ODBC datasources via Obj-C frameworks, that isn’t the challenge.<br></p><p>It would be interesting to see how far Swift’s syntax can be pushed to create a cleaner syntax for queries. I’m thinking of C#’s LINQ, which is really sweet. Some LINQ stuff can be replicated in Swift, I believe, but there are parts of it that rely on a super-powerful C# feature where a function can receive a parameter in the form of a parse tree of the expression. (Sort of like LISP macros.)<br></p><p>—Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160107/79a192f6/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>&quot;business applications market&quot; flame</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January  6, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; It would be interesting to see how far Swift’s syntax can be pushed to create a cleaner syntax for queries. I’m thinking of C#’s LINQ, which is really sweet. Some LINQ stuff can be replicated in Swift, I believe, but there are parts of it that rely on a super-powerful C# feature where a function can receive a parameter in the form of a parse tree of the expression. (Sort of like LISP macros.)<br></p><p>Back in the Swift 1 days, I experimented with writing NSPredicates in Swift: &lt;https://github.com/brentdax/PrediKit&gt;<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be09ed656d5d90501c958b001261f218?s=50"></div><header><strong>&quot;business applications market&quot; flame</strong> from <string>Jeremy Pereira</string> &lt;jeremy.j.pereira at googlemail.com&gt;<p>January  7, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On 7 Jan 2016, at 01:10, Jens Alfke via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 6, 2016, at 5:04 PM, Dru Satori &lt;dru at druware.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Oh, on OS X, swift works fine with PostgreSQL and ODBC datasources via Obj-C frameworks, that isn’t the challenge.<br>&gt; <br>&gt; It would be interesting to see how far Swift’s syntax can be pushed to create a cleaner syntax for queries. I’m thinking of C#’s LINQ, which is really sweet. Some LINQ stuff can be replicated in Swift, I believe, but there are parts of it that rely on a super-powerful C# feature where a function can receive a parameter in the form of a parse tree of the expression. (Sort of like LISP macros.)<br></p><p>I got part of the way there. I was able to define a set of classes/enums and operator overrides such that I got to the point where I could write<br></p><p>dbConnection.select([“column1&quot;, “column2”], from: “table”, where: “column3” == SQL.Integer(1) &amp;&amp; “column4” &gt; SQL.Integer(2))<br></p><p>SQL being an enum of the different possible SQL types.<br></p><p>The operators in the where clause did not actually do the and/or/not or comparisons but built up an expression tree that could be serialised into a string version of the where clause for use in a SQL statement.<br></p><p><br>&gt; <br>&gt; —Jens<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7edc0cf41bada7a000ca80712e36a14a?s=50"></div><header><strong>Prototyping what Swift can look like in educational settings</strong> from <string>Tom Sheffler</string> &lt;tom.sheffler at gmail.com&gt;<p>January  6, 2016 at 10:00:00am</p></header><div class="content"><p>Thanks for sharing this playground!  I hadn’t seen anything quite like it, and it’s illuminating some of the possibilities.<br></p><p>&gt; On Jan 5, 2016, at 10:42 PM, Donald Pinckney via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi all,<br>&gt; Personally, I love Swift, and I am curious to see if it will be used in educational settings, not necessarily even CS education.  As something of an experiment to see how Swift could currently look in education, I coded a Swift playground (sorry, very Mac specific right now!) that is a rewriting of a lab activity we did in my 3rd quarter of physics.  For those who are interested in educational aspects of Swift, and have a Mac to run this code, feel free to check out my attached playground, and give any sort of feedback, with respect to either the code or more philosophically where you think Swift could go with education.<br>&gt; <br>&gt; Cheers,<br>&gt; Donald Pinckney<br>&gt; <br>&gt; &lt;Schrödinger.playground&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Prototyping what Swift can look like in educational settings</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>January  6, 2016 at 11:00:00am</p></header><div class="content"><p>Don,<br></p><p>I love your playground. This highlights a few areas where I really would love to see some enhancements from the playground team. Here are a few off the top of my head. My actual list is longer:<br></p><p>* Your students should be able to have an appropriate input and submission component that isn&#39;t compiled -- answering in freeform language to the questions.<br>* Playgrounds need a &quot;reset&quot; button that enable any tweaks to return to a pristine state for starting over.<br>* Playgrounds should offer a &quot;compute this outside&quot; option, that allows you to add code *inside* the pages but have them computed outside. For example in your playground there&#39;s the harmonic oscillator, and a few other number-crunchy stop points.<br>* Playgrounds should be able to integrate video and audio snippets so it&#39;s not just all text text text for lessons<br>* Playgrounds need support for grammar / spelling tests and writing tools.<br>* Playgrounds should also include annotation tools (highlighting, notes) similar to what we see in iBooks as well as snippets/note support for collecting items (both text and code) between lessons<br></p><p>I could go on but I think you get the idea of how great it is to see this kind of development and how far it could be pushed for even better teaching/learning experiences.<br></p><p>-- Erica<br>p.s. I have a book on playgrounds in iBooks, if you want to ping me off-list, I&#39;ll send you a promo code<br></p><p><br></p><p>&gt; On Jan 6, 2016, at 11:32 AM, Tom Sheffler via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Thanks for sharing this playground!  I hadn’t seen anything quite like it, and it’s illuminating some of the possibilities.<br>&gt; <br>&gt;&gt; On Jan 5, 2016, at 10:42 PM, Donald Pinckney via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi all,<br>&gt;&gt; Personally, I love Swift, and I am curious to see if it will be used in educational settings, not necessarily even CS education.  As something of an experiment to see how Swift could currently look in education, I coded a Swift playground (sorry, very Mac specific right now!) that is a rewriting of a lab activity we did in my 3rd quarter of physics.  For those who are interested in educational aspects of Swift, and have a Mac to run this code, feel free to check out my attached playground, and give any sort of feedback, with respect to either the code or more philosophically where you think Swift could go with education.<br>&gt;&gt; <br>&gt;&gt; Cheers,<br>&gt;&gt; Donald Pinckney<br>&gt;&gt; <br>&gt;&gt; &lt;Schrödinger.playground&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0f163c0be9c7f32231614d28b2ceccab?s=50"></div><header><strong>Prototyping what Swift can look like in educational settings</strong> from <string>Donald Pinckney</string> &lt;djpinckney at ucdavis.edu&gt;<p>January  6, 2016 at 01:00:00pm</p></header><div class="content"><p>Hi Erica, and others with feedback,<br></p><p>Thanks for your positive feedback about my playground.  Top of my list for critical features would be what Loïc mentioned, some mathematical notation support inside the playground markdown.  Currently I embedded PDFs which I rendered using LaTeX, but it would be amazing to perhaps have native LaTeX support in playgrounds.<br></p><p>Erica, <br>I really like all your suggestions, and I can certainly feel how they could contribute to creating very interactive learning resources.  I&#39;m not quite understanding the 3rd bullet, but I&#39;m sure it&#39;s just as great of a suggestion as the others ;).<br></p><p>Donald Pinckney<br></p><p>Sent from my iPhone<br></p><p>&gt; On Jan 6, 2016, at 10:48 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; Don,<br>&gt; <br>&gt; I love your playground. This highlights a few areas where I really would love to see some enhancements from the playground team. Here are a few off the top of my head. My actual list is longer:<br>&gt; <br>&gt; * Your students should be able to have an appropriate input and submission component that isn&#39;t compiled -- answering in freeform language to the questions.<br>&gt; * Playgrounds need a &quot;reset&quot; button that enable any tweaks to return to a pristine state for starting over.<br>&gt; * Playgrounds should offer a &quot;compute this outside&quot; option, that allows you to add code *inside* the pages but have them computed outside. For example in your playground there&#39;s the harmonic oscillator, and a few other number-crunchy stop points.<br>&gt; * Playgrounds should be able to integrate video and audio snippets so it&#39;s not just all text text text for lessons<br>&gt; * Playgrounds need support for grammar / spelling tests and writing tools.<br>&gt; * Playgrounds should also include annotation tools (highlighting, notes) similar to what we see in iBooks as well as snippets/note support for collecting items (both text and code) between lessons<br>&gt; <br>&gt; I could go on but I think you get the idea of how great it is to see this kind of development and how far it could be pushed for even better teaching/learning experiences.<br>&gt; <br>&gt; -- Erica<br>&gt; p.s. I have a book on playgrounds in iBooks, if you want to ping me off-list, I&#39;ll send you a promo code<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Jan 6, 2016, at 11:32 AM, Tom Sheffler via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Thanks for sharing this playground!  I hadn’t seen anything quite like it, and it’s illuminating some of the possibilities.<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 5, 2016, at 10:42 PM, Donald Pinckney via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt; Personally, I love Swift, and I am curious to see if it will be used in educational settings, not necessarily even CS education.  As something of an experiment to see how Swift could currently look in education, I coded a Swift playground (sorry, very Mac specific right now!) that is a rewriting of a lab activity we did in my 3rd quarter of physics.  For those who are interested in educational aspects of Swift, and have a Mac to run this code, feel free to check out my attached playground, and give any sort of feedback, with respect to either the code or more philosophically where you think Swift could go with education.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt; Donald Pinckney<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &lt;Schrödinger.playground&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt; swift-users at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4a3b25a47532e94ff5871af45bd74710?s=50"></div><header><strong>Prototyping what Swift can look like in educational settings</strong> from <string>Victor Guerra</string> &lt;vguerra at gmail.com&gt;<p>January  6, 2016 at 10:00:00pm</p></header><div class="content"><p>Thank you for sharing the playground Donald! Great stuff!<br></p><p>On Wed, Jan 6, 2016 at 10:52 PM Donald Pinckney via swift-users &lt;<br>swift-users at swift.org&gt; wrote:<br></p><p>&gt; Hi Erica, and others with feedback,<br>&gt;<br>&gt; Thanks for your positive feedback about my playground.  Top of my list for<br>&gt; critical features would be what Loïc mentioned, some mathematical notation<br>&gt; support inside the playground markdown.  Currently I embedded PDFs which I<br>&gt; rendered using LaTeX, but it would be amazing to perhaps have native LaTeX<br>&gt; support in playgrounds.<br>&gt;<br>&gt; Erica,<br>&gt; I really like all your suggestions, and I can certainly feel how they<br>&gt; could contribute to creating very interactive learning resources.  I&#39;m not<br>&gt; quite understanding the 3rd bullet, but I&#39;m sure it&#39;s just as great of a<br>&gt; suggestion as the others ;).<br>&gt;<br>&gt; Donald Pinckney<br>&gt;<br>&gt; Sent from my iPhone<br>&gt;<br>&gt; &gt; On Jan 6, 2016, at 10:48 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Don,<br>&gt; &gt;<br>&gt; &gt; I love your playground. This highlights a few areas where I really would<br>&gt; love to see some enhancements from the playground team. Here are a few off<br>&gt; the top of my head. My actual list is longer:<br>&gt; &gt;<br>&gt; &gt; * Your students should be able to have an appropriate input and<br>&gt; submission component that isn&#39;t compiled -- answering in freeform language<br>&gt; to the questions.<br>&gt; &gt; * Playgrounds need a &quot;reset&quot; button that enable any tweaks to return to<br>&gt; a pristine state for starting over.<br>&gt; &gt; * Playgrounds should offer a &quot;compute this outside&quot; option, that allows<br>&gt; you to add code *inside* the pages but have them computed outside. For<br>&gt; example in your playground there&#39;s the harmonic oscillator, and a few other<br>&gt; number-crunchy stop points.<br>&gt; &gt; * Playgrounds should be able to integrate video and audio snippets so<br>&gt; it&#39;s not just all text text text for lessons<br>&gt; &gt; * Playgrounds need support for grammar / spelling tests and writing<br>&gt; tools.<br>&gt; &gt; * Playgrounds should also include annotation tools (highlighting, notes)<br>&gt; similar to what we see in iBooks as well as snippets/note support for<br>&gt; collecting items (both text and code) between lessons<br>&gt; &gt;<br>&gt; &gt; I could go on but I think you get the idea of how great it is to see<br>&gt; this kind of development and how far it could be pushed for even better<br>&gt; teaching/learning experiences.<br>&gt; &gt;<br>&gt; &gt; -- Erica<br>&gt; &gt; p.s. I have a book on playgrounds in iBooks, if you want to ping me<br>&gt; off-list, I&#39;ll send you a promo code<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On Jan 6, 2016, at 11:32 AM, Tom Sheffler via swift-users &lt;<br>&gt; swift-users at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Thanks for sharing this playground!  I hadn’t seen anything quite like<br>&gt; it, and it’s illuminating some of the possibilities.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On Jan 5, 2016, at 10:42 PM, Donald Pinckney via swift-users &lt;<br>&gt; swift-users at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Hi all,<br>&gt; &gt;&gt;&gt; Personally, I love Swift, and I am curious to see if it will be used<br>&gt; in educational settings, not necessarily even CS education.  As something<br>&gt; of an experiment to see how Swift could currently look in education, I<br>&gt; coded a Swift playground (sorry, very Mac specific right now!) that is a<br>&gt; rewriting of a lab activity we did in my 3rd quarter of physics.  For those<br>&gt; who are interested in educational aspects of Swift, and have a Mac to run<br>&gt; this code, feel free to check out my attached playground, and give any sort<br>&gt; of feedback, with respect to either the code or more philosophically where<br>&gt; you think Swift could go with education.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Cheers,<br>&gt; &gt;&gt;&gt; Donald Pinckney<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; &lt;Schrödinger.playground&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt; swift-users mailing list<br>&gt; &gt;&gt;&gt; swift-users at swift.org<br>&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-users mailing list<br>&gt; &gt;&gt; swift-users at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt; &gt;<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160106/18fcf855/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Prototyping what Swift can look like in educational settings</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>January  6, 2016 at 07:00:00pm</p></header><div class="content"><p>With regard to bullet 3, playgrounds vastly improve performance when you move code into Sources: http://ericasadun.com/2015/03/16/swift-vroom-vroom-fast-playgrounds/ &lt;http://ericasadun.com/2015/03/16/swift-vroom-vroom-fast-playgrounds/&gt; (but then you can&#39;t see the code or tweak it *in* the playground)<br></p><p>-- Erica<br></p><p><br>&gt; On Jan 6, 2016, at 2:52 PM, Donald Pinckney &lt;djpinckney at ucdavis.edu&gt; wrote:<br>&gt; <br>&gt; Hi Erica, and others with feedback,<br>&gt; <br>&gt; Thanks for your positive feedback about my playground.  Top of my list for critical features would be what Loïc mentioned, some mathematical notation support inside the playground markdown.  Currently I embedded PDFs which I rendered using LaTeX, but it would be amazing to perhaps have native LaTeX support in playgrounds.<br>&gt; <br>&gt; Erica, <br>&gt; I really like all your suggestions, and I can certainly feel how they could contribute to creating very interactive learning resources.  I&#39;m not quite understanding the 3rd bullet, but I&#39;m sure it&#39;s just as great of a suggestion as the others ;).<br>&gt; <br>&gt; Donald Pinckney<br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt;&gt; On Jan 6, 2016, at 10:48 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Don,<br>&gt;&gt; <br>&gt;&gt; I love your playground. This highlights a few areas where I really would love to see some enhancements from the playground team. Here are a few off the top of my head. My actual list is longer:<br>&gt;&gt; <br>&gt;&gt; * Your students should be able to have an appropriate input and submission component that isn&#39;t compiled -- answering in freeform language to the questions.<br>&gt;&gt; * Playgrounds need a &quot;reset&quot; button that enable any tweaks to return to a pristine state for starting over.<br>&gt;&gt; * Playgrounds should offer a &quot;compute this outside&quot; option, that allows you to add code *inside* the pages but have them computed outside. For example in your playground there&#39;s the harmonic oscillator, and a few other number-crunchy stop points.<br>&gt;&gt; * Playgrounds should be able to integrate video and audio snippets so it&#39;s not just all text text text for lessons<br>&gt;&gt; * Playgrounds need support for grammar / spelling tests and writing tools.<br>&gt;&gt; * Playgrounds should also include annotation tools (highlighting, notes) similar to what we see in iBooks as well as snippets/note support for collecting items (both text and code) between lessons<br>&gt;&gt; <br>&gt;&gt; I could go on but I think you get the idea of how great it is to see this kind of development and how far it could be pushed for even better teaching/learning experiences.<br>&gt;&gt; <br>&gt;&gt; -- Erica<br>&gt;&gt; p.s. I have a book on playgrounds in iBooks, if you want to ping me off-list, I&#39;ll send you a promo code<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 6, 2016, at 11:32 AM, Tom Sheffler via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks for sharing this playground!  I hadn’t seen anything quite like it, and it’s illuminating some of the possibilities.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 5, 2016, at 10:42 PM, Donald Pinckney via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt;&gt; Personally, I love Swift, and I am curious to see if it will be used in educational settings, not necessarily even CS education.  As something of an experiment to see how Swift could currently look in education, I coded a Swift playground (sorry, very Mac specific right now!) that is a rewriting of a lab activity we did in my 3rd quarter of physics.  For those who are interested in educational aspects of Swift, and have a Mac to run this code, feel free to check out my attached playground, and give any sort of feedback, with respect to either the code or more philosophically where you think Swift could go with education.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt; Donald Pinckney<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &lt;Schrödinger.playground&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt;&gt; swift-users at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt; swift-users at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160106/274ec999/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
