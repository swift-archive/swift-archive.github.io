<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Discussion] Seal `T.Type` into `Type&lt;T&gt;`</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>July  8, 2016 at 10:00:00pm</p></header><div class="content"><p>Hello Swift community, before Swift 3 drops I’d like to discuss if it is reasonable to consider to create a standalone type to drop/seal the T.Type magic?<br></p><p>However this change does not play well with the proposal of dropping the .self compiler magic.<br></p><p>Some bikeshedding:<br></p><p>public struct Type&lt;T&gt; : Hashable {<br>     <br>    // Seal the `.Type` magic into this standalone type.<br>    // Disallow `.Type` usage elsewhere<br>     <br>    public let sealed: T.Type<br>     <br>    public var hashValue: Int { /* implement somehow */ }<br>     <br>    public init() {<br>         <br>        // Or do it somehow different for the sake of dropping `.self` magic<br>        self.sealed = T.self<br>    }<br>}<br></p><p>public func ==&lt;T&gt;(lhs: Type&lt;T&gt;, rhs: Type&lt;T&gt;) -&gt; Bool {<br>     <br>    return lhs.hashValue == rhs.hashValue<br>}<br>Downside of this approach is the accessibility of the .Type instance:<br></p><p>protocol Initializable {<br>    init()<br>}<br></p><p>func foo&lt;T : Initializable&gt;(type: Type&lt;T&gt;) -&gt; T {<br>     <br>    // It would be nice if we could use `type.init()` instead, but than we<br>    // would need more compiler magic :/<br>    return type.sealed.init()<br>}<br>I couldn’t come up with a better name than sealed, if anyone has a better idea feel free to share your thoughts.<br></p><p>Remember this is a discussion and not (yet) a detailed proposal, where everyone can provide feedback and bikeshedding for a better design.<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160708/1796bb16/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Discussion] Seal `T.Type` into `Type&lt;T&gt;`</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>July  9, 2016 at 11:00:00am</p></header><div class="content"><p>Here are a few more thoughts on solving a few problems with dropped .self in mind:<br></p><p>Type&lt;SomeType&gt; cannot become Type&lt;Type&lt;SomeType&gt;&gt; to prevent infinite recursion.<br></p><p>Any other type without the short form for initializer SomeType(...) or explicit access to static members or initializer like SomeType.init(...) or SomeType.staticMember will be automatically become Type&lt;SomeType&gt; - if it’s not part of an array or dictionary shorthand syntax.<br></p><p>For array and dictionary shorthand syntax any type (except other nested array and dictionary shorthand types) does not follow the second rule from above (dropped .self in mind):<br></p><p>[SomeType]() equals Array&lt;SomeType&gt;()<br>[Type&lt;SomeType&gt;]() equals Array&lt;Type&lt;SomeType&gt;&gt;()<br>[SomeKeyType: SomeValueType]() equals Dictionary&lt;SomeKeyType, SomeValueType&gt;()<br>[Type&lt;SomeKeyType&gt;: Type&lt;SomeValueType&gt;]() equals Dictionary&lt;Type&lt;SomeKeyType&gt;, Type&lt;SomeValueType&gt;&gt;()<br>We also could extend Type&lt;T&gt; to provide more useful informations:<br></p><p>public struct Type&lt;T&gt; : Hashable, CustomStringConvertible, CustomDebugStringConvertible {<br>      <br>    // Anyone knows a better name?<br>    public let sealed: T.Type<br>      <br>    public var hashValue: Int { /* implement */ }<br>     <br>    // Inspired by SE-0101<br>    public var size: Int { /* implement */ }<br>    public var stride: Int { /* implement */ }<br>    public var alignment: Int { /* implement */ }<br>     <br>    public var description: String { /* implement */ }<br>     <br>    public var debugDescription: String { /* implement */ }<br>      <br>    public init() { /* implement */ }<br>}<br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 8. Juli 2016 um 22:06:30, Adrian Zubarev (adrian.zubarev at devandartist.com) schrieb:<br></p><p>Hello Swift community, before Swift 3 drops I’d like to discuss if it is reasonable to consider to create a standalone type to drop/seal the T.Type magic?<br></p><p>However this change does not play well with the proposal of dropping the .self compiler magic.<br></p><p>Some bikeshedding:<br></p><p>public struct Type&lt;T&gt; : Hashable {<br>      <br>    // Seal the `.Type` magic into this standalone type.<br>    // Disallow `.Type` usage elsewhere<br>      <br>    public let sealed: T.Type<br>      <br>    public var hashValue: Int { /* implement somehow */ }<br>      <br>    public init() {<br>          <br>        // Or do it somehow different for the sake of dropping `.self` magic<br>        self.sealed = T.self<br>    }<br>}<br></p><p>public func ==&lt;T&gt;(lhs: Type&lt;T&gt;, rhs: Type&lt;T&gt;) -&gt; Bool {<br>      <br>    return lhs.hashValue == rhs.hashValue<br>}<br>Downside of this approach is the accessibility of the .Type instance:<br></p><p>protocol Initializable {<br>    init()<br>}<br></p><p>func foo&lt;T : Initializable&gt;(type: Type&lt;T&gt;) -&gt; T {<br>      <br>    // It would be nice if we could use `type.init()` instead, but than we<br>    // would need more compiler magic :/<br>    return type.sealed.init()<br>}<br>I couldn’t come up with a better name than sealed, if anyone has a better idea feel free to share your thoughts.<br></p><p>Remember this is a discussion and not (yet) a detailed proposal, where everyone can provide feedback and bikeshedding for a better design.<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160709/67ea48f6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Discussion] Seal `T.Type` into `Type&lt;T&gt;`</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>July  9, 2016 at 12:00:00pm</p></header><div class="content"><p>Correcting the function from the very first post:<br></p><p>public func ==&lt;T, U&gt;(lhs: Type&lt;T&gt;, rhs: Type&lt;U&gt;) -&gt; Bool {<br>      <br>    return lhs.hashValue == rhs.hashValue<br>}<br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 9. Juli 2016 um 11:55:00, Adrian Zubarev (adrian.zubarev at devandartist.com) schrieb:<br></p><p>Here are a few more thoughts on solving a few problems with dropped .self in mind:<br></p><p>Type&lt;SomeType&gt; cannot become Type&lt;Type&lt;SomeType&gt;&gt; to prevent infinite recursion.<br></p><p>Any other type without the short form for initializer SomeType(...) or explicit access to static members or initializer like SomeType.init(...) or SomeType.staticMember will be automatically become Type&lt;SomeType&gt; - if it’s not part of an array or dictionary shorthand syntax.<br></p><p>For array and dictionary shorthand syntax any type (except other nested array and dictionary shorthand types) does not follow the second rule from above (dropped .self in mind):<br></p><p>[SomeType]() equals Array&lt;SomeType&gt;()<br>[Type&lt;SomeType&gt;]() equals Array&lt;Type&lt;SomeType&gt;&gt;()<br>[SomeKeyType: SomeValueType]() equals Dictionary&lt;SomeKeyType, SomeValueType&gt;()<br>[Type&lt;SomeKeyType&gt;: Type&lt;SomeValueType&gt;]() equals Dictionary&lt;Type&lt;SomeKeyType&gt;, Type&lt;SomeValueType&gt;&gt;()<br>We also could extend Type&lt;T&gt; to provide more useful informations:<br></p><p>public struct Type&lt;T&gt; : Hashable, CustomStringConvertible, CustomDebugStringConvertible {<br>       <br>    // Anyone knows a better name?<br>    public let sealed: T.Type<br>       <br>    public var hashValue: Int { /* implement */ }<br>      <br>    // Inspired by SE-0101<br>    public var size: Int { /* implement */ }<br>    public var stride: Int { /* implement */ }<br>    public var alignment: Int { /* implement */ }<br>      <br>    public var description: String { /* implement */ }<br>      <br>    public var debugDescription: String { /* implement */ }<br>       <br>    public init() { /* implement */ }<br>}<br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 8. Juli 2016 um 22:06:30, Adrian Zubarev (adrian.zubarev at devandartist.com) schrieb:<br></p><p>Hello Swift community, before Swift 3 drops I’d like to discuss if it is reasonable to consider to create a standalone type to drop/seal the T.Type magic?<br></p><p>However this change does not play well with the proposal of dropping the .self compiler magic.<br></p><p>Some bikeshedding:<br></p><p>public struct Type&lt;T&gt; : Hashable {<br>       <br>    // Seal the `.Type` magic into this standalone type.<br>    // Disallow `.Type` usage elsewhere<br>       <br>    public let sealed: T.Type<br>       <br>    public var hashValue: Int { /* implement somehow */ }<br>       <br>    public init() {<br>           <br>        // Or do it somehow different for the sake of dropping `.self` magic<br>        self.sealed = T.self<br>    }<br>}<br></p><p>public func ==&lt;T&gt;(lhs: Type&lt;T&gt;, rhs: Type&lt;T&gt;) -&gt; Bool {<br>       <br>    return lhs.hashValue == rhs.hashValue<br>}<br>Downside of this approach is the accessibility of the .Type instance:<br></p><p>protocol Initializable {<br>    init()<br>}<br></p><p>func foo&lt;T : Initializable&gt;(type: Type&lt;T&gt;) -&gt; T {<br>       <br>    // It would be nice if we could use `type.init()` instead, but than we<br>    // would need more compiler magic :/<br>    return type.sealed.init()<br>}<br>I couldn’t come up with a better name than sealed, if anyone has a better idea feel free to share your thoughts.<br></p><p>Remember this is a discussion and not (yet) a detailed proposal, where everyone can provide feedback and bikeshedding for a better design.<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160709/d1e7daf1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Discussion] Seal `T.Type` into `Type&lt;T&gt;`</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>July  9, 2016 at 01:00:00pm</p></header><div class="content"><p>Currently I could implement the whole type like this:<br></p><p>public struct Type&lt;T&gt; : Hashable, CustomStringConvertible, CustomDebugStringConvertible {<br>     <br>    // Anyone knows a better name?<br>    public let sealed: T.Type = T.self<br>     <br>    public let hashValue: Int = ObjectIdentifier(T.self).hashValue<br>     <br>    // Inspired by SE-0101<br>    public static var size: Int { return sizeof(T.self) }<br>    public static var stride: Int { return strideof(T.self) }<br>    public static var alignment: Int { return alignof(T.self) }<br>     <br>    public var size: Int { return Type&lt;T&gt;.size }<br>    public var stride: Int { return Type&lt;T&gt;.stride }<br>    public var alignment: Int { return Type&lt;T&gt;.alignment }<br>     <br>    public var description: String { return &quot;Type&lt;\(self.sealed)&gt;&quot; }<br>     <br>    public var debugDescription: String {<br>        return &quot;&lt;&quot; + self.description + &quot; size: \(self.size) stride: \(self.stride) alignment: \(self.alignment)&gt;&quot;<br>    }<br>}<br></p><p>public func ==&lt;T, U&gt;(lhs: Type&lt;T&gt;, rhs: Type&lt;U&gt;) -&gt; Bool {<br>     <br>    return lhs.hashValue == rhs.hashValue<br>}<br>I also added static computed properties to access the the memory layout without any initialization.<br></p><p>Type&lt;Int&gt;.size reads really great to me.<br></p><p>I’m curious about the feedback from the Swift community. :)<br></p><p>PS: All my replies are markdown formatted. If anyone can’t read them, here is a formatted gist: https://gist.github.com/DevAndArtist/c35284ac12806c13eff302d1cf347ac8<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 9. Juli 2016 um 12:03:39, Adrian Zubarev (adrian.zubarev at devandartist.com) schrieb:<br></p><p>Correcting the function from the very first post:<br></p><p>public func ==&lt;T, U&gt;(lhs: Type&lt;T&gt;, rhs: Type&lt;U&gt;) -&gt; Bool {<br>       <br>    return lhs.hashValue == rhs.hashValue<br>}<br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 9. Juli 2016 um 11:55:00, Adrian Zubarev (adrian.zubarev at devandartist.com) schrieb:<br></p><p>Here are a few more thoughts on solving a few problems with dropped .self in mind:<br></p><p>Type&lt;SomeType&gt; cannot become Type&lt;Type&lt;SomeType&gt;&gt; to prevent infinite recursion.<br></p><p>Any other type without the short form for initializer SomeType(...) or explicit access to static members or initializer like SomeType.init(...) or SomeType.staticMember will be automatically become Type&lt;SomeType&gt; - if it’s not part of an array or dictionary shorthand syntax.<br></p><p>For array and dictionary shorthand syntax any type (except other nested array and dictionary shorthand types) does not follow the second rule from above (dropped .self in mind):<br></p><p>[SomeType]() equals Array&lt;SomeType&gt;()<br>[Type&lt;SomeType&gt;]() equals Array&lt;Type&lt;SomeType&gt;&gt;()<br>[SomeKeyType: SomeValueType]() equals Dictionary&lt;SomeKeyType, SomeValueType&gt;()<br>[Type&lt;SomeKeyType&gt;: Type&lt;SomeValueType&gt;]() equals Dictionary&lt;Type&lt;SomeKeyType&gt;, Type&lt;SomeValueType&gt;&gt;()<br>We also could extend Type&lt;T&gt; to provide more useful informations:<br></p><p>public struct Type&lt;T&gt; : Hashable, CustomStringConvertible, CustomDebugStringConvertible {<br>        <br>    // Anyone knows a better name?<br>    public let sealed: T.Type<br>        <br>    public var hashValue: Int { /* implement */ }<br>       <br>    // Inspired by SE-0101<br>    public var size: Int { /* implement */ }<br>    public var stride: Int { /* implement */ }<br>    public var alignment: Int { /* implement */ }<br>       <br>    public var description: String { /* implement */ }<br>       <br>    public var debugDescription: String { /* implement */ }<br>        <br>    public init() { /* implement */ }<br>}<br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 8. Juli 2016 um 22:06:30, Adrian Zubarev (adrian.zubarev at devandartist.com) schrieb:<br></p><p>Hello Swift community, before Swift 3 drops I’d like to discuss if it is reasonable to consider to create a standalone type to drop/seal the T.Type magic?<br></p><p>However this change does not play well with the proposal of dropping the .self compiler magic.<br></p><p>Some bikeshedding:<br></p><p>public struct Type&lt;T&gt; : Hashable {<br>        <br>    // Seal the `.Type` magic into this standalone type.<br>    // Disallow `.Type` usage elsewhere<br>        <br>    public let sealed: T.Type<br>        <br>    public var hashValue: Int { /* implement somehow */ }<br>        <br>    public init() {<br>            <br>        // Or do it somehow different for the sake of dropping `.self` magic<br>        self.sealed = T.self<br>    }<br>}<br></p><p>public func ==&lt;T&gt;(lhs: Type&lt;T&gt;, rhs: Type&lt;T&gt;) -&gt; Bool {<br>        <br>    return lhs.hashValue == rhs.hashValue<br>}<br>Downside of this approach is the accessibility of the .Type instance:<br></p><p>protocol Initializable {<br>    init()<br>}<br></p><p>func foo&lt;T : Initializable&gt;(type: Type&lt;T&gt;) -&gt; T {<br>        <br>    // It would be nice if we could use `type.init()` instead, but than we<br>    // would need more compiler magic :/<br>    return type.sealed.init()<br>}<br>I couldn’t come up with a better name than sealed, if anyone has a better idea feel free to share your thoughts.<br></p><p>Remember this is a discussion and not (yet) a detailed proposal, where everyone can provide feedback and bikeshedding for a better design.<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160709/f625774a/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Discussion] Seal `T.Type` into `Type&lt;T&gt;`</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>July  9, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jul 8, 2016, at 1:06 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community, before Swift 3 drops I’d like to discuss if it is reasonable to consider to create a standalone type to drop/seal the T.Type magic?<br>&gt; <br>Hi Adrian,<br></p><p>What’s the motivation for this change?<br></p><p>-Chris<br></p><p>&gt; However this change does not play well with the proposal of dropping the .self compiler magic.<br>&gt; <br>&gt; Some bikeshedding:<br>&gt; <br>&gt; public struct Type&lt;T&gt; : Hashable {<br>&gt;      <br>&gt;     // Seal the `.Type` magic into this standalone type.<br>&gt;     // Disallow `.Type` usage elsewhere<br>&gt;      <br>&gt;     public let sealed: T.Type<br>&gt;      <br>&gt;     public var hashValue: Int { /* implement somehow */ }<br>&gt;      <br>&gt;     public init() {<br>&gt;          <br>&gt;         // Or do it somehow different for the sake of dropping `.self` magic<br>&gt;         self.sealed = T.self<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; public func ==&lt;T&gt;(lhs: Type&lt;T&gt;, rhs: Type&lt;T&gt;) -&gt; Bool {<br>&gt;      <br>&gt;     return lhs.hashValue == rhs.hashValue<br>&gt; }<br>&gt; Downside of this approach is the accessibility of the .Type instance:<br>&gt; <br>&gt; protocol Initializable {<br>&gt;     init()<br>&gt; }<br>&gt; <br>&gt; func foo&lt;T : Initializable&gt;(type: Type&lt;T&gt;) -&gt; T {<br>&gt;      <br>&gt;     // It would be nice if we could use `type.init()` instead, but than we<br>&gt;     // would need more compiler magic :/<br>&gt;     return type.sealed.init()<br>&gt; }<br>&gt; I couldn’t come up with a better name than sealed, if anyone has a better idea feel free to share your thoughts.<br>&gt; <br>&gt; Remember this is a discussion and not (yet) a detailed proposal, where everyone can provide feedback and bikeshedding for a better design.<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160709/96432452/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Discussion] Seal `T.Type` into `Type&lt;T&gt;`</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>July 10, 2016 at 02:00:00pm</p></header><div class="content"><p>Hello Chris,<br></p><p>my main concern for this change is the lack of extensibility of metatypes. We can access the metatype through the .self postfix, which potentially will be removed in the future (only the postfix). Through an instance of such a metatype we can then access the static members and all initializer for our type.<br></p><p>SomeType.staticMember equals metatypeInstance.staticMemeber<br>SomeType.init equals metatypeInstance.init<br>It is also possible to extract some more information from the metatypes with the help of Buildin wrapper functions like sizeof or strideof. And the last but not the least we can use metatypes in type checking scenarios.<br></p><p>Last weak I asked the community if there is a need for all metatypes conform to the Hashable protocol, which would be really handy. The overall response was positive, even if only a handful of people responded.<br></p><p>The whole idea of metatypes conforming to Hashable kept me thinking how this might be solved in the future. The main problem is that metatypes provide direct access to initializer and static members of the type and a conformance to Hashable seems to be impossible without some compiler magic or a hidden hashValue property. The main confusion here might be that metatypes can be stored (at least while runtime) inside variables and pretend to be instances of a T.Type type.<br></p><p>That said, I’d like to consider of sealing the direct access to a metatype into a real type for the sake of extensibility and clarity.<br></p><p>I’m aware that my bikeshedding introduced more boilerplate in terms of accessing the initializer and static members through a bottleneck property called sealed. Furthermore there is one more character to type if we’d go with Type&lt;T&gt; instead of T.Type.<br></p><p>This is why this is a discussion before making any further decisions. :)<br></p><p>PS: As I showed in my last code example a wrapper type Type&lt;T&gt; can also provide a few more information about the metatype.<br></p><p>Type&lt;T&gt;.size<br>Type&lt;T&gt;.stride<br>Type&lt;T&gt;.alignment<br>Furthermore sealing T.Type into Type&lt;T&gt; does solve the problem with the array/dictionary shorthand syntax.<br></p><p>Only when one would store/pass a type (name) we’d implicitly convert SomeType to Type&lt;SomeType&gt;.<br></p><p>Declarations do not follow this implicit conversion:<br></p><p>func foo(_: SomeType) is not equivalent to func foo(_: Type&lt;SomeType&gt;)<br>Array&lt;SomeType&gt;() == [SomeType]() but is not equivalent to [Type&lt;SomeType&gt;]() == Array&lt;Type&lt;SomeType&gt;&gt;()<br>Here is again my bikeshedding:<br></p><p>public struct Type&lt;T&gt; : Hashable, CustomStringConvertible, CustomDebugStringConvertible {<br>     <br>    // `metatype` is a better name than `sealed`<br>    // The tradeoff is this bottleneck property<br></p><p>    public let metatype: T.Type<br>      <br>    public let hashValue: Int<br>      <br>    public static var size: Int { get }<br>    public static var stride: Int { get }<br>    public static var alignment: Int { get }<br>      <br>    public var size: Int { get }<br>    public var stride: Int { get }<br>    public var alignment: Int { get }<br>      <br>    public var description: String { get }<br>    public var debugDescription: String { get }<br>}<br></p><p>public func ==&lt;T, U&gt;(lhs: Type&lt;T&gt;, rhs: Type&lt;U&gt;) -&gt; Bool<br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 10. Juli 2016 um 00:18:02, Chris Lattner (clattner at apple.com) schrieb:<br></p><p>Hi Adrian,<br></p><p>What’s the motivation for this change?<br></p><p>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160710/80c0bf5c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Discussion] Seal `T.Type` into `Type&lt;T&gt;`</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>July 10, 2016 at 04:00:00pm</p></header><div class="content"><p>It looks like this is touching on a small subset of the not-yet-designed reflection API (still tabled for 4.0?). I am interested to see what balance it strikes between declarations (eg. being able to reflect extensions declarations), types (eg reflecting type conformance), and operations (xxx.newInstance(), xxx.setValue()). The mirror api shows a general direction, maybe there is a way to squeeze a tiny subset in 3.0 (just like was done with P&amp;Q that will remain a degenerate case of the upcoming more general syntax). Maybe just enough for people not to have to use ObjectIdentifier(:Any.Type).<br></p><p>Regards<br>(From mobile)<br></p><p>&gt; On Jul 10, 2016, at 2:22 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Chris,<br>&gt; <br>&gt; my main concern for this change is the lack of extensibility of metatypes. We can access the metatype through the .self postfix, which potentially will be removed in the future (only the postfix). Through an instance of such a metatype we can then access the static members and all initializer for our type.<br>&gt; <br>&gt; SomeType.staticMember equals metatypeInstance.staticMemeber<br>&gt; SomeType.init equals metatypeInstance.init<br>&gt; It is also possible to extract some more information from the metatypes with the help of Buildin wrapper functions like sizeof or strideof. And the last but not the least we can use metatypes in type checking scenarios.<br>&gt; <br>&gt; Last weak I asked the community if there is a need for all metatypes conform to the Hashable protocol, which would be really handy. The overall response was positive, even if only a handful of people responded.<br>&gt; <br>&gt; The whole idea of metatypes conforming to Hashable kept me thinking how this might be solved in the future. The main problem is that metatypes provide direct access to initializer and static members of the type and a conformance to Hashable seems to be impossible without some compiler magic or a hidden hashValue property. The main confusion here might be that metatypes can be stored (at least while runtime) inside variables and pretend to be instances of a T.Type type.<br>&gt; <br>&gt; That said, I’d like to consider of sealing the direct access to a metatype into a real type for the sake of extensibility and clarity.<br>&gt; <br>&gt; I’m aware that my bikeshedding introduced more boilerplate in terms of accessing the initializer and static members through a bottleneck property called sealed. Furthermore there is one more character to type if we’d go with Type&lt;T&gt; instead of T.Type.<br>&gt; <br>&gt; This is why this is a discussion before making any further decisions. :)<br>&gt; <br>&gt; PS: As I showed in my last code example a wrapper type Type&lt;T&gt; can also provide a few more information about the metatype.<br>&gt; <br>&gt; Type&lt;T&gt;.size<br>&gt; Type&lt;T&gt;.stride<br>&gt; Type&lt;T&gt;.alignment<br>&gt; Furthermore sealing T.Type into Type&lt;T&gt; does solve the problem with the array/dictionary shorthand syntax.<br>&gt; <br>&gt; Only when one would store/pass a type (name) we’d implicitly convert SomeType to Type&lt;SomeType&gt;.<br>&gt; <br>&gt; Declarations do not follow this implicit conversion:<br>&gt; <br>&gt; func foo(_: SomeType) is not equivalent to func foo(_: Type&lt;SomeType&gt;)<br>&gt; Array&lt;SomeType&gt;() == [SomeType]() but is not equivalent to [Type&lt;SomeType&gt;]() == Array&lt;Type&lt;SomeType&gt;&gt;()<br>&gt; Here is again my bikeshedding:<br>&gt; <br>&gt; public struct Type&lt;T&gt; : Hashable, CustomStringConvertible, CustomDebugStringConvertible {<br>&gt;      <br>&gt;     // `metatype` is a better name than `sealed`<br>&gt;     // The tradeoff is this bottleneck property<br>&gt; <br>&gt;     public let metatype: T.Type<br>&gt;       <br>&gt;     public let hashValue: Int<br>&gt;       <br>&gt;     public static var size: Int { get }<br>&gt;     public static var stride: Int { get }<br>&gt;     public static var alignment: Int { get }<br>&gt;       <br>&gt;     public var size: Int { get }<br>&gt;     public var stride: Int { get }<br>&gt;     public var alignment: Int { get }<br>&gt;       <br>&gt;     public var description: String { get }<br>&gt;     public var debugDescription: String { get }<br>&gt; }<br>&gt; <br>&gt; public func ==&lt;T, U&gt;(lhs: Type&lt;T&gt;, rhs: Type&lt;U&gt;) -&gt; Bool<br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; Am 10. Juli 2016 um 00:18:02, Chris Lattner (clattner at apple.com) schrieb:<br>&gt; <br>&gt;&gt; Hi Adrian,<br>&gt;&gt; <br>&gt;&gt; What’s the motivation for this change?<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160710/7d47596f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Discussion] Seal `T.Type` into `Type&lt;T&gt;`</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>July 10, 2016 at 05:00:00pm</p></header><div class="content"><p>Can you point me to some reading? I’m curious what exactly you’re talking about!?<br></p><p>—<br></p><p>I found a negative side effect of sealing T.Type. The problem appears lies in the dynamic is cast.<br></p><p>Currently we could do something like this:<br></p><p>func isInt&lt;T&gt;(metatype: T.Type) -&gt; Bool {<br>     <br>    return metatype is Int.Type<br>}<br>There is no way to express the same type check with Type&lt;T&gt; except this:<br></p><p>func isInt&lt;T&gt;(type: Type&lt;T&gt;) -&gt; Bool {<br>     <br>    return type == Type&lt;Int&gt;()<br>     <br>    // since this check is something where we store/pass a type (name)<br>    // we could implicitly convert `Int` into an instance of `Type&lt;Int&gt;`<br>    //<br>    // The result would look like this:<br>     <br>    return type == Int // which is logically equivalent to `metatype is Int.Type`<br>}<br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 10. Juli 2016 um 16:24:50, L. Mihalkovic (laurent.mihalkovic at gmail.com) schrieb:<br></p><p><br>It looks like this is touching on a small subset of the not-yet-designed reflection API (still tabled for 4.0?). I am interested to see what balance it strikes between declarations (eg. being able to reflect extensions declarations), types (eg reflecting type conformance), and operations (xxx.newInstance(), xxx.setValue()). The mirror api shows a general direction, maybe there is a way to squeeze a tiny subset in 3.0 (just like was done with P&amp;Q that will remain a degenerate case of the upcoming more general syntax). Maybe just enough for people not to have to use ObjectIdentifier(:Any.Type).<br></p><p>Regards<br>(From mobile)<br></p><p>On Jul 10, 2016, at 2:22 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>Hello Chris,<br></p><p>my main concern for this change is the lack of extensibility of metatypes. We can access the metatype through the .self postfix, which potentially will be removed in the future (only the postfix). Through an instance of such a metatype we can then access the static members and all initializer for our type.<br></p><p>SomeType.staticMember equals metatypeInstance.staticMemeber<br>SomeType.init equals metatypeInstance.init<br>It is also possible to extract some more information from the metatypes with the help of Buildin wrapper functions like sizeof or strideof. And the last but not the least we can use metatypes in type checking scenarios.<br></p><p>Last weak I asked the community if there is a need for all metatypes conform to the Hashable protocol, which would be really handy. The overall response was positive, even if only a handful of people responded.<br></p><p>The whole idea of metatypes conforming to Hashable kept me thinking how this might be solved in the future. The main problem is that metatypes provide direct access to initializer and static members of the type and a conformance to Hashable seems to be impossible without some compiler magic or a hidden hashValue property. The main confusion here might be that metatypes can be stored (at least while runtime) inside variables and pretend to be instances of a T.Type type.<br></p><p>That said, I’d like to consider of sealing the direct access to a metatype into a real type for the sake of extensibility and clarity.<br></p><p>I’m aware that my bikeshedding introduced more boilerplate in terms of accessing the initializer and static members through a bottleneck property called sealed. Furthermore there is one more character to type if we’d go with Type&lt;T&gt; instead of T.Type.<br></p><p>This is why this is a discussion before making any further decisions. :)<br></p><p>PS: As I showed in my last code example a wrapper type Type&lt;T&gt; can also provide a few more information about the metatype.<br></p><p>Type&lt;T&gt;.size<br>Type&lt;T&gt;.stride<br>Type&lt;T&gt;.alignment<br>Furthermore sealing T.Type into Type&lt;T&gt; does solve the problem with the array/dictionary shorthand syntax.<br></p><p>Only when one would store/pass a type (name) we’d implicitly convert SomeType to Type&lt;SomeType&gt;.<br></p><p>Declarations do not follow this implicit conversion:<br></p><p>func foo(_: SomeType) is not equivalent to func foo(_: Type&lt;SomeType&gt;)<br>Array&lt;SomeType&gt;() == [SomeType]() but is not equivalent to [Type&lt;SomeType&gt;]() == Array&lt;Type&lt;SomeType&gt;&gt;()<br>Here is again my bikeshedding:<br></p><p>public struct Type&lt;T&gt; : Hashable, CustomStringConvertible, CustomDebugStringConvertible {<br>      <br>    // `metatype` is a better name than `sealed`<br>    // The tradeoff is this bottleneck property<br></p><p>    public let metatype: T.Type<br>       <br>    public let hashValue: Int<br>       <br>    public static var size: Int { get }<br>    public static var stride: Int { get }<br>    public static var alignment: Int { get }<br>       <br>    public var size: Int { get }<br>    public var stride: Int { get }<br>    public var alignment: Int { get }<br>       <br>    public var description: String { get }<br>    public var debugDescription: String { get }<br>}<br></p><p>public func ==&lt;T, U&gt;(lhs: Type&lt;T&gt;, rhs: Type&lt;U&gt;) -&gt; Bool<br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 10. Juli 2016 um 00:18:02, Chris Lattner (clattner at apple.com) schrieb:<br></p><p>Hi Adrian,<br></p><p>What’s the motivation for this change?<br></p><p>-Chris<br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160710/8c4fa607/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Discussion] Seal `T.Type` into `Type&lt;T&gt;`</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>July 10, 2016 at 06:00:00pm</p></header><div class="content"><p>Just to be crystal clear, here is my vision.<br></p><p>Currently Swift is heading in this direction:<br></p><p>SomeType.staticMember == metatypeInstance.staticMember == SomeType.self.staticMember<br>SomeType.init == metatypeInstance.init == SomeType.self.init<br></p><p>SomeType.self -&gt; SomeType.Type (metatype)<br></p><p>SomeType -&gt; SomeType.Type (removed .self)<br></p><p>SomeType.self is SomeType.Type == true<br></p><p>func foo&lt;T&gt;(metatype: T.Type) -&gt; T {<br>     <br>    // lets pretend T conforms to an initializable protocol  <br>    return metatype.init()  <br>}<br>With some tweaking and a little tradeoff for Type&lt;T&gt; we’d get this model:<br></p><p>SomeType.staticMember == Type&lt;SomeType&gt;.metatype.staticMember<br>SomeType.init == Type&lt;SomeType&gt;.metatype.init<br></p><p>SomeType -&gt; Type&lt;SomeType&gt;() (initialized instance; removed .self)<br></p><p>SomeType == Type&lt;SomeType&gt;() == true<br></p><p>SomeType is Type&lt;SomeType&gt;() == true<br></p><p>func foo&lt;T&gt;(type: Type&lt;T&gt;) -&gt; T {<br>     <br>    print(type.size)<br>    print(type.debugDescription)<br>    print(type.hashValue)<br>     <br>    // lets pretend T conforms to an initializable protocol  <br>    return type.metatype.init()  <br>}<br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 10. Juli 2016 um 17:28:35, Adrian Zubarev (adrian.zubarev at devandartist.com) schrieb:<br></p><p>Can you point me to some reading? I’m curious what exactly you’re talking about!?<br></p><p>—<br></p><p>I found a negative side effect of sealing T.Type. The problem appears lies in the dynamic is cast.<br></p><p>Currently we could do something like this:<br></p><p>func isInt&lt;T&gt;(metatype: T.Type) -&gt; Bool {<br>      <br>    return metatype is Int.Type<br>}<br>There is no way to express the same type check with Type&lt;T&gt; except this:<br></p><p>func isInt&lt;T&gt;(type: Type&lt;T&gt;) -&gt; Bool {<br>      <br>    return type == Type&lt;Int&gt;()<br>      <br>    // since this check is something where we store/pass a type (name)<br>    // we could implicitly convert `Int` into an instance of `Type&lt;Int&gt;`<br>    //<br>    // The result would look like this:<br>      <br>    return type == Int // which is logically equivalent to `metatype is Int.Type`<br>}<br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 10. Juli 2016 um 16:24:50, L. Mihalkovic (laurent.mihalkovic at gmail.com) schrieb:<br></p><p><br>It looks like this is touching on a small subset of the not-yet-designed reflection API (still tabled for 4.0?). I am interested to see what balance it strikes between declarations (eg. being able to reflect extensions declarations), types (eg reflecting type conformance), and operations (xxx.newInstance(), xxx.setValue()). The mirror api shows a general direction, maybe there is a way to squeeze a tiny subset in 3.0 (just like was done with P&amp;Q that will remain a degenerate case of the upcoming more general syntax). Maybe just enough for people not to have to use ObjectIdentifier(:Any.Type).<br></p><p>Regards<br>(From mobile)<br></p><p>On Jul 10, 2016, at 2:22 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>Hello Chris,<br></p><p>my main concern for this change is the lack of extensibility of metatypes. We can access the metatype through the .self postfix, which potentially will be removed in the future (only the postfix). Through an instance of such a metatype we can then access the static members and all initializer for our type.<br></p><p>SomeType.staticMember equals metatypeInstance.staticMemeber<br>SomeType.init equals metatypeInstance.init<br>It is also possible to extract some more information from the metatypes with the help of Buildin wrapper functions like sizeof or strideof. And the last but not the least we can use metatypes in type checking scenarios.<br></p><p>Last weak I asked the community if there is a need for all metatypes conform to the Hashable protocol, which would be really handy. The overall response was positive, even if only a handful of people responded.<br></p><p>The whole idea of metatypes conforming to Hashable kept me thinking how this might be solved in the future. The main problem is that metatypes provide direct access to initializer and static members of the type and a conformance to Hashable seems to be impossible without some compiler magic or a hidden hashValue property. The main confusion here might be that metatypes can be stored (at least while runtime) inside variables and pretend to be instances of a T.Type type.<br></p><p>That said, I’d like to consider of sealing the direct access to a metatype into a real type for the sake of extensibility and clarity.<br></p><p>I’m aware that my bikeshedding introduced more boilerplate in terms of accessing the initializer and static members through a bottleneck property called sealed. Furthermore there is one more character to type if we’d go with Type&lt;T&gt; instead of T.Type.<br></p><p>This is why this is a discussion before making any further decisions. :)<br></p><p>PS: As I showed in my last code example a wrapper type Type&lt;T&gt; can also provide a few more information about the metatype.<br></p><p>Type&lt;T&gt;.size<br>Type&lt;T&gt;.stride<br>Type&lt;T&gt;.alignment<br>Furthermore sealing T.Type into Type&lt;T&gt; does solve the problem with the array/dictionary shorthand syntax.<br></p><p>Only when one would store/pass a type (name) we’d implicitly convert SomeType to Type&lt;SomeType&gt;.<br></p><p>Declarations do not follow this implicit conversion:<br></p><p>func foo(_: SomeType) is not equivalent to func foo(_: Type&lt;SomeType&gt;)<br>Array&lt;SomeType&gt;() == [SomeType]() but is not equivalent to [Type&lt;SomeType&gt;]() == Array&lt;Type&lt;SomeType&gt;&gt;()<br>Here is again my bikeshedding:<br></p><p>public struct Type&lt;T&gt; : Hashable, CustomStringConvertible, CustomDebugStringConvertible {<br>       <br>    // `metatype` is a better name than `sealed`<br>    // The tradeoff is this bottleneck property<br></p><p>    public let metatype: T.Type<br>        <br>    public let hashValue: Int<br>        <br>    public static var size: Int { get }<br>    public static var stride: Int { get }<br>    public static var alignment: Int { get }<br>        <br>    public var size: Int { get }<br>    public var stride: Int { get }<br>    public var alignment: Int { get }<br>        <br>    public var description: String { get }<br>    public var debugDescription: String { get }<br>}<br></p><p>public func ==&lt;T, U&gt;(lhs: Type&lt;T&gt;, rhs: Type&lt;U&gt;) -&gt; Bool<br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 10. Juli 2016 um 00:18:02, Chris Lattner (clattner at apple.com) schrieb:<br></p><p>Hi Adrian,<br></p><p>What’s the motivation for this change?<br></p><p>-Chris<br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160710/81d08a1d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Discussion] Seal `T.Type` into `Type&lt;T&gt;`</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>July 13, 2016 at 11:00:00am</p></header><div class="content"><p>Here is a part of a draft I put together in case we should go for a review on this.<br></p><p>Here is the formatted version if you cannot read it here: https://gist.github.com/DevAndArtist/a8d11011a376d47d0afc941017e64c75<br></p><p>Proposed solution<br></p><p>I propose to seal T.Type into a standalone type Type&lt;T&gt; and disallow .Type in public declaration usage.<br></p><p>Behavior Changes:<br></p><p>Make a distinction between internal and public .self.<br></p><p>Rename internal version of .self to .metatype or revision SE–0090 for Swift 3 and leave .self internally.<br></p><p>Make public .self (if not dropped for Swift 3) construct an instance ofType&lt;T&gt; instead a metatype T.Type.<br></p><p>Update all codebase to use Type&lt;T&gt; instead of T.Type.<br></p><p>Small example:<br></p><p>- public func sizeof&lt;T&gt;(_: T.Type) -&gt; Int<br>+ public func sizeof&lt;T&gt;(_: Type&lt;T&gt;) -&gt; Int<br>     <br>    // Current implementation<br>-   return Int(Builtin.sizeof(T.self))<br></p><p>    // Possible internal implementation<br>+   return Int(Builtin.sizeof(T.metatype))<br>     <br>    // Possible implementation with `Type&lt;T&gt;`<br>+   return Int(Builtin.sizeof(Type&lt;T&gt;.metatype))<br>}<br>Pros:<br></p><p>Removing ambiguity in array/dictionary shorthand syntax.<br>Extensibility around the metatype:<br>Conformance to Hashable protocol.<br>Direct access to metatype related information like size, stride or aligment:<br>Type&lt;T&gt;.size equivalent to current sizeof(T.self)<br>Type&lt;T&gt;.stride equivalent to current strideof(T.self)<br>Type&lt;T&gt;.alignment equivalent to current alignof(T.self)<br>A step to remove public .self magic.<br>Less magical types floating around the codebase.<br>Better future maintenance.<br>Cons:<br></p><p>A distinction between internal and public .self must be introduced.<br></p><p>Dynamic types must be tweaked.<br></p><p>Currently it’s possible to check the Type like this:<br></p><p>//  <br>func isInt&lt;T&gt;(metatype: T.Type) -&gt; Bool {<br>    return metatype is Int.Type<br>}<br>is cast must be tweaked after this proposal:<br></p><p>func isInt&lt;T&gt;(type: Type&lt;T&gt;) -&gt; Bool {<br>          <br>    return type == Type&lt;Int&gt;()<br>              <br>    // Since we store/pass a type (name) in this check,<br>    // we can safely convert `Int` into an instance of `Type&lt;Int&gt;`<br>    //<br>    // The result would look like this:<br>              <br>    return type == Int  <br>             <br>    // This is logically equivalent to `metatype is Int.Type`<br>}<br>Type&lt;T&gt; adds more code noise for declarations.<br>T.Type = 6 characters<br>Type&lt;T&gt; = 7 characters<br>Type&lt;T&gt; adds a bottleneck (static) property to access the metatype:<br>Direct access today T.self (in future T)<br>Metatype access after this proposal:<br>Direct access through static member: Type&lt;T&gt;.metatype<br>Access through an initialized instance: typeInstance.metatype<br>Detailed Design<br></p><p>Rules:<br></p><p>Whenever a type (name) is passed or stored, it will be implicitly converted to Type&lt;SomeType&gt; (no need for .self - SE–0090).<br>Declarations do not follow the rule #1.<br>These rules would imply the following behavior and potentially solve the ambiguity in array/dictionary shorthand syntax:<br></p><p>// Type: Type&lt;T&gt;<br>let variable1 = T  <br></p><p>// Type: T<br>let variable2 = T.init()<br></p><p>// Type: T<br>let variable3 = T()  <br></p><p>// Return-type of static member from T<br>let variable4 = T.staticMember<br></p><p>// Return-type of an Array&lt;T&gt; static member<br>let variable6 = [T].staticMember<br></p><p>// Return-type of a Dictionary&lt;T, U&gt; static member<br>let variable7 = [T: U].staticMember<br></p><p>// Type: Array&lt;T&gt;<br>let array1 = [T]()<br></p><p>// Type: Array&lt;T&gt;<br>let array2: [T] = []<br></p><p>// Type: Array&lt;Type&lt;T&gt;&gt;<br>let array3: [Type&lt;T&gt;] = []<br></p><p>// Type: Array&lt;Type&lt;T&gt;&gt;<br>let array4 = [Type&lt;T&gt;]()<br></p><p>// Type: Dictionary&lt;T, U&gt;<br>let dictionary1 = [T: U]()<br></p><p>// Type: Dictionary&lt;T, U&gt;<br>let dictionary2: [T: U] = [:]<br></p><p>// Type: Dictionary&lt;Type&lt;T&gt;, U&gt;<br>let dictionary3: [Type&lt;T&gt;: U] = [:]<br></p><p>// Type: Dictionary&lt;Type&lt;T&gt;, U&gt;<br>let dictionary4 = [Type&lt;T&gt;: U]()<br>Possible Implementation Design:<br></p><p>///<br>public struct Type&lt;T&gt; : Hashable, CustomStringConvertible, CustomDebugStringConvertible {<br></p><p>    /// Creates an instance of `Type&lt;T&gt;`.<br>    public init() {<br>     <br>        // Possible new internal access to the metatype<br>        self.metatype = T.metatype<br>         <br>        // Same hash calculation like in `ObjectIdentifier`<br>        let rawPointerMetatype = unsafeBitCast(T.metatype, to: Builtin.RawPointer.metatype)<br>        self.hashValue = Int(Builtin.ptrtoint_Word(rawPointerMetatype))<br>         <br>        // Iff the value of `size`, `stride` and `alignment` properties cannot<br>        // be changed due runtime, we could move the calculation directly to<br>        // the initializer and make these properties to constants!<br>    }<br>     <br>    ///<br>    public let metatype: T.Type  <br>     <br>    /// The Type&lt;T&gt;&#39;s hash value.<br>    ///<br>    /// Hash values are not guaranteed to be equal across different executions of<br>    /// your program. Do not save hash values to use during a future execution.<br>    public let hashValue: Int  <br>     <br>    /// Returns the contiguous memory footprint of `T`.<br>    ///<br>    /// Does not include any dynamically-allocated or &quot;remote&quot; storage.<br>    /// In particular, when `T` is a class type, is the<br>    /// same regardless of how many stored properties `T` has.<br>    public var size: Int {<br>        return sizeof(self)<br>         <br>        // OR:<br>        return Int(Builtin.sizeof(T.metatype))<br>    }<br>     <br>    /// Returns the least possible interval between distinct instances of<br>    /// `T` in memory.  The result is always positive.<br>    public var stride: Int {<br>        return strideof(self)<br>         <br>        // OR:<br>        return Int(Builtin.strideof_nonzero(T.metatype))<br>    }<br>     <br>    /// Returns the minimum memory alignment of `T`.<br>    public var alignment: Int {<br>        return alignof(self)<br>     <br>        // OR:<br>        return Int(Builtin.alignof(T.metatype))<br>    }<br>         <br>    /// A textual representation of `self`.<br>    public var description: String {<br>        return &quot;Type&lt;\(self.metatype)&gt;&quot;<br>    }<br>     <br>    /// A textual representation of `self`, suitable for debugging.<br>    public var debugDescription: String {<br>        return &quot;&lt;&quot; + self.description<br>                   + &quot; metatype: \(self.metatype)&quot;<br>                   + &quot; size: \(self.size)&quot;<br>                   + &quot; stride: \(self.stride)&quot;<br>                   + &quot; alignment: \(self.alignment)&gt;&quot;<br>    }<br>}<br></p><p>/// Static members for access metatype specific information<br>/// without constructing an instance of `Type&lt;T&gt;`:<br>///<br>/// - `Type&lt;T&gt;.metatype`<br>/// - `Type&lt;T&gt;.size`<br>/// - `Type&lt;T&gt;.stride`<br>/// - `Type&lt;T&gt;.alignment`<br>public extension Type {<br>     <br>    ///<br>    public static var metatype: T.Type {<br>        return T.metatype<br>    }<br>     <br>    /// Returns the contiguous memory footprint of `T`.<br>    ///<br>    /// Does not include any dynamically-allocated or &quot;remote&quot; storage.<br>    /// In particular, when `T` is a class type, is the<br>    /// same regardless of how many stored properties `T` has.<br>    public static var size: Int {<br>        return sizeof(self)<br>         <br>        // OR:<br>        return Int(Builtin.sizeof(T.metatype))<br>    }<br>     <br>    /// Returns the least possible interval between distinct instances of<br>    /// `T` in memory.  The result is always positive.<br>    public static var stride: Int {<br>        return strideof(self)<br>         <br>        // OR:<br>        return Int(Builtin.strideof_nonzero(T.metatype))<br>    }<br>     <br>    /// Returns the minimum memory alignment of `T`.<br>    public static var alignment: Int {<br>        return alignof(self)<br>     <br>        // OR:<br>        return Int(Builtin.alignof(T.metatype))<br>    }<br>}<br></p><p>public func ==&lt;T, U&gt;(lhs: Type&lt;T&gt;, rhs: Type&lt;U&gt;) -&gt; Bool {<br>    return lhs.hashValue == rhs.hashValue<br>}<br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 10. Juli 2016 um 18:03:17, Adrian Zubarev (adrian.zubarev at devandartist.com) schrieb:<br></p><p>Just to be crystal clear, here is my vision.<br></p><p>Currently Swift is heading in this direction:<br></p><p>SomeType.staticMember == metatypeInstance.staticMember == SomeType.self.staticMember<br>SomeType.init == metatypeInstance.init == SomeType.self.init<br></p><p>SomeType.self -&gt; SomeType.Type (metatype)<br></p><p>SomeType -&gt; SomeType.Type (removed .self)<br></p><p>SomeType.self is SomeType.Type == true<br></p><p>func foo&lt;T&gt;(metatype: T.Type) -&gt; T {<br>      <br>    // lets pretend T conforms to an initializable protocol   <br>    return metatype.init()   <br>}<br>With some tweaking and a little tradeoff for Type&lt;T&gt; we’d get this model:<br></p><p>SomeType.staticMember == Type&lt;SomeType&gt;.metatype.staticMember<br>SomeType.init == Type&lt;SomeType&gt;.metatype.init<br></p><p>SomeType -&gt; Type&lt;SomeType&gt;() (initialized instance; removed .self)<br></p><p>SomeType == Type&lt;SomeType&gt;() == true<br></p><p>SomeType is Type&lt;SomeType&gt;() == true<br></p><p>func foo&lt;T&gt;(type: Type&lt;T&gt;) -&gt; T {<br>      <br>    print(type.size)<br>    print(type.debugDescription)<br>    print(type.hashValue)<br>      <br>    // lets pretend T conforms to an initializable protocol   <br>    return type.metatype.init()   <br>}<br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 10. Juli 2016 um 17:28:35, Adrian Zubarev (adrian.zubarev at devandartist.com) schrieb:<br></p><p>Can you point me to some reading? I’m curious what exactly you’re talking about!?<br></p><p>—<br></p><p>I found a negative side effect of sealing T.Type. The problem appears lies in the dynamic is cast.<br></p><p>Currently we could do something like this:<br></p><p>func isInt&lt;T&gt;(metatype: T.Type) -&gt; Bool {<br>       <br>    return metatype is Int.Type<br>}<br>There is no way to express the same type check with Type&lt;T&gt; except this:<br></p><p>func isInt&lt;T&gt;(type: Type&lt;T&gt;) -&gt; Bool {<br>       <br>    return type == Type&lt;Int&gt;()<br>       <br>    // since this check is something where we store/pass a type (name)<br>    // we could implicitly convert `Int` into an instance of `Type&lt;Int&gt;`<br>    //<br>    // The result would look like this:<br>       <br>    return type == Int // which is logically equivalent to `metatype is Int.Type`<br>}<br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 10. Juli 2016 um 16:24:50, L. Mihalkovic (laurent.mihalkovic at gmail.com) schrieb:<br></p><p><br>It looks like this is touching on a small subset of the not-yet-designed reflection API (still tabled for 4.0?). I am interested to see what balance it strikes between declarations (eg. being able to reflect extensions declarations), types (eg reflecting type conformance), and operations (xxx.newInstance(), xxx.setValue()). The mirror api shows a general direction, maybe there is a way to squeeze a tiny subset in 3.0 (just like was done with P&amp;Q that will remain a degenerate case of the upcoming more general syntax). Maybe just enough for people not to have to use ObjectIdentifier(:Any.Type).<br></p><p>Regards<br>(From mobile)<br></p><p>On Jul 10, 2016, at 2:22 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>Hello Chris,<br></p><p>my main concern for this change is the lack of extensibility of metatypes. We can access the metatype through the .self postfix, which potentially will be removed in the future (only the postfix). Through an instance of such a metatype we can then access the static members and all initializer for our type.<br></p><p>SomeType.staticMember equals metatypeInstance.staticMemeber<br>SomeType.init equals metatypeInstance.init<br>It is also possible to extract some more information from the metatypes with the help of Buildin wrapper functions like sizeof or strideof. And the last but not the least we can use metatypes in type checking scenarios.<br></p><p>Last weak I asked the community if there is a need for all metatypes conform to the Hashable protocol, which would be really handy. The overall response was positive, even if only a handful of people responded.<br></p><p>The whole idea of metatypes conforming to Hashable kept me thinking how this might be solved in the future. The main problem is that metatypes provide direct access to initializer and static members of the type and a conformance to Hashable seems to be impossible without some compiler magic or a hidden hashValue property. The main confusion here might be that metatypes can be stored (at least while runtime) inside variables and pretend to be instances of a T.Type type.<br></p><p>That said, I’d like to consider of sealing the direct access to a metatype into a real type for the sake of extensibility and clarity.<br></p><p>I’m aware that my bikeshedding introduced more boilerplate in terms of accessing the initializer and static members through a bottleneck property called sealed. Furthermore there is one more character to type if we’d go with Type&lt;T&gt; instead of T.Type.<br></p><p>This is why this is a discussion before making any further decisions. :)<br></p><p>PS: As I showed in my last code example a wrapper type Type&lt;T&gt; can also provide a few more information about the metatype.<br></p><p>Type&lt;T&gt;.size<br>Type&lt;T&gt;.stride<br>Type&lt;T&gt;.alignment<br>Furthermore sealing T.Type into Type&lt;T&gt; does solve the problem with the array/dictionary shorthand syntax.<br></p><p>Only when one would store/pass a type (name) we’d implicitly convert SomeType to Type&lt;SomeType&gt;.<br></p><p>Declarations do not follow this implicit conversion:<br></p><p>func foo(_: SomeType) is not equivalent to func foo(_: Type&lt;SomeType&gt;)<br>Array&lt;SomeType&gt;() == [SomeType]() but is not equivalent to [Type&lt;SomeType&gt;]() == Array&lt;Type&lt;SomeType&gt;&gt;()<br>Here is again my bikeshedding:<br></p><p>public struct Type&lt;T&gt; : Hashable, CustomStringConvertible, CustomDebugStringConvertible {<br>        <br>    // `metatype` is a better name than `sealed`<br>    // The tradeoff is this bottleneck property<br></p><p>    public let metatype: T.Type<br>         <br>    public let hashValue: Int<br>         <br>    public static var size: Int { get }<br>    public static var stride: Int { get }<br>    public static var alignment: Int { get }<br>         <br>    public var size: Int { get }<br>    public var stride: Int { get }<br>    public var alignment: Int { get }<br>         <br>    public var description: String { get }<br>    public var debugDescription: String { get }<br>}<br></p><p>public func ==&lt;T, U&gt;(lhs: Type&lt;T&gt;, rhs: Type&lt;U&gt;) -&gt; Bool<br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 10. Juli 2016 um 00:18:02, Chris Lattner (clattner at apple.com) schrieb:<br></p><p>Hi Adrian,<br></p><p>What’s the motivation for this change?<br></p><p>-Chris<br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160713/af28f8b7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Discussion] Seal `T.Type` into `Type&lt;T&gt;`</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>July 13, 2016 at 02:00:00pm</p></header><div class="content"><p>Why can&#39;t we drop metatypes T.Type with your proposal? Do they bring some<br>extra capabilities over Type&lt;T&gt; struct?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160713/9b763686/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Discussion] Seal `T.Type` into `Type&lt;T&gt;`</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>July 13, 2016 at 02:00:00pm</p></header><div class="content"><p>This isn’t a full proposal (yet). We still can change things. I didn’t consider everything and can’t to that on my own. Feedback is welcome.<br></p><p>To answer your question, we still need the metatype to access initializer and static member of that type. If we’d drop T.Type completely, we’d lose functionality to do so.<br></p><p>protocol A {<br>    init()<br>}<br></p><p>func foo&lt;T : A&gt;(metatype: T.Type) -&gt; T {<br>    return metatype.init()<br>}<br>The downside of this proposal is the bottleneck property to access that functionality, otherwise adding Hashable or other things like size (MemoryLayout) won’t be possible without serious compiler magic. So do I believe.<br></p><p>func foo&lt;T : A&gt;(type: Type&lt;T&gt;) -&gt; T {<br>    return type.metatype.init()<br>}<br>This is huge tradeoff, but it’s worth considering if the community can life with that.<br></p><p>Furthermore as already been mentioned in this thread, we might consider to extend Type&lt;T&gt; to add reflection functionality to it. (If we’d decide to go in that direction.)<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 13. Juli 2016 um 13:15:02, Anton Zhilin (antonyzhilin at gmail.com) schrieb:<br></p><p>Why can&#39;t we drop metatypes T.Type with your proposal? Do they bring some extra capabilities over Type&lt;T&gt; struct? <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160713/d9348ddf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Discussion] Seal `T.Type` into `Type&lt;T&gt;`</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>July 13, 2016 at 05:00:00pm</p></header><div class="content"><p>2016-07-13 15:02 GMT+03:00 Adrian Zubarev via swift-evolution &lt;<br>swift-evolution at swift.org&gt;:<br>&gt;<br>&gt; To answer your question, we still need the metatype to access initializer<br>&gt; and static member of that type. If we’d drop T.Type completely, we’d lose<br>&gt; functionality to do so.<br>&gt;<br>&gt; protocol A {<br>&gt;     init()<br>&gt; }<br>&gt;<br>&gt; func foo&lt;T : A&gt;(metatype: T.Type) -&gt; T {<br>&gt;     return metatype.init()<br>&gt; }<br>&gt;<br>&gt; In such cases, we can always refer to the type directly:<br></p><p>func foo&lt;T : A&gt;(metatype: Type&lt;T&gt;) -&gt; T {<br>    return T()<br>}<br></p><p>I would prefer to remove metatypes T.Type completely and replace them with<br>your somewhat transparent Type&lt;T&gt;.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160713/ee76094e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Discussion] Seal `T.Type` into `Type&lt;T&gt;`</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>July 13, 2016 at 05:00:00pm</p></header><div class="content"><p>Okay I’m convinced on that one, but do we really want to give up being able to construct an instance from an metatype instance? (Personally I’d keep it as an optional feature.)<br></p><p>There are more than 7000 search results inside swift repository for .Type.<br></p><p>I looked up a few of them and I found an interesting example:<br></p><p>a = SomeClass.self<br>expectTrue(a as? Any.Type == SomeClass.self)<br>expectTrue(a as? AnyClass == SomeClass.self)<br>expectTrue(a as? SomeClass.Type == SomeClass.self)<br>After this proposal we had this:<br></p><p>a: Type&lt;SomeClass&gt; = SomeClass<br></p><p>// How can we cast from `Type&lt;SomeClass&gt;` to `Type&lt;Any&gt;`?<br>// Comparing two Type&lt;T&gt; is done with `hashValue` at least in my<br>// implementation.<br>expectTrue(a as? Type&lt;Any&gt; == SomeClass) // `SomeClass` equals `Type&lt;SomeClass&gt;()`<br></p><p>// How can we cast `Type&lt;SomeClass&gt;` to `AnyClass`?<br>expectTrue(a as? AnyClass == SomeClass)<br></p><p>// this is fine<br>expectTrue(a as? Type&lt;SomeClass&gt; == SomeClass)<br>Dynamic casts do not work with other instances of metatypes (I feel like there was a proposal for this, but I can’t find it). If we had this, we could fix the infix == function to compare metatypes instead the hash value.<br></p><p>What about dynamicType?<br></p><p>Any ideas?<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 13. Juli 2016 um 16:17:43, Anton Zhilin (antonyzhilin at gmail.com) schrieb:<br></p><p>2016-07-13 15:02 GMT+03:00 Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>To answer your question, we still need the metatype to access initializer and static member of that type. If we’d drop T.Type completely, we’d lose functionality to do so.<br></p><p>protocol A {<br>    init()<br>}<br></p><p>func foo&lt;T : A&gt;(metatype: T.Type) -&gt; T {<br>    return metatype.init()<br>}<br>In such cases, we can always refer to the type directly:<br>func foo&lt;T : A&gt;(metatype: Type&lt;T&gt;) -&gt; T {<br>    return T()<br>}<br>I would prefer to remove metatypes T.Type completely and replace them with your somewhat transparent Type&lt;T&gt;.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160713/7da82c4c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Discussion] Seal `T.Type` into `Type&lt;T&gt;`</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>July 13, 2016 at 07:00:00pm</p></header><div class="content"><p>I see model of Type&lt;T&gt; as follows:<br></p><p>   1. Values of Type&lt;T&gt; are identifiers of types (8 bytes, I guess)<br>   2. All used identifiers are contained in Type&lt;Any&gt;<br>   3. Type&lt;T&gt; contains a subset of those identifiers<br>   4. Type&lt;T&gt; are usually created with default constructor Type&lt;T&gt;()<br>   5. Upcasting uses constructor init&lt;U: T&gt;(upcasting: Type&lt;U&gt;)<br>   6. Checking for conformance uses method isSubtype(of:)<br>   7. Size of Type&lt;Type&lt;T&gt;&gt; is 8, static size of Type&lt;SomeProtocol&gt; is 0<br></p><p>2016-07-13 18:25 GMT+03:00 Adrian Zubarev via swift-evolution &lt;<br>swift-evolution at swift.org&gt;:<br>&gt;<br>&gt; a = SomeClass.self<br>&gt;<br>&gt; expectTrue(a as? Any.Type == SomeClass.self)<br>&gt; expectTrue(a as? AnyClass == SomeClass.self)<br>&gt; expectTrue(a as? SomeClass.Type == SomeClass.self)<br>&gt;<br>&gt; That example just demonstrates syntax of metatypes and does not count.<br></p><p>&gt;<br>&gt;    -<br>&gt;<br>&gt;    What about dynamicType?<br>&gt;<br>&gt; It should have the following signature:<br></p><p>func dynamicType&lt;T&gt;(_ var: T) -&gt; Type&lt;T&gt;<br></p><p>To return Type&lt;T&gt; means to return an identifier of U: T<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160713/c89492de/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Discussion] Seal `T.Type` into `Type&lt;T&gt;`</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>July 13, 2016 at 07:00:00pm</p></header><div class="content"><p>Am 13. Juli 2016 um 18:30:53, Anton Zhilin (antonyzhilin at gmail.com) schrieb:<br></p><p>I see model of Type&lt;T&gt; as follows:<br>Values of Type&lt;T&gt; are identifiers of types (8 bytes, I guess)<br>All used identifiers are contained in Type&lt;Any&gt;<br>Type&lt;T&gt; contains a subset of those identifiers<br>I can’t follow your though here. Is this a totally new behavior?<br></p><p>Type&lt;T&gt; are usually created with default constructor Type&lt;T&gt;()<br>That one is easy and already there.<br></p><p>Upcasting uses constructor init&lt;U: T&gt;(upcasting: Type&lt;U&gt;)<br>It does look neat but I can’t implement it. At least I have no clue how to solve the problem that `T` is not a protocol or a class type.<br></p><p>Checking for conformance uses method isSubtype(of:)<br>Interesting suggestion.<br></p><p>Size of Type&lt;Type&lt;T&gt;&gt; is 8, static size of Type&lt;SomeProtocol&gt; is 0<br>I feel like you mean something different here than this:<br></p><p>```swift<br></p><p>protocol SomeProtocol {}<br></p><p>sizeof(SomeProtocol.self) == 40<br>```<br></p><p>2016-07-13 18:25 GMT+03:00 Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>a = SomeClass.self<br></p><p>expectTrue(a as? Any.Type == SomeClass.self)<br>expectTrue(a as? AnyClass == SomeClass.self)<br>expectTrue(a as? SomeClass.Type == SomeClass.self)<br>That example just demonstrates syntax of metatypes and does not count.<br>What about dynamicType?<br></p><p>It should have the following signature:<br></p><p>func dynamicType&lt;T&gt;(_ var: T) -&gt; Type&lt;T&gt;<br></p><p>To return Type&lt;T&gt; means to return an identifier of U: T<br>Was this a typo?<br></p><p>func dynamicType&lt;U: T&gt;(_ var: T) -&gt; Type&lt;U&gt;<br></p><p>PS: If you’d like to join on this idea, I could move the draft to a repo to be able to write the proposal together. You had some good catchy ideas there.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160713/42441435/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Discussion] Seal `T.Type` into `Type&lt;T&gt;`</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>July 13, 2016 at 09:00:00pm</p></header><div class="content"><p>2016-07-13 20:19 GMT+03:00 Adrian Zubarev via swift-evolution &lt;<br>swift-evolution at swift.org&gt;:<br>&gt;<br>&gt; Am 13. Juli 2016 um 18:30:53, Anton Zhilin (antonyzhilin at gmail.com)<br>&gt; schrieb:<br>&gt;<br>&gt; I see model of Type&lt;T&gt; as follows:<br>&gt;<br>&gt;    1. Values of Type&lt;T&gt; are identifiers of types (8 bytes, I guess)<br>&gt;    2. All used identifiers are contained in Type&lt;Any&gt;<br>&gt;    3. Type&lt;T&gt; contains a subset of those identifiers<br>&gt;<br>&gt; I can’t follow your though here. Is this a totally new behavior?<br>&gt;<br>That&#39;s how it works right now:<br></p><p>sizeofValue(Bool.self)              //=&gt; 0 (optimized away)<br>sizeofValue(Bool.self as Any.self)  //=&gt; 8<br></p><p>I&#39;ll put my thoughts another way:<br></p><p>   - Internally, Type&lt;T&gt; contains an Int, i.e. identifer of a type. For<br>   every type, compiler must choose a different identifier<br>   - API of Type&lt;T&gt; is defined so that it can only contain identifiers of<br>   subtypes of T<br>   - For example, when you get a variable of Type&lt;BaseClass&gt;, it can<br>   correspond to BaseClass or DerivedClass<br></p><p><br>&gt;    1. Upcasting uses constructor init&lt;U: T&gt;(upcasting: Type&lt;U&gt;)<br>&gt;<br>&gt; It does look neat but I can’t implement it. At least I have no clue how to<br>&gt; solve the problem that `T` is not a protocol or a class type.<br>&gt;<br>We should add implicit convertion of Type&lt;U&gt; to Type&lt;T&gt;, dulicating current<br>behaviour of `as T.Type`.<br>That constructor still can be useful, but it will be failable and not that<br>significant in practise.<br>I don&#39;t like adding compiler magic, but I guess we really should in this<br>case, because otherwise Type&lt;T&gt; can&#39;t replace T.Type.<br></p><p>&gt;<br>&gt;    1. Size of Type&lt;Type&lt;T&gt;&gt; is 8, static size of Type&lt;SomeProtocol&gt; is 0<br>&gt;<br>&gt; I feel like you mean something different here than this:<br>&gt;<br>&gt; ```swift<br>&gt;<br>&gt; protocol SomeProtocol {}<br>&gt;<br>&gt;<br>&gt; sizeof(SomeProtocol.self) == 40<br>&gt;<br>&gt; ```<br>&gt;<br></p><p>That was a mistake. Static size of Type&lt;SomeProtocol&gt; will be 40, and size<br>property of its values can be less or greater than 40, depending on<br>internal type identifier.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160713/caaf4389/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Discussion] Seal `T.Type` into `Type&lt;T&gt;`</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>July 13, 2016 at 09:00:00pm</p></header><div class="content"><p>Okay I get it now. You meant the size for a metatype sizeof(T.Type.self). This is indeed 8 bytes, at least not for optimized Bool (as you showed).<br></p><p>Internally, Type contains an Int, i.e. identifier of a type. For every type, compiler must choose a different identifier<br>We can already implement this with Hashable protocol.<br></p><p>ObjectIdentifier: A unique identifier for a class instance or metatype.<br></p><p>In Swift, only class instances and metatypes have unique identities. There is no notion of identity for structs, enums, functions, or tuples.<br>// version 1:<br>public let hashValue: Int = ObjectIdentifier(T.self).hashValue<br></p><p>// version 2 (uses ObjectIdentifier calculation without  <br>// constructing an instance of ObjectIdentifier):<br></p><p>init() {<br>    // calculate the hashValue only once<br>    // I&#39;d rename `.self` to `.metatype`<br>     <br>    let rawPointerMetatype = unsafeBitCast(T.self, to: Builtin.RawPointer.self)<br>    self.hashValue = Int(Builtin.ptrtoint_Word(rawPointerMetatype))<br>}<br></p><p>public let hashValue: Int<br>API of Type is defined so that it can only contain identifiers of subtypes of T<br></p><p>For example, when you get a variable of Type, it can correspond to BaseClass or DerivedClass<br>I did a quick test and I feel like this falls under the part of tweaking dynamic casts to work with Type&lt;T&gt;. There is no special compiler magic needed, unsafeBitCast should do the trick. Or we should teach dynamic casts to work with the inner type T instead of the whole Type&lt;T&gt;.<br></p><p>public struct Type&lt;T&gt; : Hashable {<br>     <br>    public let metatype: T.Type = T.self<br></p><p>    public let hashValue: Int = ObjectIdentifier(T.self).hashValue<br>}<br></p><p>public func ==&lt;T, U&gt;(lhs: Type&lt;T&gt;, rhs: Type&lt;U&gt;) -&gt; Bool {<br>     <br>    return lhs.hashValue == rhs.hashValue<br>}<br></p><p>public func asOptionalCast&lt;U, T&gt;(type: Type&lt;T&gt;) -&gt; Type&lt;U&gt;? {<br>     <br>    guard (type.metatype as? U.Type) != nil else {<br>        return nil<br>    }<br>    return unsafeBitCast(type, to: Type&lt;U&gt;.self)<br>}<br></p><p>class A {}<br>class B: A {}<br></p><p>let typeB = Type&lt;B&gt;()<br></p><p>// downcast Type&lt;B&gt; to Type&lt;A&gt;<br>let downcast: Type&lt;A&gt;? = asOptionalCast(type: typeB)<br></p><p>(downcast! == typeB) == true<br></p><p>// cast Type&lt;A&gt; (which here is Type&lt;B&gt;) back to Type&lt;B&gt;<br>let upcast: Type&lt;B&gt;? = asOptionalCast(type: downcast!)<br></p><p>(upcast! == Type&lt;B&gt;()) == true<br>The good part here that the hash value of the casted type won’t change and testing against a new instance of the same dynamic type will be always true.<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 13. Juli 2016 um 20:31:22, Anton Zhilin (antonyzhilin at gmail.com) schrieb:<br></p><p>2016-07-13 20:19 GMT+03:00 Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>Am 13. Juli 2016 um 18:30:53, Anton Zhilin (antonyzhilin at gmail.com) schrieb:<br></p><p>I see model of Type&lt;T&gt; as follows:<br>Values of Type&lt;T&gt; are identifiers of types (8 bytes, I guess)<br>All used identifiers are contained in Type&lt;Any&gt;<br>Type&lt;T&gt; contains a subset of those identifiers<br>I can’t follow your though here. Is this a totally new behavior?<br></p><p>That&#39;s how it works right now:<br></p><p>sizeofValue(Bool.self)              //=&gt; 0 (optimized away)<br>sizeofValue(Bool.self as Any.self)  //=&gt; 8<br></p><p>I&#39;ll put my thoughts another way:<br>Internally, Type&lt;T&gt; contains an Int, i.e. identifer of a type. For every type, compiler must choose a different identifier<br>API of Type&lt;T&gt; is defined so that it can only contain identifiers of subtypes of T<br>For example, when you get a variable of Type&lt;BaseClass&gt;, it can correspond to BaseClass or DerivedClass<br>Upcasting uses constructor init&lt;U: T&gt;(upcasting: Type&lt;U&gt;)<br>It does look neat but I can’t implement it. At least I have no clue how to solve the problem that `T` is not a protocol or a class type.<br></p><p>We should add implicit convertion of Type&lt;U&gt; to Type&lt;T&gt;, dulicating current behaviour of `as T.Type`.<br>That constructor still can be useful, but it will be failable and not that significant in practise.<br>I don&#39;t like adding compiler magic, but I guess we really should in this case, because otherwise Type&lt;T&gt; can&#39;t replace T.Type.<br>Size of Type&lt;Type&lt;T&gt;&gt; is 8, static size of Type&lt;SomeProtocol&gt; is 0<br>I feel like you mean something different here than this:<br></p><p>```swift<br></p><p>protocol SomeProtocol {}<br></p><p>sizeof(SomeProtocol.self) == 40<br>```<br></p><p>That was a mistake. Static size of Type&lt;SomeProtocol&gt; will be 40, and size property of its values can be less or greater than 40, depending on internal type identifier.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160713/72bc3c77/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Discussion] Seal `T.Type` into `Type&lt;T&gt;`</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>July 13, 2016 at 11:00:00pm</p></header><div class="content"><p>An even better explanation of my suggestion: instead of *sealing* T.Type, I<br>suggest to *rename* it to Type&lt;T&gt;, formally turning it into a struct, and<br>then add size and align properties to it.<br>And regardless of how you interpret it, I suggest to remove .Type notation.<br></p><p>&gt; In Swift, only class instances and metatypes have unique identities.<br>There is no notion of identity for structs, enums, functions, or tuples.<br>So Type&lt;T&gt; will lose identity. That&#39;s fine. They will contain unique<br>integer identifiers (assigned to types during compilation) to do its work.<br></p><p>&gt; There is no special compiler magic needed<br>Maybe. At least, this behaviour will be needed in construction from type<br>literals:<br></p><p>func foo(_ x: Type&lt;BaseClass&gt;)<br>foo(DerivedClass)  // ok<br>foo(Int)           // compilation error<br></p><p>With Type&lt;T&gt;, I can see reflection coming! For example, Type&lt;T&gt; can have<br>the following property (although we shouldn&#39;t right now):<br></p><p>var fields: [String: (Type&lt;Any&gt;, (T) -&gt; Any)] { get }<br></p><p>I suggest you to prepare a formal proposal, or I will try tomorrow. I would<br>take the direction on removal of T.Type notation.<br></p><p>2016-07-13 22:48 GMT+03:00 Adrian Zubarev via swift-evolution &lt;<br>swift-evolution at swift.org&gt;:<br></p><p>&gt; Okay I get it now. You meant the size for a metatype sizeof(T.Type.self).<br>&gt; This is indeed 8 bytes, at least not for optimized Bool (as you showed).<br>&gt;<br>&gt; Internally, Type contains an Int, i.e. identifier of a type. For every<br>&gt; type, compiler must choose a different identifier<br>&gt;<br>&gt; We can already implement this with Hashable protocol.<br>&gt;<br>&gt; ObjectIdentifier: A unique identifier for a class instance or metatype.<br>&gt;<br>&gt; In Swift, only class instances and metatypes have unique identities. There<br>&gt; is no notion of identity for structs, enums, functions, or tuples.<br>&gt;<br>&gt; // version 1:<br>&gt; public let hashValue: Int = ObjectIdentifier(T.self).hashValue<br>&gt;<br>&gt; // version 2 (uses ObjectIdentifier calculation without<br>&gt; // constructing an instance of ObjectIdentifier):<br>&gt;<br>&gt; init() {<br>&gt;     // calculate the hashValue only once<br>&gt;     // I&#39;d rename `.self` to `.metatype`<br>&gt;<br>&gt;     let rawPointerMetatype = unsafeBitCast(T.self, to: Builtin.RawPointer.self)<br>&gt;     self.hashValue = Int(Builtin.ptrtoint_Word(rawPointerMetatype))<br>&gt; }<br>&gt;<br>&gt; public let hashValue: Int<br>&gt;<br>&gt; API of Type is defined so that it can only contain identifiers of<br>&gt; subtypes of T<br>&gt;<br>&gt; For example, when you get a variable of Type, it can correspond to<br>&gt; BaseClass or DerivedClass<br>&gt;<br>&gt; I did a quick test and I feel like this falls under the part of tweaking<br>&gt; dynamic casts to work with Type&lt;T&gt;. There is no special compiler magic<br>&gt; needed, unsafeBitCast should do the trick. Or we should teach dynamic<br>&gt; casts to work with the inner type T instead of the whole Type&lt;T&gt;.<br>&gt;<br>&gt; public struct Type&lt;T&gt; : Hashable {<br>&gt;<br>&gt;     public let metatype: T.Type = T.self<br>&gt;<br>&gt;     public let hashValue: Int = ObjectIdentifier(T.self).hashValue<br>&gt; }<br>&gt;<br>&gt; public func ==&lt;T, U&gt;(lhs: Type&lt;T&gt;, rhs: Type&lt;U&gt;) -&gt; Bool {<br>&gt;<br>&gt;     return lhs.hashValue == rhs.hashValue<br>&gt; }<br>&gt;<br>&gt; public func asOptionalCast&lt;U, T&gt;(type: Type&lt;T&gt;) -&gt; Type&lt;U&gt;? {<br>&gt;<br>&gt;     guard (type.metatype as? U.Type) != nil else {<br>&gt;         return nil<br>&gt;     }<br>&gt;     return unsafeBitCast(type, to: Type&lt;U&gt;.self)<br>&gt; }<br>&gt;<br>&gt; class A {}<br>&gt; class B: A {}<br>&gt;<br>&gt; let typeB = Type&lt;B&gt;()<br>&gt;<br>&gt; // downcast Type&lt;B&gt; to Type&lt;A&gt;<br>&gt; let downcast: Type&lt;A&gt;? = asOptionalCast(type: typeB)<br>&gt;<br>&gt; (downcast! == typeB) == true<br>&gt;<br>&gt; // cast Type&lt;A&gt; (which here is Type&lt;B&gt;) back to Type&lt;B&gt;<br>&gt; let upcast: Type&lt;B&gt;? = asOptionalCast(type: downcast!)<br>&gt;<br>&gt; (upcast! == Type&lt;B&gt;()) == true<br>&gt;<br>&gt; The good part here that the hash value of the casted type won’t change and<br>&gt; testing against a new instance of the same dynamic type will be always true.<br>&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt;<br>&gt; Am 13. Juli 2016 um 20:31:22, Anton Zhilin (antonyzhilin at gmail.com)<br>&gt; schrieb:<br>&gt;<br>&gt; 2016-07-13 20:19 GMT+03:00 Adrian Zubarev via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt;&gt;<br>&gt;&gt; Am 13. Juli 2016 um 18:30:53, Anton Zhilin (antonyzhilin at gmail.com)<br>&gt;&gt; schrieb:<br>&gt;&gt;<br>&gt;&gt; I see model of Type&lt;T&gt; as follows:<br>&gt;&gt;<br>&gt;&gt;    1. Values of Type&lt;T&gt; are identifiers of types (8 bytes, I guess)<br>&gt;&gt;    2. All used identifiers are contained in Type&lt;Any&gt;<br>&gt;&gt;    3. Type&lt;T&gt; contains a subset of those identifiers<br>&gt;&gt;<br>&gt;&gt; I can’t follow your though here. Is this a totally new behavior?<br>&gt;&gt;<br>&gt; That&#39;s how it works right now:<br>&gt;<br>&gt; sizeofValue(Bool.self)              //=&gt; 0 (optimized away)<br>&gt; sizeofValue(Bool.self as Any.self)  //=&gt; 8<br>&gt;<br>&gt; I&#39;ll put my thoughts another way:<br>&gt;<br>&gt;    - Internally, Type&lt;T&gt; contains an Int, i.e. identifer of a type. For<br>&gt;    every type, compiler must choose a different identifier<br>&gt;    - API of Type&lt;T&gt; is defined so that it can only contain identifiers of<br>&gt;    subtypes of T<br>&gt;    - For example, when you get a variable of Type&lt;BaseClass&gt;, it can<br>&gt;    correspond to BaseClass or DerivedClass<br>&gt;<br>&gt;<br>&gt;&gt;    1. Upcasting uses constructor init&lt;U: T&gt;(upcasting: Type&lt;U&gt;)<br>&gt;&gt;<br>&gt;&gt; It does look neat but I can’t implement it. At least I have no clue how<br>&gt;&gt; to solve the problem that `T` is not a protocol or a class type.<br>&gt;&gt;<br>&gt; We should add implicit convertion of Type&lt;U&gt; to Type&lt;T&gt;, dulicating<br>&gt; current behaviour of `as T.Type`.<br>&gt; That constructor still can be useful, but it will be failable and not that<br>&gt; significant in practise.<br>&gt; I don&#39;t like adding compiler magic, but I guess we really should in this<br>&gt; case, because otherwise Type&lt;T&gt; can&#39;t replace T.Type.<br>&gt;<br>&gt;&gt;<br>&gt;&gt;    1. Size of Type&lt;Type&lt;T&gt;&gt; is 8, static size of Type&lt;SomeProtocol&gt; is 0<br>&gt;&gt;<br>&gt;&gt; I feel like you mean something different here than this:<br>&gt;&gt;<br>&gt;&gt; ```swift<br>&gt;&gt;<br>&gt;&gt; protocol SomeProtocol {}<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; sizeof(SomeProtocol.self) == 40<br>&gt;&gt;<br>&gt;&gt; ```<br>&gt;&gt;<br>&gt;<br>&gt; That was a mistake. Static size of Type&lt;SomeProtocol&gt; will be 40, and<br>&gt; size property of its values can be less or greater than 40, depending on<br>&gt; internal type identifier.<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160713/5fc5f7a8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Discussion] Seal `T.Type` into `Type&lt;T&gt;`</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>July 13, 2016 at 11:00:00pm</p></header><div class="content"><p>I’m still not fully convinced about fully removing the access to the metatype.<br></p><p>If you look at Ericas and Daves current proposal for MemoryLayout it would completely break and it would become impossible to build something like this.<br></p><p>And yes I borrowed the idea of putting properties like size into Type&lt;T&gt; from SE–0101. That was mentioned in my previews posts.<br></p><p>If we remove .Type, how’d we access static members in other types like MemoryLayout&lt;T&gt;?<br></p><p>This is another contra argument to consider.<br>@Erica @Dave: Any statement on our conversation about Type&lt;T&gt;?<br></p><p>I apologize that this whole idea raised in parallel to your proposal.<br></p><p>PS: We can merge our ideas into a single formal proposal. Ping me off-list when you get some time tomorrow.<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 13. Juli 2016 um 22:57:40, Anton Zhilin (antonyzhilin at gmail.com) schrieb:<br></p><p>An even better explanation of my suggestion: instead of sealing T.Type, I suggest to rename it to Type&lt;T&gt;, formally turning it into a struct, and then add size and align properties to it.<br>And regardless of how you interpret it, I suggest to remove .Type notation.<br></p><p>&gt; In Swift, only class instances and metatypes have unique identities. There is no notion of identity for structs, enums, functions, or tuples.<br>So Type&lt;T&gt; will lose identity. That&#39;s fine. They will contain unique integer identifiers (assigned to types during compilation) to do its work.<br></p><p>&gt; There is no special compiler magic needed<br>Maybe. At least, this behaviour will be needed in construction from type literals:<br></p><p>func foo(_ x: Type&lt;BaseClass&gt;)<br>foo(DerivedClass)  // ok<br>foo(Int)           // compilation error<br></p><p>With Type&lt;T&gt;, I can see reflection coming! For example, Type&lt;T&gt; can have the following property (although we shouldn&#39;t right now):<br></p><p>var fields: [String: (Type&lt;Any&gt;, (T) -&gt; Any)] { get }<br></p><p>I suggest you to prepare a formal proposal, or I will try tomorrow. I would take the direction on removal of T.Type notation.<br></p><p>2016-07-13 22:48 GMT+03:00 Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>Okay I get it now. You meant the size for a metatype sizeof(T.Type.self). This is indeed 8 bytes, at least not for optimized Bool (as you showed).<br></p><p>Internally, Type contains an Int, i.e. identifier of a type. For every type, compiler must choose a different identifier<br>We can already implement this with Hashable protocol.<br></p><p>ObjectIdentifier: A unique identifier for a class instance or metatype.<br></p><p>In Swift, only class instances and metatypes have unique identities. There is no notion of identity for structs, enums, functions, or tuples.<br>// version 1:<br>public let hashValue: Int = ObjectIdentifier(T.self).hashValue<br></p><p>// version 2 (uses ObjectIdentifier calculation without   <br>// constructing an instance of ObjectIdentifier):<br></p><p>init() {<br>    // calculate the hashValue only once<br>    // I&#39;d rename `.self` to `.metatype`<br>      <br>    let rawPointerMetatype = unsafeBitCast(T.self, to: Builtin.RawPointer.self)<br>    self.hashValue = Int(Builtin.ptrtoint_Word(rawPointerMetatype))<br>}<br></p><p>public let hashValue: Int<br>API of Type is defined so that it can only contain identifiers of subtypes of T<br></p><p>For example, when you get a variable of Type, it can correspond to BaseClass or DerivedClass<br>I did a quick test and I feel like this falls under the part of tweaking dynamic casts to work with Type&lt;T&gt;. There is no special compiler magic needed, unsafeBitCast should do the trick. Or we should teach dynamic casts to work with the inner type T instead of the whole Type&lt;T&gt;.<br></p><p>public struct Type&lt;T&gt; : Hashable {<br>      <br>    public let metatype: T.Type = T.self<br></p><p>    public let hashValue: Int = ObjectIdentifier(T.self).hashValue<br>}<br></p><p>public func ==&lt;T, U&gt;(lhs: Type&lt;T&gt;, rhs: Type&lt;U&gt;) -&gt; Bool {<br>      <br>    return lhs.hashValue == rhs.hashValue<br>}<br></p><p>public func asOptionalCast&lt;U, T&gt;(type: Type&lt;T&gt;) -&gt; Type&lt;U&gt;? {<br>      <br>    guard (type.metatype as? U.Type) != nil else {<br>        return nil<br>    }<br>    return unsafeBitCast(type, to: Type&lt;U&gt;.self)<br>}<br></p><p>class A {}<br>class B: A {}<br></p><p>let typeB = Type&lt;B&gt;()<br></p><p>// downcast Type&lt;B&gt; to Type&lt;A&gt;<br>let downcast: Type&lt;A&gt;? = asOptionalCast(type: typeB)<br></p><p>(downcast! == typeB) == true<br></p><p>// cast Type&lt;A&gt; (which here is Type&lt;B&gt;) back to Type&lt;B&gt;<br>let upcast: Type&lt;B&gt;? = asOptionalCast(type: downcast!)<br></p><p>(upcast! == Type&lt;B&gt;()) == true<br>The good part here that the hash value of the casted type won’t change and testing against a new instance of the same dynamic type will be always true.<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 13. Juli 2016 um 20:31:22, Anton Zhilin (antonyzhilin at gmail.com) schrieb:<br></p><p>2016-07-13 20:19 GMT+03:00 Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>Am 13. Juli 2016 um 18:30:53, Anton Zhilin (antonyzhilin at gmail.com) schrieb:<br></p><p>I see model of Type&lt;T&gt; as follows:<br>Values of Type&lt;T&gt; are identifiers of types (8 bytes, I guess)<br>All used identifiers are contained in Type&lt;Any&gt;<br>Type&lt;T&gt; contains a subset of those identifiers<br>I can’t follow your though here. Is this a totally new behavior?<br></p><p>That&#39;s how it works right now:<br></p><p>sizeofValue(Bool.self)              //=&gt; 0 (optimized away)<br>sizeofValue(Bool.self as Any.self)  //=&gt; 8<br></p><p>I&#39;ll put my thoughts another way:<br>Internally, Type&lt;T&gt; contains an Int, i.e. identifer of a type. For every type, compiler must choose a different identifier<br>API of Type&lt;T&gt; is defined so that it can only contain identifiers of subtypes of T<br>For example, when you get a variable of Type&lt;BaseClass&gt;, it can correspond to BaseClass or DerivedClass<br>Upcasting uses constructor init&lt;U: T&gt;(upcasting: Type&lt;U&gt;)<br>It does look neat but I can’t implement it. At least I have no clue how to solve the problem that `T` is not a protocol or a class type.<br></p><p>We should add implicit convertion of Type&lt;U&gt; to Type&lt;T&gt;, dulicating current behaviour of `as T.Type`.<br>That constructor still can be useful, but it will be failable and not that significant in practise.<br>I don&#39;t like adding compiler magic, but I guess we really should in this case, because otherwise Type&lt;T&gt; can&#39;t replace T.Type.<br>Size of Type&lt;Type&lt;T&gt;&gt; is 8, static size of Type&lt;SomeProtocol&gt; is 0<br>I feel like you mean something different here than this:<br></p><p>```swift<br></p><p>protocol SomeProtocol {}<br></p><p>sizeof(SomeProtocol.self) == 40<br>```<br></p><p>That was a mistake. Static size of Type&lt;SomeProtocol&gt; will be 40, and size property of its values can be less or greater than 40, depending on internal type identifier.<br></p><p><br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160713/367359cb/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Discussion] Seal `T.Type` into `Type&lt;T&gt;`</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>July 15, 2016 at 05:00:00pm</p></header><div class="content"><p>Regards<br>LM<br>(From mobile)<br></p><p>&gt; On Jul 13, 2016, at 2:02 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This isn’t a full proposal (yet). We still can change things. I didn’t consider everything and can’t to that on my own. Feedback is welcome.<br>&gt; <br>&gt; To answer your question, we still need the metatype to access initializer and static member of that type. If we’d drop T.Type completely, we’d lose functionality to do so.<br>&gt; <br>&gt; protocol A {<br>&gt;     init()<br>&gt; }<br>&gt; <br>&gt; func foo&lt;T : A&gt;(metatype: T.Type) -&gt; T {<br>&gt;     return metatype.init()<br>&gt; }<br>&gt; The downside of this proposal is the bottleneck property to access that functionality, otherwise adding Hashable or other things like size (MemoryLayout) won’t be possible without serious compiler magic. So do I believe.<br>&gt; <br>&gt; func foo&lt;T : A&gt;(type: Type&lt;T&gt;) -&gt; T {<br>&gt;     return type.metatype.init()<br>&gt; }<br>&gt; This is huge tradeoff, but it’s worth considering if the community can life with that.<br>&gt; <br>&gt; Furthermore as already been mentioned in this thread, we might consider to extend Type&lt;T&gt; to add reflection functionality to it. (If we’d decide to go in that direction.)<br>&gt; <br>IMHO it is not just a matter of &#39;adding reflection&#39;.. this IS a subset of reflection. The key is to design it question exhaustively enough to leave clean holes for the rest being only additive. Otherwise this will lead the way to more &#39;oops we have to change the proposal so that what we loose now can be put back additively later&#39; (reference to the recent dance around the labels in sigs proposal that had to be patched post-acceptance)<br></p><p><br></p><p>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; Am 13. Juli 2016 um 13:15:02, Anton Zhilin (antonyzhilin at gmail.com) schrieb:<br>&gt; <br>&gt;&gt; Why can&#39;t we drop metatypes T.Type with your proposal? Do they bring some extra capabilities over Type&lt;T&gt; struct? <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160715/93821124/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Discussion] Seal `T.Type` into `Type&lt;T&gt;`</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>July 15, 2016 at 05:00:00pm</p></header><div class="content"><p>I’m investing all my strength to create such a design. Stay patient and feel free to provide feedback to the our vision of the implementation (WIP): https://gist.github.com/DevAndArtist/a5744f21107812b2d4e6baee2c55e0bf<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 15. Juli 2016 um 17:17:44, L. Mihalkovic (laurent.mihalkovic at gmail.com) schrieb:<br></p><p><br>Regards<br>LM<br>(From mobile)<br></p><p>On Jul 13, 2016, at 2:02 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>This isn’t a full proposal (yet). We still can change things. I didn’t consider everything and can’t to that on my own. Feedback is welcome.<br></p><p>To answer your question, we still need the metatype to access initializer and static member of that type. If we’d drop T.Type completely, we’d lose functionality to do so.<br></p><p>protocol A {<br>    init()<br>}<br></p><p>func foo&lt;T : A&gt;(metatype: T.Type) -&gt; T {<br>    return metatype.init()<br>}<br>The downside of this proposal is the bottleneck property to access that functionality, otherwise adding Hashable or other things like size (MemoryLayout) won’t be possible without serious compiler magic. So do I believe.<br></p><p>func foo&lt;T : A&gt;(type: Type&lt;T&gt;) -&gt; T {<br>    return type.metatype.init()<br>}<br>This is huge tradeoff, but it’s worth considering if the community can life with that.<br></p><p>Furthermore as already been mentioned in this thread, we might consider to extend Type&lt;T&gt; to add reflection functionality to it. (If we’d decide to go in that direction.)<br></p><p>IMHO it is not just a matter of &#39;adding reflection&#39;.. this IS a subset of reflection. The key is to design it question exhaustively enough to leave clean holes for the rest being only additive. Otherwise this will lead the way to more &#39;oops we have to change the proposal so that what we loose now can be put back additively later&#39; (reference to the recent dance around the labels in sigs proposal that had to be patched post-acceptance)<br></p><p><br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 13. Juli 2016 um 13:15:02, Anton Zhilin (antonyzhilin at gmail.com) schrieb:<br></p><p>Why can&#39;t we drop metatypes T.Type with your proposal? Do they bring some extra capabilities over Type&lt;T&gt; struct? <br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160715/e812745b/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
