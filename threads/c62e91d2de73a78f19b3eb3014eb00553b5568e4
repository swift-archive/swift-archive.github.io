<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0c95e1c099887eaa1f47934d54bd673b?s=50"></div><header><strong>Revisiting 0004 etc. - Swift deprecations</strong> from <string>John Heerema</string> &lt;jheerema at ucalgary.ca&gt;<p>April  2, 2016 at 11:00:00pm</p></header><div class="content"><p>Warning - long post.<br>I know that some folks really hate long posts, so let me apologize right<br>now for this being a long post. Please feel free to skip right on past it.<br>I posted it on a weekend, when there¹s less mailing list traffic, but that<br>doesn¹t make it any shorter.<br></p><p>Warning - revisits two approved deprecations.<br>If you really, really hate it when people want to revisit decisions that<br>have already been made, please just skip right past this post. My<br>apologies for not contributing to the discussion when these decisions were<br>originally being made!<br></p><p>The day that Swift was announced at the WWDC was very<br>exciting for me, and I immediately read the Swift book from beginning to<br>end.<br>Swift quickly became my favourite language: I felt that the Swift language<br>developers had created a beautiful language that combined expressiveness<br>with<br>practicality in a way that made Swift code both powerful and easy to<br>understand. Swift was crafted by some very smart and practical people.<br></p><p>To put my thoughts into perspective, I should mention that<br>I¹ve taught Computer Science at a senior University level for years, and<br>have<br>worked in industry for decades. As a computer scientist, I¹ve had a strong<br>interest in computer languages for many years. I became an Apple developer<br>upon<br>purchasing an Apple Lisa a very long time ago.<br></p><p>Over the past couple of years though, I¹ve seen what I think<br>of as a growing emphasis on strict feature orthagonality at the expense of<br>practicality in Swift. Perhaps this because much of the feedback on the<br>language has been provided by those of us who are interested in computer<br>languages. But for whatever reasons, the Swift language seems to have<br>become<br>more cluttered and less friendly.<br></p><p>As I¹ve gone through the various beta releases, I¹ve seen<br>changes that detract from the experience of using Swift, for reasons that<br>seem<br>related to ³language purity².<br></p><p>I was finally moved to try to express my thoughts after<br>seeing a couple of what I think of as particularly inadvisable proposals<br>for<br>Swift version 3 and beyond.<br></p><p>Unary increment and decrement operators: ++ and ‹<br></p><p>The first of these was the now approved removal of Swift¹s<br>convenient unary increment and decrement operators. I would agree with<br>some of<br>the comments that have been made about these operators not being quite<br>orthogonal with other expressive elements in the language. Nonetheless,<br>they<br>are a handy and popular way to iterate over enumerable collections, and to<br>increment and decrement a variable that is used for purposes other than<br>iteration. They also lend themselves to being extended to other data<br>types, such<br>as position pointers in linked lists, where they can implement the<br>convenient<br>concept of ³the next thing² (which += does not provide).<br></p><p>The desire to get rid of these rather harmless operators<br>reminds me of some of Apple¹s own history, and the history of computer<br>languages in general. Niklaus Wirth didn¹t care for shortcut operators<br>either,<br>and so Pascal never got them.<br></p><p>However, Apple eventually moved away from Pascal to C, even<br>though C is in many ways a deeply flawed language that is responsible for a<br>wide litany of software errors. Why? I personally really liked Pascal, but<br>many<br>(most) developers didn¹t care for the language. I¹d argue that developers<br>preferred the flexibility of C to what they saw as the overly restricting<br>constraints of Pascal.<br></p><p>One of the surprising reasons that I heard a lot at the<br>time, was that developers didn¹t want to lose C¹s shortcut operators. If<br>Wirth<br>had been willing to give Pascal some of C¹s convenience operators, things<br>might<br>well have turned out differently. Developers hate typing.<br></p><p>The notion that there should be exactly one way to do a<br>particular thing sounds like dogma to me: not practicality. If people are<br>concerned that unary operators confuse beginners, I would encourage them to<br>convince educators not to teach them to beginners. Anyway, there are a lot<br>of<br>things in Swift that can confuse beginners!<br></p><p>Although it¹s hard for me to believe that having these<br>operators return void has been seriously considered, I would argue that<br>this<br>would be even sillier than removing them. A lot of developers use both C<br>(or<br>Objective C, C++, C#, Java, etc. etc.) and Swift ­ having those unary<br>operators<br>act completely differently in Swift would be a great way to alienate those<br>developers. <br></p><p>Let¹s not forget that  Swift<br>is not the lingua franca of the computing world. It¹s an upstart that<br>needs to<br>attract the development community. Why repel people coming from the various<br>C-like languages without a really, really, convincingly good reason? it¹s<br>better for an upstart to attract than to repel.<br></p><p>Right now, there are an awful lot of developers who are used<br>to, and like the convenience of unary increment and decrement operators.<br>Removing them seems bound to annoy developers and diminish the popularity<br>of<br>Swift, in exchange for Š well, not very much except for a tiny bit of<br>language<br>purity. That just seems silly to me.<br></p><p>C-style For loops<br></p><p>Removal of C-style For loops has already been approved for a<br>future version of Swift. Even though I find the C-style For loop to be a<br>bit<br>ugly and unintuitive, I believe that removing it was the wrong thing to do.<br></p><p>It comes down to flexibility and expressiveness. The reality<br>is that C-style For loops easily implement certain operations that are more<br>difficult to implement without them.<br></p><p>I¹ve seen comments that C-style For loops are ³hardly ever<br>used², and that ³hardly any² algorithms really need them. I believe that<br>³hardly any² is a lazy mental shortcut for ³Well, I don¹t like them, and I<br>I<br>don¹t use them, so I don¹t think that any anyone who¹s important uses<br>them.².<br></p><p>Yes, there are many cases in which I believe that Swift<br>provides looping structures that are safer and easier to understand than<br>the<br>C-style For loop. I¹d even say most cases. But I work in the scientific and<br>engineering domains, and can point to many instances of looping structures<br>that<br>are easily expressed with a C-style For loop, but are clumsy to implement<br>without it.<br></p><p>In the world of the natural sciences, there are any number<br>of instances of loop increments that requires some kind of a calculation.<br>There<br>are any number of instances of dynamically calculated loop termination.<br></p><p>Swift¹s stride has some nice features for simple increments,<br>but also has some important limitations. Among them, it involves the two<br>step<br>process of first creating an enumerable set, and then iterating over it.<br>In the<br>natural sciences, it is not uncommon for complex loop increments to be<br>used in<br>loops that are executed millions of times.<br></p><p>Conceptually, creating an enumerable set, and then iterating over it,<br>reeks of the arrogance of assuming that computing resources are unlimited.<br>Even<br>though the compiler may optimize the stride into the loop structure, it<br>feels<br>like unnecessarily creating a gigantic enumerable set.<br></p><p>Whether we like it or not, the enduring popularity of the<br>C-style For loop comes from it¹s flexibility. Swift doesn¹t have a better<br>alternative that also provides the same flexibility. So don¹t take it<br>away. If<br>you don¹t like it (I don¹t always either), think of something that is<br>clearly<br>superior in 100% of use cases. Even then, I would argue against removing<br>it. <br></p><p>I would argue that the C-style For loop implements some<br>rather Swift-like concepts. The syntax provide for three closures: one<br>each for<br>(a) things to do first, (b) things to do when deciding whether to stop<br>iterating,  and (c) things to do after each iteration. How is that contrary<br>to the principals of Swift?<br></p><p>Just like pretty much everywhere that Swift allows closures,<br>they can be used to write code that is difficult to understand. But the<br>syntax<br>is general and flexible enough to have survived intact for half a century.<br></p><p>It¹s the carrot vs. the stick. Developers prefer the carrot.<br>The belief that we can force developers to write better code by taking away<br>language features, has not historically met with success. Let me say that<br>again, because I think it¹s important. Developers who are given a choice<br>between C and a ³better² language (say Modula-2, or Swift) are unlikely to<br>react favourably to being told ³we¹re taking away this feature of C that<br>you<br>like, for your own good, because you¹re too stupid to use it sensibly².<br>Taking away well-understood expressive language elements, and replacing<br>them with something less expressive, is not going to win developers over.<br></p><p>C-style For loops haven¹t changed in half acentury, because they work.<br>A lot of other languages have also adopted them, because they work.<br></p><p>If I may, I¹d like to take the English language by way of<br>analogy. English contains a lot of weird, irregular language elements.<br>There¹s<br>no single way to express a concept. Instead, there are many, subtly<br>different<br>ways to express yourself.<br></p><p>But, for all of its weirdness, English has remained popular<br>for centuries, whereas more ³sensible², ³regular² languages like Esperanto<br>never caught on. The reasons are flexibility and expressiveness. The same<br>thing<br>applies to computer languages.<br></p><p>If we only look inside the world of compilers and computer<br>science instruction, to see if we need the flexibility of C-style For<br>loops, we<br>might mistakenly think that we don¹t. But those domains are relatively<br>simple<br>in comparison to the physical sciences. Our experience there doesn¹t always<br>translate to the more complex world of physical reality. So let¹s not throw<br>away convenient and useful language features just because we don¹t<br>personally<br>care for them.<br></p><p>Don¹t make Swift Yet Another Interesting Experiment in<br>language design that wasn¹t widely adopted, and<br>ended up being relegated to the dustbin of history.<br>It would make me sad to see the best new computer language<br>in ages become just another niche language. We already<br>have enough of those.<br></p><p>So, all of you folks who voted to remove these things, please don¹t hate<br>me!<br></p><p>Regards,<br>J. Heerema, Ph.D.<br></p><p><br></p><p><br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: default.xml<br>Type: application/xml<br>Size: 3222 bytes<br>Desc: default.xml<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160402/c62e68e4/attachment.wsdl&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: default[1].xml<br>Type: application/xml<br>Size: 3222 bytes<br>Desc: default[1].xml<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160402/c62e68e4/attachment-0001.wsdl&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d172fa3c47108d84ee35a68e8d675c1?s=50"></div><header><strong>Revisiting 0004 etc. - Swift deprecations</strong> from <string>Ross O&#39;Brien</string> &lt;narrativium+swift at gmail.com&gt;<p>April  3, 2016 at 02:00:00am</p></header><div class="content"><p>Because you&#39;re coming to the discussion late, the arguments you&#39;re making<br>are a little out of date. It&#39;s no longer a case of not removing these<br>features. It&#39;s now a case of having a compelling reason to put them back.<br></p><p>I trust you&#39;ve read the proposals that were put forward. For the benefit of<br>those reading, they&#39;re here:<br>https://github.com/apple/swift-evolution/blob/master/proposals/0004-remove-pre-post-inc-decrement.md<br>https://github.com/apple/swift-evolution/blob/master/proposals/0007-remove-c-style-for-loops.md<br></p><p>There are several disadvantages listed for keeping these two features.<br>Those are the arguments you need to counter. As it happens, both proposals<br>refer to the metric of &#39;if this wasn&#39;t already in Swift, would it be<br>accepted for Swift 3?&#39; and both features have been deemed to fail this<br>criterion. That&#39;s what you need to address.<br></p><p>Bear in mind these decisions were made several months ago, and both<br>features have already been deprecated as of Swift 2.2, which is now in use<br>in production code, many developers (including myself) are already<br>refactoring their code to remove uses of these syntax forms.<br></p><p><br>On Sun, Apr 3, 2016 at 12:45 AM, John Heerema via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Warning - long post.<br>&gt; I know that some folks really hate long posts, so let me apologize right<br>&gt; now for this being a long post. Please feel free to skip right on past it.<br>&gt; I posted it on a weekend, when there¹s less mailing list traffic, but that<br>&gt; doesn¹t make it any shorter.<br>&gt;<br>&gt; Warning - revisits two approved deprecations.<br>&gt; If you really, really hate it when people want to revisit decisions that<br>&gt; have already been made, please just skip right past this post. My<br>&gt; apologies for not contributing to the discussion when these decisions were<br>&gt; originally being made!<br>&gt;<br>&gt; The day that Swift was announced at the WWDC was very<br>&gt; exciting for me, and I immediately read the Swift book from beginning to<br>&gt; end.<br>&gt; Swift quickly became my favourite language: I felt that the Swift language<br>&gt; developers had created a beautiful language that combined expressiveness<br>&gt; with<br>&gt; practicality in a way that made Swift code both powerful and easy to<br>&gt; understand. Swift was crafted by some very smart and practical people.<br>&gt;<br>&gt; To put my thoughts into perspective, I should mention that<br>&gt; I¹ve taught Computer Science at a senior University level for years, and<br>&gt; have<br>&gt; worked in industry for decades. As a computer scientist, I¹ve had a strong<br>&gt; interest in computer languages for many years. I became an Apple developer<br>&gt; upon<br>&gt; purchasing an Apple Lisa a very long time ago.<br>&gt;<br>&gt; Over the past couple of years though, I¹ve seen what I think<br>&gt; of as a growing emphasis on strict feature orthagonality at the expense of<br>&gt; practicality in Swift. Perhaps this because much of the feedback on the<br>&gt; language has been provided by those of us who are interested in computer<br>&gt; languages. But for whatever reasons, the Swift language seems to have<br>&gt; become<br>&gt; more cluttered and less friendly.<br>&gt;<br>&gt; As I¹ve gone through the various beta releases, I¹ve seen<br>&gt; changes that detract from the experience of using Swift, for reasons that<br>&gt; seem<br>&gt; related to ³language purity².<br>&gt;<br>&gt; I was finally moved to try to express my thoughts after<br>&gt; seeing a couple of what I think of as particularly inadvisable proposals<br>&gt; for<br>&gt; Swift version 3 and beyond.<br>&gt;<br>&gt; Unary increment and decrement operators: ++ and ‹<br>&gt;<br>&gt; The first of these was the now approved removal of Swift¹s<br>&gt; convenient unary increment and decrement operators. I would agree with<br>&gt; some of<br>&gt; the comments that have been made about these operators not being quite<br>&gt; orthogonal with other expressive elements in the language. Nonetheless,<br>&gt; they<br>&gt; are a handy and popular way to iterate over enumerable collections, and to<br>&gt; increment and decrement a variable that is used for purposes other than<br>&gt; iteration. They also lend themselves to being extended to other data<br>&gt; types, such<br>&gt; as position pointers in linked lists, where they can implement the<br>&gt; convenient<br>&gt; concept of ³the next thing² (which += does not provide).<br>&gt;<br>&gt; The desire to get rid of these rather harmless operators<br>&gt; reminds me of some of Apple¹s own history, and the history of computer<br>&gt; languages in general. Niklaus Wirth didn¹t care for shortcut operators<br>&gt; either,<br>&gt; and so Pascal never got them.<br>&gt;<br>&gt; However, Apple eventually moved away from Pascal to C, even<br>&gt; though C is in many ways a deeply flawed language that is responsible for a<br>&gt; wide litany of software errors. Why? I personally really liked Pascal, but<br>&gt; many<br>&gt; (most) developers didn¹t care for the language. I¹d argue that developers<br>&gt; preferred the flexibility of C to what they saw as the overly restricting<br>&gt; constraints of Pascal.<br>&gt;<br>&gt; One of the surprising reasons that I heard a lot at the<br>&gt; time, was that developers didn¹t want to lose C¹s shortcut operators. If<br>&gt; Wirth<br>&gt; had been willing to give Pascal some of C¹s convenience operators, things<br>&gt; might<br>&gt; well have turned out differently. Developers hate typing.<br>&gt;<br>&gt; The notion that there should be exactly one way to do a<br>&gt; particular thing sounds like dogma to me: not practicality. If people are<br>&gt; concerned that unary operators confuse beginners, I would encourage them to<br>&gt; convince educators not to teach them to beginners. Anyway, there are a lot<br>&gt; of<br>&gt; things in Swift that can confuse beginners!<br>&gt;<br>&gt; Although it¹s hard for me to believe that having these<br>&gt; operators return void has been seriously considered, I would argue that<br>&gt; this<br>&gt; would be even sillier than removing them. A lot of developers use both C<br>&gt; (or<br>&gt; Objective C, C++, C#, Java, etc. etc.) and Swift ­ having those unary<br>&gt; operators<br>&gt; act completely differently in Swift would be a great way to alienate those<br>&gt; developers.<br>&gt;<br>&gt; Let¹s not forget that  Swift<br>&gt; is not the lingua franca of the computing world. It¹s an upstart that<br>&gt; needs to<br>&gt; attract the development community. Why repel people coming from the various<br>&gt; C-like languages without a really, really, convincingly good reason? it¹s<br>&gt; better for an upstart to attract than to repel.<br>&gt;<br>&gt; Right now, there are an awful lot of developers who are used<br>&gt; to, and like the convenience of unary increment and decrement operators.<br>&gt; Removing them seems bound to annoy developers and diminish the popularity<br>&gt; of<br>&gt; Swift, in exchange for Š well, not very much except for a tiny bit of<br>&gt; language<br>&gt; purity. That just seems silly to me.<br>&gt;<br>&gt; C-style For loops<br>&gt;<br>&gt; Removal of C-style For loops has already been approved for a<br>&gt; future version of Swift. Even though I find the C-style For loop to be a<br>&gt; bit<br>&gt; ugly and unintuitive, I believe that removing it was the wrong thing to do.<br>&gt;<br>&gt; It comes down to flexibility and expressiveness. The reality<br>&gt; is that C-style For loops easily implement certain operations that are more<br>&gt; difficult to implement without them.<br>&gt;<br>&gt; I¹ve seen comments that C-style For loops are ³hardly ever<br>&gt; used², and that ³hardly any² algorithms really need them. I believe that<br>&gt; ³hardly any² is a lazy mental shortcut for ³Well, I don¹t like them, and I<br>&gt; I<br>&gt; don¹t use them, so I don¹t think that any anyone who¹s important uses<br>&gt; them.².<br>&gt;<br>&gt; Yes, there are many cases in which I believe that Swift<br>&gt; provides looping structures that are safer and easier to understand than<br>&gt; the<br>&gt; C-style For loop. I¹d even say most cases. But I work in the scientific and<br>&gt; engineering domains, and can point to many instances of looping structures<br>&gt; that<br>&gt; are easily expressed with a C-style For loop, but are clumsy to implement<br>&gt; without it.<br>&gt;<br>&gt; In the world of the natural sciences, there are any number<br>&gt; of instances of loop increments that requires some kind of a calculation.<br>&gt; There<br>&gt; are any number of instances of dynamically calculated loop termination.<br>&gt;<br>&gt; Swift¹s stride has some nice features for simple increments,<br>&gt; but also has some important limitations. Among them, it involves the two<br>&gt; step<br>&gt; process of first creating an enumerable set, and then iterating over it.<br>&gt; In the<br>&gt; natural sciences, it is not uncommon for complex loop increments to be<br>&gt; used in<br>&gt; loops that are executed millions of times.<br>&gt;<br>&gt; Conceptually, creating an enumerable set, and then iterating over it,<br>&gt; reeks of the arrogance of assuming that computing resources are unlimited.<br>&gt; Even<br>&gt; though the compiler may optimize the stride into the loop structure, it<br>&gt; feels<br>&gt; like unnecessarily creating a gigantic enumerable set.<br>&gt;<br>&gt; Whether we like it or not, the enduring popularity of the<br>&gt; C-style For loop comes from it¹s flexibility. Swift doesn¹t have a better<br>&gt; alternative that also provides the same flexibility. So don¹t take it<br>&gt; away. If<br>&gt; you don¹t like it (I don¹t always either), think of something that is<br>&gt; clearly<br>&gt; superior in 100% of use cases. Even then, I would argue against removing<br>&gt; it.<br>&gt;<br>&gt; I would argue that the C-style For loop implements some<br>&gt; rather Swift-like concepts. The syntax provide for three closures: one<br>&gt; each for<br>&gt; (a) things to do first, (b) things to do when deciding whether to stop<br>&gt; iterating,  and (c) things to do after each iteration. How is that contrary<br>&gt; to the principals of Swift?<br>&gt;<br>&gt; Just like pretty much everywhere that Swift allows closures,<br>&gt; they can be used to write code that is difficult to understand. But the<br>&gt; syntax<br>&gt; is general and flexible enough to have survived intact for half a century.<br>&gt;<br>&gt; It¹s the carrot vs. the stick. Developers prefer the carrot.<br>&gt; The belief that we can force developers to write better code by taking away<br>&gt; language features, has not historically met with success. Let me say that<br>&gt; again, because I think it¹s important. Developers who are given a choice<br>&gt; between C and a ³better² language (say Modula-2, or Swift) are unlikely to<br>&gt; react favourably to being told ³we¹re taking away this feature of C that<br>&gt; you<br>&gt; like, for your own good, because you¹re too stupid to use it sensibly².<br>&gt; Taking away well-understood expressive language elements, and replacing<br>&gt; them with something less expressive, is not going to win developers over.<br>&gt;<br>&gt; C-style For loops haven¹t changed in half acentury, because they work.<br>&gt; A lot of other languages have also adopted them, because they work.<br>&gt;<br>&gt; If I may, I¹d like to take the English language by way of<br>&gt; analogy. English contains a lot of weird, irregular language elements.<br>&gt; There¹s<br>&gt; no single way to express a concept. Instead, there are many, subtly<br>&gt; different<br>&gt; ways to express yourself.<br>&gt;<br>&gt; But, for all of its weirdness, English has remained popular<br>&gt; for centuries, whereas more ³sensible², ³regular² languages like Esperanto<br>&gt; never caught on. The reasons are flexibility and expressiveness. The same<br>&gt; thing<br>&gt; applies to computer languages.<br>&gt;<br>&gt; If we only look inside the world of compilers and computer<br>&gt; science instruction, to see if we need the flexibility of C-style For<br>&gt; loops, we<br>&gt; might mistakenly think that we don¹t. But those domains are relatively<br>&gt; simple<br>&gt; in comparison to the physical sciences. Our experience there doesn¹t always<br>&gt; translate to the more complex world of physical reality. So let¹s not throw<br>&gt; away convenient and useful language features just because we don¹t<br>&gt; personally<br>&gt; care for them.<br>&gt;<br>&gt; Don¹t make Swift Yet Another Interesting Experiment in<br>&gt; language design that wasn¹t widely adopted, and<br>&gt; ended up being relegated to the dustbin of history.<br>&gt; It would make me sad to see the best new computer language<br>&gt; in ages become just another niche language. We already<br>&gt; have enough of those.<br>&gt;<br>&gt; So, all of you folks who voted to remove these things, please don¹t hate<br>&gt; me!<br>&gt;<br>&gt; Regards,<br>&gt; J. Heerema, Ph.D.<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160403/3ea1b053/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>Revisiting 0004 etc. - Swift deprecations</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>April  3, 2016 at 11:00:00am</p></header><div class="content"><p>On that note here is a convenient pattern I&#39;ve used in the rare cases I<br>haven&#39;t been able to convert to a &quot;for in&quot; syntax when refactoring:<br></p><p>var i = 0<br></p><p>while i &lt; 10 {<br></p><p>    defer { i += 1 }<br></p><p>    print(i)<br></p><p>}<br></p><p><br>To be honest I don&#39;t really mind this syntax, I often found during<br>refactoring:<br> * the c-style &quot;for&quot; was broken up over multiple lines anyway<br> * I wanted the last value of `i` outside the loop, so it was written &quot;for ;<br>check; incr&quot;<br> * It still works with continue, although it does increment &quot;i&quot; on break<br></p><p><br>On Sun, Apr 3, 2016 at 11:19 AM, Ross O&#39;Brien via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Because you&#39;re coming to the discussion late, the arguments you&#39;re making<br>&gt; are a little out of date. It&#39;s no longer a case of not removing these<br>&gt; features. It&#39;s now a case of having a compelling reason to put them back.<br>&gt;<br>&gt; I trust you&#39;ve read the proposals that were put forward. For the benefit<br>&gt; of those reading, they&#39;re here:<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0004-remove-pre-post-inc-decrement.md<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0007-remove-c-style-for-loops.md<br>&gt;<br>&gt; There are several disadvantages listed for keeping these two features.<br>&gt; Those are the arguments you need to counter. As it happens, both proposals<br>&gt; refer to the metric of &#39;if this wasn&#39;t already in Swift, would it be<br>&gt; accepted for Swift 3?&#39; and both features have been deemed to fail this<br>&gt; criterion. That&#39;s what you need to address.<br>&gt;<br>&gt; Bear in mind these decisions were made several months ago, and both<br>&gt; features have already been deprecated as of Swift 2.2, which is now in use<br>&gt; in production code, many developers (including myself) are already<br>&gt; refactoring their code to remove uses of these syntax forms.<br>&gt;<br>&gt;<br>&gt; On Sun, Apr 3, 2016 at 12:45 AM, John Heerema via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Warning - long post.<br>&gt;&gt; I know that some folks really hate long posts, so let me apologize right<br>&gt;&gt; now for this being a long post. Please feel free to skip right on past it.<br>&gt;&gt; I posted it on a weekend, when there¹s less mailing list traffic, but that<br>&gt;&gt; doesn¹t make it any shorter.<br>&gt;&gt;<br>&gt;&gt; Warning - revisits two approved deprecations.<br>&gt;&gt; If you really, really hate it when people want to revisit decisions that<br>&gt;&gt; have already been made, please just skip right past this post. My<br>&gt;&gt; apologies for not contributing to the discussion when these decisions were<br>&gt;&gt; originally being made!<br>&gt;&gt;<br>&gt;&gt; The day that Swift was announced at the WWDC was very<br>&gt;&gt; exciting for me, and I immediately read the Swift book from beginning to<br>&gt;&gt; end.<br>&gt;&gt; Swift quickly became my favourite language: I felt that the Swift language<br>&gt;&gt; developers had created a beautiful language that combined expressiveness<br>&gt;&gt; with<br>&gt;&gt; practicality in a way that made Swift code both powerful and easy to<br>&gt;&gt; understand. Swift was crafted by some very smart and practical people.<br>&gt;&gt;<br>&gt;&gt; To put my thoughts into perspective, I should mention that<br>&gt;&gt; I¹ve taught Computer Science at a senior University level for years, and<br>&gt;&gt; have<br>&gt;&gt; worked in industry for decades. As a computer scientist, I¹ve had a strong<br>&gt;&gt; interest in computer languages for many years. I became an Apple developer<br>&gt;&gt; upon<br>&gt;&gt; purchasing an Apple Lisa a very long time ago.<br>&gt;&gt;<br>&gt;&gt; Over the past couple of years though, I¹ve seen what I think<br>&gt;&gt; of as a growing emphasis on strict feature orthagonality at the expense of<br>&gt;&gt; practicality in Swift. Perhaps this because much of the feedback on the<br>&gt;&gt; language has been provided by those of us who are interested in computer<br>&gt;&gt; languages. But for whatever reasons, the Swift language seems to have<br>&gt;&gt; become<br>&gt;&gt; more cluttered and less friendly.<br>&gt;&gt;<br>&gt;&gt; As I¹ve gone through the various beta releases, I¹ve seen<br>&gt;&gt; changes that detract from the experience of using Swift, for reasons that<br>&gt;&gt; seem<br>&gt;&gt; related to ³language purity².<br>&gt;&gt;<br>&gt;&gt; I was finally moved to try to express my thoughts after<br>&gt;&gt; seeing a couple of what I think of as particularly inadvisable proposals<br>&gt;&gt; for<br>&gt;&gt; Swift version 3 and beyond.<br>&gt;&gt;<br>&gt;&gt; Unary increment and decrement operators: ++ and ‹<br>&gt;&gt;<br>&gt;&gt; The first of these was the now approved removal of Swift¹s<br>&gt;&gt; convenient unary increment and decrement operators. I would agree with<br>&gt;&gt; some of<br>&gt;&gt; the comments that have been made about these operators not being quite<br>&gt;&gt; orthogonal with other expressive elements in the language. Nonetheless,<br>&gt;&gt; they<br>&gt;&gt; are a handy and popular way to iterate over enumerable collections, and to<br>&gt;&gt; increment and decrement a variable that is used for purposes other than<br>&gt;&gt; iteration. They also lend themselves to being extended to other data<br>&gt;&gt; types, such<br>&gt;&gt; as position pointers in linked lists, where they can implement the<br>&gt;&gt; convenient<br>&gt;&gt; concept of ³the next thing² (which += does not provide).<br>&gt;&gt;<br>&gt;&gt; The desire to get rid of these rather harmless operators<br>&gt;&gt; reminds me of some of Apple¹s own history, and the history of computer<br>&gt;&gt; languages in general. Niklaus Wirth didn¹t care for shortcut operators<br>&gt;&gt; either,<br>&gt;&gt; and so Pascal never got them.<br>&gt;&gt;<br>&gt;&gt; However, Apple eventually moved away from Pascal to C, even<br>&gt;&gt; though C is in many ways a deeply flawed language that is responsible for<br>&gt;&gt; a<br>&gt;&gt; wide litany of software errors. Why? I personally really liked Pascal, but<br>&gt;&gt; many<br>&gt;&gt; (most) developers didn¹t care for the language. I¹d argue that developers<br>&gt;&gt; preferred the flexibility of C to what they saw as the overly restricting<br>&gt;&gt; constraints of Pascal.<br>&gt;&gt;<br>&gt;&gt; One of the surprising reasons that I heard a lot at the<br>&gt;&gt; time, was that developers didn¹t want to lose C¹s shortcut operators. If<br>&gt;&gt; Wirth<br>&gt;&gt; had been willing to give Pascal some of C¹s convenience operators, things<br>&gt;&gt; might<br>&gt;&gt; well have turned out differently. Developers hate typing.<br>&gt;&gt;<br>&gt;&gt; The notion that there should be exactly one way to do a<br>&gt;&gt; particular thing sounds like dogma to me: not practicality. If people are<br>&gt;&gt; concerned that unary operators confuse beginners, I would encourage them<br>&gt;&gt; to<br>&gt;&gt; convince educators not to teach them to beginners. Anyway, there are a lot<br>&gt;&gt; of<br>&gt;&gt; things in Swift that can confuse beginners!<br>&gt;&gt;<br>&gt;&gt; Although it¹s hard for me to believe that having these<br>&gt;&gt; operators return void has been seriously considered, I would argue that<br>&gt;&gt; this<br>&gt;&gt; would be even sillier than removing them. A lot of developers use both C<br>&gt;&gt; (or<br>&gt;&gt; Objective C, C++, C#, Java, etc. etc.) and Swift ­ having those unary<br>&gt;&gt; operators<br>&gt;&gt; act completely differently in Swift would be a great way to alienate those<br>&gt;&gt; developers.<br>&gt;&gt;<br>&gt;&gt; Let¹s not forget that  Swift<br>&gt;&gt; is not the lingua franca of the computing world. It¹s an upstart that<br>&gt;&gt; needs to<br>&gt;&gt; attract the development community. Why repel people coming from the<br>&gt;&gt; various<br>&gt;&gt; C-like languages without a really, really, convincingly good reason? it¹s<br>&gt;&gt; better for an upstart to attract than to repel.<br>&gt;&gt;<br>&gt;&gt; Right now, there are an awful lot of developers who are used<br>&gt;&gt; to, and like the convenience of unary increment and decrement operators.<br>&gt;&gt; Removing them seems bound to annoy developers and diminish the popularity<br>&gt;&gt; of<br>&gt;&gt; Swift, in exchange for Š well, not very much except for a tiny bit of<br>&gt;&gt; language<br>&gt;&gt; purity. That just seems silly to me.<br>&gt;&gt;<br>&gt;&gt; C-style For loops<br>&gt;&gt;<br>&gt;&gt; Removal of C-style For loops has already been approved for a<br>&gt;&gt; future version of Swift. Even though I find the C-style For loop to be a<br>&gt;&gt; bit<br>&gt;&gt; ugly and unintuitive, I believe that removing it was the wrong thing to<br>&gt;&gt; do.<br>&gt;&gt;<br>&gt;&gt; It comes down to flexibility and expressiveness. The reality<br>&gt;&gt; is that C-style For loops easily implement certain operations that are<br>&gt;&gt; more<br>&gt;&gt; difficult to implement without them.<br>&gt;&gt;<br>&gt;&gt; I¹ve seen comments that C-style For loops are ³hardly ever<br>&gt;&gt; used², and that ³hardly any² algorithms really need them. I believe that<br>&gt;&gt; ³hardly any² is a lazy mental shortcut for ³Well, I don¹t like them, and I<br>&gt;&gt; I<br>&gt;&gt; don¹t use them, so I don¹t think that any anyone who¹s important uses<br>&gt;&gt; them.².<br>&gt;&gt;<br>&gt;&gt; Yes, there are many cases in which I believe that Swift<br>&gt;&gt; provides looping structures that are safer and easier to understand than<br>&gt;&gt; the<br>&gt;&gt; C-style For loop. I¹d even say most cases. But I work in the scientific<br>&gt;&gt; and<br>&gt;&gt; engineering domains, and can point to many instances of looping structures<br>&gt;&gt; that<br>&gt;&gt; are easily expressed with a C-style For loop, but are clumsy to implement<br>&gt;&gt; without it.<br>&gt;&gt;<br>&gt;&gt; In the world of the natural sciences, there are any number<br>&gt;&gt; of instances of loop increments that requires some kind of a calculation.<br>&gt;&gt; There<br>&gt;&gt; are any number of instances of dynamically calculated loop termination.<br>&gt;&gt;<br>&gt;&gt; Swift¹s stride has some nice features for simple increments,<br>&gt;&gt; but also has some important limitations. Among them, it involves the two<br>&gt;&gt; step<br>&gt;&gt; process of first creating an enumerable set, and then iterating over it.<br>&gt;&gt; In the<br>&gt;&gt; natural sciences, it is not uncommon for complex loop increments to be<br>&gt;&gt; used in<br>&gt;&gt; loops that are executed millions of times.<br>&gt;&gt;<br>&gt;&gt; Conceptually, creating an enumerable set, and then iterating over it,<br>&gt;&gt; reeks of the arrogance of assuming that computing resources are unlimited.<br>&gt;&gt; Even<br>&gt;&gt; though the compiler may optimize the stride into the loop structure, it<br>&gt;&gt; feels<br>&gt;&gt; like unnecessarily creating a gigantic enumerable set.<br>&gt;&gt;<br>&gt;&gt; Whether we like it or not, the enduring popularity of the<br>&gt;&gt; C-style For loop comes from it¹s flexibility. Swift doesn¹t have a better<br>&gt;&gt; alternative that also provides the same flexibility. So don¹t take it<br>&gt;&gt; away. If<br>&gt;&gt; you don¹t like it (I don¹t always either), think of something that is<br>&gt;&gt; clearly<br>&gt;&gt; superior in 100% of use cases. Even then, I would argue against removing<br>&gt;&gt; it.<br>&gt;&gt;<br>&gt;&gt; I would argue that the C-style For loop implements some<br>&gt;&gt; rather Swift-like concepts. The syntax provide for three closures: one<br>&gt;&gt; each for<br>&gt;&gt; (a) things to do first, (b) things to do when deciding whether to stop<br>&gt;&gt; iterating,  and (c) things to do after each iteration. How is that<br>&gt;&gt; contrary<br>&gt;&gt; to the principals of Swift?<br>&gt;&gt;<br>&gt;&gt; Just like pretty much everywhere that Swift allows closures,<br>&gt;&gt; they can be used to write code that is difficult to understand. But the<br>&gt;&gt; syntax<br>&gt;&gt; is general and flexible enough to have survived intact for half a century.<br>&gt;&gt;<br>&gt;&gt; It¹s the carrot vs. the stick. Developers prefer the carrot.<br>&gt;&gt; The belief that we can force developers to write better code by taking<br>&gt;&gt; away<br>&gt;&gt; language features, has not historically met with success. Let me say that<br>&gt;&gt; again, because I think it¹s important. Developers who are given a choice<br>&gt;&gt; between C and a ³better² language (say Modula-2, or Swift) are unlikely to<br>&gt;&gt; react favourably to being told ³we¹re taking away this feature of C that<br>&gt;&gt; you<br>&gt;&gt; like, for your own good, because you¹re too stupid to use it sensibly².<br>&gt;&gt; Taking away well-understood expressive language elements, and replacing<br>&gt;&gt; them with something less expressive, is not going to win developers over.<br>&gt;&gt;<br>&gt;&gt; C-style For loops haven¹t changed in half acentury, because they work.<br>&gt;&gt; A lot of other languages have also adopted them, because they work.<br>&gt;&gt;<br>&gt;&gt; If I may, I¹d like to take the English language by way of<br>&gt;&gt; analogy. English contains a lot of weird, irregular language elements.<br>&gt;&gt; There¹s<br>&gt;&gt; no single way to express a concept. Instead, there are many, subtly<br>&gt;&gt; different<br>&gt;&gt; ways to express yourself.<br>&gt;&gt;<br>&gt;&gt; But, for all of its weirdness, English has remained popular<br>&gt;&gt; for centuries, whereas more ³sensible², ³regular² languages like Esperanto<br>&gt;&gt; never caught on. The reasons are flexibility and expressiveness. The same<br>&gt;&gt; thing<br>&gt;&gt; applies to computer languages.<br>&gt;&gt;<br>&gt;&gt; If we only look inside the world of compilers and computer<br>&gt;&gt; science instruction, to see if we need the flexibility of C-style For<br>&gt;&gt; loops, we<br>&gt;&gt; might mistakenly think that we don¹t. But those domains are relatively<br>&gt;&gt; simple<br>&gt;&gt; in comparison to the physical sciences. Our experience there doesn¹t<br>&gt;&gt; always<br>&gt;&gt; translate to the more complex world of physical reality. So let¹s not<br>&gt;&gt; throw<br>&gt;&gt; away convenient and useful language features just because we don¹t<br>&gt;&gt; personally<br>&gt;&gt; care for them.<br>&gt;&gt;<br>&gt;&gt; Don¹t make Swift Yet Another Interesting Experiment in<br>&gt;&gt; language design that wasn¹t widely adopted, and<br>&gt;&gt; ended up being relegated to the dustbin of history.<br>&gt;&gt; It would make me sad to see the best new computer language<br>&gt;&gt; in ages become just another niche language. We already<br>&gt;&gt; have enough of those.<br>&gt;&gt;<br>&gt;&gt; So, all of you folks who voted to remove these things, please don¹t hate<br>&gt;&gt; me!<br>&gt;&gt;<br>&gt;&gt; Regards,<br>&gt;&gt; J. Heerema, Ph.D.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160403/a0b0a768/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Revisiting 0004 etc. - Swift deprecations</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>April  2, 2016 at 08:00:00pm</p></header><div class="content"><p>While this style works, and definitely can substitute for a classical for loop, it is not quite as nice, because it cannot limit i’s scope to the loop. The variable will be visible outside of the loop body.<br></p><p>Charles<br></p><p>&gt; On Apr 2, 2016, at 8:43 PM, Andrew Bennett via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On that note here is a convenient pattern I&#39;ve used in the rare cases I haven&#39;t been able to convert to a &quot;for in&quot; syntax when refactoring:<br>&gt; <br>&gt; var i = 0<br>&gt; while i &lt; 10 {<br>&gt;     defer { i += 1 }<br>&gt;     print(i)<br>&gt; }<br>&gt; <br>&gt; To be honest I don&#39;t really mind this syntax, I often found during refactoring:<br>&gt;  * the c-style &quot;for&quot; was broken up over multiple lines anyway<br>&gt;  * I wanted the last value of `i` outside the loop, so it was written &quot;for ; check; incr&quot;<br>&gt;  * It still works with continue, although it does increment &quot;i&quot; on break<br>&gt; <br>&gt; <br>&gt; On Sun, Apr 3, 2016 at 11:19 AM, Ross O&#39;Brien via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Because you&#39;re coming to the discussion late, the arguments you&#39;re making are a little out of date. It&#39;s no longer a case of not removing these features. It&#39;s now a case of having a compelling reason to put them back.<br>&gt; <br>&gt; I trust you&#39;ve read the proposals that were put forward. For the benefit of those reading, they&#39;re here:<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0004-remove-pre-post-inc-decrement.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0004-remove-pre-post-inc-decrement.md&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0007-remove-c-style-for-loops.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0007-remove-c-style-for-loops.md&gt;<br>&gt; <br>&gt; There are several disadvantages listed for keeping these two features. Those are the arguments you need to counter. As it happens, both proposals refer to the metric of &#39;if this wasn&#39;t already in Swift, would it be accepted for Swift 3?&#39; and both features have been deemed to fail this criterion. That&#39;s what you need to address.<br>&gt; <br>&gt; Bear in mind these decisions were made several months ago, and both features have already been deprecated as of Swift 2.2, which is now in use in production code, many developers (including myself) are already refactoring their code to remove uses of these syntax forms.<br>&gt; <br>&gt; <br>&gt; On Sun, Apr 3, 2016 at 12:45 AM, John Heerema via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Warning - long post.<br>&gt; I know that some folks really hate long posts, so let me apologize right<br>&gt; now for this being a long post. Please feel free to skip right on past it.<br>&gt; I posted it on a weekend, when there¹s less mailing list traffic, but that<br>&gt; doesn¹t make it any shorter.<br>&gt; <br>&gt; Warning - revisits two approved deprecations.<br>&gt; If you really, really hate it when people want to revisit decisions that<br>&gt; have already been made, please just skip right past this post. My<br>&gt; apologies for not contributing to the discussion when these decisions were<br>&gt; originally being made!<br>&gt; <br>&gt; The day that Swift was announced at the WWDC was very<br>&gt; exciting for me, and I immediately read the Swift book from beginning to<br>&gt; end.<br>&gt; Swift quickly became my favourite language: I felt that the Swift language<br>&gt; developers had created a beautiful language that combined expressiveness<br>&gt; with<br>&gt; practicality in a way that made Swift code both powerful and easy to<br>&gt; understand. Swift was crafted by some very smart and practical people.<br>&gt; <br>&gt; To put my thoughts into perspective, I should mention that<br>&gt; I¹ve taught Computer Science at a senior University level for years, and<br>&gt; have<br>&gt; worked in industry for decades. As a computer scientist, I¹ve had a strong<br>&gt; interest in computer languages for many years. I became an Apple developer<br>&gt; upon<br>&gt; purchasing an Apple Lisa a very long time ago.<br>&gt; <br>&gt; Over the past couple of years though, I¹ve seen what I think<br>&gt; of as a growing emphasis on strict feature orthagonality at the expense of<br>&gt; practicality in Swift. Perhaps this because much of the feedback on the<br>&gt; language has been provided by those of us who are interested in computer<br>&gt; languages. But for whatever reasons, the Swift language seems to have<br>&gt; become<br>&gt; more cluttered and less friendly.<br>&gt; <br>&gt; As I¹ve gone through the various beta releases, I¹ve seen<br>&gt; changes that detract from the experience of using Swift, for reasons that<br>&gt; seem<br>&gt; related to ³language purity².<br>&gt; <br>&gt; I was finally moved to try to express my thoughts after<br>&gt; seeing a couple of what I think of as particularly inadvisable proposals<br>&gt; for<br>&gt; Swift version 3 and beyond.<br>&gt; <br>&gt; Unary increment and decrement operators: ++ and ‹<br>&gt; <br>&gt; The first of these was the now approved removal of Swift¹s<br>&gt; convenient unary increment and decrement operators. I would agree with<br>&gt; some of<br>&gt; the comments that have been made about these operators not being quite<br>&gt; orthogonal with other expressive elements in the language. Nonetheless,<br>&gt; they<br>&gt; are a handy and popular way to iterate over enumerable collections, and to<br>&gt; increment and decrement a variable that is used for purposes other than<br>&gt; iteration. They also lend themselves to being extended to other data<br>&gt; types, such<br>&gt; as position pointers in linked lists, where they can implement the<br>&gt; convenient<br>&gt; concept of ³the next thing² (which += does not provide).<br>&gt; <br>&gt; The desire to get rid of these rather harmless operators<br>&gt; reminds me of some of Apple¹s own history, and the history of computer<br>&gt; languages in general. Niklaus Wirth didn¹t care for shortcut operators<br>&gt; either,<br>&gt; and so Pascal never got them.<br>&gt; <br>&gt; However, Apple eventually moved away from Pascal to C, even<br>&gt; though C is in many ways a deeply flawed language that is responsible for a<br>&gt; wide litany of software errors. Why? I personally really liked Pascal, but<br>&gt; many<br>&gt; (most) developers didn¹t care for the language. I¹d argue that developers<br>&gt; preferred the flexibility of C to what they saw as the overly restricting<br>&gt; constraints of Pascal.<br>&gt; <br>&gt; One of the surprising reasons that I heard a lot at the<br>&gt; time, was that developers didn¹t want to lose C¹s shortcut operators. If<br>&gt; Wirth<br>&gt; had been willing to give Pascal some of C¹s convenience operators, things<br>&gt; might<br>&gt; well have turned out differently. Developers hate typing.<br>&gt; <br>&gt; The notion that there should be exactly one way to do a<br>&gt; particular thing sounds like dogma to me: not practicality. If people are<br>&gt; concerned that unary operators confuse beginners, I would encourage them to<br>&gt; convince educators not to teach them to beginners. Anyway, there are a lot<br>&gt; of<br>&gt; things in Swift that can confuse beginners!<br>&gt; <br>&gt; Although it¹s hard for me to believe that having these<br>&gt; operators return void has been seriously considered, I would argue that<br>&gt; this<br>&gt; would be even sillier than removing them. A lot of developers use both C<br>&gt; (or<br>&gt; Objective C, C++, C#, Java, etc. etc.) and Swift ­ having those unary<br>&gt; operators<br>&gt; act completely differently in Swift would be a great way to alienate those<br>&gt; developers.<br>&gt; <br>&gt; Let¹s not forget that  Swift<br>&gt; is not the lingua franca of the computing world. It¹s an upstart that<br>&gt; needs to<br>&gt; attract the development community. Why repel people coming from the various<br>&gt; C-like languages without a really, really, convincingly good reason? it¹s<br>&gt; better for an upstart to attract than to repel.<br>&gt; <br>&gt; Right now, there are an awful lot of developers who are used<br>&gt; to, and like the convenience of unary increment and decrement operators.<br>&gt; Removing them seems bound to annoy developers and diminish the popularity<br>&gt; of<br>&gt; Swift, in exchange for Š well, not very much except for a tiny bit of<br>&gt; language<br>&gt; purity. That just seems silly to me.<br>&gt; <br>&gt; C-style For loops<br>&gt; <br>&gt; Removal of C-style For loops has already been approved for a<br>&gt; future version of Swift. Even though I find the C-style For loop to be a<br>&gt; bit<br>&gt; ugly and unintuitive, I believe that removing it was the wrong thing to do.<br>&gt; <br>&gt; It comes down to flexibility and expressiveness. The reality<br>&gt; is that C-style For loops easily implement certain operations that are more<br>&gt; difficult to implement without them.<br>&gt; <br>&gt; I¹ve seen comments that C-style For loops are ³hardly ever<br>&gt; used², and that ³hardly any² algorithms really need them. I believe that<br>&gt; ³hardly any² is a lazy mental shortcut for ³Well, I don¹t like them, and I<br>&gt; I<br>&gt; don¹t use them, so I don¹t think that any anyone who¹s important uses<br>&gt; them.².<br>&gt; <br>&gt; Yes, there are many cases in which I believe that Swift<br>&gt; provides looping structures that are safer and easier to understand than<br>&gt; the<br>&gt; C-style For loop. I¹d even say most cases. But I work in the scientific and<br>&gt; engineering domains, and can point to many instances of looping structures<br>&gt; that<br>&gt; are easily expressed with a C-style For loop, but are clumsy to implement<br>&gt; without it.<br>&gt; <br>&gt; In the world of the natural sciences, there are any number<br>&gt; of instances of loop increments that requires some kind of a calculation.<br>&gt; There<br>&gt; are any number of instances of dynamically calculated loop termination.<br>&gt; <br>&gt; Swift¹s stride has some nice features for simple increments,<br>&gt; but also has some important limitations. Among them, it involves the two<br>&gt; step<br>&gt; process of first creating an enumerable set, and then iterating over it.<br>&gt; In the<br>&gt; natural sciences, it is not uncommon for complex loop increments to be<br>&gt; used in<br>&gt; loops that are executed millions of times.<br>&gt; <br>&gt; Conceptually, creating an enumerable set, and then iterating over it,<br>&gt; reeks of the arrogance of assuming that computing resources are unlimited.<br>&gt; Even<br>&gt; though the compiler may optimize the stride into the loop structure, it<br>&gt; feels<br>&gt; like unnecessarily creating a gigantic enumerable set.<br>&gt; <br>&gt; Whether we like it or not, the enduring popularity of the<br>&gt; C-style For loop comes from it¹s flexibility. Swift doesn¹t have a better<br>&gt; alternative that also provides the same flexibility. So don¹t take it<br>&gt; away. If<br>&gt; you don¹t like it (I don¹t always either), think of something that is<br>&gt; clearly<br>&gt; superior in 100% of use cases. Even then, I would argue against removing<br>&gt; it.<br>&gt; <br>&gt; I would argue that the C-style For loop implements some<br>&gt; rather Swift-like concepts. The syntax provide for three closures: one<br>&gt; each for<br>&gt; (a) things to do first, (b) things to do when deciding whether to stop<br>&gt; iterating,  and (c) things to do after each iteration. How is that contrary<br>&gt; to the principals of Swift?<br>&gt; <br>&gt; Just like pretty much everywhere that Swift allows closures,<br>&gt; they can be used to write code that is difficult to understand. But the<br>&gt; syntax<br>&gt; is general and flexible enough to have survived intact for half a century.<br>&gt; <br>&gt; It¹s the carrot vs. the stick. Developers prefer the carrot.<br>&gt; The belief that we can force developers to write better code by taking away<br>&gt; language features, has not historically met with success. Let me say that<br>&gt; again, because I think it¹s important. Developers who are given a choice<br>&gt; between C and a ³better² language (say Modula-2, or Swift) are unlikely to<br>&gt; react favourably to being told ³we¹re taking away this feature of C that<br>&gt; you<br>&gt; like, for your own good, because you¹re too stupid to use it sensibly².<br>&gt; Taking away well-understood expressive language elements, and replacing<br>&gt; them with something less expressive, is not going to win developers over.<br>&gt; <br>&gt; C-style For loops haven¹t changed in half acentury, because they work.<br>&gt; A lot of other languages have also adopted them, because they work.<br>&gt; <br>&gt; If I may, I¹d like to take the English language by way of<br>&gt; analogy. English contains a lot of weird, irregular language elements.<br>&gt; There¹s<br>&gt; no single way to express a concept. Instead, there are many, subtly<br>&gt; different<br>&gt; ways to express yourself.<br>&gt; <br>&gt; But, for all of its weirdness, English has remained popular<br>&gt; for centuries, whereas more ³sensible², ³regular² languages like Esperanto<br>&gt; never caught on. The reasons are flexibility and expressiveness. The same<br>&gt; thing<br>&gt; applies to computer languages.<br>&gt; <br>&gt; If we only look inside the world of compilers and computer<br>&gt; science instruction, to see if we need the flexibility of C-style For<br>&gt; loops, we<br>&gt; might mistakenly think that we don¹t. But those domains are relatively<br>&gt; simple<br>&gt; in comparison to the physical sciences. Our experience there doesn¹t always<br>&gt; translate to the more complex world of physical reality. So let¹s not throw<br>&gt; away convenient and useful language features just because we don¹t<br>&gt; personally<br>&gt; care for them.<br>&gt; <br>&gt; Don¹t make Swift Yet Another Interesting Experiment in<br>&gt; language design that wasn¹t widely adopted, and<br>&gt; ended up being relegated to the dustbin of history.<br>&gt; It would make me sad to see the best new computer language<br>&gt; in ages become just another niche language. We already<br>&gt; have enough of those.<br>&gt; <br>&gt; So, all of you folks who voted to remove these things, please don¹t hate<br>&gt; me!<br>&gt; <br>&gt; Regards,<br>&gt; J. Heerema, Ph.D.<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160402/77759938/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Revisiting 0004 etc. - Swift deprecations</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>April  2, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Apr 2, 2016, at 20:49, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; While this style works, and definitely can substitute for a classical for loop, it is not quite as nice, because it cannot limit i’s scope to the loop. The variable will be visible outside of the loop body.<br></p><p>I agree it&#39;s not as nice aesthetically, but does the loop variable being visible outside the loop cause any real-world problems?<br></p><p>- Dave Sweeris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>Revisiting 0004 etc. - Swift deprecations</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>April  2, 2016 at 09:00:00pm</p></header><div class="content"><p>The C99 spec changed the scoping rules to address the very issue you are asking about having any &quot;real-world impact&quot;.<br></p><p>Yes, the variable outside does matter. It&#39;s why you see some code like this, even with C++ because it used to not scope locally there too with all compilers:<br></p><p>{for (int i= 0; i&lt;10; i++) { ... }}<br></p><p>And as fully explained in the previous threads on the topic, the defer pattern is an insufficient mechanism to generically be used for all c-style for loop constructs. <br></p><p>-David<br></p><p>Sent from my iPad<br></p><p>&gt; On Apr 2, 2016, at 7:35 PM, David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 2, 2016, at 20:49, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; While this style works, and definitely can substitute for a classical for loop, it is not quite as nice, because it cannot limit i’s scope to the loop. The variable will be visible outside of the loop body.<br>&gt; <br>&gt; I agree it&#39;s not as nice aesthetically, but does the loop variable being visible outside the loop cause any real-world problems?<br>&gt; <br>&gt; - Dave Sweeris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ab486d7597af4cfe0be33a762150848?s=50"></div><header><strong>Revisiting 0004 etc. - Swift deprecations</strong> from <string>Dany St-Amant</string> &lt;dsa.mls at icloud.com&gt;<p>April 10, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; Le 2 avr. 2016 à 21:43, Andrew Bennett via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; On that note here is a convenient pattern I&#39;ve used in the rare cases I haven&#39;t been able to convert to a &quot;for in&quot; syntax when refactoring:<br>&gt; <br>&gt; var i = 0<br>&gt; while i &lt; 10 {<br>&gt;     defer { i += 1 }<br>&gt;     print(i)<br>&gt; }<br>&gt; <br>&gt; To be honest I don&#39;t really mind this syntax, I often found during refactoring:<br>&gt;  * the c-style &quot;for&quot; was broken up over multiple lines anyway<br>&gt;  * I wanted the last value of `i` outside the loop, so it was written &quot;for ; check; incr&quot;<br>&gt;  * It still works with continue, although it does increment &quot;i&quot; on break<br>&gt; <br></p><p>Interesting pattern, it closely match with the &quot;sugar&quot; that C provides around ‘while’ in the form of &#39;for(;;)’<br></p><p>The following C snippet<br></p><p>#define INITIALIZER (i = 0)<br>#define TEST (i &lt; 10)<br>#define STEPPER (i += 1)<br></p><p>for (INITIALIZER; TEST; STEPPER)<br>{<br>  if (i % 2 == 0) { continue; }<br>  if (i % 5 == 0) { break; }<br>  printf(&quot;%d\n&quot;,i);<br>}<br></p><p>can be written (reusing the #define)<br></p><p>INITIALIZER;<br>while TEST<br>{<br>  if (i % 2 == 0) { STEPPER; continue; }<br>  if (i % 5 == 0) { break; }<br>  printf(&quot;%d\n&quot;,i);<br>  STEPPER;<br>}<br></p><p>Beside the break issue, making use of ‘defer’ causes the nested continue to misbehave:<br></p><p>    var i = 0<br>    loop_i:<br>    while i &lt; 10 {<br>        defer { i += 1 }<br>        defer { print(&quot;---&quot;,j) }<br>        var j = 0<br>        loop_j:<br>        while j &lt; 10 {<br>            defer { j += 1 }<br>            if j % 2 == 0 { continue loop_j }<br>            if j % 5 == 0 { continue loop_i }<br>            print(i,j)<br>        }<br>    }<br></p><p>In this example, the ‘continue loop_i’ does increase ‘j’, but I would not expect that; since C doesn&#39;t  allow to directly continue an outer loop I cannot compare my opinion against the real world.<br></p><p>Should we pursue having a ‘defer(@oncontinue)’ or a new ‘continuer’ (don’t really like that name)?<br></p><p>With this lone new syntax, all the imaginable &#39;for(;;)’ can be blindly ported to Swift, with all the advantages and disadvantages of the C version. Reusing my #define as placeholders, any C-world ‘for(;;)’ can be written in Swift as:<br></p><p>	INITIALIZER<br>	while TEST<br>	{<br>		defer(@oncontinue) { STEPPER }<br>		// Work load<br>	} <br></p><p>In a nested loop environment, this could be used like:<br></p><p>    var i = 0<br>    loop_i:<br>    while i &lt; 10 {<br>        defer(@onncontinue) { i += 1 }<br>        var j = 0<br>        loop_j:<br>        while j &lt; 10 {<br>            defer(@oncontinue) { j += 1 }<br>            if j % 2 == 0 { continue loop_j /* j += 1 */}<br>            if j % 5 == 0 { continue loop_i /* i += 1, but NOT j += 1*/}<br>            print(i,j)<br>            // continue loop_j // implicit, so j += 1<br>        }<br>        // continue loop_i // implicit, so i += 1<br>    }<br></p><p>Dany<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160410/1e11b882/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>Revisiting 0004 etc. - Swift deprecations</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>April  3, 2016 at 08:00:00am</p></header><div class="content"><p>Hi John, <br></p><p> there seems to be a fundamental misunderstanding on your part how collection based (for .. in..) loops operate. The enumerable sets you talk about do not need to be created upfront - they can be virtual/lazy (however you want to describe them). So yes, the Swift for … in .. loop has essentially the same semantics as the C-style for(;;) loop — only in Swift this semantics is abstracted behind the Generator/Iterator protocol. Abstracting the semantics of a iterating loop has important advantages in terms of maintainability, compositionally and reusability. Imagine for instance, that you are writing a loop that needs to iterate a sparse matrix. With a for(;;) loop, you need to include complex loop logic into your code. With a for .. in .. loop, you only need a sequence/generator abstraction for the sparse matrix to be implemented once. The loop code itself becomes very simple. Besides, some popular language that are widely used for numerical calculations (Python, R) do not have the for(;;) loop — for a good reason. <br></p><p> Besides, I am quite sure that the purpose of Swift is not to appeal to everyone. Its purpose its to make certain things better. Things like for(;;) an unary decrement/increment operators are quite neat, but they ultimately result in less maintainable and comprehensive code. <br></p><p>Best, <br></p><p> Taras<br></p><p>&gt; On 03 Apr 2016, at 01:45, John Heerema via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Warning - long post.<br>&gt; I know that some folks really hate long posts, so let me apologize right<br>&gt; now for this being a long post. Please feel free to skip right on past it.<br>&gt; I posted it on a weekend, when there¹s less mailing list traffic, but that<br>&gt; doesn¹t make it any shorter.<br>&gt; <br>&gt; Warning - revisits two approved deprecations.<br>&gt; If you really, really hate it when people want to revisit decisions that<br>&gt; have already been made, please just skip right past this post. My<br>&gt; apologies for not contributing to the discussion when these decisions were<br>&gt; originally being made!<br>&gt; <br>&gt; The day that Swift was announced at the WWDC was very<br>&gt; exciting for me, and I immediately read the Swift book from beginning to<br>&gt; end.<br>&gt; Swift quickly became my favourite language: I felt that the Swift language<br>&gt; developers had created a beautiful language that combined expressiveness<br>&gt; with<br>&gt; practicality in a way that made Swift code both powerful and easy to<br>&gt; understand. Swift was crafted by some very smart and practical people.<br>&gt; <br>&gt; To put my thoughts into perspective, I should mention that<br>&gt; I¹ve taught Computer Science at a senior University level for years, and<br>&gt; have<br>&gt; worked in industry for decades. As a computer scientist, I¹ve had a strong<br>&gt; interest in computer languages for many years. I became an Apple developer<br>&gt; upon<br>&gt; purchasing an Apple Lisa a very long time ago.<br>&gt; <br>&gt; Over the past couple of years though, I¹ve seen what I think<br>&gt; of as a growing emphasis on strict feature orthagonality at the expense of<br>&gt; practicality in Swift. Perhaps this because much of the feedback on the<br>&gt; language has been provided by those of us who are interested in computer<br>&gt; languages. But for whatever reasons, the Swift language seems to have<br>&gt; become<br>&gt; more cluttered and less friendly.<br>&gt; <br>&gt; As I¹ve gone through the various beta releases, I¹ve seen<br>&gt; changes that detract from the experience of using Swift, for reasons that<br>&gt; seem<br>&gt; related to ³language purity².<br>&gt; <br>&gt; I was finally moved to try to express my thoughts after<br>&gt; seeing a couple of what I think of as particularly inadvisable proposals<br>&gt; for<br>&gt; Swift version 3 and beyond.<br>&gt; <br>&gt; Unary increment and decrement operators: ++ and ‹<br>&gt; <br>&gt; The first of these was the now approved removal of Swift¹s<br>&gt; convenient unary increment and decrement operators. I would agree with<br>&gt; some of<br>&gt; the comments that have been made about these operators not being quite<br>&gt; orthogonal with other expressive elements in the language. Nonetheless,<br>&gt; they<br>&gt; are a handy and popular way to iterate over enumerable collections, and to<br>&gt; increment and decrement a variable that is used for purposes other than<br>&gt; iteration. They also lend themselves to being extended to other data<br>&gt; types, such<br>&gt; as position pointers in linked lists, where they can implement the<br>&gt; convenient<br>&gt; concept of ³the next thing² (which += does not provide).<br>&gt; <br>&gt; The desire to get rid of these rather harmless operators<br>&gt; reminds me of some of Apple¹s own history, and the history of computer<br>&gt; languages in general. Niklaus Wirth didn¹t care for shortcut operators<br>&gt; either,<br>&gt; and so Pascal never got them.<br>&gt; <br>&gt; However, Apple eventually moved away from Pascal to C, even<br>&gt; though C is in many ways a deeply flawed language that is responsible for a<br>&gt; wide litany of software errors. Why? I personally really liked Pascal, but<br>&gt; many<br>&gt; (most) developers didn¹t care for the language. I¹d argue that developers<br>&gt; preferred the flexibility of C to what they saw as the overly restricting<br>&gt; constraints of Pascal.<br>&gt; <br>&gt; One of the surprising reasons that I heard a lot at the<br>&gt; time, was that developers didn¹t want to lose C¹s shortcut operators. If<br>&gt; Wirth<br>&gt; had been willing to give Pascal some of C¹s convenience operators, things<br>&gt; might<br>&gt; well have turned out differently. Developers hate typing.<br>&gt; <br>&gt; The notion that there should be exactly one way to do a<br>&gt; particular thing sounds like dogma to me: not practicality. If people are<br>&gt; concerned that unary operators confuse beginners, I would encourage them to<br>&gt; convince educators not to teach them to beginners. Anyway, there are a lot<br>&gt; of<br>&gt; things in Swift that can confuse beginners!<br>&gt; <br>&gt; Although it¹s hard for me to believe that having these<br>&gt; operators return void has been seriously considered, I would argue that<br>&gt; this<br>&gt; would be even sillier than removing them. A lot of developers use both C<br>&gt; (or<br>&gt; Objective C, C++, C#, Java, etc. etc.) and Swift ­ having those unary<br>&gt; operators<br>&gt; act completely differently in Swift would be a great way to alienate those<br>&gt; developers. <br>&gt; <br>&gt; Let¹s not forget that  Swift<br>&gt; is not the lingua franca of the computing world. It¹s an upstart that<br>&gt; needs to<br>&gt; attract the development community. Why repel people coming from the various<br>&gt; C-like languages without a really, really, convincingly good reason? it¹s<br>&gt; better for an upstart to attract than to repel.<br>&gt; <br>&gt; Right now, there are an awful lot of developers who are used<br>&gt; to, and like the convenience of unary increment and decrement operators.<br>&gt; Removing them seems bound to annoy developers and diminish the popularity<br>&gt; of<br>&gt; Swift, in exchange for Š well, not very much except for a tiny bit of<br>&gt; language<br>&gt; purity. That just seems silly to me.<br>&gt; <br>&gt; C-style For loops<br>&gt; <br>&gt; Removal of C-style For loops has already been approved for a<br>&gt; future version of Swift. Even though I find the C-style For loop to be a<br>&gt; bit<br>&gt; ugly and unintuitive, I believe that removing it was the wrong thing to do.<br>&gt; <br>&gt; It comes down to flexibility and expressiveness. The reality<br>&gt; is that C-style For loops easily implement certain operations that are more<br>&gt; difficult to implement without them.<br>&gt; <br>&gt; I¹ve seen comments that C-style For loops are ³hardly ever<br>&gt; used², and that ³hardly any² algorithms really need them. I believe that<br>&gt; ³hardly any² is a lazy mental shortcut for ³Well, I don¹t like them, and I<br>&gt; I<br>&gt; don¹t use them, so I don¹t think that any anyone who¹s important uses<br>&gt; them.².<br>&gt; <br>&gt; Yes, there are many cases in which I believe that Swift<br>&gt; provides looping structures that are safer and easier to understand than<br>&gt; the<br>&gt; C-style For loop. I¹d even say most cases. But I work in the scientific and<br>&gt; engineering domains, and can point to many instances of looping structures<br>&gt; that<br>&gt; are easily expressed with a C-style For loop, but are clumsy to implement<br>&gt; without it.<br>&gt; <br>&gt; In the world of the natural sciences, there are any number<br>&gt; of instances of loop increments that requires some kind of a calculation.<br>&gt; There<br>&gt; are any number of instances of dynamically calculated loop termination.<br>&gt; <br>&gt; Swift¹s stride has some nice features for simple increments,<br>&gt; but also has some important limitations. Among them, it involves the two<br>&gt; step<br>&gt; process of first creating an enumerable set, and then iterating over it.<br>&gt; In the<br>&gt; natural sciences, it is not uncommon for complex loop increments to be<br>&gt; used in<br>&gt; loops that are executed millions of times.<br>&gt; <br>&gt; Conceptually, creating an enumerable set, and then iterating over it,<br>&gt; reeks of the arrogance of assuming that computing resources are unlimited.<br>&gt; Even<br>&gt; though the compiler may optimize the stride into the loop structure, it<br>&gt; feels<br>&gt; like unnecessarily creating a gigantic enumerable set.<br>&gt; <br>&gt; Whether we like it or not, the enduring popularity of the<br>&gt; C-style For loop comes from it¹s flexibility. Swift doesn¹t have a better<br>&gt; alternative that also provides the same flexibility. So don¹t take it<br>&gt; away. If<br>&gt; you don¹t like it (I don¹t always either), think of something that is<br>&gt; clearly<br>&gt; superior in 100% of use cases. Even then, I would argue against removing<br>&gt; it. <br>&gt; <br>&gt; I would argue that the C-style For loop implements some<br>&gt; rather Swift-like concepts. The syntax provide for three closures: one<br>&gt; each for<br>&gt; (a) things to do first, (b) things to do when deciding whether to stop<br>&gt; iterating,  and (c) things to do after each iteration. How is that contrary<br>&gt; to the principals of Swift?<br>&gt; <br>&gt; Just like pretty much everywhere that Swift allows closures,<br>&gt; they can be used to write code that is difficult to understand. But the<br>&gt; syntax<br>&gt; is general and flexible enough to have survived intact for half a century.<br>&gt; <br>&gt; It¹s the carrot vs. the stick. Developers prefer the carrot.<br>&gt; The belief that we can force developers to write better code by taking away<br>&gt; language features, has not historically met with success. Let me say that<br>&gt; again, because I think it¹s important. Developers who are given a choice<br>&gt; between C and a ³better² language (say Modula-2, or Swift) are unlikely to<br>&gt; react favourably to being told ³we¹re taking away this feature of C that<br>&gt; you<br>&gt; like, for your own good, because you¹re too stupid to use it sensibly².<br>&gt; Taking away well-understood expressive language elements, and replacing<br>&gt; them with something less expressive, is not going to win developers over.<br>&gt; <br>&gt; C-style For loops haven¹t changed in half acentury, because they work.<br>&gt; A lot of other languages have also adopted them, because they work.<br>&gt; <br>&gt; If I may, I¹d like to take the English language by way of<br>&gt; analogy. English contains a lot of weird, irregular language elements.<br>&gt; There¹s<br>&gt; no single way to express a concept. Instead, there are many, subtly<br>&gt; different<br>&gt; ways to express yourself.<br>&gt; <br>&gt; But, for all of its weirdness, English has remained popular<br>&gt; for centuries, whereas more ³sensible², ³regular² languages like Esperanto<br>&gt; never caught on. The reasons are flexibility and expressiveness. The same<br>&gt; thing<br>&gt; applies to computer languages.<br>&gt; <br>&gt; If we only look inside the world of compilers and computer<br>&gt; science instruction, to see if we need the flexibility of C-style For<br>&gt; loops, we<br>&gt; might mistakenly think that we don¹t. But those domains are relatively<br>&gt; simple<br>&gt; in comparison to the physical sciences. Our experience there doesn¹t always<br>&gt; translate to the more complex world of physical reality. So let¹s not throw<br>&gt; away convenient and useful language features just because we don¹t<br>&gt; personally<br>&gt; care for them.<br>&gt; <br>&gt; Don¹t make Swift Yet Another Interesting Experiment in<br>&gt; language design that wasn¹t widely adopted, and<br>&gt; ended up being relegated to the dustbin of history.<br>&gt; It would make me sad to see the best new computer language<br>&gt; in ages become just another niche language. We already<br>&gt; have enough of those.<br>&gt; <br>&gt; So, all of you folks who voted to remove these things, please don¹t hate<br>&gt; me!<br>&gt; <br>&gt; Regards,<br>&gt; J. Heerema, Ph.D.<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; &lt;default.xml&gt;&lt;default[1].xml&gt;_______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Revisiting 0004 etc. - Swift deprecations</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April  3, 2016 at 03:00:00am</p></header><div class="content"><p>On Sat, Apr 2, 2016 at 6:45 PM, John Heerema via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Yes, there are many cases in which I believe that Swift<br>&gt; provides looping structures that are safer and easier to understand than<br>&gt; the<br>&gt; C-style For loop. I¹d even say most cases. But I work in the scientific and<br>&gt; engineering domains, and can point to many instances of looping structures<br>&gt; that<br>&gt; are easily expressed with a C-style For loop, but are clumsy to implement<br>&gt; without it.<br>&gt;<br>&gt; In the world of the natural sciences, there are any number<br>&gt; of instances of loop increments that requires some kind of a calculation.<br>&gt; There<br>&gt; are any number of instances of dynamically calculated loop termination.<br>&gt;<br>&gt; Swift¹s stride has some nice features for simple increments,<br>&gt; but also has some important limitations. Among them, it involves the two<br>&gt; step<br>&gt; process of first creating an enumerable set, and then iterating over it.<br>&gt; In the<br>&gt; natural sciences, it is not uncommon for complex loop increments to be<br>&gt; used in<br>&gt; loops that are executed millions of times.<br>&gt;<br>&gt; Conceptually, creating an enumerable set, and then iterating over it,<br>&gt; reeks of the arrogance of assuming that computing resources are unlimited.<br>&gt; Even<br>&gt; though the compiler may optimize the stride into the loop structure, it<br>&gt; feels<br>&gt; like unnecessarily creating a gigantic enumerable set.<br>&gt;<br>&gt; Whether we like it or not, the enduring popularity of the<br>&gt; C-style For loop comes from it¹s flexibility. Swift doesn¹t have a better<br>&gt; alternative that also provides the same flexibility. So don¹t take it<br>&gt; away. If<br>&gt; you don¹t like it (I don¹t always either), think of something that is<br>&gt; clearly<br>&gt; superior in 100% of use cases. Even then, I would argue against removing<br>&gt; it.<br></p><p>FWIW, as an anecdote, I&#39;ve been working on a side project in the<br>natural sciences using Swift and I haven&#39;t missed the C-style for;;<br>loop much. It seemed a little irksome at first to refactor, but that<br>was about it. Looking around at other languages, I&#39;m also not seeing<br>evidence that working in the natural sciences domain<br>disproportionately requires these loops. For instance, Python (which<br>has significant uptake in my corner of the natural sciences world) and<br>Julia (the up-and-coming technical computing language) both lack<br>C-style for;; syntax and the ++ and -- operators, which doesn&#39;t seem<br>to have dampened the enthusiasm of my colleagues for those languages.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>Revisiting 0004 etc. - Swift deprecations</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>April  3, 2016 at 10:00:00am</p></header><div class="content"><p>It would be very interesting to see more examples dynamic loop conditions and dynamic loop increments using the Swifter for in loop with strides... without while :).<br></p><p>[[iOS messageWithData:ideas] broadcast]<br></p><p>&gt; On 3 Apr 2016, at 09:19, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Sat, Apr 2, 2016 at 6:45 PM, John Heerema via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Yes, there are many cases in which I believe that Swift<br>&gt;&gt; provides looping structures that are safer and easier to understand than<br>&gt;&gt; the<br>&gt;&gt; C-style For loop. I¹d even say most cases. But I work in the scientific and<br>&gt;&gt; engineering domains, and can point to many instances of looping structures<br>&gt;&gt; that<br>&gt;&gt; are easily expressed with a C-style For loop, but are clumsy to implement<br>&gt;&gt; without it.<br>&gt;&gt; <br>&gt;&gt; In the world of the natural sciences, there are any number<br>&gt;&gt; of instances of loop increments that requires some kind of a calculation.<br>&gt;&gt; There<br>&gt;&gt; are any number of instances of dynamically calculated loop termination.<br>&gt;&gt; <br>&gt;&gt; Swift¹s stride has some nice features for simple increments,<br>&gt;&gt; but also has some important limitations. Among them, it involves the two<br>&gt;&gt; step<br>&gt;&gt; process of first creating an enumerable set, and then iterating over it.<br>&gt;&gt; In the<br>&gt;&gt; natural sciences, it is not uncommon for complex loop increments to be<br>&gt;&gt; used in<br>&gt;&gt; loops that are executed millions of times.<br>&gt;&gt; <br>&gt;&gt; Conceptually, creating an enumerable set, and then iterating over it,<br>&gt;&gt; reeks of the arrogance of assuming that computing resources are unlimited.<br>&gt;&gt; Even<br>&gt;&gt; though the compiler may optimize the stride into the loop structure, it<br>&gt;&gt; feels<br>&gt;&gt; like unnecessarily creating a gigantic enumerable set.<br>&gt;&gt; <br>&gt;&gt; Whether we like it or not, the enduring popularity of the<br>&gt;&gt; C-style For loop comes from it¹s flexibility. Swift doesn¹t have a better<br>&gt;&gt; alternative that also provides the same flexibility. So don¹t take it<br>&gt;&gt; away. If<br>&gt;&gt; you don¹t like it (I don¹t always either), think of something that is<br>&gt;&gt; clearly<br>&gt;&gt; superior in 100% of use cases. Even then, I would argue against removing<br>&gt;&gt; it.<br>&gt; <br>&gt; FWIW, as an anecdote, I&#39;ve been working on a side project in the<br>&gt; natural sciences using Swift and I haven&#39;t missed the C-style for;;<br>&gt; loop much. It seemed a little irksome at first to refactor, but that<br>&gt; was about it. Looking around at other languages, I&#39;m also not seeing<br>&gt; evidence that working in the natural sciences domain<br>&gt; disproportionately requires these loops. For instance, Python (which<br>&gt; has significant uptake in my corner of the natural sciences world) and<br>&gt; Julia (the up-and-coming technical computing language) both lack<br>&gt; C-style for;; syntax and the ++ and -- operators, which doesn&#39;t seem<br>&gt; to have dampened the enthusiasm of my colleagues for those languages.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
