<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/18c60397fcda8f42900d42ba4db4f029?s=50"></div><header><strong>Enabling Whole Module Optimizations by default for Release builds</strong> from <string>Nadav Rotem</string> &lt;nrotem at apple.com&gt;<p>March 11, 2016 at 10:00:00am</p></header><div class="content"><p>Hi, <br></p><p>Many of us have considered it a long-term goal to make whole-module optimizations the default compilation mode for Release builds. I believe that we are ready and that we should enable WMO by default. WMO solves real problems but comes at a cost. Let’s discuss this and make a decision. <br></p><p>Today, each swift file is compiled and optimized independently. Compiling each file independently makes our compile times relatively fast because multiple files are optimized in parallel on different CPU cores, and only files that have been modified need to be recompiled. Both Debug and Release builds use this technique. <br></p><p>However, the current compilation mode is not that great for the performance of the generated code. File boundaries are optimization barriers. Swift users found that when they develop generic data structures (like Queue&lt;T&gt;) the performance of these data structures was not ideal, because the compiler was not able to specialize the generics into concrete types (turn T into an Int for all uses of Queue&lt;T&gt;). Our recommendation was to either copy the generic data structures into the files that use them or enable WMO[1].<br></p><p>With WMO all of the files in the module are optimized together and the optimizer is free to specialize generics and inline functions across file boundaries. This compilation mode is excellent for performance, but it comes at a cost. Naturally, WMO builds take longer because the compiler can’t parallelize the build on multiple cores. Also, every change in a single files makes the compiler re-optimize the whole program and not only the file what was modified. <br></p><p>We’ve been working to improve our WMO builds in a number of ways. Erik (@eeckstein) found that we spent most of our compile time in code generation optimizations (such as instruction selection and register allocations) inside LLVM, and was able to split the Swift module into multiple units that LLVM can compile in parallel. He also implemented cacheing at the LLVM level that improved the performance of incremental builds. Unrelated to the work on WMO, we also improved the speed of the optimizer by tuning our optimization pipeline and the different optimizations - and in the last three months we improved the overall compile time of optimized builds by ~10%.  <br></p><p>Another concern was the increase in code size. In WMO mode we are free to specialize generics and inline code between files. These optimizations can increase the size of the generated program significantly. We also made a huge progress on this front. We were able to reduce the size of the Swift dylib that builds with WMO from 4.6MB in January to 3.7MB today.<br></p><p>We should not enable WMO for Debug builds. We don’t do any major optimizations on Debug builds and compiling things in WMO will only slow the compile times and not provide any speedups. We strive to make Swift Debug builds as fast as scripts (and intend to allow people to use #!/bin/swift), so unjustified reduction in compile time is unacceptable. <br></p><p>To summarize, WMO is critical to the performance of optimized Swift programs. WMO increases code size and compile times but we’ve made excellent progress and we’ll continue to invest in these areas. I believe that considering the inherit tradeoffs, enabling WMO is a good idea. <br></p><p>Please let me know what you think.  <br></p><p>Thanks,<br>Nadav<br></p><p>[1] - https://developer.apple.com/swift/blog/?id=27<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d042be5dcfe90e649f760303af3e429?s=50"></div><header><strong>Enabling Whole Module Optimizations by default for Release builds</strong> from <string>Jens Persson</string> &lt;jens at bitcycle.com&gt;<p>March 11, 2016 at 10:00:00pm</p></header><div class="content"><p>+1<br>The first thing I do in a new project is always to enable WMO.<br></p><p>My impression/experience is that slow compile times often have to do with<br>the type checker; I use<br>-Xfrontend -debug-time-function-bodies<br>to see in which funcs the type checker spends &quot;too much&quot; time, edit them<br>and repeat until compile time goes down. The first time I did this I had a<br>project in which the compile time was about 10 seconds and it went down to<br>less than a second after I had identified and reformulated ten or so time<br>consuming parts of my code.<br></p><p>However, especially for bigger project, viewing the time/func-output in<br>Xcode&#39;s Report Navigator is quite far from a pleasant experience.<br>The contents of the view is painfully slow, and it is not possible to<br>sort/order/filter the time/func-entries etc.<br></p><p>An improved report of where the compile time is spent (not only time/func<br>but time/code-location) would be a very valuable tool until compile times<br>becomes less erratic and expressions like eg this:<br>let dictionaryOfIntOps: [String: (Int, Int) -&gt; Int] = [<br>&quot;+&quot;: (+),<br>&quot;-&quot;: (-),<br>&quot;*&quot;: (*),<br>&quot;/&quot;: (/),<br>]<br>is no longer considered &quot;too complex to be solved in reasonable time&quot;<br>(commenting out one of the four elements will make it compile).<br>Also, there are other seemingly simple expressions that are slow but not<br>too slow / too complex.<br>And as the sum of a project&#39;s all &quot;reasonable times&quot; quite often ends up<br>being kind of unreasonable, we need a reasonable tool to help us help the<br>compiler/type-checker (by quickly pointing us to the most time consuming<br>parts of the code so we can reformulate it).<br></p><p>/Jens<br></p><p>On Fri, Mar 11, 2016 at 7:47 PM, Nadav Rotem via swift-dev &lt;<br>swift-dev at swift.org&gt; wrote:<br></p><p>&gt; Hi,<br>&gt;<br>&gt; Many of us have considered it a long-term goal to make whole-module<br>&gt; optimizations the default compilation mode for Release builds. I believe<br>&gt; that we are ready and that we should enable WMO by default. WMO solves real<br>&gt; problems but comes at a cost. Let’s discuss this and make a decision.<br>&gt;<br>&gt; Today, each swift file is compiled and optimized independently. Compiling<br>&gt; each file independently makes our compile times relatively fast because<br>&gt; multiple files are optimized in parallel on different CPU cores, and only<br>&gt; files that have been modified need to be recompiled. Both Debug and Release<br>&gt; builds use this technique.<br>&gt;<br>&gt; However, the current compilation mode is not that great for the<br>&gt; performance of the generated code. File boundaries are optimization<br>&gt; barriers. Swift users found that when they develop generic data structures<br>&gt; (like Queue&lt;T&gt;) the performance of these data structures was not ideal,<br>&gt; because the compiler was not able to specialize the generics into concrete<br>&gt; types (turn T into an Int for all uses of Queue&lt;T&gt;). Our recommendation was<br>&gt; to either copy the generic data structures into the files that use them or<br>&gt; enable WMO[1].<br>&gt;<br>&gt; With WMO all of the files in the module are optimized together and the<br>&gt; optimizer is free to specialize generics and inline functions across file<br>&gt; boundaries. This compilation mode is excellent for performance, but it<br>&gt; comes at a cost. Naturally, WMO builds take longer because the compiler<br>&gt; can’t parallelize the build on multiple cores. Also, every change in a<br>&gt; single files makes the compiler re-optimize the whole program and not only<br>&gt; the file what was modified.<br>&gt;<br>&gt; We’ve been working to improve our WMO builds in a number of ways. Erik<br>&gt; (@eeckstein) found that we spent most of our compile time in code<br>&gt; generation optimizations (such as instruction selection and register<br>&gt; allocations) inside LLVM, and was able to split the Swift module into<br>&gt; multiple units that LLVM can compile in parallel. He also implemented<br>&gt; cacheing at the LLVM level that improved the performance of incremental<br>&gt; builds. Unrelated to the work on WMO, we also improved the speed of the<br>&gt; optimizer by tuning our optimization pipeline and the different<br>&gt; optimizations - and in the last three months we improved the overall<br>&gt; compile time of optimized builds by ~10%.<br>&gt;<br>&gt; Another concern was the increase in code size. In WMO mode we are free to<br>&gt; specialize generics and inline code between files. These optimizations can<br>&gt; increase the size of the generated program significantly. We also made a<br>&gt; huge progress on this front. We were able to reduce the size of the Swift<br>&gt; dylib that builds with WMO from 4.6MB in January to 3.7MB today.<br>&gt;<br>&gt; We should not enable WMO for Debug builds. We don’t do any major<br>&gt; optimizations on Debug builds and compiling things in WMO will only slow<br>&gt; the compile times and not provide any speedups. We strive to make Swift<br>&gt; Debug builds as fast as scripts (and intend to allow people to use<br>&gt; #!/bin/swift), so unjustified reduction in compile time is unacceptable.<br>&gt;<br>&gt; To summarize, WMO is critical to the performance of optimized Swift<br>&gt; programs. WMO increases code size and compile times but we’ve made<br>&gt; excellent progress and we’ll continue to invest in these areas. I believe<br>&gt; that considering the inherit tradeoffs, enabling WMO is a good idea.<br>&gt;<br>&gt; Please let me know what you think.<br>&gt;<br>&gt; Thanks,<br>&gt; Nadav<br>&gt;<br>&gt; [1] - https://developer.apple.com/swift/blog/?id=27<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;<br></p><p><br></p><p>-- <br>bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>http://www.bitcycle.com/<br>Phone: +46-73-753 24 62<br>E-mail: jens at bitcycle.com<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160311/65dcc53c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/64e7c3f106cb83b50891f5dcccde198b?s=50"></div><header><strong>Enabling Whole Module Optimizations by default for Release builds</strong> from <string>Joe Pamer</string> &lt;jpamer at apple.com&gt;<p>March 11, 2016 at 01:00:00pm</p></header><div class="content"><p>Hey Jens,<br></p><p>I feel your pain here - it’s an area that I’ve gradually been trying to improve for quite some time. We consider these kinds of simple inference problems to be serious type checker bugs, and we’re trying to flush them out wherever possible.<br></p><p>We’ve already made some big improvements for Swift 3. With the edge contraction work I pushed back in January, I think I have some of the right abstractions in place to address problems like the one you call out below (also captured as rdar://problem/22810685 &lt;rdar://problem/22810685&gt;). For example, the expression you provided now compiles without “going exponential” in Swift 3 (though it still requires a type annotation).<br></p><p>I hope to keep improving the status quo, so that -debug-time-function-bodies will eventually be unnecessary, but in the meantime please keep filing bugs. I’m working through these issues one-by-one.<br></p><p>Thanks!<br>- Joe<br></p><p><br>&gt; On Mar 11, 2016, at 1:38 PM, Jens Persson via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; +1<br>&gt; The first thing I do in a new project is always to enable WMO.<br>&gt; <br>&gt; My impression/experience is that slow compile times often have to do with the type checker; I use<br>&gt; -Xfrontend -debug-time-function-bodies<br>&gt; to see in which funcs the type checker spends &quot;too much&quot; time, edit them and repeat until compile time goes down. The first time I did this I had a project in which the compile time was about 10 seconds and it went down to less than a second after I had identified and reformulated ten or so time consuming parts of my code.<br>&gt; <br>&gt; However, especially for bigger project, viewing the time/func-output in Xcode&#39;s Report Navigator is quite far from a pleasant experience.<br>&gt; The contents of the view is painfully slow, and it is not possible to sort/order/filter the time/func-entries etc.<br>&gt; <br>&gt; An improved report of where the compile time is spent (not only time/func but time/code-location) would be a very valuable tool until compile times becomes less erratic and expressions like eg this:<br>&gt; let dictionaryOfIntOps: [String: (Int, Int) -&gt; Int] = [<br>&gt; &quot;+&quot;: (+),<br>&gt; &quot;-&quot;: (-),<br>&gt; &quot;*&quot;: (*),<br>&gt; &quot;/&quot;: (/),<br>&gt; ]<br>&gt; is no longer considered &quot;too complex to be solved in reasonable time&quot; (commenting out one of the four elements will make it compile).<br>&gt; Also, there are other seemingly simple expressions that are slow but not too slow / too complex.<br>&gt; And as the sum of a project&#39;s all &quot;reasonable times&quot; quite often ends up being kind of unreasonable, we need a reasonable tool to help us help the compiler/type-checker (by quickly pointing us to the most time consuming parts of the code so we can reformulate it).<br>&gt; <br>&gt; /Jens<br>&gt; <br>&gt; On Fri, Mar 11, 2016 at 7:47 PM, Nadav Rotem via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt; Hi,<br>&gt; <br>&gt; Many of us have considered it a long-term goal to make whole-module optimizations the default compilation mode for Release builds. I believe that we are ready and that we should enable WMO by default. WMO solves real problems but comes at a cost. Let’s discuss this and make a decision.<br>&gt; <br>&gt; Today, each swift file is compiled and optimized independently. Compiling each file independently makes our compile times relatively fast because multiple files are optimized in parallel on different CPU cores, and only files that have been modified need to be recompiled. Both Debug and Release builds use this technique.<br>&gt; <br>&gt; However, the current compilation mode is not that great for the performance of the generated code. File boundaries are optimization barriers. Swift users found that when they develop generic data structures (like Queue&lt;T&gt;) the performance of these data structures was not ideal, because the compiler was not able to specialize the generics into concrete types (turn T into an Int for all uses of Queue&lt;T&gt;). Our recommendation was to either copy the generic data structures into the files that use them or enable WMO[1].<br>&gt; <br>&gt; With WMO all of the files in the module are optimized together and the optimizer is free to specialize generics and inline functions across file boundaries. This compilation mode is excellent for performance, but it comes at a cost. Naturally, WMO builds take longer because the compiler can’t parallelize the build on multiple cores. Also, every change in a single files makes the compiler re-optimize the whole program and not only the file what was modified.<br>&gt; <br>&gt; We’ve been working to improve our WMO builds in a number of ways. Erik (@eeckstein) found that we spent most of our compile time in code generation optimizations (such as instruction selection and register allocations) inside LLVM, and was able to split the Swift module into multiple units that LLVM can compile in parallel. He also implemented cacheing at the LLVM level that improved the performance of incremental builds. Unrelated to the work on WMO, we also improved the speed of the optimizer by tuning our optimization pipeline and the different optimizations - and in the last three months we improved the overall compile time of optimized builds by ~10%.<br>&gt; <br>&gt; Another concern was the increase in code size. In WMO mode we are free to specialize generics and inline code between files. These optimizations can increase the size of the generated program significantly. We also made a huge progress on this front. We were able to reduce the size of the Swift dylib that builds with WMO from 4.6MB in January to 3.7MB today.<br>&gt; <br>&gt; We should not enable WMO for Debug builds. We don’t do any major optimizations on Debug builds and compiling things in WMO will only slow the compile times and not provide any speedups. We strive to make Swift Debug builds as fast as scripts (and intend to allow people to use #!/bin/swift), so unjustified reduction in compile time is unacceptable.<br>&gt; <br>&gt; To summarize, WMO is critical to the performance of optimized Swift programs. WMO increases code size and compile times but we’ve made excellent progress and we’ll continue to invest in these areas. I believe that considering the inherit tradeoffs, enabling WMO is a good idea.<br>&gt; <br>&gt; Please let me know what you think.<br>&gt; <br>&gt; Thanks,<br>&gt; Nadav<br>&gt; <br>&gt; [1] - https://developer.apple.com/swift/blog/?id=27 &lt;https://developer.apple.com/swift/blog/?id=27&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt; http://www.bitcycle.com/ &lt;http://www.bitcycle.com/&gt;<br>&gt; Phone: +46-73-753 24 62<br>&gt; E-mail: jens at bitcycle.com &lt;mailto:jens at bitcycle.com&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160311/a98781ba/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
