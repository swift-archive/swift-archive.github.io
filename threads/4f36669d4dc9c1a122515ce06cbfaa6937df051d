<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9e453dc290485e158dcd01698e8c60ae?s=50"></div><header><strong>Proposal: Initialization should not be required in precondition(false) case.</strong> from <string>Alexey Demedetskiy</string> &lt;demedeckie at gmail.com&gt;<p>February 12, 2016 at 09:00:00pm</p></header><div class="content"><p>+1 for this switch behavior. Can we also treat switch? as one with did not require default checking?<br></p><p>&gt; I have a suggestion.<br>&gt; Suppose we think of &#39;switch&#39; as being like a non-optional type. The compiler does its thing and tries to ensure that the switched expression will match something, and enforces a default if it cannot verify a matching state.<br>&gt; Could we force the switch? i.e. suffix the &#39;switch&#39; keyword with an exclamation mark, to say: the programmer insists that one of these cases will match; there&#39;s no need for a default case, but if nothing matches then crash.<br>&gt; <br>&gt; For example:<br>&gt; let x:Int<br>&gt; switch! expression<br>&gt; {<br>&gt; case ... { x = 1 }<br>&gt; case ... { x = 2 }<br>&gt; // no default. the ! signifies that the app should crash if none of these cases matches the expression<br>&gt; }<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; On Fri, Feb 12, 2016 at 5:32 PM, Chris Lattner via swift-evolution&lt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)&gt;wrote:<br>&gt; &gt; On Feb 12, 2016, at 9:27 AM, Amir Michail&lt;a.michail at me.com(mailto:a.michail at me.com)&gt;wrote:<br>&gt; &gt; &gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;What’s wrong with having the compiler explicitly check for “false”?<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt;Weird special cases make the compiler less predictable.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;True, but not having them requires deeper knowledge of the standard libraries.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;In practice, just checking for “false” would solve this problem.<br>&gt; &gt; <br>&gt; &gt; That is not what you’re actually proposing.You are proposing that the compiler encode special knowledge of the precondition *library function* into the compiler, and teach it about a single special case.We don’t like the compiler to have special cases like this for a large number of reasons, in particular, if we did this, someone would file a bug asking for *their* equivalent reimplementation of precondition to have the same magic blessed behavior.<br>&gt; &gt; <br>&gt; &gt; This is a slippery slope that leads to a lot of complexity downstream, it is better to keep the compiler simple and predictable.Also, as other people have pointed out, this has already been solved for you: just use preconditionFailure.<br>&gt; &gt; <br>&gt; &gt; -Chris<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org(mailto:swift-evolution at swift.org)<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d172fa3c47108d84ee35a68e8d675c1?s=50"></div><header><strong>Proposal: Initialization should not be required in precondition(false) case.</strong> from <string>Ross O&#39;Brien</string> &lt;narrativium+swift at gmail.com&gt;<p>February 13, 2016 at 06:00:00pm</p></header><div class="content"><p>So...<br></p><p>Our basic &#39;switch&#39; takes an expression and tries to match it to the first<br>matching case (with programmer option to &#39;fallthrough&#39;. The compiler runs<br>an extra routine to check we covered every situation, but as far as I know,<br>it&#39;s only sure in cases of booleans and enums. In all other situations the<br>compiler requires a &#39;default&#39; case.<br></p><p>The proposed &#39;switch!&#39; says: the programmer overrules the compiler. Don&#39;t<br>require a default case, the provided cases cover everything, yes we&#39;re<br>sure, crash if not. It&#39;s &#39;default: fatalError()&#39; in one character.<br></p><p>I&#39;m not sure what &#39;switch?&#39; ought to do. If I understand you right, you&#39;re<br>suggesting that &#39;switch?&#39; be &#39;default: break&#39; in one character. I think<br>that might have merit, but I also think the compiler would still have to do<br>its checks, because in this case:<br>&#39;let x : Foo<br>switch? y<br>{<br>   case z: x = Foo()<br>   case ...: ...<br>   ...<br>}&#39;<br>If the compiler doesn&#39;t think it can find a matching case for y, then Swift<br>can&#39;t be sure that x has a value. That should still have a warning.<br></p><p>If I haven&#39;t understood you, please clarify.<br></p><p><br>On Fri, Feb 12, 2016 at 7:06 PM, Алексей Демедецкий &lt;demedeckie at gmail.com&gt;<br>wrote:<br></p><p>&gt; +1 for this switch behavior. Can we also treat switch? as one with did not<br>&gt; require default checking?<br>&gt;<br>&gt; &gt; I have a suggestion.<br>&gt; &gt; Suppose we think of &#39;switch&#39; as being like a non-optional type. The<br>&gt; compiler does its thing and tries to ensure that the switched expression<br>&gt; will match something, and enforces a default if it cannot verify a matching<br>&gt; state.<br>&gt; &gt; Could we force the switch? i.e. suffix the &#39;switch&#39; keyword with an<br>&gt; exclamation mark, to say: the programmer insists that one of these cases<br>&gt; will match; there&#39;s no need for a default case, but if nothing matches then<br>&gt; crash.<br>&gt; &gt;<br>&gt; &gt; For example:<br>&gt; &gt; let x:Int<br>&gt; &gt; switch! expression<br>&gt; &gt; {<br>&gt; &gt; case ... { x = 1 }<br>&gt; &gt; case ... { x = 2 }<br>&gt; &gt; // no default. the ! signifies that the app should crash if none of<br>&gt; these cases matches the expression<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; On Fri, Feb 12, 2016 at 5:32 PM, Chris Lattner via swift-evolution&lt;<br>&gt; swift-evolution at swift.org(mailto:swift-evolution at swift.org)&gt;wrote:<br>&gt; &gt; &gt; On Feb 12, 2016, at 9:27 AM, Amir Michail&lt;a.michail at me.com(mailto:<br>&gt; a.michail at me.com)&gt;wrote:<br>&gt; &gt; &gt; &gt;&gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;&gt;What’s wrong with having the compiler explicitly check for “false”?<br>&gt; &gt; &gt; &gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;Weird special cases make the compiler less predictable.<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt;True, but not having them requires deeper knowledge of the standard<br>&gt; libraries.<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt;In practice, just checking for “false” would solve this problem.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; That is not what you’re actually proposing.You are proposing that the<br>&gt; compiler encode special knowledge of the precondition *library function*<br>&gt; into the compiler, and teach it about a single special case.We don’t like<br>&gt; the compiler to have special cases like this for a large number of reasons,<br>&gt; in particular, if we did this, someone would file a bug asking for *their*<br>&gt; equivalent reimplementation of precondition to have the same magic blessed<br>&gt; behavior.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; This is a slippery slope that leads to a lot of complexity downstream,<br>&gt; it is better to keep the compiler simple and predictable.Also, as other<br>&gt; people have pointed out, this has already been solved for you: just use<br>&gt; preconditionFailure.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; -Chris<br>&gt; &gt; &gt; _______________________________________________<br>&gt; &gt; &gt; swift-evolution mailing list<br>&gt; &gt; &gt; swift-evolution at swift.org(mailto:swift-evolution at swift.org)<br>&gt; &gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160213/3fe52689/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9e453dc290485e158dcd01698e8c60ae?s=50"></div><header><strong>Proposal: Initialization should not be required in precondition(false) case.</strong> from <string>Alexey Demedetskiy</string> &lt;demedeckie at gmail.com&gt;<p>February 13, 2016 at 10:00:00pm</p></header><div class="content"><p>Well you have described it perfectly. :)<br>It is indeed default: fatalError() and default: break in one character. <br></p><p>On the other hand I have fear that we will overwhelm language semantic with ! and ? everywhere. <br></p><p>So, do you think this ability to tweak compiler behavior and save one line of code is valuable?<br></p><p>Will be interesting to see some statistics  of using different default cases.  <br></p><p>&gt; 13 февр. 2016 г., в 20:36, Ross O&#39;Brien &lt;narrativium+swift at gmail.com&gt; написал(а):<br>&gt; <br>&gt; So...<br>&gt; <br>&gt; Our basic &#39;switch&#39; takes an expression and tries to match it to the first matching case (with programmer option to &#39;fallthrough&#39;. The compiler runs an extra routine to check we covered every situation, but as far as I know, it&#39;s only sure in cases of booleans and enums. In all other situations the compiler requires a &#39;default&#39; case.<br>&gt; <br>&gt; The proposed &#39;switch!&#39; says: the programmer overrules the compiler. Don&#39;t require a default case, the provided cases cover everything, yes we&#39;re sure, crash if not. It&#39;s &#39;default: fatalError()&#39; in one character.<br>&gt; <br>&gt; I&#39;m not sure what &#39;switch?&#39; ought to do. If I understand you right, you&#39;re suggesting that &#39;switch?&#39; be &#39;default: break&#39; in one character. I think that might have merit, but I also think the compiler would still have to do its checks, because in this case:<br>&gt; &#39;let x : Foo<br>&gt; switch? y<br>&gt; {<br>&gt;    case z: x = Foo()<br>&gt;    case ...: ...<br>&gt;    ...<br>&gt; }&#39;<br>&gt; If the compiler doesn&#39;t think it can find a matching case for y, then Swift can&#39;t be sure that x has a value. That should still have a warning.<br>&gt; <br>&gt; If I haven&#39;t understood you, please clarify.<br>&gt; <br>&gt; <br>&gt;&gt; On Fri, Feb 12, 2016 at 7:06 PM, Алексей Демедецкий &lt;demedeckie at gmail.com&gt; wrote:<br>&gt;&gt; +1 for this switch behavior. Can we also treat switch? as one with did not require default checking?<br>&gt;&gt; <br>&gt;&gt; &gt; I have a suggestion.<br>&gt;&gt; &gt; Suppose we think of &#39;switch&#39; as being like a non-optional type. The compiler does its thing and tries to ensure that the switched expression will match something, and enforces a default if it cannot verify a matching state.<br>&gt;&gt; &gt; Could we force the switch? i.e. suffix the &#39;switch&#39; keyword with an exclamation mark, to say: the programmer insists that one of these cases will match; there&#39;s no need for a default case, but if nothing matches then crash.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; For example:<br>&gt;&gt; &gt; let x:Int<br>&gt;&gt; &gt; switch! expression<br>&gt;&gt; &gt; {<br>&gt;&gt; &gt; case ... { x = 1 }<br>&gt;&gt; &gt; case ... { x = 2 }<br>&gt;&gt; &gt; // no default. the ! signifies that the app should crash if none of these cases matches the expression<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; On Fri, Feb 12, 2016 at 5:32 PM, Chris Lattner via swift-evolution&lt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)&gt;wrote:<br>&gt;&gt; &gt; &gt; On Feb 12, 2016, at 9:27 AM, Amir Michail&lt;a.michail at me.com(mailto:a.michail at me.com)&gt;wrote:<br>&gt;&gt; &gt; &gt; &gt;&gt;&gt;<br>&gt;&gt; &gt; &gt; &gt;&gt;&gt;What’s wrong with having the compiler explicitly check for “false”?<br>&gt;&gt; &gt; &gt; &gt;&gt;<br>&gt;&gt; &gt; &gt; &gt;&gt;Weird special cases make the compiler less predictable.<br>&gt;&gt; &gt; &gt; &gt;<br>&gt;&gt; &gt; &gt; &gt;True, but not having them requires deeper knowledge of the standard libraries.<br>&gt;&gt; &gt; &gt; &gt;<br>&gt;&gt; &gt; &gt; &gt;In practice, just checking for “false” would solve this problem.<br>&gt;&gt; &gt; &gt;<br>&gt;&gt; &gt; &gt; That is not what you’re actually proposing.You are proposing that the compiler encode special knowledge of the precondition *library function* into the compiler, and teach it about a single special case.We don’t like the compiler to have special cases like this for a large number of reasons, in particular, if we did this, someone would file a bug asking for *their* equivalent reimplementation of precondition to have the same magic blessed behavior.<br>&gt;&gt; &gt; &gt;<br>&gt;&gt; &gt; &gt; This is a slippery slope that leads to a lot of complexity downstream, it is better to keep the compiler simple and predictable.Also, as other people have pointed out, this has already been solved for you: just use preconditionFailure.<br>&gt;&gt; &gt; &gt;<br>&gt;&gt; &gt; &gt; -Chris<br>&gt;&gt; &gt; &gt; _______________________________________________<br>&gt;&gt; &gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; &gt; swift-evolution at swift.org(mailto:swift-evolution at swift.org)<br>&gt;&gt; &gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160213/eb8463d6/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
