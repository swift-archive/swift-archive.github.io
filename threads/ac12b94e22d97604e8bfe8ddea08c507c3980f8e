<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Contiguous Memory and the Effect of Borrowing on Safety</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>November  6, 2016 at 01:00:00pm</p></header><div class="content"><p>Given that we&#39;re headed for ABI (and thus stdlib API) stability, I&#39;ve<br>been giving lots of thought to the bottom layer of our collection<br>abstraction and how it may limit our potential for efficiency.  In<br>particular, I want to keep the door open for optimizations that work on<br>contiguous memory regions.  Every cache-friendly data structure, even if<br>it is not an array, contains contiguous memory regions over which<br>operations can often be vectorized, that should define boundaries for<br>parallelism, etc.  Throughout Cocoa you can find patterns designed to<br>exploit this fact when possible (NSFastEnumeration).  Posix I/O bottoms<br>out in readv/writev, and MPI datatypes essentially boil down to<br>identifying the contiguous parts of data structures.  My point is that<br>this is an important class of optimization, with numerous real-world<br>examples.<br></p><p>If you think about what it means to build APIs for contiguous memory<br>into abstractions like Sequence or Collection, at least without<br>penalizing the lowest-level code, it means exposing UnsafeBufferPointers<br>as a first-class part of the protocols, which is really<br>unappealing... unless you consider that *borrowed* UnsafeBufferPointers<br>can be made safe.  <br></p><p>[Well, it&#39;s slightly more complicated than that because<br>UnsafeBufferPointer is designed to bypass bounds checking in release<br>builds, and to ensure safety you&#39;d need a BoundsCheckedBuffer—or<br>something—that checks bounds unconditionally... but] the point remains<br>that<br></p><p>  A thing that is unsafe when it&#39;s arbitrarily copied can become safe if<br>  you ensure that it&#39;s only borrowed (in accordance with well-understood<br>  lifetime rules).<br></p><p>And this leads me to wonder about our practice of embedding the word<br>&quot;unsafe&quot; in names.  A construct that is only conditionally unsafe<br>shouldn&#39;t be spelled &quot;unsafe&quot; when used in a safe way, right?  So this<br>*seems* to argue for an &quot;unsafe&quot; keyword that can be used to label<br>the constructs that actually add unsafety (as has been previously<br>suggested on this list).  Other ideas are of course most welcome.<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f6b7154fd1d6a470d0b521a2e484bffc?s=50"></div><header><strong>Contiguous Memory and the Effect of Borrowing on Safety</strong> from <string>Daniel Duan</string> &lt;daniel at duan.org&gt;<p>November  6, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Nov 6, 2016, at 1:20 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; A construct that is only conditionally unsafe<br>&gt; shouldn&#39;t be spelled &quot;unsafe&quot; when used in a safe way, right?  So this<br>&gt; *seems* to argue for an &quot;unsafe&quot; keyword that can be used to label<br>&gt; the constructs that actually add unsafety (as has been previously<br>&gt; suggested on this list).  Other ideas are of course most welcome.<br>&gt; <br></p><p>How would “unsafe” coexist with memory ownership model? It seems to me that there’s some overlapping concepts here (borrowed/moved). I haven’t formulated any complete thoughts on this topic. Just had a feeling that we should take the ownership model in mind as we tackle this.<br></p><p>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Contiguous Memory and the Effect of Borrowing on Safety</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>November  6, 2016 at 06:00:00pm</p></header><div class="content"><p>on Sun Nov 06 2016, Daniel Duan &lt;daniel-AT-duan.org&gt; wrote:<br></p><p>&gt;&gt; On Nov 6, 2016, at 1:20 PM, Dave Abrahams via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; A construct that is only conditionally unsafe<br>&gt;&gt; shouldn&#39;t be spelled &quot;unsafe&quot; when used in a safe way, right?  So this<br>&gt;&gt; *seems* to argue for an &quot;unsafe&quot; keyword that can be used to label<br>&gt;&gt; the constructs that actually add unsafety (as has been previously<br>&gt;&gt; suggested on this list).  Other ideas are of course most welcome.<br>&gt;&gt; <br>&gt;<br>&gt; How would “unsafe” coexist with memory ownership model? It seems to me<br>&gt; that there’s some overlapping concepts here (borrowed/moved). <br></p><p>Yes, the ownership model covers borrowing.<br></p><p>&gt; I haven’t formulated any complete thoughts on this topic. Just had a<br>&gt; feeling that we should take the ownership model in mind as we tackle<br>&gt; this.<br></p><p>That was a main point of my posting.  Apologies if that wasn&#39;t made<br>clear.<br></p><p>-- <br>-Dave<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e7e554db1f80d7d6041d92edd5145698?s=50"></div><header><strong>Contiguous Memory and the Effect of Borrowing on Safety</strong> from <string>Hooman Mehr</string> &lt;hooman at mac.com&gt;<p>November  6, 2016 at 07:00:00pm</p></header><div class="content"><p>Yes, this is a very important issue to consider before we freeze them.<br></p><p>As part of my Swift hobby, I have worked a bit on a Swifty wrapper for linear algebra packages and also toyed a bit with the merits of a Swift implementation of some of the related algorithms and data structures (such as banded or sparse matrices)<br></p><p>It is really difficult to come up with efficient and generic solutions in these spaces. I had a brush with Julia &lt;http://julialang.org/&gt; as well. Have you looked at their work and the recent reworking of their similar data structures?<br></p><p>&gt; On Nov 6, 2016, at 1:20 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Given that we&#39;re headed for ABI (and thus stdlib API) stability, I&#39;ve<br>&gt; been giving lots of thought to the bottom layer of our collection<br>&gt; abstraction and how it may limit our potential for efficiency.  In<br>&gt; particular, I want to keep the door open for optimizations that work on<br>&gt; contiguous memory regions.  Every cache-friendly data structure, even if<br>&gt; it is not an array, contains contiguous memory regions over which<br>&gt; operations can often be vectorized, that should define boundaries for<br>&gt; parallelism, etc.  Throughout Cocoa you can find patterns designed to<br>&gt; exploit this fact when possible (NSFastEnumeration).  Posix I/O bottoms<br>&gt; out in readv/writev, and MPI datatypes essentially boil down to<br>&gt; identifying the contiguous parts of data structures.  My point is that<br>&gt; this is an important class of optimization, with numerous real-world<br>&gt; examples.<br>&gt; <br>&gt; If you think about what it means to build APIs for contiguous memory<br>&gt; into abstractions like Sequence or Collection, at least without<br>&gt; penalizing the lowest-level code, it means exposing UnsafeBufferPointers<br>&gt; as a first-class part of the protocols, which is really<br>&gt; unappealing... unless you consider that *borrowed* UnsafeBufferPointers<br>&gt; can be made safe.  <br>&gt; <br>&gt; [Well, it&#39;s slightly more complicated than that because<br>&gt; UnsafeBufferPointer is designed to bypass bounds checking in release<br>&gt; builds, and to ensure safety you&#39;d need a BoundsCheckedBuffer—or<br>&gt; something—that checks bounds unconditionally... but] the point remains<br>&gt; that<br>&gt; <br>&gt;  A thing that is unsafe when it&#39;s arbitrarily copied can become safe if<br>&gt;  you ensure that it&#39;s only borrowed (in accordance with well-understood<br>&gt;  lifetime rules).<br>&gt; <br>&gt; And this leads me to wonder about our practice of embedding the word<br>&gt; &quot;unsafe&quot; in names.  A construct that is only conditionally unsafe<br>&gt; shouldn&#39;t be spelled &quot;unsafe&quot; when used in a safe way, right?  So this<br>&gt; *seems* to argue for an &quot;unsafe&quot; keyword that can be used to label<br>&gt; the constructs that actually add unsafety (as has been previously<br>&gt; suggested on this list).  Other ideas are of course most welcome.<br>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161106/17911393/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6b81089e81d6bb1e14b5adb746725de1?s=50"></div><header><strong>Contiguous Memory and the Effect of Borrowing on Safety</strong> from <string>Alexis</string> &lt;abeingessner at apple.com&gt;<p>November  7, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Nov 6, 2016, at 4:20 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Given that we&#39;re headed for ABI (and thus stdlib API) stability, I&#39;ve<br>&gt; been giving lots of thought to the bottom layer of our collection<br>&gt; abstraction and how it may limit our potential for efficiency.  In<br>&gt; particular, I want to keep the door open for optimizations that work on<br>&gt; contiguous memory regions.  Every cache-friendly data structure, even if<br>&gt; it is not an array, contains contiguous memory regions over which<br>&gt; operations can often be vectorized, that should define boundaries for<br>&gt; parallelism, etc.  Throughout Cocoa you can find patterns designed to<br>&gt; exploit this fact when possible (NSFastEnumeration).  Posix I/O bottoms<br>&gt; out in readv/writev, and MPI datatypes essentially boil down to<br>&gt; identifying the contiguous parts of data structures.  My point is that<br>&gt; this is an important class of optimization, with numerous real-world<br>&gt; examples.<br>&gt; <br>&gt; If you think about what it means to build APIs for contiguous memory<br>&gt; into abstractions like Sequence or Collection, at least without<br>&gt; penalizing the lowest-level code, it means exposing UnsafeBufferPointers<br>&gt; as a first-class part of the protocols, which is really<br>&gt; unappealing... unless you consider that *borrowed* UnsafeBufferPointers<br>&gt; can be made safe.  <br>&gt; <br>&gt; [Well, it&#39;s slightly more complicated than that because<br>&gt; UnsafeBufferPointer is designed to bypass bounds checking in release<br>&gt; builds, and to ensure safety you&#39;d need a BoundsCheckedBuffer—or<br>&gt; something—that checks bounds unconditionally... but] the point remains<br>&gt; that<br>&gt; <br>&gt;  A thing that is unsafe when it&#39;s arbitrarily copied can become safe if<br>&gt;  you ensure that it&#39;s only borrowed (in accordance with well-understood<br>&gt;  lifetime rules).<br>&gt; <br>&gt; And this leads me to wonder about our practice of embedding the word<br>&gt; &quot;unsafe&quot; in names.  A construct that is only conditionally unsafe<br>&gt; shouldn&#39;t be spelled &quot;unsafe&quot; when used in a safe way, right?  So this<br>&gt; *seems* to argue for an &quot;unsafe&quot; keyword that can be used to label<br>&gt; the constructs that actually add unsafety (as has been previously<br>&gt; suggested on this list).  Other ideas are of course most welcome.<br>&gt; <br></p><p>Yes, I’ve always found this more appealing (“operations are unsafe, not types”). This allows you to make more subtle distinctions, and expose “low level” APIs for otherwise safe types (e.g. unchecked indexing on Array). I believe Graydon made a draft proposal for this a while back, but neither of us can recall what became of it.<br></p><p>That said, in this particular case the distinction isn’t very helpful: basically everything you can do with an Unsafe(Buffer)Pointer is truly unsafe today, and I wouldn’t really expect this to change with ownership stuff. You need a completely unchecked pointer type for the very lowest levels of abstractions, where scoped lifetimes can’t capture the relationships that are involved.<br></p><p>I would expect there to be two types of interest, one with safe borrowed semantics (Pointer/BufferPointer?), and one with unsafe unchecked semantics (today’s UnsafePointer/UnsafeBufferPointer). For those familiar with Rust, this is roughly equivalent to: &amp;T, &amp;[T], *mut T, and *mut [T] respectively. Most APIs should operate in terms of the safe types, requiring the holder of an unsafe type to do some kind of cast, asserting that the whatever guarantees the safe types make will be upheld.<br></p><p>99% of code should subsequently never actually interact with the Unsafe types, instead using the safe ones. Anything using the Unsafe types should subsequently try to get into the world of safe types as fast as possible. For instance, much of Rust’s growable array type (Vec) is implemented as “convert my unsafe pointer into a safe, borrowed slice, then operate on the slice”. Similarly, any API which is interested in passing around a non-growable pile of memory communicates in terms of these slices.<br></p><p><br>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Contiguous Memory and the Effect of Borrowing on Safety</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>November  7, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Nov 6, 2016, at 1:20 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Given that we&#39;re headed for ABI (and thus stdlib API) stability, I&#39;ve<br>&gt; been giving lots of thought to the bottom layer of our collection<br>&gt; abstraction and how it may limit our potential for efficiency.  In<br>&gt; particular, I want to keep the door open for optimizations that work on<br>&gt; contiguous memory regions.  Every cache-friendly data structure, even if<br>&gt; it is not an array, contains contiguous memory regions over which<br>&gt; operations can often be vectorized, that should define boundaries for<br>&gt; parallelism, etc.  Throughout Cocoa you can find patterns designed to<br>&gt; exploit this fact when possible (NSFastEnumeration).  Posix I/O bottoms<br>&gt; out in readv/writev, and MPI datatypes essentially boil down to<br>&gt; identifying the contiguous parts of data structures.  My point is that<br>&gt; this is an important class of optimization, with numerous real-world<br>&gt; examples.<br>&gt; <br>&gt; If you think about what it means to build APIs for contiguous memory<br>&gt; into abstractions like Sequence or Collection, at least without<br>&gt; penalizing the lowest-level code, it means exposing UnsafeBufferPointers<br>&gt; as a first-class part of the protocols, which is really<br>&gt; unappealing... unless you consider that *borrowed* UnsafeBufferPointers<br>&gt; can be made safe.  <br>&gt; <br>&gt; [Well, it&#39;s slightly more complicated than that because<br>&gt; UnsafeBufferPointer is designed to bypass bounds checking in release<br>&gt; builds, and to ensure safety you&#39;d need a BoundsCheckedBuffer—or<br>&gt; something—that checks bounds unconditionally... but] the point remains<br>&gt; that<br>&gt; <br>&gt;  A thing that is unsafe when it&#39;s arbitrarily copied can become safe if<br>&gt;  you ensure that it&#39;s only borrowed (in accordance with well-understood<br>&gt;  lifetime rules).<br></p><p>UnsafeBufferPointer today is a copyable type.  Having a borrowed value<br>doesn&#39;t prevent you from making your own copy, which could then escape<br>the scope that was guaranteeing safety.<br></p><p>This is fixable, of course, but it&#39;s a more significant change to the type and<br>how it would be used.<br></p><p>John.<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
