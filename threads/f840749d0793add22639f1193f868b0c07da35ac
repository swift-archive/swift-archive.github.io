<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: Remove implicit tuple splat behavior from function applications</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 26, 2016 at 10:00:00pm</p></header><div class="content"><p>For discussion: comments appreciated!<br></p><p><br></p><p><br>Remove implicit tuple splat behavior from function applications<br></p><p>Proposal: SE- &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;TBD<br>Author(s): Chris Lattner<br>Status: Awaiting review<br>Review manager: TBD<br> &lt;https://github.com/apple/swift-evolution#introduction&gt;Introduction<br></p><p>Function calls (which include several syntactic forms that apply an argument list to something of function type) currently have a dual nature in Swift.  Given something like:<br></p><p><br>	func foo(a : Int, b : Int) {}<br></p><p><br>You can call it either with with the typical syntactic form that passes arguments to each of its parameters:<br></p><p><br>	foo(42, b : 17)<br></p><p>or you can take advantage of a little-known feature to pass an entire argument list as a single value (of tuple type):<br></p><p>	let x = (1, b: 2)<br>	foo(x)<br></p><p><br>This proposal recommends removing the later form, which I affectionately refer to as the “tuple splat” form.  This feature is purely a sugar feature, it does not provide any expressive ability beyond passing the parameters manually.<br></p><p><br>Swift-evolution thread: TBD<br></p><p> &lt;https://github.com/apple/swift-evolution#motivation&gt;Motivation<br></p><p>This behavior is cute, precedented in other functional languages, and has some advantages, but it also has several major disadvantages, which are all related to its syntactic form.<br></p><p>* A call to foo(x) looks like a call to an overloaded version of foo, both to the compiler and to the human who maintains the code.  This is extremely confusing if you don’t know the feature exists.<br>* There are real ambiguities in the syntax, e.g. involving Any arguments and situations where you want to pass a tuple value as a single parameter.<br>* The current implementation has a ton of implementation bugs - it doesn’t work reliably.<br>* The current implementation adds complexity to the type checker, slowing it down and adding maintenance burden.<br>* The current implementation doesn’t work the way we would want a tuple splat operation to work.  For example, arguably, you should be able to call foo with:<br></p><p>	func bar() -&gt; (Int, Int) { … }<br>	foo(bar())<br></p><p>… but this is not allowed, since tuple labels are required to line up.  You have to write:<br></p><p><br>	func bar() -&gt; (Int, b: Int)  { … }<br>	foo(bar())<br></p><p><br>This makes this feature very difficult to use in practice, because you have to _’ize a lot of parameters (violating naming conventions), perform manual shuffling (defeating the sugar benefits of the feature), or add parameter labels to the result of functions (which leads to odd tying between callers and callees).<br></p><p><br>The root problem here is that we use exactly the same syntax for both forms of function application.  If the two forms were differentiated (an option considered in “alternatives considered” below) then some of these problems would be defined away.<br></p><p>From a historical perspective, the tuple splat form of function application dates back to very early Swift design (probably introduced in 2010, but possibly 2011) where all function application was of a single value to a function type.  For a large number of reasons (including default arguments, variadic arguments, labels, etc) we have completely abandoned this model, but we never came back to reevaluating the tuple splat behavior.<br></p><p>If we didn’t already have this feature, we would not add it to Swift 3 (at least in its current form).<br></p><p> &lt;https://github.com/apple/swift-evolution#proposed-solution&gt;Proposed solution<br></p><p>The proposed solution is simple, we should just remove this feature from the Swift 3 compiler.  Ideally we would deprecate it in the Swift 2.2 compiler and remove it in Swift 3.  However, if there isn’t time to get the deprecation into Swift 2.2, the author believes it would be perfectly fine to just remove it in Swift 3 (with a fixit + migration help of course).<br></p><p>One of the interesting aspect of this feature is that some of the people we’ve spoken to are very fond of it.  However, when pressed, they admit that they are not actually using it widely in their code, or if they are using it, they are abusing naming conventions (distorting their code) in order to use it.  This doesn’t seem like a positive contribution - this seems like a “clever” feature, not a practical one.<br></p><p> &lt;https://github.com/apple/swift-evolution#detailed-design&gt;Detailed design<br></p><p>The design is straight-forward.  In the Swift 3 time frame, we continue to parse and type check these expressions as we have so far, but produce an error + fixit hint when it is the tuple splat form.  The migrator would auto-apply the fixit hint as it does for other cases.<br></p><p> &lt;https://github.com/apple/swift-evolution#impact-on-existing-code&gt;Impact on existing code<br></p><p>Any code that uses this feature will have to move to the traditional form.  In the case of the example above, this means rewriting the code from:<br></p><p>	foo(x)<br></p><p>into a form like this:<br></p><p>	foo(x.0, x.b)<br></p><p>In the case where “x” is a complex expression, a temporary variable will need to be introduced.  We believe that compiler fixits can handle the simple cases directly and that this extension is not widely used.<br></p><p> &lt;https://github.com/apple/swift-evolution#alternatives-considered&gt;Alternatives considered<br></p><p>The major problem with this feature is that it was not well considered and implemented properly (owing to its very old age, it has just been kept limping along).  The alternative then is to actually design a proper feature to support this.  Since the implicitness and syntactic ambiguity with normal function application is the problem, the solution is to introduce an explicit syntactic form to represent this.  For example, something like this could address the problems we have:<br></p><p>	foo(*x)    // NOT a serious syntax proposal<br></p><p>However, actually designing this feature would be a non-trivial effort not core to the Swift 3 mission:<br></p><p>* It is a pure-sugar feature, and therefore low priority.<br>* We don’t have an obvious sigil to use.  “prefix-star” should be kept as unused for now in case we want to use it to refer to memory-related operations in the future.<br>* Making the tuple splat operation great requires more than just fixing the syntactic ambiguities we have, it would require re-evaluating the semantics of the operation (e.g. in light of parameter labels, varargs and other features).<br></p><p>If there is serious interest in pursuing this as a concept, we should do it as a follow-on proposal to this one.  If a good design emerges, we can evaluate that design based on its merits.<br></p><p><br>The final alternative is that we could leave the feature in the compiler.  However, that means living with its complexity “forever” or breaking code in the Swift 4 timeframe.  It would be preferable to tackle this breakage in the Swift 3 timeframe, since we know that migration will already be needed then.<br></p><p>-Chris<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160126/f84035ac/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>Proposal: Remove implicit tuple splat behavior from function applications</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>January 27, 2016 at 01:00:00am</p></header><div class="content"><p>+1<br></p><p>I like the feature quite a bit but avoid it as a result of the naming<br>concerns. If removing this feature can help improve the type checker, the<br>trade is worthwhile, IMO.<br></p><p>On Wed, Jan 27, 2016 at 1:23 AM, Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; For discussion: comments appreciated!<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; Remove implicit tuple splat behavior from function applications<br>&gt;<br>&gt;    - Proposal: SE-<br>&gt;    &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;<br>&gt;    TBD<br>&gt;    - Author(s): Chris Lattner<br>&gt;    - Status: *Awaiting review*<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt; &lt;https://github.com/apple/swift-evolution#introduction&gt;Introduction<br>&gt;<br>&gt; Function calls (which include several syntactic forms that apply an<br>&gt; argument list to something of function type) currently have a dual nature<br>&gt; in Swift.  Given something like:<br>&gt;<br>&gt; func foo(a : Int, b : Int) {}<br>&gt;<br>&gt;<br>&gt; You can call it either with with the typical syntactic form that passes<br>&gt; arguments to each of its parameters:<br>&gt;<br>&gt; foo(42, b : 17)<br>&gt;<br>&gt; or you can take advantage of a little-known feature to pass an entire<br>&gt; argument list as a single value (of tuple type):<br>&gt; let x = (1, b: 2)<br>&gt; foo(x)<br>&gt;<br>&gt;<br>&gt; This proposal recommends removing the later form, which I affectionately<br>&gt; refer to as the “tuple splat” form.  This feature is purely a sugar<br>&gt; feature, it does not provide any expressive ability beyond passing the<br>&gt; parameters manually.<br>&gt;<br>&gt; Swift-evolution thread: TBD<br>&gt; &lt;https://github.com/apple/swift-evolution#motivation&gt;Motivation<br>&gt;<br>&gt; This behavior is cute, precedented in other functional languages, and has<br>&gt; some advantages, but it also has several major disadvantages, which are all<br>&gt; related to its syntactic form.<br>&gt; * A call to foo(x) looks like a call to an overloaded version of foo, both<br>&gt; to the compiler and to the human who maintains the code.  This is extremely<br>&gt; confusing if you don’t know the feature exists.<br>&gt; * There are real ambiguities in the syntax, e.g. involving Any arguments<br>&gt; and situations where you want to pass a tuple value as a single parameter.<br>&gt; * The current implementation has a ton of implementation bugs - it doesn’t<br>&gt; work reliably.<br>&gt; * The current implementation adds complexity to the type checker, slowing<br>&gt; it down and adding maintenance burden.<br>&gt; * The current implementation doesn’t work the way we would want a tuple<br>&gt; splat operation to work.  For example, arguably, you should be able to call<br>&gt; foo with:<br>&gt;<br>&gt; func bar() -&gt; (Int, Int) { … }<br>&gt; foo(bar())<br>&gt;<br>&gt; … but this is not allowed, since tuple labels are required to line up.<br>&gt; You have to write:<br>&gt;<br>&gt; func bar() -&gt; (Int, b: Int)  { … }<br>&gt; foo(bar())<br>&gt;<br>&gt;<br>&gt; This makes this feature very difficult to use in practice, because you<br>&gt; have to _’ize a lot of parameters (violating naming conventions), perform<br>&gt; manual shuffling (defeating the sugar benefits of the feature), or add<br>&gt; parameter labels to the result of functions (which leads to odd tying<br>&gt; between callers and callees).<br>&gt;<br>&gt; The root problem here is that we use exactly the same syntax for both<br>&gt; forms of function application.  If the two forms were differentiated (an<br>&gt; option considered in “alternatives considered” below) then some of these<br>&gt; problems would be defined away.<br>&gt;<br>&gt; From a historical perspective, the tuple splat form of function<br>&gt; application dates back to very early Swift design (probably introduced in<br>&gt; 2010, but possibly 2011) where all function application was of a single<br>&gt; value to a function type.  For a large number of reasons (including default<br>&gt; arguments, variadic arguments, labels, etc) we have completely abandoned<br>&gt; this model, but we never came back to reevaluating the tuple splat behavior.<br>&gt;<br>&gt; If we didn’t already have this feature, we would not add it to Swift 3 (at<br>&gt; least in its current form).<br>&gt; &lt;https://github.com/apple/swift-evolution#proposed-solution&gt;Proposed<br>&gt; solution<br>&gt;<br>&gt; The proposed solution is simple, we should just remove this feature from<br>&gt; the Swift 3 compiler.  Ideally we would deprecate it in the Swift 2.2<br>&gt; compiler and remove it in Swift 3.  However, if there isn’t time to get the<br>&gt; deprecation into Swift 2.2, the author believes it would be perfectly fine<br>&gt; to just remove it in Swift 3 (with a fixit + migration help of course).<br>&gt;<br>&gt; One of the interesting aspect of this feature is that some of the people<br>&gt; we’ve spoken to are very fond of it.  However, when pressed, they admit<br>&gt; that they are not actually using it widely in their code, or if they are<br>&gt; using it, they are abusing naming conventions (distorting their code) in<br>&gt; order to use it.  This doesn’t seem like a positive contribution - this<br>&gt; seems like a “clever” feature, not a practical one.<br>&gt; &lt;https://github.com/apple/swift-evolution#detailed-design&gt;Detailed design<br>&gt;<br>&gt; The design is straight-forward.  In the Swift 3 time frame, we continue to<br>&gt; parse and type check these expressions as we have so far, but produce an<br>&gt; error + fixit hint when it is the tuple splat form.  The migrator would<br>&gt; auto-apply the fixit hint as it does for other cases.<br>&gt; &lt;https://github.com/apple/swift-evolution#impact-on-existing-code&gt;Impact<br>&gt; on existing code<br>&gt;<br>&gt; Any code that uses this feature will have to move to the traditional<br>&gt; form.  In the case of the example above, this means rewriting the code from:<br>&gt; foo(x)<br>&gt;<br>&gt; into a form like this:<br>&gt; foo(x.0, x.b)<br>&gt;<br>&gt; In the case where “x” is a complex expression, a temporary variable will<br>&gt; need to be introduced.  We believe that compiler fixits can handle the<br>&gt; simple cases directly and that this extension is not widely used.<br>&gt;<br>&gt; &lt;https://github.com/apple/swift-evolution#alternatives-considered&gt;Alternatives<br>&gt; considered<br>&gt; The major problem with this feature is that it was not well considered and<br>&gt; implemented properly (owing to its very old age, it has just been kept<br>&gt; limping along).  The alternative then is to actually design a proper<br>&gt; feature to support this.  Since the implicitness and syntactic ambiguity<br>&gt; with normal function application is the problem, the solution is to<br>&gt; introduce an explicit syntactic form to represent this.  For example,<br>&gt; something like this could address the problems we have:<br>&gt;<br>&gt; foo(*x)    // NOT a serious syntax proposal<br>&gt;<br>&gt; However, actually designing this feature would be a non-trivial effort not<br>&gt; core to the Swift 3 mission:<br>&gt;<br>&gt; * It is a pure-sugar feature, and therefore low priority.<br>&gt; * We don’t have an obvious sigil to use.  “prefix-star” should be kept as<br>&gt; unused for now in case we want to use it to refer to memory-related<br>&gt; operations in the future.<br>&gt; * Making the tuple splat operation great requires more than just fixing<br>&gt; the syntactic ambiguities we have, it would require re-evaluating the<br>&gt; semantics of the operation (e.g. in light of parameter labels, varargs and<br>&gt; other features).<br>&gt;<br>&gt; If there is serious interest in pursuing this as a concept, we should do<br>&gt; it as a follow-on proposal to this one.  If a good design emerges, we can<br>&gt; evaluate that design based on its merits.<br>&gt;<br>&gt;<br>&gt; The final alternative is that we could leave the feature in the compiler.<br>&gt; However, that means living with its complexity “forever” or breaking code<br>&gt; in the Swift 4 timeframe.  It would be preferable to tackle this breakage<br>&gt; in the Swift 3 timeframe, since we know that migration will already be<br>&gt; needed then.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/af376423/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Proposal: Remove implicit tuple splat behavior from function applications</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>January 26, 2016 at 10:00:00pm</p></header><div class="content"><p>+1 from me as well. I don&#39;t think I&#39;ve ever used this feature on purpose.<br></p><p>I look forward to future discussions about splatting, especially as they<br>relate to variadic functions.<br></p><p>On Tue, Jan 26, 2016 at 10:36 PM, T.J. Usiyan via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; +1<br>&gt;<br>&gt; I like the feature quite a bit but avoid it as a result of the naming<br>&gt; concerns. If removing this feature can help improve the type checker, the<br>&gt; trade is worthwhile, IMO.<br>&gt;<br>&gt; On Wed, Jan 27, 2016 at 1:23 AM, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; For discussion: comments appreciated!<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Remove implicit tuple splat behavior from function applications<br>&gt;&gt;<br>&gt;&gt;    - Proposal: SE-<br>&gt;&gt;    &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;<br>&gt;&gt;    TBD<br>&gt;&gt;    - Author(s): Chris Lattner<br>&gt;&gt;    - Status: *Awaiting review*<br>&gt;&gt;    - Review manager: TBD<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/apple/swift-evolution#introduction&gt;Introduction<br>&gt;&gt;<br>&gt;&gt; Function calls (which include several syntactic forms that apply an<br>&gt;&gt; argument list to something of function type) currently have a dual nature<br>&gt;&gt; in Swift.  Given something like:<br>&gt;&gt;<br>&gt;&gt; func foo(a : Int, b : Int) {}<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; You can call it either with with the typical syntactic form that passes<br>&gt;&gt; arguments to each of its parameters:<br>&gt;&gt;<br>&gt;&gt; foo(42, b : 17)<br>&gt;&gt;<br>&gt;&gt; or you can take advantage of a little-known feature to pass an entire<br>&gt;&gt; argument list as a single value (of tuple type):<br>&gt;&gt; let x = (1, b: 2)<br>&gt;&gt; foo(x)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; This proposal recommends removing the later form, which I affectionately<br>&gt;&gt; refer to as the “tuple splat” form.  This feature is purely a sugar<br>&gt;&gt; feature, it does not provide any expressive ability beyond passing the<br>&gt;&gt; parameters manually.<br>&gt;&gt;<br>&gt;&gt; Swift-evolution thread: TBD<br>&gt;&gt; &lt;https://github.com/apple/swift-evolution#motivation&gt;Motivation<br>&gt;&gt;<br>&gt;&gt; This behavior is cute, precedented in other functional languages, and has<br>&gt;&gt; some advantages, but it also has several major disadvantages, which are all<br>&gt;&gt; related to its syntactic form.<br>&gt;&gt; * A call to foo(x) looks like a call to an overloaded version of foo,<br>&gt;&gt; both to the compiler and to the human who maintains the code.  This is<br>&gt;&gt; extremely confusing if you don’t know the feature exists.<br>&gt;&gt; * There are real ambiguities in the syntax, e.g. involving Any arguments<br>&gt;&gt; and situations where you want to pass a tuple value as a single parameter.<br>&gt;&gt; * The current implementation has a ton of implementation bugs - it<br>&gt;&gt; doesn’t work reliably.<br>&gt;&gt; * The current implementation adds complexity to the type checker, slowing<br>&gt;&gt; it down and adding maintenance burden.<br>&gt;&gt; * The current implementation doesn’t work the way we would want a tuple<br>&gt;&gt; splat operation to work.  For example, arguably, you should be able to call<br>&gt;&gt; foo with:<br>&gt;&gt;<br>&gt;&gt; func bar() -&gt; (Int, Int) { … }<br>&gt;&gt; foo(bar())<br>&gt;&gt;<br>&gt;&gt; … but this is not allowed, since tuple labels are required to line up.<br>&gt;&gt; You have to write:<br>&gt;&gt;<br>&gt;&gt; func bar() -&gt; (Int, b: Int)  { … }<br>&gt;&gt; foo(bar())<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; This makes this feature very difficult to use in practice, because you<br>&gt;&gt; have to _’ize a lot of parameters (violating naming conventions), perform<br>&gt;&gt; manual shuffling (defeating the sugar benefits of the feature), or add<br>&gt;&gt; parameter labels to the result of functions (which leads to odd tying<br>&gt;&gt; between callers and callees).<br>&gt;&gt;<br>&gt;&gt; The root problem here is that we use exactly the same syntax for both<br>&gt;&gt; forms of function application.  If the two forms were differentiated (an<br>&gt;&gt; option considered in “alternatives considered” below) then some of these<br>&gt;&gt; problems would be defined away.<br>&gt;&gt;<br>&gt;&gt; From a historical perspective, the tuple splat form of function<br>&gt;&gt; application dates back to very early Swift design (probably introduced in<br>&gt;&gt; 2010, but possibly 2011) where all function application was of a single<br>&gt;&gt; value to a function type.  For a large number of reasons (including default<br>&gt;&gt; arguments, variadic arguments, labels, etc) we have completely abandoned<br>&gt;&gt; this model, but we never came back to reevaluating the tuple splat behavior.<br>&gt;&gt;<br>&gt;&gt; If we didn’t already have this feature, we would not add it to Swift 3<br>&gt;&gt; (at least in its current form).<br>&gt;&gt; &lt;https://github.com/apple/swift-evolution#proposed-solution&gt;Proposed<br>&gt;&gt; solution<br>&gt;&gt;<br>&gt;&gt; The proposed solution is simple, we should just remove this feature from<br>&gt;&gt; the Swift 3 compiler.  Ideally we would deprecate it in the Swift 2.2<br>&gt;&gt; compiler and remove it in Swift 3.  However, if there isn’t time to get the<br>&gt;&gt; deprecation into Swift 2.2, the author believes it would be perfectly fine<br>&gt;&gt; to just remove it in Swift 3 (with a fixit + migration help of course).<br>&gt;&gt;<br>&gt;&gt; One of the interesting aspect of this feature is that some of the people<br>&gt;&gt; we’ve spoken to are very fond of it.  However, when pressed, they admit<br>&gt;&gt; that they are not actually using it widely in their code, or if they are<br>&gt;&gt; using it, they are abusing naming conventions (distorting their code) in<br>&gt;&gt; order to use it.  This doesn’t seem like a positive contribution - this<br>&gt;&gt; seems like a “clever” feature, not a practical one.<br>&gt;&gt; &lt;https://github.com/apple/swift-evolution#detailed-design&gt;Detailed design<br>&gt;&gt;<br>&gt;&gt; The design is straight-forward.  In the Swift 3 time frame, we continue<br>&gt;&gt; to parse and type check these expressions as we have so far, but produce an<br>&gt;&gt; error + fixit hint when it is the tuple splat form.  The migrator would<br>&gt;&gt; auto-apply the fixit hint as it does for other cases.<br>&gt;&gt; &lt;https://github.com/apple/swift-evolution#impact-on-existing-code&gt;Impact<br>&gt;&gt; on existing code<br>&gt;&gt;<br>&gt;&gt; Any code that uses this feature will have to move to the traditional<br>&gt;&gt; form.  In the case of the example above, this means rewriting the code from:<br>&gt;&gt; foo(x)<br>&gt;&gt;<br>&gt;&gt; into a form like this:<br>&gt;&gt; foo(x.0, x.b)<br>&gt;&gt;<br>&gt;&gt; In the case where “x” is a complex expression, a temporary variable will<br>&gt;&gt; need to be introduced.  We believe that compiler fixits can handle the<br>&gt;&gt; simple cases directly and that this extension is not widely used.<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/apple/swift-evolution#alternatives-considered&gt;Alternatives<br>&gt;&gt; considered<br>&gt;&gt; The major problem with this feature is that it was not well considered<br>&gt;&gt; and implemented properly (owing to its very old age, it has just been kept<br>&gt;&gt; limping along).  The alternative then is to actually design a proper<br>&gt;&gt; feature to support this.  Since the implicitness and syntactic ambiguity<br>&gt;&gt; with normal function application is the problem, the solution is to<br>&gt;&gt; introduce an explicit syntactic form to represent this.  For example,<br>&gt;&gt; something like this could address the problems we have:<br>&gt;&gt;<br>&gt;&gt; foo(*x)    // NOT a serious syntax proposal<br>&gt;&gt;<br>&gt;&gt; However, actually designing this feature would be a non-trivial effort<br>&gt;&gt; not core to the Swift 3 mission:<br>&gt;&gt;<br>&gt;&gt; * It is a pure-sugar feature, and therefore low priority.<br>&gt;&gt; * We don’t have an obvious sigil to use.  “prefix-star” should be kept as<br>&gt;&gt; unused for now in case we want to use it to refer to memory-related<br>&gt;&gt; operations in the future.<br>&gt;&gt; * Making the tuple splat operation great requires more than just fixing<br>&gt;&gt; the syntactic ambiguities we have, it would require re-evaluating the<br>&gt;&gt; semantics of the operation (e.g. in light of parameter labels, varargs and<br>&gt;&gt; other features).<br>&gt;&gt;<br>&gt;&gt; If there is serious interest in pursuing this as a concept, we should do<br>&gt;&gt; it as a follow-on proposal to this one.  If a good design emerges, we can<br>&gt;&gt; evaluate that design based on its merits.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; The final alternative is that we could leave the feature in the<br>&gt;&gt; compiler.  However, that means living with its complexity “forever” or<br>&gt;&gt; breaking code in the Swift 4 timeframe.  It would be preferable to tackle<br>&gt;&gt; this breakage in the Swift 3 timeframe, since we know that migration will<br>&gt;&gt; already be needed then.<br>&gt;&gt;<br>&gt;&gt; -Chris<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160126/39ab8caa/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Proposal: Remove implicit tuple splat behavior from function applications</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>January 27, 2016 at 07:00:00am</p></header><div class="content"><p>I think libraries like argo use it.<br></p><p>In these cases it&#39;s for initlizing a struct with data (from Json).<br></p><p>You could argue that these libraries could implement this better but I would like to put forward a few questions:<br></p><p>- if we kept this we could instead add an apply function to closures which could take a turple, vardaric array or maybe even allowed you to call it by specifying the names arguments (in any order you liked)<br></p><p>That way you could do:<br></p><p>Object.foo //returns a normal closure<br>Object.foo.apply(turple) //compiler generated sugar function<br></p><p>A lot of libraries including Lenses I think would be simplified by this as they would no longer rely on currying or turple splats as heavily. It also allows you to apply the value of something easily.<br></p><p>Or we could define a new syntax to call labelled arguments in any order <br></p><p>This would work well with immutable objects as in certain cases I wish to mutate a struc like so:<br></p><p>Struct Person<br>{<br>Let name: String<br></p><p>Init(name: String)<br>{<br>self.name = name)<br>}<br>}<br></p><p>Let person = Person(name:&quot;James&quot;)<br>person.mutate({<br>.name = &quot;Bob&quot;<br>}) // this special syntax says to the compiler to take this special object and to return a new copy of the original struct with the values changed.<br></p><p>Inside of the {} you can directly access the properties you wish to change.<br></p><p>I use the closure syntax but perhaps it could use another one .<br></p><p>This syntax could be used for apply so you can define the parameters you care about:  <br></p><p>dependency({<br>name:&quot;networking&quot;,<br>git:&quot;&quot;<br>})<br></p><p>Sent froml my iPhone<br></p><p>&gt; On 27 Jan 2016, at 06:38, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; +1 from me as well. I don&#39;t think I&#39;ve ever used this feature on purpose.<br>&gt; <br>&gt; I look forward to future discussions about splatting, especially as they relate to variadic functions.<br>&gt; <br>&gt;&gt; On Tue, Jan 26, 2016 at 10:36 PM, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; +1<br>&gt;&gt; <br>&gt;&gt; I like the feature quite a bit but avoid it as a result of the naming concerns. If removing this feature can help improve the type checker, the trade is worthwhile, IMO.<br>&gt;&gt; <br>&gt;&gt;&gt; On Wed, Jan 27, 2016 at 1:23 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; For discussion: comments appreciated!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Remove implicit tuple splat behavior from function applications<br>&gt;&gt;&gt; Proposal: SE-TBD<br>&gt;&gt;&gt; Author(s): Chris Lattner<br>&gt;&gt;&gt; Status: Awaiting review<br>&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Function calls (which include several syntactic forms that apply an argument list to something of function type) currently have a dual nature in Swift.  Given something like:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	func foo(a : Int, b : Int) {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You can call it either with with the typical syntactic form that passes arguments to each of its parameters:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	foo(42, b : 17)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; or you can take advantage of a little-known feature to pass an entire argument list as a single value (of tuple type):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	let x = (1, b: 2)<br>&gt;&gt;&gt; 	foo(x)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This proposal recommends removing the later form, which I affectionately refer to as the “tuple splat” form.  This feature is purely a sugar feature, it does not provide any expressive ability beyond passing the parameters manually.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift-evolution thread: TBD<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This behavior is cute, precedented in other functional languages, and has some advantages, but it also has several major disadvantages, which are all related to its syntactic form.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * A call to foo(x) looks like a call to an overloaded version of foo, both to the compiler and to the human who maintains the code.  This is extremely confusing if you don’t know the feature exists.<br>&gt;&gt;&gt; * There are real ambiguities in the syntax, e.g. involving Any arguments and situations where you want to pass a tuple value as a single parameter.<br>&gt;&gt;&gt; * The current implementation has a ton of implementation bugs - it doesn’t work reliably.<br>&gt;&gt;&gt; * The current implementation adds complexity to the type checker, slowing it down and adding maintenance burden.<br>&gt;&gt;&gt; * The current implementation doesn’t work the way we would want a tuple splat operation to work.  For example, arguably, you should be able to call foo with:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	func bar() -&gt; (Int, Int) { … }<br>&gt;&gt;&gt; 	foo(bar())<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; … but this is not allowed, since tuple labels are required to line up.  You have to write:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	func bar() -&gt; (Int, b: Int)  { … }<br>&gt;&gt;&gt; 	foo(bar())<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This makes this feature very difficult to use in practice, because you have to _’ize a lot of parameters (violating naming conventions), perform manual shuffling (defeating the sugar benefits of the feature), or add parameter labels to the result of functions (which leads to odd tying between callers and callees).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The root problem here is that we use exactly the same syntax for both forms of function application.  If the two forms were differentiated (an option considered in “alternatives considered” below) then some of these problems would be defined away.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; From a historical perspective, the tuple splat form of function application dates back to very early Swift design (probably introduced in 2010, but possibly 2011) where all function application was of a single value to a function type.  For a large number of reasons (including default arguments, variadic arguments, labels, etc) we have completely abandoned this model, but we never came back to reevaluating the tuple splat behavior.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If we didn’t already have this feature, we would not add it to Swift 3 (at least in its current form).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The proposed solution is simple, we should just remove this feature from the Swift 3 compiler.  Ideally we would deprecate it in the Swift 2.2 compiler and remove it in Swift 3.  However, if there isn’t time to get the deprecation into Swift 2.2, the author believes it would be perfectly fine to just remove it in Swift 3 (with a fixit + migration help of course).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One of the interesting aspect of this feature is that some of the people we’ve spoken to are very fond of it.  However, when pressed, they admit that they are not actually using it widely in their code, or if they are using it, they are abusing naming conventions (distorting their code) in order to use it.  This doesn’t seem like a positive contribution - this seems like a “clever” feature, not a practical one.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Detailed design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The design is straight-forward.  In the Swift 3 time frame, we continue to parse and type check these expressions as we have so far, but produce an error + fixit hint when it is the tuple splat form.  The migrator would auto-apply the fixit hint as it does for other cases.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Any code that uses this feature will have to move to the traditional form.  In the case of the example above, this means rewriting the code from:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	foo(x)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; into a form like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	foo(x.0, x.b)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In the case where “x” is a complex expression, a temporary variable will need to be introduced.  We believe that compiler fixits can handle the simple cases directly and that this extension is not widely used.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alternatives considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The major problem with this feature is that it was not well considered and implemented properly (owing to its very old age, it has just been kept limping along).  The alternative then is to actually design a proper feature to support this.  Since the implicitness and syntactic ambiguity with normal function application is the problem, the solution is to introduce an explicit syntactic form to represent this.  For example, something like this could address the problems we have:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	foo(*x)    // NOT a serious syntax proposal<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; However, actually designing this feature would be a non-trivial effort not core to the Swift 3 mission:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * It is a pure-sugar feature, and therefore low priority.<br>&gt;&gt;&gt; * We don’t have an obvious sigil to use.  “prefix-star” should be kept as unused for now in case we want to use it to refer to memory-related operations in the future.<br>&gt;&gt;&gt; * Making the tuple splat operation great requires more than just fixing the syntactic ambiguities we have, it would require re-evaluating the semantics of the operation (e.g. in light of parameter labels, varargs and other features).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If there is serious interest in pursuing this as a concept, we should do it as a follow-on proposal to this one.  If a good design emerges, we can evaluate that design based on its merits.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The final alternative is that we could leave the feature in the compiler.  However, that means living with its complexity “forever” or breaking code in the Swift 4 timeframe.  It would be preferable to tackle this breakage in the Swift 3 timeframe, since we know that migration will already be needed then.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/a7514674/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: Remove implicit tuple splat behavior from function applications</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 27, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 26, 2016, at 11:41 PM, James Campbell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I think libraries like argo use it.<br>&gt; <br>&gt; In these cases it&#39;s for initlizing a struct with data (from Json).<br></p><p>Ok, I’m definitely interested in knowing more.  Please include a code sample, showing both the declaration being splatted into and the call sites.  Otherwise, I can’t tell how much value this feature is adding, and what the pain would be if it were removed.  Thanks!<br></p><p>-Chris<br></p><p><br>&gt; <br>&gt; You could argue that these libraries could implement this better but I would like to put forward a few questions:<br>&gt; <br>&gt; - if we kept this we could instead add an apply function to closures which could take a turple, vardaric array or maybe even allowed you to call it by specifying the names arguments (in any order you liked)<br>&gt; <br>&gt; That way you could do:<br>&gt; <br>&gt; Object.foo //returns a normal closure<br>&gt; Object.foo.apply(turple) //compiler generated sugar function<br>&gt; <br>&gt; A lot of libraries including Lenses I think would be simplified by this as they would no longer rely on currying or turple splats as heavily. It also allows you to apply the value of something easily.<br>&gt; <br>&gt; Or we could define a new syntax to call labelled arguments in any order <br>&gt; <br>&gt; This would work well with immutable objects as in certain cases I wish to mutate a struc like so:<br>&gt; <br>&gt; Struct Person<br>&gt; {<br>&gt; Let name: String<br>&gt; <br>&gt; Init(name: String)<br>&gt; {<br>&gt; self.name = name)<br>&gt; }<br>&gt; }<br>&gt; <br>&gt; Let person = Person(name:&quot;James&quot;)<br>&gt; person.mutate({<br>&gt; .name = &quot;Bob&quot;<br>&gt; }) // this special syntax says to the compiler to take this special object and to return a new copy of the original struct with the values changed.<br>&gt; <br>&gt; Inside of the {} you can directly access the properties you wish to change.<br>&gt; <br>&gt; I use the closure syntax but perhaps it could use another one .<br>&gt; <br>&gt; This syntax could be used for apply so you can define the parameters you care about:  <br>&gt; <br>&gt; dependency({<br>&gt; name:&quot;networking&quot;,<br>&gt; git:&quot;&quot;<br>&gt; })<br>&gt; <br>&gt; Sent froml my iPhone<br>&gt; <br>&gt; On 27 Jan 2016, at 06:38, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; +1 from me as well. I don&#39;t think I&#39;ve ever used this feature on purpose.<br>&gt;&gt; <br>&gt;&gt; I look forward to future discussions about splatting, especially as they relate to variadic functions.<br>&gt;&gt; <br>&gt;&gt; On Tue, Jan 26, 2016 at 10:36 PM, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; +1<br>&gt;&gt; <br>&gt;&gt; I like the feature quite a bit but avoid it as a result of the naming concerns. If removing this feature can help improve the type checker, the trade is worthwhile, IMO.<br>&gt;&gt; <br>&gt;&gt; On Wed, Jan 27, 2016 at 1:23 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; For discussion: comments appreciated!<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Remove implicit tuple splat behavior from function applications<br>&gt;&gt; <br>&gt;&gt; Proposal: SE- &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;TBD<br>&gt;&gt; Author(s): Chris Lattner<br>&gt;&gt; Status: Awaiting review<br>&gt;&gt; Review manager: TBD<br>&gt;&gt;  &lt;https://github.com/apple/swift-evolution#introduction&gt;Introduction<br>&gt;&gt; <br>&gt;&gt; Function calls (which include several syntactic forms that apply an argument list to something of function type) currently have a dual nature in Swift.  Given something like:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; 	func foo(a : Int, b : Int) {}<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; You can call it either with with the typical syntactic form that passes arguments to each of its parameters:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; 	foo(42, b : 17)<br>&gt;&gt; <br>&gt;&gt; or you can take advantage of a little-known feature to pass an entire argument list as a single value (of tuple type):<br>&gt;&gt; <br>&gt;&gt; 	let x = (1, b: 2)<br>&gt;&gt; 	foo(x)<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; This proposal recommends removing the later form, which I affectionately refer to as the “tuple splat” form.  This feature is purely a sugar feature, it does not provide any expressive ability beyond passing the parameters manually.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Swift-evolution thread: TBD<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/apple/swift-evolution#motivation&gt;Motivation<br>&gt;&gt; <br>&gt;&gt; This behavior is cute, precedented in other functional languages, and has some advantages, but it also has several major disadvantages, which are all related to its syntactic form.<br>&gt;&gt; <br>&gt;&gt; * A call to foo(x) looks like a call to an overloaded version of foo, both to the compiler and to the human who maintains the code.  This is extremely confusing if you don’t know the feature exists.<br>&gt;&gt; * There are real ambiguities in the syntax, e.g. involving Any arguments and situations where you want to pass a tuple value as a single parameter.<br>&gt;&gt; * The current implementation has a ton of implementation bugs - it doesn’t work reliably.<br>&gt;&gt; * The current implementation adds complexity to the type checker, slowing it down and adding maintenance burden.<br>&gt;&gt; * The current implementation doesn’t work the way we would want a tuple splat operation to work.  For example, arguably, you should be able to call foo with:<br>&gt;&gt; <br>&gt;&gt; 	func bar() -&gt; (Int, Int) { … }<br>&gt;&gt; 	foo(bar())<br>&gt;&gt; <br>&gt;&gt; … but this is not allowed, since tuple labels are required to line up.  You have to write:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; 	func bar() -&gt; (Int, b: Int)  { … }<br>&gt;&gt; 	foo(bar())<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; This makes this feature very difficult to use in practice, because you have to _’ize a lot of parameters (violating naming conventions), perform manual shuffling (defeating the sugar benefits of the feature), or add parameter labels to the result of functions (which leads to odd tying between callers and callees).<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; The root problem here is that we use exactly the same syntax for both forms of function application.  If the two forms were differentiated (an option considered in “alternatives considered” below) then some of these problems would be defined away.<br>&gt;&gt; <br>&gt;&gt; From a historical perspective, the tuple splat form of function application dates back to very early Swift design (probably introduced in 2010, but possibly 2011) where all function application was of a single value to a function type.  For a large number of reasons (including default arguments, variadic arguments, labels, etc) we have completely abandoned this model, but we never came back to reevaluating the tuple splat behavior.<br>&gt;&gt; <br>&gt;&gt; If we didn’t already have this feature, we would not add it to Swift 3 (at least in its current form).<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/apple/swift-evolution#proposed-solution&gt;Proposed solution<br>&gt;&gt; <br>&gt;&gt; The proposed solution is simple, we should just remove this feature from the Swift 3 compiler.  Ideally we would deprecate it in the Swift 2.2 compiler and remove it in Swift 3.  However, if there isn’t time to get the deprecation into Swift 2.2, the author believes it would be perfectly fine to just remove it in Swift 3 (with a fixit + migration help of course).<br>&gt;&gt; <br>&gt;&gt; One of the interesting aspect of this feature is that some of the people we’ve spoken to are very fond of it.  However, when pressed, they admit that they are not actually using it widely in their code, or if they are using it, they are abusing naming conventions (distorting their code) in order to use it.  This doesn’t seem like a positive contribution - this seems like a “clever” feature, not a practical one.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/apple/swift-evolution#detailed-design&gt;Detailed design<br>&gt;&gt; <br>&gt;&gt; The design is straight-forward.  In the Swift 3 time frame, we continue to parse and type check these expressions as we have so far, but produce an error + fixit hint when it is the tuple splat form.  The migrator would auto-apply the fixit hint as it does for other cases.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/apple/swift-evolution#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt; <br>&gt;&gt; Any code that uses this feature will have to move to the traditional form.  In the case of the example above, this means rewriting the code from:<br>&gt;&gt; <br>&gt;&gt; 	foo(x)<br>&gt;&gt; <br>&gt;&gt; into a form like this:<br>&gt;&gt; <br>&gt;&gt; 	foo(x.0, x.b)<br>&gt;&gt; <br>&gt;&gt; In the case where “x” is a complex expression, a temporary variable will need to be introduced.  We believe that compiler fixits can handle the simple cases directly and that this extension is not widely used.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/apple/swift-evolution#alternatives-considered&gt;Alternatives considered<br>&gt;&gt; <br>&gt;&gt; The major problem with this feature is that it was not well considered and implemented properly (owing to its very old age, it has just been kept limping along).  The alternative then is to actually design a proper feature to support this.  Since the implicitness and syntactic ambiguity with normal function application is the problem, the solution is to introduce an explicit syntactic form to represent this.  For example, something like this could address the problems we have:<br>&gt;&gt; <br>&gt;&gt; 	foo(*x)    // NOT a serious syntax proposal<br>&gt;&gt; <br>&gt;&gt; However, actually designing this feature would be a non-trivial effort not core to the Swift 3 mission:<br>&gt;&gt; <br>&gt;&gt; * It is a pure-sugar feature, and therefore low priority.<br>&gt;&gt; * We don’t have an obvious sigil to use.  “prefix-star” should be kept as unused for now in case we want to use it to refer to memory-related operations in the future.<br>&gt;&gt; * Making the tuple splat operation great requires more than just fixing the syntactic ambiguities we have, it would require re-evaluating the semantics of the operation (e.g. in light of parameter labels, varargs and other features).<br>&gt;&gt; <br>&gt;&gt; If there is serious interest in pursuing this as a concept, we should do it as a follow-on proposal to this one.  If a good design emerges, we can evaluate that design based on its merits.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; The final alternative is that we could leave the feature in the compiler.  However, that means living with its complexity “forever” or breaking code in the Swift 4 timeframe.  It would be preferable to tackle this breakage in the Swift 3 timeframe, since we know that migration will already be needed then.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/623ed180/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Proposal: Remove implicit tuple splat behavior from function applications</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>January 27, 2016 at 07:00:00pm</p></header><div class="content"><p>https://github.com/thoughtbot/Argo<br></p><p>This is the example from their github page<br></p><p>import Argoimport Curry<br>struct User {<br>  let id: Int<br>  let name: String<br>  let email: String?<br>  let role: Role<br>  let companyName: String<br>  let friends: [User]<br>}<br>extension User: Decodable {<br>  static func decode(j: JSON) -&gt; Decoded&lt;User&gt; {<br>    return curry(User.init)<br>      &lt;^&gt; j &lt;| &quot;id&quot;<br>      &lt;*&gt; j &lt;| &quot;name&quot;<br>      &lt;*&gt; j &lt;|? &quot;email&quot; // Use ? for parsing optional values<br>      &lt;*&gt; j &lt;| &quot;role&quot; // Custom types that also conform to Decodable just work<br>      &lt;*&gt; j &lt;| [&quot;company&quot;, &quot;name&quot;] // Parse nested objects<br>      &lt;*&gt; j &lt;|| &quot;friends&quot; // parse arrays of objects<br>  }<br>}<br>// Wherever you receive JSON data:<br>let json: AnyObject? = try?<br>NSJSONSerialization.JSONObjectWithData(data, options: [])<br>if let j: AnyObject = json {<br>  let user: User? = decode(j)<br>}<br></p><p>On second reading it seems to use currying<br></p><p><br>public func curry&lt;A, B&gt;(function: (A) -&gt; B) -&gt; A -&gt; B {<br>    return { `a` in function(`a`) }<br>}<br>public func curry&lt;A, B, C&gt;(function: (A, B) -&gt; C) -&gt; A -&gt; B -&gt; C {<br>    return { `a` in { `b` in function(`a`, `b`) } }<br>}<br>public func curry&lt;A, B, C, D&gt;(function: (A, B, C) -&gt; D) -&gt; A -&gt; B -&gt; C -&gt; D {<br>    return { `a` in { `b` in { `c` in function(`a`, `b`, `c`) } } }<br>}<br>public func curry&lt;A, B, C, D, E&gt;(function: (A, B, C, D) -&gt; E) -&gt; A -&gt;<br>B -&gt; C -&gt; D -&gt; E {<br>    return { `a` in { `b` in { `c` in { `d` in function(`a`, `b`, `c`,<br>`d`) } } } }<br>}<br>public func curry&lt;A, B, C, D, E, F&gt;(function: (A, B, C, D, E) -&gt; F) -&gt;<br>A -&gt; B -&gt; C -&gt; D -&gt; E -&gt; F {<br>    return { `a` in { `b` in { `c` in { `d` in { `e` in function(`a`,<br>`b`, `c`, `d`, `e`) } } } } }<br>}<br>public func curry&lt;A, B, C, D, E, F, G&gt;(function: (A, B, C, D, E, F) -&gt;<br>G) -&gt; A -&gt; B -&gt; C -&gt; D -&gt; E -&gt; F -&gt; G {<br>    return { `a` in { `b` in { `c` in { `d` in { `e` in { `f` in<br>function(`a`, `b`, `c`, `d`, `e`, `f`) } } } } } }<br>}<br>public func curry&lt;A, B, C, D, E, F, G, H&gt;(function: (A, B, C, D, E, F,<br>G) -&gt; H) -&gt; A -&gt; B -&gt; C -&gt; D -&gt; E -&gt; F -&gt; G -&gt; H {<br>    return { `a` in { `b` in { `c` in { `d` in { `e` in { `f` in { `g`<br>in function(`a`, `b`, `c`, `d`, `e`, `f`, `g`) } } } } } } }<br>}<br>public func curry&lt;A, B, C, D, E, F, G, H, I&gt;(function: (A, B, C, D, E,<br>F, G, H) -&gt; I) -&gt; A -&gt; B -&gt; C -&gt; D -&gt; E -&gt; F -&gt; G -&gt; H -&gt; I {<br>    return { `a` in { `b` in { `c` in { `d` in { `e` in { `f` in { `g`<br>in { `h` in function(`a`, `b`, `c`, `d`, `e`, `f`, `g`, `h`) } } } } }<br>} } }<br>}<br>public func curry&lt;A, B, C, D, E, F, G, H, I, J&gt;(function: (A, B, C, D,<br>E, F, G, H, I) -&gt; J) -&gt; A -&gt; B -&gt; C -&gt; D -&gt; E -&gt; F -&gt; G -&gt; H -&gt; I -&gt; J<br>{<br>    return { `a` in { `b` in { `c` in { `d` in { `e` in { `f` in { `g`<br>in { `h` in { `i` in function(`a`, `b`, `c`, `d`, `e`, `f`, `g`, `h`,<br>`i`) } } } } } } } } }<br>}<br>public func curry&lt;A, B, C, D, E, F, G, H, I, J, K&gt;(function: (A, B, C,<br>D, E, F, G, H, I, J) -&gt; K) -&gt; A -&gt; B -&gt; C -&gt; D -&gt; E -&gt; F -&gt; G -&gt; H -&gt;<br>I -&gt; J -&gt; K {<br>    return { `a` in { `b` in { `c` in { `d` in { `e` in { `f` in { `g`<br>in { `h` in { `i` in { `j` in function(`a`, `b`, `c`, `d`, `e`, `f`,<br>`g`, `h`, `i`, `j`) } } } } } } } } } }<br>}<br>public func curry&lt;A, B, C, D, E, F, G, H, I, J, K, L&gt;(function: (A, B,<br>C, D, E, F, G, H, I, J, K) -&gt; L) -&gt; A -&gt; B -&gt; C -&gt; D -&gt; E -&gt; F -&gt; G -&gt;<br>H -&gt; I -&gt; J -&gt; K -&gt; L {<br>    return { `a` in { `b` in { `c` in { `d` in { `e` in { `f` in { `g`<br>in { `h` in { `i` in { `j` in { `k` in function(`a`, `b`, `c`, `d`,<br>`e`, `f`, `g`, `h`, `i`, `j`, `k`) } } } } } } } } } } }<br>}<br>public func curry&lt;A, B, C, D, E, F, G, H, I, J, K, L, M&gt;(function: (A,<br>B, C, D, E, F, G, H, I, J, K, L) -&gt; M) -&gt; A -&gt; B -&gt; C -&gt; D -&gt; E -&gt; F<br>-&gt; G -&gt; H -&gt; I -&gt; J -&gt; K -&gt; L -&gt; M {<br>    return { `a` in { `b` in { `c` in { `d` in { `e` in { `f` in { `g`<br>in { `h` in { `i` in { `j` in { `k` in { `l` in function(`a`, `b`,<br>`c`, `d`, `e`, `f`, `g`, `h`, `i`, `j`, `k`, `l`) } } } } } } } } } }<br>} }<br>}<br>public func curry&lt;A, B, C, D, E, F, G, H, I, J, K, L, M, N&gt;(function:<br>(A, B, C, D, E, F, G, H, I, J, K, L, M) -&gt; N) -&gt; A -&gt; B -&gt; C -&gt; D -&gt; E<br>-&gt; F -&gt; G -&gt; H -&gt; I -&gt; J -&gt; K -&gt; L -&gt; M -&gt; N {<br>    return { `a` in { `b` in { `c` in { `d` in { `e` in { `f` in { `g`<br>in { `h` in { `i` in { `j` in { `k` in { `l` in { `m` in function(`a`,<br>`b`, `c`, `d`, `e`, `f`, `g`, `h`, `i`, `j`, `k`, `l`, `m`) } } } } }<br>} } } } } } } }<br>}<br>public func curry&lt;A, B, C, D, E, F, G, H, I, J, K, L, M, N,<br>O&gt;(function: (A, B, C, D, E, F, G, H, I, J, K, L, M, N) -&gt; O) -&gt; A -&gt;<br>B -&gt; C -&gt; D -&gt; E -&gt; F -&gt; G -&gt; H -&gt; I -&gt; J -&gt; K -&gt; L -&gt; M -&gt; N -&gt; O {<br>    return { `a` in { `b` in { `c` in { `d` in { `e` in { `f` in { `g`<br>in { `h` in { `i` in { `j` in { `k` in { `l` in { `m` in { `n` in<br>function(`a`, `b`, `c`, `d`, `e`, `f`, `g`, `h`, `i`, `j`, `k`, `l`,<br>`m`, `n`) } } } } } } } } } } } } } }<br>}<br>public func curry&lt;A, B, C, D, E, F, G, H, I, J, K, L, M, N, O,<br>P&gt;(function: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O) -&gt; P) -&gt; A<br>-&gt; B -&gt; C -&gt; D -&gt; E -&gt; F -&gt; G -&gt; H -&gt; I -&gt; J -&gt; K -&gt; L -&gt; M -&gt; N -&gt; O<br>-&gt; P {<br>    return { `a` in { `b` in { `c` in { `d` in { `e` in { `f` in { `g`<br>in { `h` in { `i` in { `j` in { `k` in { `l` in { `m` in { `n` in {<br>`o` in function(`a`, `b`, `c`, `d`, `e`, `f`, `g`, `h`, `i`, `j`, `k`,<br>`l`, `m`, `n`, `o`) } } } } } } } } } } } } } } }<br>}<br>public func curry&lt;A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P,<br>Q&gt;(function: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P) -&gt; Q) -&gt;<br>A -&gt; B -&gt; C -&gt; D -&gt; E -&gt; F -&gt; G -&gt; H -&gt; I -&gt; J -&gt; K -&gt; L -&gt; M -&gt; N -&gt;<br>O -&gt; P -&gt; Q {<br>    return { `a` in { `b` in { `c` in { `d` in { `e` in { `f` in { `g`<br>in { `h` in { `i` in { `j` in { `k` in { `l` in { `m` in { `n` in {<br>`o` in { `p` in function(`a`, `b`, `c`, `d`, `e`, `f`, `g`, `h`, `i`,<br>`j`, `k`, `l`, `m`, `n`, `o`, `p`) } } } } } } } } } } } } } } } }<br>}<br>public func curry&lt;A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q,<br>R&gt;(function: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q) -&gt; R)<br>-&gt; A -&gt; B -&gt; C -&gt; D -&gt; E -&gt; F -&gt; G -&gt; H -&gt; I -&gt; J -&gt; K -&gt; L -&gt; M -&gt; N<br>-&gt; O -&gt; P -&gt; Q -&gt; R {<br>    return { `a` in { `b` in { `c` in { `d` in { `e` in { `f` in { `g`<br>in { `h` in { `i` in { `j` in { `k` in { `l` in { `m` in { `n` in {<br>`o` in { `p` in { `q` in function(`a`, `b`, `c`, `d`, `e`, `f`, `g`,<br>`h`, `i`, `j`, `k`, `l`, `m`, `n`, `o`, `p`, `q`) } } } } } } } } } }<br>} } } } } } }<br>}<br>public func curry&lt;A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q,<br>R, S&gt;(function: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R)<br>-&gt; S) -&gt; A -&gt; B -&gt; C -&gt; D -&gt; E -&gt; F -&gt; G -&gt; H -&gt; I -&gt; J -&gt; K -&gt; L -&gt; M<br>-&gt; N -&gt; O -&gt; P -&gt; Q -&gt; R -&gt; S {<br>    return { `a` in { `b` in { `c` in { `d` in { `e` in { `f` in { `g`<br>in { `h` in { `i` in { `j` in { `k` in { `l` in { `m` in { `n` in {<br>`o` in { `p` in { `q` in { `r` in function(`a`, `b`, `c`, `d`, `e`,<br>`f`, `g`, `h`, `i`, `j`, `k`, `l`, `m`, `n`, `o`, `p`, `q`, `r`) } } }<br>} } } } } } } } } } } } } } }<br>}<br></p><p><br>*___________________________________*<br></p><p>*James⎥Lead Engineer*<br></p><p>*james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com &lt;http://supmenow.com&gt;*<br></p><p>*Sup*<br></p><p>*Runway East *<br></p><p>*10 Finsbury Square*<br></p><p>*London*<br></p><p>* EC2A 1AF *<br></p><p>On Wed, Jan 27, 2016 at 6:15 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Jan 26, 2016, at 11:41 PM, James Campbell via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I think libraries like argo use it.<br>&gt;<br>&gt; In these cases it&#39;s for initlizing a struct with data (from Json).<br>&gt;<br>&gt;<br>&gt; Ok, I’m definitely interested in knowing more.  Please include a code<br>&gt; sample, showing both the declaration being splatted into and the call<br>&gt; sites.  Otherwise, I can’t tell how much value this feature is adding, and<br>&gt; what the pain would be if it were removed.  Thanks!<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br>&gt;<br>&gt; You could argue that these libraries could implement this better but I<br>&gt; would like to put forward a few questions:<br>&gt;<br>&gt; - if we kept this we could instead add an apply function to closures which<br>&gt; could take a turple, vardaric array or maybe even allowed you to call it by<br>&gt; specifying the names arguments (in any order you liked)<br>&gt;<br>&gt; That way you could do:<br>&gt;<br>&gt; Object.foo //returns a normal closure<br>&gt; Object.foo.apply(turple) //compiler generated sugar function<br>&gt;<br>&gt; A lot of libraries including Lenses I think would be simplified by this as<br>&gt; they would no longer rely on currying or turple splats as heavily. It also<br>&gt; allows you to apply the value of something easily.<br>&gt;<br>&gt; Or we could define a new syntax to call labelled arguments in any order<br>&gt;<br>&gt; This would work well with immutable objects as in certain cases I wish to<br>&gt; mutate a struc like so:<br>&gt;<br>&gt; Struct Person<br>&gt; {<br>&gt; Let name: String<br>&gt;<br>&gt; Init(name: String)<br>&gt; {<br>&gt; self.name = name)<br>&gt; }<br>&gt; }<br>&gt;<br>&gt; Let person = Person(name:&quot;James&quot;)<br>&gt; person.mutate({<br>&gt; .name = &quot;Bob&quot;<br>&gt; }) // this special syntax says to the compiler to take this special object<br>&gt; and to return a new copy of the original struct with the values changed.<br>&gt;<br>&gt; Inside of the {} you can directly access the properties you wish to change.<br>&gt;<br>&gt; I use the closure syntax but perhaps it could use another one .<br>&gt;<br>&gt; This syntax could be used for apply so you can define the parameters you<br>&gt; care about:<br>&gt;<br>&gt; dependency({<br>&gt; name:&quot;networking&quot;,<br>&gt; git:&quot;&quot;<br>&gt; })<br>&gt;<br>&gt; Sent froml my iPhone<br>&gt;<br>&gt; On 27 Jan 2016, at 06:38, Jacob Bandes-Storch via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; +1 from me as well. I don&#39;t think I&#39;ve ever used this feature on purpose.<br>&gt;<br>&gt; I look forward to future discussions about splatting, especially as they<br>&gt; relate to variadic functions.<br>&gt;<br>&gt; On Tue, Jan 26, 2016 at 10:36 PM, T.J. Usiyan via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; +1<br>&gt;&gt;<br>&gt;&gt; I like the feature quite a bit but avoid it as a result of the naming<br>&gt;&gt; concerns. If removing this feature can help improve the type checker, the<br>&gt;&gt; trade is worthwhile, IMO.<br>&gt;&gt;<br>&gt;&gt; On Wed, Jan 27, 2016 at 1:23 AM, Chris Lattner via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; For discussion: comments appreciated!<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Remove implicit tuple splat behavior from function applications<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    - Proposal: SE-<br>&gt;&gt;&gt;    &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;<br>&gt;&gt;&gt;    TBD<br>&gt;&gt;&gt;    - Author(s): Chris Lattner<br>&gt;&gt;&gt;    - Status: *Awaiting review*<br>&gt;&gt;&gt;    - Review manager: TBD<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &lt;https://github.com/apple/swift-evolution#introduction&gt;Introduction<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Function calls (which include several syntactic forms that apply an<br>&gt;&gt;&gt; argument list to something of function type) currently have a dual nature<br>&gt;&gt;&gt; in Swift.  Given something like:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func foo(a : Int, b : Int) {}<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; You can call it either with with the typical syntactic form that passes<br>&gt;&gt;&gt; arguments to each of its parameters:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; foo(42, b : 17)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; or you can take advantage of a little-known feature to pass an entire<br>&gt;&gt;&gt; argument list as a single value (of tuple type):<br>&gt;&gt;&gt; let x = (1, b: 2)<br>&gt;&gt;&gt; foo(x)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This proposal recommends removing the later form, which I affectionately<br>&gt;&gt;&gt; refer to as the “tuple splat” form.  This feature is purely a sugar<br>&gt;&gt;&gt; feature, it does not provide any expressive ability beyond passing the<br>&gt;&gt;&gt; parameters manually.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Swift-evolution thread: TBD<br>&gt;&gt;&gt; &lt;https://github.com/apple/swift-evolution#motivation&gt;Motivation<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This behavior is cute, precedented in other functional languages, and<br>&gt;&gt;&gt; has some advantages, but it also has several major disadvantages, which are<br>&gt;&gt;&gt; all related to its syntactic form.<br>&gt;&gt;&gt; * A call to foo(x) looks like a call to an overloaded version of foo,<br>&gt;&gt;&gt; both to the compiler and to the human who maintains the code.  This is<br>&gt;&gt;&gt; extremely confusing if you don’t know the feature exists.<br>&gt;&gt;&gt; * There are real ambiguities in the syntax, e.g. involving Any arguments<br>&gt;&gt;&gt; and situations where you want to pass a tuple value as a single parameter.<br>&gt;&gt;&gt; * The current implementation has a ton of implementation bugs - it<br>&gt;&gt;&gt; doesn’t work reliably.<br>&gt;&gt;&gt; * The current implementation adds complexity to the type checker,<br>&gt;&gt;&gt; slowing it down and adding maintenance burden.<br>&gt;&gt;&gt; * The current implementation doesn’t work the way we would want a tuple<br>&gt;&gt;&gt; splat operation to work.  For example, arguably, you should be able to call<br>&gt;&gt;&gt; foo with:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func bar() -&gt; (Int, Int) { … }<br>&gt;&gt;&gt; foo(bar())<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; … but this is not allowed, since tuple labels are required to line up.<br>&gt;&gt;&gt; You have to write:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func bar() -&gt; (Int, b: Int)  { … }<br>&gt;&gt;&gt; foo(bar())<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This makes this feature very difficult to use in practice, because you<br>&gt;&gt;&gt; have to _’ize a lot of parameters (violating naming conventions), perform<br>&gt;&gt;&gt; manual shuffling (defeating the sugar benefits of the feature), or add<br>&gt;&gt;&gt; parameter labels to the result of functions (which leads to odd tying<br>&gt;&gt;&gt; between callers and callees).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The root problem here is that we use exactly the same syntax for both<br>&gt;&gt;&gt; forms of function application.  If the two forms were differentiated (an<br>&gt;&gt;&gt; option considered in “alternatives considered” below) then some of these<br>&gt;&gt;&gt; problems would be defined away.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; From a historical perspective, the tuple splat form of function<br>&gt;&gt;&gt; application dates back to very early Swift design (probably introduced in<br>&gt;&gt;&gt; 2010, but possibly 2011) where all function application was of a single<br>&gt;&gt;&gt; value to a function type.  For a large number of reasons (including default<br>&gt;&gt;&gt; arguments, variadic arguments, labels, etc) we have completely abandoned<br>&gt;&gt;&gt; this model, but we never came back to reevaluating the tuple splat behavior.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If we didn’t already have this feature, we would not add it to Swift 3<br>&gt;&gt;&gt; (at least in its current form).<br>&gt;&gt;&gt; &lt;https://github.com/apple/swift-evolution#proposed-solution&gt;Proposed<br>&gt;&gt;&gt; solution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The proposed solution is simple, we should just remove this feature from<br>&gt;&gt;&gt; the Swift 3 compiler.  Ideally we would deprecate it in the Swift 2.2<br>&gt;&gt;&gt; compiler and remove it in Swift 3.  However, if there isn’t time to get the<br>&gt;&gt;&gt; deprecation into Swift 2.2, the author believes it would be perfectly fine<br>&gt;&gt;&gt; to just remove it in Swift 3 (with a fixit + migration help of course).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; One of the interesting aspect of this feature is that some of the people<br>&gt;&gt;&gt; we’ve spoken to are very fond of it.  However, when pressed, they admit<br>&gt;&gt;&gt; that they are not actually using it widely in their code, or if they<br>&gt;&gt;&gt; are using it, they are abusing naming conventions (distorting their code)<br>&gt;&gt;&gt; in order to use it.  This doesn’t seem like a positive contribution - this<br>&gt;&gt;&gt; seems like a “clever” feature, not a practical one.<br>&gt;&gt;&gt; &lt;https://github.com/apple/swift-evolution#detailed-design&gt;Detailed<br>&gt;&gt;&gt; design<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The design is straight-forward.  In the Swift 3 time frame, we continue<br>&gt;&gt;&gt; to parse and type check these expressions as we have so far, but produce an<br>&gt;&gt;&gt; error + fixit hint when it is the tuple splat form.  The migrator would<br>&gt;&gt;&gt; auto-apply the fixit hint as it does for other cases.<br>&gt;&gt;&gt; &lt;https://github.com/apple/swift-evolution#impact-on-existing-code&gt;Impact<br>&gt;&gt;&gt; on existing code<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Any code that uses this feature will have to move to the traditional<br>&gt;&gt;&gt; form.  In the case of the example above, this means rewriting the code from:<br>&gt;&gt;&gt; foo(x)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; into a form like this:<br>&gt;&gt;&gt; foo(x.0, x.b)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In the case where “x” is a complex expression, a temporary variable will<br>&gt;&gt;&gt; need to be introduced.  We believe that compiler fixits can handle the<br>&gt;&gt;&gt; simple cases directly and that this extension is not widely used.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &lt;https://github.com/apple/swift-evolution#alternatives-considered&gt;Alternatives<br>&gt;&gt;&gt; considered<br>&gt;&gt;&gt; The major problem with this feature is that it was not well considered<br>&gt;&gt;&gt; and implemented properly (owing to its very old age, it has just been kept<br>&gt;&gt;&gt; limping along).  The alternative then is to actually design a proper<br>&gt;&gt;&gt; feature to support this.  Since the implicitness and syntactic ambiguity<br>&gt;&gt;&gt; with normal function application is the problem, the solution is to<br>&gt;&gt;&gt; introduce an explicit syntactic form to represent this.  For example,<br>&gt;&gt;&gt; something like this could address the problems we have:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; foo(*x)    // NOT a serious syntax proposal<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; However, actually designing this feature would be a non-trivial effort<br>&gt;&gt;&gt; not core to the Swift 3 mission:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; * It is a pure-sugar feature, and therefore low priority.<br>&gt;&gt;&gt; * We don’t have an obvious sigil to use.  “prefix-star” should be kept<br>&gt;&gt;&gt; as unused for now in case we want to use it to refer to memory-related<br>&gt;&gt;&gt; operations in the future.<br>&gt;&gt;&gt; * Making the tuple splat operation great requires more than just fixing<br>&gt;&gt;&gt; the syntactic ambiguities we have, it would require re-evaluating the<br>&gt;&gt;&gt; semantics of the operation (e.g. in light of parameter labels, varargs and<br>&gt;&gt;&gt; other features).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If there is serious interest in pursuing this as a concept, we should do<br>&gt;&gt;&gt; it as a follow-on proposal to this one.  If a good design emerges, we can<br>&gt;&gt;&gt; evaluate that design based on its merits.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The final alternative is that we could leave the feature in the<br>&gt;&gt;&gt; compiler.  However, that means living with its complexity “forever” or<br>&gt;&gt;&gt; breaking code in the Swift 4 timeframe.  It would be preferable to tackle<br>&gt;&gt;&gt; this breakage in the Swift 3 timeframe, since we know that migration will<br>&gt;&gt;&gt; already be needed then.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/cd7ac2ea/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d042be5dcfe90e649f760303af3e429?s=50"></div><header><strong>Proposal: Remove implicit tuple splat behavior from function applications</strong> from <string>Jens Persson</string> &lt;jens at bitcycle.com&gt;<p>January 27, 2016 at 08:00:00am</p></header><div class="content"><p>+-0. I saw, in my dreams, many &quot;different parts&quot; of the language, like<br>pattern matching, function argument- &amp; parameter lists, and tuples, all<br>just being one and the same simple yet powerful unifying concept ...<br>:´ /<br></p><p>On Wed, Jan 27, 2016 at 7:38 AM, Jacob Bandes-Storch via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; +1 from me as well. I don&#39;t think I&#39;ve ever used this feature on purpose.<br>&gt;<br>&gt; I look forward to future discussions about splatting, especially as they<br>&gt; relate to variadic functions.<br>&gt;<br>&gt;<br>&gt; On Tue, Jan 26, 2016 at 10:36 PM, T.J. Usiyan via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; +1<br>&gt;&gt;<br>&gt;&gt; I like the feature quite a bit but avoid it as a result of the naming<br>&gt;&gt; concerns. If removing this feature can help improve the type checker, the<br>&gt;&gt; trade is worthwhile, IMO.<br>&gt;&gt;<br>&gt;&gt; On Wed, Jan 27, 2016 at 1:23 AM, Chris Lattner via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; For discussion: comments appreciated!<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Remove implicit tuple splat behavior from function applications<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    - Proposal: SE-<br>&gt;&gt;&gt;    &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;<br>&gt;&gt;&gt;    TBD<br>&gt;&gt;&gt;    - Author(s): Chris Lattner<br>&gt;&gt;&gt;    - Status: *Awaiting review*<br>&gt;&gt;&gt;    - Review manager: TBD<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &lt;https://github.com/apple/swift-evolution#introduction&gt;Introduction<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Function calls (which include several syntactic forms that apply an<br>&gt;&gt;&gt; argument list to something of function type) currently have a dual nature<br>&gt;&gt;&gt; in Swift.  Given something like:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func foo(a : Int, b : Int) {}<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; You can call it either with with the typical syntactic form that passes<br>&gt;&gt;&gt; arguments to each of its parameters:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; foo(42, b : 17)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; or you can take advantage of a little-known feature to pass an entire<br>&gt;&gt;&gt; argument list as a single value (of tuple type):<br>&gt;&gt;&gt; let x = (1, b: 2)<br>&gt;&gt;&gt; foo(x)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This proposal recommends removing the later form, which I affectionately<br>&gt;&gt;&gt; refer to as the “tuple splat” form.  This feature is purely a sugar<br>&gt;&gt;&gt; feature, it does not provide any expressive ability beyond passing the<br>&gt;&gt;&gt; parameters manually.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Swift-evolution thread: TBD<br>&gt;&gt;&gt; &lt;https://github.com/apple/swift-evolution#motivation&gt;Motivation<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This behavior is cute, precedented in other functional languages, and<br>&gt;&gt;&gt; has some advantages, but it also has several major disadvantages, which are<br>&gt;&gt;&gt; all related to its syntactic form.<br>&gt;&gt;&gt; * A call to foo(x) looks like a call to an overloaded version of foo,<br>&gt;&gt;&gt; both to the compiler and to the human who maintains the code.  This is<br>&gt;&gt;&gt; extremely confusing if you don’t know the feature exists.<br>&gt;&gt;&gt; * There are real ambiguities in the syntax, e.g. involving Any arguments<br>&gt;&gt;&gt; and situations where you want to pass a tuple value as a single parameter.<br>&gt;&gt;&gt; * The current implementation has a ton of implementation bugs - it<br>&gt;&gt;&gt; doesn’t work reliably.<br>&gt;&gt;&gt; * The current implementation adds complexity to the type checker,<br>&gt;&gt;&gt; slowing it down and adding maintenance burden.<br>&gt;&gt;&gt; * The current implementation doesn’t work the way we would want a tuple<br>&gt;&gt;&gt; splat operation to work.  For example, arguably, you should be able to call<br>&gt;&gt;&gt; foo with:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func bar() -&gt; (Int, Int) { … }<br>&gt;&gt;&gt; foo(bar())<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; … but this is not allowed, since tuple labels are required to line up.<br>&gt;&gt;&gt; You have to write:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func bar() -&gt; (Int, b: Int)  { … }<br>&gt;&gt;&gt; foo(bar())<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This makes this feature very difficult to use in practice, because you<br>&gt;&gt;&gt; have to _’ize a lot of parameters (violating naming conventions), perform<br>&gt;&gt;&gt; manual shuffling (defeating the sugar benefits of the feature), or add<br>&gt;&gt;&gt; parameter labels to the result of functions (which leads to odd tying<br>&gt;&gt;&gt; between callers and callees).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The root problem here is that we use exactly the same syntax for both<br>&gt;&gt;&gt; forms of function application.  If the two forms were differentiated (an<br>&gt;&gt;&gt; option considered in “alternatives considered” below) then some of these<br>&gt;&gt;&gt; problems would be defined away.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; From a historical perspective, the tuple splat form of function<br>&gt;&gt;&gt; application dates back to very early Swift design (probably introduced in<br>&gt;&gt;&gt; 2010, but possibly 2011) where all function application was of a single<br>&gt;&gt;&gt; value to a function type.  For a large number of reasons (including default<br>&gt;&gt;&gt; arguments, variadic arguments, labels, etc) we have completely abandoned<br>&gt;&gt;&gt; this model, but we never came back to reevaluating the tuple splat behavior.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If we didn’t already have this feature, we would not add it to Swift 3<br>&gt;&gt;&gt; (at least in its current form).<br>&gt;&gt;&gt; &lt;https://github.com/apple/swift-evolution#proposed-solution&gt;Proposed<br>&gt;&gt;&gt; solution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The proposed solution is simple, we should just remove this feature from<br>&gt;&gt;&gt; the Swift 3 compiler.  Ideally we would deprecate it in the Swift 2.2<br>&gt;&gt;&gt; compiler and remove it in Swift 3.  However, if there isn’t time to get the<br>&gt;&gt;&gt; deprecation into Swift 2.2, the author believes it would be perfectly fine<br>&gt;&gt;&gt; to just remove it in Swift 3 (with a fixit + migration help of course).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; One of the interesting aspect of this feature is that some of the people<br>&gt;&gt;&gt; we’ve spoken to are very fond of it.  However, when pressed, they admit<br>&gt;&gt;&gt; that they are not actually using it widely in their code, or if they<br>&gt;&gt;&gt; are using it, they are abusing naming conventions (distorting their code)<br>&gt;&gt;&gt; in order to use it.  This doesn’t seem like a positive contribution - this<br>&gt;&gt;&gt; seems like a “clever” feature, not a practical one.<br>&gt;&gt;&gt; &lt;https://github.com/apple/swift-evolution#detailed-design&gt;Detailed<br>&gt;&gt;&gt; design<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The design is straight-forward.  In the Swift 3 time frame, we continue<br>&gt;&gt;&gt; to parse and type check these expressions as we have so far, but produce an<br>&gt;&gt;&gt; error + fixit hint when it is the tuple splat form.  The migrator would<br>&gt;&gt;&gt; auto-apply the fixit hint as it does for other cases.<br>&gt;&gt;&gt; &lt;https://github.com/apple/swift-evolution#impact-on-existing-code&gt;Impact<br>&gt;&gt;&gt; on existing code<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Any code that uses this feature will have to move to the traditional<br>&gt;&gt;&gt; form.  In the case of the example above, this means rewriting the code from:<br>&gt;&gt;&gt; foo(x)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; into a form like this:<br>&gt;&gt;&gt; foo(x.0, x.b)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In the case where “x” is a complex expression, a temporary variable will<br>&gt;&gt;&gt; need to be introduced.  We believe that compiler fixits can handle the<br>&gt;&gt;&gt; simple cases directly and that this extension is not widely used.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &lt;https://github.com/apple/swift-evolution#alternatives-considered&gt;Alternatives<br>&gt;&gt;&gt; considered<br>&gt;&gt;&gt; The major problem with this feature is that it was not well considered<br>&gt;&gt;&gt; and implemented properly (owing to its very old age, it has just been kept<br>&gt;&gt;&gt; limping along).  The alternative then is to actually design a proper<br>&gt;&gt;&gt; feature to support this.  Since the implicitness and syntactic ambiguity<br>&gt;&gt;&gt; with normal function application is the problem, the solution is to<br>&gt;&gt;&gt; introduce an explicit syntactic form to represent this.  For example,<br>&gt;&gt;&gt; something like this could address the problems we have:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; foo(*x)    // NOT a serious syntax proposal<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; However, actually designing this feature would be a non-trivial effort<br>&gt;&gt;&gt; not core to the Swift 3 mission:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; * It is a pure-sugar feature, and therefore low priority.<br>&gt;&gt;&gt; * We don’t have an obvious sigil to use.  “prefix-star” should be kept<br>&gt;&gt;&gt; as unused for now in case we want to use it to refer to memory-related<br>&gt;&gt;&gt; operations in the future.<br>&gt;&gt;&gt; * Making the tuple splat operation great requires more than just fixing<br>&gt;&gt;&gt; the syntactic ambiguities we have, it would require re-evaluating the<br>&gt;&gt;&gt; semantics of the operation (e.g. in light of parameter labels, varargs and<br>&gt;&gt;&gt; other features).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If there is serious interest in pursuing this as a concept, we should do<br>&gt;&gt;&gt; it as a follow-on proposal to this one.  If a good design emerges, we can<br>&gt;&gt;&gt; evaluate that design based on its merits.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The final alternative is that we could leave the feature in the<br>&gt;&gt;&gt; compiler.  However, that means living with its complexity “forever” or<br>&gt;&gt;&gt; breaking code in the Swift 4 timeframe.  It would be preferable to tackle<br>&gt;&gt;&gt; this breakage in the Swift 3 timeframe, since we know that migration will<br>&gt;&gt;&gt; already be needed then.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p><p><br>-- <br>bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>http://www.bitcycle.com/<br>Phone: +46-73-753 24 62<br>E-mail: jens at bitcycle.com<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/7f01c7df/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: Remove implicit tuple splat behavior from function applications</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 27, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 26, 2016, at 11:44 PM, Jens Persson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; +-0. I saw, in my dreams, many &quot;different parts&quot; of the language, like pattern matching, function argument- &amp; parameter lists, and tuples, all just being one and the same simple yet powerful unifying concept ...<br>&gt; :´ /<br></p><p>I had that dream too, very early on in Swift development, but it isn’t practical for a very large number of reasons…<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d042be5dcfe90e649f760303af3e429?s=50"></div><header><strong>Proposal: Remove implicit tuple splat behavior from function applications</strong> from <string>Jens Persson</string> &lt;jens at bitcycle.com&gt;<p>January 28, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; +-0. I saw, in my dreams, many &quot;different parts&quot; of the language, like<br>pattern matching, function argument- &amp; parameter lists, and tuples, all<br>just being one and the same simple yet powerful unifying concept ...<br></p><p>&gt; &gt; :´ /<br>&gt;<br>&gt; I had that dream too, very early on in Swift development, but it isn’t<br>&gt; practical for a very large number of reasons…<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br>I guess you are right. But I&#39;ll take the opportunity to whine a bit anyway,<br>perhaps it might be worth something, coming from my idealistic<br>user/layman&#39;s perspective:<br></p><p>I feel as though the unifying-tuple-concept-dream could still come true, if<br>only:-) the whole thing was redesigned from scratch, with a stronger focus<br>on simplicity and consistency (the rules for argument/parameter lists,<br>parameter naming, tuple types, tuple element labels, pattern matching etc).<br></p><p>IMHO not being able to eg think of, and use, argument/parameter lists as<br>tuples/tuple types dumbs down and complicates the language, trading<br>expressibility for boilerplate and special-casing.<br></p><p>Yes, it seems like this aspect of the language are not wildly appreciated<br>and used. But that might be a chicken and egg problem, the current<br>inconsistencies might have been introduced/sustained/amplified by not<br>letting the unifying-tuple-concept place enough selection pressure in the<br>evolution of the language. And another reason might of course be slow<br>changing programming habits / adopting new concepts.<br></p><p>As I said, I know this is very naive and idealistic, but perhaps it can<br>play a small part in some pragmatic decision making.<br>/Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/44fd4304/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>Proposal: Remove implicit tuple splat behavior from function applications</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>January 28, 2016 at 12:00:00pm</p></header><div class="content"><p>My opinion closely matches Jens’s. I am very fond of the idea that functions are  just syntactically privileges forms of closures, which themselves are maps from tuples to tuples. Its elegant, explicit, clean and it avoids treating functions as compiler magic. I would like this notion to be even more explicit and I would like to see some tuple algebra that allows one to manipulate functions in a flexible, type-safe way. <br></p><p>I am not opposed to removal of tuple splat behaviour in its current form, but it would be a shame if such removal would signify that Swift is abandoning the path of formal elegance. Swift is already quite idiosyncratic, with magical bits and pieces all over the language, and I believe that one should aim to have a semantically consistent, lean language rather then a collection of loosely coupled devices with orthogonal semantics. <br></p><p>— Taras<br></p><p><br>&gt; On 28 Jan 2016, at 11:48, Jens Persson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; &gt; +-0. I saw, in my dreams, many &quot;different parts&quot; of the language, like pattern matching, function argument- &amp; parameter lists, and tuples, all just being one and the same simple yet powerful unifying concept ...<br>&gt; &gt; :´ /<br>&gt; <br>&gt; I had that dream too, very early on in Swift development, but it isn’t practical for a very large number of reasons…<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; <br>&gt; I guess you are right. But I&#39;ll take the opportunity to whine a bit anyway, perhaps it might be worth something, coming from my idealistic user/layman&#39;s perspective:<br>&gt; <br>&gt; I feel as though the unifying-tuple-concept-dream could still come true, if only:-) the whole thing was redesigned from scratch, with a stronger focus on simplicity and consistency (the rules for argument/parameter lists, parameter naming, tuple types, tuple element labels, pattern matching etc).<br>&gt; <br>&gt; IMHO not being able to eg think of, and use, argument/parameter lists as tuples/tuple types dumbs down and complicates the language, trading expressibility for boilerplate and special-casing.<br>&gt; <br>&gt; Yes, it seems like this aspect of the language are not wildly appreciated and used. But that might be a chicken and egg problem, the current inconsistencies might have been introduced/sustained/amplified by not letting the unifying-tuple-concept place enough selection pressure in the evolution of the language. And another reason might of course be slow changing programming habits / adopting new concepts.<br>&gt; <br>&gt; As I said, I know this is very naive and idealistic, but perhaps it can play a small part in some pragmatic decision making.<br>&gt; /Jens<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/809b743d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Proposal: Remove implicit tuple splat behavior from function applications</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>January 28, 2016 at 09:00:00pm</p></header><div class="content"><p>I hope the timing of the proposal is coincidence — I would feel really bad if I triggered the death of tuple splat ;-)<br></p><p>I strongly agree with Jens and Taras and would love to see &quot;Remove implicit&quot; replaced with &quot;Fix&quot;* in the headline:<br>There is no doubt that the feature in its current state has problems, but I think the concept in general isn&#39;t bad.<br>Imho it would be sad if nifty little helpers like tuple splat and currying disappear forever, just because their implementation has issues.<br></p><p>Besides the option of delayed execution, there could be other use cases we aren&#39;t aware of yet, either because the current APIs were designed without tuples (I really dislike the use of unsafe dictionaries for configuration of objects like NSPersistantStoreCoordinator), or because tiny pieces of functionality aren&#39;t available in the language.<br></p><p>Take forwarding of method arguments as an example:<br>There has been a proposal to introduce an extra construct for this, but with a tiny feature to retrieve the argument tuple, it could be as simple as<br></p><p>override func f(a: Int, b: Int, c: Int, d: Int, e: Int, f: Int, g: Int, h: Int, i: Int, j: Int) // ridiculous long parameter list to exaggerate usefulness ;-)<br>{<br>	// do some stuff<br>	if a &gt; 0 {<br>		#arguments.b += 1<br>	}<br>	super.f(#arguments)<br>}<br></p><p>Tino<br></p><p>* I wouldn&#39;t mind if fixing takes time and the feature is removed until it is polished ;-)<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: Remove implicit tuple splat behavior from function applications</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 28, 2016 at 10:00:00am</p></header><div class="content"><p>On Jan 28, 2016, at 2:48 AM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt; &gt; +-0. I saw, in my dreams, many &quot;different parts&quot; of the language, like pattern matching, function argument- &amp; parameter lists, and tuples, all just being one and the same simple yet powerful unifying concept ...<br>&gt; &gt; :´ /<br>&gt; <br>&gt; I had that dream too, very early on in Swift development, but it isn’t practical for a very large number of reasons…<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; <br>&gt; I guess you are right. But I&#39;ll take the opportunity to whine a bit anyway, perhaps it might be worth something, coming from my idealistic user/layman&#39;s perspective:<br>&gt; <br>&gt; I feel as though the unifying-tuple-concept-dream could still come true, if only:-) the whole thing was redesigned from scratch, with a stronger focus on simplicity and consistency (the rules for argument/parameter lists, parameter naming, tuple types, tuple element labels, pattern matching etc).<br>&gt; <br>&gt; IMHO not being able to eg think of, and use, argument/parameter lists as tuples/tuple types dumbs down and complicates the language, trading expressibility for boilerplate and special-casing.<br></p><p>As I mentioned, I agree with the general principle of eliminating special cases and having a single unifying principle.  Also, the original swift model was that parameter lists *were just tuples*.  We are still slowly digging the compiler out of that hole.<br></p><p>Functions “need” to have things like inout, variadics, default arguments, and other features that either don’t make sense at all (e.g. inout), or are marginally useful but had huge complexity to the user model (varargs and default args).<br></p><p>You’re right that a single unifying principle can be good, but there is a huge value in tuples being simple and self consistent with themselves without a ton of weird stuff hanging out on them just because functions need them.<br></p><p>&gt; Yes, it seems like this aspect of the language are not wildly appreciated and used.<br></p><p>Function parameters are widely used :-)<br></p><p>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/67e2747b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>Proposal: Remove implicit tuple splat behavior from function applications</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>January 29, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; Functions “need” to have things like inout, variadics, default arguments, and other features that either don’t make sense at all (e.g. inout), or are marginally useful but had huge complexity to the user model (varargs and default args).<br></p><p>In all honesty, I’d rather prefer inout  to go, and cases that absolutely need it (FFI) transparently replace inout arguments with multiple return values. I don’t see any issue with variadics and default arguments — they are quite useful features for a generic tuple type. But I understand if following this path is not what the Swift team intends to do and I respect that decision. Its formal elegance vs. pragmatism. Pragmatism is not a bad choice :) <br></p><p>— Taras<br></p><p>&gt; On 28 Jan 2016, at 19:18, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Jan 28, 2016, at 2:48 AM, Jens Persson &lt;jens at bitcycle.com &lt;mailto:jens at bitcycle.com&gt;&gt; wrote:<br>&gt;&gt; &gt; +-0. I saw, in my dreams, many &quot;different parts&quot; of the language, like pattern matching, function argument- &amp; parameter lists, and tuples, all just being one and the same simple yet powerful unifying concept ...<br>&gt;&gt; &gt; :´ /<br>&gt;&gt; <br>&gt;&gt; I had that dream too, very early on in Swift development, but it isn’t practical for a very large number of reasons…<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I guess you are right. But I&#39;ll take the opportunity to whine a bit anyway, perhaps it might be worth something, coming from my idealistic user/layman&#39;s perspective:<br>&gt;&gt; <br>&gt;&gt; I feel as though the unifying-tuple-concept-dream could still come true, if only:-) the whole thing was redesigned from scratch, with a stronger focus on simplicity and consistency (the rules for argument/parameter lists, parameter naming, tuple types, tuple element labels, pattern matching etc).<br>&gt;&gt; <br>&gt;&gt; IMHO not being able to eg think of, and use, argument/parameter lists as tuples/tuple types dumbs down and complicates the language, trading expressibility for boilerplate and special-casing.<br>&gt; <br>&gt; As I mentioned, I agree with the general principle of eliminating special cases and having a single unifying principle.  Also, the original swift model was that parameter lists *were just tuples*.  We are still slowly digging the compiler out of that hole.<br>&gt; <br>&gt; Functions “need” to have things like inout, variadics, default arguments, and other features that either don’t make sense at all (e.g. inout), or are marginally useful but had huge complexity to the user model (varargs and default args).<br>&gt; <br>&gt; You’re right that a single unifying principle can be good, but there is a huge value in tuples being simple and self consistent with themselves without a ton of weird stuff hanging out on them just because functions need them.<br>&gt; <br>&gt;&gt; Yes, it seems like this aspect of the language are not wildly appreciated and used. <br>&gt; <br>&gt; Function parameters are widely used :-)<br>&gt; <br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/1754a950/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Proposal: Remove implicit tuple splat behavior from function applications</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>January 27, 2016 at 01:00:00am</p></header><div class="content"><p>+1. I like consistency and predictability, and this would improve both of them.<br></p><p>Charles<br></p><p>&gt; On Jan 27, 2016, at 12:23 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; For discussion: comments appreciated!<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; Remove implicit tuple splat behavior from function applications<br>&gt; <br>&gt; Proposal: SE- &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;TBD<br>&gt; Author(s): Chris Lattner<br>&gt; Status: Awaiting review<br>&gt; Review manager: TBD<br>&gt;  &lt;https://github.com/apple/swift-evolution#introduction&gt;Introduction<br>&gt; <br>&gt; Function calls (which include several syntactic forms that apply an argument list to something of function type) currently have a dual nature in Swift.  Given something like:<br>&gt; <br>&gt; <br>&gt; 	func foo(a : Int, b : Int) {}<br>&gt; <br>&gt; <br>&gt; You can call it either with with the typical syntactic form that passes arguments to each of its parameters:<br>&gt; <br>&gt; <br>&gt; 	foo(42, b : 17)<br>&gt; <br>&gt; or you can take advantage of a little-known feature to pass an entire argument list as a single value (of tuple type):<br>&gt; <br>&gt; 	let x = (1, b: 2)<br>&gt; 	foo(x)<br>&gt; <br>&gt; <br>&gt; This proposal recommends removing the later form, which I affectionately refer to as the “tuple splat” form.  This feature is purely a sugar feature, it does not provide any expressive ability beyond passing the parameters manually.<br>&gt; <br>&gt; <br>&gt; Swift-evolution thread: TBD<br>&gt; <br>&gt;  &lt;https://github.com/apple/swift-evolution#motivation&gt;Motivation<br>&gt; <br>&gt; This behavior is cute, precedented in other functional languages, and has some advantages, but it also has several major disadvantages, which are all related to its syntactic form.<br>&gt; <br>&gt; * A call to foo(x) looks like a call to an overloaded version of foo, both to the compiler and to the human who maintains the code.  This is extremely confusing if you don’t know the feature exists.<br>&gt; * There are real ambiguities in the syntax, e.g. involving Any arguments and situations where you want to pass a tuple value as a single parameter.<br>&gt; * The current implementation has a ton of implementation bugs - it doesn’t work reliably.<br>&gt; * The current implementation adds complexity to the type checker, slowing it down and adding maintenance burden.<br>&gt; * The current implementation doesn’t work the way we would want a tuple splat operation to work.  For example, arguably, you should be able to call foo with:<br>&gt; <br>&gt; 	func bar() -&gt; (Int, Int) { … }<br>&gt; 	foo(bar())<br>&gt; <br>&gt; … but this is not allowed, since tuple labels are required to line up.  You have to write:<br>&gt; <br>&gt; <br>&gt; <br>&gt; 	func bar() -&gt; (Int, b: Int)  { … }<br>&gt; 	foo(bar())<br>&gt; <br>&gt; <br>&gt; This makes this feature very difficult to use in practice, because you have to _’ize a lot of parameters (violating naming conventions), perform manual shuffling (defeating the sugar benefits of the feature), or add parameter labels to the result of functions (which leads to odd tying between callers and callees).<br>&gt; <br>&gt; <br>&gt; The root problem here is that we use exactly the same syntax for both forms of function application.  If the two forms were differentiated (an option considered in “alternatives considered” below) then some of these problems would be defined away.<br>&gt; <br>&gt; From a historical perspective, the tuple splat form of function application dates back to very early Swift design (probably introduced in 2010, but possibly 2011) where all function application was of a single value to a function type.  For a large number of reasons (including default arguments, variadic arguments, labels, etc) we have completely abandoned this model, but we never came back to reevaluating the tuple splat behavior.<br>&gt; <br>&gt; If we didn’t already have this feature, we would not add it to Swift 3 (at least in its current form).<br>&gt; <br>&gt;  &lt;https://github.com/apple/swift-evolution#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt; The proposed solution is simple, we should just remove this feature from the Swift 3 compiler.  Ideally we would deprecate it in the Swift 2.2 compiler and remove it in Swift 3.  However, if there isn’t time to get the deprecation into Swift 2.2, the author believes it would be perfectly fine to just remove it in Swift 3 (with a fixit + migration help of course).<br>&gt; <br>&gt; One of the interesting aspect of this feature is that some of the people we’ve spoken to are very fond of it.  However, when pressed, they admit that they are not actually using it widely in their code, or if they are using it, they are abusing naming conventions (distorting their code) in order to use it.  This doesn’t seem like a positive contribution - this seems like a “clever” feature, not a practical one.<br>&gt; <br>&gt;  &lt;https://github.com/apple/swift-evolution#detailed-design&gt;Detailed design<br>&gt; <br>&gt; The design is straight-forward.  In the Swift 3 time frame, we continue to parse and type check these expressions as we have so far, but produce an error + fixit hint when it is the tuple splat form.  The migrator would auto-apply the fixit hint as it does for other cases.<br>&gt; <br>&gt;  &lt;https://github.com/apple/swift-evolution#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; Any code that uses this feature will have to move to the traditional form.  In the case of the example above, this means rewriting the code from:<br>&gt; <br>&gt; 	foo(x)<br>&gt; <br>&gt; into a form like this:<br>&gt; <br>&gt; 	foo(x.0, x.b)<br>&gt; <br>&gt; In the case where “x” is a complex expression, a temporary variable will need to be introduced.  We believe that compiler fixits can handle the simple cases directly and that this extension is not widely used.<br>&gt; <br>&gt;  &lt;https://github.com/apple/swift-evolution#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt; The major problem with this feature is that it was not well considered and implemented properly (owing to its very old age, it has just been kept limping along).  The alternative then is to actually design a proper feature to support this.  Since the implicitness and syntactic ambiguity with normal function application is the problem, the solution is to introduce an explicit syntactic form to represent this.  For example, something like this could address the problems we have:<br>&gt; <br>&gt; 	foo(*x)    // NOT a serious syntax proposal<br>&gt; <br>&gt; However, actually designing this feature would be a non-trivial effort not core to the Swift 3 mission:<br>&gt; <br>&gt; * It is a pure-sugar feature, and therefore low priority.<br>&gt; * We don’t have an obvious sigil to use.  “prefix-star” should be kept as unused for now in case we want to use it to refer to memory-related operations in the future.<br>&gt; * Making the tuple splat operation great requires more than just fixing the syntactic ambiguities we have, it would require re-evaluating the semantics of the operation (e.g. in light of parameter labels, varargs and other features).<br>&gt; <br>&gt; If there is serious interest in pursuing this as a concept, we should do it as a follow-on proposal to this one.  If a good design emerges, we can evaluate that design based on its merits.<br>&gt; <br>&gt; <br>&gt; The final alternative is that we could leave the feature in the compiler.  However, that means living with its complexity “forever” or breaking code in the Swift 4 timeframe.  It would be preferable to tackle this breakage in the Swift 3 timeframe, since we know that migration will already be needed then.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/8a7f8836/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b8fbb69a582e03b56bd4c125aef9e3f?s=50"></div><header><strong>Proposal: Remove implicit tuple splat behavior from function applications</strong> from <string>Haravikk</string> &lt;e-mail at haravikk.me&gt;<p>January 27, 2016 at 10:00:00am</p></header><div class="content"><p>+1 from me as well; if someone needs this they can just use a closure to perform the conversion. This is probably a better way to present it anyway since it makes it clearer since this is presumably what is happening behind the scenes anyway.<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: smime.p7s<br>Type: application/pkcs7-signature<br>Size: 2475 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/cabb0833/attachment.p7s&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Proposal: Remove implicit tuple splat behavior from function applications</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>January 27, 2016 at 03:00:00am</p></header><div class="content"><p>I used this just last week! But only as an illustration<br></p><p>+1<br></p><p>One comment though, a splat operator need not be purely syntactic sugar - it could be the way arrays are applied to variadic functions.<br></p><p>-DW<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/02b3e471050a20a8e94732823c238cdf?s=50"></div><header><strong>Proposal: Remove implicit tuple splat behavior from function applications</strong> from <string>Nisse Bergman</string> &lt;nisse at potmo.com&gt;<p>January 27, 2016 at 11:00:00am</p></header><div class="content"><p>-1 I use this in both my mocking API and in JSON deserialising/serializing.<br>I think this is a great thing to have<br></p><p><br>&gt; On 27 Jan 2016, at 11:07, David Waite via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I used this just last week! But only as an illustration<br>&gt; <br>&gt; +1<br>&gt; <br>&gt; One comment though, a splat operator need not be purely syntactic sugar - it could be the way arrays are applied to variadic functions.<br>&gt; <br>&gt; -DW<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: Remove implicit tuple splat behavior from function applications</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 27, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 27, 2016, at 4:18 AM, Nisse Bergman via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; -1 I use this in both my mocking API and in JSON deserialising/serializing.<br>&gt; I think this is a great thing to have<br></p><p>It would be great to have an explicit, well-designed version of this.  Nobody is arguing against that.  But there are quite a few problems with its current form.<br></p><p>&gt; <br>&gt; <br>&gt;&gt; On 27 Jan 2016, at 11:07, David Waite via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I used this just last week! But only as an illustration<br>&gt;&gt; <br>&gt;&gt; +1<br>&gt;&gt; <br>&gt;&gt; One comment though, a splat operator need not be purely syntactic sugar - it could be the way arrays are applied to variadic functions.<br>&gt;&gt; <br>&gt;&gt; -DW<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>Proposal: Remove implicit tuple splat behavior from function applications</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>January 27, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jan 27, 2016, at 10:48 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 27, 2016, at 4:18 AM, Nisse Bergman via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; -1 I use this in both my mocking API and in JSON deserialising/serializing.<br>&gt;&gt; I think this is a great thing to have<br>&gt; <br>&gt; It would be great to have an explicit, well-designed version of this.  Nobody is arguing against that.  But there are quite a few problems with its current form.<br></p><p>+1, exactly this.<br></p><p>I also have tried to use the implicit form for similar purposes but it’s IMHO too wonky to rely on; I’d rather see it removed, and a well-thought-through explicit form (eventually) introduced (perhaps as part of broader compiler support for tuple-manipulation).<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 27 Jan 2016, at 11:07, David Waite via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I used this just last week! But only as an illustration<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +1<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One comment though, a splat operator need not be purely syntactic sugar - it could be the way arrays are applied to variadic functions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -DW<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/6eeee106/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Proposal: Remove implicit tuple splat behavior from function applications</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>January 27, 2016 at 09:00:00am</p></header><div class="content"><p>Fair enough. Can we get an explicit, well-designed version of this before we get rid of the implicit, poorly-designed version?<br></p><p>I can’t recall off the top my head where, but I know I’ve done something like this:<br>struct FunctionApplicator &lt;T, U&gt; {<br>    var args: T<br>    let function: T -&gt; U<br>    init(args: T, function: T -&gt; U) {<br>        self.args = args<br>        self.function = function<br>    }<br>    func apply() -&gt; U {<br>        return function(args)<br>    }<br>}<br></p><p>Without tuple splatting, you’d need a FunctionApplicator1&lt;T,U&gt;, FunctionApplicator2&lt;T,U,V&gt;, FunctionApplicator3&lt;T,U,V,W&gt;, etc. They can’t even have the same name because Swift doesn’t support overloading type names for types with a different number of generic parameters.<br></p><p>- Dave Sweeris<br></p><p>&gt; On Jan 27, 2016, at 08:48, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 27, 2016, at 4:18 AM, Nisse Bergman via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; -1 I use this in both my mocking API and in JSON deserialising/serializing.<br>&gt;&gt; I think this is a great thing to have<br>&gt; <br>&gt; It would be great to have an explicit, well-designed version of this.  Nobody is arguing against that.  But there are quite a few problems with its current form.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/4819d4f3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: Remove implicit tuple splat behavior from function applications</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 27, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 27, 2016, at 9:27 AM, Dave via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Fair enough. Can we get an explicit, well-designed version of this before we get rid of the implicit, poorly-designed version?<br></p><p>I’m certainly not opposed to someone exploring this, but I don’t think it should block removing the bad thing.<br></p><p>&gt; I can’t recall off the top my head where, but I know I’ve done something like this:<br>&gt; struct FunctionApplicator &lt;T, U&gt; {<br>&gt;     var args: T<br>&gt;     let function: T -&gt; U<br>&gt;     init(args: T, function: T -&gt; U) {<br>&gt;         self.args = args<br>&gt;         self.function = function<br>&gt;     }<br>&gt;     func apply() -&gt; U {<br>&gt;         return function(args)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; Without tuple splatting, you’d need a FunctionApplicator1&lt;T,U&gt;, FunctionApplicator2&lt;T,U,V&gt;, FunctionApplicator3&lt;T,U,V,W&gt;, etc. They can’t even have the same name because Swift doesn’t support overloading type names for types with a different number of generic parameters.<br></p><p>Perhaps I’m misunderstanding, but that is certainly not the case.  Even without the feature in question you can definitely pass a tuple around as a single argument, e.g.:<br></p><p>func f(a : Int, _ b : Int) {…}<br></p><p>let x = FunctionApplicator((42, b: 19), f)<br></p><p>This functionality won’t be affected by removal of this feature.<br></p><p>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/b6f899e3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Proposal: Remove implicit tuple splat behavior from function applications</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>January 27, 2016 at 10:00:00am</p></header><div class="content"><p>&lt;scratches head&gt; Then I’ve misunderstood what splatting was. Is the difference between splatting and what my example does the arguments’ labels?<br>func f(a : Int, _ b : Int) {…}<br>let x = FunctionApplicator((42, b: 19), f) //Would stay legal, because of the &quot;b:&quot;<br>let y = FunctionApplicator((42, 19), f)    //Would become illegal, because there’s no “b:”<br></p><p>And we would have to use the internal argument labels? If so, how would that work with functions in 3rd-party libraries, where we might not have access to that information?<br></p><p>- Dave Sweeris<br></p><p>&gt; On Jan 27, 2016, at 10:21, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 27, 2016, at 9:27 AM, Dave via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Fair enough. Can we get an explicit, well-designed version of this before we get rid of the implicit, poorly-designed version?<br>&gt; <br>&gt; I’m certainly not opposed to someone exploring this, but I don’t think it should block removing the bad thing.<br>&gt; <br>&gt;&gt; I can’t recall off the top my head where, but I know I’ve done something like this:<br>&gt;&gt; struct FunctionApplicator &lt;T, U&gt; {<br>&gt;&gt;     var args: T<br>&gt;&gt;     let function: T -&gt; U<br>&gt;&gt;     init(args: T, function: T -&gt; U) {<br>&gt;&gt;         self.args = args<br>&gt;&gt;         self.function = function<br>&gt;&gt;     }<br>&gt;&gt;     func apply() -&gt; U {<br>&gt;&gt;         return function(args)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Without tuple splatting, you’d need a FunctionApplicator1&lt;T,U&gt;, FunctionApplicator2&lt;T,U,V&gt;, FunctionApplicator3&lt;T,U,V,W&gt;, etc. They can’t even have the same name because Swift doesn’t support overloading type names for types with a different number of generic parameters.<br>&gt; <br>&gt; Perhaps I’m misunderstanding, but that is certainly not the case.  Even without the feature in question you can definitely pass a tuple around as a single argument, e.g.:<br>&gt; <br>&gt; func f(a : Int, _ b : Int) {…}<br>&gt; <br>&gt; let x = FunctionApplicator((42, b: 19), f)<br>&gt; <br>&gt; This functionality won’t be affected by removal of this feature.<br>&gt; <br>&gt; -Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/2d8ce3ef/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: Remove implicit tuple splat behavior from function applications</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 27, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 27, 2016, at 10:46 AM, davesweeris at mac.com wrote:<br>&gt; <br>&gt; &lt;scratches head&gt; Then I’ve misunderstood what splatting was. Is the difference between splatting and what my example does the arguments’ labels?<br>&gt; func f(a : Int, _ b : Int) {…}<br>&gt; let x = FunctionApplicator((42, b: 19), f) //Would stay legal, because of the &quot;b:&quot;<br>&gt; let y = FunctionApplicator((42, 19), f)    //Would become illegal, because there’s no “b:”<br></p><p>There is no change to either of these.  The later example succeed because of an implicit conversion from &quot;(T,U) -&gt; (T, b: U)”, which is an entirely separate thing.<br></p><p>The tuple splat behavior I’m talking about can *only* affect call sites that take a single argument.  Both of these examples take two.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/cd079928/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e70505f1dd2dfb47c6d53d83492f3bdd?s=50"></div><header><strong>Proposal: Remove implicit tuple splat behavior from function applications</strong> from <string>Christopher Whidden</string> &lt;christopher.whidden at gmail.com&gt;<p>January 27, 2016 at 02:00:00pm</p></header><div class="content"><p>On Jan 27, 2016, at 12:53 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 27, 2016, at 10:46 AM, davesweeris at mac.com &lt;mailto:davesweeris at mac.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &lt;scratches head&gt; Then I’ve misunderstood what splatting was. Is the difference between splatting and what my example does the arguments’ labels?<br>&gt;&gt; func f(a : Int, _ b : Int) {…}<br>&gt;&gt; let x = FunctionApplicator((42, b: 19), f) //Would stay legal, because of the &quot;b:&quot;<br>&gt;&gt; let y = FunctionApplicator((42, 19), f)    //Would become illegal, because there’s no “b:”<br>&gt; <br>&gt; There is no change to either of these.  The later example succeed because of an implicit conversion from &quot;(T,U) -&gt; (T, b: U)”, which is an entirely separate thing.<br>&gt; <br>&gt; The tuple splat behavior I’m talking about can *only* affect call sites that take a single argument.  Both of these examples take two.<br>&gt; <br>&gt; -Chris<br></p><p><br>I thought Dave had a good point with his first generics example before, but don’t understand what the point was with labeling that he makes above.  However, there is a call site that takes a single argument in his example:<br>func apply() -&gt; U {<br>    return function(args)<br>}<br></p><p>Where args could be a tuple of type T.<br></p><p>I just want to be clear on this.  I’ll put the question a bit more succinctly.  Wouldn’t this functionality be eliminated with the removal of tuple splatting?<br></p><p>func execute&lt;T,U&gt;(f: T-&gt;U, args: T) -&gt; U {<br>    return f(args)<br>}<br>execute({$0+1}, args: 5) // Single arg<br>//6<br>execute(*, args: (5,5)) // Tuple arg<br>//25<br></p><p>In this generic function, args can be either a single argument *or* a tuple of arguments that gets applied to the function.<br></p><p>Having said that, I’m not sure what the real use cases or practical value of this is.  Perhaps like a lot of people, I thought Swift’s features like function currying and tuple splatting were *cool* but in reality never used them.  Although I think the generics context is something to consider, I still give the proposal +1.  Tuple splatting looks to be a feature that can’t pull its own weight and has downsides because of syntactic ambiguity.<br></p><p><br>-Chris Whidden<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/32e58086/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76eb9711d45c1c9a71c0f24004072a22?s=50"></div><header><strong>Proposal: Remove implicit tuple splat behavior from function applications</strong> from <string>Zach Waldowski</string> &lt;zach at waldowski.me&gt;<p>January 27, 2016 at 04:00:00pm</p></header><div class="content"><p>I agree. I&#39;m +1 for the proposal, but it should be possible for a T to<br>resolve to an arguments-list type tuple. As I don&#39;t often think like a<br>compiler, I don&#39;t know if that would be made harder or easier as a<br>result of this proposal.<br></p><p>Zachary Waldowski zach at waldowski.me<br></p><p><br>On Wed, Jan 27, 2016, at 12:27 PM, Dave via swift-evolution wrote:<br>&gt; Fair enough. Can we get an explicit, well-designed version of this<br>&gt; before we get rid of the implicit, poorly-designed version?<br>&gt;<br>&gt; I can’t recall off the top my head where, but I *know* I’ve done<br>&gt; something like this: struct FunctionApplicator &lt;T, U&gt; { var args: T<br>&gt; let function: T -&gt; U init(args: T, function: T -&gt; U) { self.args =<br>&gt; args self.function = function    } func apply() -&gt; U {<br>&gt; returnfunction(args)    } }<br>&gt;<br>&gt; Without tuple splatting, you’d need a FunctionApplicator1&lt;T,U&gt;,<br>&gt; FunctionApplicator2&lt;T,U,V&gt;, FunctionApplicator3&lt;T,U,V,W&gt;, etc. They<br>&gt; can’t even have the same name because Swift doesn’t support<br>&gt; overloading type names for types with a different number of generic<br>&gt; parameters.<br>&gt;<br>&gt; - Dave Sweeris<br>&gt;<br>&gt;&gt; On Jan 27, 2016, at 08:48, Matthew Johnson via swift-evolution &lt;swift-<br>&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Jan 27, 2016, at 4:18 AM, Nisse Bergman via swift-evolution &lt;swift-<br>&gt;&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -1 I use this in both my mocking API and in JSON<br>&gt;&gt;&gt; deserialising/serializing. I think this is a great thing to have<br>&gt;&gt;<br>&gt;&gt; It would be great to have an explicit, well-designed version of this.<br>&gt;&gt; Nobody is arguing against that.  But there are quite a few problems<br>&gt;&gt; with its current form.<br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/0d859d5f/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Proposal: Remove implicit tuple splat behavior from function applications</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>January 27, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jan 27, 2016, at 2:18 , Nisse Bergman via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; -1 I use this in both my mocking API and in JSON deserialising/serializing.<br>&gt; I think this is a great thing to have<br></p><p>Hi, Nisse. Since most responses on the thread have been +1s, would you mind going into a bit more detail here? It&#39;s important to see real-world use cases for a feature, and it may help convince others.<br></p><p>Thanks,<br>Jordan<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: Remove implicit tuple splat behavior from function applications</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 27, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 27, 2016, at 2:18 AM, Nisse Bergman &lt;nisse at potmo.com&gt; wrote:<br>&gt; <br>&gt; -1 I use this in both my mocking API and in JSON deserialising/serializing.<br>&gt; I think this is a great thing to have.<br></p><p>Ok, I’m definitely interested in knowing more.  Please include a code sample, showing both the declaration being splatted into and the call sites.  Otherwise, I can’t tell how much value this feature is adding, and what the pain would be if it were removed.  Thanks!<br></p><p>-Chris<br></p><p><br>&gt; <br></p><p>&gt; <br>&gt;&gt; On 27 Jan 2016, at 11:07, David Waite via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I used this just last week! But only as an illustration<br>&gt;&gt; <br>&gt;&gt; +1<br>&gt;&gt; <br>&gt;&gt; One comment though, a splat operator need not be purely syntactic sugar - it could be the way arrays are applied to variadic functions.<br>&gt;&gt; <br>&gt;&gt; -DW<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d1bff9080a4237cc9b79c5751afb6f7?s=50"></div><header><strong>Proposal: Remove implicit tuple splat behavior from function applications</strong> from <string>Jarod Long</string> &lt;swift at lng.la&gt;<p>January 27, 2016 at 11:00:00am</p></header><div class="content"><p>I&#39;m +1 if this will eventually be replaced with a better-designed version, but I do use it and would be sad to see it go. I&#39;ve found it very helpful for testing:<br></p><p>protocol APIType {<br>    func getChatMessages(channel channel: ChatChannel, limit: Int, success: (chatMessages: [ChatMessage]) -&gt; Void, failure: (error: NSError) -&gt; Void)<br>}<br></p><p>class FakeAPI: APIType {<br>    var getChatMessagesEndpoint = FakeAPIEndpoint(<br>        calls:        [(channel: ChatChannel, limit: Int)](),<br>        successStubs: [[ChatMessage]](),<br>        failureStubs: [NSError]()<br>    )<br>    <br>    func getChatMessages(channel channel: ChatChannel, limit: Int, success: (chatMessages: [ChatMessage]) -&gt; Void, failure: (error: NSError) -&gt; Void) {<br>        getChatMessagesEndpoint.handleCall(success, failure, callParams: (channel: channel, limit: limit))<br>    }<br>}<br></p><p>struct FakeAPIEndpoint&lt;CallParams, SuccessParams, FailureParams&gt; {<br>    private(set) var calls:        [CallParams]<br>    private(set) var successStubs: [SuccessParams]<br>    private(set) var failureStubs: [FailureParams]<br>    <br>    mutating func stubSuccess(params: SuccessParams) {<br>        successStubs.append(params)<br>    }<br>    <br>    mutating func stubFailure(params: FailureParams) {<br>        failureStubs.append(params)<br>    }<br>    <br>    private mutating func handleCall(success: (SuccessParams) -&gt; Void, _ failure: (FailureParams) -&gt; Void, call: CallParams) {<br>        calls.append(call)<br>        <br>        if successStubs.count &gt; 0 {<br>            success(successStubs.removeFirst())<br>        }<br>        else if failureStubs.count &gt; 0 {<br>            failure(failureStubs.removeFirst())<br>        }<br>    }<br>}<br></p><p>It&#39;s really nice to have that handleCall method that can call the success or failure callback automatically rather than reimplementing that functionality in every fake API call.<br></p><p>Jarod<br></p><p>&gt; On Jan 27, 2016, at 10:16, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 27, 2016, at 2:18 AM, Nisse Bergman &lt;nisse at potmo.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; -1 I use this in both my mocking API and in JSON deserialising/serializing.<br>&gt;&gt; I think this is a great thing to have.<br>&gt; <br>&gt; Ok, I’m definitely interested in knowing more.  Please include a code sample, showing both the declaration being splatted into and the call sites.  Otherwise, I can’t tell how much value this feature is adding, and what the pain would be if it were removed.  Thanks!<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 27 Jan 2016, at 11:07, David Waite via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I used this just last week! But only as an illustration<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +1<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One comment though, a splat operator need not be purely syntactic sugar - it could be the way arrays are applied to variadic functions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -DW<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/8e0d092a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: Remove implicit tuple splat behavior from function applications</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 27, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jan 27, 2016, at 11:03 AM, swift at lng.la wrote:<br>&gt; <br>&gt; I&#39;m +1 if this will eventually be replaced with a better-designed version, but I do use it and would be sad to see it go. I&#39;ve found it very helpful for testing:<br></p><p>Hi Jarod, where are you using this feature?<br></p><p>&gt; <br>&gt; protocol APIType {<br>&gt;     func getChatMessages(channel channel: ChatChannel, limit: Int, success: (chatMessages: [ChatMessage]) -&gt; Void, failure: (error: NSError) -&gt; Void)<br>&gt; }<br>&gt; <br>&gt; class FakeAPI: APIType {<br>&gt;     var getChatMessagesEndpoint = FakeAPIEndpoint(<br>&gt;         calls:        [(channel: ChatChannel, limit: Int)](),<br>&gt;         successStubs: [[ChatMessage]](),<br>&gt;         failureStubs: [NSError]()<br>&gt;     )<br>&gt;     <br>&gt;     func getChatMessages(channel channel: ChatChannel, limit: Int, success: (chatMessages: [ChatMessage]) -&gt; Void, failure: (error: NSError) -&gt; Void) {<br>&gt;         getChatMessagesEndpoint.handleCall(success, failure, callParams: (channel: channel, limit: limit))<br></p><p>If you are referring to this line, then there is no change.  The only affected case is in call sites that take a single parameter without a label.  Passing tuples as values will not be change.<br></p><p>-Chris<br></p><p><br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; struct FakeAPIEndpoint&lt;CallParams, SuccessParams, FailureParams&gt; {<br>&gt;     private(set) var calls:        [CallParams]<br>&gt;     private(set) var successStubs: [SuccessParams]<br>&gt;     private(set) var failureStubs: [FailureParams]<br>&gt;     <br>&gt;     mutating func stubSuccess(params: SuccessParams) {<br>&gt;         successStubs.append(params)<br>&gt;     }<br>&gt;     <br>&gt;     mutating func stubFailure(params: FailureParams) {<br>&gt;         failureStubs.append(params)<br>&gt;     }<br>&gt;     <br>&gt;     private mutating func handleCall(success: (SuccessParams) -&gt; Void, _ failure: (FailureParams) -&gt; Void, call: CallParams) {<br>&gt;         calls.append(call)<br>&gt;         <br>&gt;         if successStubs.count &gt; 0 {<br>&gt;             success(successStubs.removeFirst())<br>&gt;         }<br>&gt;         else if failureStubs.count &gt; 0 {<br>&gt;             failure(failureStubs.removeFirst())<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; It&#39;s really nice to have that handleCall method that can call the success or failure callback automatically rather than reimplementing that functionality in every fake API call.<br>&gt; <br>&gt; Jarod<br>&gt; <br>&gt;&gt; On Jan 27, 2016, at 10:16, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 27, 2016, at 2:18 AM, Nisse Bergman &lt;nisse at potmo.com &lt;mailto:nisse at potmo.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -1 I use this in both my mocking API and in JSON deserialising/serializing.<br>&gt;&gt;&gt; I think this is a great thing to have.<br>&gt;&gt; <br>&gt;&gt; Ok, I’m definitely interested in knowing more.  Please include a code sample, showing both the declaration being splatted into and the call sites.  Otherwise, I can’t tell how much value this feature is adding, and what the pain would be if it were removed.  Thanks!<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 27 Jan 2016, at 11:07, David Waite via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I used this just last week! But only as an illustration<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; +1<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One comment though, a splat operator need not be purely syntactic sugar - it could be the way arrays are applied to variadic functions.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -DW<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/bce37196/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d1bff9080a4237cc9b79c5751afb6f7?s=50"></div><header><strong>Proposal: Remove implicit tuple splat behavior from function applications</strong> from <string>Jarod Long</string> &lt;swift at lng.la&gt;<p>January 27, 2016 at 11:00:00am</p></header><div class="content"><p>Apologies -- I just realized I chose a bad example that isn&#39;t actually using the feature, but the usage would be here:<br></p><p>if successStubs.count &gt; 0 {<br>    success(successStubs.removeFirst())<br>}<br>else if failureStubs.count &gt; 0 {<br>    failure(failureStubs.removeFirst())<br>}<br></p><p>Here&#39;s a quick modification of the example that would necessitate using the feature:<br></p><p>var getChatMessagesEndpoint = FakeAPIEndpoint(<br>    calls:        [(channel: ChatChannel, limit: Int)](),<br>    successStubs: [(messages: [ChatMessage], someOtherReturnValue: Int)](),<br>    failureStubs: [(error: NSError, status: Int)]()<br>)<br></p><p>Unless I&#39;ve overlooked something, when the success and failure callbacks take multiple parameters, calling them in a generic way requires the use of tuple splatting.<br></p><p>Jarod<br></p><p>&gt; On Jan 27, 2016, at 11:10, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 27, 2016, at 11:03 AM, swift at lng.la &lt;mailto:swift at lng.la&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;m +1 if this will eventually be replaced with a better-designed version, but I do use it and would be sad to see it go. I&#39;ve found it very helpful for testing:<br>&gt; <br>&gt; Hi Jarod, where are you using this feature?<br>&gt; <br>&gt;&gt; <br>&gt;&gt; protocol APIType {<br>&gt;&gt;     func getChatMessages(channel channel: ChatChannel, limit: Int, success: (chatMessages: [ChatMessage]) -&gt; Void, failure: (error: NSError) -&gt; Void)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class FakeAPI: APIType {<br>&gt;&gt;     var getChatMessagesEndpoint = FakeAPIEndpoint(<br>&gt;&gt;         calls:        [(channel: ChatChannel, limit: Int)](),<br>&gt;&gt;         successStubs: [[ChatMessage]](),<br>&gt;&gt;         failureStubs: [NSError]()<br>&gt;&gt;     )<br>&gt;&gt;     <br>&gt;&gt;     func getChatMessages(channel channel: ChatChannel, limit: Int, success: (chatMessages: [ChatMessage]) -&gt; Void, failure: (error: NSError) -&gt; Void) {<br>&gt;&gt;         getChatMessagesEndpoint.handleCall(success, failure, callParams: (channel: channel, limit: limit))<br>&gt; <br>&gt; If you are referring to this line, then there is no change.  The only affected case is in call sites that take a single parameter without a label.  Passing tuples as values will not be change.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; <br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct FakeAPIEndpoint&lt;CallParams, SuccessParams, FailureParams&gt; {<br>&gt;&gt;     private(set) var calls:        [CallParams]<br>&gt;&gt;     private(set) var successStubs: [SuccessParams]<br>&gt;&gt;     private(set) var failureStubs: [FailureParams]<br>&gt;&gt;     <br>&gt;&gt;     mutating func stubSuccess(params: SuccessParams) {<br>&gt;&gt;         successStubs.append(params)<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     mutating func stubFailure(params: FailureParams) {<br>&gt;&gt;         failureStubs.append(params)<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     private mutating func handleCall(success: (SuccessParams) -&gt; Void, _ failure: (FailureParams) -&gt; Void, call: CallParams) {<br>&gt;&gt;         calls.append(call)<br>&gt;&gt;         <br>&gt;&gt;         if successStubs.count &gt; 0 {<br>&gt;&gt;             success(successStubs.removeFirst())<br>&gt;&gt;         }<br>&gt;&gt;         else if failureStubs.count &gt; 0 {<br>&gt;&gt;             failure(failureStubs.removeFirst())<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; It&#39;s really nice to have that handleCall method that can call the success or failure callback automatically rather than reimplementing that functionality in every fake API call.<br>&gt;&gt; <br>&gt;&gt; Jarod<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 27, 2016, at 10:16, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 27, 2016, at 2:18 AM, Nisse Bergman &lt;nisse at potmo.com &lt;mailto:nisse at potmo.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -1 I use this in both my mocking API and in JSON deserialising/serializing.<br>&gt;&gt;&gt;&gt; I think this is a great thing to have.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Ok, I’m definitely interested in knowing more.  Please include a code sample, showing both the declaration being splatted into and the call sites.  Otherwise, I can’t tell how much value this feature is adding, and what the pain would be if it were removed.  Thanks!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 27 Jan 2016, at 11:07, David Waite via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I used this just last week! But only as an illustration<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; +1<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; One comment though, a splat operator need not be purely syntactic sugar - it could be the way arrays are applied to variadic functions.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -DW<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/bcdae87f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: Remove implicit tuple splat behavior from function applications</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 27, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jan 27, 2016, at 11:24 AM, swift at lng.la wrote:<br>&gt; <br>&gt; Apologies -- I just realized I chose a bad example that isn&#39;t actually using the feature, but the usage would be here:<br>&gt; <br>&gt; if successStubs.count &gt; 0 {<br>&gt;     success(successStubs.removeFirst())<br>&gt; }<br>&gt; else if failureStubs.count &gt; 0 {<br>&gt;     failure(failureStubs.removeFirst())<br>&gt; }<br></p><p>This isn’t using the feature either.  You are passing a single value (returned by removeFirst) as a single argument.  No spat is happening.<br></p><p>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/62533a0a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d1bff9080a4237cc9b79c5751afb6f7?s=50"></div><header><strong>Proposal: Remove implicit tuple splat behavior from function applications</strong> from <string>Jarod Long</string> &lt;swift at lng.la&gt;<p>January 27, 2016 at 11:00:00am</p></header><div class="content"><p>But failure in this case is a function that takes two arguments, and failureStubs is an array of tuples that map to that function&#39;s arguments. How do the tuple values get mapped to the arguments if not via tuple splatting?<br></p><p>Jarod<br></p><p>&gt; On Jan 27, 2016, at 11:28, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 27, 2016, at 11:24 AM, swift at lng.la &lt;mailto:swift at lng.la&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Apologies -- I just realized I chose a bad example that isn&#39;t actually using the feature, but the usage would be here:<br>&gt;&gt; <br>&gt;&gt; if successStubs.count &gt; 0 {<br>&gt;&gt;     success(successStubs.removeFirst())<br>&gt;&gt; }<br>&gt;&gt; else if failureStubs.count &gt; 0 {<br>&gt;&gt;     failure(failureStubs.removeFirst())<br>&gt;&gt; }<br>&gt; <br>&gt; This isn’t using the feature either.  You are passing a single value (returned by removeFirst) as a single argument.  No spat is happening.<br>&gt; <br>&gt; -Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/04901371/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: Remove implicit tuple splat behavior from function applications</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 27, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jan 27, 2016, at 11:32 AM, Jarod Long &lt;swift at lng.la&gt; wrote:<br>&gt; <br>&gt; But failure in this case is a function that takes two arguments, and failureStubs is an array of tuples that map to that function&#39;s arguments. How do the tuple values get mapped to the arguments if not via tuple splatting?<br></p><p>Ah ok, I was looking at the success case I guess.  You’re right.  In this case, instead of :<br></p><p>    failure(failureStubs.removeFirst())<br></p><p>you’d have to write something like this:<br></p><p>    let tmp = failureStubs.removeFirst()<br>    failure(tmp.0, tmp.1)<br></p><p>-Chris<br></p><p>&gt; <br>&gt; Jarod<br>&gt; <br>&gt;&gt; On Jan 27, 2016, at 11:28, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 27, 2016, at 11:24 AM, swift at lng.la &lt;mailto:swift at lng.la&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Apologies -- I just realized I chose a bad example that isn&#39;t actually using the feature, but the usage would be here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; if successStubs.count &gt; 0 {<br>&gt;&gt;&gt;     success(successStubs.removeFirst())<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; else if failureStubs.count &gt; 0 {<br>&gt;&gt;&gt;     failure(failureStubs.removeFirst())<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This isn’t using the feature either.  You are passing a single value (returned by removeFirst) as a single argument.  No spat is happening.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/37115eda/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d1bff9080a4237cc9b79c5751afb6f7?s=50"></div><header><strong>Proposal: Remove implicit tuple splat behavior from function applications</strong> from <string>Jarod Long</string> &lt;swift at lng.la&gt;<p>January 27, 2016 at 12:00:00pm</p></header><div class="content"><p>In the simple case that&#39;s a reasonable alternative, but in this case the loss is fairly significant. Tuple splatting allows the success and failure callbacks to be called generically, simplifying the implementation of fake API calls to a single line.<br></p><p>    func getChatMessages(channel channel: ChatChannel, limit: Int, success: (chatMessages: [ChatMessage]) -&gt; Void, failure: (error: NSError) -&gt; Void) {<br>        // Can&#39;t do this anymore:<br>        // getChatMessagesEndpoint.handleCall(success, failure, callParams: (channel: channel, limit: limit))<br>        <br>        getChatMessagesEndpoint.calls.append((channel: channel, limit: limit))<br>        <br>        if getChatMessagesEndpoint.successStubs.count &gt; 0 {<br>            var stub = successStubs.removeFirst()<br>            success(messages: stub.0, someOtherValue: stub.1)<br>        }<br>        else if getChatMessagesEndpoint.failureStubs.count &gt; 0 {<br>            var stub = failureStubs.removeFirst()<br>            failure(error: stub.0, status: stub.1)<br>        }<br>    }<br></p><p>All that duplicated boilerplate really adds up once you have 10 or 20 different API calls.<br></p><p>In any case, this is a rare enough pattern (though I do think it&#39;s a very useful one) that it wouldn&#39;t be a huge loss for this feature to disappear for a while, but I do hope that it shows up again in another form at some point.<br></p><p>Jarod<br></p><p>&gt; On Jan 27, 2016, at 11:41, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 27, 2016, at 11:32 AM, Jarod Long &lt;swift at lng.la &lt;mailto:swift at lng.la&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; But failure in this case is a function that takes two arguments, and failureStubs is an array of tuples that map to that function&#39;s arguments. How do the tuple values get mapped to the arguments if not via tuple splatting?<br>&gt; <br>&gt; Ah ok, I was looking at the success case I guess.  You’re right.  In this case, instead of :<br>&gt; <br>&gt;     failure(failureStubs.removeFirst())<br>&gt; <br>&gt; you’d have to write something like this:<br>&gt; <br>&gt;     let tmp = failureStubs.removeFirst()<br>&gt;     failure(tmp.0, tmp.1)<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Jarod<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 27, 2016, at 11:28, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 27, 2016, at 11:24 AM, swift at lng.la &lt;mailto:swift at lng.la&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Apologies -- I just realized I chose a bad example that isn&#39;t actually using the feature, but the usage would be here:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; if successStubs.count &gt; 0 {<br>&gt;&gt;&gt;&gt;     success(successStubs.removeFirst())<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; else if failureStubs.count &gt; 0 {<br>&gt;&gt;&gt;&gt;     failure(failureStubs.removeFirst())<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This isn’t using the feature either.  You are passing a single value (returned by removeFirst) as a single argument.  No spat is happening.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/93e55b28/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>Proposal: Remove implicit tuple splat behavior from function applications</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>January 28, 2016 at 10:00:00am</p></header><div class="content"><p>I&#39;m for making it clearer, not for removing it.<br></p><p>If I understand correctly we would lose the ability to do this:<br></p><p>func compose&lt;A,B,C&gt;(lhs: A -&gt; B, rhs: B -&gt; C) -&gt; A -&gt; C {<br></p><p>    return { rhs(lhs($0)) }<br></p><p>}<br></p><p>let apply: (Int,Int)-&gt;Int = compose(+, rhs: abs)<br></p><p>print(&quot;result: &quot;, apply(1,-5)) // prints 4, ie. abs(1 + -5)<br></p><p><br>It&#39;s nice at the moment to be able to do generalised functions on functions<br>without needing versions for every combination of parameter count.<br></p><p>The biggest use case for me is generics, specifically functions on<br>functions and testing libraries.<br></p><p><br>On Thu, Jan 28, 2016 at 6:41 AM, Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Jan 27, 2016, at 11:32 AM, Jarod Long &lt;swift at lng.la&gt; wrote:<br>&gt;<br>&gt; But failure in this case is a function that takes two arguments, and<br>&gt; failureStubs is an array of tuples that map to that function&#39;s arguments.<br>&gt; How do the tuple values get mapped to the arguments if not via tuple<br>&gt; splatting?<br>&gt;<br>&gt;<br>&gt; Ah ok, I was looking at the success case I guess.  You’re right.  In this<br>&gt; case, instead of :<br>&gt;<br>&gt;     failure(failureStubs.removeFirst())<br>&gt;<br>&gt; you’d have to write something like this:<br>&gt;<br>&gt;     let tmp = failureStubs.removeFirst()<br>&gt;     failure(tmp.0, tmp.1)<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br>&gt; Jarod<br>&gt;<br>&gt; On Jan 27, 2016, at 11:28, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;<br>&gt; On Jan 27, 2016, at 11:24 AM, swift at lng.la wrote:<br>&gt;<br>&gt; Apologies -- I just realized I chose a bad example that isn&#39;t actually<br>&gt; using the feature, but the usage would be here:<br>&gt;<br>&gt; if successStubs.count &gt; 0 {<br>&gt;     success(successStubs.removeFirst())<br>&gt; }<br>&gt; else if failureStubs.count &gt; 0 {<br>&gt;     failure(failureStubs.removeFirst())<br>&gt; }<br>&gt;<br>&gt;<br>&gt; This isn’t using the feature either.  You are passing a single value<br>&gt; (returned by removeFirst) as a single argument.  No spat is happening.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/2616edf4/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Proposal: Remove implicit tuple splat behavior from function applications</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>January 27, 2016 at 12:00:00pm</p></header><div class="content"><p>Chris, tell me if this code example clarifies what you are proposing.<br></p><p>Given:<br>func moveTo(x x:Double, y:Double} {/*…*/ }<br>moveTo(x:0, y:0)<br></p><p>This is the behavior that is being proposed to be removed:<br>var point = (x:1.0, y:1.0)<br>moveTo(point)<br></p><p>instead, I’d have to do either:<br>moveTo(x:point.x, y:point.y)<br></p><p>or:<br></p><p>func moveTo(point:(x:Double, y:Double)) {<br>  moveTo(x:point.x, y:point.y)<br>}<br></p><p>today, I’m not entirely sure the behavior if I defined that second function signature. I’m guessing that is one of the motivators to remove this behavior.<br></p><p>-DW<br></p><p>&gt; On Jan 27, 2016, at 12:10 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 27, 2016, at 11:03 AM, swift at lng.la &lt;mailto:swift at lng.la&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;m +1 if this will eventually be replaced with a better-designed version, but I do use it and would be sad to see it go. I&#39;ve found it very helpful for testing:<br>&gt; <br>&gt; Hi Jarod, where are you using this feature?<br>&gt; <br>&gt;&gt; <br>&gt;&gt; protocol APIType {<br>&gt;&gt;     func getChatMessages(channel channel: ChatChannel, limit: Int, success: (chatMessages: [ChatMessage]) -&gt; Void, failure: (error: NSError) -&gt; Void)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class FakeAPI: APIType {<br>&gt;&gt;     var getChatMessagesEndpoint = FakeAPIEndpoint(<br>&gt;&gt;         calls:        [(channel: ChatChannel, limit: Int)](),<br>&gt;&gt;         successStubs: [[ChatMessage]](),<br>&gt;&gt;         failureStubs: [NSError]()<br>&gt;&gt;     )<br>&gt;&gt;     <br>&gt;&gt;     func getChatMessages(channel channel: ChatChannel, limit: Int, success: (chatMessages: [ChatMessage]) -&gt; Void, failure: (error: NSError) -&gt; Void) {<br>&gt;&gt;         getChatMessagesEndpoint.handleCall(success, failure, callParams: (channel: channel, limit: limit))<br>&gt; <br>&gt; If you are referring to this line, then there is no change.  The only affected case is in call sites that take a single parameter without a label.  Passing tuples as values will not be change.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; <br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct FakeAPIEndpoint&lt;CallParams, SuccessParams, FailureParams&gt; {<br>&gt;&gt;     private(set) var calls:        [CallParams]<br>&gt;&gt;     private(set) var successStubs: [SuccessParams]<br>&gt;&gt;     private(set) var failureStubs: [FailureParams]<br>&gt;&gt;     <br>&gt;&gt;     mutating func stubSuccess(params: SuccessParams) {<br>&gt;&gt;         successStubs.append(params)<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     mutating func stubFailure(params: FailureParams) {<br>&gt;&gt;         failureStubs.append(params)<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     private mutating func handleCall(success: (SuccessParams) -&gt; Void, _ failure: (FailureParams) -&gt; Void, call: CallParams) {<br>&gt;&gt;         calls.append(call)<br>&gt;&gt;         <br>&gt;&gt;         if successStubs.count &gt; 0 {<br>&gt;&gt;             success(successStubs.removeFirst())<br>&gt;&gt;         }<br>&gt;&gt;         else if failureStubs.count &gt; 0 {<br>&gt;&gt;             failure(failureStubs.removeFirst())<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; It&#39;s really nice to have that handleCall method that can call the success or failure callback automatically rather than reimplementing that functionality in every fake API call.<br>&gt;&gt; <br>&gt;&gt; Jarod<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 27, 2016, at 10:16, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 27, 2016, at 2:18 AM, Nisse Bergman &lt;nisse at potmo.com &lt;mailto:nisse at potmo.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -1 I use this in both my mocking API and in JSON deserialising/serializing.<br>&gt;&gt;&gt;&gt; I think this is a great thing to have.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Ok, I’m definitely interested in knowing more.  Please include a code sample, showing both the declaration being splatted into and the call sites.  Otherwise, I can’t tell how much value this feature is adding, and what the pain would be if it were removed.  Thanks!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 27 Jan 2016, at 11:07, David Waite via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I used this just last week! But only as an illustration<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; +1<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; One comment though, a splat operator need not be purely syntactic sugar - it could be the way arrays are applied to variadic functions.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -DW<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/3cbcfe0a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: Remove implicit tuple splat behavior from function applications</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 27, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jan 27, 2016, at 11:32 AM, David Waite &lt;david at alkaline-solutions.com&gt; wrote:<br>&gt; <br>&gt; Chris, tell me if this code example clarifies what you are proposing.<br>&gt; <br>&gt; Given:<br>&gt; func moveTo(x x:Double, y:Double} {/*…*/ }<br>&gt; moveTo(x:0, y:0)<br>&gt; <br>&gt; This is the behavior that is being proposed to be removed:<br>&gt; var point = (x:1.0, y:1.0)<br>&gt; moveTo(point)<br>&gt; <br>&gt; instead, I’d have to do either:<br>&gt; moveTo(x:point.x, y:point.y)<br>&gt; <br>&gt; or:<br>&gt; <br>&gt; func moveTo(point:(x:Double, y:Double)) {<br>&gt;   moveTo(x:point.x, y:point.y)<br>&gt; }<br></p><p>Correct.<br></p><p>&gt; today, I’m not entirely sure the behavior if I defined that second function signature. I’m guessing that is one of the motivators to remove this behavior.<br></p><p>Yes, exactly.  This is an example of the ambiguity that I’m referring to.<br></p><p>-Chris<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Proposal: Remove implicit tuple splat behavior from function applications</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January 27, 2016 at 10:00:00pm</p></header><div class="content"><p>+1. Never use it. <br></p><p>-- Howard. <br></p><p>&gt; On 27 Jan 2016, at 5:23 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; For discussion: comments appreciated!<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; Remove implicit tuple splat behavior from function applications<br>&gt; Proposal: SE-TBD<br>&gt; Author(s): Chris Lattner<br>&gt; Status: Awaiting review<br>&gt; Review manager: TBD<br>&gt; Introduction<br>&gt; <br>&gt; Function calls (which include several syntactic forms that apply an argument list to something of function type) currently have a dual nature in Swift.  Given something like:<br>&gt; <br>&gt; <br>&gt; 	func foo(a : Int, b : Int) {}<br>&gt; <br>&gt; <br>&gt; You can call it either with with the typical syntactic form that passes arguments to each of its parameters:<br>&gt; <br>&gt; <br>&gt; 	foo(42, b : 17)<br>&gt; <br>&gt; or you can take advantage of a little-known feature to pass an entire argument list as a single value (of tuple type):<br>&gt; <br>&gt; 	let x = (1, b: 2)<br>&gt; 	foo(x)<br>&gt; <br>&gt; <br>&gt; This proposal recommends removing the later form, which I affectionately refer to as the “tuple splat” form.  This feature is purely a sugar feature, it does not provide any expressive ability beyond passing the parameters manually.<br>&gt; <br>&gt; <br>&gt; Swift-evolution thread: TBD<br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; This behavior is cute, precedented in other functional languages, and has some advantages, but it also has several major disadvantages, which are all related to its syntactic form.<br>&gt; <br>&gt; * A call to foo(x) looks like a call to an overloaded version of foo, both to the compiler and to the human who maintains the code.  This is extremely confusing if you don’t know the feature exists.<br>&gt; * There are real ambiguities in the syntax, e.g. involving Any arguments and situations where you want to pass a tuple value as a single parameter.<br>&gt; * The current implementation has a ton of implementation bugs - it doesn’t work reliably.<br>&gt; * The current implementation adds complexity to the type checker, slowing it down and adding maintenance burden.<br>&gt; * The current implementation doesn’t work the way we would want a tuple splat operation to work.  For example, arguably, you should be able to call foo with:<br>&gt; <br>&gt; 	func bar() -&gt; (Int, Int) { … }<br>&gt; 	foo(bar())<br>&gt; <br>&gt; … but this is not allowed, since tuple labels are required to line up.  You have to write:<br>&gt; <br>&gt; 	func bar() -&gt; (Int, b: Int)  { … }<br>&gt; 	foo(bar())<br>&gt; <br>&gt; <br>&gt; This makes this feature very difficult to use in practice, because you have to _’ize a lot of parameters (violating naming conventions), perform manual shuffling (defeating the sugar benefits of the feature), or add parameter labels to the result of functions (which leads to odd tying between callers and callees).<br>&gt; <br>&gt; <br>&gt; The root problem here is that we use exactly the same syntax for both forms of function application.  If the two forms were differentiated (an option considered in “alternatives considered” below) then some of these problems would be defined away.<br>&gt; <br>&gt; From a historical perspective, the tuple splat form of function application dates back to very early Swift design (probably introduced in 2010, but possibly 2011) where all function application was of a single value to a function type.  For a large number of reasons (including default arguments, variadic arguments, labels, etc) we have completely abandoned this model, but we never came back to reevaluating the tuple splat behavior.<br>&gt; <br>&gt; If we didn’t already have this feature, we would not add it to Swift 3 (at least in its current form).<br>&gt; <br>&gt; Proposed solution<br>&gt; <br>&gt; The proposed solution is simple, we should just remove this feature from the Swift 3 compiler.  Ideally we would deprecate it in the Swift 2.2 compiler and remove it in Swift 3.  However, if there isn’t time to get the deprecation into Swift 2.2, the author believes it would be perfectly fine to just remove it in Swift 3 (with a fixit + migration help of course).<br>&gt; <br>&gt; One of the interesting aspect of this feature is that some of the people we’ve spoken to are very fond of it.  However, when pressed, they admit that they are not actually using it widely in their code, or if they are using it, they are abusing naming conventions (distorting their code) in order to use it.  This doesn’t seem like a positive contribution - this seems like a “clever” feature, not a practical one.<br>&gt; <br>&gt; Detailed design<br>&gt; <br>&gt; The design is straight-forward.  In the Swift 3 time frame, we continue to parse and type check these expressions as we have so far, but produce an error + fixit hint when it is the tuple splat form.  The migrator would auto-apply the fixit hint as it does for other cases.<br>&gt; <br>&gt; Impact on existing code<br>&gt; <br>&gt; Any code that uses this feature will have to move to the traditional form.  In the case of the example above, this means rewriting the code from:<br>&gt; <br>&gt; 	foo(x)<br>&gt; <br>&gt; into a form like this:<br>&gt; <br>&gt; 	foo(x.0, x.b)<br>&gt; <br>&gt; In the case where “x” is a complex expression, a temporary variable will need to be introduced.  We believe that compiler fixits can handle the simple cases directly and that this extension is not widely used.<br>&gt; <br>&gt; Alternatives considered<br>&gt; <br>&gt; The major problem with this feature is that it was not well considered and implemented properly (owing to its very old age, it has just been kept limping along).  The alternative then is to actually design a proper feature to support this.  Since the implicitness and syntactic ambiguity with normal function application is the problem, the solution is to introduce an explicit syntactic form to represent this.  For example, something like this could address the problems we have:<br>&gt; <br>&gt; 	foo(*x)    // NOT a serious syntax proposal<br>&gt; <br>&gt; However, actually designing this feature would be a non-trivial effort not core to the Swift 3 mission:<br>&gt; <br>&gt; * It is a pure-sugar feature, and therefore low priority.<br>&gt; * We don’t have an obvious sigil to use.  “prefix-star” should be kept as unused for now in case we want to use it to refer to memory-related operations in the future.<br>&gt; * Making the tuple splat operation great requires more than just fixing the syntactic ambiguities we have, it would require re-evaluating the semantics of the operation (e.g. in light of parameter labels, varargs and other features).<br>&gt; <br>&gt; If there is serious interest in pursuing this as a concept, we should do it as a follow-on proposal to this one.  If a good design emerges, we can evaluate that design based on its merits.<br>&gt; <br>&gt; <br>&gt; The final alternative is that we could leave the feature in the compiler.  However, that means living with its complexity “forever” or breaking code in the Swift 4 timeframe.  It would be preferable to tackle this breakage in the Swift 3 timeframe, since we know that migration will already be needed then.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/27c27d3c/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>Proposal: Remove implicit tuple splat behavior from function applications</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>January 27, 2016 at 10:00:00am</p></header><div class="content"><p>I do think there’s eventual value in this (modulo syntax refinement):<br></p><p>	foo(*x)    // NOT a serious syntax proposal<br></p><p>I have hit just a few proxy-flavored situations where argument forwarding was useful. However, in those situations, it’s very little manual effort to just rebuild the tuple: f(tuple.a, b: tuple.b). I thus don’t consider that feature urgent, and would happily wait until Swift 4+ for it. I’d just like to keep a toe in the door for it.<br></p><p>With that minor caveat, I support this proposal. I’ve been bitten by the Any-related ambiguities Chris mentions — far more often than I’ve actually had use for this feature.<br></p><p>I’ll also reiterate my wish to remove the overloaded meaning of $0 as the unsplatted args of a closure. It’s equally esoteric and super confusing. Hmm, I should bump that thread….<br></p><p>Cheers, P<br></p><p><br>&gt; On Jan 27, 2016, at 12:23 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; For discussion: comments appreciated!<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; Remove implicit tuple splat behavior from function applications<br>&gt; <br>&gt; Proposal: SE- &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;TBD<br>&gt; Author(s): Chris Lattner<br>&gt; Status: Awaiting review<br>&gt; Review manager: TBD<br>&gt;  &lt;https://github.com/apple/swift-evolution#introduction&gt;Introduction<br>&gt; <br>&gt; Function calls (which include several syntactic forms that apply an argument list to something of function type) currently have a dual nature in Swift.  Given something like:<br>&gt; <br>&gt; <br>&gt; 	func foo(a : Int, b : Int) {}<br>&gt; <br>&gt; <br>&gt; You can call it either with with the typical syntactic form that passes arguments to each of its parameters:<br>&gt; <br>&gt; <br>&gt; 	foo(42, b : 17)<br>&gt; <br>&gt; or you can take advantage of a little-known feature to pass an entire argument list as a single value (of tuple type):<br>&gt; <br>&gt; 	let x = (1, b: 2)<br>&gt; 	foo(x)<br>&gt; <br>&gt; <br>&gt; This proposal recommends removing the later form, which I affectionately refer to as the “tuple splat” form.  This feature is purely a sugar feature, it does not provide any expressive ability beyond passing the parameters manually.<br>&gt; <br>&gt; <br>&gt; Swift-evolution thread: TBD<br>&gt; <br>&gt;  &lt;https://github.com/apple/swift-evolution#motivation&gt;Motivation<br>&gt; <br>&gt; This behavior is cute, precedented in other functional languages, and has some advantages, but it also has several major disadvantages, which are all related to its syntactic form.<br>&gt; <br>&gt; * A call to foo(x) looks like a call to an overloaded version of foo, both to the compiler and to the human who maintains the code.  This is extremely confusing if you don’t know the feature exists.<br>&gt; * There are real ambiguities in the syntax, e.g. involving Any arguments and situations where you want to pass a tuple value as a single parameter.<br>&gt; * The current implementation has a ton of implementation bugs - it doesn’t work reliably.<br>&gt; * The current implementation adds complexity to the type checker, slowing it down and adding maintenance burden.<br>&gt; * The current implementation doesn’t work the way we would want a tuple splat operation to work.  For example, arguably, you should be able to call foo with:<br>&gt; <br>&gt; 	func bar() -&gt; (Int, Int) { … }<br>&gt; 	foo(bar())<br>&gt; <br>&gt; … but this is not allowed, since tuple labels are required to line up.  You have to write:<br>&gt; <br>&gt; <br>&gt; <br>&gt; 	func bar() -&gt; (Int, b: Int)  { … }<br>&gt; 	foo(bar())<br>&gt; <br>&gt; <br>&gt; This makes this feature very difficult to use in practice, because you have to _’ize a lot of parameters (violating naming conventions), perform manual shuffling (defeating the sugar benefits of the feature), or add parameter labels to the result of functions (which leads to odd tying between callers and callees).<br>&gt; <br>&gt; <br>&gt; The root problem here is that we use exactly the same syntax for both forms of function application.  If the two forms were differentiated (an option considered in “alternatives considered” below) then some of these problems would be defined away.<br>&gt; <br>&gt; From a historical perspective, the tuple splat form of function application dates back to very early Swift design (probably introduced in 2010, but possibly 2011) where all function application was of a single value to a function type.  For a large number of reasons (including default arguments, variadic arguments, labels, etc) we have completely abandoned this model, but we never came back to reevaluating the tuple splat behavior.<br>&gt; <br>&gt; If we didn’t already have this feature, we would not add it to Swift 3 (at least in its current form).<br>&gt; <br>&gt;  &lt;https://github.com/apple/swift-evolution#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt; The proposed solution is simple, we should just remove this feature from the Swift 3 compiler.  Ideally we would deprecate it in the Swift 2.2 compiler and remove it in Swift 3.  However, if there isn’t time to get the deprecation into Swift 2.2, the author believes it would be perfectly fine to just remove it in Swift 3 (with a fixit + migration help of course).<br>&gt; <br>&gt; One of the interesting aspect of this feature is that some of the people we’ve spoken to are very fond of it.  However, when pressed, they admit that they are not actually using it widely in their code, or if they are using it, they are abusing naming conventions (distorting their code) in order to use it.  This doesn’t seem like a positive contribution - this seems like a “clever” feature, not a practical one.<br>&gt; <br>&gt;  &lt;https://github.com/apple/swift-evolution#detailed-design&gt;Detailed design<br>&gt; <br>&gt; The design is straight-forward.  In the Swift 3 time frame, we continue to parse and type check these expressions as we have so far, but produce an error + fixit hint when it is the tuple splat form.  The migrator would auto-apply the fixit hint as it does for other cases.<br>&gt; <br>&gt;  &lt;https://github.com/apple/swift-evolution#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; Any code that uses this feature will have to move to the traditional form.  In the case of the example above, this means rewriting the code from:<br>&gt; <br>&gt; 	foo(x)<br>&gt; <br>&gt; into a form like this:<br>&gt; <br>&gt; 	foo(x.0, x.b)<br>&gt; <br>&gt; In the case where “x” is a complex expression, a temporary variable will need to be introduced.  We believe that compiler fixits can handle the simple cases directly and that this extension is not widely used.<br>&gt; <br>&gt;  &lt;https://github.com/apple/swift-evolution#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt; The major problem with this feature is that it was not well considered and implemented properly (owing to its very old age, it has just been kept limping along).  The alternative then is to actually design a proper feature to support this.  Since the implicitness and syntactic ambiguity with normal function application is the problem, the solution is to introduce an explicit syntactic form to represent this.  For example, something like this could address the problems we have:<br>&gt; <br>&gt; 	foo(*x)    // NOT a serious syntax proposal<br>&gt; <br>&gt; However, actually designing this feature would be a non-trivial effort not core to the Swift 3 mission:<br>&gt; <br>&gt; * It is a pure-sugar feature, and therefore low priority.<br>&gt; * We don’t have an obvious sigil to use.  “prefix-star” should be kept as unused for now in case we want to use it to refer to memory-related operations in the future.<br>&gt; * Making the tuple splat operation great requires more than just fixing the syntactic ambiguities we have, it would require re-evaluating the semantics of the operation (e.g. in light of parameter labels, varargs and other features).<br>&gt; <br>&gt; If there is serious interest in pursuing this as a concept, we should do it as a follow-on proposal to this one.  If a good design emerges, we can evaluate that design based on its merits.<br>&gt; <br>&gt; <br>&gt; The final alternative is that we could leave the feature in the compiler.  However, that means living with its complexity “forever” or breaking code in the Swift 4 timeframe.  It would be preferable to tackle this breakage in the Swift 3 timeframe, since we know that migration will already be needed then.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/293e872c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/caa7226ca750e974668243476ffbafd5?s=50"></div><header><strong>Proposal: Remove implicit tuple splat behavior from function applications</strong> from <string>Greg Titus</string> &lt;greg at omnigroup.com&gt;<p>January 27, 2016 at 08:00:00am</p></header><div class="content"><p>+1.<br></p><p>Removing implicit tuple splat will also fix most of the confusing argument issues with anonymous closures.<br></p><p>You wrote a couple weeks back:<br>----<br>    func foo(val: Int) { }<br></p><p>    func bar(closure: (Int,Int) -&gt; Void) {<br>        closure(0, 1)<br>    }<br></p><p>    bar { foo($0) }       // compiler error<br>    bar { foo($1) }       // just dandy<br>    bar { foo($0 + $1) }  // also works<br>—-<br></p><p>The reason why the compiler error happens is because it is currently legal for $0 to be a tuple of type (Int,Int) and to call foo() with that tuple because of the implicit splatting. Once that is illegal, having the anonymous closure take a single (Int,Int) tuple isn’t a legal possibility, and so you will probably end up with a more understandable error about bar() being called with an argument of  (_) -&gt; Void instead of the expected (Int, Int) -&gt; Void. (I.e. the compiler thinks that there’s just one argument to the closure still, but at least it’s narrowed down the type problem to the correct location.)<br></p><p>And now that the problem will be narrowed to the type signature of the anonymous closure, it becomes possible to fix it (in a separate proposal) by making type inference on anonymous closures implicitly allow additional ignored arguments.  <br></p><p>	- Greg<br></p><p>&gt; On Jan 27, 2016, at 8:06 AM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I do think there’s eventual value in this (modulo syntax refinement):<br>&gt; <br>&gt; 	foo(*x)    // NOT a serious syntax proposal<br>&gt; <br>&gt; I have hit just a few proxy-flavored situations where argument forwarding was useful. However, in those situations, it’s very little manual effort to just rebuild the tuple: f(tuple.a, b: tuple.b). I thus don’t consider that feature urgent, and would happily wait until Swift 4+ for it. I’d just like to keep a toe in the door for it.<br>&gt; <br>&gt; With that minor caveat, I support this proposal. I’ve been bitten by the Any-related ambiguities Chris mentions — far more often than I’ve actually had use for this feature.<br>&gt; <br>&gt; I’ll also reiterate my wish to remove the overloaded meaning of $0 as the unsplatted args of a closure. It’s equally esoteric and super confusing. Hmm, I should bump that thread….<br>&gt; <br>&gt; Cheers, P<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 27, 2016, at 12:23 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; For discussion: comments appreciated!<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Remove implicit tuple splat behavior from function applications<br>&gt;&gt; <br>&gt;&gt; 	• Proposal: SE-TBD<br>&gt;&gt; 	• Author(s): Chris Lattner<br>&gt;&gt; 	• Status: Awaiting review<br>&gt;&gt; 	• Review manager: TBD<br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; Function calls (which include several syntactic forms that apply an argument list to something of function type) currently have a dual nature in Swift.  Given something like:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; 	func foo(a : Int, b : Int) {}<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; You can call it either with with the typical syntactic form that passes arguments to each of its parameters:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; 	foo(42, b : 17)<br>&gt;&gt; <br>&gt;&gt; or you can take advantage of a little-known feature to pass an entire argument list as a single value (of tuple type):<br>&gt;&gt; <br>&gt;&gt; 	let x = (1, b: 2)<br>&gt;&gt; 	foo(x)<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; This proposal recommends removing the later form, which I affectionately refer to as the “tuple splat” form.  This feature is purely a sugar feature, it does not provide any expressive ability beyond passing the parameters manually.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Swift-evolution thread: TBD<br>&gt;&gt; <br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; This behavior is cute, precedented in other functional languages, and has some advantages, but it also has several major disadvantages, which are all related to its syntactic form.<br>&gt;&gt; <br>&gt;&gt; * A call to foo(x) looks like a call to an overloaded version of foo, both to the compiler and to the human who maintains the code.  This is extremely confusing if you don’t know the feature exists.<br>&gt;&gt; * There are real ambiguities in the syntax, e.g. involving Any arguments and situations where you want to pass a tuple value as a single parameter.<br>&gt;&gt; * The current implementation has a ton of implementation bugs - it doesn’t work reliably.<br>&gt;&gt; * The current implementation adds complexity to the type checker, slowing it down and adding maintenance burden.<br>&gt;&gt; * The current implementation doesn’t work the way we would want a tuple splat operation to work.  For example, arguably, you should be able to call foo with:<br>&gt;&gt; <br>&gt;&gt; 	func bar() -&gt; (Int, Int) { … }<br>&gt;&gt; 	foo(bar())<br>&gt;&gt; <br>&gt;&gt; … but this is not allowed, since tuple labels are required to line up.  You have to write:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; 	func bar() -&gt; (Int, b: Int)  { … }<br>&gt;&gt; 	foo(bar())<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; This makes this feature very difficult to use in practice, because you have to _’ize a lot of parameters (violating naming conventions), perform manual shuffling (defeating the sugar benefits of the feature), or add parameter labels to the result of functions (which leads to odd tying between callers and callees).<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; The root problem here is that we use exactly the same syntax for both forms of function application.  If the two forms were differentiated (an option considered in “alternatives considered” below) then some of these problems would be defined away.<br>&gt;&gt; <br>&gt;&gt; From a historical perspective, the tuple splat form of function application dates back to very early Swift design (probably introduced in 2010, but possibly 2011) where all function application was of a single value to a function type.  For a large number of reasons (including default arguments, variadic arguments, labels, etc) we have completely abandoned this model, but we never came back to reevaluating the tuple splat behavior.<br>&gt;&gt; <br>&gt;&gt; If we didn’t already have this feature, we would not add it to Swift 3 (at least in its current form).<br>&gt;&gt; <br>&gt;&gt; Proposed solution<br>&gt;&gt; <br>&gt;&gt; The proposed solution is simple, we should just remove this feature from the Swift 3 compiler.  Ideally we would deprecate it in the Swift 2.2 compiler and remove it in Swift 3.  However, if there isn’t time to get the deprecation into Swift 2.2, the author believes it would be perfectly fine to just remove it in Swift 3 (with a fixit + migration help of course).<br>&gt;&gt; <br>&gt;&gt; One of the interesting aspect of this feature is that some of the people we’ve spoken to are very fond of it.  However, when pressed, they admit that they are not actually using it widely in their code, or if they are using it, they are abusing naming conventions (distorting their code) in order to use it.  This doesn’t seem like a positive contribution - this seems like a “clever” feature, not a practical one.<br>&gt;&gt; <br>&gt;&gt; Detailed design<br>&gt;&gt; <br>&gt;&gt; The design is straight-forward.  In the Swift 3 time frame, we continue to parse and type check these expressions as we have so far, but produce an error + fixit hint when it is the tuple splat form.  The migrator would auto-apply the fixit hint as it does for other cases.<br>&gt;&gt; <br>&gt;&gt; Impact on existing code<br>&gt;&gt; <br>&gt;&gt; Any code that uses this feature will have to move to the traditional form.  In the case of the example above, this means rewriting the code from:<br>&gt;&gt; <br>&gt;&gt; 	foo(x)<br>&gt;&gt; <br>&gt;&gt; into a form like this:<br>&gt;&gt; <br>&gt;&gt; 	foo(x.0, x.b)<br>&gt;&gt; <br>&gt;&gt; In the case where “x” is a complex expression, a temporary variable will need to be introduced.  We believe that compiler fixits can handle the simple cases directly and that this extension is not widely used.<br>&gt;&gt; <br>&gt;&gt; Alternatives considered<br>&gt;&gt; <br>&gt;&gt; The major problem with this feature is that it was not well considered and implemented properly (owing to its very old age, it has just been kept limping along).  The alternative then is to actually design a proper feature to support this.  Since the implicitness and syntactic ambiguity with normal function application is the problem, the solution is to introduce an explicit syntactic form to represent this.  For example, something like this could address the problems we have:<br>&gt;&gt; <br>&gt;&gt; 	foo(*x)    // NOT a serious syntax proposal<br>&gt;&gt; <br>&gt;&gt; However, actually designing this feature would be a non-trivial effort not core to the Swift 3 mission:<br>&gt;&gt; <br>&gt;&gt; * It is a pure-sugar feature, and therefore low priority.<br>&gt;&gt; * We don’t have an obvious sigil to use.  “prefix-star” should be kept as unused for now in case we want to use it to refer to memory-related operations in the future.<br>&gt;&gt; * Making the tuple splat operation great requires more than just fixing the syntactic ambiguities we have, it would require re-evaluating the semantics of the operation (e.g. in light of parameter labels, varargs and other features).<br>&gt;&gt; <br>&gt;&gt; If there is serious interest in pursuing this as a concept, we should do it as a follow-on proposal to this one.  If a good design emerges, we can evaluate that design based on its merits.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; The final alternative is that we could leave the feature in the compiler.  However, that means living with its complexity “forever” or breaking code in the Swift 4 timeframe.  It would be preferable to tackle this breakage in the Swift 3 timeframe, since we know that migration will already be needed then.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/aeab22e60ba7b7e2bd445775850448d1?s=50"></div><header><strong>Proposal: Remove implicit tuple splat behavior from function applications</strong> from <string>Radosław Pietruszewski</string> &lt;radexpl at gmail.com&gt;<p>January 27, 2016 at 08:00:00pm</p></header><div class="content"><p>+1 with the same caveat. I used this feature a few times and liked having it, but I agree that it would be much better as an explicit operation, and I can wait for that. It&#39;s not high priority.<br></p><p>Sent from my iPad<br></p><p>&gt; On 27 Jan 2016, at 17:06, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I do think there’s eventual value in this (modulo syntax refinement):<br>&gt; <br>&gt; 	foo(*x)    // NOT a serious syntax proposal<br>&gt; <br>&gt; I have hit just a few proxy-flavored situations where argument forwarding was useful. However, in those situations, it’s very little manual effort to just rebuild the tuple: f(tuple.a, b: tuple.b). I thus don’t consider that feature urgent, and would happily wait until Swift 4+ for it. I’d just like to keep a toe in the door for it.<br>&gt; <br>&gt; With that minor caveat, I support this proposal. I’ve been bitten by the Any-related ambiguities Chris mentions — far more often than I’ve actually had use for this feature.<br>&gt; <br>&gt; I’ll also reiterate my wish to remove the overloaded meaning of $0 as the unsplatted args of a closure. It’s equally esoteric and super confusing. Hmm, I should bump that thread….<br>&gt; <br>&gt; Cheers, P<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 27, 2016, at 12:23 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; For discussion: comments appreciated!<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Remove implicit tuple splat behavior from function applications<br>&gt;&gt; Proposal: SE-TBD<br>&gt;&gt; Author(s): Chris Lattner<br>&gt;&gt; Status: Awaiting review<br>&gt;&gt; Review manager: TBD<br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; Function calls (which include several syntactic forms that apply an argument list to something of function type) currently have a dual nature in Swift.  Given something like:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; 	func foo(a : Int, b : Int) {}<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; You can call it either with with the typical syntactic form that passes arguments to each of its parameters:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; 	foo(42, b : 17)<br>&gt;&gt; <br>&gt;&gt; or you can take advantage of a little-known feature to pass an entire argument list as a single value (of tuple type):<br>&gt;&gt; <br>&gt;&gt; 	let x = (1, b: 2)<br>&gt;&gt; 	foo(x)<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; This proposal recommends removing the later form, which I affectionately refer to as the “tuple splat” form.  This feature is purely a sugar feature, it does not provide any expressive ability beyond passing the parameters manually.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Swift-evolution thread: TBD<br>&gt;&gt; <br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; This behavior is cute, precedented in other functional languages, and has some advantages, but it also has several major disadvantages, which are all related to its syntactic form.<br>&gt;&gt; <br>&gt;&gt; * A call to foo(x) looks like a call to an overloaded version of foo, both to the compiler and to the human who maintains the code.  This is extremely confusing if you don’t know the feature exists.<br>&gt;&gt; * There are real ambiguities in the syntax, e.g. involving Any arguments and situations where you want to pass a tuple value as a single parameter.<br>&gt;&gt; * The current implementation has a ton of implementation bugs - it doesn’t work reliably.<br>&gt;&gt; * The current implementation adds complexity to the type checker, slowing it down and adding maintenance burden.<br>&gt;&gt; * The current implementation doesn’t work the way we would want a tuple splat operation to work.  For example, arguably, you should be able to call foo with:<br>&gt;&gt; <br>&gt;&gt; 	func bar() -&gt; (Int, Int) { … }<br>&gt;&gt; 	foo(bar())<br>&gt;&gt; <br>&gt;&gt; … but this is not allowed, since tuple labels are required to line up.  You have to write:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; 	func bar() -&gt; (Int, b: Int)  { … }<br>&gt;&gt; 	foo(bar())<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; This makes this feature very difficult to use in practice, because you have to _’ize a lot of parameters (violating naming conventions), perform manual shuffling (defeating the sugar benefits of the feature), or add parameter labels to the result of functions (which leads to odd tying between callers and callees).<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; The root problem here is that we use exactly the same syntax for both forms of function application.  If the two forms were differentiated (an option considered in “alternatives considered” below) then some of these problems would be defined away.<br>&gt;&gt; <br>&gt;&gt; From a historical perspective, the tuple splat form of function application dates back to very early Swift design (probably introduced in 2010, but possibly 2011) where all function application was of a single value to a function type.  For a large number of reasons (including default arguments, variadic arguments, labels, etc) we have completely abandoned this model, but we never came back to reevaluating the tuple splat behavior.<br>&gt;&gt; <br>&gt;&gt; If we didn’t already have this feature, we would not add it to Swift 3 (at least in its current form).<br>&gt;&gt; <br>&gt;&gt; Proposed solution<br>&gt;&gt; <br>&gt;&gt; The proposed solution is simple, we should just remove this feature from the Swift 3 compiler.  Ideally we would deprecate it in the Swift 2.2 compiler and remove it in Swift 3.  However, if there isn’t time to get the deprecation into Swift 2.2, the author believes it would be perfectly fine to just remove it in Swift 3 (with a fixit + migration help of course).<br>&gt;&gt; <br>&gt;&gt; One of the interesting aspect of this feature is that some of the people we’ve spoken to are very fond of it.  However, when pressed, they admit that they are not actually using it widely in their code, or if they are using it, they are abusing naming conventions (distorting their code) in order to use it.  This doesn’t seem like a positive contribution - this seems like a “clever” feature, not a practical one.<br>&gt;&gt; <br>&gt;&gt; Detailed design<br>&gt;&gt; <br>&gt;&gt; The design is straight-forward.  In the Swift 3 time frame, we continue to parse and type check these expressions as we have so far, but produce an error + fixit hint when it is the tuple splat form.  The migrator would auto-apply the fixit hint as it does for other cases.<br>&gt;&gt; <br>&gt;&gt; Impact on existing code<br>&gt;&gt; <br>&gt;&gt; Any code that uses this feature will have to move to the traditional form.  In the case of the example above, this means rewriting the code from:<br>&gt;&gt; <br>&gt;&gt; 	foo(x)<br>&gt;&gt; <br>&gt;&gt; into a form like this:<br>&gt;&gt; <br>&gt;&gt; 	foo(x.0, x.b)<br>&gt;&gt; <br>&gt;&gt; In the case where “x” is a complex expression, a temporary variable will need to be introduced.  We believe that compiler fixits can handle the simple cases directly and that this extension is not widely used.<br>&gt;&gt; <br>&gt;&gt; Alternatives considered<br>&gt;&gt; <br>&gt;&gt; The major problem with this feature is that it was not well considered and implemented properly (owing to its very old age, it has just been kept limping along).  The alternative then is to actually design a proper feature to support this.  Since the implicitness and syntactic ambiguity with normal function application is the problem, the solution is to introduce an explicit syntactic form to represent this.  For example, something like this could address the problems we have:<br>&gt;&gt; <br>&gt;&gt; 	foo(*x)    // NOT a serious syntax proposal<br>&gt;&gt; <br>&gt;&gt; However, actually designing this feature would be a non-trivial effort not core to the Swift 3 mission:<br>&gt;&gt; <br>&gt;&gt; * It is a pure-sugar feature, and therefore low priority.<br>&gt;&gt; * We don’t have an obvious sigil to use.  “prefix-star” should be kept as unused for now in case we want to use it to refer to memory-related operations in the future.<br>&gt;&gt; * Making the tuple splat operation great requires more than just fixing the syntactic ambiguities we have, it would require re-evaluating the semantics of the operation (e.g. in light of parameter labels, varargs and other features).<br>&gt;&gt; <br>&gt;&gt; If there is serious interest in pursuing this as a concept, we should do it as a follow-on proposal to this one.  If a good design emerges, we can evaluate that design based on its merits.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; The final alternative is that we could leave the feature in the compiler.  However, that means living with its complexity “forever” or breaking code in the Swift 4 timeframe.  It would be preferable to tackle this breakage in the Swift 3 timeframe, since we know that migration will already be needed then.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/d3196222/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>Proposal: Remove implicit tuple splat behavior from function applications</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>January 27, 2016 at 08:00:00am</p></header><div class="content"><p>+1. I&#39;m pretty sure this feature is the source of some of the more annoying bugs I&#39;ve run into, especially with generics and mislabeled parameters. In any regards, this should not be implicit.<br></p><p>-David<br></p><p>&gt; On Jan 26, 2016, at 10:23 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; For discussion: comments appreciated!<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; Remove implicit tuple splat behavior from function applications<br>&gt; <br>&gt; Proposal: SE- &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;TBD<br>&gt; Author(s): Chris Lattner<br>&gt; Status: Awaiting review<br>&gt; Review manager: TBD<br>&gt;  &lt;https://github.com/apple/swift-evolution#introduction&gt;Introduction<br>&gt; <br>&gt; Function calls (which include several syntactic forms that apply an argument list to something of function type) currently have a dual nature in Swift.  Given something like:<br>&gt; <br>&gt; <br>&gt; 	func foo(a : Int, b : Int) {}<br>&gt; <br>&gt; <br>&gt; You can call it either with with the typical syntactic form that passes arguments to each of its parameters:<br>&gt; <br>&gt; <br>&gt; 	foo(42, b : 17)<br>&gt; <br>&gt; or you can take advantage of a little-known feature to pass an entire argument list as a single value (of tuple type):<br>&gt; <br>&gt; 	let x = (1, b: 2)<br>&gt; 	foo(x)<br>&gt; <br>&gt; <br>&gt; This proposal recommends removing the later form, which I affectionately refer to as the “tuple splat” form.  This feature is purely a sugar feature, it does not provide any expressive ability beyond passing the parameters manually.<br>&gt; <br>&gt; <br>&gt; Swift-evolution thread: TBD<br>&gt; <br>&gt;  &lt;https://github.com/apple/swift-evolution#motivation&gt;Motivation<br>&gt; <br>&gt; This behavior is cute, precedented in other functional languages, and has some advantages, but it also has several major disadvantages, which are all related to its syntactic form.<br>&gt; <br>&gt; * A call to foo(x) looks like a call to an overloaded version of foo, both to the compiler and to the human who maintains the code.  This is extremely confusing if you don’t know the feature exists.<br>&gt; * There are real ambiguities in the syntax, e.g. involving Any arguments and situations where you want to pass a tuple value as a single parameter.<br>&gt; * The current implementation has a ton of implementation bugs - it doesn’t work reliably.<br>&gt; * The current implementation adds complexity to the type checker, slowing it down and adding maintenance burden.<br>&gt; * The current implementation doesn’t work the way we would want a tuple splat operation to work.  For example, arguably, you should be able to call foo with:<br>&gt; <br>&gt; 	func bar() -&gt; (Int, Int) { … }<br>&gt; 	foo(bar())<br>&gt; <br>&gt; … but this is not allowed, since tuple labels are required to line up.  You have to write:<br>&gt; <br>&gt; <br>&gt; <br>&gt; 	func bar() -&gt; (Int, b: Int)  { … }<br>&gt; 	foo(bar())<br>&gt; <br>&gt; <br>&gt; This makes this feature very difficult to use in practice, because you have to _’ize a lot of parameters (violating naming conventions), perform manual shuffling (defeating the sugar benefits of the feature), or add parameter labels to the result of functions (which leads to odd tying between callers and callees).<br>&gt; <br>&gt; <br>&gt; The root problem here is that we use exactly the same syntax for both forms of function application.  If the two forms were differentiated (an option considered in “alternatives considered” below) then some of these problems would be defined away.<br>&gt; <br>&gt; From a historical perspective, the tuple splat form of function application dates back to very early Swift design (probably introduced in 2010, but possibly 2011) where all function application was of a single value to a function type.  For a large number of reasons (including default arguments, variadic arguments, labels, etc) we have completely abandoned this model, but we never came back to reevaluating the tuple splat behavior.<br>&gt; <br>&gt; If we didn’t already have this feature, we would not add it to Swift 3 (at least in its current form).<br>&gt; <br>&gt;  &lt;https://github.com/apple/swift-evolution#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt; The proposed solution is simple, we should just remove this feature from the Swift 3 compiler.  Ideally we would deprecate it in the Swift 2.2 compiler and remove it in Swift 3.  However, if there isn’t time to get the deprecation into Swift 2.2, the author believes it would be perfectly fine to just remove it in Swift 3 (with a fixit + migration help of course).<br>&gt; <br>&gt; One of the interesting aspect of this feature is that some of the people we’ve spoken to are very fond of it.  However, when pressed, they admit that they are not actually using it widely in their code, or if they are using it, they are abusing naming conventions (distorting their code) in order to use it.  This doesn’t seem like a positive contribution - this seems like a “clever” feature, not a practical one.<br>&gt; <br>&gt;  &lt;https://github.com/apple/swift-evolution#detailed-design&gt;Detailed design<br>&gt; <br>&gt; The design is straight-forward.  In the Swift 3 time frame, we continue to parse and type check these expressions as we have so far, but produce an error + fixit hint when it is the tuple splat form.  The migrator would auto-apply the fixit hint as it does for other cases.<br>&gt; <br>&gt;  &lt;https://github.com/apple/swift-evolution#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; Any code that uses this feature will have to move to the traditional form.  In the case of the example above, this means rewriting the code from:<br>&gt; <br>&gt; 	foo(x)<br>&gt; <br>&gt; into a form like this:<br>&gt; <br>&gt; 	foo(x.0, x.b)<br>&gt; <br>&gt; In the case where “x” is a complex expression, a temporary variable will need to be introduced.  We believe that compiler fixits can handle the simple cases directly and that this extension is not widely used.<br>&gt; <br>&gt;  &lt;https://github.com/apple/swift-evolution#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt; The major problem with this feature is that it was not well considered and implemented properly (owing to its very old age, it has just been kept limping along).  The alternative then is to actually design a proper feature to support this.  Since the implicitness and syntactic ambiguity with normal function application is the problem, the solution is to introduce an explicit syntactic form to represent this.  For example, something like this could address the problems we have:<br>&gt; <br>&gt; 	foo(*x)    // NOT a serious syntax proposal<br>&gt; <br>&gt; However, actually designing this feature would be a non-trivial effort not core to the Swift 3 mission:<br>&gt; <br>&gt; * It is a pure-sugar feature, and therefore low priority.<br>&gt; * We don’t have an obvious sigil to use.  “prefix-star” should be kept as unused for now in case we want to use it to refer to memory-related operations in the future.<br>&gt; * Making the tuple splat operation great requires more than just fixing the syntactic ambiguities we have, it would require re-evaluating the semantics of the operation (e.g. in light of parameter labels, varargs and other features).<br>&gt; <br>&gt; If there is serious interest in pursuing this as a concept, we should do it as a follow-on proposal to this one.  If a good design emerges, we can evaluate that design based on its merits.<br>&gt; <br>&gt; <br>&gt; The final alternative is that we could leave the feature in the compiler.  However, that means living with its complexity “forever” or breaking code in the Swift 4 timeframe.  It would be preferable to tackle this breakage in the Swift 3 timeframe, since we know that migration will already be needed then.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/edf25b24/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Proposal: Remove implicit tuple splat behavior from function applications</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January 27, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; Remove implicit tuple splat behavior from function applications<br></p><p>Please do not remove this without providing an alternative.<br></p><p>I use this pretty frequently, usually in combination with higher-order functions like `map` and `filter` when I&#39;m linking together steps in a pipeline. Here&#39;s one example where I&#39;m converting structs into CloudKit objects. I have to perform a series of steps: extract the type and value from the instance (and possibly from its child instances), retrieve or allocate CKRecords for each one, and then write the data into the CKRecords. The top-level flow for this is simply:<br></p><p>    func addInstance(instance: CloudRepresentable, recursively: Bool) throws {<br>        try typeNameAndValueForInstance(instance, recursively: recursively).lazy.map(recordAllocatorWithVersionMemory(versionMemory)).forEach(writeAttributesAndReferencesToRecord)<br>    }<br></p><p>Each step in this process is implemented with a private method whose signature matches the methods before and after. This allows me to name each step and encapsulate the details of how they&#39;re done. Yes, the signatures are slightly contorted, but they&#39;re private methods—implementation details—so it doesn&#39;t matter.<br></p><p>    private func typeNameAndValueForInstance(instance: CloudRepresentable, recursively: Bool) -&gt; [(typeName: String, value: CloudValue)]<br>    private func recordAllocatorWithVersionMemory(versionMemory: CloudDatabaseVersionMemoryType?)(typeName: String, _ cloudValue: CloudValue) throws -&gt; (CKRecord, CloudValue)<br>    private func writeAttributesAndReferencesToRecord(record: CKRecord, cloudValue: CloudValue)<br></p><p>I agree that the implicit splat causes problems sometimes, but I don&#39;t think it should be removed without an alternative. For my uses, simply being able to say `myFunc.apply` for any function (including the ones provided by SomeType.init) would be sufficient. This method could perhaps be overloaded to support all possible combinations of default argument omissions.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>Proposal: Remove implicit tuple splat behavior from function applications</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>January 28, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jan 28, 2016, at 12:30 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Remove implicit tuple splat behavior from function applications<br>&gt; <br>&gt; Please do not remove this without providing an alternative.<br>&gt; <br>&gt; I use this pretty frequently, usually in combination with higher-order functions like `map` and `filter` when I&#39;m linking together steps in a pipeline. Here&#39;s one example where I&#39;m converting structs into CloudKit objects. I have to perform a series of steps: extract the type and value from the instance (and possibly from its child instances), retrieve or allocate CKRecords for each one, and then write the data into the CKRecords. The top-level flow for this is simply:<br>&gt; <br>&gt;    func addInstance(instance: CloudRepresentable, recursively: Bool) throws {<br>&gt;        try typeNameAndValueForInstance(instance, recursively: recursively).lazy.map(recordAllocatorWithVersionMemory(versionMemory)).forEach(writeAttributesAndReferencesToRecord)<br>&gt;    }<br>&gt; <br>&gt; Each step in this process is implemented with a private method whose signature matches the methods before and after. This allows me to name each step and encapsulate the details of how they&#39;re done. Yes, the signatures are slightly contorted, but they&#39;re private methods—implementation details—so it doesn&#39;t matter.<br>&gt; <br>&gt;    private func typeNameAndValueForInstance(instance: CloudRepresentable, recursively: Bool) -&gt; [(typeName: String, value: CloudValue)]<br>&gt;    private func recordAllocatorWithVersionMemory(versionMemory: CloudDatabaseVersionMemoryType?)(typeName: String, _ cloudValue: CloudValue) throws -&gt; (CKRecord, CloudValue)<br>&gt;    private func writeAttributesAndReferencesToRecord(record: CKRecord, cloudValue: CloudValue)<br>&gt; <br>&gt; I agree that the implicit splat causes problems sometimes, but I don&#39;t think it should be removed without an alternative.<br></p><p>Brent — Not sure how it all plays out, but would it work for you to use tuples to make all the functions in your chain take a single arg? e.g.:<br></p><p>   private func recordAllocatorWithVersionMemory(args: (versionMemory: CloudDatabaseVersionMemoryType?, typeName: String, _ cloudValue: CloudValue)) throws -&gt; (CKRecord, CloudValue)<br></p><p>   private func writeAttributesAndReferencesToRecord(args: (record: CKRecord, cloudValue: CloudValue))<br></p><p>P<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Proposal: Remove implicit tuple splat behavior from function applications</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January 28, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; Brent — Not sure how it all plays out, but would it work for you to use tuples to make all the functions in your chain take a single arg? e.g.:<br>&gt; <br>&gt;   private func recordAllocatorWithVersionMemory(args: (versionMemory: CloudDatabaseVersionMemoryType?, typeName: String, _ cloudValue: CloudValue)) throws -&gt; (CKRecord, CloudValue)<br>&gt; <br>&gt;   private func writeAttributesAndReferencesToRecord(args: (record: CKRecord, cloudValue: CloudValue))<br></p><p>Yes, but it would be less elegant. As it is, these are normal functions written to operate on a single model instance, and I just happen to use them with `map` and `forEach` to apply them to many instances. Rewriting them to explicitly take tuples makes the code more awkward. Obviously this ends up boiling down to code style, but I would be very sorry to see the capability to essentially prepare a bunch of argument lists and apply them all to a function go.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: Remove implicit tuple splat behavior from function applications</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 29, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jan 27, 2016, at 10:30 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; Remove implicit tuple splat behavior from function applications<br>&gt; <br>&gt; Please do not remove this without providing an alternative.<br></p><p>I understand the desires, but I don’t think that is the right way to go in this case for three reasons:<br></p><p>1. Proposals should be incremental.  Removing this (very rarely used) feature is a prerequisite to adding its replacement, particularly given that the replacement will have different semantics.<br></p><p>2. The proposed addition of the new feature will have to be self-justified based on the merits of that proposal.  Those merits will depend on the exact design.<br></p><p>3. Shipping Swift 3 with this feature, then changing the feature in Swift 4 would break code.  While Swift 4 will probably break *some* code, we really want to reduce cases that happens.  We *know* this feature is wrong as it is, so it is most conservative to remove it now (accepting the breakage in Swift 3 timeframe) and add it back if/when there is a good proposal.<br></p><p>-Chris <br></p><p><br></p><p><br>&gt; <br>&gt; I use this pretty frequently, usually in combination with higher-order functions like `map` and `filter` when I&#39;m linking together steps in a pipeline. Here&#39;s one example where I&#39;m converting structs into CloudKit objects. I have to perform a series of steps: extract the type and value from the instance (and possibly from its child instances), retrieve or allocate CKRecords for each one, and then write the data into the CKRecords. The top-level flow for this is simply:<br>&gt; <br>&gt;    func addInstance(instance: CloudRepresentable, recursively: Bool) throws {<br>&gt;        try typeNameAndValueForInstance(instance, recursively: recursively).lazy.map(recordAllocatorWithVersionMemory(versionMemory)).forEach(writeAttributesAndReferencesToRecord)<br>&gt;    }<br>&gt; <br>&gt; Each step in this process is implemented with a private method whose signature matches the methods before and after. This allows me to name each step and encapsulate the details of how they&#39;re done. Yes, the signatures are slightly contorted, but they&#39;re private methods—implementation details—so it doesn&#39;t matter.<br>&gt; <br>&gt;    private func typeNameAndValueForInstance(instance: CloudRepresentable, recursively: Bool) -&gt; [(typeName: String, value: CloudValue)]<br>&gt;    private func recordAllocatorWithVersionMemory(versionMemory: CloudDatabaseVersionMemoryType?)(typeName: String, _ cloudValue: CloudValue) throws -&gt; (CKRecord, CloudValue)<br>&gt;    private func writeAttributesAndReferencesToRecord(record: CKRecord, cloudValue: CloudValue)<br>&gt; <br>&gt; I agree that the implicit splat causes problems sometimes, but I don&#39;t think it should be removed without an alternative. For my uses, simply being able to say `myFunc.apply` for any function (including the ones provided by SomeType.init) would be sufficient. This method could perhaps be overloaded to support all possible combinations of default argument omissions.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Proposal: Remove implicit tuple splat behavior from function applications</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>January 30, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; 1. Proposals should be incremental.  Removing this (very rarely used) feature is a prerequisite to adding its replacement, particularly given that the replacement will have different semantics.<br>&quot;Look, boy: First you have to endure a fresh haircut, afterwards we can debate about the merits of visiting the ice cream shop&quot; ;-)<br></p><p>I guess all critics could be silenced easily with a realistic possibility that the feature will be re-added in a later version, so its just a natural reaction to highlight the value of tuple splat now and convince many people that it is a nice concept.<br>If this fails, I predict that reactions on a proposal to add tuple splat will include statements like &quot;didn&#39;t Swift have this in an old version, but removed it because it was bad?&quot;.<br></p><p>A process with small steps is easier to handle and more honest (no one can be sure what will happen until Swift 4, so it&#39;s good to be careful with promises), but it is easier to thrill people with a big picture of the future (it is even more easy to disappoint them with a failed vision — and we already have enough thrill now ;-).<br></p><p>&gt; 2. The proposed addition of the new feature will have to be self-justified based on the merits of that proposal.  Those merits will depend on the exact design.<br>Considering a common reaction on the proposal (&quot;I never used this, get rid of it&quot;), it is hard to foresee how many people would like to add an exotic feature that they haven&#39;t seen in action.<br>But I really hope that decisions in general are not only based on the needs of the majority:<br>Many C++ developers never write templates, and some even hate them — but imho their removal would cripple the language.<br></p><p>Tino<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>Proposal: Remove implicit tuple splat behavior from function applications</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>January 30, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; Considering a common reaction on the proposal (&quot;I never used this, get rid of it&quot;), it is hard to foresee how many people would like to add an exotic feature that they haven&#39;t seen in action.<br>&gt; But I really hope that decisions in general are not only based on the needs of the majority:<br></p><p>I think this list has demonstrated that the majority vote is indicative at most. The final word is still with the Swift design team, and its very good this way :) They have clearly demonstrated their ability to make the right decision.<br></p><p>— Taras<br></p><p>&gt; On 30 Jan 2016, at 12:00, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; 1. Proposals should be incremental.  Removing this (very rarely used) feature is a prerequisite to adding its replacement, particularly given that the replacement will have different semantics.<br>&gt; &quot;Look, boy: First you have to endure a fresh haircut, afterwards we can debate about the merits of visiting the ice cream shop&quot; ;-)<br>&gt; <br>&gt; I guess all critics could be silenced easily with a realistic possibility that the feature will be re-added in a later version, so its just a natural reaction to highlight the value of tuple splat now and convince many people that it is a nice concept.<br>&gt; If this fails, I predict that reactions on a proposal to add tuple splat will include statements like &quot;didn&#39;t Swift have this in an old version, but removed it because it was bad?&quot;.<br>&gt; <br>&gt; A process with small steps is easier to handle and more honest (no one can be sure what will happen until Swift 4, so it&#39;s good to be careful with promises), but it is easier to thrill people with a big picture of the future (it is even more easy to disappoint them with a failed vision — and we already have enough thrill now ;-).<br>&gt; <br>&gt;&gt; 2. The proposed addition of the new feature will have to be self-justified based on the merits of that proposal.  Those merits will depend on the exact design.<br>&gt; Considering a common reaction on the proposal (&quot;I never used this, get rid of it&quot;), it is hard to foresee how many people would like to add an exotic feature that they haven&#39;t seen in action.<br>&gt; But I really hope that decisions in general are not only based on the needs of the majority:<br>&gt; Many C++ developers never write templates, and some even hate them — but imho their removal would cripple the language.<br>&gt; <br>&gt; Tino<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Proposal: Remove implicit tuple splat behavior from function applications</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>January 30, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On 30 Jan 2016, at 11:00, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; 1. Proposals should be incremental.  Removing this (very rarely used) feature is a prerequisite to adding its replacement, particularly given that the replacement will have different semantics.<br>&gt; &quot;Look, boy: First you have to endure a fresh haircut, afterwards we can debate about the merits of visiting the ice cream shop&quot; ;-)<br>&gt; <br>&gt; I guess all critics could be silenced easily with a realistic possibility that the feature will be re-added in a later version, so its just a natural reaction to highlight the value of tuple splat now and convince many people that it is a nice concept.<br>&gt; If this fails, I predict that reactions on a proposal to add tuple splat will include statements like &quot;didn&#39;t Swift have this in an old version, but removed it because it was bad?&quot;.<br>&gt; <br>&gt; A process with small steps is easier to handle and more honest (no one can be sure what will happen until Swift 4, so it&#39;s good to be careful with promises), but it is easier to thrill people with a big picture of the future (it is even more easy to disappoint them with a failed vision — and we already have enough thrill now ;-).<br>&gt; <br>&gt;&gt; 2. The proposed addition of the new feature will have to be self-justified based on the merits of that proposal.  Those merits will depend on the exact design.<br>&gt; Considering a common reaction on the proposal (&quot;I never used this, get rid of it&quot;), it is hard to foresee how many people would like to add an exotic feature that they haven&#39;t seen in action.<br>&gt; But I really hope that decisions in general are not only based on the needs of the majority:<br>&gt; Many C++ developers never write templates, and some even hate them — but imho their removal would cripple the language.<br></p><p>While I don’t personally use the feature (didn’t even know about it until this discussion), I kind of like it, but I also don’t really see what the big deal is with just keeping it? It seems like it should be relatively easy to just replace it when a new version can be designed, so I don’t think there’s much need for it to be done “incrementally” when that means ripping it out with no alternative on the horizon.<br></p><p>Though it may currently lead to confusing code for beginners, and so should be discouraged by convention except where necessary, I don’t think leaving it in really hurts anyone either.<br></p><p>Personally my preference for replacing it would be to add a call() or callWithArgs() method to all functions/closures, which coincides quite nicely with the discussion for explicit closure execution, which would require adding the same kind of functionality anyway, so it might provide a good opportunity to adding a “tuple splat” replacement as well. So basically calls to foo(args) would become foo.call(args) or similar.<br></p><p>So yeah, I think we should consider replacements before removing “tuple splat”, as adding a replacement might not be that much harder than removing the feature, and if the replacement is similar to other features under consideration then it could be a good opportunity to group them together and just do it all in one go.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>Proposal: Remove implicit tuple splat behavior from function applications</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>January 31, 2016 at 03:00:00pm</p></header><div class="content"><p>I&#39;m +1 if there&#39;s a standard library function like this:<br></p><p>    func call&lt;T,R&gt;(params: T, function: T -&gt; R) -&gt; R<br></p><p>I think that should make it clear when you want this behaviour, and allow<br>it to be done in those circumstances. I like the idea of a method on<br>functions, but I don&#39;t think Swift is ready for that yet.<br></p><p>On Sun, Jan 31, 2016 at 5:34 AM, Haravikk via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On 30 Jan 2016, at 11:00, Tino Heth via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt; 1. Proposals should be incremental.  Removing this (very rarely used)<br>&gt; feature is a prerequisite to adding its replacement, particularly given<br>&gt; that the replacement will have different semantics.<br>&gt; &gt; &quot;Look, boy: First you have to endure a fresh haircut, afterwards we can<br>&gt; debate about the merits of visiting the ice cream shop&quot; ;-)<br>&gt; &gt;<br>&gt; &gt; I guess all critics could be silenced easily with a realistic<br>&gt; possibility that the feature will be re-added in a later version, so its<br>&gt; just a natural reaction to highlight the value of tuple splat now and<br>&gt; convince many people that it is a nice concept.<br>&gt; &gt; If this fails, I predict that reactions on a proposal to add tuple splat<br>&gt; will include statements like &quot;didn&#39;t Swift have this in an old version, but<br>&gt; removed it because it was bad?&quot;.<br>&gt; &gt;<br>&gt; &gt; A process with small steps is easier to handle and more honest (no one<br>&gt; can be sure what will happen until Swift 4, so it&#39;s good to be careful with<br>&gt; promises), but it is easier to thrill people with a big picture of the<br>&gt; future (it is even more easy to disappoint them with a failed vision — and<br>&gt; we already have enough thrill now ;-).<br>&gt; &gt;<br>&gt; &gt;&gt; 2. The proposed addition of the new feature will have to be<br>&gt; self-justified based on the merits of that proposal.  Those merits will<br>&gt; depend on the exact design.<br>&gt; &gt; Considering a common reaction on the proposal (&quot;I never used this, get<br>&gt; rid of it&quot;), it is hard to foresee how many people would like to add an<br>&gt; exotic feature that they haven&#39;t seen in action.<br>&gt; &gt; But I really hope that decisions in general are not only based on the<br>&gt; needs of the majority:<br>&gt; &gt; Many C++ developers never write templates, and some even hate them — but<br>&gt; imho their removal would cripple the language.<br>&gt;<br>&gt; While I don’t personally use the feature (didn’t even know about it until<br>&gt; this discussion), I kind of like it, but I also don’t really see what the<br>&gt; big deal is with just keeping it? It seems like it should be relatively<br>&gt; easy to just replace it when a new version can be designed, so I don’t<br>&gt; think there’s much need for it to be done “incrementally” when that means<br>&gt; ripping it out with no alternative on the horizon.<br>&gt;<br>&gt; Though it may currently lead to confusing code for beginners, and so<br>&gt; should be discouraged by convention except where necessary, I don’t think<br>&gt; leaving it in really hurts anyone either.<br>&gt;<br>&gt; Personally my preference for replacing it would be to add a call() or<br>&gt; callWithArgs() method to all functions/closures, which coincides quite<br>&gt; nicely with the discussion for explicit closure execution, which would<br>&gt; require adding the same kind of functionality anyway, so it might provide a<br>&gt; good opportunity to adding a “tuple splat” replacement as well. So<br>&gt; basically calls to foo(args) would become foo.call(args) or similar.<br>&gt;<br>&gt; So yeah, I think we should consider replacements before removing “tuple<br>&gt; splat”, as adding a replacement might not be that much harder than removing<br>&gt; the feature, and if the replacement is similar to other features under<br>&gt; consideration then it could be a good opportunity to group them together<br>&gt; and just do it all in one go.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160131/00098c47/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cc80e78263eebbb13817a36ed5f3a701?s=50"></div><header><strong>Proposal: Remove implicit tuple splat behavior from function applications</strong> from <string>Nikita Leonov</string> &lt;nikita.leonov at gmail.com&gt;<p>January 29, 2016 at 11:00:00pm</p></header><div class="content"><p>+1. Based on experience of splatting use in other languages it has limited applications. I assume feature not well known by Swift community just because of small demand. For those who needs splatting, it can be replicated by existing tooling manually or generalized by something similar to following code:<br>func splat&lt;T, U, R&gt;(f: (T, U) -&gt; R, _ tuple: (T, U)) -&gt; R {<br>    return f(tuple.0, tuple.1)<br>}<br></p><p>Nikita<br></p><p>&gt; On Jan 26, 2016, at 10:23 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; For discussion: comments appreciated!<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; Remove implicit tuple splat behavior from function applications<br>&gt; <br>&gt; Proposal: SE- &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;TBD<br>&gt; Author(s): Chris Lattner<br>&gt; Status: Awaiting review<br>&gt; Review manager: TBD<br>&gt;  &lt;https://github.com/apple/swift-evolution#introduction&gt;Introduction<br>&gt; <br>&gt; Function calls (which include several syntactic forms that apply an argument list to something of function type) currently have a dual nature in Swift.  Given something like:<br>&gt; <br>&gt; <br>&gt; 	func foo(a : Int, b : Int) {}<br>&gt; <br>&gt; <br>&gt; You can call it either with with the typical syntactic form that passes arguments to each of its parameters:<br>&gt; <br>&gt; <br>&gt; 	foo(42, b : 17)<br>&gt; <br>&gt; or you can take advantage of a little-known feature to pass an entire argument list as a single value (of tuple type):<br>&gt; <br>&gt; 	let x = (1, b: 2)<br>&gt; 	foo(x)<br>&gt; <br>&gt; <br>&gt; This proposal recommends removing the later form, which I affectionately refer to as the “tuple splat” form.  This feature is purely a sugar feature, it does not provide any expressive ability beyond passing the parameters manually.<br>&gt; <br>&gt; <br>&gt; Swift-evolution thread: TBD<br>&gt; <br>&gt;  &lt;https://github.com/apple/swift-evolution#motivation&gt;Motivation<br>&gt; <br>&gt; This behavior is cute, precedented in other functional languages, and has some advantages, but it also has several major disadvantages, which are all related to its syntactic form.<br>&gt; <br>&gt; * A call to foo(x) looks like a call to an overloaded version of foo, both to the compiler and to the human who maintains the code.  This is extremely confusing if you don’t know the feature exists.<br>&gt; * There are real ambiguities in the syntax, e.g. involving Any arguments and situations where you want to pass a tuple value as a single parameter.<br>&gt; * The current implementation has a ton of implementation bugs - it doesn’t work reliably.<br>&gt; * The current implementation adds complexity to the type checker, slowing it down and adding maintenance burden.<br>&gt; * The current implementation doesn’t work the way we would want a tuple splat operation to work.  For example, arguably, you should be able to call foo with:<br>&gt; <br>&gt; 	func bar() -&gt; (Int, Int) { … }<br>&gt; 	foo(bar())<br>&gt; <br>&gt; … but this is not allowed, since tuple labels are required to line up.  You have to write:<br>&gt; <br>&gt; <br>&gt; <br>&gt; 	func bar() -&gt; (Int, b: Int)  { … }<br>&gt; 	foo(bar())<br>&gt; <br>&gt; <br>&gt; This makes this feature very difficult to use in practice, because you have to _’ize a lot of parameters (violating naming conventions), perform manual shuffling (defeating the sugar benefits of the feature), or add parameter labels to the result of functions (which leads to odd tying between callers and callees).<br>&gt; <br>&gt; <br>&gt; The root problem here is that we use exactly the same syntax for both forms of function application.  If the two forms were differentiated (an option considered in “alternatives considered” below) then some of these problems would be defined away.<br>&gt; <br>&gt; From a historical perspective, the tuple splat form of function application dates back to very early Swift design (probably introduced in 2010, but possibly 2011) where all function application was of a single value to a function type.  For a large number of reasons (including default arguments, variadic arguments, labels, etc) we have completely abandoned this model, but we never came back to reevaluating the tuple splat behavior.<br>&gt; <br>&gt; If we didn’t already have this feature, we would not add it to Swift 3 (at least in its current form).<br>&gt; <br>&gt;  &lt;https://github.com/apple/swift-evolution#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt; The proposed solution is simple, we should just remove this feature from the Swift 3 compiler.  Ideally we would deprecate it in the Swift 2.2 compiler and remove it in Swift 3.  However, if there isn’t time to get the deprecation into Swift 2.2, the author believes it would be perfectly fine to just remove it in Swift 3 (with a fixit + migration help of course).<br>&gt; <br>&gt; One of the interesting aspect of this feature is that some of the people we’ve spoken to are very fond of it.  However, when pressed, they admit that they are not actually using it widely in their code, or if they are using it, they are abusing naming conventions (distorting their code) in order to use it.  This doesn’t seem like a positive contribution - this seems like a “clever” feature, not a practical one.<br>&gt; <br>&gt;  &lt;https://github.com/apple/swift-evolution#detailed-design&gt;Detailed design<br>&gt; <br>&gt; The design is straight-forward.  In the Swift 3 time frame, we continue to parse and type check these expressions as we have so far, but produce an error + fixit hint when it is the tuple splat form.  The migrator would auto-apply the fixit hint as it does for other cases.<br>&gt; <br>&gt;  &lt;https://github.com/apple/swift-evolution#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; Any code that uses this feature will have to move to the traditional form.  In the case of the example above, this means rewriting the code from:<br>&gt; <br>&gt; 	foo(x)<br>&gt; <br>&gt; into a form like this:<br>&gt; <br>&gt; 	foo(x.0, x.b)<br>&gt; <br>&gt; In the case where “x” is a complex expression, a temporary variable will need to be introduced.  We believe that compiler fixits can handle the simple cases directly and that this extension is not widely used.<br>&gt; <br>&gt;  &lt;https://github.com/apple/swift-evolution#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt; The major problem with this feature is that it was not well considered and implemented properly (owing to its very old age, it has just been kept limping along).  The alternative then is to actually design a proper feature to support this.  Since the implicitness and syntactic ambiguity with normal function application is the problem, the solution is to introduce an explicit syntactic form to represent this.  For example, something like this could address the problems we have:<br>&gt; <br>&gt; 	foo(*x)    // NOT a serious syntax proposal<br>&gt; <br>&gt; However, actually designing this feature would be a non-trivial effort not core to the Swift 3 mission:<br>&gt; <br>&gt; * It is a pure-sugar feature, and therefore low priority.<br>&gt; * We don’t have an obvious sigil to use.  “prefix-star” should be kept as unused for now in case we want to use it to refer to memory-related operations in the future.<br>&gt; * Making the tuple splat operation great requires more than just fixing the syntactic ambiguities we have, it would require re-evaluating the semantics of the operation (e.g. in light of parameter labels, varargs and other features).<br>&gt; <br>&gt; If there is serious interest in pursuing this as a concept, we should do it as a follow-on proposal to this one.  If a good design emerges, we can evaluate that design based on its merits.<br>&gt; <br>&gt; <br>&gt; The final alternative is that we could leave the feature in the compiler.  However, that means living with its complexity “forever” or breaking code in the Swift 4 timeframe.  It would be preferable to tackle this breakage in the Swift 3 timeframe, since we know that migration will already be needed then.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/5c92523b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Proposal: Remove implicit tuple splat behavior from function applications</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>January 30, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; +1. Based on experience of splatting use in other languages it has limited applications. I assume feature not well known by Swift community just because of small demand. For those who needs splatting, it can be replicated by existing tooling manually or generalized by something similar to following code:<br>&gt; func splat&lt;T, U, R&gt;(f: (T, U) -&gt; R, _ tuple: (T, U)) -&gt; R {<br>&gt;     return f(tuple.0, tuple.1)<br>&gt; }<br></p><p>If a set of splat functions would be available in stdlib, they could act as a temporary stand-in, but it is a poor replacement:<br>The beauty of splat is that it works for functions with an arbitrary number of parameters out of the box, and it is most useful when you have many parameters (something that is very uncommon in Cocoa — but I expect that this won&#39;t be true for new libraries that make use of default parameter values).<br>Swift has many convenience features and overlapping functionality, but tuple splat is singular and can&#39;t be replaced with other constructs.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160130/4d0f47b1/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b660eecceda60138f137d353b8289925?s=50"></div><header><strong>Proposal: Remove implicit tuple splat behavior from function applications</strong> from <string>Janosch Hildebrand</string> &lt;jnosh at jnosh.com&gt;<p>January 31, 2016 at 07:00:00pm</p></header><div class="content"><p>+1 to the existing proposal.<br></p><p><br>On a related note, would this also affect the implicit &quot;argument-list to tuple&quot; conversion?<br>To give an example:<br></p><p>var array: [(Int, Int)] = []<br>var int_var = 1<br>let int_let = 1<br></p><p>// These obviously work<br>array.append((int_let, 1))<br>array.append((1, 1))<br>array.append((int_var, 1))<br>array.append((int_var, int_var))<br></p><p><br>// The following have worked to varying degrees over Swift&#39;s (public) lifetime<br>// Currently only the first example compiles<br>array.append(int_let, int_let)<br>array.append(int_let, 1)<br>array.append(1, 1)<br>array.append(int_var, 1)<br>array.append(int_var, int_var)<br></p><p>This is in a way the reverse of splatting but IMO equally troublesome at least in it&#39;s current form.<br>And it also presumes some form of equivalence between function argument lists and tuples.<br></p><p>So my question is does the proposal already cover removing this behaviour (in which case +1)?<br>Or else, could this be added to the proposal or would this need a separate proposal entirely?<br></p><p>- Janosch<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: Remove implicit tuple splat behavior from function applications</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 31, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jan 31, 2016, at 10:35 AM, Janosch Hildebrand &lt;jnosh at jnosh.com&gt; wrote:<br>&gt; <br>&gt; +1 to the existing proposal.<br>&gt; <br>&gt; <br>&gt; On a related note, would this also affect the implicit &quot;argument-list to tuple&quot; conversion?<br>&gt; To give an example:<br>&gt; <br>&gt; var array: [(Int, Int)] = []<br>&gt; var int_var = 1<br>&gt; let int_let = 1<br>&gt; <br>&gt; // These obviously work<br>&gt; array.append((int_let, 1))<br>&gt; array.append((1, 1))<br>&gt; array.append((int_var, 1))<br>&gt; array.append((int_var, int_var))<br></p><p>Yes, these should all work.<br></p><p>&gt; // The following have worked to varying degrees over Swift&#39;s (public) lifetime<br>&gt; // Currently only the first example compiles<br>&gt; array.append(int_let, int_let)<br></p><p>it is a bug that this first one compiles, it is an example of the flakiness caused by this.  This is the inverse of splat :-)<br></p><p>&gt; array.append(int_let, 1)<br>&gt; array.append(1, 1)<br>&gt; array.append(int_var, 1)<br>&gt; array.append(int_var, int_var)<br></p><p>These should all be uniformly rejected, since append takes one parameter.<br></p><p>&gt; This is in a way the reverse of splatting but IMO equally troublesome at least in it&#39;s current form.<br>&gt; And it also presumes some form of equivalence between function argument lists and tuples.<br>&gt; <br>&gt; So my question is does the proposal already cover removing this behaviour (in which case +1)?<br></p><p>Yes, even with the current design, this is a bug.  As I mentioned, the tuple “splat” feature has a number of bugs.<br></p><p>-Chris<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
