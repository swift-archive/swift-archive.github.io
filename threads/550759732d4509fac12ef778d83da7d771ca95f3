<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>June  2, 2016 at 09:00:00am</p></header><div class="content"><p>The official way to build a literal of a specific type is to write the literal in an explicitly-typed context, like so:<br>    let x: UInt16 = 7<br>or<br>    let x = 7 as UInt16<br></p><p>Nonetheless, programmers often try the following:<br>    UInt16(7)<br></p><p>Unfortunately, this does not attempt to construct the value using the appropriate literal protocol; it instead performs overload resolution using the standard rules, i.e. considering only single-argument unlabelled initializers of a type which conforms to IntegerLiteralConvertible.  Often this leads to static ambiguities or, worse, causes the literal to be built using a default type (such as Int); this may have semantically very different results which are only caught at runtime.<br></p><p>In my opinion, using this initializer-call syntax to build an explicitly-typed literal is an obvious and natural choice with several advantages over the &quot;as&quot; syntax.  However, even if you disagree, it&#39;s clear that programmers are going to continue to independently try to use it, so it&#39;s really unfortunate for it to be subtly wrong.<br></p><p>Therefore, I propose that we adopt the following typing rule:<br></p><p>  Given a function call expression of the form A(B) (that is, an expr-call with a single, unlabelled argument) where B is an expr-literal or expr-collection, if A has type T.Type for some type T and there is a declared conformance of T to an appropriate literal protocol for B, then the expression is always resolves as a literal construction of type T (as if the expression were written &quot;B as A&quot;) rather than as a general initializer call.<br></p><p>Formally, this would be a special form of the argument conversion constraint, since the type of the expression A may not be immediately known.<br></p><p>Note that, as specified, it is possible to suppress this typing rule by wrapping the literal in parentheses.  This might seem distasteful; it would be easy enough to allow the form of B to include extra parentheses.  It&#39;s potentially useful to have a way to suppress this rule and get a normal construction, but there are several other ways of getting that effect, such as explicitly typing the literal argument (e.g. writing &quot;A(Int(B))&quot;).<br></p><p>A conditional conformance counts as a declared conformance even if the generic arguments are known to not satisfy the conditional conformance.  This permits the applicability of the rule to be decided without having to first decide the type arguments, which greatly simplifies the type-checking problem (and may be necessary for soundness; I didn&#39;t explore this in depth, but it certainly feels like a very nasty sort of dependence).  We could potentially weaken this for cases where A is a direct type reference with bound parameters, e.g. Foo&lt;Int&gt;([]) or the same with a typealias, but I think there&#39;s some benefit from having a simpler specification, both for the implementation and for the explicability of the model.<br></p><p>John.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/550795f3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>June  2, 2016 at 12:00:00pm</p></header><div class="content"><p>I’m not entirely sure what an “expr-collection” is. Does your proposal mean that in this code:<br>func foo() -&gt; Int {...}<br>var w = 0<br>var x = T(foo())<br>var y = T(w)<br>var z = T(0)<br>different initializers would be used for `x`,`y`, and `z`? If so, that seems a potential source of much subtler problems.<br></p><p>I don’t disagree that you’ve identified a potential source of issues, but it’s conceivable that there might be circumstances where the &quot;semantically very different results” are desired. I can’t think of any off the top of my head, but I’m not convinced that means they don’t exist.<br></p><p>So… I’m tentatively -1<br></p><p>- Dave Sweeris<br></p><p>&gt; On Jun 2, 2016, at 11:08 AM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The official way to build a literal of a specific type is to write the literal in an explicitly-typed context, like so:<br>&gt;     let x: UInt16 = 7<br>&gt; or<br>&gt;     let x = 7 as UInt16<br>&gt; <br>&gt; Nonetheless, programmers often try the following:<br>&gt;     UInt16(7)<br>&gt; <br>&gt; Unfortunately, this does not attempt to construct the value using the appropriate literal protocol; it instead performs overload resolution using the standard rules, i.e. considering only single-argument unlabelled initializers of a type which conforms to IntegerLiteralConvertible.  Often this leads to static ambiguities or, worse, causes the literal to be built using a default type (such as Int); this may have semantically very different results which are only caught at runtime.<br>&gt; <br>&gt; In my opinion, using this initializer-call syntax to build an explicitly-typed literal is an obvious and natural choice with several advantages over the &quot;as&quot; syntax.  However, even if you disagree, it&#39;s clear that programmers are going to continue to independently try to use it, so it&#39;s really unfortunate for it to be subtly wrong.<br>&gt; <br>&gt; Therefore, I propose that we adopt the following typing rule:<br>&gt; <br>&gt;   Given a function call expression of the form A(B) (that is, an expr-call with a single, unlabelled argument) where B is an expr-literal or expr-collection, if A has type T.Type for some type T and there is a declared conformance of T to an appropriate literal protocol for B, then the expression is always resolves as a literal construction of type T (as if the expression were written &quot;B as A&quot;) rather than as a general initializer call.<br>&gt; <br>&gt; Formally, this would be a special form of the argument conversion constraint, since the type of the expression A may not be immediately known.<br>&gt; <br>&gt; Note that, as specified, it is possible to suppress this typing rule by wrapping the literal in parentheses.  This might seem distasteful; it would be easy enough to allow the form of B to include extra parentheses.  It&#39;s potentially useful to have a way to suppress this rule and get a normal construction, but there are several other ways of getting that effect, such as explicitly typing the literal argument (e.g. writing &quot;A(Int(B))&quot;).<br>&gt; <br>&gt; A conditional conformance counts as a declared conformance even if the generic arguments are known to not satisfy the conditional conformance.  This permits the applicability of the rule to be decided without having to first decide the type arguments, which greatly simplifies the type-checking problem (and may be necessary for soundness; I didn&#39;t explore this in depth, but it certainly feels like a very nasty sort of dependence).  We could potentially weaken this for cases where A is a direct type reference with bound parameters, e.g. Foo&lt;Int&gt;([]) or the same with a typealias, but I think there&#39;s some benefit from having a simpler specification, both for the implementation and for the explicability of the model.<br>&gt; <br>&gt; John.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/12c0ba4f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>June  2, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jun 2, 2016, at 10:49 AM, David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt; I’m not entirely sure what an “expr-collection” is.<br></p><p>Collection literals, e.g. [x,y,z] and [a: x, b: y].<br></p><p>&gt; Does your proposal mean that in this code:<br>&gt; func foo() -&gt; Int {...}<br>&gt; var w = 0<br>&gt; var x = T(foo())<br>&gt; var y = T(w)<br>&gt; var z = T(0)<br>&gt; different initializers would be used for `x`,`y`, and `z`?<br></p><p>z would be initialized using the literal initializer if T conforms to that protocol, yes.<br></p><p>&gt; If so, that seems a potential source of much subtler problems.<br></p><p>Note that this is only an issue for types that conform to the literal protocols.<br></p><p>&gt; I don’t disagree that you’ve identified a potential source of issues, but it’s conceivable that there might be circumstances where the &quot;semantically very different results” are desired. I can’t think of any off the top of my head, but I’m not convinced that means they don’t exist.<br></p><p>I do not think that anybody writes UInt64(0) and *wants* the 0 to be built as an Int and then coerced to UInt64.<br></p><p>John.<br></p><p>&gt; <br>&gt; So… I’m tentatively -1<br>&gt; <br>&gt; - Dave Sweeris<br>&gt; <br>&gt;&gt; On Jun 2, 2016, at 11:08 AM, John McCall via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The official way to build a literal of a specific type is to write the literal in an explicitly-typed context, like so:<br>&gt;&gt;     let x: UInt16 = 7<br>&gt;&gt; or<br>&gt;&gt;     let x = 7 as UInt16<br>&gt;&gt; <br>&gt;&gt; Nonetheless, programmers often try the following:<br>&gt;&gt;     UInt16(7)<br>&gt;&gt; <br>&gt;&gt; Unfortunately, this does not attempt to construct the value using the appropriate literal protocol; it instead performs overload resolution using the standard rules, i.e. considering only single-argument unlabelled initializers of a type which conforms to IntegerLiteralConvertible.  Often this leads to static ambiguities or, worse, causes the literal to be built using a default type (such as Int); this may have semantically very different results which are only caught at runtime.<br>&gt;&gt; <br>&gt;&gt; In my opinion, using this initializer-call syntax to build an explicitly-typed literal is an obvious and natural choice with several advantages over the &quot;as&quot; syntax.  However, even if you disagree, it&#39;s clear that programmers are going to continue to independently try to use it, so it&#39;s really unfortunate for it to be subtly wrong.<br>&gt;&gt; <br>&gt;&gt; Therefore, I propose that we adopt the following typing rule:<br>&gt;&gt; <br>&gt;&gt;   Given a function call expression of the form A(B) (that is, an expr-call with a single, unlabelled argument) where B is an expr-literal or expr-collection, if A has type T.Type for some type T and there is a declared conformance of T to an appropriate literal protocol for B, then the expression is always resolves as a literal construction of type T (as if the expression were written &quot;B as A&quot;) rather than as a general initializer call.<br>&gt;&gt; <br>&gt;&gt; Formally, this would be a special form of the argument conversion constraint, since the type of the expression A may not be immediately known.<br>&gt;&gt; <br>&gt;&gt; Note that, as specified, it is possible to suppress this typing rule by wrapping the literal in parentheses.  This might seem distasteful; it would be easy enough to allow the form of B to include extra parentheses.  It&#39;s potentially useful to have a way to suppress this rule and get a normal construction, but there are several other ways of getting that effect, such as explicitly typing the literal argument (e.g. writing &quot;A(Int(B))&quot;).<br>&gt;&gt; <br>&gt;&gt; A conditional conformance counts as a declared conformance even if the generic arguments are known to not satisfy the conditional conformance.  This permits the applicability of the rule to be decided without having to first decide the type arguments, which greatly simplifies the type-checking problem (and may be necessary for soundness; I didn&#39;t explore this in depth, but it certainly feels like a very nasty sort of dependence).  We could potentially weaken this for cases where A is a direct type reference with bound parameters, e.g. Foo&lt;Int&gt;([]) or the same with a typealias, but I think there&#39;s some benefit from having a simpler specification, both for the implementation and for the explicability of the model.<br>&gt;&gt; <br>&gt;&gt; John.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/59513022/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>June  2, 2016 at 03:00:00pm</p></header><div class="content"><p>Would it be possible to have a warning on usage if there is an ambiguity here?<br></p><p>Otherwise, if we want T(0) to work, shouldn&#39;t we change the initializer signatures for LiteralConvertibles to match the desired behavior, rather than make it a special case?<br></p><p>-DW<br></p><p>&gt; On Jun 2, 2016, at 1:57 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Jun 2, 2016, at 10:49 AM, David Sweeris &lt;davesweeris at mac.com &lt;mailto:davesweeris at mac.com&gt;&gt; wrote:<br>&gt;&gt; I’m not entirely sure what an “expr-collection” is.<br>&gt; <br>&gt; Collection literals, e.g. [x,y,z] and [a: x, b: y].<br>&gt; <br>&gt;&gt; Does your proposal mean that in this code:<br>&gt;&gt; func foo() -&gt; Int {...}<br>&gt;&gt; var w = 0<br>&gt;&gt; var x = T(foo())<br>&gt;&gt; var y = T(w)<br>&gt;&gt; var z = T(0)<br>&gt;&gt; different initializers would be used for `x`,`y`, and `z`?<br>&gt; <br>&gt; z would be initialized using the literal initializer if T conforms to that protocol, yes.<br>&gt; <br>&gt;&gt; If so, that seems a potential source of much subtler problems.<br>&gt; <br>&gt; Note that this is only an issue for types that conform to the literal protocols.<br>&gt; <br>&gt;&gt; I don’t disagree that you’ve identified a potential source of issues, but it’s conceivable that there might be circumstances where the &quot;semantically very different results” are desired. I can’t think of any off the top of my head, but I’m not convinced that means they don’t exist.<br>&gt; <br>&gt; I do not think that anybody writes UInt64(0) and *wants* the 0 to be built as an Int and then coerced to UInt64.<br>&gt; <br>&gt; John.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; So… I’m tentatively -1<br>&gt;&gt; <br>&gt;&gt; - Dave Sweeris<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 2, 2016, at 11:08 AM, John McCall via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The official way to build a literal of a specific type is to write the literal in an explicitly-typed context, like so:<br>&gt;&gt;&gt;     let x: UInt16 = 7<br>&gt;&gt;&gt; or<br>&gt;&gt;&gt;     let x = 7 as UInt16<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Nonetheless, programmers often try the following:<br>&gt;&gt;&gt;     UInt16(7)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Unfortunately, this does not attempt to construct the value using the appropriate literal protocol; it instead performs overload resolution using the standard rules, i.e. considering only single-argument unlabelled initializers of a type which conforms to IntegerLiteralConvertible.  Often this leads to static ambiguities or, worse, causes the literal to be built using a default type (such as Int); this may have semantically very different results which are only caught at runtime.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In my opinion, using this initializer-call syntax to build an explicitly-typed literal is an obvious and natural choice with several advantages over the &quot;as&quot; syntax.  However, even if you disagree, it&#39;s clear that programmers are going to continue to independently try to use it, so it&#39;s really unfortunate for it to be subtly wrong.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Therefore, I propose that we adopt the following typing rule:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   Given a function call expression of the form A(B) (that is, an expr-call with a single, unlabelled argument) where B is an expr-literal or expr-collection, if A has type T.Type for some type T and there is a declared conformance of T to an appropriate literal protocol for B, then the expression is always resolves as a literal construction of type T (as if the expression were written &quot;B as A&quot;) rather than as a general initializer call.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Formally, this would be a special form of the argument conversion constraint, since the type of the expression A may not be immediately known.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Note that, as specified, it is possible to suppress this typing rule by wrapping the literal in parentheses.  This might seem distasteful; it would be easy enough to allow the form of B to include extra parentheses.  It&#39;s potentially useful to have a way to suppress this rule and get a normal construction, but there are several other ways of getting that effect, such as explicitly typing the literal argument (e.g. writing &quot;A(Int(B))&quot;).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A conditional conformance counts as a declared conformance even if the generic arguments are known to not satisfy the conditional conformance.  This permits the applicability of the rule to be decided without having to first decide the type arguments, which greatly simplifies the type-checking problem (and may be necessary for soundness; I didn&#39;t explore this in depth, but it certainly feels like a very nasty sort of dependence).  We could potentially weaken this for cases where A is a direct type reference with bound parameters, e.g. Foo&lt;Int&gt;([]) or the same with a typealias, but I think there&#39;s some benefit from having a simpler specification, both for the implementation and for the explicability of the model.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; John.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/3a0e8efb/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 496 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/3a0e8efb/attachment.sig&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>June  2, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jun 2, 2016, at 12:57 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Jun 2, 2016, at 10:49 AM, David Sweeris &lt;davesweeris at mac.com &lt;mailto:davesweeris at mac.com&gt;&gt; wrote:<br>&gt;&gt; I’m not entirely sure what an “expr-collection” is.<br>&gt; <br>&gt; Collection literals, e.g. [x,y,z] and [a: x, b: y].<br>Thought so, but I wasn’t sure. Thanks for clarifying :-)<br></p><p>&gt; <br>&gt;&gt; Does your proposal mean that in this code:<br>&gt;&gt; func foo() -&gt; Int {...}<br>&gt;&gt; var w = 0<br>&gt;&gt; var x = T(foo())<br>&gt;&gt; var y = T(w)<br>&gt;&gt; var z = T(0)<br>&gt;&gt; different initializers would be used for `x`,`y`, and `z`?<br>&gt; <br>&gt; z would be initialized using the literal initializer if T conforms to that protocol, yes.<br>&gt; <br>&gt;&gt; If so, that seems a potential source of much subtler problems.<br>&gt; <br>&gt; Note that this is only an issue for types that conform to the literal protocols.<br></p><p>Oh, I know. The crux of my concern is that while the difference between `UInt16(7)` and `7 as UInt16` is subtle, it’s not that subtle… the literal convertible syntax doesn’t even look that much like a call to init, so it shouldn’t be that surprising if explicitly calling the init function might send you down a different code path. OTOH, this proposal silently (and invisibly) rewrites an explicit call to`init(_: Int)` to `init(integerLiteral: IntegerLiteralType)`, which seems worse. Again, I don’t disagree that there’s a subtlety here, but at least with the current behavior, the unexpected behavior comes from not paying attention to syntax.<br></p><p>&gt;&gt; I don’t disagree that you’ve identified a potential source of issues, but it’s conceivable that there might be circumstances where the &quot;semantically very different results” are desired. I can’t think of any off the top of my head, but I’m not convinced that means they don’t exist.<br>&gt; <br>&gt; I do not think that anybody writes UInt64(0) and *wants* the 0 to be built as an Int and then coerced to UInt64.<br></p><p>I can’t think of why anyone would either — all my *LiteralConvertible types just pass on the literal arguments to an init that takes an Int (or whatever) — but “a failure of imagination…”<br></p><p>I guess I’m just saying that with the way Swift treats literals, potential confusion is inevitable, and that it’s better to contain the subtleties to syntax which already involves some implicit behavior, rather than to start rewriting explicit code simply because we think the programmer doesn’t know what they’re doing.<br></p><p>- Dave Sweeris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/5ed1b28e/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4a9841be165fb834d08296761b4a32e3?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>Christopher Kornher</string> &lt;ckornher at me.com&gt;<p>June  2, 2016 at 12:00:00pm</p></header><div class="content"><p>+1<br> I have started using the ‘()’ syntax without even thinking about it. I never knew that it behaved in the way described. Using ‘()’ syntax will be natural for anyone with C++ experience.<br></p><p><br>&gt; On Jun 2, 2016, at 10:08 AM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The official way to build a literal of a specific type is to write the literal in an explicitly-typed context, like so:<br>&gt;     let x: UInt16 = 7<br>&gt; or<br>&gt;     let x = 7 as UInt16<br>&gt; <br>&gt; Nonetheless, programmers often try the following:<br>&gt;     UInt16(7)<br>&gt; <br>&gt; Unfortunately, this does not attempt to construct the value using the appropriate literal protocol; it instead performs overload resolution using the standard rules, i.e. considering only single-argument unlabelled initializers of a type which conforms to IntegerLiteralConvertible.  Often this leads to static ambiguities or, worse, causes the literal to be built using a default type (such as Int); this may have semantically very different results which are only caught at runtime.<br>&gt; <br>&gt; In my opinion, using this initializer-call syntax to build an explicitly-typed literal is an obvious and natural choice with several advantages over the &quot;as&quot; syntax.  However, even if you disagree, it&#39;s clear that programmers are going to continue to independently try to use it, so it&#39;s really unfortunate for it to be subtly wrong.<br>&gt; <br>&gt; Therefore, I propose that we adopt the following typing rule:<br>&gt; <br>&gt;   Given a function call expression of the form A(B) (that is, an expr-call with a single, unlabelled argument) where B is an expr-literal or expr-collection, if A has type T.Type for some type T and there is a declared conformance of T to an appropriate literal protocol for B, then the expression is always resolves as a literal construction of type T (as if the expression were written &quot;B as A&quot;) rather than as a general initializer call.<br>&gt; <br>&gt; Formally, this would be a special form of the argument conversion constraint, since the type of the expression A may not be immediately known.<br>&gt; <br>&gt; Note that, as specified, it is possible to suppress this typing rule by wrapping the literal in parentheses.  This might seem distasteful; it would be easy enough to allow the form of B to include extra parentheses.  It&#39;s potentially useful to have a way to suppress this rule and get a normal construction, but there are several other ways of getting that effect, such as explicitly typing the literal argument (e.g. writing &quot;A(Int(B))&quot;).<br>&gt; <br>&gt; A conditional conformance counts as a declared conformance even if the generic arguments are known to not satisfy the conditional conformance.  This permits the applicability of the rule to be decided without having to first decide the type arguments, which greatly simplifies the type-checking problem (and may be necessary for soundness; I didn&#39;t explore this in depth, but it certainly feels like a very nasty sort of dependence).  We could potentially weaken this for cases where A is a direct type reference with bound parameters, e.g. Foo&lt;Int&gt;([]) or the same with a typealias, but I think there&#39;s some benefit from having a simpler specification, both for the implementation and for the explicability of the model.<br>&gt; <br>&gt; John.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/cb4702c8/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June  2, 2016 at 01:00:00pm</p></header><div class="content"><p>+1 to this.  It seems like a very straightforward thing to do.<br></p><p>Sent from my iPad<br></p><p>&gt; On Jun 2, 2016, at 11:08 AM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The official way to build a literal of a specific type is to write the literal in an explicitly-typed context, like so:<br>&gt;     let x: UInt16 = 7<br>&gt; or<br>&gt;     let x = 7 as UInt16<br>&gt; <br>&gt; Nonetheless, programmers often try the following:<br>&gt;     UInt16(7)<br>&gt; <br>&gt; Unfortunately, this does not attempt to construct the value using the appropriate literal protocol; it instead performs overload resolution using the standard rules, i.e. considering only single-argument unlabelled initializers of a type which conforms to IntegerLiteralConvertible.  Often this leads to static ambiguities or, worse, causes the literal to be built using a default type (such as Int); this may have semantically very different results which are only caught at runtime.<br>&gt; <br>&gt; In my opinion, using this initializer-call syntax to build an explicitly-typed literal is an obvious and natural choice with several advantages over the &quot;as&quot; syntax.  However, even if you disagree, it&#39;s clear that programmers are going to continue to independently try to use it, so it&#39;s really unfortunate for it to be subtly wrong.<br>&gt; <br>&gt; Therefore, I propose that we adopt the following typing rule:<br>&gt; <br>&gt;   Given a function call expression of the form A(B) (that is, an expr-call with a single, unlabelled argument) where B is an expr-literal or expr-collection, if A has type T.Type for some type T and there is a declared conformance of T to an appropriate literal protocol for B, then the expression is always resolves as a literal construction of type T (as if the expression were written &quot;B as A&quot;) rather than as a general initializer call.<br>&gt; <br>&gt; Formally, this would be a special form of the argument conversion constraint, since the type of the expression A may not be immediately known.<br>&gt; <br>&gt; Note that, as specified, it is possible to suppress this typing rule by wrapping the literal in parentheses.  This might seem distasteful; it would be easy enough to allow the form of B to include extra parentheses.  It&#39;s potentially useful to have a way to suppress this rule and get a normal construction, but there are several other ways of getting that effect, such as explicitly typing the literal argument (e.g. writing &quot;A(Int(B))&quot;).<br>&gt; <br>&gt; A conditional conformance counts as a declared conformance even if the generic arguments are known to not satisfy the conditional conformance.  This permits the applicability of the rule to be decided without having to first decide the type arguments, which greatly simplifies the type-checking problem (and may be necessary for soundness; I didn&#39;t explore this in depth, but it certainly feels like a very nasty sort of dependence).  We could potentially weaken this for cases where A is a direct type reference with bound parameters, e.g. Foo&lt;Int&gt;([]) or the same with a typealias, but I think there&#39;s some benefit from having a simpler specification, both for the implementation and for the explicability of the model.<br>&gt; <br>&gt; John.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/2ab7b251/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>June  2, 2016 at 11:00:00am</p></header><div class="content"><p>+1.<br></p><p>The primary advantage is that it aligns the language semantics with how<br>most programmers expect this common C-language-family idiom to behave and<br>removes a potential source of silently wrong code.<br></p><p>The primary disadvantage is that it introduces special-case behavior to<br>certain types of initializers (although, to be fair, this special-case<br>behavior is easily recognizable: unlabeled one-argument initializer with a<br>literal as the argument).<br></p><p>I think the advantage outweighs the disadvantage.<br></p><p>This problem should be addressed one way or another. I prefer this<br>solution, but if it is rejected for whatever reason we should at least<br>explicitly outlaw A(literal) syntax in favor of &quot;literal as A&quot;.<br></p><p>Austin<br></p><p>On Thu, Jun 2, 2016 at 9:08 AM, John McCall via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; The official way to build a literal of a specific type is to write the<br>&gt; literal in an explicitly-typed context, like so:<br>&gt;     let x: UInt16 = 7<br>&gt; or<br>&gt;     let x = 7 as UInt16<br>&gt;<br>&gt; Nonetheless, programmers often try the following:<br>&gt;     UInt16(7)<br>&gt;<br>&gt; Unfortunately, this does *not* attempt to construct the value using the<br>&gt; appropriate literal protocol; it instead performs overload resolution using<br>&gt; the standard rules, i.e. considering only single-argument unlabelled<br>&gt; initializers of a type which conforms to IntegerLiteralConvertible.  Often<br>&gt; this leads to static ambiguities or, worse, causes the literal to be built<br>&gt; using a default type (such as Int); this may have semantically very<br>&gt; different results which are only caught at runtime.<br>&gt;<br>&gt; In my opinion, using this initializer-call syntax to build an<br>&gt; explicitly-typed literal is an obvious and natural choice with several<br>&gt; advantages over the &quot;as&quot; syntax.  However, even if you disagree, it&#39;s clear<br>&gt; that programmers are going to continue to independently try to use it, so<br>&gt; it&#39;s really unfortunate for it to be subtly wrong.<br>&gt;<br>&gt; Therefore, I propose that we adopt the following typing rule:<br>&gt;<br>&gt;   Given a function call expression of the form A(B) (that is, an<br>&gt; *expr-call* with a single, unlabelled argument) where B is an<br>&gt; *expr-literal* or *expr-collection*, if A has type T.Type for some type T<br>&gt; and there is a declared conformance of T to an appropriate literal protocol<br>&gt; for B, then the expression is always resolves as a literal construction of<br>&gt; type T (as if the expression were written &quot;B as A&quot;) rather than as a<br>&gt; general initializer call.<br>&gt;<br>&gt; Formally, this would be a special form of the argument conversion<br>&gt; constraint, since the type of the expression A may not be immediately known.<br>&gt;<br>&gt; Note that, as specified, it is possible to suppress this typing rule by<br>&gt; wrapping the literal in parentheses.  This might seem distasteful; it would<br>&gt; be easy enough to allow the form of B to include extra parentheses.  It&#39;s<br>&gt; potentially useful to have a way to suppress this rule and get a normal<br>&gt; construction, but there are several other ways of getting that effect, such<br>&gt; as explicitly typing the literal argument (e.g. writing &quot;A(Int(B))&quot;).<br>&gt;<br>&gt; A conditional conformance counts as a declared conformance even if the<br>&gt; generic arguments are known to not satisfy the conditional conformance.<br>&gt; This permits the applicability of the rule to be decided without having to<br>&gt; first decide the type arguments, which greatly simplifies the type-checking<br>&gt; problem (and may be necessary for soundness; I didn&#39;t explore this in<br>&gt; depth, but it certainly feels like a very nasty sort of dependence).  We<br>&gt; could potentially weaken this for cases where A is a direct type reference<br>&gt; with bound parameters, e.g. Foo&lt;Int&gt;([]) or the same with a typealias, but<br>&gt; I think there&#39;s some benefit from having a simpler specification, both for<br>&gt; the implementation and for the explicability of the model.<br>&gt;<br>&gt; John.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/3647dbd0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>June  2, 2016 at 01:00:00pm</p></header><div class="content"><p>+1<br></p><p>l8r<br>Sean<br></p><p><br>&gt; On Jun 2, 2016, at 1:46 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; +1.<br>&gt; <br>&gt; The primary advantage is that it aligns the language semantics with how most programmers expect this common C-language-family idiom to behave and removes a potential source of silently wrong code.<br>&gt; <br>&gt; The primary disadvantage is that it introduces special-case behavior to certain types of initializers (although, to be fair, this special-case behavior is easily recognizable: unlabeled one-argument initializer with a literal as the argument).<br>&gt; <br>&gt; I think the advantage outweighs the disadvantage.<br>&gt; <br>&gt; This problem should be addressed one way or another. I prefer this solution, but if it is rejected for whatever reason we should at least explicitly outlaw A(literal) syntax in favor of &quot;literal as A&quot;.<br>&gt; <br>&gt; Austin<br>&gt; <br>&gt; On Thu, Jun 2, 2016 at 9:08 AM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; The official way to build a literal of a specific type is to write the literal in an explicitly-typed context, like so:<br>&gt;     let x: UInt16 = 7<br>&gt; or<br>&gt;     let x = 7 as UInt16<br>&gt; <br>&gt; Nonetheless, programmers often try the following:<br>&gt;     UInt16(7)<br>&gt; <br>&gt; Unfortunately, this does not attempt to construct the value using the appropriate literal protocol; it instead performs overload resolution using the standard rules, i.e. considering only single-argument unlabelled initializers of a type which conforms to IntegerLiteralConvertible.  Often this leads to static ambiguities or, worse, causes the literal to be built using a default type (such as Int); this may have semantically very different results which are only caught at runtime.<br>&gt; <br>&gt; In my opinion, using this initializer-call syntax to build an explicitly-typed literal is an obvious and natural choice with several advantages over the &quot;as&quot; syntax.  However, even if you disagree, it&#39;s clear that programmers are going to continue to independently try to use it, so it&#39;s really unfortunate for it to be subtly wrong.<br>&gt; <br>&gt; Therefore, I propose that we adopt the following typing rule:<br>&gt; <br>&gt;   Given a function call expression of the form A(B) (that is, an expr-call with a single, unlabelled argument) where B is an expr-literal or expr-collection, if A has type T.Type for some type T and there is a declared conformance of T to an appropriate literal protocol for B, then the expression is always resolves as a literal construction of type T (as if the expression were written &quot;B as A&quot;) rather than as a general initializer call.<br>&gt; <br>&gt; Formally, this would be a special form of the argument conversion constraint, since the type of the expression A may not be immediately known.<br>&gt; <br>&gt; Note that, as specified, it is possible to suppress this typing rule by wrapping the literal in parentheses.  This might seem distasteful; it would be easy enough to allow the form of B to include extra parentheses.  It&#39;s potentially useful to have a way to suppress this rule and get a normal construction, but there are several other ways of getting that effect, such as explicitly typing the literal argument (e.g. writing &quot;A(Int(B))&quot;).<br>&gt; <br>&gt; A conditional conformance counts as a declared conformance even if the generic arguments are known to not satisfy the conditional conformance.  This permits the applicability of the rule to be decided without having to first decide the type arguments, which greatly simplifies the type-checking problem (and may be necessary for soundness; I didn&#39;t explore this in depth, but it certainly feels like a very nasty sort of dependence).  We could potentially weaken this for cases where A is a direct type reference with bound parameters, e.g. Foo&lt;Int&gt;([]) or the same with a typealias, but I think there&#39;s some benefit from having a simpler specification, both for the implementation and for the explicability of the model.<br>&gt; <br>&gt; John.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>June  2, 2016 at 11:00:00am</p></header><div class="content"><p>I think we should actually go further.<br></p><p>If this proposal is accepted, disallow &quot;as&quot; as a way of specifying the type<br>to construct from a literal.<br></p><p>If this proposal isn&#39;t accepted, disallow using literal values as the<br>argument to one-unlabeled-argument constructors.<br></p><p>In either case we should disabuse users of the notion that A(literal) is an<br>initializer that behaves exactly the same as other initializers.<br></p><p>Austin<br></p><p>On Thu, Jun 2, 2016 at 11:46 AM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br></p><p>&gt; +1.<br>&gt;<br>&gt; The primary advantage is that it aligns the language semantics with how<br>&gt; most programmers expect this common C-language-family idiom to behave and<br>&gt; removes a potential source of silently wrong code.<br>&gt;<br>&gt; The primary disadvantage is that it introduces special-case behavior to<br>&gt; certain types of initializers (although, to be fair, this special-case<br>&gt; behavior is easily recognizable: unlabeled one-argument initializer with a<br>&gt; literal as the argument).<br>&gt;<br>&gt; I think the advantage outweighs the disadvantage.<br>&gt;<br>&gt; This problem should be addressed one way or another. I prefer this<br>&gt; solution, but if it is rejected for whatever reason we should at least<br>&gt; explicitly outlaw A(literal) syntax in favor of &quot;literal as A&quot;.<br>&gt;<br>&gt; Austin<br>&gt;<br>&gt; On Thu, Jun 2, 2016 at 9:08 AM, John McCall via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; The official way to build a literal of a specific type is to write the<br>&gt;&gt; literal in an explicitly-typed context, like so:<br>&gt;&gt;     let x: UInt16 = 7<br>&gt;&gt; or<br>&gt;&gt;     let x = 7 as UInt16<br>&gt;&gt;<br>&gt;&gt; Nonetheless, programmers often try the following:<br>&gt;&gt;     UInt16(7)<br>&gt;&gt;<br>&gt;&gt; Unfortunately, this does *not* attempt to construct the value using the<br>&gt;&gt; appropriate literal protocol; it instead performs overload resolution using<br>&gt;&gt; the standard rules, i.e. considering only single-argument unlabelled<br>&gt;&gt; initializers of a type which conforms to IntegerLiteralConvertible.  Often<br>&gt;&gt; this leads to static ambiguities or, worse, causes the literal to be built<br>&gt;&gt; using a default type (such as Int); this may have semantically very<br>&gt;&gt; different results which are only caught at runtime.<br>&gt;&gt;<br>&gt;&gt; In my opinion, using this initializer-call syntax to build an<br>&gt;&gt; explicitly-typed literal is an obvious and natural choice with several<br>&gt;&gt; advantages over the &quot;as&quot; syntax.  However, even if you disagree, it&#39;s clear<br>&gt;&gt; that programmers are going to continue to independently try to use it, so<br>&gt;&gt; it&#39;s really unfortunate for it to be subtly wrong.<br>&gt;&gt;<br>&gt;&gt; Therefore, I propose that we adopt the following typing rule:<br>&gt;&gt;<br>&gt;&gt;   Given a function call expression of the form A(B) (that is, an<br>&gt;&gt; *expr-call* with a single, unlabelled argument) where B is an<br>&gt;&gt; *expr-literal* or *expr-collection*, if A has type T.Type for some type<br>&gt;&gt; T and there is a declared conformance of T to an appropriate literal<br>&gt;&gt; protocol for B, then the expression is always resolves as a literal<br>&gt;&gt; construction of type T (as if the expression were written &quot;B as A&quot;) rather<br>&gt;&gt; than as a general initializer call.<br>&gt;&gt;<br>&gt;&gt; Formally, this would be a special form of the argument conversion<br>&gt;&gt; constraint, since the type of the expression A may not be immediately known.<br>&gt;&gt;<br>&gt;&gt; Note that, as specified, it is possible to suppress this typing rule by<br>&gt;&gt; wrapping the literal in parentheses.  This might seem distasteful; it would<br>&gt;&gt; be easy enough to allow the form of B to include extra parentheses.  It&#39;s<br>&gt;&gt; potentially useful to have a way to suppress this rule and get a normal<br>&gt;&gt; construction, but there are several other ways of getting that effect, such<br>&gt;&gt; as explicitly typing the literal argument (e.g. writing &quot;A(Int(B))&quot;).<br>&gt;&gt;<br>&gt;&gt; A conditional conformance counts as a declared conformance even if the<br>&gt;&gt; generic arguments are known to not satisfy the conditional conformance.<br>&gt;&gt; This permits the applicability of the rule to be decided without having to<br>&gt;&gt; first decide the type arguments, which greatly simplifies the type-checking<br>&gt;&gt; problem (and may be necessary for soundness; I didn&#39;t explore this in<br>&gt;&gt; depth, but it certainly feels like a very nasty sort of dependence).  We<br>&gt;&gt; could potentially weaken this for cases where A is a direct type reference<br>&gt;&gt; with bound parameters, e.g. Foo&lt;Int&gt;([]) or the same with a typealias, but<br>&gt;&gt; I think there&#39;s some benefit from having a simpler specification, both for<br>&gt;&gt; the implementation and for the explicability of the model.<br>&gt;&gt;<br>&gt;&gt; John.<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/32d819ab/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June  2, 2016 at 02:00:00pm</p></header><div class="content"><p>+1 to the proposal. I can also see the argument for disallowing multiple<br>ways of doing the same thing, though disallowing the use of `as` in this<br>way might be introducing another special case.<br></p><p>If the proposal is accepted, I&#39;d also advocate for the suggestion in the<br>initial proposal to apply the rule regardless of the number of parentheses,<br>so that `A((B))` behaves the same way as `A(B)`.<br></p><p>On Thu, Jun 2, 2016 at 1:55 PM, Austin Zheng via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I think we should actually go further.<br>&gt;<br>&gt; If this proposal is accepted, disallow &quot;as&quot; as a way of specifying the<br>&gt; type to construct from a literal.<br>&gt;<br>&gt; If this proposal isn&#39;t accepted, disallow using literal values as the<br>&gt; argument to one-unlabeled-argument constructors.<br>&gt;<br>&gt; In either case we should disabuse users of the notion that A(literal) is<br>&gt; an initializer that behaves exactly the same as other initializers.<br>&gt;<br>&gt; Austin<br>&gt;<br>&gt; On Thu, Jun 2, 2016 at 11:46 AM, Austin Zheng &lt;austinzheng at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; +1.<br>&gt;&gt;<br>&gt;&gt; The primary advantage is that it aligns the language semantics with how<br>&gt;&gt; most programmers expect this common C-language-family idiom to behave and<br>&gt;&gt; removes a potential source of silently wrong code.<br>&gt;&gt;<br>&gt;&gt; The primary disadvantage is that it introduces special-case behavior to<br>&gt;&gt; certain types of initializers (although, to be fair, this special-case<br>&gt;&gt; behavior is easily recognizable: unlabeled one-argument initializer with a<br>&gt;&gt; literal as the argument).<br>&gt;&gt;<br>&gt;&gt; I think the advantage outweighs the disadvantage.<br>&gt;&gt;<br>&gt;&gt; This problem should be addressed one way or another. I prefer this<br>&gt;&gt; solution, but if it is rejected for whatever reason we should at least<br>&gt;&gt; explicitly outlaw A(literal) syntax in favor of &quot;literal as A&quot;.<br>&gt;&gt;<br>&gt;&gt; Austin<br>&gt;&gt;<br>&gt;&gt; On Thu, Jun 2, 2016 at 9:08 AM, John McCall via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; The official way to build a literal of a specific type is to write the<br>&gt;&gt;&gt; literal in an explicitly-typed context, like so:<br>&gt;&gt;&gt;     let x: UInt16 = 7<br>&gt;&gt;&gt; or<br>&gt;&gt;&gt;     let x = 7 as UInt16<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Nonetheless, programmers often try the following:<br>&gt;&gt;&gt;     UInt16(7)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Unfortunately, this does *not* attempt to construct the value using the<br>&gt;&gt;&gt; appropriate literal protocol; it instead performs overload resolution using<br>&gt;&gt;&gt; the standard rules, i.e. considering only single-argument unlabelled<br>&gt;&gt;&gt; initializers of a type which conforms to IntegerLiteralConvertible.  Often<br>&gt;&gt;&gt; this leads to static ambiguities or, worse, causes the literal to be built<br>&gt;&gt;&gt; using a default type (such as Int); this may have semantically very<br>&gt;&gt;&gt; different results which are only caught at runtime.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In my opinion, using this initializer-call syntax to build an<br>&gt;&gt;&gt; explicitly-typed literal is an obvious and natural choice with several<br>&gt;&gt;&gt; advantages over the &quot;as&quot; syntax.  However, even if you disagree, it&#39;s clear<br>&gt;&gt;&gt; that programmers are going to continue to independently try to use it, so<br>&gt;&gt;&gt; it&#39;s really unfortunate for it to be subtly wrong.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Therefore, I propose that we adopt the following typing rule:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   Given a function call expression of the form A(B) (that is, an<br>&gt;&gt;&gt; *expr-call* with a single, unlabelled argument) where B is an<br>&gt;&gt;&gt; *expr-literal* or *expr-collection*, if A has type T.Type for some type<br>&gt;&gt;&gt; T and there is a declared conformance of T to an appropriate literal<br>&gt;&gt;&gt; protocol for B, then the expression is always resolves as a literal<br>&gt;&gt;&gt; construction of type T (as if the expression were written &quot;B as A&quot;) rather<br>&gt;&gt;&gt; than as a general initializer call.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Formally, this would be a special form of the argument conversion<br>&gt;&gt;&gt; constraint, since the type of the expression A may not be immediately known.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Note that, as specified, it is possible to suppress this typing rule by<br>&gt;&gt;&gt; wrapping the literal in parentheses.  This might seem distasteful; it would<br>&gt;&gt;&gt; be easy enough to allow the form of B to include extra parentheses.  It&#39;s<br>&gt;&gt;&gt; potentially useful to have a way to suppress this rule and get a normal<br>&gt;&gt;&gt; construction, but there are several other ways of getting that effect, such<br>&gt;&gt;&gt; as explicitly typing the literal argument (e.g. writing &quot;A(Int(B))&quot;).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; A conditional conformance counts as a declared conformance even if the<br>&gt;&gt;&gt; generic arguments are known to not satisfy the conditional conformance.<br>&gt;&gt;&gt; This permits the applicability of the rule to be decided without having to<br>&gt;&gt;&gt; first decide the type arguments, which greatly simplifies the type-checking<br>&gt;&gt;&gt; problem (and may be necessary for soundness; I didn&#39;t explore this in<br>&gt;&gt;&gt; depth, but it certainly feels like a very nasty sort of dependence).  We<br>&gt;&gt;&gt; could potentially weaken this for cases where A is a direct type reference<br>&gt;&gt;&gt; with bound parameters, e.g. Foo&lt;Int&gt;([]) or the same with a typealias, but<br>&gt;&gt;&gt; I think there&#39;s some benefit from having a simpler specification, both for<br>&gt;&gt;&gt; the implementation and for the explicability of the model.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; John.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/c6c96862/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>June  2, 2016 at 12:00:00pm</p></header><div class="content"><p>On Thu, Jun 2, 2016 at 12:11 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br></p><p>&gt; +1 to the proposal. I can also see the argument for disallowing multiple<br>&gt; ways of doing the same thing, though disallowing the use of `as` in this<br>&gt; way might be introducing another special case.<br>&gt;<br>&gt;<br>The &quot;as&quot;, &quot;as?&quot; and &quot;as!&quot; operators in Swift are already surprisingly<br>overloaded.  Joe Groff&#39;s proposal lists 9 (!!!) different things &quot;as?&quot; does<br>here:<br>https://github.com/apple/swift-evolution/blob/master/proposals/0083-remove-bridging-from-dynamic-casts.md<br>.<br></p><p>&quot;as&quot; is also overloaded in this sense. It performs bridging casts (soon to<br>go away?), upcasts that can never fail (e.g. subclass to superclass), and<br>defining the concrete type of a literal expression. It wouldn&#39;t be a big<br>loss for &quot;as&quot; to lose the last meaning.<br></p><p><br></p><p>&gt; If the proposal is accepted, I&#39;d also advocate for the suggestion in the<br>&gt; initial proposal to apply the rule regardless of the number of parentheses,<br>&gt; so that `A((B))` behaves the same way as `A(B)`.<br>&gt;<br></p><p>+1. Yes please.<br></p><p><br>&gt;<br>&gt; On Thu, Jun 2, 2016 at 1:55 PM, Austin Zheng via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; I think we should actually go further.<br>&gt;&gt;<br>&gt;&gt; If this proposal is accepted, disallow &quot;as&quot; as a way of specifying the<br>&gt;&gt; type to construct from a literal.<br>&gt;&gt;<br>&gt;&gt; If this proposal isn&#39;t accepted, disallow using literal values as the<br>&gt;&gt; argument to one-unlabeled-argument constructors.<br>&gt;&gt;<br>&gt;&gt; In either case we should disabuse users of the notion that A(literal) is<br>&gt;&gt; an initializer that behaves exactly the same as other initializers.<br>&gt;&gt;<br>&gt;&gt; Austin<br>&gt;&gt;<br>&gt;&gt; On Thu, Jun 2, 2016 at 11:46 AM, Austin Zheng &lt;austinzheng at gmail.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; +1.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The primary advantage is that it aligns the language semantics with how<br>&gt;&gt;&gt; most programmers expect this common C-language-family idiom to behave and<br>&gt;&gt;&gt; removes a potential source of silently wrong code.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The primary disadvantage is that it introduces special-case behavior to<br>&gt;&gt;&gt; certain types of initializers (although, to be fair, this special-case<br>&gt;&gt;&gt; behavior is easily recognizable: unlabeled one-argument initializer with a<br>&gt;&gt;&gt; literal as the argument).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I think the advantage outweighs the disadvantage.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This problem should be addressed one way or another. I prefer this<br>&gt;&gt;&gt; solution, but if it is rejected for whatever reason we should at least<br>&gt;&gt;&gt; explicitly outlaw A(literal) syntax in favor of &quot;literal as A&quot;.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Thu, Jun 2, 2016 at 9:08 AM, John McCall via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The official way to build a literal of a specific type is to write the<br>&gt;&gt;&gt;&gt; literal in an explicitly-typed context, like so:<br>&gt;&gt;&gt;&gt;     let x: UInt16 = 7<br>&gt;&gt;&gt;&gt; or<br>&gt;&gt;&gt;&gt;     let x = 7 as UInt16<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Nonetheless, programmers often try the following:<br>&gt;&gt;&gt;&gt;     UInt16(7)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Unfortunately, this does *not* attempt to construct the value using<br>&gt;&gt;&gt;&gt; the appropriate literal protocol; it instead performs overload resolution<br>&gt;&gt;&gt;&gt; using the standard rules, i.e. considering only single-argument unlabelled<br>&gt;&gt;&gt;&gt; initializers of a type which conforms to IntegerLiteralConvertible.  Often<br>&gt;&gt;&gt;&gt; this leads to static ambiguities or, worse, causes the literal to be built<br>&gt;&gt;&gt;&gt; using a default type (such as Int); this may have semantically very<br>&gt;&gt;&gt;&gt; different results which are only caught at runtime.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; In my opinion, using this initializer-call syntax to build an<br>&gt;&gt;&gt;&gt; explicitly-typed literal is an obvious and natural choice with several<br>&gt;&gt;&gt;&gt; advantages over the &quot;as&quot; syntax.  However, even if you disagree, it&#39;s clear<br>&gt;&gt;&gt;&gt; that programmers are going to continue to independently try to use it, so<br>&gt;&gt;&gt;&gt; it&#39;s really unfortunate for it to be subtly wrong.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Therefore, I propose that we adopt the following typing rule:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;   Given a function call expression of the form A(B) (that is, an<br>&gt;&gt;&gt;&gt; *expr-call* with a single, unlabelled argument) where B is an<br>&gt;&gt;&gt;&gt; *expr-literal* or *expr-collection*, if A has type T.Type for some<br>&gt;&gt;&gt;&gt; type T and there is a declared conformance of T to an appropriate literal<br>&gt;&gt;&gt;&gt; protocol for B, then the expression is always resolves as a literal<br>&gt;&gt;&gt;&gt; construction of type T (as if the expression were written &quot;B as A&quot;) rather<br>&gt;&gt;&gt;&gt; than as a general initializer call.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Formally, this would be a special form of the argument conversion<br>&gt;&gt;&gt;&gt; constraint, since the type of the expression A may not be immediately known.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Note that, as specified, it is possible to suppress this typing rule by<br>&gt;&gt;&gt;&gt; wrapping the literal in parentheses.  This might seem distasteful; it would<br>&gt;&gt;&gt;&gt; be easy enough to allow the form of B to include extra parentheses.  It&#39;s<br>&gt;&gt;&gt;&gt; potentially useful to have a way to suppress this rule and get a normal<br>&gt;&gt;&gt;&gt; construction, but there are several other ways of getting that effect, such<br>&gt;&gt;&gt;&gt; as explicitly typing the literal argument (e.g. writing &quot;A(Int(B))&quot;).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; A conditional conformance counts as a declared conformance even if the<br>&gt;&gt;&gt;&gt; generic arguments are known to not satisfy the conditional conformance.<br>&gt;&gt;&gt;&gt; This permits the applicability of the rule to be decided without having to<br>&gt;&gt;&gt;&gt; first decide the type arguments, which greatly simplifies the type-checking<br>&gt;&gt;&gt;&gt; problem (and may be necessary for soundness; I didn&#39;t explore this in<br>&gt;&gt;&gt;&gt; depth, but it certainly feels like a very nasty sort of dependence).  We<br>&gt;&gt;&gt;&gt; could potentially weaken this for cases where A is a direct type reference<br>&gt;&gt;&gt;&gt; with bound parameters, e.g. Foo&lt;Int&gt;([]) or the same with a typealias, but<br>&gt;&gt;&gt;&gt; I think there&#39;s some benefit from having a simpler specification, both for<br>&gt;&gt;&gt;&gt; the implementation and for the explicability of the model.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/80d3bd1a/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June  2, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jun 2, 2016, at 1:55 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I think we should actually go further.<br>&gt; <br>&gt; If this proposal is accepted, disallow &quot;as&quot; as a way of specifying the type to construct from a literal.<br></p><p>I’m not sure.  I agree it would be bad style to use `as` here.  But I’m not sure if it should be banned or not.<br></p><p>&gt; <br>&gt; If this proposal isn&#39;t accepted, disallow using literal values as the argument to one-unlabeled-argument constructors.<br></p><p>I don’t know about this.  It says that if you want users to initialize your type with an unlabeled argument that has a type which has a corresponding literal you *must* conform to the corresponding literal convertible protocol.  Do we really want to require that?  Maybe, but maybe not.  We definitely *should not* allow such an initializer to be written if it cannot be called with a literal.<br></p><p>For example, if I have:<br></p><p>`init(_ a: [String])`<br></p><p>users could call the initializer with an array variable but not a array literal.  That would be very bad IMO.  Either this initializer is banned altogether, or we allow it to be called with a literal. <br></p><p>FWIW, there are types in the standard library with overlapping initializers in this new model:<br></p><p>public init(_ value: UInt8)<br>public init(integerLiteral value: UInt8)<br></p><p>I’m not sure whether they actually need to do different things or whether they are just provided so you can initialize the type with a variable and also use literals in a context expecting that type.<br></p><p>I think it’s important to understand whether overlap like this is necessary or not.  If behavior should always be identical I am in favor of refactoring the literal convertible protocols as part of this change.<br></p><p>&gt; <br>&gt; In either case we should disabuse users of the notion that A(literal) is an initializer that behaves exactly the same as other initializers.<br>&gt; <br>&gt; Austin<br>&gt; <br>&gt; On Thu, Jun 2, 2016 at 11:46 AM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt; +1.<br>&gt; <br>&gt; The primary advantage is that it aligns the language semantics with how most programmers expect this common C-language-family idiom to behave and removes a potential source of silently wrong code.<br>&gt; <br>&gt; The primary disadvantage is that it introduces special-case behavior to certain types of initializers (although, to be fair, this special-case behavior is easily recognizable: unlabeled one-argument initializer with a literal as the argument).<br>&gt; <br>&gt; I think the advantage outweighs the disadvantage.<br>&gt; <br>&gt; This problem should be addressed one way or another. I prefer this solution, but if it is rejected for whatever reason we should at least explicitly outlaw A(literal) syntax in favor of &quot;literal as A&quot;.<br>&gt; <br>&gt; Austin<br>&gt; <br>&gt; On Thu, Jun 2, 2016 at 9:08 AM, John McCall via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; The official way to build a literal of a specific type is to write the literal in an explicitly-typed context, like so:<br>&gt;     let x: UInt16 = 7<br>&gt; or<br>&gt;     let x = 7 as UInt16<br>&gt; <br>&gt; Nonetheless, programmers often try the following:<br>&gt;     UInt16(7)<br>&gt; <br>&gt; Unfortunately, this does not attempt to construct the value using the appropriate literal protocol; it instead performs overload resolution using the standard rules, i.e. considering only single-argument unlabelled initializers of a type which conforms to IntegerLiteralConvertible.  Often this leads to static ambiguities or, worse, causes the literal to be built using a default type (such as Int); this may have semantically very different results which are only caught at runtime.<br>&gt; <br>&gt; In my opinion, using this initializer-call syntax to build an explicitly-typed literal is an obvious and natural choice with several advantages over the &quot;as&quot; syntax.  However, even if you disagree, it&#39;s clear that programmers are going to continue to independently try to use it, so it&#39;s really unfortunate for it to be subtly wrong.<br>&gt; <br>&gt; Therefore, I propose that we adopt the following typing rule:<br>&gt; <br>&gt;   Given a function call expression of the form A(B) (that is, an expr-call with a single, unlabelled argument) where B is an expr-literal or expr-collection, if A has type T.Type for some type T and there is a declared conformance of T to an appropriate literal protocol for B, then the expression is always resolves as a literal construction of type T (as if the expression were written &quot;B as A&quot;) rather than as a general initializer call.<br>&gt; <br>&gt; Formally, this would be a special form of the argument conversion constraint, since the type of the expression A may not be immediately known.<br>&gt; <br>&gt; Note that, as specified, it is possible to suppress this typing rule by wrapping the literal in parentheses.  This might seem distasteful; it would be easy enough to allow the form of B to include extra parentheses.  It&#39;s potentially useful to have a way to suppress this rule and get a normal construction, but there are several other ways of getting that effect, such as explicitly typing the literal argument (e.g. writing &quot;A(Int(B))&quot;).<br>&gt; <br>&gt; A conditional conformance counts as a declared conformance even if the generic arguments are known to not satisfy the conditional conformance.  This permits the applicability of the rule to be decided without having to first decide the type arguments, which greatly simplifies the type-checking problem (and may be necessary for soundness; I didn&#39;t explore this in depth, but it certainly feels like a very nasty sort of dependence).  We could potentially weaken this for cases where A is a direct type reference with bound parameters, e.g. Foo&lt;Int&gt;([]) or the same with a typealias, but I think there&#39;s some benefit from having a simpler specification, both for the implementation and for the explicability of the model.<br>&gt; <br>&gt; John.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/90425c5a/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>June  2, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jun 2, 2016, at 11:55 AM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; I think we should actually go further.<br>&gt; <br>&gt; If this proposal is accepted, disallow &quot;as&quot; as a way of specifying the type to construct from a literal.<br></p><p>I see no reason to restrict &quot;as&quot; like this.  We&#39;re not going to stop using type context as a way of determining the type of a literal, and &quot;as&quot; is a general feature for providing type context.<br></p><p>&gt; If this proposal isn&#39;t accepted, disallow using literal values as the argument to one-unlabeled-argument constructors.<br></p><p>I can&#39;t imagine accepting this, either; it would be a major regression in the usefulness of unlabeled initializers.  At best, this would be appropriate only when the type conforms to an appropriate literal protocol.<br></p><p>In general, Swift gives unlabeled initializers an idiomatic meaning: they coerce the argument to the target type in a nominally value-preserving way.  One way of viewing this proposal is that it recognizes that there is an obvious way to do that when the target type supports being directly formed from the given kind of literal.  But if the target type doesn&#39;t support that, coercing a value of some other appropriate literal type is still a completely reasonable behavior.<br></p><p>John.<br></p><p>&gt; <br>&gt; Austin<br>&gt; <br>&gt; On Thu, Jun 2, 2016 at 11:46 AM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt; +1.<br>&gt; <br>&gt; The primary advantage is that it aligns the language semantics with how most programmers expect this common C-language-family idiom to behave and removes a potential source of silently wrong code.<br>&gt; <br>&gt; The primary disadvantage is that it introduces special-case behavior to certain types of initializers (although, to be fair, this special-case behavior is easily recognizable: unlabeled one-argument initializer with a literal as the argument).<br>&gt; <br>&gt; I think the advantage outweighs the disadvantage.<br>&gt; <br>&gt; This problem should be addressed one way or another. I prefer this solution, but if it is rejected for whatever reason we should at least explicitly outlaw A(literal) syntax in favor of &quot;literal as A&quot;.<br>&gt; <br>&gt; Austin<br>&gt; <br>&gt; On Thu, Jun 2, 2016 at 9:08 AM, John McCall via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; The official way to build a literal of a specific type is to write the literal in an explicitly-typed context, like so:<br>&gt;     let x: UInt16 = 7<br>&gt; or<br>&gt;     let x = 7 as UInt16<br>&gt; <br>&gt; Nonetheless, programmers often try the following:<br>&gt;     UInt16(7)<br>&gt; <br>&gt; Unfortunately, this does not attempt to construct the value using the appropriate literal protocol; it instead performs overload resolution using the standard rules, i.e. considering only single-argument unlabelled initializers of a type which conforms to IntegerLiteralConvertible.  Often this leads to static ambiguities or, worse, causes the literal to be built using a default type (such as Int); this may have semantically very different results which are only caught at runtime.<br>&gt; <br>&gt; In my opinion, using this initializer-call syntax to build an explicitly-typed literal is an obvious and natural choice with several advantages over the &quot;as&quot; syntax.  However, even if you disagree, it&#39;s clear that programmers are going to continue to independently try to use it, so it&#39;s really unfortunate for it to be subtly wrong.<br>&gt; <br>&gt; Therefore, I propose that we adopt the following typing rule:<br>&gt; <br>&gt;   Given a function call expression of the form A(B) (that is, an expr-call with a single, unlabelled argument) where B is an expr-literal or expr-collection, if A has type T.Type for some type T and there is a declared conformance of T to an appropriate literal protocol for B, then the expression is always resolves as a literal construction of type T (as if the expression were written &quot;B as A&quot;) rather than as a general initializer call.<br>&gt; <br>&gt; Formally, this would be a special form of the argument conversion constraint, since the type of the expression A may not be immediately known.<br>&gt; <br>&gt; Note that, as specified, it is possible to suppress this typing rule by wrapping the literal in parentheses.  This might seem distasteful; it would be easy enough to allow the form of B to include extra parentheses.  It&#39;s potentially useful to have a way to suppress this rule and get a normal construction, but there are several other ways of getting that effect, such as explicitly typing the literal argument (e.g. writing &quot;A(Int(B))&quot;).<br>&gt; <br>&gt; A conditional conformance counts as a declared conformance even if the generic arguments are known to not satisfy the conditional conformance.  This permits the applicability of the rule to be decided without having to first decide the type arguments, which greatly simplifies the type-checking problem (and may be necessary for soundness; I didn&#39;t explore this in depth, but it certainly feels like a very nasty sort of dependence).  We could potentially weaken this for cases where A is a direct type reference with bound parameters, e.g. Foo&lt;Int&gt;([]) or the same with a typealias, but I think there&#39;s some benefit from having a simpler specification, both for the implementation and for the explicability of the model.<br>&gt; <br>&gt; John.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/f08e64e9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>June  2, 2016 at 01:00:00pm</p></header><div class="content"><p>That makes sense. Thanks for sharing your reasoning.<br></p><p>On Thu, Jun 2, 2016 at 1:38 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br></p><p>&gt; On Jun 2, 2016, at 11:55 AM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; I think we should actually go further.<br>&gt;<br>&gt; If this proposal is accepted, disallow &quot;as&quot; as a way of specifying the<br>&gt; type to construct from a literal.<br>&gt;<br>&gt;<br>&gt; I see no reason to restrict &quot;as&quot; like this.  We&#39;re not going to stop using<br>&gt; type context as a way of determining the type of a literal, and &quot;as&quot; is a<br>&gt; general feature for providing type context.<br>&gt;<br>&gt; If this proposal isn&#39;t accepted, disallow using literal values as the<br>&gt; argument to one-unlabeled-argument constructors.<br>&gt;<br>&gt;<br>&gt; I can&#39;t imagine accepting this, either; it would be a major regression in<br>&gt; the usefulness of unlabeled initializers.  At best, this would be<br>&gt; appropriate only when the type conforms to an appropriate literal protocol.<br>&gt;<br>&gt; In general, Swift gives unlabeled initializers an idiomatic meaning: they<br>&gt; coerce the argument to the target type in a nominally value-preserving<br>&gt; way.  One way of viewing this proposal is that it recognizes that there is<br>&gt; an obvious way to do that when the target type supports being directly<br>&gt; formed from the given kind of literal.  But if the target type doesn&#39;t<br>&gt; support that, coercing a value of some other appropriate literal type is<br>&gt; still a completely reasonable behavior.<br>&gt;<br>&gt; John.<br>&gt;<br>&gt;<br>&gt; Austin<br>&gt;<br>&gt; On Thu, Jun 2, 2016 at 11:46 AM, Austin Zheng &lt;austinzheng at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; +1.<br>&gt;&gt;<br>&gt;&gt; The primary advantage is that it aligns the language semantics with how<br>&gt;&gt; most programmers expect this common C-language-family idiom to behave and<br>&gt;&gt; removes a potential source of silently wrong code.<br>&gt;&gt;<br>&gt;&gt; The primary disadvantage is that it introduces special-case behavior to<br>&gt;&gt; certain types of initializers (although, to be fair, this special-case<br>&gt;&gt; behavior is easily recognizable: unlabeled one-argument initializer with a<br>&gt;&gt; literal as the argument).<br>&gt;&gt;<br>&gt;&gt; I think the advantage outweighs the disadvantage.<br>&gt;&gt;<br>&gt;&gt; This problem should be addressed one way or another. I prefer this<br>&gt;&gt; solution, but if it is rejected for whatever reason we should at least<br>&gt;&gt; explicitly outlaw A(literal) syntax in favor of &quot;literal as A&quot;.<br>&gt;&gt;<br>&gt;&gt; Austin<br>&gt;&gt;<br>&gt;&gt; On Thu, Jun 2, 2016 at 9:08 AM, John McCall via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; The official way to build a literal of a specific type is to write the<br>&gt;&gt;&gt; literal in an explicitly-typed context, like so:<br>&gt;&gt;&gt;     let x: UInt16 = 7<br>&gt;&gt;&gt; or<br>&gt;&gt;&gt;     let x = 7 as UInt16<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Nonetheless, programmers often try the following:<br>&gt;&gt;&gt;     UInt16(7)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Unfortunately, this does *not* attempt to construct the value using the<br>&gt;&gt;&gt; appropriate literal protocol; it instead performs overload resolution using<br>&gt;&gt;&gt; the standard rules, i.e. considering only single-argument unlabelled<br>&gt;&gt;&gt; initializers of a type which conforms to IntegerLiteralConvertible.  Often<br>&gt;&gt;&gt; this leads to static ambiguities or, worse, causes the literal to be built<br>&gt;&gt;&gt; using a default type (such as Int); this may have semantically very<br>&gt;&gt;&gt; different results which are only caught at runtime.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In my opinion, using this initializer-call syntax to build an<br>&gt;&gt;&gt; explicitly-typed literal is an obvious and natural choice with several<br>&gt;&gt;&gt; advantages over the &quot;as&quot; syntax.  However, even if you disagree, it&#39;s clear<br>&gt;&gt;&gt; that programmers are going to continue to independently try to use it, so<br>&gt;&gt;&gt; it&#39;s really unfortunate for it to be subtly wrong.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Therefore, I propose that we adopt the following typing rule:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   Given a function call expression of the form A(B) (that is, an<br>&gt;&gt;&gt; *expr-call* with a single, unlabelled argument) where B is an<br>&gt;&gt;&gt; *expr-literal* or *expr-collection*, if A has type T.Type for some type<br>&gt;&gt;&gt; T and there is a declared conformance of T to an appropriate literal<br>&gt;&gt;&gt; protocol for B, then the expression is always resolves as a literal<br>&gt;&gt;&gt; construction of type T (as if the expression were written &quot;B as A&quot;) rather<br>&gt;&gt;&gt; than as a general initializer call.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Formally, this would be a special form of the argument conversion<br>&gt;&gt;&gt; constraint, since the type of the expression A may not be immediately known.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Note that, as specified, it is possible to suppress this typing rule by<br>&gt;&gt;&gt; wrapping the literal in parentheses.  This might seem distasteful; it would<br>&gt;&gt;&gt; be easy enough to allow the form of B to include extra parentheses.  It&#39;s<br>&gt;&gt;&gt; potentially useful to have a way to suppress this rule and get a normal<br>&gt;&gt;&gt; construction, but there are several other ways of getting that effect, such<br>&gt;&gt;&gt; as explicitly typing the literal argument (e.g. writing &quot;A(Int(B))&quot;).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; A conditional conformance counts as a declared conformance even if the<br>&gt;&gt;&gt; generic arguments are known to not satisfy the conditional conformance.<br>&gt;&gt;&gt; This permits the applicability of the rule to be decided without having to<br>&gt;&gt;&gt; first decide the type arguments, which greatly simplifies the type-checking<br>&gt;&gt;&gt; problem (and may be necessary for soundness; I didn&#39;t explore this in<br>&gt;&gt;&gt; depth, but it certainly feels like a very nasty sort of dependence).  We<br>&gt;&gt;&gt; could potentially weaken this for cases where A is a direct type reference<br>&gt;&gt;&gt; with bound parameters, e.g. Foo&lt;Int&gt;([]) or the same with a typealias, but<br>&gt;&gt;&gt; I think there&#39;s some benefit from having a simpler specification, both for<br>&gt;&gt;&gt; the implementation and for the explicability of the model.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; John.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/12db7555/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June  2, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jun 2, 2016, at 1:46 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; +1.<br>&gt; <br>&gt; The primary advantage is that it aligns the language semantics with how most programmers expect this common C-language-family idiom to behave and removes a potential source of silently wrong code.<br>&gt; <br>&gt; The primary disadvantage is that it introduces special-case behavior to certain types of initializers (although, to be fair, this special-case behavior is easily recognizable: unlabeled one-argument initializer with a literal as the argument).<br>&gt; <br>&gt; I think the advantage outweighs the disadvantage.<br></p><p>Agree.  This change basically means the label isn’t intended to be used by callers, but is only present to distinguish the initializer used by the protocol from any other unlabeled initializer accepting the same type.  But conceptually it is treated as the *most specific* unlabelled initializer possible, thus winning the overload resolution.<br></p><p>How important is it that we have the ability to distinguish between literals and non-literals with the same type?  If that isn’t important, maybe the literal convertible protocols could be reworked such that the label isn’t necessary.  That would eliminate the special-case elision of the label.<br></p><p>&gt; <br>&gt; This problem should be addressed one way or another. I prefer this solution, but if it is rejected for whatever reason we should at least explicitly outlaw A(literal) syntax in favor of &quot;literal as A&quot;.<br>&gt; <br>&gt; Austin<br>&gt; <br>&gt; On Thu, Jun 2, 2016 at 9:08 AM, John McCall via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; The official way to build a literal of a specific type is to write the literal in an explicitly-typed context, like so:<br>&gt;     let x: UInt16 = 7<br>&gt; or<br>&gt;     let x = 7 as UInt16<br>&gt; <br>&gt; Nonetheless, programmers often try the following:<br>&gt;     UInt16(7)<br>&gt; <br>&gt; Unfortunately, this does not attempt to construct the value using the appropriate literal protocol; it instead performs overload resolution using the standard rules, i.e. considering only single-argument unlabelled initializers of a type which conforms to IntegerLiteralConvertible.  Often this leads to static ambiguities or, worse, causes the literal to be built using a default type (such as Int); this may have semantically very different results which are only caught at runtime.<br>&gt; <br>&gt; In my opinion, using this initializer-call syntax to build an explicitly-typed literal is an obvious and natural choice with several advantages over the &quot;as&quot; syntax.  However, even if you disagree, it&#39;s clear that programmers are going to continue to independently try to use it, so it&#39;s really unfortunate for it to be subtly wrong.<br>&gt; <br>&gt; Therefore, I propose that we adopt the following typing rule:<br>&gt; <br>&gt;   Given a function call expression of the form A(B) (that is, an expr-call with a single, unlabelled argument) where B is an expr-literal or expr-collection, if A has type T.Type for some type T and there is a declared conformance of T to an appropriate literal protocol for B, then the expression is always resolves as a literal construction of type T (as if the expression were written &quot;B as A&quot;) rather than as a general initializer call.<br>&gt; <br>&gt; Formally, this would be a special form of the argument conversion constraint, since the type of the expression A may not be immediately known.<br>&gt; <br>&gt; Note that, as specified, it is possible to suppress this typing rule by wrapping the literal in parentheses.  This might seem distasteful; it would be easy enough to allow the form of B to include extra parentheses.  It&#39;s potentially useful to have a way to suppress this rule and get a normal construction, but there are several other ways of getting that effect, such as explicitly typing the literal argument (e.g. writing &quot;A(Int(B))&quot;).<br>&gt; <br>&gt; A conditional conformance counts as a declared conformance even if the generic arguments are known to not satisfy the conditional conformance.  This permits the applicability of the rule to be decided without having to first decide the type arguments, which greatly simplifies the type-checking problem (and may be necessary for soundness; I didn&#39;t explore this in depth, but it certainly feels like a very nasty sort of dependence).  We could potentially weaken this for cases where A is a direct type reference with bound parameters, e.g. Foo&lt;Int&gt;([]) or the same with a typealias, but I think there&#39;s some benefit from having a simpler specification, both for the implementation and for the explicability of the model.<br>&gt; <br>&gt; John.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/87cc8c94/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>June  2, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jun 2, 2016, at 12:10 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; On Jun 2, 2016, at 1:46 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; +1.<br>&gt;&gt; <br>&gt;&gt; The primary advantage is that it aligns the language semantics with how most programmers expect this common C-language-family idiom to behave and removes a potential source of silently wrong code.<br>&gt;&gt; <br>&gt;&gt; The primary disadvantage is that it introduces special-case behavior to certain types of initializers (although, to be fair, this special-case behavior is easily recognizable: unlabeled one-argument initializer with a literal as the argument).<br>&gt;&gt; <br>&gt;&gt; I think the advantage outweighs the disadvantage.<br>&gt; <br>&gt; Agree.  This change basically means the label isn’t intended to be used by callers, but is only present to distinguish the initializer used by the protocol from any other unlabeled initializer accepting the same type.  But conceptually it is treated as the *most specific* unlabelled initializer possible, thus winning the overload resolution.<br>&gt; <br>&gt; How important is it that we have the ability to distinguish between literals and non-literals with the same type?  If that isn’t important, maybe the literal convertible protocols could be reworked such that the label isn’t necessary.  That would eliminate the special-case elision of the label.<br></p><p>There is no way to rework the literal protocols so that this behavior just falls out.  It&#39;s easy enough to convince yourself of this if you try to work through an actual example.<br></p><p>John.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; This problem should be addressed one way or another. I prefer this solution, but if it is rejected for whatever reason we should at least explicitly outlaw A(literal) syntax in favor of &quot;literal as A&quot;.<br>&gt;&gt; <br>&gt;&gt; Austin<br>&gt;&gt; <br>&gt;&gt; On Thu, Jun 2, 2016 at 9:08 AM, John McCall via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; The official way to build a literal of a specific type is to write the literal in an explicitly-typed context, like so:<br>&gt;&gt;     let x: UInt16 = 7<br>&gt;&gt; or<br>&gt;&gt;     let x = 7 as UInt16<br>&gt;&gt; <br>&gt;&gt; Nonetheless, programmers often try the following:<br>&gt;&gt;     UInt16(7)<br>&gt;&gt; <br>&gt;&gt; Unfortunately, this does not attempt to construct the value using the appropriate literal protocol; it instead performs overload resolution using the standard rules, i.e. considering only single-argument unlabelled initializers of a type which conforms to IntegerLiteralConvertible.  Often this leads to static ambiguities or, worse, causes the literal to be built using a default type (such as Int); this may have semantically very different results which are only caught at runtime.<br>&gt;&gt; <br>&gt;&gt; In my opinion, using this initializer-call syntax to build an explicitly-typed literal is an obvious and natural choice with several advantages over the &quot;as&quot; syntax.  However, even if you disagree, it&#39;s clear that programmers are going to continue to independently try to use it, so it&#39;s really unfortunate for it to be subtly wrong.<br>&gt;&gt; <br>&gt;&gt; Therefore, I propose that we adopt the following typing rule:<br>&gt;&gt; <br>&gt;&gt;   Given a function call expression of the form A(B) (that is, an expr-call with a single, unlabelled argument) where B is an expr-literal or expr-collection, if A has type T.Type for some type T and there is a declared conformance of T to an appropriate literal protocol for B, then the expression is always resolves as a literal construction of type T (as if the expression were written &quot;B as A&quot;) rather than as a general initializer call.<br>&gt;&gt; <br>&gt;&gt; Formally, this would be a special form of the argument conversion constraint, since the type of the expression A may not be immediately known.<br>&gt;&gt; <br>&gt;&gt; Note that, as specified, it is possible to suppress this typing rule by wrapping the literal in parentheses.  This might seem distasteful; it would be easy enough to allow the form of B to include extra parentheses.  It&#39;s potentially useful to have a way to suppress this rule and get a normal construction, but there are several other ways of getting that effect, such as explicitly typing the literal argument (e.g. writing &quot;A(Int(B))&quot;).<br>&gt;&gt; <br>&gt;&gt; A conditional conformance counts as a declared conformance even if the generic arguments are known to not satisfy the conditional conformance.  This permits the applicability of the rule to be decided without having to first decide the type arguments, which greatly simplifies the type-checking problem (and may be necessary for soundness; I didn&#39;t explore this in depth, but it certainly feels like a very nasty sort of dependence).  We could potentially weaken this for cases where A is a direct type reference with bound parameters, e.g. Foo&lt;Int&gt;([]) or the same with a typealias, but I think there&#39;s some benefit from having a simpler specification, both for the implementation and for the explicability of the model.<br>&gt;&gt; <br>&gt;&gt; John.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/6ff486c1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June  2, 2016 at 03:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jun 2, 2016, at 3:41 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Jun 2, 2016, at 12:10 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt; On Jun 2, 2016, at 1:46 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +1.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The primary advantage is that it aligns the language semantics with how most programmers expect this common C-language-family idiom to behave and removes a potential source of silently wrong code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The primary disadvantage is that it introduces special-case behavior to certain types of initializers (although, to be fair, this special-case behavior is easily recognizable: unlabeled one-argument initializer with a literal as the argument).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think the advantage outweighs the disadvantage.<br>&gt;&gt; <br>&gt;&gt; Agree.  This change basically means the label isn’t intended to be used by callers, but is only present to distinguish the initializer used by the protocol from any other unlabeled initializer accepting the same type.  But conceptually it is treated as the *most specific* unlabelled initializer possible, thus winning the overload resolution.<br>&gt;&gt; <br>&gt;&gt; How important is it that we have the ability to distinguish between literals and non-literals with the same type?  If that isn’t important, maybe the literal convertible protocols could be reworked such that the label isn’t necessary.  That would eliminate the special-case elision of the label.<br>&gt; <br>&gt; There is no way to rework the literal protocols so that this behavior just falls out.  It&#39;s easy enough to convince yourself of this if you try to work through an actual example.<br></p><p>Ok, I&#39;ll trust you on this point.  +1 on the idea as you proposed it.<br></p><p>&gt; <br>&gt; John.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This problem should be addressed one way or another. I prefer this solution, but if it is rejected for whatever reason we should at least explicitly outlaw A(literal) syntax in favor of &quot;literal as A&quot;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Austin<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Thu, Jun 2, 2016 at 9:08 AM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; The official way to build a literal of a specific type is to write the literal in an explicitly-typed context, like so:<br>&gt;&gt;&gt;&gt;     let x: UInt16 = 7<br>&gt;&gt;&gt;&gt; or<br>&gt;&gt;&gt;&gt;     let x = 7 as UInt16<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Nonetheless, programmers often try the following:<br>&gt;&gt;&gt;&gt;     UInt16(7)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Unfortunately, this does not attempt to construct the value using the appropriate literal protocol; it instead performs overload resolution using the standard rules, i.e. considering only single-argument unlabelled initializers of a type which conforms to IntegerLiteralConvertible.  Often this leads to static ambiguities or, worse, causes the literal to be built using a default type (such as Int); this may have semantically very different results which are only caught at runtime.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In my opinion, using this initializer-call syntax to build an explicitly-typed literal is an obvious and natural choice with several advantages over the &quot;as&quot; syntax.  However, even if you disagree, it&#39;s clear that programmers are going to continue to independently try to use it, so it&#39;s really unfortunate for it to be subtly wrong.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Therefore, I propose that we adopt the following typing rule:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   Given a function call expression of the form A(B) (that is, an expr-call with a single, unlabelled argument) where B is an expr-literal or expr-collection, if A has type T.Type for some type T and there is a declared conformance of T to an appropriate literal protocol for B, then the expression is always resolves as a literal construction of type T (as if the expression were written &quot;B as A&quot;) rather than as a general initializer call.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Formally, this would be a special form of the argument conversion constraint, since the type of the expression A may not be immediately known.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Note that, as specified, it is possible to suppress this typing rule by wrapping the literal in parentheses.  This might seem distasteful; it would be easy enough to allow the form of B to include extra parentheses.  It&#39;s potentially useful to have a way to suppress this rule and get a normal construction, but there are several other ways of getting that effect, such as explicitly typing the literal argument (e.g. writing &quot;A(Int(B))&quot;).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A conditional conformance counts as a declared conformance even if the generic arguments are known to not satisfy the conditional conformance.  This permits the applicability of the rule to be decided without having to first decide the type arguments, which greatly simplifies the type-checking problem (and may be necessary for soundness; I didn&#39;t explore this in depth, but it certainly feels like a very nasty sort of dependence).  We could potentially weaken this for cases where A is a direct type reference with bound parameters, e.g. Foo&lt;Int&gt;([]) or the same with a typealias, but I think there&#39;s some benefit from having a simpler specification, both for the implementation and for the explicability of the model.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/7c7aa3fd/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>June  2, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; Often<br> &gt; this leads to static ambiguities or, worse, causes the literal to be built<br> &gt; using a default type (such as Int); this may have semantically very<br> &gt; different results which are only caught at runtime.<br></p><p>Seems like I&#39;m very slow today.. Could you present a couple of examples <br>where such initialization(like UInt16(7)) can produce some unexpected <br>behavior / error at runtime?<br></p><p>On 02.06.2016 19:08, John McCall via swift-evolution wrote:<br>&gt; The official way to build a literal of a specific type is to write the<br>&gt; literal in an explicitly-typed context, like so:<br>&gt;     let x: UInt16 = 7<br>&gt; or<br>&gt;     let x = 7 as UInt16<br>&gt;<br>&gt; Nonetheless, programmers often try the following:<br>&gt;     UInt16(7)<br>&gt;<br>&gt; Unfortunately, this does /not/ attempt to construct the value using the<br>&gt; appropriate literal protocol; it instead performs overload resolution using<br>&gt; the standard rules, i.e. considering only single-argument unlabelled<br>&gt; initializers of a type which conforms to IntegerLiteralConvertible.  Often<br>&gt; this leads to static ambiguities or, worse, causes the literal to be built<br>&gt; using a default type (such as Int); this may have semantically very<br>&gt; different results which are only caught at runtime.<br>&gt;<br>&gt; In my opinion, using this initializer-call syntax to build an<br>&gt; explicitly-typed literal is an obvious and natural choice with several<br>&gt; advantages over the &quot;as&quot; syntax.  However, even if you disagree, it&#39;s clear<br>&gt; that programmers are going to continue to independently try to use it, so<br>&gt; it&#39;s really unfortunate for it to be subtly wrong.<br>&gt;<br>&gt; Therefore, I propose that we adopt the following typing rule:<br>&gt;<br>&gt;   Given a function call expression of the form A(B) (that is, an<br>&gt; /expr-call/ with a single, unlabelled argument) where B is<br>&gt; an /expr-literal/ or /expr-collection/, if A has type T.Type for some type<br>&gt; T and there is a declared conformance of T to an appropriate literal<br>&gt; protocol for B, then the expression is always resolves as a literal<br>&gt; construction of type T (as if the expression were written &quot;B as A&quot;) rather<br>&gt; than as a general initializer call.<br>&gt;<br>&gt; Formally, this would be a special form of the argument conversion<br>&gt; constraint, since the type of the expression A may not be immediately known.<br>&gt;<br>&gt; Note that, as specified, it is possible to suppress this typing rule by<br>&gt; wrapping the literal in parentheses.  This might seem distasteful; it would<br>&gt; be easy enough to allow the form of B to include extra parentheses.  It&#39;s<br>&gt; potentially useful to have a way to suppress this rule and get a normal<br>&gt; construction, but there are several other ways of getting that effect, such<br>&gt; as explicitly typing the literal argument (e.g. writing &quot;A(Int(B))&quot;).<br>&gt;<br>&gt; A conditional conformance counts as a declared conformance even if the<br>&gt; generic arguments are known to not satisfy the conditional conformance.<br>&gt;  This permits the applicability of the rule to be decided without having to<br>&gt; first decide the type arguments, which greatly simplifies the type-checking<br>&gt; problem (and may be necessary for soundness; I didn&#39;t explore this in<br>&gt; depth, but it certainly feels like a very nasty sort of dependence).  We<br>&gt; could potentially weaken this for cases where A is a direct type reference<br>&gt; with bound parameters, e.g. Foo&lt;Int&gt;([]) or the same with a typealias, but<br>&gt; I think there&#39;s some benefit from having a simpler specification, both for<br>&gt; the implementation and for the explicability of the model.<br>&gt;<br>&gt; John.<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>June  2, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jun 2, 2016, at 1:56 PM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt; &gt; Often<br>&gt; &gt; this leads to static ambiguities or, worse, causes the literal to be built<br>&gt; &gt; using a default type (such as Int); this may have semantically very<br>&gt; &gt; different results which are only caught at runtime.<br>&gt; <br>&gt; Seems like I&#39;m very slow today.. Could you present a couple of examples where such initialization(like UInt16(7)) can produce some unexpected behavior / error at runtime?<br></p><p>UIntN has unlabeled initializers taking all of the standard integer types, including itself.  The literal type will therefore get defaulted to Int.  The legal range of values for Int may not be a superset of the legal range of values for UIntN.  If the literal is in the legal range for an Int but not for the target type, this might trap at runtime.  Now, for a built-in integer type like UInt16, we will recognize that the coercion always traps and emit an error at compile-time, but this generally won&#39;t apply to other types.<br></p><p>John.<br></p><p>&gt; <br>&gt; On 02.06.2016 19:08, John McCall via swift-evolution wrote:<br>&gt;&gt; The official way to build a literal of a specific type is to write the<br>&gt;&gt; literal in an explicitly-typed context, like so:<br>&gt;&gt;    let x: UInt16 = 7<br>&gt;&gt; or<br>&gt;&gt;    let x = 7 as UInt16<br>&gt;&gt; <br>&gt;&gt; Nonetheless, programmers often try the following:<br>&gt;&gt;    UInt16(7)<br>&gt;&gt; <br>&gt;&gt; Unfortunately, this does /not/ attempt to construct the value using the<br>&gt;&gt; appropriate literal protocol; it instead performs overload resolution using<br>&gt;&gt; the standard rules, i.e. considering only single-argument unlabelled<br>&gt;&gt; initializers of a type which conforms to IntegerLiteralConvertible.  Often<br>&gt;&gt; this leads to static ambiguities or, worse, causes the literal to be built<br>&gt;&gt; using a default type (such as Int); this may have semantically very<br>&gt;&gt; different results which are only caught at runtime.<br>&gt;&gt; <br>&gt;&gt; In my opinion, using this initializer-call syntax to build an<br>&gt;&gt; explicitly-typed literal is an obvious and natural choice with several<br>&gt;&gt; advantages over the &quot;as&quot; syntax.  However, even if you disagree, it&#39;s clear<br>&gt;&gt; that programmers are going to continue to independently try to use it, so<br>&gt;&gt; it&#39;s really unfortunate for it to be subtly wrong.<br>&gt;&gt; <br>&gt;&gt; Therefore, I propose that we adopt the following typing rule:<br>&gt;&gt; <br>&gt;&gt;  Given a function call expression of the form A(B) (that is, an<br>&gt;&gt; /expr-call/ with a single, unlabelled argument) where B is<br>&gt;&gt; an /expr-literal/ or /expr-collection/, if A has type T.Type for some type<br>&gt;&gt; T and there is a declared conformance of T to an appropriate literal<br>&gt;&gt; protocol for B, then the expression is always resolves as a literal<br>&gt;&gt; construction of type T (as if the expression were written &quot;B as A&quot;) rather<br>&gt;&gt; than as a general initializer call.<br>&gt;&gt; <br>&gt;&gt; Formally, this would be a special form of the argument conversion<br>&gt;&gt; constraint, since the type of the expression A may not be immediately known.<br>&gt;&gt; <br>&gt;&gt; Note that, as specified, it is possible to suppress this typing rule by<br>&gt;&gt; wrapping the literal in parentheses.  This might seem distasteful; it would<br>&gt;&gt; be easy enough to allow the form of B to include extra parentheses.  It&#39;s<br>&gt;&gt; potentially useful to have a way to suppress this rule and get a normal<br>&gt;&gt; construction, but there are several other ways of getting that effect, such<br>&gt;&gt; as explicitly typing the literal argument (e.g. writing &quot;A(Int(B))&quot;).<br>&gt;&gt; <br>&gt;&gt; A conditional conformance counts as a declared conformance even if the<br>&gt;&gt; generic arguments are known to not satisfy the conditional conformance.<br>&gt;&gt; This permits the applicability of the rule to be decided without having to<br>&gt;&gt; first decide the type arguments, which greatly simplifies the type-checking<br>&gt;&gt; problem (and may be necessary for soundness; I didn&#39;t explore this in<br>&gt;&gt; depth, but it certainly feels like a very nasty sort of dependence).  We<br>&gt;&gt; could potentially weaken this for cases where A is a direct type reference<br>&gt;&gt; with bound parameters, e.g. Foo&lt;Int&gt;([]) or the same with a typealias, but<br>&gt;&gt; I think there&#39;s some benefit from having a simpler specification, both for<br>&gt;&gt; the implementation and for the explicability of the model.<br>&gt;&gt; <br>&gt;&gt; John.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>June  3, 2016 at 12:00:00am</p></header><div class="content"><p>Well, I understand that it seems like there is some problem with UIntN() <br>initialization, but can&#39;t find any simple code that will demonstrate this..<br></p><p>All below works as expected:<br></p><p>var x1: Int32 = 0<br>var x2 = Int32(0)<br></p><p>print(x1.dynamicType, x2.dynamicType) // Int32 Int32<br></p><p>// integer overflows when converted from &#39;Int&#39; to &#39;UInt16&#39;<br>//var x = UInt16(100_000)<br>//var x = UInt16(-10)<br></p><p>// negative integer cannot be converted to unsigned type &#39;UInt64&#39;<br>// var x = UInt64(-1)<br></p><p>So, what code will produce some unexpected behavior / error at runtime?<br></p><p>On 03.06.2016 0:25, John McCall wrote:<br>&gt;&gt; On Jun 2, 2016, at 1:56 PM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt;&gt;&gt; Often<br>&gt;&gt;&gt; this leads to static ambiguities or, worse, causes the literal to be built<br>&gt;&gt;&gt; using a default type (such as Int); this may have semantically very<br>&gt;&gt;&gt; different results which are only caught at runtime.<br>&gt;&gt;<br>&gt;&gt; Seems like I&#39;m very slow today.. Could you present a couple of examples where such initialization(like UInt16(7)) can produce some unexpected behavior / error at runtime?<br>&gt;<br>&gt; UIntN has unlabeled initializers taking all of the standard integer types, including itself.  The literal type will therefore get defaulted to Int.  The legal range of values for Int may not be a superset of the legal range of values for UIntN.  If the literal is in the legal range for an Int but not for the target type, this might trap at runtime.  Now, for a built-in integer type like UInt16, we will recognize that the coercion always traps and emit an error at compile-time, but this generally won&#39;t apply to other types.<br>&gt;<br>&gt; John.<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On 02.06.2016 19:08, John McCall via swift-evolution wrote:<br>&gt;&gt;&gt; The official way to build a literal of a specific type is to write the<br>&gt;&gt;&gt; literal in an explicitly-typed context, like so:<br>&gt;&gt;&gt;    let x: UInt16 = 7<br>&gt;&gt;&gt; or<br>&gt;&gt;&gt;    let x = 7 as UInt16<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Nonetheless, programmers often try the following:<br>&gt;&gt;&gt;    UInt16(7)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Unfortunately, this does /not/ attempt to construct the value using the<br>&gt;&gt;&gt; appropriate literal protocol; it instead performs overload resolution using<br>&gt;&gt;&gt; the standard rules, i.e. considering only single-argument unlabelled<br>&gt;&gt;&gt; initializers of a type which conforms to IntegerLiteralConvertible.  Often<br>&gt;&gt;&gt; this leads to static ambiguities or, worse, causes the literal to be built<br>&gt;&gt;&gt; using a default type (such as Int); this may have semantically very<br>&gt;&gt;&gt; different results which are only caught at runtime.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In my opinion, using this initializer-call syntax to build an<br>&gt;&gt;&gt; explicitly-typed literal is an obvious and natural choice with several<br>&gt;&gt;&gt; advantages over the &quot;as&quot; syntax.  However, even if you disagree, it&#39;s clear<br>&gt;&gt;&gt; that programmers are going to continue to independently try to use it, so<br>&gt;&gt;&gt; it&#39;s really unfortunate for it to be subtly wrong.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Therefore, I propose that we adopt the following typing rule:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;  Given a function call expression of the form A(B) (that is, an<br>&gt;&gt;&gt; /expr-call/ with a single, unlabelled argument) where B is<br>&gt;&gt;&gt; an /expr-literal/ or /expr-collection/, if A has type T.Type for some type<br>&gt;&gt;&gt; T and there is a declared conformance of T to an appropriate literal<br>&gt;&gt;&gt; protocol for B, then the expression is always resolves as a literal<br>&gt;&gt;&gt; construction of type T (as if the expression were written &quot;B as A&quot;) rather<br>&gt;&gt;&gt; than as a general initializer call.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Formally, this would be a special form of the argument conversion<br>&gt;&gt;&gt; constraint, since the type of the expression A may not be immediately known.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Note that, as specified, it is possible to suppress this typing rule by<br>&gt;&gt;&gt; wrapping the literal in parentheses.  This might seem distasteful; it would<br>&gt;&gt;&gt; be easy enough to allow the form of B to include extra parentheses.  It&#39;s<br>&gt;&gt;&gt; potentially useful to have a way to suppress this rule and get a normal<br>&gt;&gt;&gt; construction, but there are several other ways of getting that effect, such<br>&gt;&gt;&gt; as explicitly typing the literal argument (e.g. writing &quot;A(Int(B))&quot;).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; A conditional conformance counts as a declared conformance even if the<br>&gt;&gt;&gt; generic arguments are known to not satisfy the conditional conformance.<br>&gt;&gt;&gt; This permits the applicability of the rule to be decided without having to<br>&gt;&gt;&gt; first decide the type arguments, which greatly simplifies the type-checking<br>&gt;&gt;&gt; problem (and may be necessary for soundness; I didn&#39;t explore this in<br>&gt;&gt;&gt; depth, but it certainly feels like a very nasty sort of dependence).  We<br>&gt;&gt;&gt; could potentially weaken this for cases where A is a direct type reference<br>&gt;&gt;&gt; with bound parameters, e.g. Foo&lt;Int&gt;([]) or the same with a typealias, but<br>&gt;&gt;&gt; I think there&#39;s some benefit from having a simpler specification, both for<br>&gt;&gt;&gt; the implementation and for the explicability of the model.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; John.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>June  2, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jun 2, 2016, at 2:36 PM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt; Well, I understand that it seems like there is some problem with UIntN() initialization, but can&#39;t find any simple code that will demonstrate this..<br>&gt; <br>&gt; All below works as expected:<br>&gt; <br>&gt; var x1: Int32 = 0<br>&gt; var x2 = Int32(0)<br>&gt; <br>&gt; print(x1.dynamicType, x2.dynamicType) // Int32 Int32<br>&gt; <br>&gt; // integer overflows when converted from &#39;Int&#39; to &#39;UInt16&#39;<br>&gt; //var x = UInt16(100_000)<br>&gt; //var x = UInt16(-10)<br>&gt; <br>&gt; // negative integer cannot be converted to unsigned type &#39;UInt64&#39;<br>&gt; // var x = UInt64(-1)<br>&gt; <br>&gt; So, what code will produce some unexpected behavior / error at runtime?<br></p><p>Like I said, the standard library and compiler conspire to make sure that easy cases like this are caught at compile time, but that would not help non-standard types that conform to IntegerLiteralConvertible.<br></p><p>Also, even for standard types, the syntax only works statically if the literal fits in the range of Int, which may not be a superset of the desired type.  For example, UInt64(0x10000000000) would not work on a 32-bit platform.  It is diagnosed statically, however.<br></p><p>John.<br></p><p>&gt; <br>&gt; On 03.06.2016 0:25, John McCall wrote:<br>&gt;&gt;&gt; On Jun 2, 2016, at 1:56 PM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; Often<br>&gt;&gt;&gt;&gt; this leads to static ambiguities or, worse, causes the literal to be built<br>&gt;&gt;&gt;&gt; using a default type (such as Int); this may have semantically very<br>&gt;&gt;&gt;&gt; different results which are only caught at runtime.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Seems like I&#39;m very slow today.. Could you present a couple of examples where such initialization(like UInt16(7)) can produce some unexpected behavior / error at runtime?<br>&gt;&gt; <br>&gt;&gt; UIntN has unlabeled initializers taking all of the standard integer types, including itself.  The literal type will therefore get defaulted to Int.  The legal range of values for Int may not be a superset of the legal range of values for UIntN.  If the literal is in the legal range for an Int but not for the target type, this might trap at runtime.  Now, for a built-in integer type like UInt16, we will recognize that the coercion always traps and emit an error at compile-time, but this generally won&#39;t apply to other types.<br>&gt;&gt; <br>&gt;&gt; John.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 02.06.2016 19:08, John McCall via swift-evolution wrote:<br>&gt;&gt;&gt;&gt; The official way to build a literal of a specific type is to write the<br>&gt;&gt;&gt;&gt; literal in an explicitly-typed context, like so:<br>&gt;&gt;&gt;&gt;   let x: UInt16 = 7<br>&gt;&gt;&gt;&gt; or<br>&gt;&gt;&gt;&gt;   let x = 7 as UInt16<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Nonetheless, programmers often try the following:<br>&gt;&gt;&gt;&gt;   UInt16(7)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Unfortunately, this does /not/ attempt to construct the value using the<br>&gt;&gt;&gt;&gt; appropriate literal protocol; it instead performs overload resolution using<br>&gt;&gt;&gt;&gt; the standard rules, i.e. considering only single-argument unlabelled<br>&gt;&gt;&gt;&gt; initializers of a type which conforms to IntegerLiteralConvertible.  Often<br>&gt;&gt;&gt;&gt; this leads to static ambiguities or, worse, causes the literal to be built<br>&gt;&gt;&gt;&gt; using a default type (such as Int); this may have semantically very<br>&gt;&gt;&gt;&gt; different results which are only caught at runtime.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In my opinion, using this initializer-call syntax to build an<br>&gt;&gt;&gt;&gt; explicitly-typed literal is an obvious and natural choice with several<br>&gt;&gt;&gt;&gt; advantages over the &quot;as&quot; syntax.  However, even if you disagree, it&#39;s clear<br>&gt;&gt;&gt;&gt; that programmers are going to continue to independently try to use it, so<br>&gt;&gt;&gt;&gt; it&#39;s really unfortunate for it to be subtly wrong.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Therefore, I propose that we adopt the following typing rule:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Given a function call expression of the form A(B) (that is, an<br>&gt;&gt;&gt;&gt; /expr-call/ with a single, unlabelled argument) where B is<br>&gt;&gt;&gt;&gt; an /expr-literal/ or /expr-collection/, if A has type T.Type for some type<br>&gt;&gt;&gt;&gt; T and there is a declared conformance of T to an appropriate literal<br>&gt;&gt;&gt;&gt; protocol for B, then the expression is always resolves as a literal<br>&gt;&gt;&gt;&gt; construction of type T (as if the expression were written &quot;B as A&quot;) rather<br>&gt;&gt;&gt;&gt; than as a general initializer call.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Formally, this would be a special form of the argument conversion<br>&gt;&gt;&gt;&gt; constraint, since the type of the expression A may not be immediately known.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Note that, as specified, it is possible to suppress this typing rule by<br>&gt;&gt;&gt;&gt; wrapping the literal in parentheses.  This might seem distasteful; it would<br>&gt;&gt;&gt;&gt; be easy enough to allow the form of B to include extra parentheses.  It&#39;s<br>&gt;&gt;&gt;&gt; potentially useful to have a way to suppress this rule and get a normal<br>&gt;&gt;&gt;&gt; construction, but there are several other ways of getting that effect, such<br>&gt;&gt;&gt;&gt; as explicitly typing the literal argument (e.g. writing &quot;A(Int(B))&quot;).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A conditional conformance counts as a declared conformance even if the<br>&gt;&gt;&gt;&gt; generic arguments are known to not satisfy the conditional conformance.<br>&gt;&gt;&gt;&gt; This permits the applicability of the rule to be decided without having to<br>&gt;&gt;&gt;&gt; first decide the type arguments, which greatly simplifies the type-checking<br>&gt;&gt;&gt;&gt; problem (and may be necessary for soundness; I didn&#39;t explore this in<br>&gt;&gt;&gt;&gt; depth, but it certainly feels like a very nasty sort of dependence).  We<br>&gt;&gt;&gt;&gt; could potentially weaken this for cases where A is a direct type reference<br>&gt;&gt;&gt;&gt; with bound parameters, e.g. Foo&lt;Int&gt;([]) or the same with a typealias, but<br>&gt;&gt;&gt;&gt; I think there&#39;s some benefit from having a simpler specification, both for<br>&gt;&gt;&gt;&gt; the implementation and for the explicability of the model.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>June  3, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; Like I said, the standard library and compiler conspire to make sure <br>that easy cases like this are caught at compile time, but that would not <br>help non-standard types that conform to IntegerLiteralConvertible.<br> &gt;<br> &gt; Also, even for standard types, the syntax only works statically if the <br>literal fits in the range of Int, which may not be a superset of the <br>desired type.  For example, UInt64(0x10000000000) would not work on a <br>32-bit platform.  It is diagnosed statically, however.<br></p><p>I believe I understand the problem you described, but I really can&#39;t figure <br>out how this problem can produce a unexpected behavior and run-time errors, <br>as was stated in your initial message. So, this is why I was asking for any <br>code that can prove this. The example with UInt64(0x10000000000) on 32bit <br>systems will raise error at _compilation_ time. Could someone provide any <br>code to illustrate the possible problems at run-time? I understand that we <br>need to fix this somehow in any case.<br></p><p>For others, who not really understand the issue(probably I&#39;m not the one, I <br>hope ;-) ) : If we&#39;d have Int128 type, we can&#39;t create an instance of it in <br>this form:<br>let x = Int128(92233720368547758070)<br>(92233720368547758070 == Int.max * 10)<br>as &#39;92233720368547758070&#39; literal will be treated always as of Int type.<br></p><p>In more general description, the difference between UIntN(xxx) and yyy as <br>UIntN is that xxx will be treated as Int(so it can&#39;t be greater than <br>Int.max for example) then this Int will be sent to UIntN(:Int) initializer <br>and then we have UIntN as a result of call to initializer; yyy will be <br>treated as UIntN literal just by its definition, no calling to any <br>initializer, yyy can be of any value allowed for UIntN.<br></p><p>But again, could someone help with examples when this can produce problems <br>at run-time?<br></p><p>On 03.06.2016 1:12, John McCall wrote:<br>&gt;&gt; On Jun 2, 2016, at 2:36 PM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt;&gt; Well, I understand that it seems like there is some problem with UIntN() initialization, but can&#39;t find any simple code that will demonstrate this..<br>&gt;&gt;<br>&gt;&gt; All below works as expected:<br>&gt;&gt;<br>&gt;&gt; var x1: Int32 = 0<br>&gt;&gt; var x2 = Int32(0)<br>&gt;&gt;<br>&gt;&gt; print(x1.dynamicType, x2.dynamicType) // Int32 Int32<br>&gt;&gt;<br>&gt;&gt; // integer overflows when converted from &#39;Int&#39; to &#39;UInt16&#39;<br>&gt;&gt; //var x = UInt16(100_000)<br>&gt;&gt; //var x = UInt16(-10)<br>&gt;&gt;<br>&gt;&gt; // negative integer cannot be converted to unsigned type &#39;UInt64&#39;<br>&gt;&gt; // var x = UInt64(-1)<br>&gt;&gt;<br>&gt;&gt; So, what code will produce some unexpected behavior / error at runtime?<br>&gt;<br>&gt; Like I said, the standard library and compiler conspire to make sure that easy cases like this are caught at compile time, but that would not help non-standard types that conform to IntegerLiteralConvertible.<br>&gt;<br>&gt; Also, even for standard types, the syntax only works statically if the literal fits in the range of Int, which may not be a superset of the desired type.  For example, UInt64(0x10000000000) would not work on a 32-bit platform.  It is diagnosed statically, however.<br>&gt;<br>&gt; John.<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On 03.06.2016 0:25, John McCall wrote:<br>&gt;&gt;&gt;&gt; On Jun 2, 2016, at 1:56 PM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; Often<br>&gt;&gt;&gt;&gt;&gt; this leads to static ambiguities or, worse, causes the literal to be built<br>&gt;&gt;&gt;&gt;&gt; using a default type (such as Int); this may have semantically very<br>&gt;&gt;&gt;&gt;&gt; different results which are only caught at runtime.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Seems like I&#39;m very slow today.. Could you present a couple of examples where such initialization(like UInt16(7)) can produce some unexpected behavior / error at runtime?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; UIntN has unlabeled initializers taking all of the standard integer types, including itself.  The literal type will therefore get defaulted to Int.  The legal range of values for Int may not be a superset of the legal range of values for UIntN.  If the literal is in the legal range for an Int but not for the target type, this might trap at runtime.  Now, for a built-in integer type like UInt16, we will recognize that the coercion always traps and emit an error at compile-time, but this generally won&#39;t apply to other types.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; John.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On 02.06.2016 19:08, John McCall via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt; The official way to build a literal of a specific type is to write the<br>&gt;&gt;&gt;&gt;&gt; literal in an explicitly-typed context, like so:<br>&gt;&gt;&gt;&gt;&gt;   let x: UInt16 = 7<br>&gt;&gt;&gt;&gt;&gt; or<br>&gt;&gt;&gt;&gt;&gt;   let x = 7 as UInt16<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Nonetheless, programmers often try the following:<br>&gt;&gt;&gt;&gt;&gt;   UInt16(7)<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Unfortunately, this does /not/ attempt to construct the value using the<br>&gt;&gt;&gt;&gt;&gt; appropriate literal protocol; it instead performs overload resolution using<br>&gt;&gt;&gt;&gt;&gt; the standard rules, i.e. considering only single-argument unlabelled<br>&gt;&gt;&gt;&gt;&gt; initializers of a type which conforms to IntegerLiteralConvertible.  Often<br>&gt;&gt;&gt;&gt;&gt; this leads to static ambiguities or, worse, causes the literal to be built<br>&gt;&gt;&gt;&gt;&gt; using a default type (such as Int); this may have semantically very<br>&gt;&gt;&gt;&gt;&gt; different results which are only caught at runtime.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; In my opinion, using this initializer-call syntax to build an<br>&gt;&gt;&gt;&gt;&gt; explicitly-typed literal is an obvious and natural choice with several<br>&gt;&gt;&gt;&gt;&gt; advantages over the &quot;as&quot; syntax.  However, even if you disagree, it&#39;s clear<br>&gt;&gt;&gt;&gt;&gt; that programmers are going to continue to independently try to use it, so<br>&gt;&gt;&gt;&gt;&gt; it&#39;s really unfortunate for it to be subtly wrong.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Therefore, I propose that we adopt the following typing rule:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Given a function call expression of the form A(B) (that is, an<br>&gt;&gt;&gt;&gt;&gt; /expr-call/ with a single, unlabelled argument) where B is<br>&gt;&gt;&gt;&gt;&gt; an /expr-literal/ or /expr-collection/, if A has type T.Type for some type<br>&gt;&gt;&gt;&gt;&gt; T and there is a declared conformance of T to an appropriate literal<br>&gt;&gt;&gt;&gt;&gt; protocol for B, then the expression is always resolves as a literal<br>&gt;&gt;&gt;&gt;&gt; construction of type T (as if the expression were written &quot;B as A&quot;) rather<br>&gt;&gt;&gt;&gt;&gt; than as a general initializer call.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Formally, this would be a special form of the argument conversion<br>&gt;&gt;&gt;&gt;&gt; constraint, since the type of the expression A may not be immediately known.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Note that, as specified, it is possible to suppress this typing rule by<br>&gt;&gt;&gt;&gt;&gt; wrapping the literal in parentheses.  This might seem distasteful; it would<br>&gt;&gt;&gt;&gt;&gt; be easy enough to allow the form of B to include extra parentheses.  It&#39;s<br>&gt;&gt;&gt;&gt;&gt; potentially useful to have a way to suppress this rule and get a normal<br>&gt;&gt;&gt;&gt;&gt; construction, but there are several other ways of getting that effect, such<br>&gt;&gt;&gt;&gt;&gt; as explicitly typing the literal argument (e.g. writing &quot;A(Int(B))&quot;).<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; A conditional conformance counts as a declared conformance even if the<br>&gt;&gt;&gt;&gt;&gt; generic arguments are known to not satisfy the conditional conformance.<br>&gt;&gt;&gt;&gt;&gt; This permits the applicability of the rule to be decided without having to<br>&gt;&gt;&gt;&gt;&gt; first decide the type arguments, which greatly simplifies the type-checking<br>&gt;&gt;&gt;&gt;&gt; problem (and may be necessary for soundness; I didn&#39;t explore this in<br>&gt;&gt;&gt;&gt;&gt; depth, but it certainly feels like a very nasty sort of dependence).  We<br>&gt;&gt;&gt;&gt;&gt; could potentially weaken this for cases where A is a direct type reference<br>&gt;&gt;&gt;&gt;&gt; with bound parameters, e.g. Foo&lt;Int&gt;([]) or the same with a typealias, but<br>&gt;&gt;&gt;&gt;&gt; I think there&#39;s some benefit from having a simpler specification, both for<br>&gt;&gt;&gt;&gt;&gt; the implementation and for the explicability of the model.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;<br>&gt; .<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>June  3, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jun 2, 2016, at 10:28 PM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt; &gt; Like I said, the standard library and compiler conspire to make sure that easy cases like this are caught at compile time, but that would not help non-standard types that conform to IntegerLiteralConvertible.<br>&gt; &gt;<br>&gt; &gt; Also, even for standard types, the syntax only works statically if the literal fits in the range of Int, which may not be a superset of the desired type.  For example, UInt64(0x10000000000) would not work on a 32-bit platform.  It is diagnosed statically, however.<br>&gt; <br>&gt; I believe I understand the problem you described, but I really can&#39;t figure out how this problem can produce a unexpected behavior and run-time errors, as was stated in your initial message. So, this is why I was asking for any code that can prove this. The example with UInt64(0x10000000000) on 32bit systems will raise error at _compilation_ time. Could someone provide any code to illustrate the possible problems at run-time?<br></p><p>It&#39;s sufficient to do the same thing as the standard library, just without the @transparent tricks that enable static detection of the failure:<br></p><p>  struct WidgetCount : IntegerLiteralConvertible {<br>    var value: UInt64<br>    init(integerLiteral value: UInt64) {<br>      self.value = value<br>    }<br>    init(_ value: Int) {<br>      self.value = UInt64(value)<br>    }<br>  }<br></p><p>  let count = WidgetCount(-1)<br></p><p>John.<br></p><p><br>&gt; <br>&gt; For others, who not really understand the issue(probably I&#39;m not the one, I hope ;-) ) : If we&#39;d have Int128 type, we can&#39;t create an instance of it in this form:<br>&gt; let x = Int128(92233720368547758070)<br>&gt; (92233720368547758070 == Int.max * 10)<br>&gt; as &#39;92233720368547758070&#39; literal will be treated always as of Int type.<br>&gt; <br>&gt; In more general description, the difference between UIntN(xxx) and yyy as UIntN is that xxx will be treated as Int(so it can&#39;t be greater than Int.max for example) then this Int will be sent to UIntN(:Int) initializer and then we have UIntN as a result of call to initializer; yyy will be treated as UIntN literal just by its definition, no calling to any initializer, yyy can be of any value allowed for UIntN.<br>&gt; <br>&gt; But again, could someone help with examples when this can produce problems at run-time?<br>&gt; <br>&gt; On 03.06.2016 1:12, John McCall wrote:<br>&gt;&gt;&gt; On Jun 2, 2016, at 2:36 PM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt;&gt;&gt; Well, I understand that it seems like there is some problem with UIntN() initialization, but can&#39;t find any simple code that will demonstrate this..<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; All below works as expected:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var x1: Int32 = 0<br>&gt;&gt;&gt; var x2 = Int32(0)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; print(x1.dynamicType, x2.dynamicType) // Int32 Int32<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // integer overflows when converted from &#39;Int&#39; to &#39;UInt16&#39;<br>&gt;&gt;&gt; //var x = UInt16(100_000)<br>&gt;&gt;&gt; //var x = UInt16(-10)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // negative integer cannot be converted to unsigned type &#39;UInt64&#39;<br>&gt;&gt;&gt; // var x = UInt64(-1)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So, what code will produce some unexpected behavior / error at runtime?<br>&gt;&gt; <br>&gt;&gt; Like I said, the standard library and compiler conspire to make sure that easy cases like this are caught at compile time, but that would not help non-standard types that conform to IntegerLiteralConvertible.<br>&gt;&gt; <br>&gt;&gt; Also, even for standard types, the syntax only works statically if the literal fits in the range of Int, which may not be a superset of the desired type.  For example, UInt64(0x10000000000) would not work on a 32-bit platform.  It is diagnosed statically, however.<br>&gt;&gt; <br>&gt;&gt; John.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 03.06.2016 0:25, John McCall wrote:<br>&gt;&gt;&gt;&gt;&gt; On Jun 2, 2016, at 1:56 PM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; Often<br>&gt;&gt;&gt;&gt;&gt;&gt; this leads to static ambiguities or, worse, causes the literal to be built<br>&gt;&gt;&gt;&gt;&gt;&gt; using a default type (such as Int); this may have semantically very<br>&gt;&gt;&gt;&gt;&gt;&gt; different results which are only caught at runtime.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Seems like I&#39;m very slow today.. Could you present a couple of examples where such initialization(like UInt16(7)) can produce some unexpected behavior / error at runtime?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; UIntN has unlabeled initializers taking all of the standard integer types, including itself.  The literal type will therefore get defaulted to Int.  The legal range of values for Int may not be a superset of the legal range of values for UIntN.  If the literal is in the legal range for an Int but not for the target type, this might trap at runtime.  Now, for a built-in integer type like UInt16, we will recognize that the coercion always traps and emit an error at compile-time, but this generally won&#39;t apply to other types.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 02.06.2016 19:08, John McCall via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; The official way to build a literal of a specific type is to write the<br>&gt;&gt;&gt;&gt;&gt;&gt; literal in an explicitly-typed context, like so:<br>&gt;&gt;&gt;&gt;&gt;&gt;  let x: UInt16 = 7<br>&gt;&gt;&gt;&gt;&gt;&gt; or<br>&gt;&gt;&gt;&gt;&gt;&gt;  let x = 7 as UInt16<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Nonetheless, programmers often try the following:<br>&gt;&gt;&gt;&gt;&gt;&gt;  UInt16(7)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Unfortunately, this does /not/ attempt to construct the value using the<br>&gt;&gt;&gt;&gt;&gt;&gt; appropriate literal protocol; it instead performs overload resolution using<br>&gt;&gt;&gt;&gt;&gt;&gt; the standard rules, i.e. considering only single-argument unlabelled<br>&gt;&gt;&gt;&gt;&gt;&gt; initializers of a type which conforms to IntegerLiteralConvertible.  Often<br>&gt;&gt;&gt;&gt;&gt;&gt; this leads to static ambiguities or, worse, causes the literal to be built<br>&gt;&gt;&gt;&gt;&gt;&gt; using a default type (such as Int); this may have semantically very<br>&gt;&gt;&gt;&gt;&gt;&gt; different results which are only caught at runtime.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In my opinion, using this initializer-call syntax to build an<br>&gt;&gt;&gt;&gt;&gt;&gt; explicitly-typed literal is an obvious and natural choice with several<br>&gt;&gt;&gt;&gt;&gt;&gt; advantages over the &quot;as&quot; syntax.  However, even if you disagree, it&#39;s clear<br>&gt;&gt;&gt;&gt;&gt;&gt; that programmers are going to continue to independently try to use it, so<br>&gt;&gt;&gt;&gt;&gt;&gt; it&#39;s really unfortunate for it to be subtly wrong.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Therefore, I propose that we adopt the following typing rule:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Given a function call expression of the form A(B) (that is, an<br>&gt;&gt;&gt;&gt;&gt;&gt; /expr-call/ with a single, unlabelled argument) where B is<br>&gt;&gt;&gt;&gt;&gt;&gt; an /expr-literal/ or /expr-collection/, if A has type T.Type for some type<br>&gt;&gt;&gt;&gt;&gt;&gt; T and there is a declared conformance of T to an appropriate literal<br>&gt;&gt;&gt;&gt;&gt;&gt; protocol for B, then the expression is always resolves as a literal<br>&gt;&gt;&gt;&gt;&gt;&gt; construction of type T (as if the expression were written &quot;B as A&quot;) rather<br>&gt;&gt;&gt;&gt;&gt;&gt; than as a general initializer call.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Formally, this would be a special form of the argument conversion<br>&gt;&gt;&gt;&gt;&gt;&gt; constraint, since the type of the expression A may not be immediately known.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Note that, as specified, it is possible to suppress this typing rule by<br>&gt;&gt;&gt;&gt;&gt;&gt; wrapping the literal in parentheses.  This might seem distasteful; it would<br>&gt;&gt;&gt;&gt;&gt;&gt; be easy enough to allow the form of B to include extra parentheses.  It&#39;s<br>&gt;&gt;&gt;&gt;&gt;&gt; potentially useful to have a way to suppress this rule and get a normal<br>&gt;&gt;&gt;&gt;&gt;&gt; construction, but there are several other ways of getting that effect, such<br>&gt;&gt;&gt;&gt;&gt;&gt; as explicitly typing the literal argument (e.g. writing &quot;A(Int(B))&quot;).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; A conditional conformance counts as a declared conformance even if the<br>&gt;&gt;&gt;&gt;&gt;&gt; generic arguments are known to not satisfy the conditional conformance.<br>&gt;&gt;&gt;&gt;&gt;&gt; This permits the applicability of the rule to be decided without having to<br>&gt;&gt;&gt;&gt;&gt;&gt; first decide the type arguments, which greatly simplifies the type-checking<br>&gt;&gt;&gt;&gt;&gt;&gt; problem (and may be necessary for soundness; I didn&#39;t explore this in<br>&gt;&gt;&gt;&gt;&gt;&gt; depth, but it certainly feels like a very nasty sort of dependence).  We<br>&gt;&gt;&gt;&gt;&gt;&gt; could potentially weaken this for cases where A is a direct type reference<br>&gt;&gt;&gt;&gt;&gt;&gt; with bound parameters, e.g. Foo&lt;Int&gt;([]) or the same with a typealias, but<br>&gt;&gt;&gt;&gt;&gt;&gt; I think there&#39;s some benefit from having a simpler specification, both for<br>&gt;&gt;&gt;&gt;&gt;&gt; the implementation and for the explicability of the model.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; .<br>&gt;&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>June  6, 2016 at 06:00:00pm</p></header><div class="content"><p>On 03.06.2016 21:09, John McCall wrote:<br>&gt;&gt; On Jun 2, 2016, at 10:28 PM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt;&gt;&gt; Like I said, the standard library and compiler conspire to make sure that easy cases like this are caught at compile time, but that would not help non-standard types that conform to IntegerLiteralConvertible.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Also, even for standard types, the syntax only works statically if the literal fits in the range of Int, which may not be a superset of the desired type.  For example, UInt64(0x10000000000) would not work on a 32-bit platform.  It is diagnosed statically, however.<br>&gt;&gt;<br>&gt;&gt; I believe I understand the problem you described, but I really can&#39;t figure out how this problem can produce a unexpected behavior and run-time errors, as was stated in your initial message. So, this is why I was asking for any code that can prove this. The example with UInt64(0x10000000000) on 32bit systems will raise error at _compilation_ time. Could someone provide any code to illustrate the possible problems at run-time?<br>&gt;<br>&gt; It&#39;s sufficient to do the same thing as the standard library, just without the @transparent tricks that enable static detection of the failure:<br></p><p>Thank you, but I was awaiting the example where using of UIntN/IntN() with <br>integer literal produces *unexpected* error at run-time or unexpected <br>behavior (as was stated in your initial message). I don&#39;t understand how <br>the example you sent is connected with this. Could some one provide a <br>sample code to understand in which situations we can have described <br>problems when using UIntN/IntN with integer literals?<br></p><p>About your example : you have init(:Int), you sent -1 to it, UInt64(value) <br>will generate *expected* run time error in this case.<br></p><p><br>&gt;<br>&gt;   struct WidgetCount : IntegerLiteralConvertible {<br>&gt;     var value: UInt64<br>&gt;     init(integerLiteral value: UInt64) {<br>&gt;       self.value = value<br>&gt;     }<br>&gt;     init(_ value: Int) {<br>&gt;       self.value = UInt64(value)<br>&gt;     }<br>&gt;   }<br>&gt;<br>&gt;   let count = WidgetCount(-1)<br>&gt;<br>&gt; John.<br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt; For others, who not really understand the issue(probably I&#39;m not the one, I hope ;-) ) : If we&#39;d have Int128 type, we can&#39;t create an instance of it in this form:<br>&gt;&gt; let x = Int128(92233720368547758070)<br>&gt;&gt; (92233720368547758070 == Int.max * 10)<br>&gt;&gt; as &#39;92233720368547758070&#39; literal will be treated always as of Int type.<br>&gt;&gt;<br>&gt;&gt; In more general description, the difference between UIntN(xxx) and yyy as UIntN is that xxx will be treated as Int(so it can&#39;t be greater than Int.max for example) then this Int will be sent to UIntN(:Int) initializer and then we have UIntN as a result of call to initializer; yyy will be treated as UIntN literal just by its definition, no calling to any initializer, yyy can be of any value allowed for UIntN.<br>&gt;&gt;<br>&gt;&gt; But again, could someone help with examples when this can produce problems at run-time?<br>&gt;&gt;<br>&gt;&gt; On 03.06.2016 1:12, John McCall wrote:<br>&gt;&gt;&gt;&gt; On Jun 2, 2016, at 2:36 PM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; Well, I understand that it seems like there is some problem with UIntN() initialization, but can&#39;t find any simple code that will demonstrate this..<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; All below works as expected:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; var x1: Int32 = 0<br>&gt;&gt;&gt;&gt; var x2 = Int32(0)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; print(x1.dynamicType, x2.dynamicType) // Int32 Int32<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; // integer overflows when converted from &#39;Int&#39; to &#39;UInt16&#39;<br>&gt;&gt;&gt;&gt; //var x = UInt16(100_000)<br>&gt;&gt;&gt;&gt; //var x = UInt16(-10)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; // negative integer cannot be converted to unsigned type &#39;UInt64&#39;<br>&gt;&gt;&gt;&gt; // var x = UInt64(-1)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; So, what code will produce some unexpected behavior / error at runtime?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Like I said, the standard library and compiler conspire to make sure that easy cases like this are caught at compile time, but that would not help non-standard types that conform to IntegerLiteralConvertible.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Also, even for standard types, the syntax only works statically if the literal fits in the range of Int, which may not be a superset of the desired type.  For example, UInt64(0x10000000000) would not work on a 32-bit platform.  It is diagnosed statically, however.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; John.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On 03.06.2016 0:25, John McCall wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 2, 2016, at 1:56 PM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Often<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; this leads to static ambiguities or, worse, causes the literal to be built<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; using a default type (such as Int); this may have semantically very<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; different results which are only caught at runtime.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Seems like I&#39;m very slow today.. Could you present a couple of examples where such initialization(like UInt16(7)) can produce some unexpected behavior / error at runtime?<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; UIntN has unlabeled initializers taking all of the standard integer types, including itself.  The literal type will therefore get defaulted to Int.  The legal range of values for Int may not be a superset of the legal range of values for UIntN.  If the literal is in the legal range for an Int but not for the target type, this might trap at runtime.  Now, for a built-in integer type like UInt16, we will recognize that the coercion always traps and emit an error at compile-time, but this generally won&#39;t apply to other types.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On 02.06.2016 19:08, John McCall via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The official way to build a literal of a specific type is to write the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; literal in an explicitly-typed context, like so:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  let x: UInt16 = 7<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; or<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  let x = 7 as UInt16<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Nonetheless, programmers often try the following:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  UInt16(7)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Unfortunately, this does /not/ attempt to construct the value using the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; appropriate literal protocol; it instead performs overload resolution using<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; the standard rules, i.e. considering only single-argument unlabelled<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; initializers of a type which conforms to IntegerLiteralConvertible.  Often<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; this leads to static ambiguities or, worse, causes the literal to be built<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; using a default type (such as Int); this may have semantically very<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; different results which are only caught at runtime.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; In my opinion, using this initializer-call syntax to build an<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; explicitly-typed literal is an obvious and natural choice with several<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; advantages over the &quot;as&quot; syntax.  However, even if you disagree, it&#39;s clear<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; that programmers are going to continue to independently try to use it, so<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; it&#39;s really unfortunate for it to be subtly wrong.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Therefore, I propose that we adopt the following typing rule:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Given a function call expression of the form A(B) (that is, an<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; /expr-call/ with a single, unlabelled argument) where B is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; an /expr-literal/ or /expr-collection/, if A has type T.Type for some type<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; T and there is a declared conformance of T to an appropriate literal<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol for B, then the expression is always resolves as a literal<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; construction of type T (as if the expression were written &quot;B as A&quot;) rather<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; than as a general initializer call.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Formally, this would be a special form of the argument conversion<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; constraint, since the type of the expression A may not be immediately known.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Note that, as specified, it is possible to suppress this typing rule by<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrapping the literal in parentheses.  This might seem distasteful; it would<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; be easy enough to allow the form of B to include extra parentheses.  It&#39;s<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; potentially useful to have a way to suppress this rule and get a normal<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; construction, but there are several other ways of getting that effect, such<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; as explicitly typing the literal argument (e.g. writing &quot;A(Int(B))&quot;).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; A conditional conformance counts as a declared conformance even if the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; generic arguments are known to not satisfy the conditional conformance.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This permits the applicability of the rule to be decided without having to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; first decide the type arguments, which greatly simplifies the type-checking<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; problem (and may be necessary for soundness; I didn&#39;t explore this in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; depth, but it certainly feels like a very nasty sort of dependence).  We<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; could potentially weaken this for cases where A is a direct type reference<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; with bound parameters, e.g. Foo&lt;Int&gt;([]) or the same with a typealias, but<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think there&#39;s some benefit from having a simpler specification, both for<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; the implementation and for the explicability of the model.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; .<br>&gt;&gt;&gt;<br>&gt;<br>&gt; .<br>&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>June  2, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jun 2, 2016, at 9:08 AM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The official way to build a literal of a specific type is to write the literal in an explicitly-typed context, like so:<br>&gt;     let x: UInt16 = 7<br>&gt; or<br>&gt;     let x = 7 as UInt16<br>&gt; <br>&gt; Nonetheless, programmers often try the following:<br>&gt;     UInt16(7)<br>&gt; <br>&gt; Unfortunately, this does not attempt to construct the value using the appropriate literal protocol; it instead performs overload resolution using the standard rules, i.e. considering only single-argument unlabelled initializers of a type which conforms to IntegerLiteralConvertible.  Often this leads to static ambiguities or, worse, causes the literal to be built using a default type (such as Int); this may have semantically very different results which are only caught at runtime.<br></p><p><br>+1 to the proposal; I’m embarrassed to admit I thought it worked this way already. <br></p><p>Any type that wants more control shouldn’t be adopting the literal convertible protocols anyway.<br></p><p>Russ<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/19bc0729/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e910871dda004717de19e83626308b5a?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>Tony Allevato</string> &lt;allevato at google.com&gt;<p>June  2, 2016 at 09:00:00pm</p></header><div class="content"><p>+1. As someone who thought &quot;var x: Int32 = 0&quot; and &quot;var x = Int32(0)&quot; were<br>equivalent, this is very good to know (and very good to fix).<br></p><p>I&#39;m starting to wonder now if some of the times I&#39;ve hit &quot;expression was<br>too complex&quot; errors with large 64-bit multi-term expressions with literals<br>were caused by coercions happening that I didn&#39;t realize.<br></p><p><br>On Thu, Jun 2, 2016 at 9:31 AM John McCall via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; The official way to build a literal of a specific type is to write the<br>&gt; literal in an explicitly-typed context, like so:<br>&gt;     let x: UInt16 = 7<br>&gt; or<br>&gt;     let x = 7 as UInt16<br>&gt;<br>&gt; Nonetheless, programmers often try the following:<br>&gt;     UInt16(7)<br>&gt;<br>&gt; Unfortunately, this does *not* attempt to construct the value using the<br>&gt; appropriate literal protocol; it instead performs overload resolution using<br>&gt; the standard rules, i.e. considering only single-argument unlabelled<br>&gt; initializers of a type which conforms to IntegerLiteralConvertible.  Often<br>&gt; this leads to static ambiguities or, worse, causes the literal to be built<br>&gt; using a default type (such as Int); this may have semantically very<br>&gt; different results which are only caught at runtime.<br>&gt;<br>&gt; In my opinion, using this initializer-call syntax to build an<br>&gt; explicitly-typed literal is an obvious and natural choice with several<br>&gt; advantages over the &quot;as&quot; syntax.  However, even if you disagree, it&#39;s clear<br>&gt; that programmers are going to continue to independently try to use it, so<br>&gt; it&#39;s really unfortunate for it to be subtly wrong.<br>&gt;<br>&gt; Therefore, I propose that we adopt the following typing rule:<br>&gt;<br>&gt;   Given a function call expression of the form A(B) (that is, an<br>&gt; *expr-call* with a single, unlabelled argument) where B is an<br>&gt; *expr-literal* or *expr-collection*, if A has type T.Type for some type T<br>&gt; and there is a declared conformance of T to an appropriate literal protocol<br>&gt; for B, then the expression is always resolves as a literal construction of<br>&gt; type T (as if the expression were written &quot;B as A&quot;) rather than as a<br>&gt; general initializer call.<br>&gt;<br>&gt; Formally, this would be a special form of the argument conversion<br>&gt; constraint, since the type of the expression A may not be immediately known.<br>&gt;<br>&gt; Note that, as specified, it is possible to suppress this typing rule by<br>&gt; wrapping the literal in parentheses.  This might seem distasteful; it would<br>&gt; be easy enough to allow the form of B to include extra parentheses.  It&#39;s<br>&gt; potentially useful to have a way to suppress this rule and get a normal<br>&gt; construction, but there are several other ways of getting that effect, such<br>&gt; as explicitly typing the literal argument (e.g. writing &quot;A(Int(B))&quot;).<br>&gt;<br>&gt; A conditional conformance counts as a declared conformance even if the<br>&gt; generic arguments are known to not satisfy the conditional conformance.<br>&gt; This permits the applicability of the rule to be decided without having to<br>&gt; first decide the type arguments, which greatly simplifies the type-checking<br>&gt; problem (and may be necessary for soundness; I didn&#39;t explore this in<br>&gt; depth, but it certainly feels like a very nasty sort of dependence).  We<br>&gt; could potentially weaken this for cases where A is a direct type reference<br>&gt; with bound parameters, e.g. Foo&lt;Int&gt;([]) or the same with a typealias, but<br>&gt; I think there&#39;s some benefit from having a simpler specification, both for<br>&gt; the implementation and for the explicability of the model.<br>&gt;<br>&gt; John.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/34726f83/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>June  3, 2016 at 12:00:00am</p></header><div class="content"><p>What is wrong with your examples?<br></p><p>var x1: Int32 = 0<br>var x2 = Int32(0)<br>print(x1.dynamicType, x2.dynamicType) // Int32 Int32<br></p><p><br>On 03.06.2016 0:17, Tony Allevato via swift-evolution wrote:<br>&gt; +1. As someone who thought &quot;var x: Int32 = 0&quot; and &quot;var x = Int32(0)&quot; were<br>&gt; equivalent, this is very good to know (and very good to fix).<br>&gt;<br>&gt; I&#39;m starting to wonder now if some of the times I&#39;ve hit &quot;expression was<br>&gt; too complex&quot; errors with large 64-bit multi-term expressions with literals<br>&gt; were caused by coercions happening that I didn&#39;t realize.<br>&gt;<br>&gt;<br>&gt; On Thu, Jun 2, 2016 at 9:31 AM John McCall via swift-evolution<br>&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;<br>&gt;     The official way to build a literal of a specific type is to write the<br>&gt;     literal in an explicitly-typed context, like so:<br>&gt;         let x: UInt16 = 7<br>&gt;     or<br>&gt;         let x = 7 as UInt16<br>&gt;<br>&gt;     Nonetheless, programmers often try the following:<br>&gt;         UInt16(7)<br>&gt;<br>&gt;     Unfortunately, this does /not/ attempt to construct the value using the<br>&gt;     appropriate literal protocol; it instead performs overload resolution<br>&gt;     using the standard rules, i.e. considering only single-argument<br>&gt;     unlabelled initializers of a type which conforms to<br>&gt;     IntegerLiteralConvertible.  Often this leads to static ambiguities or,<br>&gt;     worse, causes the literal to be built using a default type (such as<br>&gt;     Int); this may have semantically very different results which are only<br>&gt;     caught at runtime.<br>&gt;<br>&gt;     In my opinion, using this initializer-call syntax to build an<br>&gt;     explicitly-typed literal is an obvious and natural choice with several<br>&gt;     advantages over the &quot;as&quot; syntax.  However, even if you disagree, it&#39;s<br>&gt;     clear that programmers are going to continue to independently try to<br>&gt;     use it, so it&#39;s really unfortunate for it to be subtly wrong.<br>&gt;<br>&gt;     Therefore, I propose that we adopt the following typing rule:<br>&gt;<br>&gt;       Given a function call expression of the form A(B) (that is, an<br>&gt;     /expr-call/ with a single, unlabelled argument) where B is<br>&gt;     an /expr-literal/ or /expr-collection/, if A has type T.Type for some<br>&gt;     type T and there is a declared conformance of T to an appropriate<br>&gt;     literal protocol for B, then the expression is always resolves as a<br>&gt;     literal construction of type T (as if the expression were written &quot;B as<br>&gt;     A&quot;) rather than as a general initializer call.<br>&gt;<br>&gt;     Formally, this would be a special form of the argument conversion<br>&gt;     constraint, since the type of the expression A may not be immediately<br>&gt;     known.<br>&gt;<br>&gt;     Note that, as specified, it is possible to suppress this typing rule by<br>&gt;     wrapping the literal in parentheses.  This might seem distasteful; it<br>&gt;     would be easy enough to allow the form of B to include extra<br>&gt;     parentheses.  It&#39;s potentially useful to have a way to suppress this<br>&gt;     rule and get a normal construction, but there are several other ways of<br>&gt;     getting that effect, such as explicitly typing the literal argument<br>&gt;     (e.g. writing &quot;A(Int(B))&quot;).<br>&gt;<br>&gt;     A conditional conformance counts as a declared conformance even if the<br>&gt;     generic arguments are known to not satisfy the conditional<br>&gt;     conformance.  This permits the applicability of the rule to be decided<br>&gt;     without having to first decide the type arguments, which greatly<br>&gt;     simplifies the type-checking problem (and may be necessary for<br>&gt;     soundness; I didn&#39;t explore this in depth, but it certainly feels like<br>&gt;     a very nasty sort of dependence).  We could potentially weaken this for<br>&gt;     cases where A is a direct type reference with bound parameters, e.g.<br>&gt;     Foo&lt;Int&gt;([]) or the same with a typealias, but I think there&#39;s some<br>&gt;     benefit from having a simpler specification, both for the<br>&gt;     implementation and for the explicability of the model.<br>&gt;<br>&gt;     John.<br>&gt;     _______________________________________________<br>&gt;     swift-evolution mailing list<br>&gt;     swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e910871dda004717de19e83626308b5a?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>Tony Allevato</string> &lt;allevato at google.com&gt;<p>June  2, 2016 at 09:00:00pm</p></header><div class="content"><p>On Thu, Jun 2, 2016 at 2:38 PM Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br></p><p>&gt; What is wrong with your examples?<br>&gt;<br>&gt; var x1: Int32 = 0<br>&gt; var x2 = Int32(0)<br>&gt; print(x1.dynamicType, x2.dynamicType) // Int32 Int32<br>&gt;<br></p><p>I was referring to the subtle distinction between creating an Int32 from a<br>literal (the first one) and creating an Int from a literal and then<br>coercing it to Int32 (the second one). So, I was pondering whether this was<br>the cause of some complex expressions I&#39;ve had problems with in the past.<br>However, looking at the specific code, it looks like I had the *opposite*<br>problem.<br></p><p>This expression is evaluated quickly in Swift 2.2:<br></p><p>let value = Int64((0x1b &lt;&lt; 0) | (0x28 &lt;&lt; 7) | (0x79 &lt;&lt; 14) | (0x42 &lt;&lt; 21) |<br>(0x3b &lt;&lt; 28) |<br>      (0x56 &lt;&lt; 35) | (0x00 &lt;&lt; 42) | (0x05 &lt;&lt; 49) | (0x26 &lt;&lt; 56) | (0x01 &lt;&lt;<br>63))<br></p><p>This one errors out with &quot;expression was too complex to be solved in<br>reasonable time&quot;:<br></p><p>let value: Int64 = (0x1b &lt;&lt; 0) | (0x28 &lt;&lt; 7) | (0x79 &lt;&lt; 14) | (0x42 &lt;&lt; 21)<br>| (0x3b &lt;&lt; 28) |<br>      (0x56 &lt;&lt; 35) | (0x00 &lt;&lt; 42) | (0x05 &lt;&lt; 49) | (0x26 &lt;&lt; 56) | (0x01 &lt;&lt;<br>63)<br></p><p><br></p><p>&gt;<br>&gt; On 03.06.2016 0:17, Tony Allevato via swift-evolution wrote:<br>&gt; &gt; +1. As someone who thought &quot;var x: Int32 = 0&quot; and &quot;var x = Int32(0)&quot; were<br>&gt; &gt; equivalent, this is very good to know (and very good to fix).<br>&gt; &gt;<br>&gt; &gt; I&#39;m starting to wonder now if some of the times I&#39;ve hit &quot;expression was<br>&gt; &gt; too complex&quot; errors with large 64-bit multi-term expressions with<br>&gt; literals<br>&gt; &gt; were caused by coercions happening that I didn&#39;t realize.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; On Thu, Jun 2, 2016 at 9:31 AM John McCall via swift-evolution<br>&gt; &gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;     The official way to build a literal of a specific type is to write<br>&gt; the<br>&gt; &gt;     literal in an explicitly-typed context, like so:<br>&gt; &gt;         let x: UInt16 = 7<br>&gt; &gt;     or<br>&gt; &gt;         let x = 7 as UInt16<br>&gt; &gt;<br>&gt; &gt;     Nonetheless, programmers often try the following:<br>&gt; &gt;         UInt16(7)<br>&gt; &gt;<br>&gt; &gt;     Unfortunately, this does /not/ attempt to construct the value using<br>&gt; the<br>&gt; &gt;     appropriate literal protocol; it instead performs overload resolution<br>&gt; &gt;     using the standard rules, i.e. considering only single-argument<br>&gt; &gt;     unlabelled initializers of a type which conforms to<br>&gt; &gt;     IntegerLiteralConvertible.  Often this leads to static ambiguities<br>&gt; or,<br>&gt; &gt;     worse, causes the literal to be built using a default type (such as<br>&gt; &gt;     Int); this may have semantically very different results which are<br>&gt; only<br>&gt; &gt;     caught at runtime.<br>&gt; &gt;<br>&gt; &gt;     In my opinion, using this initializer-call syntax to build an<br>&gt; &gt;     explicitly-typed literal is an obvious and natural choice with<br>&gt; several<br>&gt; &gt;     advantages over the &quot;as&quot; syntax.  However, even if you disagree, it&#39;s<br>&gt; &gt;     clear that programmers are going to continue to independently try to<br>&gt; &gt;     use it, so it&#39;s really unfortunate for it to be subtly wrong.<br>&gt; &gt;<br>&gt; &gt;     Therefore, I propose that we adopt the following typing rule:<br>&gt; &gt;<br>&gt; &gt;       Given a function call expression of the form A(B) (that is, an<br>&gt; &gt;     /expr-call/ with a single, unlabelled argument) where B is<br>&gt; &gt;     an /expr-literal/ or /expr-collection/, if A has type T.Type for some<br>&gt; &gt;     type T and there is a declared conformance of T to an appropriate<br>&gt; &gt;     literal protocol for B, then the expression is always resolves as a<br>&gt; &gt;     literal construction of type T (as if the expression were written &quot;B<br>&gt; as<br>&gt; &gt;     A&quot;) rather than as a general initializer call.<br>&gt; &gt;<br>&gt; &gt;     Formally, this would be a special form of the argument conversion<br>&gt; &gt;     constraint, since the type of the expression A may not be immediately<br>&gt; &gt;     known.<br>&gt; &gt;<br>&gt; &gt;     Note that, as specified, it is possible to suppress this typing rule<br>&gt; by<br>&gt; &gt;     wrapping the literal in parentheses.  This might seem distasteful; it<br>&gt; &gt;     would be easy enough to allow the form of B to include extra<br>&gt; &gt;     parentheses.  It&#39;s potentially useful to have a way to suppress this<br>&gt; &gt;     rule and get a normal construction, but there are several other ways<br>&gt; of<br>&gt; &gt;     getting that effect, such as explicitly typing the literal argument<br>&gt; &gt;     (e.g. writing &quot;A(Int(B))&quot;).<br>&gt; &gt;<br>&gt; &gt;     A conditional conformance counts as a declared conformance even if<br>&gt; the<br>&gt; &gt;     generic arguments are known to not satisfy the conditional<br>&gt; &gt;     conformance.  This permits the applicability of the rule to be<br>&gt; decided<br>&gt; &gt;     without having to first decide the type arguments, which greatly<br>&gt; &gt;     simplifies the type-checking problem (and may be necessary for<br>&gt; &gt;     soundness; I didn&#39;t explore this in depth, but it certainly feels<br>&gt; like<br>&gt; &gt;     a very nasty sort of dependence).  We could potentially weaken this<br>&gt; for<br>&gt; &gt;     cases where A is a direct type reference with bound parameters, e.g.<br>&gt; &gt;     Foo&lt;Int&gt;([]) or the same with a typealias, but I think there&#39;s some<br>&gt; &gt;     benefit from having a simpler specification, both for the<br>&gt; &gt;     implementation and for the explicability of the model.<br>&gt; &gt;<br>&gt; &gt;     John.<br>&gt; &gt;     _______________________________________________<br>&gt; &gt;     swift-evolution mailing list<br>&gt; &gt;     swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/c0b00971/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>June  3, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; I was referring to the subtle distinction between creating an Int32 from a<br> &gt; literal (the first one) and creating an Int from a literal and then<br> &gt; coercing it to Int32 (the second one).<br></p><p>I understand the difference and just trying to find out if that <br>behavior(Int32(x) vs x as Int32)  could really produce problems at run-time <br>as was stated in initial message for this proposal.<br></p><p>On 03.06.2016 0:57, Tony Allevato wrote:<br>&gt; On Thu, Jun 2, 2016 at 2:38 PM Vladimir.S &lt;svabox at gmail.com<br>&gt; &lt;mailto:svabox at gmail.com&gt;&gt; wrote:<br>&gt;<br>&gt;     What is wrong with your examples?<br>&gt;<br>&gt;     var x1: Int32 = 0<br>&gt;     var x2 = Int32(0)<br>&gt;     print(x1.dynamicType, x2.dynamicType) // Int32 Int32<br>&gt;<br>&gt;<br>&gt; I was referring to the subtle distinction between creating an Int32 from a<br>&gt; literal (the first one) and creating an Int from a literal and then<br>&gt; coercing it to Int32 (the second one). So, I was pondering whether this was<br>&gt; the cause of some complex expressions I&#39;ve had problems with in the past.<br>&gt; However, looking at the specific code, it looks like I had the *opposite*<br>&gt; problem.<br>&gt;<br>&gt; This expression is evaluated quickly in Swift 2.2:<br>&gt;<br>&gt; let value = Int64((0x1b &lt;&lt; 0) | (0x28 &lt;&lt; 7) | (0x79 &lt;&lt; 14) | (0x42 &lt;&lt; 21) |<br>&gt; (0x3b &lt;&lt; 28) |<br>&gt;       (0x56 &lt;&lt; 35) | (0x00 &lt;&lt; 42) | (0x05 &lt;&lt; 49) | (0x26 &lt;&lt; 56) | (0x01 &lt;&lt; 63))<br>&gt;<br>&gt; This one errors out with &quot;expression was too complex to be solved in<br>&gt; reasonable time&quot;:<br>&gt;<br>&gt; let value: Int64 = (0x1b &lt;&lt; 0) | (0x28 &lt;&lt; 7) | (0x79 &lt;&lt; 14) | (0x42 &lt;&lt; 21)<br>&gt; | (0x3b &lt;&lt; 28) |<br>&gt;       (0x56 &lt;&lt; 35) | (0x00 &lt;&lt; 42) | (0x05 &lt;&lt; 49) | (0x26 &lt;&lt; 56) | (0x01 &lt;&lt; 63)<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;     On 03.06.2016 0:17, Tony Allevato via swift-evolution wrote:<br>&gt;     &gt; +1. As someone who thought &quot;var x: Int32 = 0&quot; and &quot;var x = Int32(0)&quot; were<br>&gt;     &gt; equivalent, this is very good to know (and very good to fix).<br>&gt;     &gt;<br>&gt;     &gt; I&#39;m starting to wonder now if some of the times I&#39;ve hit &quot;expression was<br>&gt;     &gt; too complex&quot; errors with large 64-bit multi-term expressions with<br>&gt;     literals<br>&gt;     &gt; were caused by coercions happening that I didn&#39;t realize.<br>&gt;     &gt;<br>&gt;     &gt;<br>&gt;     &gt; On Thu, Jun 2, 2016 at 9:31 AM John McCall via swift-evolution<br>&gt;     &gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;     &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;     wrote:<br>&gt;     &gt;<br>&gt;     &gt;     The official way to build a literal of a specific type is to<br>&gt;     write the<br>&gt;     &gt;     literal in an explicitly-typed context, like so:<br>&gt;     &gt;         let x: UInt16 = 7<br>&gt;     &gt;     or<br>&gt;     &gt;         let x = 7 as UInt16<br>&gt;     &gt;<br>&gt;     &gt;     Nonetheless, programmers often try the following:<br>&gt;     &gt;         UInt16(7)<br>&gt;     &gt;<br>&gt;     &gt;     Unfortunately, this does /not/ attempt to construct the value<br>&gt;     using the<br>&gt;     &gt;     appropriate literal protocol; it instead performs overload resolution<br>&gt;     &gt;     using the standard rules, i.e. considering only single-argument<br>&gt;     &gt;     unlabelled initializers of a type which conforms to<br>&gt;     &gt;     IntegerLiteralConvertible.  Often this leads to static<br>&gt;     ambiguities or,<br>&gt;     &gt;     worse, causes the literal to be built using a default type (such as<br>&gt;     &gt;     Int); this may have semantically very different results which are<br>&gt;     only<br>&gt;     &gt;     caught at runtime.<br>&gt;     &gt;<br>&gt;     &gt;     In my opinion, using this initializer-call syntax to build an<br>&gt;     &gt;     explicitly-typed literal is an obvious and natural choice with<br>&gt;     several<br>&gt;     &gt;     advantages over the &quot;as&quot; syntax.  However, even if you disagree, it&#39;s<br>&gt;     &gt;     clear that programmers are going to continue to independently try to<br>&gt;     &gt;     use it, so it&#39;s really unfortunate for it to be subtly wrong.<br>&gt;     &gt;<br>&gt;     &gt;     Therefore, I propose that we adopt the following typing rule:<br>&gt;     &gt;<br>&gt;     &gt;       Given a function call expression of the form A(B) (that is, an<br>&gt;     &gt;     /expr-call/ with a single, unlabelled argument) where B is<br>&gt;     &gt;     an /expr-literal/ or /expr-collection/, if A has type T.Type for some<br>&gt;     &gt;     type T and there is a declared conformance of T to an appropriate<br>&gt;     &gt;     literal protocol for B, then the expression is always resolves as a<br>&gt;     &gt;     literal construction of type T (as if the expression were written<br>&gt;     &quot;B as<br>&gt;     &gt;     A&quot;) rather than as a general initializer call.<br>&gt;     &gt;<br>&gt;     &gt;     Formally, this would be a special form of the argument conversion<br>&gt;     &gt;     constraint, since the type of the expression A may not be immediately<br>&gt;     &gt;     known.<br>&gt;     &gt;<br>&gt;     &gt;     Note that, as specified, it is possible to suppress this typing<br>&gt;     rule by<br>&gt;     &gt;     wrapping the literal in parentheses.  This might seem distasteful; it<br>&gt;     &gt;     would be easy enough to allow the form of B to include extra<br>&gt;     &gt;     parentheses.  It&#39;s potentially useful to have a way to suppress this<br>&gt;     &gt;     rule and get a normal construction, but there are several other<br>&gt;     ways of<br>&gt;     &gt;     getting that effect, such as explicitly typing the literal argument<br>&gt;     &gt;     (e.g. writing &quot;A(Int(B))&quot;).<br>&gt;     &gt;<br>&gt;     &gt;     A conditional conformance counts as a declared conformance even<br>&gt;     if the<br>&gt;     &gt;     generic arguments are known to not satisfy the conditional<br>&gt;     &gt;     conformance.  This permits the applicability of the rule to be<br>&gt;     decided<br>&gt;     &gt;     without having to first decide the type arguments, which greatly<br>&gt;     &gt;     simplifies the type-checking problem (and may be necessary for<br>&gt;     &gt;     soundness; I didn&#39;t explore this in depth, but it certainly feels<br>&gt;     like<br>&gt;     &gt;     a very nasty sort of dependence).  We could potentially weaken<br>&gt;     this for<br>&gt;     &gt;     cases where A is a direct type reference with bound parameters, e.g.<br>&gt;     &gt;     Foo&lt;Int&gt;([]) or the same with a typealias, but I think there&#39;s some<br>&gt;     &gt;     benefit from having a simpler specification, both for the<br>&gt;     &gt;     implementation and for the explicability of the model.<br>&gt;     &gt;<br>&gt;     &gt;     John.<br>&gt;     &gt;     _______________________________________________<br>&gt;     &gt;     swift-evolution mailing list<br>&gt;     &gt;     swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;     &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;     &gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;     &gt;<br>&gt;     &gt;<br>&gt;     &gt;<br>&gt;     &gt; _______________________________________________<br>&gt;     &gt; swift-evolution mailing list<br>&gt;     &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;     &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;     &gt;<br>&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June  2, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; In my opinion, using this initializer-call syntax to build an explicitly-typed literal is an obvious and natural choice with several advantages over the &quot;as&quot; syntax.  However, even if you disagree, it&#39;s clear that programmers are going to continue to independently try to use it, so it&#39;s really unfortunate for it to be subtly wrong.<br></p><p>I&#39;ve seen developers do this; in one memorable case, it resulted in Swift taking a ridiculously long time to typecheck an expression, since the seemingly pinned-down types of the literals had actually become *more* ambiguous, not less.<br></p><p>However, it&#39;s not difficult to teach developers to use `as`. Usually what&#39;s happening is that their mental model of the language is wrong: they think of `UInt16(foo)` as a cast to a primitive type, and are surprised to learn that it&#39;s actually an initializer on a struct and they&#39;re initializing an instance. Learning this helps them understand how the language works, what the difference is between initializers and `as`, and how they can write the same things they see in the standard library types.<br></p><p>I think *actually* turning this into magic would be counterproductive. The better solution is to make the compiler replace me in that story, by having it emit a warning with a fix-it. It keeps initializer calls meaning exactly what they say. (And it doesn&#39;t require an evolution proposal to do, since you can add a warning with a mere bug.)<br></p><p>	UInt16(42)<br>	^~~~~~ ^~<br>	Use of initializer with integer literal does not cast &#39;42&#39; to &#39;UInt16&#39;<br>	Fix-It: Replace with &#39;42 as UInt16&#39;<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June  2, 2016 at 09:00:00pm</p></header><div class="content"><p>See, I&#39;ve made this mistake as well, and *not* because I thought it casts<br>the literal. I had always assumed that something like `UInt16(42)` would<br>initialize using the integer literal init, since it seems logical that<br>that&#39;s the most specific. The proposed change reflects my currently<br>erroneous mental model.<br>On Thu, Jun 2, 2016 at 16:42 Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; In my opinion, using this initializer-call syntax to build an<br>&gt; explicitly-typed literal is an obvious and natural choice with several<br>&gt; advantages over the &quot;as&quot; syntax.  However, even if you disagree, it&#39;s clear<br>&gt; that programmers are going to continue to independently try to use it, so<br>&gt; it&#39;s really unfortunate for it to be subtly wrong.<br>&gt;<br>&gt; I&#39;ve seen developers do this; in one memorable case, it resulted in Swift<br>&gt; taking a ridiculously long time to typecheck an expression, since the<br>&gt; seemingly pinned-down types of the literals had actually become *more*<br>&gt; ambiguous, not less.<br>&gt;<br>&gt; However, it&#39;s not difficult to teach developers to use `as`. Usually<br>&gt; what&#39;s happening is that their mental model of the language is wrong: they<br>&gt; think of `UInt16(foo)` as a cast to a primitive type, and are surprised to<br>&gt; learn that it&#39;s actually an initializer on a struct and they&#39;re<br>&gt; initializing an instance. Learning this helps them understand how the<br>&gt; language works, what the difference is between initializers and `as`, and<br>&gt; how they can write the same things they see in the standard library types.<br>&gt;<br>&gt; I think *actually* turning this into magic would be counterproductive. The<br>&gt; better solution is to make the compiler replace me in that story, by having<br>&gt; it emit a warning with a fix-it. It keeps initializer calls meaning exactly<br>&gt; what they say. (And it doesn&#39;t require an evolution proposal to do, since<br>&gt; you can add a warning with a mere bug.)<br>&gt;<br>&gt;         UInt16(42)<br>&gt;         ^~~~~~ ^~<br>&gt;         Use of initializer with integer literal does not cast &#39;42&#39; to<br>&gt; &#39;UInt16&#39;<br>&gt;         Fix-It: Replace with &#39;42 as UInt16&#39;<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/2b19bcaa/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>June  2, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jun 2, 2016, at 2:43 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt; In my opinion, using this initializer-call syntax to build an explicitly-typed literal is an obvious and natural choice with several advantages over the &quot;as&quot; syntax.  However, even if you disagree, it&#39;s clear that programmers are going to continue to independently try to use it, so it&#39;s really unfortunate for it to be subtly wrong.<br>&gt; <br>&gt; I&#39;ve seen developers do this; in one memorable case, it resulted in Swift taking a ridiculously long time to typecheck an expression, since the seemingly pinned-down types of the literals had actually become *more* ambiguous, not less.<br></p><p>Yes, this would also tend to improve compile times, since currently we end up generating a massively-ambiguous constraint system which must be resolved by type defaulting.  That&#39;s not really why I&#39;m proposing this, though.<br></p><p>&gt; However, it&#39;s not difficult to teach developers to use `as`. Usually what&#39;s happening is that their mental model of the language is wrong: they think of `UInt16(foo)` as a cast to a primitive type, and are surprised to learn that it&#39;s actually an initializer on a struct and they&#39;re initializing an instance. Learning this helps them understand how the language works, what the difference is between initializers and `as`, and how they can write the same things they see in the standard library types.<br></p><p>So, you think that this syntax is enticing to new developers who naturally think that the feature works the way that I&#39;m proposing it should work, and you think that the right solution is to make the syntax illegal so that you can more conveniently tell them it doesn&#39;t work that way? :)<br></p><p>You can still tell them that it&#39;s a struct and you&#39;re calling an initializer on it; it&#39;s just that the initializer chosen is the special literal initializer because the argument is a literal.<br></p><p>John.<br></p><p><br></p><p>&gt; <br>&gt; I think *actually* turning this into magic would be counterproductive. The better solution is to make the compiler replace me in that story, by having it emit a warning with a fix-it. It keeps initializer calls meaning exactly what they say. (And it doesn&#39;t require an evolution proposal to do, since you can add a warning with a mere bug.)<br>&gt; <br>&gt; 	UInt16(42)<br>&gt; 	^~~~~~ ^~<br>&gt; 	Use of initializer with integer literal does not cast &#39;42&#39; to &#39;UInt16&#39;<br>&gt; 	Fix-It: Replace with &#39;42 as UInt16&#39;<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June  2, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; So, you think that this syntax is enticing to new developers who naturally think that the feature works the way that I&#39;m proposing it should work, and you think that the right solution is to make the syntax illegal so that you can more conveniently tell them it doesn&#39;t work that way? :)<br></p><p>I think the difference between a cast (which merely reinterprets a value as a compatible type) and a fullwidth conversion (which creates a similar instance of an incompatible type) is very important to understanding how to write Swift, and we shouldn&#39;t muddy the waters by creating a magic syntax.<br></p><p>&gt; You can still tell them that it&#39;s a struct and you&#39;re calling an initializer on it; it&#39;s just that the initializer chosen is the special literal initializer because the argument is a literal.<br></p><p>If you&#39;re planning to change `IntegerLiteralConvertible` and friends to require a fullwidth conversion initializer like `init(_ value: IntegerLiteralType)`, then this is simply an overload resolution rule. In that case, I think your proposal is fine.<br></p><p>But if you&#39;re going to call `init(integerLiteral:)` like it&#39;s `init(_:)`, I don&#39;t think that&#39;s a good idea. Parameter labels are supposed to be significant; we don&#39;t want to lose that.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>June  2, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jun 2, 2016, at 4:22 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt; So, you think that this syntax is enticing to new developers who naturally think that the feature works the way that I&#39;m proposing it should work, and you think that the right solution is to make the syntax illegal so that you can more conveniently tell them it doesn&#39;t work that way? :)<br>&gt; <br>&gt; I think the difference between a cast (which merely reinterprets a value as a compatible type) and a fullwidth conversion (which creates a similar instance of an incompatible type) is very important to understanding how to write Swift, and we shouldn&#39;t muddy the waters by creating a magic syntax.<br></p><p>My point is that a literal doesn&#39;t really have a pre-existing type.  Your explanation relies on a very strange model in which we assign it an arbitrary type just so we can introduce unwanted semantic conversions from that type.<br></p><p>&gt;&gt; You can still tell them that it&#39;s a struct and you&#39;re calling an initializer on it; it&#39;s just that the initializer chosen is the special literal initializer because the argument is a literal.<br>&gt; <br>&gt; If you&#39;re planning to change `IntegerLiteralConvertible` and friends to require a fullwidth conversion initializer like `init(_ value: IntegerLiteralType)`, then this is simply an overload resolution rule. In that case, I think your proposal is fine.<br></p><p>This does not work.  Literal construction is not necessarily as simple as converting from an existing type, and it&#39;s important to use a semantically distinguished initializer.<br></p><p>&gt; But if you&#39;re going to call `init(integerLiteral:)` like it&#39;s `init(_:)`, I don&#39;t think that&#39;s a good idea. Parameter labels are supposed to be significant; we don&#39;t want to lose that.<br></p><p>It sounds like you&#39;re not in favor of the proposal, then.<br></p><p>John.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June  2, 2016 at 11:00:00pm</p></header><div class="content"><p>The IntegerLiteral type idea might be worth exploring. It does seem to<br>provide some additional consistency. For example, wasn&#39;t it clarified on<br>this list just recently that literals don&#39;t have a type and adopt one based<br>on context? It&#39;d be nice to point out that 42 is an IntegerLiteral when<br>explaining that it&#39;s not an Int.<br></p><p>On Thu, Jun 2, 2016 at 18:22 Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; So, you think that this syntax is enticing to new developers who<br>&gt; naturally think that the feature works the way that I&#39;m proposing it should<br>&gt; work, and you think that the right solution is to make the syntax illegal<br>&gt; so that you can more conveniently tell them it doesn&#39;t work that way? :)<br>&gt;<br>&gt; I think the difference between a cast (which merely reinterprets a value<br>&gt; as a compatible type) and a fullwidth conversion (which creates a similar<br>&gt; instance of an incompatible type) is very important to understanding how to<br>&gt; write Swift, and we shouldn&#39;t muddy the waters by creating a magic syntax.<br>&gt;<br>&gt; &gt; You can still tell them that it&#39;s a struct and you&#39;re calling an<br>&gt; initializer on it; it&#39;s just that the initializer chosen is the special<br>&gt; literal initializer because the argument is a literal.<br>&gt;<br>&gt; If you&#39;re planning to change `IntegerLiteralConvertible` and friends to<br>&gt; require a fullwidth conversion initializer like `init(_ value:<br>&gt; IntegerLiteralType)`, then this is simply an overload resolution rule. In<br>&gt; that case, I think your proposal is fine.<br>&gt;<br>&gt; But if you&#39;re going to call `init(integerLiteral:)` like it&#39;s `init(_:)`,<br>&gt; I don&#39;t think that&#39;s a good idea. Parameter labels are supposed to be<br>&gt; significant; we don&#39;t want to lose that.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/d6345324/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>June  2, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jun 2, 2016, at 4:33 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; The IntegerLiteral type idea might be worth exploring. It does seem to provide some additional consistency. For example, wasn&#39;t it clarified on this list just recently that literals don&#39;t have a type and adopt one based on context? It&#39;d be nice to point out that 42 is an IntegerLiteral when explaining that it&#39;s not an Int.<br></p><p>I think that&#39;s a very promising way of thinking about literals.  Writing a literal creates a notional value whose type is the informal, infinite-precise type of all integer/FP/collection/etc. literals, which (1) can be implicitly converted to any type that implements the appropriate protocol and (2) in fact *must* be converted to some such type (possibly the default type for that literal) in order for the code to be executable.  You can then think about this proposal as saying that an explicit conversion from that informal type to a literal-convertible type follows the same path as an implicit conversion would have.<br></p><p>John.<br></p><p>&gt; <br>&gt; On Thu, Jun 2, 2016 at 18:22 Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt; So, you think that this syntax is enticing to new developers who naturally think that the feature works the way that I&#39;m proposing it should work, and you think that the right solution is to make the syntax illegal so that you can more conveniently tell them it doesn&#39;t work that way? :)<br>&gt; <br>&gt; I think the difference between a cast (which merely reinterprets a value as a compatible type) and a fullwidth conversion (which creates a similar instance of an incompatible type) is very important to understanding how to write Swift, and we shouldn&#39;t muddy the waters by creating a magic syntax.<br>&gt; <br>&gt; &gt; You can still tell them that it&#39;s a struct and you&#39;re calling an initializer on it; it&#39;s just that the initializer chosen is the special literal initializer because the argument is a literal.<br>&gt; <br>&gt; If you&#39;re planning to change `IntegerLiteralConvertible` and friends to require a fullwidth conversion initializer like `init(_ value: IntegerLiteralType)`, then this is simply an overload resolution rule. In that case, I think your proposal is fine.<br>&gt; <br>&gt; But if you&#39;re going to call `init(integerLiteral:)` like it&#39;s `init(_:)`, I don&#39;t think that&#39;s a good idea. Parameter labels are supposed to be significant; we don&#39;t want to lose that.<br>&gt; <br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/73a9ba88/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June  2, 2016 at 08:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt;&gt; On Jun 2, 2016, at 6:51 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Jun 2, 2016, at 4:33 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt; The IntegerLiteral type idea might be worth exploring. It does seem to provide some additional consistency. For example, wasn&#39;t it clarified on this list just recently that literals don&#39;t have a type and adopt one based on context? It&#39;d be nice to point out that 42 is an IntegerLiteral when explaining that it&#39;s not an Int.<br>&gt; <br>&gt; I think that&#39;s a very promising way of thinking about literals.  Writing a literal creates a notional value whose type is the informal, infinite-precise type of all integer/FP/collection/etc. literals, which (1) can be implicitly converted to any type that implements the appropriate protocol and (2) in fact *must* be converted to some such type (possibly the default type for that literal) in order for the code to be executable.  You can then think about this proposal as saying that an explicit conversion from that informal type to a literal-convertible type follows the same path as an implicit conversion would have.<br></p><p>It sounds like the reason you don&#39;t want to remove the label is because it distinguishes the literal initializer and you don&#39;t want it called with a variable accidentally right?  <br></p><p>What if we do something like this:<br></p><p>init(_ value: IntegerLiteralType, literal: IntegerLiteral = #literal)<br></p><p>The idea here is that the IntegerLiteral type and friends are special types that have no members and cannot be used except by the literal convertible protocols and their conformances.  There is nothing you can do with the value at all.  <br></p><p>The trick is that by defaulting it to #literal we are indicating the compiler synthesizes the logical value, as with #file, #line, etc.  The compiler would refuse to synthesize this value when a literal is not used.  This means it is never selected when the user provides a variable to a converting initializer.  If an independent initializer accepting a value of the same type also exists that would be selected.  However, when a literal *is* used and the type conforms to the relevant literal convertible protocol the compiler always synthesized the value making it always the most specific overload.<br></p><p>Of course no runtime value would actually exist.  This is just a logical value marking the fact that a literal was used to call the initializer.  <br></p><p>This approach solves the same problem while retaining semantic consistency with the language (no label elision or short circuit of overload resolution).  The magic is arguably a lot more restrained - types for which values can only be supplied by the compiler.  We could artificially restrict usage of these types if we wanted to, but we wouldn&#39;t have to.  Nothing could be accomplished by using the types anywhere else so nobody do so and it wouldn&#39;t be actively harmful to allow them to be used anywhere other types can be used.  Only the ability to create values of the type needs to be restricted and we can already write types like that by marking the initializers private.<br></p><p>Any thoughts on this approach?<br></p><p>&gt; <br>&gt; John.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Thu, Jun 2, 2016 at 18:22 Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt; So, you think that this syntax is enticing to new developers who naturally think that the feature works the way that I&#39;m proposing it should work, and you think that the right solution is to make the syntax illegal so that you can more conveniently tell them it doesn&#39;t work that way? :)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think the difference between a cast (which merely reinterprets a value as a compatible type) and a fullwidth conversion (which creates a similar instance of an incompatible type) is very important to understanding how to write Swift, and we shouldn&#39;t muddy the waters by creating a magic syntax.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; You can still tell them that it&#39;s a struct and you&#39;re calling an initializer on it; it&#39;s just that the initializer chosen is the special literal initializer because the argument is a literal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you&#39;re planning to change `IntegerLiteralConvertible` and friends to require a fullwidth conversion initializer like `init(_ value: IntegerLiteralType)`, then this is simply an overload resolution rule. In that case, I think your proposal is fine.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But if you&#39;re going to call `init(integerLiteral:)` like it&#39;s `init(_:)`, I don&#39;t think that&#39;s a good idea. Parameter labels are supposed to be significant; we don&#39;t want to lose that.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/ab5e5c0f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>June  3, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jun 2, 2016, at 6:48 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; On Jun 2, 2016, at 6:51 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Jun 2, 2016, at 4:33 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; The IntegerLiteral type idea might be worth exploring. It does seem to provide some additional consistency. For example, wasn&#39;t it clarified on this list just recently that literals don&#39;t have a type and adopt one based on context? It&#39;d be nice to point out that 42 is an IntegerLiteral when explaining that it&#39;s not an Int.<br>&gt;&gt; <br>&gt;&gt; I think that&#39;s a very promising way of thinking about literals.  Writing a literal creates a notional value whose type is the informal, infinite-precise type of all integer/FP/collection/etc. literals, which (1) can be implicitly converted to any type that implements the appropriate protocol and (2) in fact *must* be converted to some such type (possibly the default type for that literal) in order for the code to be executable.  You can then think about this proposal as saying that an explicit conversion from that informal type to a literal-convertible type follows the same path as an implicit conversion would have.<br>&gt; <br>&gt; It sounds like the reason you don&#39;t want to remove the label is because it distinguishes the literal initializer and you don&#39;t want it called with a variable accidentally right?  <br>&gt; <br>&gt; What if we do something like this:<br>&gt; <br>&gt; init(_ value: IntegerLiteralType, literal: IntegerLiteral = #literal)<br>&gt; <br>&gt; The idea here is that the IntegerLiteral type and friends are special types that have no members and cannot be used except by the literal convertible protocols and their conformances.  There is nothing you can do with the value at all.  <br>&gt; <br>&gt; The trick is that by defaulting it to #literal we are indicating the compiler synthesizes the logical value, as with #file, #line, etc.  The compiler would refuse to synthesize this value when a literal is not used.  This means it is never selected when the user provides a variable to a converting initializer.  If an independent initializer accepting a value of the same type also exists that would be selected.  However, when a literal *is* used and the type conforms to the relevant literal convertible protocol the compiler always synthesized the value making it always the most specific overload.<br>&gt; <br>&gt; Of course no runtime value would actually exist.  This is just a logical value marking the fact that a literal was used to call the initializer.  <br>&gt; <br>&gt; This approach solves the same problem while retaining semantic consistency with the language (no label elision or short circuit of overload resolution).  The magic is arguably a lot more restrained - types for which values can only be supplied by the compiler.  We could artificially restrict usage of these types if we wanted to, but we wouldn&#39;t have to.  Nothing could be accomplished by using the types anywhere else so nobody do so and it wouldn&#39;t be actively harmful to allow them to be used anywhere other types can be used.  Only the ability to create values of the type needs to be restricted and we can already write types like that by marking the initializers private.<br>&gt; <br>&gt; Any thoughts on this approach?<br></p><p>This is still a special-case type-checking rule, which means that it&#39;s still basically my proposal except, instead of just rewriting the call to use a labeled literal initializer, it rewrites the call to use a magic initializer which cannot be used by users because it requires arguments that users cannot create.  I just don&#39;t understand the motivation here.  It&#39;s not a simpler language model to use, explain, or implement; it purports to be conceptually simpler and less magical while actually inventing two magic new language concepts (IntegerLiteral and #literal) on top of the same special cases.<br></p><p>Literals are always going to involve some magic behind the scenes.  The non-trivial literals, for example, all actually traffic through some sort of builtin protocol (e.g. BuiltinIntegerLiteralConvertible) which cannot be implemented by users and whose construction necessarily involves a private API contract between the standard library and compiler that we reserve the right to change at will without bringing in swift-evolution.  All of the supposedly simple explanations eventually reach, &quot;okay, but if Int isn&#39;t a special type, how does the literal turn into an Int in the first place&quot;, and that is just unanswerable, because it turns out that standard library types *are* actually special in the sense that they get to conform to BuiltinIntegerLiteralConvertible and nobody else does.<br></p><p>John.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; John.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Thu, Jun 2, 2016 at 18:22 Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt; So, you think that this syntax is enticing to new developers who naturally think that the feature works the way that I&#39;m proposing it should work, and you think that the right solution is to make the syntax illegal so that you can more conveniently tell them it doesn&#39;t work that way? :)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think the difference between a cast (which merely reinterprets a value as a compatible type) and a fullwidth conversion (which creates a similar instance of an incompatible type) is very important to understanding how to write Swift, and we shouldn&#39;t muddy the waters by creating a magic syntax.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; You can still tell them that it&#39;s a struct and you&#39;re calling an initializer on it; it&#39;s just that the initializer chosen is the special literal initializer because the argument is a literal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you&#39;re planning to change `IntegerLiteralConvertible` and friends to require a fullwidth conversion initializer like `init(_ value: IntegerLiteralType)`, then this is simply an overload resolution rule. In that case, I think your proposal is fine.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But if you&#39;re going to call `init(integerLiteral:)` like it&#39;s `init(_:)`, I don&#39;t think that&#39;s a good idea. Parameter labels are supposed to be significant; we don&#39;t want to lose that.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160603/f45aff5c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June  3, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jun 3, 2016, at 1:36 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Jun 2, 2016, at 6:48 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; On Jun 2, 2016, at 6:51 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 2, 2016, at 4:33 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; The IntegerLiteral type idea might be worth exploring. It does seem to provide some additional consistency. For example, wasn&#39;t it clarified on this list just recently that literals don&#39;t have a type and adopt one based on context? It&#39;d be nice to point out that 42 is an IntegerLiteral when explaining that it&#39;s not an Int.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think that&#39;s a very promising way of thinking about literals.  Writing a literal creates a notional value whose type is the informal, infinite-precise type of all integer/FP/collection/etc. literals, which (1) can be implicitly converted to any type that implements the appropriate protocol and (2) in fact *must* be converted to some such type (possibly the default type for that literal) in order for the code to be executable.  You can then think about this proposal as saying that an explicit conversion from that informal type to a literal-convertible type follows the same path as an implicit conversion would have.<br>&gt;&gt; <br>&gt;&gt; It sounds like the reason you don&#39;t want to remove the label is because it distinguishes the literal initializer and you don&#39;t want it called with a variable accidentally right?  <br>&gt;&gt; <br>&gt;&gt; What if we do something like this:<br>&gt;&gt; <br>&gt;&gt; init(_ value: IntegerLiteralType, literal: IntegerLiteral = #literal)<br>&gt;&gt; <br>&gt;&gt; The idea here is that the IntegerLiteral type and friends are special types that have no members and cannot be used except by the literal convertible protocols and their conformances.  There is nothing you can do with the value at all.  <br>&gt;&gt; <br>&gt;&gt; The trick is that by defaulting it to #literal we are indicating the compiler synthesizes the logical value, as with #file, #line, etc.  The compiler would refuse to synthesize this value when a literal is not used.  This means it is never selected when the user provides a variable to a converting initializer.  If an independent initializer accepting a value of the same type also exists that would be selected.  However, when a literal *is* used and the type conforms to the relevant literal convertible protocol the compiler always synthesized the value making it always the most specific overload.<br>&gt;&gt; <br>&gt;&gt; Of course no runtime value would actually exist.  This is just a logical value marking the fact that a literal was used to call the initializer.  <br>&gt;&gt; <br>&gt;&gt; This approach solves the same problem while retaining semantic consistency with the language (no label elision or short circuit of overload resolution).  The magic is arguably a lot more restrained - types for which values can only be supplied by the compiler.  We could artificially restrict usage of these types if we wanted to, but we wouldn&#39;t have to.  Nothing could be accomplished by using the types anywhere else so nobody do so and it wouldn&#39;t be actively harmful to allow them to be used anywhere other types can be used.  Only the ability to create values of the type needs to be restricted and we can already write types like that by marking the initializers private.<br>&gt;&gt; <br>&gt;&gt; Any thoughts on this approach?<br>&gt; <br>&gt; This is still a special-case type-checking rule, which means that it&#39;s still basically my proposal except, instead of just rewriting the call to use a labeled literal initializer, it rewrites the call to use a magic initializer which cannot be used by users because it requires arguments that users cannot create.  I just don&#39;t understand the motivation here.  It&#39;s not a simpler language model to use, explain, or implement; it purports to be conceptually simpler and less magical while actually inventing two magic new language concepts (IntegerLiteral and #literal) on top of the same special cases.<br></p><p>I understand that this is still a special case and also that the implementation is pretty much identical.  But I think the way it is presented to users is important. <br></p><p> The motivation is to come up with a design that lets us implement your proposal without magically eliding a parameter label.  There is no other case in Swift where you can directly call any function (initializer or otherwise) without including labels for all parameters that have external labels.  Creating a special case to allow that here is inconsistent.  Why wouldn’t look for a way to do this that treats the signature consistently with the rest of the language and is more in line with how we handle other compiler magic (i.e. #file, #line, etc)?<br></p><p>I am not the only one who feels that way.  Quoting Brent:<br></p><p>&quot;But if you&#39;re going to call `init(integerLiteral:)` like it&#39;s `init(_:)`, I don&#39;t think that&#39;s a good idea. Parameter labels are supposed to be significant; we don&#39;t want to lose that.”<br></p><p>I agree with this.  That is the motivation for my suggestion.  I think it’s at least worth discussing as an alternative to magically allowing an external parameter label to be omitted.  Brent, what do you think of my suggestion?<br></p><p>&gt; <br>&gt; Literals are always going to involve some magic behind the scenes.  The non-trivial literals, for example, all actually traffic through some sort of builtin protocol (e.g. BuiltinIntegerLiteralConvertible) which cannot be implemented by users and whose construction necessarily involves a private API contract between the standard library and compiler that we reserve the right to change at will without bringing in swift-evolution.  All of the supposedly simple explanations eventually reach, &quot;okay, but if Int isn&#39;t a special type, how does the literal turn into an Int in the first place&quot;, and that is just unanswerable, because it turns out that standard library types *are* actually special in the sense that they get to conform to BuiltinIntegerLiteralConvertible and nobody else does.<br></p><p>Understood.  But Swift does a good job of making the magic feel consistent with the rest of the language.  That’s a good thing.  Allowing omission of a parameter label is a break from that IMO.<br></p><p>I believe this is an important problem to solve but I also think we should try to find a way to solve it that doesn’t violate rules that apply everywhere else in the language (specifically regarding parameter labels).<br></p><p>-Matthew<br></p><p>&gt; <br>&gt; John.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; John.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Thu, Jun 2, 2016 at 18:22 Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt; So, you think that this syntax is enticing to new developers who naturally think that the feature works the way that I&#39;m proposing it should work, and you think that the right solution is to make the syntax illegal so that you can more conveniently tell them it doesn&#39;t work that way? :)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think the difference between a cast (which merely reinterprets a value as a compatible type) and a fullwidth conversion (which creates a similar instance of an incompatible type) is very important to understanding how to write Swift, and we shouldn&#39;t muddy the waters by creating a magic syntax.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt; You can still tell them that it&#39;s a struct and you&#39;re calling an initializer on it; it&#39;s just that the initializer chosen is the special literal initializer because the argument is a literal.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If you&#39;re planning to change `IntegerLiteralConvertible` and friends to require a fullwidth conversion initializer like `init(_ value: IntegerLiteralType)`, then this is simply an overload resolution rule. In that case, I think your proposal is fine.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; But if you&#39;re going to call `init(integerLiteral:)` like it&#39;s `init(_:)`, I don&#39;t think that&#39;s a good idea. Parameter labels are supposed to be significant; we don&#39;t want to lose that.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160603/acd4e49a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June  3, 2016 at 03:00:00pm</p></header><div class="content"><p>On Fri, Jun 3, 2016 at 2:41 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt; On Jun 3, 2016, at 1:36 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;<br>&gt; On Jun 2, 2016, at 6:48 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; wrote:<br>&gt; On Jun 2, 2016, at 6:51 PM, John McCall via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Jun 2, 2016, at 4:33 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; The IntegerLiteral type idea might be worth exploring. It does seem to<br>&gt; provide some additional consistency. For example, wasn&#39;t it clarified on<br>&gt; this list just recently that literals don&#39;t have a type and adopt one based<br>&gt; on context? It&#39;d be nice to point out that 42 is an IntegerLiteral when<br>&gt; explaining that it&#39;s not an Int.<br>&gt;<br>&gt;<br>&gt; I think that&#39;s a very promising way of thinking about literals.  Writing a<br>&gt; literal creates a notional value whose type is the informal,<br>&gt; infinite-precise type of all integer/FP/collection/etc. literals, which (1)<br>&gt; can be implicitly converted to any type that implements the appropriate<br>&gt; protocol and (2) in fact *must* be converted to some such type (possibly<br>&gt; the default type for that literal) in order for the code to be executable.<br>&gt; You can then think about this proposal as saying that an explicit<br>&gt; conversion from that informal type to a literal-convertible type follows<br>&gt; the same path as an implicit conversion would have.<br>&gt;<br>&gt;<br>&gt; It sounds like the reason you don&#39;t want to remove the label is because it<br>&gt; distinguishes the literal initializer and you don&#39;t want it called with a<br>&gt; variable accidentally right?<br>&gt;<br>&gt; What if we do something like this:<br>&gt;<br>&gt; init(_ value: IntegerLiteralType, literal: IntegerLiteral = #literal)<br>&gt;<br>&gt; The idea here is that the IntegerLiteral type and friends are special<br>&gt; types that have no members and cannot be used except by the literal<br>&gt; convertible protocols and their conformances.  There is nothing you can do<br>&gt; with the value at all.<br>&gt;<br>&gt; The trick is that by defaulting it to #literal we are indicating the<br>&gt; compiler synthesizes the logical value, as with #file, #line, etc.  The<br>&gt; compiler would refuse to synthesize this value when a literal is not used.<br>&gt; This means it is never selected when the user provides a variable to a<br>&gt; converting initializer.  If an independent initializer accepting a value of<br>&gt; the same type also exists that would be selected.  However, when a literal<br>&gt; *is* used and the type conforms to the relevant literal convertible<br>&gt; protocol the compiler always synthesized the value making it always the<br>&gt; most specific overload.<br>&gt;<br>&gt; Of course no runtime value would actually exist.  This is just a logical<br>&gt; value marking the fact that a literal was used to call the initializer.<br>&gt;<br>&gt; This approach solves the same problem while retaining semantic consistency<br>&gt; with the language (no label elision or short circuit of overload<br>&gt; resolution).  The magic is arguably a lot more restrained - types for which<br>&gt; values can only be supplied by the compiler.  We could artificially<br>&gt; restrict usage of these types if we wanted to, but we wouldn&#39;t have to.<br>&gt; Nothing could be accomplished by using the types anywhere else so nobody do<br>&gt; so and it wouldn&#39;t be actively harmful to allow them to be used anywhere<br>&gt; other types can be used.  Only the ability to create values of the type<br>&gt; needs to be restricted and we can already write types like that by marking<br>&gt; the initializers private.<br>&gt;<br>&gt; Any thoughts on this approach?<br>&gt;<br>&gt;<br>&gt; This is still a special-case type-checking rule, which means that it&#39;s<br>&gt; still basically my proposal except, instead of just rewriting the call to<br>&gt; use a labeled literal initializer, it rewrites the call to use a magic<br>&gt; initializer which cannot be used by users because it requires arguments<br>&gt; that users cannot create.  I just don&#39;t understand the motivation here.<br>&gt; It&#39;s not a simpler language model to use, explain, or implement; it<br>&gt; purports to be conceptually simpler and less magical while actually<br>&gt; inventing two magic new language concepts (IntegerLiteral and #literal) on<br>&gt; top of the same special cases.<br>&gt;<br>&gt;<br>&gt; I understand that this is still a special case and also that the<br>&gt; implementation is pretty much identical.  But I think the way it is<br>&gt; presented to users is important.<br>&gt;<br>&gt;  The motivation is to come up with a design that lets us implement your<br>&gt; proposal without magically eliding a parameter label.  There is no other<br>&gt; case in Swift where you can directly call any function (initializer or<br>&gt; otherwise) without including labels for all parameters that have external<br>&gt; labels.  Creating a special case to allow that here is inconsistent.  Why<br>&gt; wouldn’t look for a way to do this that treats the signature consistently<br>&gt; with the rest of the language and is more in line with how we handle other<br>&gt; compiler magic (i.e. #file, #line, etc)?<br>&gt;<br>&gt; I am not the only one who feels that way.  Quoting Brent:<br>&gt;<br>&gt; &quot;But if you&#39;re going to call `init(integerLiteral:)` like it&#39;s `init(_:)`,<br>&gt; I don&#39;t think that&#39;s a good idea. Parameter labels are supposed to be<br>&gt; significant; we don&#39;t want to lose that.”<br>&gt;<br>&gt; I agree with this.  That is the motivation for my suggestion.  I think<br>&gt; it’s at least worth discussing as an alternative to magically allowing an<br>&gt; external parameter label to be omitted.  Brent, what do you think of my<br>&gt; suggestion?<br>&gt;<br>&gt;<br>&gt; Literals are always going to involve some magic behind the scenes.  The<br>&gt; non-trivial literals, for example, all actually traffic through some sort<br>&gt; of builtin protocol (e.g. BuiltinIntegerLiteralConvertible) which cannot be<br>&gt; implemented by users and whose construction necessarily involves a private<br>&gt; API contract between the standard library and compiler that we reserve the<br>&gt; right to change at will without bringing in swift-evolution.  All of the<br>&gt; supposedly simple explanations eventually reach, &quot;okay, but if Int isn&#39;t a<br>&gt; special type, how does the literal turn into an Int in the first place&quot;,<br>&gt; and that is just unanswerable, because it turns out that standard library<br>&gt; types *are* actually special in the sense that they get to conform to<br>&gt; BuiltinIntegerLiteralConvertible and nobody else does.<br>&gt;<br>&gt;<br>&gt; Understood.  But Swift does a good job of making the magic feel consistent<br>&gt; with the rest of the language.  That’s a good thing.  Allowing omission of<br>&gt; a parameter label is a break from that IMO.<br>&gt;<br>&gt; I believe this is an important problem to solve but I also think we should<br>&gt; try to find a way to solve it that doesn’t violate rules that apply<br>&gt; everywhere else in the language (specifically regarding parameter labels).<br>&gt;<br>&gt;<br>Would it help if we had an attribute or contextual keyword to describe this<br>magic? By this I mean, what if we had `init(_: @literal Int)` or something<br>similar? The magic would be isolated to the fact that you&#39;d have to supply<br>an integer literal to such an argument, which through behind-the-scenes<br>stuff becomes an Int.<br></p><p><br>&gt; -Matthew<br>&gt;<br>&gt;<br>&gt; John.<br>&gt;<br>&gt;<br>&gt;<br>&gt; John.<br>&gt;<br>&gt;<br>&gt; On Thu, Jun 2, 2016 at 18:22 Brent Royal-Gordon via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; &gt; So, you think that this syntax is enticing to new developers who<br>&gt;&gt; naturally think that the feature works the way that I&#39;m proposing it should<br>&gt;&gt; work, and you think that the right solution is to make the syntax illegal<br>&gt;&gt; so that you can more conveniently tell them it doesn&#39;t work that way? :)<br>&gt;&gt;<br>&gt;&gt; I think the difference between a cast (which merely reinterprets a value<br>&gt;&gt; as a compatible type) and a fullwidth conversion (which creates a similar<br>&gt;&gt; instance of an incompatible type) is very important to understanding how to<br>&gt;&gt; write Swift, and we shouldn&#39;t muddy the waters by creating a magic syntax.<br>&gt;&gt;<br>&gt;&gt; &gt; You can still tell them that it&#39;s a struct and you&#39;re calling an<br>&gt;&gt; initializer on it; it&#39;s just that the initializer chosen is the special<br>&gt;&gt; literal initializer because the argument is a literal.<br>&gt;&gt;<br>&gt;&gt; If you&#39;re planning to change `IntegerLiteralConvertible` and friends to<br>&gt;&gt; require a fullwidth conversion initializer like `init(_ value:<br>&gt;&gt; IntegerLiteralType)`, then this is simply an overload resolution rule. In<br>&gt;&gt; that case, I think your proposal is fine.<br>&gt;&gt;<br>&gt;&gt; But if you&#39;re going to call `init(integerLiteral:)` like it&#39;s `init(_:)`,<br>&gt;&gt; I don&#39;t think that&#39;s a good idea. Parameter labels are supposed to be<br>&gt;&gt; significant; we don&#39;t want to lose that.<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160603/4422cdc9/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>June  3, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jun 3, 2016, at 12:41 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; On Jun 3, 2016, at 1:36 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 2, 2016, at 6:48 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt; On Jun 2, 2016, at 6:51 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 2, 2016, at 4:33 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; The IntegerLiteral type idea might be worth exploring. It does seem to provide some additional consistency. For example, wasn&#39;t it clarified on this list just recently that literals don&#39;t have a type and adopt one based on context? It&#39;d be nice to point out that 42 is an IntegerLiteral when explaining that it&#39;s not an Int.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think that&#39;s a very promising way of thinking about literals.  Writing a literal creates a notional value whose type is the informal, infinite-precise type of all integer/FP/collection/etc. literals, which (1) can be implicitly converted to any type that implements the appropriate protocol and (2) in fact *must* be converted to some such type (possibly the default type for that literal) in order for the code to be executable.  You can then think about this proposal as saying that an explicit conversion from that informal type to a literal-convertible type follows the same path as an implicit conversion would have.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It sounds like the reason you don&#39;t want to remove the label is because it distinguishes the literal initializer and you don&#39;t want it called with a variable accidentally right?  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What if we do something like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; init(_ value: IntegerLiteralType, literal: IntegerLiteral = #literal)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The idea here is that the IntegerLiteral type and friends are special types that have no members and cannot be used except by the literal convertible protocols and their conformances.  There is nothing you can do with the value at all.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The trick is that by defaulting it to #literal we are indicating the compiler synthesizes the logical value, as with #file, #line, etc.  The compiler would refuse to synthesize this value when a literal is not used.  This means it is never selected when the user provides a variable to a converting initializer.  If an independent initializer accepting a value of the same type also exists that would be selected.  However, when a literal *is* used and the type conforms to the relevant literal convertible protocol the compiler always synthesized the value making it always the most specific overload.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Of course no runtime value would actually exist.  This is just a logical value marking the fact that a literal was used to call the initializer.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This approach solves the same problem while retaining semantic consistency with the language (no label elision or short circuit of overload resolution).  The magic is arguably a lot more restrained - types for which values can only be supplied by the compiler.  We could artificially restrict usage of these types if we wanted to, but we wouldn&#39;t have to.  Nothing could be accomplished by using the types anywhere else so nobody do so and it wouldn&#39;t be actively harmful to allow them to be used anywhere other types can be used.  Only the ability to create values of the type needs to be restricted and we can already write types like that by marking the initializers private.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Any thoughts on this approach?<br>&gt;&gt; <br>&gt;&gt; This is still a special-case type-checking rule, which means that it&#39;s still basically my proposal except, instead of just rewriting the call to use a labeled literal initializer, it rewrites the call to use a magic initializer which cannot be used by users because it requires arguments that users cannot create.  I just don&#39;t understand the motivation here.  It&#39;s not a simpler language model to use, explain, or implement; it purports to be conceptually simpler and less magical while actually inventing two magic new language concepts (IntegerLiteral and #literal) on top of the same special cases.<br>&gt; <br>&gt; I understand that this is still a special case and also that the implementation is pretty much identical.  But I think the way it is presented to users is important. <br>&gt; <br>&gt;  The motivation is to come up with a design that lets us implement your proposal without magically eliding a parameter label.  There is no other case in Swift where you can directly call any function (initializer or otherwise) without including labels for all parameters that have external labels.<br></p><p>Don&#39;t think of it as omitting a parameter label.  Constructing a value from a literal is a complex and well-defined process that happens to end by calling an initializer with a labeled argument.  The proposal says that we follow that entire process as normal, not just that we silently rewrite the call to add a label, which is not how it works.<br></p><p>&gt;  Creating a special case to allow that here is inconsistent.  Why wouldn’t look for a way to do this that treats the signature consistently with the rest of the language and is more in line with how we handle other compiler magic (i.e. #file, #line, etc)?<br></p><p>It&#39;s not more consistent with the rest of the language.  You&#39;re talking about introducing a default argument that only defaults when the compiler recognizes a special syntactic form in the call site.  I don&#39;t understand why inventing novel and massively invasive language mechanisms like that is somehow clearer or more consistent than explaining that a particular syntactic form is recognized as performing the well-defined literal-construction process.<br></p><p>There is simply no way that this is going to feel 100% consistent with the ordinary language while still prohibiting the literal initializer from being called as an unlabelled initializer in the ordinary language, which is explicitly something we do not want to allow.  It will be a special case.  It will not be consistent.  Special cases are not consistent.  You cannot thread this needle.<br></p><p>John.<br></p><p>&gt; I am not the only one who feels that way.  Quoting Brent:<br>&gt; <br>&gt; &quot;But if you&#39;re going to call `init(integerLiteral:)` like it&#39;s `init(_:)`, I don&#39;t think that&#39;s a good idea. Parameter labels are supposed to be significant; we don&#39;t want to lose that.”<br>&gt; <br>&gt; I agree with this.  That is the motivation for my suggestion.  I think it’s at least worth discussing as an alternative to magically allowing an external parameter label to be omitted.  Brent, what do you think of my suggestion?<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Literals are always going to involve some magic behind the scenes.  The non-trivial literals, for example, all actually traffic through some sort of builtin protocol (e.g. BuiltinIntegerLiteralConvertible) which cannot be implemented by users and whose construction necessarily involves a private API contract between the standard library and compiler that we reserve the right to change at will without bringing in swift-evolution.  All of the supposedly simple explanations eventually reach, &quot;okay, but if Int isn&#39;t a special type, how does the literal turn into an Int in the first place&quot;, and that is just unanswerable, because it turns out that standard library types *are* actually special in the sense that they get to conform to BuiltinIntegerLiteralConvertible and nobody else does.<br>&gt; <br>&gt; Understood.  But Swift does a good job of making the magic feel consistent with the rest of the language.  That’s a good thing.  Allowing omission of a parameter label is a break from that IMO.<br>&gt; <br>&gt; I believe this is an important problem to solve but I also think we should try to find a way to solve it that doesn’t violate rules that apply everywhere else in the language (specifically regarding parameter labels).<br>&gt; <br>&gt; -Matthew<br>&gt; <br>&gt;&gt; <br>&gt;&gt; John.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Thu, Jun 2, 2016 at 18:22 Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt; So, you think that this syntax is enticing to new developers who naturally think that the feature works the way that I&#39;m proposing it should work, and you think that the right solution is to make the syntax illegal so that you can more conveniently tell them it doesn&#39;t work that way? :)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think the difference between a cast (which merely reinterprets a value as a compatible type) and a fullwidth conversion (which creates a similar instance of an incompatible type) is very important to understanding how to write Swift, and we shouldn&#39;t muddy the waters by creating a magic syntax.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt; You can still tell them that it&#39;s a struct and you&#39;re calling an initializer on it; it&#39;s just that the initializer chosen is the special literal initializer because the argument is a literal.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If you&#39;re planning to change `IntegerLiteralConvertible` and friends to require a fullwidth conversion initializer like `init(_ value: IntegerLiteralType)`, then this is simply an overload resolution rule. In that case, I think your proposal is fine.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; But if you&#39;re going to call `init(integerLiteral:)` like it&#39;s `init(_:)`, I don&#39;t think that&#39;s a good idea. Parameter labels are supposed to be significant; we don&#39;t want to lose that.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160603/892b50b4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June  3, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jun 3, 2016, at 3:17 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Jun 3, 2016, at 12:41 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt; On Jun 3, 2016, at 1:36 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 2, 2016, at 6:48 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; On Jun 2, 2016, at 6:51 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 2, 2016, at 4:33 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; The IntegerLiteral type idea might be worth exploring. It does seem to provide some additional consistency. For example, wasn&#39;t it clarified on this list just recently that literals don&#39;t have a type and adopt one based on context? It&#39;d be nice to point out that 42 is an IntegerLiteral when explaining that it&#39;s not an Int.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think that&#39;s a very promising way of thinking about literals.  Writing a literal creates a notional value whose type is the informal, infinite-precise type of all integer/FP/collection/etc. literals, which (1) can be implicitly converted to any type that implements the appropriate protocol and (2) in fact *must* be converted to some such type (possibly the default type for that literal) in order for the code to be executable.  You can then think about this proposal as saying that an explicit conversion from that informal type to a literal-convertible type follows the same path as an implicit conversion would have.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It sounds like the reason you don&#39;t want to remove the label is because it distinguishes the literal initializer and you don&#39;t want it called with a variable accidentally right?  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What if we do something like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; init(_ value: IntegerLiteralType, literal: IntegerLiteral = #literal)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The idea here is that the IntegerLiteral type and friends are special types that have no members and cannot be used except by the literal convertible protocols and their conformances.  There is nothing you can do with the value at all.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The trick is that by defaulting it to #literal we are indicating the compiler synthesizes the logical value, as with #file, #line, etc.  The compiler would refuse to synthesize this value when a literal is not used.  This means it is never selected when the user provides a variable to a converting initializer.  If an independent initializer accepting a value of the same type also exists that would be selected.  However, when a literal *is* used and the type conforms to the relevant literal convertible protocol the compiler always synthesized the value making it always the most specific overload.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Of course no runtime value would actually exist.  This is just a logical value marking the fact that a literal was used to call the initializer.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This approach solves the same problem while retaining semantic consistency with the language (no label elision or short circuit of overload resolution).  The magic is arguably a lot more restrained - types for which values can only be supplied by the compiler.  We could artificially restrict usage of these types if we wanted to, but we wouldn&#39;t have to.  Nothing could be accomplished by using the types anywhere else so nobody do so and it wouldn&#39;t be actively harmful to allow them to be used anywhere other types can be used.  Only the ability to create values of the type needs to be restricted and we can already write types like that by marking the initializers private.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Any thoughts on this approach?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is still a special-case type-checking rule, which means that it&#39;s still basically my proposal except, instead of just rewriting the call to use a labeled literal initializer, it rewrites the call to use a magic initializer which cannot be used by users because it requires arguments that users cannot create.  I just don&#39;t understand the motivation here.  It&#39;s not a simpler language model to use, explain, or implement; it purports to be conceptually simpler and less magical while actually inventing two magic new language concepts (IntegerLiteral and #literal) on top of the same special cases.<br>&gt;&gt; <br>&gt;&gt; I understand that this is still a special case and also that the implementation is pretty much identical.  But I think the way it is presented to users is important. <br>&gt;&gt; <br>&gt;&gt;  The motivation is to come up with a design that lets us implement your proposal without magically eliding a parameter label.  There is no other case in Swift where you can directly call any function (initializer or otherwise) without including labels for all parameters that have external labels.<br>&gt; <br>&gt; Don&#39;t think of it as omitting a parameter label.  Constructing a value from a literal is a complex and well-defined process that happens to end by calling an initializer with a labeled argument.  The proposal says that we follow that entire process as normal, not just that we silently rewrite the call to add a label, which is not how it works.<br></p><p>This is an implementation detail.  It is important to the implementation but is inconsistent on the surface, which is what the programmer sees.  The fact is that the programmer-visible surface of the language currently treats it as a parameter label.  There are *no* exceptions to parameter labels and at least some of us would prefer to keep it that way if we can find an acceptable alternative.<br></p><p>&gt; <br>&gt;&gt;  Creating a special case to allow that here is inconsistent.  Why wouldn’t look for a way to do this that treats the signature consistently with the rest of the language and is more in line with how we handle other compiler magic (i.e. #file, #line, etc)?<br>&gt; <br>&gt; It&#39;s not more consistent with the rest of the language.  You&#39;re talking about introducing a default argument that only defaults when the compiler recognizes a special syntactic form in the call site.  I don&#39;t understand why inventing novel and massively invasive language mechanisms like that is somehow clearer or more consistent than explaining that a particular syntactic form is recognized as performing the well-defined literal-construction process.<br></p><p>I was never fully comfortable but wanted to prompt discussion about some alternative way to mark the initializer that doesn’t contradict the rules for parameter labels.  I can see how this compiler generated default would not behave like other compiler generated defaults now and agree it also has problems.  <br></p><p>Fortunately it looks like I succeeded in prompting some other alternatives which are better options IMO.<br></p><p>&gt; <br>&gt; There is simply no way that this is going to feel 100% consistent with the ordinary language while still prohibiting the literal initializer from being called as an unlabelled initializer in the ordinary language, which is explicitly something we do not want to allow.  It will be a special case.  It will not be consistent.  Special cases are not consistent.  You cannot thread this needle.<br></p><p>The way I see it, the question is how to find a way to handle the special case that feels the least inconsistent.  Using an external parameter label in a declaration and allowing it to be omitted at the call site does not feel like the right answer to me.  I think we can find a better way to present this syntactically.<br></p><p>&gt; <br>&gt; John.<br>&gt; <br>&gt;&gt; I am not the only one who feels that way.  Quoting Brent:<br>&gt;&gt; <br>&gt;&gt; &quot;But if you&#39;re going to call `init(integerLiteral:)` like it&#39;s `init(_:)`, I don&#39;t think that&#39;s a good idea. Parameter labels are supposed to be significant; we don&#39;t want to lose that.”<br>&gt;&gt; <br>&gt;&gt; I agree with this.  That is the motivation for my suggestion.  I think it’s at least worth discussing as an alternative to magically allowing an external parameter label to be omitted.  Brent, what do you think of my suggestion?<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Literals are always going to involve some magic behind the scenes.  The non-trivial literals, for example, all actually traffic through some sort of builtin protocol (e.g. BuiltinIntegerLiteralConvertible) which cannot be implemented by users and whose construction necessarily involves a private API contract between the standard library and compiler that we reserve the right to change at will without bringing in swift-evolution.  All of the supposedly simple explanations eventually reach, &quot;okay, but if Int isn&#39;t a special type, how does the literal turn into an Int in the first place&quot;, and that is just unanswerable, because it turns out that standard library types *are* actually special in the sense that they get to conform to BuiltinIntegerLiteralConvertible and nobody else does.<br>&gt;&gt; <br>&gt;&gt; Understood.  But Swift does a good job of making the magic feel consistent with the rest of the language.  That’s a good thing.  Allowing omission of a parameter label is a break from that IMO.<br>&gt;&gt; <br>&gt;&gt; I believe this is an important problem to solve but I also think we should try to find a way to solve it that doesn’t violate rules that apply everywhere else in the language (specifically regarding parameter labels).<br>&gt;&gt; <br>&gt;&gt; -Matthew<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; John.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Thu, Jun 2, 2016 at 18:22 Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; So, you think that this syntax is enticing to new developers who naturally think that the feature works the way that I&#39;m proposing it should work, and you think that the right solution is to make the syntax illegal so that you can more conveniently tell them it doesn&#39;t work that way? :)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I think the difference between a cast (which merely reinterprets a value as a compatible type) and a fullwidth conversion (which creates a similar instance of an incompatible type) is very important to understanding how to write Swift, and we shouldn&#39;t muddy the waters by creating a magic syntax.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; You can still tell them that it&#39;s a struct and you&#39;re calling an initializer on it; it&#39;s just that the initializer chosen is the special literal initializer because the argument is a literal.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If you&#39;re planning to change `IntegerLiteralConvertible` and friends to require a fullwidth conversion initializer like `init(_ value: IntegerLiteralType)`, then this is simply an overload resolution rule. In that case, I think your proposal is fine.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; But if you&#39;re going to call `init(integerLiteral:)` like it&#39;s `init(_:)`, I don&#39;t think that&#39;s a good idea. Parameter labels are supposed to be significant; we don&#39;t want to lose that.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt;&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160603/8e487b91/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>June  3, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jun 3, 2016, at 16:17, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Using an external parameter label in a declaration and allowing it to be omitted at the call site does not feel like the right answer to me.  I think we can find a better way to present this syntactically.<br></p><p>+eleventy gajillion<br></p><p>- Dave Sweeris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>June  3, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jun 3, 2016, at 4:07 PM, David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt;&gt; On Jun 3, 2016, at 16:17, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Using an external parameter label in a declaration and allowing it to be omitted at the call site does not feel like the right answer to me.  I think we can find a better way to present this syntactically.<br>&gt; <br>&gt; +eleventy gajillion<br></p><p>I&#39;m actually quite happy with the user-facing aspects of the current literal protocols and see zero reason to update them for this, so if that&#39;s the choice, I&#39;ll just leave this aside.<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>June  3, 2016 at 04:00:00pm</p></header><div class="content"><p>I would be very interested in seeing your original proposal presented<br>for formal review.<br></p><p>Austin<br></p><p>On 6/3/16, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; On Jun 3, 2016, at 4:07 PM, David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt;&gt;&gt; On Jun 3, 2016, at 16:17, Matthew Johnson via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Using an external parameter label in a declaration and allowing it to be<br>&gt;&gt;&gt; omitted at the call site does not feel like the right answer to me.  I<br>&gt;&gt;&gt; think we can find a better way to present this syntactically.<br>&gt;&gt;<br>&gt;&gt; +eleventy gajillion<br>&gt;<br>&gt; I&#39;m actually quite happy with the user-facing aspects of the current literal<br>&gt; protocols and see zero reason to update them for this, so if that&#39;s the<br>&gt; choice, I&#39;ll just leave this aside.<br>&gt;<br>&gt; John.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June  3, 2016 at 07:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>On Jun 3, 2016, at 6:23 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br></p><p>&gt;&gt;&gt; On Jun 3, 2016, at 4:07 PM, David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt;&gt;&gt; On Jun 3, 2016, at 16:17, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Using an external parameter label in a declaration and allowing it to be omitted at the call site does not feel like the right answer to me.  I think we can find a better way to present this syntactically.<br>&gt;&gt; <br>&gt;&gt; +eleventy gajillion<br>&gt; <br>&gt; I&#39;m actually quite happy with the user-facing aspects of the current literal protocols and see zero reason to update them for this, so if that&#39;s the choice, I&#39;ll just leave this aside.<br></p><p>Are you suggesting that preserving the current syntax of the literal protocols is more important than fixing this behavior so it works like most people seem to expect?  Why not be open to other syntactic solutions? <br></p><p>&gt; <br>&gt; John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>June  3, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jun 3, 2016, at 5:13 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; On Jun 3, 2016, at 6:23 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt;&gt; On Jun 3, 2016, at 4:07 PM, David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt;&gt;&gt;&gt; On Jun 3, 2016, at 16:17, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Using an external parameter label in a declaration and allowing it to be omitted at the call site does not feel like the right answer to me.  I think we can find a better way to present this syntactically.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +eleventy gajillion<br>&gt;&gt; <br>&gt;&gt; I&#39;m actually quite happy with the user-facing aspects of the current literal protocols and see zero reason to update them for this, so if that&#39;s the choice, I&#39;ll just leave this aside.<br>&gt; <br>&gt; Are you suggesting that preserving the current syntax of the literal protocols is more important than fixing this behavior so it works like most people seem to expect?  Why not be open to other syntactic solutions? <br></p><p>I think fixing the behavior is good, and I stand by this proposal.  There is, however, nothing glaringly wrong with the literal protocols.  They do not need to redesigned simply because we found a syntactic interaction that needs to be cleaned up.<br></p><p>There are good reasons the protocols have evolved the way they have.  The labels clearly mark the purpose of each initializer and distinguish one from another on types that support multiple literal kinds.  The labels also clearly indicate that the initializers are not intended for general use.  The argument(s) to the initializer do not always represent a single value of literal type.  Some protocols provide multiple initializers, and it is quite possible that that will become gradually more common as we explore ways to grant more flexibility to code outside of the standard library.  And we actually consider it good that you can invoke these initializers explicitly; it&#39;s only accidental use that we feel it&#39;s important to avoid, which labels provide excellent protection against.<br></p><p>If you have specific criticisms of any of the literal protocols, e.g. you find them limiting or non-performant for your own types, then you are welcome to raise them here.  However, resemblance to actual literal syntax has never been a design goal for the literal protocols; and besides, this will always be a secondary literal syntax, one far less important than contextual typing.<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June  3, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jun 3, 2016, at 8:11 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Jun 3, 2016, at 5:13 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; On Jun 3, 2016, at 6:23 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 3, 2016, at 4:07 PM, David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; On Jun 3, 2016, at 16:17, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Using an external parameter label in a declaration and allowing it to be omitted at the call site does not feel like the right answer to me.  I think we can find a better way to present this syntactically.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; +eleventy gajillion<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m actually quite happy with the user-facing aspects of the current literal protocols and see zero reason to update them for this, so if that&#39;s the choice, I&#39;ll just leave this aside.<br>&gt;&gt; <br>&gt;&gt; Are you suggesting that preserving the current syntax of the literal protocols is more important than fixing this behavior so it works like most people seem to expect?  Why not be open to other syntactic solutions? <br>&gt; <br>&gt; I think fixing the behavior is good, and I stand by this proposal.  <br></p><p>I agree fixing it is good and we should do it.  I’m just trying to explore the solution space to see if there are any alternatives that might be more appealing.  Clearly you’ve thought about this a lot but it’s a new topic to consider for the rest of us.  :)<br></p><p>&gt; There is, however, nothing glaringly wrong with the literal protocols.  They do not need to redesigned simply because we found a syntactic interaction that needs to be cleaned up.<br>&gt; <br>&gt; There are good reasons the protocols have evolved the way they have.  The labels clearly mark the purpose of each initializer and distinguish one from another on types that support multiple literal kinds.  The labels also clearly indicate that the initializers are not intended for general use.  The argument(s) to the initializer do not always represent a single value of literal type.  Some protocols provide multiple initializers, and it is quite possible that that will become gradually more common as we explore ways to grant more flexibility to code outside of the standard library.  And we actually consider it good that you can invoke these initializers explicitly; it&#39;s only accidental use that we feel it&#39;s important to avoid, which labels provide excellent protection against.<br></p><p>If it is important that these initializers be callable directly I suppose the label is the only way to go.  I can’t think of a reason why this is necessary though.  I would consider it bad design for a type that expects to be initialized with an Int variable to require its callers to use the label, as opposed to providing an alternate initializer that doesn’t have a label with “literal” in its name.  Are there specific use cases where you think this capability is important or is it just the principle that you should be able to call any initializer you write?<br></p><p>-Matthew<br></p><p>&gt; <br>&gt; If you have specific criticisms of any of the literal protocols, e.g. you find them limiting or non-performant for your own types, then you are welcome to raise them here.  However, resemblance to actual literal syntax has never been a design goal for the literal protocols; and besides, this will always be a secondary literal syntax, one far less important than contextual typing.<br>&gt; <br>&gt; John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>June  3, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Jun 3, 2016, at 7:08 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; On Jun 3, 2016, at 8:11 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 3, 2016, at 5:13 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt; On Jun 3, 2016, at 6:23 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 3, 2016, at 4:07 PM, David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 3, 2016, at 16:17, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Using an external parameter label in a declaration and allowing it to be omitted at the call site does not feel like the right answer to me.  I think we can find a better way to present this syntactically.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; +eleventy gajillion<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m actually quite happy with the user-facing aspects of the current literal protocols and see zero reason to update them for this, so if that&#39;s the choice, I&#39;ll just leave this aside.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Are you suggesting that preserving the current syntax of the literal protocols is more important than fixing this behavior so it works like most people seem to expect?  Why not be open to other syntactic solutions? <br>&gt;&gt; <br>&gt;&gt; I think fixing the behavior is good, and I stand by this proposal.  <br>&gt; <br>&gt; I agree fixing it is good and we should do it.  I’m just trying to explore the solution space to see if there are any alternatives that might be more appealing.  Clearly you’ve thought about this a lot but it’s a new topic to consider for the rest of us.  :)<br></p><p>I&#39;m sorry if I&#39;ve come across as frustrated.  It&#39;s easy for me to forget that things that I consider well-settled haven&#39;t always been covered in depth here.  The community is not intentionally re-inventing things for no purpose, it&#39;s making a genuine effort to explore the constraints on a part of the language that it isn&#39;t familiar with the rationale for.<br></p><p>&gt;&gt; There is, however, nothing glaringly wrong with the literal protocols.  They do not need to redesigned simply because we found a syntactic interaction that needs to be cleaned up.<br>&gt;&gt; <br>&gt;&gt; There are good reasons the protocols have evolved the way they have.  The labels clearly mark the purpose of each initializer and distinguish one from another on types that support multiple literal kinds.  The labels also clearly indicate that the initializers are not intended for general use.  The argument(s) to the initializer do not always represent a single value of literal type.  Some protocols provide multiple initializers, and it is quite possible that that will become gradually more common as we explore ways to grant more flexibility to code outside of the standard library.  And we actually consider it good that you can invoke these initializers explicitly; it&#39;s only accidental use that we feel it&#39;s important to avoid, which labels provide excellent protection against.<br>&gt; <br>&gt; If it is important that these initializers be callable directly I suppose the label is the only way to go.  I can’t think of a reason why this is necessary though.  I would consider it bad design for a type that expects to be initialized with an Int variable to require its callers to use the label, as opposed to providing an alternate initializer that doesn’t have a label with “literal” in its name.  Are there specific use cases where you think this capability is important or is it just the principle that you should be able to call any initializer you write?<br></p><p>Partly that principle, but partly the ability to forward literal-initialization.  You can forward literal-initialization to, say, a BuiltinIntegerLiteralConvertible type by just appointing it your associated IntegerLiteralType, but if you&#39;re wrapping another type, that doesn&#39;t work.  For example:<br></p><p>  struct MyValue : IntegerLiteralConvertible {<br>    init(integerLiteral literal: JSONValue.IntegerLiteralType) {<br>      json = JSONValue(integerLiteral: literal)<br>    }<br>    ...<br>  }<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June  4, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jun 3, 2016, at 9:30 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Jun 3, 2016, at 7:08 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt; On Jun 3, 2016, at 8:11 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 3, 2016, at 5:13 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt; On Jun 3, 2016, at 6:23 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 3, 2016, at 4:07 PM, David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 3, 2016, at 16:17, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Using an external parameter label in a declaration and allowing it to be omitted at the call site does not feel like the right answer to me.  I think we can find a better way to present this syntactically.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; +eleventy gajillion<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;m actually quite happy with the user-facing aspects of the current literal protocols and see zero reason to update them for this, so if that&#39;s the choice, I&#39;ll just leave this aside.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Are you suggesting that preserving the current syntax of the literal protocols is more important than fixing this behavior so it works like most people seem to expect?  Why not be open to other syntactic solutions? <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think fixing the behavior is good, and I stand by this proposal.  <br>&gt;&gt; <br>&gt;&gt; I agree fixing it is good and we should do it.  I’m just trying to explore the solution space to see if there are any alternatives that might be more appealing.  Clearly you’ve thought about this a lot but it’s a new topic to consider for the rest of us.  :)<br>&gt; <br>&gt; I&#39;m sorry if I&#39;ve come across as frustrated.  It&#39;s easy for me to forget that things that I consider well-settled haven&#39;t always been covered in depth here.  The community is not intentionally re-inventing things for no purpose, it&#39;s making a genuine effort to explore the constraints on a part of the language that it isn&#39;t familiar with the rationale for.<br></p><p>No problem.  I know it’s not fun to revisit hard-thought decisions that you’re happy with! :)  And I can see how it feels like we’re trying to do that here.  That said, these discussions are the best way for the community to become familiar with some of the rationale for the way things currently are.  :)<br></p><p>&gt; <br>&gt;&gt;&gt; There is, however, nothing glaringly wrong with the literal protocols.  They do not need to redesigned simply because we found a syntactic interaction that needs to be cleaned up.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are good reasons the protocols have evolved the way they have.  The labels clearly mark the purpose of each initializer and distinguish one from another on types that support multiple literal kinds.  The labels also clearly indicate that the initializers are not intended for general use.  The argument(s) to the initializer do not always represent a single value of literal type.  Some protocols provide multiple initializers, and it is quite possible that that will become gradually more common as we explore ways to grant more flexibility to code outside of the standard library.  And we actually consider it good that you can invoke these initializers explicitly; it&#39;s only accidental use that we feel it&#39;s important to avoid, which labels provide excellent protection against.<br>&gt;&gt; <br>&gt;&gt; If it is important that these initializers be callable directly I suppose the label is the only way to go.  I can’t think of a reason why this is necessary though.  I would consider it bad design for a type that expects to be initialized with an Int variable to require its callers to use the label, as opposed to providing an alternate initializer that doesn’t have a label with “literal” in its name.  Are there specific use cases where you think this capability is important or is it just the principle that you should be able to call any initializer you write?<br>&gt; <br>&gt; Partly that principle, but partly the ability to forward literal-initialization.  You can forward literal-initialization to, say, a BuiltinIntegerLiteralConvertible type by just appointing it your associated IntegerLiteralType, but if you&#39;re wrapping another type, that doesn&#39;t work.  For example:<br>&gt; <br>&gt;  struct MyValue : IntegerLiteralConvertible {<br>&gt;    init(integerLiteral literal: JSONValue.IntegerLiteralType) {<br>&gt;      json = JSONValue(integerLiteral: literal)<br>&gt;    }<br>&gt;    ...<br>&gt;  }<br></p><p>What is the advantage of calling the literal JSONValue initializer here rather than a non-literal initializer that accepts JSONValue.IntegerLiteralType?  Is there something in the implementation that makes this more efficient?<br></p><p>If forwarding is the intended use for explicit calls, wouldn’t the `@literal` attribute attached to the type be an alternative way to address the forwarding use case?<br></p><p>Are there any non-forwarding use cases for explicit calls?<br></p><p>If forwarding is the only intended use case of explicit calls and `@literal` could cover that use case then the question (in my mind) is which principle do we hold more sacred?  The ability to call any initializer we write or the syntactic consistency that external argument labels are always required at the call site?  I admit this is partly an aesthetic concern…<br></p><p>-Matthew<br></p><p>&gt; <br>&gt; John.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160604/c1f36721/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June  4, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jun 4, 2016, at 4:00 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Jun 3, 2016, at 9:30 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 3, 2016, at 7:08 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; On Jun 3, 2016, at 8:11 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 3, 2016, at 5:13 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; On Jun 3, 2016, at 6:23 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 3, 2016, at 4:07 PM, David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 3, 2016, at 16:17, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Using an external parameter label in a declaration and allowing it to be omitted at the call site does not feel like the right answer to me.  I think we can find a better way to present this syntactically.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; +eleventy gajillion<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I&#39;m actually quite happy with the user-facing aspects of the current literal protocols and see zero reason to update them for this, so if that&#39;s the choice, I&#39;ll just leave this aside.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Are you suggesting that preserving the current syntax of the literal protocols is more important than fixing this behavior so it works like most people seem to expect?  Why not be open to other syntactic solutions? <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think fixing the behavior is good, and I stand by this proposal.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree fixing it is good and we should do it.  I’m just trying to explore the solution space to see if there are any alternatives that might be more appealing.  Clearly you’ve thought about this a lot but it’s a new topic to consider for the rest of us.  :)<br>&gt;&gt; <br>&gt;&gt; I&#39;m sorry if I&#39;ve come across as frustrated.  It&#39;s easy for me to forget that things that I consider well-settled haven&#39;t always been covered in depth here.  The community is not intentionally re-inventing things for no purpose, it&#39;s making a genuine effort to explore the constraints on a part of the language that it isn&#39;t familiar with the rationale for.<br>&gt; <br>&gt; No problem.  I know it’s not fun to revisit hard-thought decisions that you’re happy with! :)  And I can see how it feels like we’re trying to do that here.  That said, these discussions are the best way for the community to become familiar with some of the rationale for the way things currently are.  :)<br></p><p>I find It helps to read the docs that has been produced (not all up to date but still rich in background data). The source code is also a great place to do a reality chk on ideas. <br></p><p>@john thank you for taking the time to share.<br></p><p><br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; There is, however, nothing glaringly wrong with the literal protocols.  They do not need to redesigned simply because we found a syntactic interaction that needs to be cleaned up.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There are good reasons the protocols have evolved the way they have.  The labels clearly mark the purpose of each initializer and distinguish one from another on types that support multiple literal kinds.  The labels also clearly indicate that the initializers are not intended for general use.  The argument(s) to the initializer do not always represent a single value of literal type.  Some protocols provide multiple initializers, and it is quite possible that that will become gradually more common as we explore ways to grant more flexibility to code outside of the standard library.  And we actually consider it good that you can invoke these initializers explicitly; it&#39;s only accidental use that we feel it&#39;s important to avoid, which labels provide excellent protection against.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If it is important that these initializers be callable directly I suppose the label is the only way to go.  I can’t think of a reason why this is necessary though.  I would consider it bad design for a type that expects to be initialized with an Int variable to require its callers to use the label, as opposed to providing an alternate initializer that doesn’t have a label with “literal” in its name.  Are there specific use cases where you think this capability is important or is it just the principle that you should be able to call any initializer you write?<br>&gt;&gt; <br>&gt;&gt; Partly that principle, but partly the ability to forward literal-initialization.  You can forward literal-initialization to, say, a BuiltinIntegerLiteralConvertible type by just appointing it your associated IntegerLiteralType, but if you&#39;re wrapping another type, that doesn&#39;t work.  For example:<br>&gt;&gt; <br>&gt;&gt;  struct MyValue : IntegerLiteralConvertible {<br>&gt;&gt;    init(integerLiteral literal: JSONValue.IntegerLiteralType) {<br>&gt;&gt;      json = JSONValue(integerLiteral: literal)<br>&gt;&gt;    }<br>&gt;&gt;    ...<br>&gt;&gt;  }<br>&gt; <br>&gt; What is the advantage of calling the literal JSONValue initializer here rather than a non-literal initializer that accepts JSONValue.IntegerLiteralType?  Is there something in the implementation that makes this more efficient?<br>&gt; <br>&gt; If forwarding is the intended use for explicit calls, wouldn’t the `@literal` attribute attached to the type be an alternative way to address the forwarding use case?<br>&gt; <br>&gt; Are there any non-forwarding use cases for explicit calls?<br>&gt; <br>&gt; If forwarding is the only intended use case of explicit calls and `@literal` could cover that use case then the question (in my mind) is which principle do we hold more sacred?  The ability to call any initializer we write or the syntactic consistency that external argument labels are always required at the call site?  I admit this is partly an aesthetic concern…<br>&gt; <br>&gt; -Matthew<br>&gt; <br>&gt;&gt; <br>&gt;&gt; John.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160604/651aa728/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June  4, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jun 4, 2016, at 10:27 AM, LM &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Jun 4, 2016, at 4:00 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 3, 2016, at 9:30 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 3, 2016, at 7:08 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; On Jun 3, 2016, at 8:11 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 3, 2016, at 5:13 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 3, 2016, at 6:23 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 3, 2016, at 4:07 PM, David Sweeris &lt;davesweeris at mac.com &lt;mailto:davesweeris at mac.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 3, 2016, at 16:17, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Using an external parameter label in a declaration and allowing it to be omitted at the call site does not feel like the right answer to me.  I think we can find a better way to present this syntactically.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +eleventy gajillion<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I&#39;m actually quite happy with the user-facing aspects of the current literal protocols and see zero reason to update them for this, so if that&#39;s the choice, I&#39;ll just leave this aside.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Are you suggesting that preserving the current syntax of the literal protocols is more important than fixing this behavior so it works like most people seem to expect?  Why not be open to other syntactic solutions? <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think fixing the behavior is good, and I stand by this proposal.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I agree fixing it is good and we should do it.  I’m just trying to explore the solution space to see if there are any alternatives that might be more appealing.  Clearly you’ve thought about this a lot but it’s a new topic to consider for the rest of us.  :)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m sorry if I&#39;ve come across as frustrated.  It&#39;s easy for me to forget that things that I consider well-settled haven&#39;t always been covered in depth here.  The community is not intentionally re-inventing things for no purpose, it&#39;s making a genuine effort to explore the constraints on a part of the language that it isn&#39;t familiar with the rationale for.<br>&gt;&gt; <br>&gt;&gt; No problem.  I know it’s not fun to revisit hard-thought decisions that you’re happy with! :)  And I can see how it feels like we’re trying to do that here.  That said, these discussions are the best way for the community to become familiar with some of the rationale for the way things currently are.  :)<br>&gt; <br>&gt; I find It helps to read the docs that has been produced (not all up to date but still rich in background data). The source code is also a great place to do a reality chk on ideas. <br></p><p>Agree.  I have read most of the docs found here: https://github.com/apple/swift/tree/master/docs &lt;https://github.com/apple/swift/tree/master/docs&gt;.  But docs can only cover so much.  A lot of knowledge is often shared communally, but not explicitly documented.<br></p><p>&gt; <br>&gt; @john thank you for taking the time to share.<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There is, however, nothing glaringly wrong with the literal protocols.  They do not need to redesigned simply because we found a syntactic interaction that needs to be cleaned up.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There are good reasons the protocols have evolved the way they have.  The labels clearly mark the purpose of each initializer and distinguish one from another on types that support multiple literal kinds.  The labels also clearly indicate that the initializers are not intended for general use.  The argument(s) to the initializer do not always represent a single value of literal type.  Some protocols provide multiple initializers, and it is quite possible that that will become gradually more common as we explore ways to grant more flexibility to code outside of the standard library.  And we actually consider it good that you can invoke these initializers explicitly; it&#39;s only accidental use that we feel it&#39;s important to avoid, which labels provide excellent protection against.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If it is important that these initializers be callable directly I suppose the label is the only way to go.  I can’t think of a reason why this is necessary though.  I would consider it bad design for a type that expects to be initialized with an Int variable to require its callers to use the label, as opposed to providing an alternate initializer that doesn’t have a label with “literal” in its name.  Are there specific use cases where you think this capability is important or is it just the principle that you should be able to call any initializer you write?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Partly that principle, but partly the ability to forward literal-initialization.  You can forward literal-initialization to, say, a BuiltinIntegerLiteralConvertible type by just appointing it your associated IntegerLiteralType, but if you&#39;re wrapping another type, that doesn&#39;t work.  For example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  struct MyValue : IntegerLiteralConvertible {<br>&gt;&gt;&gt;    init(integerLiteral literal: JSONValue.IntegerLiteralType) {<br>&gt;&gt;&gt;      json = JSONValue(integerLiteral: literal)<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt;    ...<br>&gt;&gt;&gt;  }<br>&gt;&gt; <br>&gt;&gt; What is the advantage of calling the literal JSONValue initializer here rather than a non-literal initializer that accepts JSONValue.IntegerLiteralType?  Is there something in the implementation that makes this more efficient?<br>&gt;&gt; <br>&gt;&gt; If forwarding is the intended use for explicit calls, wouldn’t the `@literal` attribute attached to the type be an alternative way to address the forwarding use case?<br>&gt;&gt; <br>&gt;&gt; Are there any non-forwarding use cases for explicit calls?<br>&gt;&gt; <br>&gt;&gt; If forwarding is the only intended use case of explicit calls and `@literal` could cover that use case then the question (in my mind) is which principle do we hold more sacred?  The ability to call any initializer we write or the syntactic consistency that external argument labels are always required at the call site?  I admit this is partly an aesthetic concern…<br>&gt;&gt; <br>&gt;&gt; -Matthew<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; John.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160604/018d9551/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June  3, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; I am not the only one who feels that way.  Quoting Brent:<br>&gt; <br>&gt; &quot;But if you&#39;re going to call `init(integerLiteral:)` like it&#39;s `init(_:)`, I don&#39;t think that&#39;s a good idea. Parameter labels are supposed to be significant; we don&#39;t want to lose that.”<br>&gt; <br>&gt; I agree with this.  That is the motivation for my suggestion.  I think it’s at least worth discussing as an alternative to magically allowing an external parameter label to be omitted.  Brent, what do you think of my suggestion?<br></p><p>I think it could be simpler:<br></p><p>	public struct Literal&lt;LiteralType&gt; {<br>		public let value: LiteralType<br>		internal init(_value value: LiteralType)<br>	}<br>	<br>	public protocol IntegerLiteralConvertible {<br>		associatedtype IntegerLiteralType<br>		init(_ literal: Literal&lt;IntegerLiteralType&gt;)<br>	}<br></p><p>Only the standard library can create a Literal, which it would do by constructing the IntegerLiteralType with its magic builtin literal stuff and wrapping it. You still have your magic parameter aspect, but without any actual magic, just access control. <br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June  3, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jun 3, 2016, at 4:05 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; I am not the only one who feels that way.  Quoting Brent:<br>&gt;&gt; <br>&gt;&gt; &quot;But if you&#39;re going to call `init(integerLiteral:)` like it&#39;s `init(_:)`, I don&#39;t think that&#39;s a good idea. Parameter labels are supposed to be significant; we don&#39;t want to lose that.”<br>&gt;&gt; <br>&gt;&gt; I agree with this.  That is the motivation for my suggestion.  I think it’s at least worth discussing as an alternative to magically allowing an external parameter label to be omitted.  Brent, what do you think of my suggestion?<br>&gt; <br>&gt; I think it could be simpler:<br>&gt; <br>&gt; 	public struct Literal&lt;LiteralType&gt; {<br>&gt; 		public let value: LiteralType<br>&gt; 		internal init(_value value: LiteralType)<br>&gt; 	}<br>&gt; 	<br>&gt; 	public protocol IntegerLiteralConvertible {<br>&gt; 		associatedtype IntegerLiteralType<br>&gt; 		init(_ literal: Literal&lt;IntegerLiteralType&gt;)<br>&gt; 	}<br>&gt; <br>&gt; Only the standard library can create a Literal, which it would do by constructing the IntegerLiteralType with its magic builtin literal stuff and wrapping it. You still have your magic parameter aspect, but without any actual magic, just access control. <br></p><p>I like this solution as well as Xiaodi’s `@literal` idea better than the idea I came up with.  I think I like `@literal` best because it feels more appropriate to restrict an attribute to a specific context (signatures for literal convertible initializers) than anything else.  We don’t want to allow this in any other signatures and no types are restricted in that way.  The solution I came up with has that problem as well as the `#literal` “value” that is also restricted unlike other compiler generated values.  <br></p><p>I think our decision should be based upon which syntactic construct feels least inconsistent with other similar syntactic constructs and therefore feels the least arbitrary.  Restricting the usage of a generic `Literal` type to literal convertible initializers feels a little bit less arbitrary than allowing the call site to omit a label, but it feels a little bit more arbitrary than introducing an attribute that has a very specialized context of applicability.<br></p><p>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June  3, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; I think our decision should be based upon which syntactic construct feels least inconsistent with other similar syntactic constructs and therefore feels the least arbitrary.  Restricting the usage of a generic `Literal` type to literal convertible initializers feels a little bit less arbitrary than allowing the call site to omit a label, but it feels a little bit more arbitrary than introducing an attribute that has a very specialized context of applicability.<br></p><p>Honestly, I think `@literal` is only &quot;consistent&quot; with the rest of the language in that @s are used to mark compiler magic. `Literal&lt;&gt;` is attempting to *not* be much more magical than, say, `StringInterpolationConvertible`, where a particular syntax generates a certain pattern of calls.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>June  2, 2016 at 07:00:00pm</p></header><div class="content"><p>+1<br>It has nagged at me that this can happen even though I understood *why* it<br>happens.<br></p><p>On Thu, Jun 2, 2016 at 6:22 PM, John McCall via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; On Jun 2, 2016, at 2:43 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>&gt; wrote:<br>&gt; &gt;&gt; In my opinion, using this initializer-call syntax to build an<br>&gt; explicitly-typed literal is an obvious and natural choice with several<br>&gt; advantages over the &quot;as&quot; syntax.  However, even if you disagree, it&#39;s clear<br>&gt; that programmers are going to continue to independently try to use it, so<br>&gt; it&#39;s really unfortunate for it to be subtly wrong.<br>&gt; &gt;<br>&gt; &gt; I&#39;ve seen developers do this; in one memorable case, it resulted in<br>&gt; Swift taking a ridiculously long time to typecheck an expression, since the<br>&gt; seemingly pinned-down types of the literals had actually become *more*<br>&gt; ambiguous, not less.<br>&gt;<br>&gt; Yes, this would also tend to improve compile times, since currently we end<br>&gt; up generating a massively-ambiguous constraint system which must be<br>&gt; resolved by type defaulting.  That&#39;s not really why I&#39;m proposing this,<br>&gt; though.<br>&gt;<br>&gt; &gt; However, it&#39;s not difficult to teach developers to use `as`. Usually<br>&gt; what&#39;s happening is that their mental model of the language is wrong: they<br>&gt; think of `UInt16(foo)` as a cast to a primitive type, and are surprised to<br>&gt; learn that it&#39;s actually an initializer on a struct and they&#39;re<br>&gt; initializing an instance. Learning this helps them understand how the<br>&gt; language works, what the difference is between initializers and `as`, and<br>&gt; how they can write the same things they see in the standard library types.<br>&gt;<br>&gt; So, you think that this syntax is enticing to new developers who naturally<br>&gt; think that the feature works the way that I&#39;m proposing it should work, and<br>&gt; you think that the right solution is to make the syntax illegal so that you<br>&gt; can more conveniently tell them it doesn&#39;t work that way? :)<br>&gt;<br>&gt; You can still tell them that it&#39;s a struct and you&#39;re calling an<br>&gt; initializer on it; it&#39;s just that the initializer chosen is the special<br>&gt; literal initializer because the argument is a literal.<br>&gt;<br>&gt; John.<br>&gt;<br>&gt;<br>&gt;<br>&gt; &gt;<br>&gt; &gt; I think *actually* turning this into magic would be counterproductive.<br>&gt; The better solution is to make the compiler replace me in that story, by<br>&gt; having it emit a warning with a fix-it. It keeps initializer calls meaning<br>&gt; exactly what they say. (And it doesn&#39;t require an evolution proposal to do,<br>&gt; since you can add a warning with a mere bug.)<br>&gt; &gt;<br>&gt; &gt;       UInt16(42)<br>&gt; &gt;       ^~~~~~ ^~<br>&gt; &gt;       Use of initializer with integer literal does not cast &#39;42&#39; to<br>&gt; &#39;UInt16&#39;<br>&gt; &gt;       Fix-It: Replace with &#39;42 as UInt16&#39;<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Brent Royal-Gordon<br>&gt; &gt; Architechies<br>&gt; &gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/437d6ee9/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June  3, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; On Jun 2, 2016, at 6:08 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The official way to build a literal of a specific type is to write the literal in an explicitly-typed context, like so:<br>&gt;     let x: UInt16 = 7<br>&gt; or<br>&gt;     let x = 7 as UInt16<br>&gt; <br>&gt; Nonetheless, programmers often try the following:<br>&gt;     UInt16(7)<br>&gt; <br>&gt; Unfortunately, this does not attempt to construct the value using the appropriate literal protocol; it instead performs overload resolution using the standard rules, i.e. considering only single-argument unlabelled initializers of a type which conforms to IntegerLiteralConvertible.  Often this leads to static ambiguities or, worse, causes the literal to be built using a default type (such as Int); this may have semantically very different results which are only caught at runtime.<br>&gt; <br>&gt; In my opinion, using this initializer-call syntax to build an explicitly-typed literal is an obvious and natural choice with several advantages over the &quot;as&quot; syntax.  However, even if you disagree, it&#39;s clear that programmers are going to continue to independently try to use it, so it&#39;s really unfortunate for it to be subtly wrong.<br>&gt; <br>&gt; Therefore, I propose that we adopt the following typing rule:<br>&gt; <br>&gt;   Given a function call expression of the form A(B) (that is, an expr-call with a single, unlabelled argument) where B is an expr-literal or expr-collection, if A has type T.Type for some type T and there is a declared conformance of T to an appropriate literal protocol for B, then the expression is always resolves as a literal construction of type T (as if the expression were written &quot;B as A&quot;) rather than as a general initializer call.<br></p><p>Looking transversally at all literal protocols as this proposes to operates reminds me that the knowledge that a protocol has the right semantic is based on a convention, rather than on conformance. Would it be conceibable to look into something like the following, that all others would specialize.<br></p><p>protocol LiteralConvertible {}<br></p><p>This might offer a stronger identification than the name. It might also be interesting to define an associated type, but that would exclude NilLiteralConvertible.<br></p><p>Note: as compiler expert, I would appreciate your thinking on the notion of formally expressing what might otherwise be a known strong semantic relationship. Is there any incentive to pursue, known disavantages, ...<br></p><p><br>&gt; <br>&gt; Formally, this would be a special form of the argument conversion constraint, since the type of the expression A may not be immediately known.<br>&gt; <br>&gt; Note that, as specified, it is possible to suppress this typing rule by wrapping the literal in parentheses.  This might seem distasteful; it would be easy enough to allow the form of B to include extra parentheses.  It&#39;s potentially useful to have a way to suppress this rule and get a normal construction, but there are several other ways of getting that effect, such as explicitly typing the literal argument (e.g. writing &quot;A(Int(B))&quot;).<br>&gt; <br>&gt; A conditional conformance counts as a declared conformance even if the generic arguments are known to not satisfy the conditional conformance.  This permits the applicability of the rule to be decided without having to first decide the type arguments, which greatly simplifies the type-checking problem (and may be necessary for soundness; I didn&#39;t explore this in depth, but it certainly feels like a very nasty sort of dependence).  We could potentially weaken this for cases where A is a direct type reference with bound parameters, e.g. Foo&lt;Int&gt;([]) or the same with a typealias, but I think there&#39;s some benefit from having a simpler specification, both for the implementation and for the explicability of the model.<br>&gt; <br>&gt; John.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160603/f4d54d58/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>June  3, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jun 2, 2016, at 10:31 PM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt; On Jun 2, 2016, at 6:08 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; The official way to build a literal of a specific type is to write the literal in an explicitly-typed context, like so:<br>&gt;&gt;     let x: UInt16 = 7<br>&gt;&gt; or<br>&gt;&gt;     let x = 7 as UInt16<br>&gt;&gt; <br>&gt;&gt; Nonetheless, programmers often try the following:<br>&gt;&gt;     UInt16(7)<br>&gt;&gt; <br>&gt;&gt; Unfortunately, this does not attempt to construct the value using the appropriate literal protocol; it instead performs overload resolution using the standard rules, i.e. considering only single-argument unlabelled initializers of a type which conforms to IntegerLiteralConvertible.  Often this leads to static ambiguities or, worse, causes the literal to be built using a default type (such as Int); this may have semantically very different results which are only caught at runtime.<br>&gt;&gt; <br>&gt;&gt; In my opinion, using this initializer-call syntax to build an explicitly-typed literal is an obvious and natural choice with several advantages over the &quot;as&quot; syntax.  However, even if you disagree, it&#39;s clear that programmers are going to continue to independently try to use it, so it&#39;s really unfortunate for it to be subtly wrong.<br>&gt;&gt; <br>&gt;&gt; Therefore, I propose that we adopt the following typing rule:<br>&gt;&gt; <br>&gt;&gt;   Given a function call expression of the form A(B) (that is, an expr-call with a single, unlabelled argument) where B is an expr-literal or expr-collection, if A has type T.Type for some type T and there is a declared conformance of T to an appropriate literal protocol for B, then the expression is always resolves as a literal construction of type T (as if the expression were written &quot;B as A&quot;) rather than as a general initializer call.<br>&gt; <br>&gt; Looking transversally at all literal protocols as this proposes to operates reminds me that the knowledge that a protocol has the right semantic is based on a convention, rather than on conformance. Would it be conceibable to look into something like the following, that all others would specialize.<br>&gt; <br>&gt; protocol LiteralConvertible {}<br>&gt; <br>&gt; This might offer a stronger identification than the name. It might also be interesting to define an associated type, but that would exclude NilLiteralConvertible.<br>&gt; <br>&gt; Note: as compiler expert, I would appreciate your thinking on the notion of formally expressing what might otherwise be a known strong semantic relationship. Is there any incentive to pursue, known disavantages, ...<br></p><p>I don&#39;t know what you&#39;re saying here.  Literal types already do explicitly conform to a protocol that&#39;s specific to the literal; it&#39;s not just convention.  There&#39;s nothing linking those protocols because there&#39;s no useful operation in common: there is no useful generic code that you can write that works for an arbitrary type that allows some unknown kind of literal.  We intentionally do not add protocols that do not serve some useful purpose in generic programming.<br></p><p>John.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160603/b9ad8386/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June  3, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Jun 3, 2016, at 8:51 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Jun 2, 2016, at 10:31 PM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt;&gt;&gt; On Jun 2, 2016, at 6:08 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The official way to build a literal of a specific type is to write the literal in an explicitly-typed context, like so:<br>&gt;&gt;&gt;     let x: UInt16 = 7<br>&gt;&gt;&gt; or<br>&gt;&gt;&gt;     let x = 7 as UInt16<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Nonetheless, programmers often try the following:<br>&gt;&gt;&gt;     UInt16(7)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Unfortunately, this does not attempt to construct the value using the appropriate literal protocol; it instead performs overload resolution using the standard rules, i.e. considering only single-argument unlabelled initializers of a type which conforms to IntegerLiteralConvertible.  Often this leads to static ambiguities or, worse, causes the literal to be built using a default type (such as Int); this may have semantically very different results which are only caught at runtime.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In my opinion, using this initializer-call syntax to build an explicitly-typed literal is an obvious and natural choice with several advantages over the &quot;as&quot; syntax.  However, even if you disagree, it&#39;s clear that programmers are going to continue to independently try to use it, so it&#39;s really unfortunate for it to be subtly wrong.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Therefore, I propose that we adopt the following typing rule:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   Given a function call expression of the form A(B) (that is, an expr-call with a single, unlabelled argument) where B is an expr-literal or expr-collection, if A has type T.Type for some type T and there is a declared conformance of T to an appropriate literal protocol for B, then the expression is always resolves as a literal construction of type T (as if the expression were written &quot;B as A&quot;) rather than as a general initializer call.<br>&gt;&gt; <br>&gt;&gt; Looking transversally at all literal protocols as this proposes to operates reminds me that the knowledge that a protocol has the right semantic is based on a convention, rather than on conformance. Would it be conceibable to look into something like the following, that all others would specialize.<br>&gt;&gt; <br>&gt;&gt; protocol LiteralConvertible {}<br>&gt;&gt; <br>&gt;&gt; This might offer a stronger identification than the name. It might also be interesting to define an associated type, but that would exclude NilLiteralConvertible.<br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; I don&#39;t know what you&#39;re saying here.  Literal types already do explicitly conform to a protocol that&#39;s specific to the literal; it&#39;s not just convention.<br></p><p>Sorry for my lack of clarity. Each literal type (string/int/array...) is independent from the others, forming a &#39;set&#39; only in appearance. And in the compiler, they must all be declared individually in knownprotocols.def. Which then means that these are the only literals, which the compiler knows and can reason about now and for ever. And then if users write a hypothetical XyzLiteralConvertible, there is no chance for the compiler to ever treat it like the builins.<br></p><p>&gt;  There&#39;s nothing linking those protocols because there&#39;s no useful operation in common: there is no useful generic code that you can write that works for an arbitrary type that allows some unknown kind of literal.<br></p><p>I believe I understand. I come from a heavy java/scala background, with lots of reflection/invokedynamic/bytecode work, so it looked like a bit of missed opportunities for some future proofing of the runtime. Particularly being able to discover at compile-time additional protocols than those listed statically in knownprotocols.def<br></p><p>&gt;  We intentionally do not add protocols that do not serve some useful purpose in generic programming.<br></p><p>I understand and respecfully point to a discrepancy with this logic: the existance of the _builtinxxx underlying layer. To me it says that some protocols (there are others) do carry a compiler oriented semantic, and when i found it i took it as the sign that the team was willing to consider that it was worth using the language constructs to encode some of its semantics, in the name of creating future proofing or simplifying the compiler source.  But your answer is clear, and I now understand it as: _builtinxxxliteral is an exceptional case, not necessarily a design principle or future proofing tool.<br></p><p>&gt;&gt; Note: as compiler expert, I would appreciate your thinking on the notion of formally expressing what might otherwise be a known strong semantic relationship. Is there any incentive to pursue, known disavantages, ...<br></p><p>This part was an extension on future proofing another part of the library where there is IMHO a real incentive for formalizing what exists today, considering it will likely never change and is already a source of questions. I am still trying to find a formalism that would align with how the library and compiler are designed, so it will be its own topic. Thank you for taking the time.<br></p><p>&gt; <br>&gt; John.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160603/7541b2e5/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>June  4, 2016 at 11:00:00am</p></header><div class="content"><p>On Jun 2, 2016, at 9:08 AM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The official way to build a literal of a specific type is to write the literal in an explicitly-typed context, like so:<br>&gt;     let x: UInt16 = 7<br>&gt; or<br>&gt;     let x = 7 as UInt16<br>&gt; <br>&gt; Nonetheless, programmers often try the following:<br>&gt;     UInt16(7)<br>&gt; <br>&gt; Unfortunately, this does not attempt to construct the value using the appropriate literal protocol; it instead performs overload resolution using the standard rules, i.e. considering only single-argument unlabelled initializers of a type which conforms to IntegerLiteralConvertible.  Often this leads to static ambiguities or, worse, causes the literal to be built using a default type (such as Int); this may have semantically very different results which are only caught at runtime.<br>&gt; <br>&gt; In my opinion, using this initializer-call syntax to build an explicitly-typed literal is an obvious and natural choice with several advantages over the &quot;as&quot; syntax.<br></p><p>I completely agree that this is a problem that we need to solve.  In addition to the trap of using [U]Int64 values on 32-bit targets, it is embarrassing that we reject (on all targets):<br></p><p>	let x = UInt64(0x8000_0000_0000_0000)<br></p><p>and require people to use the less obvious syntax:<br></p><p>	let x = 0x1000_0000_0000_0000 as UInt64<br></p><p>&gt; Therefore, I propose that we adopt the following typing rule:<br></p><p>I’m sorry of this has already been covered down-thread (just getting caught up now, and haven’t read it all), but this seems like a LOT of magic in the type checker to solve this problem.<br></p><p>Can’t we just require that literal convertibles implement an initializer that the type checker will already consider to be more specific than any of the other overloads?  This would eliminate the need for magic like this in the type checker.  Right now, we have this:<br></p><p>public protocol IntegerLiteralConvertible {<br>  associatedtype IntegerLiteralType : _BuiltinIntegerLiteralConvertible<br>  init(integerLiteral value: IntegerLiteralType)<br>}<br></p><p>Change it to be an unlabeled requirement like this probably isn’t enough to make it privileged in the case of ambiguity:<br></p><p>public protocol IntegerLiteralConvertible {<br>  associatedtype IntegerLiteralType : _BuiltinIntegerLiteralConvertible<br>  init(_ value: IntegerLiteralType)<br>}<br></p><p>but perhaps we could have:<br></p><p>public protocol IntegerLiteralConvertible {<br>  associatedtype IntegerLiteralType : _BuiltinIntegerLiteralConvertible<br>  init(integerLiteral value: IntegerLiteralType)<br>  init&lt;T : IntegerLiteralConvertible&gt;(_ value: T)<br>}<br></p><p>and get the type checker to consider the later one to be a“more specific” match than the other overloads, when confronted with a literal?<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160604/4c86d86f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>June  7, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jun 4, 2016, at 11:54 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; On Jun 2, 2016, at 9:08 AM, John McCall via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The official way to build a literal of a specific type is to write the literal in an explicitly-typed context, like so:<br>&gt;&gt;     let x: UInt16 = 7<br>&gt;&gt; or<br>&gt;&gt;     let x = 7 as UInt16<br>&gt;&gt; <br>&gt;&gt; Nonetheless, programmers often try the following:<br>&gt;&gt;     UInt16(7)<br>&gt;&gt; <br>&gt;&gt; Unfortunately, this does not attempt to construct the value using the appropriate literal protocol; it instead performs overload resolution using the standard rules, i.e. considering only single-argument unlabelled initializers of a type which conforms to IntegerLiteralConvertible.  Often this leads to static ambiguities or, worse, causes the literal to be built using a default type (such as Int); this may have semantically very different results which are only caught at runtime.<br>&gt;&gt; <br>&gt;&gt; In my opinion, using this initializer-call syntax to build an explicitly-typed literal is an obvious and natural choice with several advantages over the &quot;as&quot; syntax.<br>&gt; <br>&gt; I completely agree that this is a problem that we need to solve.  In addition to the trap of using [U]Int64 values on 32-bit targets, it is embarrassing that we reject (on all targets):<br>&gt; <br>&gt; 	let x = UInt64(0x8000_0000_0000_0000)<br>&gt; <br>&gt; and require people to use the less obvious syntax:<br>&gt; <br>&gt; 	let x = 0x1000_0000_0000_0000 as UInt64<br>&gt; <br>&gt;&gt; Therefore, I propose that we adopt the following typing rule:<br>&gt; <br>&gt; I’m sorry of this has already been covered down-thread (just getting caught up now, and haven’t read it all), but this seems like a LOT of magic in the type checker to solve this problem.<br></p><p>It was somewhat covered elsewhere in the thread, but this particular idea is new, I think.<br></p><p>&gt; Can’t we just require that literal convertibles implement an initializer that the type checker will already consider to be more specific than any of the other overloads?  This would eliminate the need for magic like this in the type checker.  Right now, we have this:<br>&gt; <br>&gt; public protocol IntegerLiteralConvertible {<br>&gt;   associatedtype IntegerLiteralType : _BuiltinIntegerLiteralConvertible<br>&gt;   init(integerLiteral value: IntegerLiteralType)<br>&gt; }<br>&gt; <br>&gt; Change it to be an unlabeled requirement like this probably isn’t enough to make it privileged in the case of ambiguity:<br></p><p>Right.<br></p><p>&gt; public protocol IntegerLiteralConvertible {<br>&gt;   associatedtype IntegerLiteralType : _BuiltinIntegerLiteralConvertible<br>&gt;   init(_ value: IntegerLiteralType)<br>&gt; }<br>&gt; <br>&gt; but perhaps we could have:<br>&gt; <br>&gt; public protocol IntegerLiteralConvertible {<br>&gt;   associatedtype IntegerLiteralType : _BuiltinIntegerLiteralConvertible<br>&gt;   init(integerLiteral value: IntegerLiteralType)<br>&gt;   init&lt;T : IntegerLiteralConvertible&gt;(_ value: T)<br>&gt; }<br>&gt; <br>&gt; and get the type checker to consider the later one to be a“more specific” match than the other overloads, when confronted with a literal?<br></p><p>Er.  We definitely don&#39;t want to say that every integer-literal-convertible type has to be initializable from an arbitrary value of an arbitrary other integer-literal-convertible type.  That&#39;s not an implementable requirement, nor should it be.<br></p><p>The idea of making a special unlabelled initializer that&#39;s preferred by the type-checker came up earlier in the thread; the more workable proposals included declaring it with @literal or changing the type to some magic Literal&lt;T&gt; type.  I just don&#39;t think it&#39;s a good idea because it&#39;s still basically the same type-checker magic on the expression side to recognize that we should favor the case, and then it adds extra complexity on the declaration side; plus the different literal protocols start to interfere with each other if one type implements more than one of them.<br></p><p>If you&#39;re worried about the complexity of adding new constraints, we could start with a more modest rule that only applies the special case when the callee is syntactically a type reference rather than e.g. an arbitrary expression of metatype value.  But changing the ambiguity-resolution rules is actually a lot more complex than just adding a new constraint.<br></p><p>John.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160607/edbd7874/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
