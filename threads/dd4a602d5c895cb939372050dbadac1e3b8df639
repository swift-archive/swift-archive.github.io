<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6e4479b6097e171f8f46de71f35764ba?s=50"></div><header><strong>Proposal: Tuple Convertible</strong> from <string>Nikolai Vazquez</string> &lt;nvazquez1297 at gmail.com&gt;<p>December  6, 2015 at 11:00:00pm</p></header><div class="content"><p>When working with points, I’ll sometimes make a typealias to an integer<br>tuple:<br></p><p>typealias Point = (x: Int, y: Int)<br></p><p>However, if I want to add extended functionality to my Point type, I would<br>have to change it to a struct, removing the ability to create one on the<br>fly with a tuple.<br></p><p>I’m proposing a TupleConvertible protocol that allows initialization from a<br>tuple directly.<br></p><p>struct Point: TupleConvertible {<br></p><p>    var x, y: Int<br></p><p>    init(x: Int, y: Int) {<br>        self.x = x<br>        self.y = y<br>    }<br></p><p>    init(tuple: (x: Int, y: Int)) {<br>        self.init(x: tuple.x, y: tuple.y)<br>    }<br></p><p>}<br></p><p>This would make it very easy to create new Point instances.<br></p><p>let somePoint: Point = (50, 120)let otherPoint = Point(x: 50, y: 120)<br></p><p>​<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/dd4af639/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d68c97e8e2f1653b54c24493caf236ae?s=50"></div><header><strong>Proposal: Tuple Convertible</strong> from <string>Stephen Celis</string> &lt;stephen.celis at gmail.com&gt;<p>December  6, 2015 at 07:00:00pm</p></header><div class="content"><p>Do you mean a TupleLiteralConvertible? I’m also in favor of a ClosureLiteralConvertible (or FunctionLiteralConvertible).<br></p><p>Stephen<br></p><p>&gt; On Dec 6, 2015, at 6:40 PM, Nikolai Vazquez via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; When working with points, I’ll sometimes make a typealias to an integer tuple:<br>&gt; <br>&gt; typealias Point = (x: Int, y: Int)<br>&gt; However, if I want to add extended functionality to my Point type, I would have to change it to a struct, removing the ability to create one on the fly with a tuple.<br>&gt; <br>&gt; I’m proposing a TupleConvertible protocol that allows initialization from a tuple directly.<br>&gt; <br>&gt; struct Point: TupleConvertible {<br>&gt; <br>&gt;     var x, y: Int<br>&gt; <br>&gt;     init(x: Int, y: Int) {<br>&gt;         self.x = x<br>&gt;         self.y = y<br>&gt;     }<br>&gt; <br>&gt;     init(tuple: (x: Int, y: Int)) {<br>&gt;         self.init(x: tuple.x, y: tuple.y)<br>&gt;     }<br>&gt; <br>&gt; }<br>&gt; This would make it very easy to create new Point instances.<br>&gt; <br>&gt; let somePoint: Point = (50, 120)<br>&gt; let otherPoint = Point(x: 50, y: 120)<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/4a56088d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6e4479b6097e171f8f46de71f35764ba?s=50"></div><header><strong>Proposal: Tuple Convertible</strong> from <string>Nikolai Vazquez</string> &lt;nvazquez1297 at gmail.com&gt;<p>December  7, 2015 at 12:00:00am</p></header><div class="content"><p>I was thinking it could work for variables that are already tuples but then<br>that goes against Swift&#39;s strict typing. So really it should only be for<br>tuple literals.<br></p><p>On Sun, Dec 6, 2015, 7:01 PM Stephen Celis &lt;stephen.celis at gmail.com&gt; wrote:<br></p><p>&gt; Do you mean a TupleLiteralConvertible? I’m also in favor of a<br>&gt; ClosureLiteralConvertible (or FunctionLiteralConvertible).<br>&gt;<br>&gt; Stephen<br>&gt;<br>&gt; On Dec 6, 2015, at 6:40 PM, Nikolai Vazquez via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; When working with points, I’ll sometimes make a typealias to an integer<br>&gt; tuple:<br>&gt;<br>&gt; typealias Point = (x: Int, y: Int)<br>&gt;<br>&gt; However, if I want to add extended functionality to my Point type, I<br>&gt; would have to change it to a struct, removing the ability to create one<br>&gt; on the fly with a tuple.<br>&gt;<br>&gt; I’m proposing a TupleConvertible protocol that allows initialization from<br>&gt; a tuple directly.<br>&gt;<br>&gt; struct Point: TupleConvertible {<br>&gt;<br>&gt;     var x, y: Int<br>&gt;<br>&gt;     init(x: Int, y: Int) {<br>&gt;         self.x = x<br>&gt;         self.y = y<br>&gt;     }<br>&gt;<br>&gt;     init(tuple: (x: Int, y: Int)) {<br>&gt;         self.init(x: tuple.x, y: tuple.y)<br>&gt;     }<br>&gt;<br>&gt; }<br>&gt;<br>&gt; This would make it very easy to create new Point instances.<br>&gt;<br>&gt; let somePoint: Point = (50, 120)let otherPoint = Point(x: 50, y: 120)<br>&gt;<br>&gt; ​<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/9c1f4b4a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Proposal: Tuple Convertible</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>December  6, 2015 at 10:00:00pm</p></header><div class="content"><p>&gt; On Dec 6, 2015, at 4:07 PM, Nikolai Vazquez via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; I was thinking it could work for variables that are already tuples but then that goes against Swift&#39;s strict typing. So really it should only be for tuple literals.<br>&gt; <br></p><p>I think this is an interesting idea, but I believe it’s not actually expressible in the current generics system without hard-coding the protocol to just 2-tuples.<br></p><p>John.<br></p><p>&gt; <br>&gt; On Sun, Dec 6, 2015, 7:01 PM Stephen Celis &lt;stephen.celis at gmail.com &lt;mailto:stephen.celis at gmail.com&gt;&gt; wrote:<br>&gt; Do you mean a TupleLiteralConvertible? I’m also in favor of a ClosureLiteralConvertible (or FunctionLiteralConvertible).<br>&gt; <br>&gt; Stephen<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 6, 2015, at 6:40 PM, Nikolai Vazquez via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt; <br>&gt;&gt; When working with points, I’ll sometimes make a typealias to an integer tuple:<br>&gt;&gt; <br>&gt;&gt; typealias Point = (x: Int, y: Int)<br>&gt;&gt; However, if I want to add extended functionality to my Point type, I would have to change it to a struct, removing the ability to create one on the fly with a tuple.<br>&gt;&gt; <br>&gt;&gt; I’m proposing a TupleConvertible protocol that allows initialization from a tuple directly.<br>&gt;&gt; <br>&gt;&gt; struct Point: TupleConvertible {<br>&gt;&gt; <br>&gt;&gt;     var x, y: Int<br>&gt;&gt; <br>&gt;&gt;     init(x: Int, y: Int) {<br>&gt;&gt;         self.x = x<br>&gt;&gt;         self.y = y<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     init(tuple: (x: Int, y: Int)) {<br>&gt;&gt;         self.init(x: tuple.x, y: tuple.y)<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; This would make it very easy to create new Point instances.<br>&gt;&gt; <br>&gt;&gt; let somePoint: Point = (50, 120)<br>&gt;&gt; let otherPoint = Point(x: 50, y: 120)<br>&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/930a7940/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a03106b2fbee9e0ada822057dfd0b6d3?s=50"></div><header><strong>Proposal: Tuple Convertible</strong> from <string>Tal Atlas</string> &lt;me at tal.by&gt;<p>December  7, 2015 at 02:00:00pm</p></header><div class="content"><p>Overall this is an interesting idea but in practice I think what you’re<br>looking for is more of scala implicit conversions. A way to define a<br>conversion from one type to another so that when you cast the implicit<br>conversion gets run for you. It’s much more flexible and gives you what you<br>want without only working for tuples.<br></p><p>On Mon, Dec 7, 2015 at 1:02 AM John McCall via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Dec 6, 2015, at 4:07 PM, Nikolai Vazquez via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I was thinking it could work for variables that are already tuples but<br>&gt; then that goes against Swift&#39;s strict typing. So really it should only be<br>&gt; for tuple literals.<br>&gt;<br>&gt;<br>&gt; I think this is an interesting idea, but I believe it’s not actually<br>&gt; expressible in the current generics system without hard-coding the protocol<br>&gt; to just 2-tuples.<br>&gt;<br>&gt; John.<br>&gt;<br>&gt;<br>&gt; On Sun, Dec 6, 2015, 7:01 PM Stephen Celis &lt;stephen.celis at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; Do you mean a TupleLiteralConvertible? I’m also in favor of a<br>&gt;&gt; ClosureLiteralConvertible (or FunctionLiteralConvertible).<br>&gt;&gt;<br>&gt;&gt; Stephen<br>&gt;&gt;<br>&gt;&gt; On Dec 6, 2015, at 6:40 PM, Nikolai Vazquez via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; When working with points, I’ll sometimes make a typealias to an integer<br>&gt;&gt; tuple:<br>&gt;&gt;<br>&gt;&gt; typealias Point = (x: Int, y: Int)<br>&gt;&gt;<br>&gt;&gt; However, if I want to add extended functionality to my Point type, I<br>&gt;&gt; would have to change it to a struct, removing the ability to create one<br>&gt;&gt; on the fly with a tuple.<br>&gt;&gt;<br>&gt;&gt; I’m proposing a TupleConvertible protocol that allows initialization<br>&gt;&gt; from a tuple directly.<br>&gt;&gt;<br>&gt;&gt; struct Point: TupleConvertible {<br>&gt;&gt;<br>&gt;&gt;     var x, y: Int<br>&gt;&gt;<br>&gt;&gt;     init(x: Int, y: Int) {<br>&gt;&gt;         self.x = x<br>&gt;&gt;         self.y = y<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;     init(tuple: (x: Int, y: Int)) {<br>&gt;&gt;         self.init(x: tuple.x, y: tuple.y)<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; This would make it very easy to create new Point instances.<br>&gt;&gt;<br>&gt;&gt; let somePoint: Point = (50, 120)let otherPoint = Point(x: 50, y: 120)<br>&gt;&gt;<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/98f15b14/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
