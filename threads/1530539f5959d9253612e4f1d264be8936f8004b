<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c40db4457ab2c91a0d8006da31b177c6?s=50"></div><header><strong>[Proposal] Scoped resources (like C# using statement)</strong> from <string>Trent Nadeau</string> &lt;tanadeau at gmail.com&gt;<p>December 29, 2015 at 11:00:00pm</p></header><div class="content"><p># Introduction<br></p><p>Add a new `Scoped` protocol and enhance the do statement to automatically<br>call enter/exit actions on resources.<br></p><p># Motivation<br></p><p>Resources (e.g., locks, files, sockets, etc.) often need to be scoped to a<br>block, where some action is taken at the start of the block and another is<br>required at the end. Examples include locking and unlocking a lock in a<br>critical section or closing a file at the end of a block.<br></p><p>Doing this manually is possible using `defer` statements among other<br>options, but this is error prone as a `defer` can be forgotten,<br>`lock`/`unlock` calls for two locks can be switched due to a typo, etc.<br>Having a dedicated language construct for this common case makes it easier<br>to read and write while making code shorter and clearer.<br></p><p># Language Survey<br></p><p>At least three major languages have widely used statements for this use<br>case.<br></p><p>## C#<br></p><p>C# has the `using` statement and the associated `IDisposable` interface.<br></p><p>```csharp<br>using (StreamReader sr = new StreamReader(filename)) {<br>    txt = sr.ReadToEnd();<br>}<br>```<br></p><p>C#&#39;s solution only handles close/exit actions via the<br>`IDisposable.Dispose()` method and so cannot easily be used with items such<br>as locks; however, C# has the additional `lock` statement for that use case.<br></p><p>## Java<br></p><p>Java has try-with-resources and the associated `AutoCloseable` interface.<br></p><p>```java<br>try (BufferedReader br = new BufferedReader(new FileReader(path))) {<br>    return br.readLine();<br>}<br>```<br></p><p>Java&#39;s solution only handles close/exit actions via the<br>`AutoCloseable.close()` method and so cannot easily be used with items such<br>as locks; however, Java has the additional `synchronized` statement for<br>that use case.<br></p><p>## Python<br></p><p>Python has with `with` statement and the associated `__enter__` and<br>`__exit__` special methods that classes may implement to become a &quot;context<br>manager&quot;.<br></p><p>```python<br>with lock, open(path) as my_file:<br>    contents = my_file.read()<br>    # use contents<br>```<br></p><p>Python&#39;s solution handles both enter and exit actions and so this one<br>construct is usable for locks as well as resources like sockets and files.<br></p><p># Proposed Solution<br></p><p>We add a new protocol called `Scoped` to the standard library. Types for<br>resources that have enter/exit actions will be extended to add conformance<br>to this protocol.<br></p><p>The `do` statement will be extended to allow a new `using &lt;resources&gt;`<br>&quot;suffix&quot;.<br></p><p># Detailed Design<br></p><p>The `Scoped` protocol shall be as follows:<br></p><p>```swift<br>public protocol Scoped {<br>    func enterScope()<br>    func exitScope()<br>}<br>```<br></p><p>The compiler statement will accept a new form for resources. For example,<br></p><p>```swift<br>do using lock, let file = try getFileHandle() {<br>    // statements<br>}<br>```<br></p><p>As can be seen in the example above, the resources can be bindings that<br>already exist (like `lock`) or can be new bindings. Bindings created with<br>`do using` are not available outside of the scope of the `do using`. Only<br>types conforming to `Scoped` may be using with `do using`. Use of<br>non-conforming types will result in a compiler error.<br></p><p>The above example would be syntactic sugar for the following:<br></p><p>```swift<br>do {<br>    lock.enterScope()<br>    defer { lock.exitScope() }<br></p><p>    let file = try getFileHandle()<br>    file.enterScope()<br>    defer { file.exitScope() }<br></p><p>    // statements<br>}<br>```<br></p><p># Framework Changes / Examples<br></p><p>As an example of some real-world classes that would be useful with<br>`Scoped`, from Foundation:<br></p><p>```swift<br>// Would be nice to extend the NSLocking protocol instead, but that&#39;s not<br>supported yet.<br>extension NSLock: Scoped {<br>    func enterScope() {<br>        self.lock()<br>    }<br></p><p>    func exitScope() {<br>        self.unlock()<br>    }<br>}<br></p><p>extension NSFileHandle: Scoped {<br>    func enterScope() {}<br></p><p>    func exitScope() {<br>        self.closeFile()<br>    }<br>}<br>```<br></p><p># Questions and Concerns<br> * Bikeshedding protocol naming and scoping syntax<br> * Should the enter and exit actions be allowed to throw errors?<br></p><p>-- <br>Trent Nadeau<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151229/1530004b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal] Scoped resources (like C# using statement)</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 29, 2015 at 08:00:00pm</p></header><div class="content"><p>On Dec 29, 2015, at 8:02 PM, Trent Nadeau via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Doing this manually is possible using `defer` statements among other options, but this is error prone as a `defer` can be forgotten, `lock`/`unlock` calls for two locks can be switched due to a typo, etc. Having a dedicated language construct for this common case makes it easier to read and write while making code shorter and clearer.<br>&gt; <br>&gt; ```swift<br>&gt; do {<br>&gt;     lock.enterScope()<br>&gt;     defer { lock.exitScope() }<br>&gt; <br>&gt;     let file = try getFileHandle()<br>&gt;     file.enterScope()<br>&gt;     defer { file.exitScope() }<br>&gt; <br>&gt;     // statements<br>&gt; }<br></p><p>We have another pattern that types can use, which is:<br></p><p>lock.withThisLockHeld {<br>  … stuff ...<br>}<br></p><p>This can be done today with trailing closures.  Other examples of this are “autoreleasepool” and withUnsafePointer (for other reasons).<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c40db4457ab2c91a0d8006da31b177c6?s=50"></div><header><strong>[Proposal] Scoped resources (like C# using statement)</strong> from <string>Trent Nadeau</string> &lt;tanadeau at gmail.com&gt;<p>December 29, 2015 at 11:00:00pm</p></header><div class="content"><p>While useful, that pattern doesn&#39;t seem to compose well. What if you need<br>two locks? Would that be:<br></p><p>lock1.withThisLockHeld {<br>    lock2.withThisLockHeld {<br>        // statements<br>    }<br>}<br></p><p>If so, it seems like it has the &quot;pyramid of doom&quot; issue that prompted<br>allowing `if let` to have multiple bindings.<br></p><p>In addition to the possible indentation and vertical space issue, you need<br>to look up if and how each resource type does this. I believe this is a<br>general enough pattern that it deserves language support. I think an<br>analogy to the current situation would be if each collection type had its<br>own way to iterate (Array.forEach, Set.withEachElement, etc.) instead of<br>having for-in.<br></p><p>On Tue, Dec 29, 2015 at 11:15 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br></p><p>&gt; On Dec 29, 2015, at 8:02 PM, Trent Nadeau via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; Doing this manually is possible using `defer` statements among other<br>&gt; options, but this is error prone as a `defer` can be forgotten,<br>&gt; `lock`/`unlock` calls for two locks can be switched due to a typo, etc.<br>&gt; Having a dedicated language construct for this common case makes it easier<br>&gt; to read and write while making code shorter and clearer.<br>&gt; &gt;<br>&gt; &gt; ```swift<br>&gt; &gt; do {<br>&gt; &gt;     lock.enterScope()<br>&gt; &gt;     defer { lock.exitScope() }<br>&gt; &gt;<br>&gt; &gt;     let file = try getFileHandle()<br>&gt; &gt;     file.enterScope()<br>&gt; &gt;     defer { file.exitScope() }<br>&gt; &gt;<br>&gt; &gt;     // statements<br>&gt; &gt; }<br>&gt;<br>&gt; We have another pattern that types can use, which is:<br>&gt;<br>&gt; lock.withThisLockHeld {<br>&gt;   … stuff ...<br>&gt; }<br>&gt;<br>&gt; This can be done today with trailing closures.  Other examples of this are<br>&gt; “autoreleasepool” and withUnsafePointer (for other reasons).<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br></p><p><br>-- <br>Trent Nadeau<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151229/57b8b26f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[Proposal] Scoped resources (like C# using statement)</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>December 30, 2015 at 01:00:00am</p></header><div class="content"><p>My understanding is that you suggest using the &quot;do using&quot; statement for two purposes:<br></p><p>to deterministically free resources (files, sockets);<br>to create a scope with a guarantee about something (locks).<br></p><p>The first purpose is very relevant for garbage-collected languages because the GC generally only monitors memory pressure to decide when to run, and so the GC won&#39;t budge if you&#39;re running out of file descriptors even if some could be reclaimed. However, Swift is not garbage-collected and resources are already reclaimed deterministically. If you create a Swift object that represents a file descriptor and don&#39;t allow references to escape the function, the object will be destroyed (and its resources reclaimed) at the latest when the function returns. In my opinion, this makes a &quot;do using&quot; statement useless for resource management.<br></p><p>For scopes with guarantees, as Chris said, the most common pattern is to have a function that accepts a closure. I&#39;ve seen some pretty serious nesting with `if let` (which are one very frequent case of scopes with guarantees), but other than that, I don&#39;t see lots of nesting and I&#39;ve been pretty happy with what the language can do so far. The only thing I can complain about is that you can&#39;t use break/continue with the current setup.<br></p><p>I see the discrepancy between objects, but I would say that any scope-based solution will often be just as hard to discover as the current solutions. `do using AutoreleasePool() { ... }` isn&#39;t an improvement over `autoreleasepool { ... }`.<br></p><p>It&#39;s better for the lock case, but only if you agree that `do using` is useless for resource management. Otherwise, if your mutex itself benefits from being scoped, `do using lock` is probably creating/deleting a mutex, and you&#39;d need to use `do using Lock(mutex) { ... }` to actually lock it (like with C++ mutex/lock objects), which is as discoverable as `mutex.lock { ... }`.<br></p><p>Félix<br></p><p>&gt; Le 29 déc. 2015 à 23:24:53, Trent Nadeau via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; While useful, that pattern doesn&#39;t seem to compose well. What if you need two locks? Would that be:<br>&gt; <br>&gt; lock1.withThisLockHeld {<br>&gt;     lock2.withThisLockHeld {<br>&gt;         // statements<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; If so, it seems like it has the &quot;pyramid of doom&quot; issue that prompted allowing `if let` to have multiple bindings.<br>&gt; <br>&gt; In addition to the possible indentation and vertical space issue, you need to look up if and how each resource type does this. I believe this is a general enough pattern that it deserves language support. I think an analogy to the current situation would be if each collection type had its own way to iterate (Array.forEach, Set.withEachElement, etc.) instead of having for-in.<br>&gt; <br>&gt; On Tue, Dec 29, 2015 at 11:15 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt; On Dec 29, 2015, at 8:02 PM, Trent Nadeau via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt; Doing this manually is possible using `defer` statements among other options, but this is error prone as a `defer` can be forgotten, `lock`/`unlock` calls for two locks can be switched due to a typo, etc. Having a dedicated language construct for this common case makes it easier to read and write while making code shorter and clearer.<br>&gt; &gt;<br>&gt; &gt; ```swift<br>&gt; &gt; do {<br>&gt; &gt;     lock.enterScope()<br>&gt; &gt;     defer { lock.exitScope() }<br>&gt; &gt;<br>&gt; &gt;     let file = try getFileHandle()<br>&gt; &gt;     file.enterScope()<br>&gt; &gt;     defer { file.exitScope() }<br>&gt; &gt;<br>&gt; &gt;     // statements<br>&gt; &gt; }<br>&gt; <br>&gt; We have another pattern that types can use, which is:<br>&gt; <br>&gt; lock.withThisLockHeld {<br>&gt;   … stuff ...<br>&gt; }<br>&gt; <br>&gt; This can be done today with trailing closures.  Other examples of this are “autoreleasepool” and withUnsafePointer (for other reasons).<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Trent Nadeau<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/1144e544/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c40db4457ab2c91a0d8006da31b177c6?s=50"></div><header><strong>[Proposal] Scoped resources (like C# using statement)</strong> from <string>Trent Nadeau</string> &lt;tanadeau at gmail.com&gt;<p>December 30, 2015 at 01:00:00am</p></header><div class="content"><p>I disagree that `do using` would be useless for resources. Essentially no<br>Cocoa resource classes have a `deinit`. NSFileHandle, NSStream, etc.<br>require a close-like call to free the underlying resource. Also, per the<br>Swift documentation about deinitialization:<br></p><p>    &quot;Typically you don’t need to perform manual clean-up when your<br>instances are deallocated. However, when you are working with your own<br>resources, you might need to perform some additional clean-up yourself. For<br>example, if you create a custom class to open a file and write some data to<br>it, you might need to close the file before the class instance is<br>deallocated.&quot;<br></p><p>On Wed, Dec 30, 2015 at 1:19 AM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br></p><p>&gt; My understanding is that you suggest using the &quot;do using&quot; statement for<br>&gt; two purposes:<br>&gt;<br>&gt;<br>&gt;    1. to deterministically free resources (files, sockets);<br>&gt;    2. to create a scope with a guarantee about something (locks).<br>&gt;<br>&gt;<br>&gt; The first purpose is very relevant for garbage-collected languages because<br>&gt; the GC generally only monitors memory pressure to decide when to run, and<br>&gt; so the GC won&#39;t budge if you&#39;re running out of file descriptors even if<br>&gt; some could be reclaimed. However, Swift is not garbage-collected and<br>&gt; resources are already reclaimed deterministically. If you create a Swift<br>&gt; object that represents a file descriptor and don&#39;t allow references to<br>&gt; escape the function, the object will be destroyed (and its resources<br>&gt; reclaimed) at the latest when the function returns. In my opinion, this<br>&gt; makes a &quot;do using&quot; statement useless for resource management.<br>&gt;<br>&gt; For scopes with guarantees, as Chris said, the most common pattern is to<br>&gt; have a function that accepts a closure. I&#39;ve seen some pretty serious<br>&gt; nesting with `if let` (which are one very frequent case of scopes with<br>&gt; guarantees), but other than that, I don&#39;t see lots of nesting and I&#39;ve been<br>&gt; pretty happy with what the language can do so far. The only thing I can<br>&gt; complain about is that you can&#39;t use break/continue with the current setup.<br>&gt;<br>&gt; I see the discrepancy between objects, but I would say that any<br>&gt; scope-based solution will often be just as hard to discover as the current<br>&gt; solutions. `do using AutoreleasePool() { ... }` isn&#39;t an improvement over<br>&gt; `autoreleasepool { ... }`.<br>&gt;<br>&gt; It&#39;s better for the lock case, but only if you agree that `do using` is<br>&gt; useless for resource management. Otherwise, if your mutex itself benefits<br>&gt; from being scoped, `do using lock` is probably creating/deleting a mutex,<br>&gt; and you&#39;d need to use `do using Lock(mutex) { ... }` to actually lock it<br>&gt; (like with C++ mutex/lock objects), which is as discoverable as `mutex.lock<br>&gt; { ... }`.<br>&gt;<br>&gt; Félix<br>&gt;<br>&gt; Le 29 déc. 2015 à 23:24:53, Trent Nadeau via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;<br>&gt; While useful, that pattern doesn&#39;t seem to compose well. What if you need<br>&gt; two locks? Would that be:<br>&gt;<br>&gt; lock1.withThisLockHeld {<br>&gt;     lock2.withThisLockHeld {<br>&gt;         // statements<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; If so, it seems like it has the &quot;pyramid of doom&quot; issue that prompted<br>&gt; allowing `if let` to have multiple bindings.<br>&gt;<br>&gt; In addition to the possible indentation and vertical space issue, you need<br>&gt; to look up if and how each resource type does this. I believe this is a<br>&gt; general enough pattern that it deserves language support. I think an<br>&gt; analogy to the current situation would be if each collection type had its<br>&gt; own way to iterate (Array.forEach, Set.withEachElement, etc.) instead of<br>&gt; having for-in.<br>&gt;<br>&gt; On Tue, Dec 29, 2015 at 11:15 PM, Chris Lattner &lt;clattner at apple.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; On Dec 29, 2015, at 8:02 PM, Trent Nadeau via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt; Doing this manually is possible using `defer` statements among other<br>&gt;&gt; options, but this is error prone as a `defer` can be forgotten,<br>&gt;&gt; `lock`/`unlock` calls for two locks can be switched due to a typo, etc.<br>&gt;&gt; Having a dedicated language construct for this common case makes it easier<br>&gt;&gt; to read and write while making code shorter and clearer.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; ```swift<br>&gt;&gt; &gt; do {<br>&gt;&gt; &gt;     lock.enterScope()<br>&gt;&gt; &gt;     defer { lock.exitScope() }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;     let file = try getFileHandle()<br>&gt;&gt; &gt;     file.enterScope()<br>&gt;&gt; &gt;     defer { file.exitScope() }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;     // statements<br>&gt;&gt; &gt; }<br>&gt;&gt;<br>&gt;&gt; We have another pattern that types can use, which is:<br>&gt;&gt;<br>&gt;&gt; lock.withThisLockHeld {<br>&gt;&gt;   … stuff ...<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; This can be done today with trailing closures.  Other examples of this<br>&gt;&gt; are “autoreleasepool” and withUnsafePointer (for other reasons).<br>&gt;&gt;<br>&gt;&gt; -Chris<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Trent Nadeau<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br></p><p><br>-- <br>Trent Nadeau<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/73d32199/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Proposal] Scoped resources (like C# using statement)</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 29, 2015 at 11:00:00pm</p></header><div class="content"><p>That&#39;s completely false. All of the Cocoa classes that manage resources absolutely clean them up in deinit. The explicit call to closeFile() on NSFileHandle exists for two reasons:<br></p><p>1. To let you close the file before throwing away the handle (e.g. if<br>   you know the handle is being kept alive by something else but still<br>   want to close the file right now), and<br>2. Because you can create instances of NSFileHandle that explicitly<br>   don&#39;t close the handle in dealloc (typically because they don&#39;t &quot;own&quot;<br>   the file handle), the closeFile() call lets you change your mind and<br>   close it anyway.<br></p><p>NSStream doesn&#39;t document its deinit behavior, but it definitely closes<br>itself automatically if it&#39;s still open when it deinits.<br></p><p>Also, the quoted passage from the Swift documentation is talking about<br>why you might need to implement deinit. In your class&#39;s deinit you can<br>close/free any resources that your class manages.<br></p><p>So none of this is at all relevant to any kind of scoped operation.<br></p><p>-Kevin Ballard<br></p><p>On Tue, Dec 29, 2015, at 10:45 PM, Trent Nadeau via swift-evolution wrote:<br>&gt; I disagree that `do using` would be useless for resources. Essentially<br>&gt; no Cocoa resource classes have a `deinit`. NSFileHandle, NSStream,<br>&gt; etc. require a close-like call to free the underlying resource. Also,<br>&gt; per the Swift documentation about deinitialization:<br>&gt;<br>&gt; &quot;Typically you don’t need to perform manual clean-up when your<br>&gt; instances are deallocated. However, when you are working with your own<br>&gt; resources, you might need to perform some additional clean-up<br>&gt; yourself. For example, if you create a custom class to open a file and<br>&gt; write some data to it, you might need to close the file before the<br>&gt; class instance is deallocated.&quot;<br>&gt;<br>&gt; On Wed, Dec 30, 2015 at 1:19 AM, Félix Cloutier<br>&gt; &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt;&gt; My understanding is that you suggest using the &quot;do using&quot; statement<br>&gt;&gt; for two purposes:<br>&gt;&gt;<br>&gt;&gt;  1. to deterministically free resources (files, sockets);<br>&gt;&gt;  2. to create a scope with a guarantee about something (locks).<br>&gt;&gt;<br>&gt;&gt; The first purpose is very relevant for garbage-collected languages<br>&gt;&gt; because the GC generally only monitors memory pressure to decide when<br>&gt;&gt; to run, and so the GC won&#39;t budge if you&#39;re running out of file<br>&gt;&gt; descriptors even if some could be reclaimed. However, Swift is not<br>&gt;&gt; garbage-collected and resources are already reclaimed<br>&gt;&gt; deterministically. If you create a Swift object that represents a<br>&gt;&gt; file descriptor and don&#39;t allow references to escape the function,<br>&gt;&gt; the object will be destroyed (and its resources reclaimed) at the<br>&gt;&gt; latest when the function returns. In my opinion, this makes a &quot;do<br>&gt;&gt; using&quot; statement useless for resource management.<br>&gt;&gt;<br>&gt;&gt; For scopes with guarantees, as Chris said, the most common pattern is<br>&gt;&gt; to have a function that accepts a closure. I&#39;ve seen some pretty<br>&gt;&gt; serious nesting with `if let` (which are one very frequent case of<br>&gt;&gt; scopes with guarantees), but other than that, I don&#39;t see lots of<br>&gt;&gt; nesting and I&#39;ve been pretty happy with what the language can do so<br>&gt;&gt; far. The only thing I can complain about is that you can&#39;t use<br>&gt;&gt; break/continue with the current setup.<br>&gt;&gt;<br>&gt;&gt; I see the discrepancy between objects, but I would say that any scope-<br>&gt;&gt; based solution will often be just as hard to discover as the current<br>&gt;&gt; solutions. `do using AutoreleasePool() { ... }` isn&#39;t an improvement<br>&gt;&gt; over `autoreleasepool { ... }`.<br>&gt;&gt;<br>&gt;&gt; It&#39;s better for the lock case, but only if you agree that `do using`<br>&gt;&gt; is useless for resource management. Otherwise, if your mutex itself<br>&gt;&gt; benefits from being scoped, `do using lock` is probably<br>&gt;&gt; creating/deleting a mutex, and you&#39;d need to use `do using<br>&gt;&gt; Lock(mutex) { ... }` to actually lock it (like with C++ mutex/lock<br>&gt;&gt; objects), which is as discoverable as `mutex.lock { ... }`.<br>&gt;&gt;<br>&gt;&gt; Félix<br>&gt;&gt;<br>&gt;&gt;&gt; Le 29 déc. 2015 à 23:24:53, Trent Nadeau via swift-evolution &lt;swift-<br>&gt;&gt;&gt; evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; While useful, that pattern doesn&#39;t seem to compose well. What if you<br>&gt;&gt;&gt; need two locks? Would that be:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; lock1.withThisLockHeld {    lock2.withThisLockHeld {        //<br>&gt;&gt;&gt; statements    } }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If so, it seems like it has the &quot;pyramid of doom&quot; issue that<br>&gt;&gt;&gt; prompted allowing `if let` to have multiple bindings.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In addition to the possible indentation and vertical space issue,<br>&gt;&gt;&gt; you need to look up if and how each resource type does this. I<br>&gt;&gt;&gt; believe this is a general enough pattern that it deserves language<br>&gt;&gt;&gt; support. I think an analogy to the current situation would be if<br>&gt;&gt;&gt; each collection type had its own way to iterate (Array.forEach,<br>&gt;&gt;&gt; Set.withEachElement, etc.) instead of having for-in.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Tue, Dec 29, 2015 at 11:15 PM, Chris<br>&gt;&gt;&gt; Lattner&lt;clattner at apple.com&gt;wrote:<br>&gt;&gt;&gt;&gt; On Dec 29, 2015, at 8:02 PM, Trent Nadeau via swift-evolution &lt;swift-<br>&gt;&gt;&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt; Doing this manually is possible using `defer` statements among<br>&gt;&gt;&gt;&gt; &gt; other options, but this is error prone as a `defer` can be<br>&gt;&gt;&gt;&gt; &gt; forgotten, `lock`/`unlock` calls for two locks can be switched<br>&gt;&gt;&gt;&gt; &gt; due to a typo, etc. Having a dedicated language construct for<br>&gt;&gt;&gt;&gt; &gt; this common case makes it easier to read and write while making<br>&gt;&gt;&gt;&gt; &gt; code shorter and clearer.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; ```swift do {     lock.enterScope()     defer {<br>&gt;&gt;&gt;&gt; &gt; lock.exitScope() }<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;let file = try getFileHandle()     file.enterScope()     defer {<br>&gt;&gt;&gt;&gt; &gt;file.exitScope() }<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;// statements }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; We have another pattern that types can use, which is:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; lock.withThisLockHeld { … stuff ... }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This can be done today with trailing closures.  Other examples of<br>&gt;&gt;&gt;&gt; this are “autoreleasepool” and withUnsafePointer (for other<br>&gt;&gt;&gt;&gt; reasons).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Trent Nadeau<br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Trent Nadeau<br>&gt;<br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151229/8881a155/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Proposal] Scoped resources (like C# using statement)</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 29, 2015 at 08:00:00pm</p></header><div class="content"><p>An alternative solution is to do what Rust and C++ do, which is to use<br>RAII. Which is to say, instead of introducing a new language construct<br>that&#39;s explicitly tied to a scope, you just use a struct to represent<br>the resource that you hold (e.g. a File that represents an open file).<br>Of course, this does require some changes to structs, notably the<br>addition of a deinit. And if structs have a deinit, then they also need<br>to have a way to restrict copies. This is precisely what Rust does; any<br>struct in Rust that implements Drop (the equivalent to deinit) loses the<br>ability to be implicitly copied (a second trait called Clone provides a<br>.clone() method that is the normal way to copy such non-implicitly-<br>copyable structs).<br></p><p>This solution is elegant for a few reasons:<br></p><p>1. Once you allow deinit on structs (which is useful) and deal with the<br>   fact that structs are no longer implicitly copyable (because almost<br>   all deinit functions on structs won&#39;t work right if they&#39;re called<br>   twice, such as on two copies), then RAII just sort of falls out of<br>   all of this and doesn&#39;t require any specific language features.<br>2. It&#39;s more flexible, because you can actually return the RAII value<br>   from a scope in order to extend its lifetime.<br>3. The RAII value itself provides the means to access the resource it&#39;s<br>   protecting; e.g. a Lock might return a LockGuard RAII value from the<br>   .lock() method, and LockGuard provides the means to access the<br>   protected value (as opposed to just having the lock sitting next to<br>   the value, which makes it trivially easy to accidentally access the<br>   value without holding the lock).<br>4. In Rust, this pattern also integrates extremely well with Rust&#39;s<br>   lifetime system (the system that prevents data races / memory<br>   corruption at compile time), because e.g. a LockGuard contains the<br>   lifetime of the Lock, which prevents you at compile-time from<br>   attempting to lock the Lock while you already have it locked (though<br>   it doesn&#39;t prevent deadlocks where you and another thread try and<br>   lock two locks in opposite orders, but there is plenty of stuff it<br>   does catch).<br></p><p>The biggest problem with adding deinit to structs in Swift right now is<br>the fact that we don&#39;t have references, which means you can&#39;t take a<br>RAII struct and pass it to another function without losing it. Heck, you<br>can&#39;t even call a method on it, because `self` on non-mutating methods<br>in Swift is a value and not a reference (although we could hand-wave<br>that away and make `self` in non-mutating RAII methods actually be an<br>&quot;in&quot; reference internally, but this kind of hand-waving doesn&#39;t work<br>when passing the struct as an argument to another function). So we&#39;d<br>actually have to introduce a special &quot;in&quot; reference, which would be like<br>&quot;inout&quot; except it doesn&#39;t actually copy it out (and is guaranteed to<br>actually pass a pointer, although this pointer may be a pointer to a<br>temporary). Except even that fails if you want to have a computed<br>property that returns an existing RAII value (for example, having an<br>Array of these things; barring optimizations, the subscript getter<br>returns a computed value). And you can&#39;t generalize such &quot;in&quot; references<br>beyond function arguments without basically providing raw C pointers.<br>Rust&#39;s lifetime system lets them do it safely, but barring such a<br>system, Swift can&#39;t really do this (I assume it&#39;s obvious why we don&#39;t<br>want to start using raw C pointers everywhere).<br></p><p>All that said, I think this is a problem Swift needs to solve, because<br>having non-copyable structs would be very useful. In particular, I<br>_really_ want some way to do atomics in Swift, but the only safe way I<br>can think of to do it requires non-copyable structs (because it&#39;s not<br>correct to do a nonatomic read (such as a memcpy) of an atomic that&#39;s<br>visible to other threads). I suppose you could provide a way to override<br>how struct copies work (e.g. so you could do an atomic read of the old<br>value), but it&#39;s rather problematic to break the assumption that struct<br>copies are cheap.<br></p><p>Of course, you could model RAII with classes instead of structs, that<br>just has the overhead of heap allocation (+ atomic reference counting)<br>for every RAII value.<br></p><p>-Kevin Ballard<br></p><p>On Tue, Dec 29, 2015, at 08:02 PM, Trent Nadeau via swift-evolution wrote:<br>&gt; # Introduction<br>&gt;<br>&gt; Add a new `Scoped` protocol and enhance the do statement to<br>&gt; automatically call enter/exit actions on resources.<br>&gt;<br>&gt; # Motivation<br>&gt;<br>&gt; Resources (e.g., locks, files, sockets, etc.) often need to be scoped<br>&gt; to a block, where some action is taken at the start of the block and<br>&gt; another is required at the end. Examples include locking and unlocking<br>&gt; a lock in a critical section or closing a file at the end of a block.<br>&gt;<br>&gt; Doing this manually is possible using `defer` statements among other<br>&gt; options, but this is error prone as a `defer` can be forgotten,<br>&gt; `lock`/`unlock` calls for two locks can be switched due to a typo,<br>&gt; etc. Having a dedicated language construct for this common case makes<br>&gt; it easier to read and write while making code shorter and clearer.<br>&gt;<br>&gt; # Language Survey<br>&gt;<br>&gt; At least three major languages have widely used statements for this<br>&gt; use case.<br>&gt;<br>&gt; ## C#<br>&gt;<br>&gt; C# has the `using` statement and the associated `IDisposable`<br>&gt; interface.<br>&gt;<br>&gt; ```csharp using (StreamReader sr = new StreamReader(filename)) {<br>&gt; txt = sr.ReadToEnd(); } ```<br>&gt;<br>&gt; C#&#39;s solution only handles close/exit actions via the<br>&gt; `IDisposable.Dispose()` method and so cannot easily be used with items<br>&gt; such as locks; however, C# has the additional `lock` statement for<br>&gt; that use case.<br>&gt;<br>&gt; ## Java<br>&gt;<br>&gt; Java has try-with-resources and the associated `AutoCloseable`<br>&gt; interface.<br>&gt;<br>&gt; ```java try (BufferedReader br = new BufferedReader(new<br>&gt; FileReader(path))) {    return br.readLine(); } ```<br>&gt;<br>&gt; Java&#39;s solution only handles close/exit actions via the<br>&gt; `AutoCloseable.close()` method and so cannot easily be used with items<br>&gt; such as locks; however, Java has the additional `synchronized`<br>&gt; statement for that use case.<br>&gt;<br>&gt; ## Python<br>&gt;<br>&gt; Python has with `with` statement and the associated `__enter__` and<br>&gt; `__exit__` special methods that classes may implement to become a<br>&gt; &quot;context manager&quot;.<br>&gt;<br>&gt; ```python with lock, open(path) as my_file:    contents =<br>&gt; my_file.read()    # use contents ```<br>&gt;<br>&gt; Python&#39;s solution handles both enter and exit actions and so this<br>&gt; one construct is usable for locks as well as resources like sockets<br>&gt; and files.<br>&gt;<br>&gt; # Proposed Solution<br>&gt;<br>&gt; We add a new protocol called `Scoped` to the standard library. Types<br>&gt; for resources that have enter/exit actions will be extended to add<br>&gt; conformance to this protocol.<br>&gt;<br>&gt; The `do` statement will be extended to allow a new `using &lt;resources&gt;`<br>&gt; &quot;suffix&quot;.<br>&gt;<br>&gt; # Detailed Design<br>&gt;<br>&gt; The `Scoped` protocol shall be as follows:<br>&gt;<br>&gt; ```swift public protocol Scoped {    func enterScope()    func<br>&gt; exitScope() } ```<br>&gt;<br>&gt; The compiler statement will accept a new form for resources. For<br>&gt; example,<br>&gt;<br>&gt; ```swift do using lock, let file = try getFileHandle() {    //<br>&gt; statements } ```<br>&gt;<br>&gt; As can be seen in the example above, the resources can be bindings<br>&gt; that already exist (like `lock`) or can be new bindings. Bindings<br>&gt; created with `do using` are not available outside of the scope of the<br>&gt; `do using`. Only types conforming to `Scoped` may be using with `do<br>&gt; using`. Use of non-conforming types will result in a compiler error.<br>&gt;<br>&gt; The above example would be syntactic sugar for the following:<br>&gt;<br>&gt; ```swift do {    lock.enterScope()    defer { lock.exitScope() }<br>&gt;<br>&gt; let file = try getFileHandle()    file.enterScope()    defer {<br>&gt; file.exitScope() }<br>&gt;<br>&gt; // statements } ```<br>&gt;<br>&gt; # Framework Changes / Examples<br>&gt;<br>&gt; As an example of some real-world classes that would be useful with<br>&gt; `Scoped`, from Foundation:<br>&gt;<br>&gt; ```swift // Would be nice to extend the NSLocking protocol instead,<br>&gt; but that&#39;s not supported yet. extension NSLock: Scoped {    func<br>&gt; enterScope() {        self.lock()    }<br>&gt;<br>&gt; func exitScope() {        self.unlock()    } }<br>&gt;<br>&gt; extension NSFileHandle: Scoped {    func enterScope() {}<br>&gt;<br>&gt; func exitScope() {        self.closeFile()    } } ```<br>&gt;<br>&gt; # Questions and Concerns<br>&gt; * Bikeshedding protocol naming and scoping syntax * Should the enter<br>&gt; and exit actions be allowed to throw errors?<br>&gt;<br>&gt; --<br>&gt; Trent Nadeau<br>&gt;<br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151229/eed27746/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e5b8fa5e4f9e527ea335031bf2ec9a03?s=50"></div><header><strong>[Proposal] Scoped resources (like C# using statement)</strong> from <string>Árpád Goretity</string> &lt;arpad.goretity at gmail.com&gt;<p>December 30, 2015 at 07:00:00am</p></header><div class="content"><p>I&#39;m really standing with Kevin on this one — no non-orthogonal features and special cases please. If we allow RAII- (DIRR-)-style constructors and destructors, we get a solution that is more general (needs no new syntax nor a separate language construct) and doesn&#39;t introduce syntactic noise (via the triangle of death).<br></p><p>Sent from my iPhone<br></p><p>&gt; On 30 Dec 2015, at 05:55, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; An alternative solution is to do what Rust and C++ do, which is to use RAII. Which is to say, instead of introducing a new language construct that&#39;s explicitly tied to a scope, you just use a struct to represent the resource that you hold (e.g. a File that represents an open file). Of course, this does require some changes to structs, notably the addition of a deinit. And if structs have a deinit, then they also need to have a way to restrict copies. This is precisely what Rust does; any struct in Rust that implements Drop (the equivalent to deinit) loses the ability to be implicitly copied (a second trait called Clone provides a .clone() method that is the normal way to copy such non-implicitly-copyable structs).<br>&gt;  <br>&gt; This solution is elegant for a few reasons:<br>&gt;  <br>&gt; 1. Once you allow deinit on structs (which is useful) and deal with the fact that structs are no longer implicitly copyable (because almost all deinit functions on structs won&#39;t work right if they&#39;re called twice, such as on two copies), then RAII just sort of falls out of all of this and doesn&#39;t require any specific language features.<br>&gt; 2. It&#39;s more flexible, because you can actually return the RAII value from a scope in order to extend its lifetime.<br>&gt; 3. The RAII value itself provides the means to access the resource it&#39;s protecting; e.g. a Lock might return a LockGuard RAII value from the .lock() method, and LockGuard provides the means to access the protected value (as opposed to just having the lock sitting next to the value, which makes it trivially easy to accidentally access the value without holding the lock).<br>&gt; 4. In Rust, this pattern also integrates extremely well with Rust&#39;s lifetime system (the system that prevents data races / memory corruption at compile time), because e.g. a LockGuard contains the lifetime of the Lock, which prevents you at compile-time from attempting to lock the Lock while you already have it locked (though it doesn&#39;t prevent deadlocks where you and another thread try and lock two locks in opposite orders, but there is plenty of stuff it does catch).<br>&gt;  <br>&gt; The biggest problem with adding deinit to structs in Swift right now is the fact that we don&#39;t have references, which means you can&#39;t take a RAII struct and pass it to another function without losing it. Heck, you can&#39;t even call a method on it, because `self` on non-mutating methods in Swift is a value and not a reference (although we could hand-wave that away and make `self` in non-mutating RAII methods actually be an &quot;in&quot; reference internally, but this kind of hand-waving doesn&#39;t work when passing the struct as an argument to another function). So we&#39;d actually have to introduce a special &quot;in&quot; reference, which would be like &quot;inout&quot; except it doesn&#39;t actually copy it out (and is guaranteed to actually pass a pointer, although this pointer may be a pointer to a temporary). Except even that fails if you want to have a computed property that returns an existing RAII value (for example, having an Array of these things; barring optimizations, the subscript getter returns a computed value). And you can&#39;t generalize such &quot;in&quot; references beyond function arguments without basically providing raw C pointers. Rust&#39;s lifetime system lets them do it safely, but barring such a system, Swift can&#39;t really do this (I assume it&#39;s obvious why we don&#39;t want to start using raw C pointers everywhere).<br>&gt;  <br>&gt; All that said, I think this is a problem Swift needs to solve, because having non-copyable structs would be very useful. In particular, I _really_ want some way to do atomics in Swift, but the only safe way I can think of to do it requires non-copyable structs (because it&#39;s not correct to do a nonatomic read (such as a memcpy) of an atomic that&#39;s visible to other threads). I suppose you could provide a way to override how struct copies work (e.g. so you could do an atomic read of the old value), but it&#39;s rather problematic to break the assumption that struct copies are cheap.<br>&gt;  <br>&gt; Of course, you could model RAII with classes instead of structs, that just has the overhead of heap allocation (+ atomic reference counting) for every RAII value.<br>&gt;  <br>&gt; -Kevin Ballard<br>&gt;  <br>&gt;&gt; On Tue, Dec 29, 2015, at 08:02 PM, Trent Nadeau via swift-evolution wrote:<br>&gt;&gt; # Introduction<br>&gt;&gt;  <br>&gt;&gt; Add a new `Scoped` protocol and enhance the do statement to automatically call enter/exit actions on resources.<br>&gt;&gt;  <br>&gt;&gt; # Motivation<br>&gt;&gt;  <br>&gt;&gt; Resources (e.g., locks, files, sockets, etc.) often need to be scoped to a block, where some action is taken at the start of the block and another is required at the end. Examples include locking and unlocking a lock in a critical section or closing a file at the end of a block.<br>&gt;&gt;  <br>&gt;&gt; Doing this manually is possible using `defer` statements among other options, but this is error prone as a `defer` can be forgotten, `lock`/`unlock` calls for two locks can be switched due to a typo, etc. Having a dedicated language construct for this common case makes it easier to read and write while making code shorter and clearer.<br>&gt;&gt;  <br>&gt;&gt; # Language Survey<br>&gt;&gt;  <br>&gt;&gt; At least three major languages have widely used statements for this use case.<br>&gt;&gt;  <br>&gt;&gt; ## C#<br>&gt;&gt;  <br>&gt;&gt; C# has the `using` statement and the associated `IDisposable` interface.<br>&gt;&gt;  <br>&gt;&gt; ```csharp<br>&gt;&gt; using (StreamReader sr = new StreamReader(filename)) {<br>&gt;&gt;     txt = sr.ReadToEnd();<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt;  <br>&gt;&gt; C#&#39;s solution only handles close/exit actions via the `IDisposable.Dispose()` method and so cannot easily be used with items such as locks; however, C# has the additional `lock` statement for that use case.<br>&gt;&gt;  <br>&gt;&gt; ## Java<br>&gt;&gt;  <br>&gt;&gt; Java has try-with-resources and the associated `AutoCloseable` interface.<br>&gt;&gt;  <br>&gt;&gt; ```java<br>&gt;&gt; try (BufferedReader br = new BufferedReader(new FileReader(path))) {<br>&gt;&gt;     return br.readLine();<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt;  <br>&gt;&gt; Java&#39;s solution only handles close/exit actions via the `AutoCloseable.close()` method and so cannot easily be used with items such as locks; however, Java has the additional `synchronized` statement for that use case.<br>&gt;&gt;  <br>&gt;&gt; ## Python<br>&gt;&gt;  <br>&gt;&gt; Python has with `with` statement and the associated `__enter__` and `__exit__` special methods that classes may implement to become a &quot;context manager&quot;.<br>&gt;&gt;  <br>&gt;&gt; ```python<br>&gt;&gt; with lock, open(path) as my_file:<br>&gt;&gt;     contents = my_file.read()<br>&gt;&gt;     # use contents<br>&gt;&gt; ```<br>&gt;&gt;  <br>&gt;&gt; Python&#39;s solution handles both enter and exit actions and so this one construct is usable for locks as well as resources like sockets and files.<br>&gt;&gt;  <br>&gt;&gt; # Proposed Solution<br>&gt;&gt;  <br>&gt;&gt; We add a new protocol called `Scoped` to the standard library. Types for resources that have enter/exit actions will be extended to add conformance to this protocol.<br>&gt;&gt;  <br>&gt;&gt; The `do` statement will be extended to allow a new `using &lt;resources&gt;` &quot;suffix&quot;.<br>&gt;&gt;  <br>&gt;&gt; # Detailed Design<br>&gt;&gt;  <br>&gt;&gt; The `Scoped` protocol shall be as follows:<br>&gt;&gt;  <br>&gt;&gt; ```swift<br>&gt;&gt; public protocol Scoped {<br>&gt;&gt;     func enterScope()<br>&gt;&gt;     func exitScope()<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt;  <br>&gt;&gt; The compiler statement will accept a new form for resources. For example,<br>&gt;&gt;  <br>&gt;&gt; ```swift<br>&gt;&gt; do using lock, let file = try getFileHandle() {<br>&gt;&gt;     // statements<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt;  <br>&gt;&gt; As can be seen in the example above, the resources can be bindings that already exist (like `lock`) or can be new bindings. Bindings created with `do using` are not available outside of the scope of the `do using`. Only types conforming to `Scoped` may be using with `do using`. Use of non-conforming types will result in a compiler error.<br>&gt;&gt;  <br>&gt;&gt; The above example would be syntactic sugar for the following:<br>&gt;&gt;  <br>&gt;&gt; ```swift<br>&gt;&gt; do {<br>&gt;&gt;     lock.enterScope()<br>&gt;&gt;     defer { lock.exitScope() }<br>&gt;&gt;  <br>&gt;&gt;     let file = try getFileHandle()<br>&gt;&gt;     file.enterScope()<br>&gt;&gt;     defer { file.exitScope() }<br>&gt;&gt;  <br>&gt;&gt;     // statements<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt;  <br>&gt;&gt; # Framework Changes / Examples<br>&gt;&gt;  <br>&gt;&gt; As an example of some real-world classes that would be useful with `Scoped`, from Foundation:<br>&gt;&gt;  <br>&gt;&gt; ```swift<br>&gt;&gt; // Would be nice to extend the NSLocking protocol instead, but that&#39;s not supported yet.<br>&gt;&gt; extension NSLock: Scoped {<br>&gt;&gt;     func enterScope() {<br>&gt;&gt;         self.lock()<br>&gt;&gt;     }<br>&gt;&gt;  <br>&gt;&gt;     func exitScope() {<br>&gt;&gt;         self.unlock()<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;  <br>&gt;&gt; extension NSFileHandle: Scoped {<br>&gt;&gt;     func enterScope() {}<br>&gt;&gt;  <br>&gt;&gt;     func exitScope() {<br>&gt;&gt;         self.closeFile()<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt;  <br>&gt;&gt; # Questions and Concerns<br>&gt;&gt;  * Bikeshedding protocol naming and scoping syntax<br>&gt;&gt;  * Should the enter and exit actions be allowed to throw errors?<br>&gt;&gt;  <br>&gt;&gt; -- <br>&gt;&gt; Trent Nadeau<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;  <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/9b3d7af8/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Scoped resources (like C# using statement)</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 30, 2015 at 08:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Dec 29, 2015, at 10:55 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; An alternative solution is to do what Rust and C++ do, which is to use RAII. Which is to say, instead of introducing a new language construct that&#39;s explicitly tied to a scope, you just use a struct to represent the resource that you hold (e.g. a File that represents an open file). Of course, this does require some changes to structs, notably the addition of a deinit. And if structs have a deinit, then they also need to have a way to restrict copies. This is precisely what Rust does; any struct in Rust that implements Drop (the equivalent to deinit) loses the ability to be implicitly copied (a second trait called Clone provides a .clone() method that is the normal way to copy such non-implicitly-copyable structs).<br>&gt;  <br>&gt; This solution is elegant for a few reasons:<br>&gt;  <br>&gt; 1. Once you allow deinit on structs (which is useful) and deal with the fact that structs are no longer implicitly copyable (because almost all deinit functions on structs won&#39;t work right if they&#39;re called twice, such as on two copies), then RAII just sort of falls out of all of this and doesn&#39;t require any specific language features.<br>&gt; 2. It&#39;s more flexible, because you can actually return the RAII value from a scope in order to extend its lifetime.<br>&gt; 3. The RAII value itself provides the means to access the resource it&#39;s protecting; e.g. a Lock might return a LockGuard RAII value from the .lock() method, and LockGuard provides the means to access the protected value (as opposed to just having the lock sitting next to the value, which makes it trivially easy to accidentally access the value without holding the lock).<br>&gt; 4. In Rust, this pattern also integrates extremely well with Rust&#39;s lifetime system (the system that prevents data races / memory corruption at compile time), because e.g. a LockGuard contains the lifetime of the Lock, which prevents you at compile-time from attempting to lock the Lock while you already have it locked (though it doesn&#39;t prevent deadlocks where you and another thread try and lock two locks in opposite orders, but there is plenty of stuff it does catch).<br>&gt;  <br>&gt; The biggest problem with adding deinit to structs in Swift right now is the fact that we don&#39;t have references, which means you can&#39;t take a RAII struct and pass it to another function without losing it. Heck, you can&#39;t even call a method on it, because `self` on non-mutating methods in Swift is a value and not a reference (although we could hand-wave that away and make `self` in non-mutating RAII methods actually be an &quot;in&quot; reference internally, but this kind of hand-waving doesn&#39;t work when passing the struct as an argument to another function). So we&#39;d actually have to introduce a special &quot;in&quot; reference, which would be like &quot;inout&quot; except it doesn&#39;t actually copy it out (and is guaranteed to actually pass a pointer, although this pointer may be a pointer to a temporary). Except even that fails if you want to have a computed property that returns an existing RAII value (for example, having an Array of these things; barring optimizations, the subscript getter returns a computed value). And you can&#39;t generalize such &quot;in&quot; references beyond function arguments without basically providing raw C pointers. Rust&#39;s lifetime system lets them do it safely, but barring such a system, Swift can&#39;t really do this (I assume it&#39;s obvious why we don&#39;t want to start using raw C pointers everywhere).<br>&gt;  <br>&gt; All that said, I think this is a problem Swift needs to solve, because having non-copyable structs would be very useful. In particular, I _really_ want some way to do atomics in Swift, but the only safe way I can think of to do it requires non-copyable structs (because it&#39;s not correct to do a nonatomic read (such as a memcpy) of an atomic that&#39;s visible to other threads). I suppose you could provide a way to override how struct copies work (e.g. so you could do an atomic read of the old value), but it&#39;s rather problematic to break the assumption that struct copies are cheap.<br>&gt;  <br>&gt; Of course, you could model RAII with classes instead of structs, that just has the overhead of heap allocation (+ atomic reference counting) for every RAII value.<br></p><p>+1 to using RAII for this.  <br></p><p>I want to see all of the enhancements you describe that would enable structs to be used.<br></p><p>The situation for classes isn&#39;t necessarily quite as dire you make it sound.  In some cases the optimizer will perform stack promotion.  There was a brief discussion about this a few days ago.  I don&#39;t recall which thread.  <br></p><p>There is one challenge with using classes however.  ARC does not guarantee an instance will stay alive until the end of the scope.  Depending on the use case you may need this guarantee.<br></p><p>So in the end, improved language support for RAII one way or another is very desirable.  I don&#39;t expect to see major improvements in this area sin Swift 3, but maybe there are some smaller improvements that can be made.<br></p><p>&gt;  <br>&gt; -Kevin Ballard<br>&gt;  <br>&gt;&gt; On Tue, Dec 29, 2015, at 08:02 PM, Trent Nadeau via swift-evolution wrote:<br>&gt;&gt; # Introduction<br>&gt;&gt;  <br>&gt;&gt; Add a new `Scoped` protocol and enhance the do statement to automatically call enter/exit actions on resources.<br>&gt;&gt;  <br>&gt;&gt; # Motivation<br>&gt;&gt;  <br>&gt;&gt; Resources (e.g., locks, files, sockets, etc.) often need to be scoped to a block, where some action is taken at the start of the block and another is required at the end. Examples include locking and unlocking a lock in a critical section or closing a file at the end of a block.<br>&gt;&gt;  <br>&gt;&gt; Doing this manually is possible using `defer` statements among other options, but this is error prone as a `defer` can be forgotten, `lock`/`unlock` calls for two locks can be switched due to a typo, etc. Having a dedicated language construct for this common case makes it easier to read and write while making code shorter and clearer.<br>&gt;&gt;  <br>&gt;&gt; # Language Survey<br>&gt;&gt;  <br>&gt;&gt; At least three major languages have widely used statements for this use case.<br>&gt;&gt;  <br>&gt;&gt; ## C#<br>&gt;&gt;  <br>&gt;&gt; C# has the `using` statement and the associated `IDisposable` interface.<br>&gt;&gt;  <br>&gt;&gt; ```csharp<br>&gt;&gt; using (StreamReader sr = new StreamReader(filename)) {<br>&gt;&gt;     txt = sr.ReadToEnd();<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt;  <br>&gt;&gt; C#&#39;s solution only handles close/exit actions via the `IDisposable.Dispose()` method and so cannot easily be used with items such as locks; however, C# has the additional `lock` statement for that use case.<br>&gt;&gt;  <br>&gt;&gt; ## Java<br>&gt;&gt;  <br>&gt;&gt; Java has try-with-resources and the associated `AutoCloseable` interface.<br>&gt;&gt;  <br>&gt;&gt; ```java<br>&gt;&gt; try (BufferedReader br = new BufferedReader(new FileReader(path))) {<br>&gt;&gt;     return br.readLine();<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt;  <br>&gt;&gt; Java&#39;s solution only handles close/exit actions via the `AutoCloseable.close()` method and so cannot easily be used with items such as locks; however, Java has the additional `synchronized` statement for that use case.<br>&gt;&gt;  <br>&gt;&gt; ## Python<br>&gt;&gt;  <br>&gt;&gt; Python has with `with` statement and the associated `__enter__` and `__exit__` special methods that classes may implement to become a &quot;context manager&quot;.<br>&gt;&gt;  <br>&gt;&gt; ```python<br>&gt;&gt; with lock, open(path) as my_file:<br>&gt;&gt;     contents = my_file.read()<br>&gt;&gt;     # use contents<br>&gt;&gt; ```<br>&gt;&gt;  <br>&gt;&gt; Python&#39;s solution handles both enter and exit actions and so this one construct is usable for locks as well as resources like sockets and files.<br>&gt;&gt;  <br>&gt;&gt; # Proposed Solution<br>&gt;&gt;  <br>&gt;&gt; We add a new protocol called `Scoped` to the standard library. Types for resources that have enter/exit actions will be extended to add conformance to this protocol.<br>&gt;&gt;  <br>&gt;&gt; The `do` statement will be extended to allow a new `using &lt;resources&gt;` &quot;suffix&quot;.<br>&gt;&gt;  <br>&gt;&gt; # Detailed Design<br>&gt;&gt;  <br>&gt;&gt; The `Scoped` protocol shall be as follows:<br>&gt;&gt;  <br>&gt;&gt; ```swift<br>&gt;&gt; public protocol Scoped {<br>&gt;&gt;     func enterScope()<br>&gt;&gt;     func exitScope()<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt;  <br>&gt;&gt; The compiler statement will accept a new form for resources. For example,<br>&gt;&gt;  <br>&gt;&gt; ```swift<br>&gt;&gt; do using lock, let file = try getFileHandle() {<br>&gt;&gt;     // statements<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt;  <br>&gt;&gt; As can be seen in the example above, the resources can be bindings that already exist (like `lock`) or can be new bindings. Bindings created with `do using` are not available outside of the scope of the `do using`. Only types conforming to `Scoped` may be using with `do using`. Use of non-conforming types will result in a compiler error.<br>&gt;&gt;  <br>&gt;&gt; The above example would be syntactic sugar for the following:<br>&gt;&gt;  <br>&gt;&gt; ```swift<br>&gt;&gt; do {<br>&gt;&gt;     lock.enterScope()<br>&gt;&gt;     defer { lock.exitScope() }<br>&gt;&gt;  <br>&gt;&gt;     let file = try getFileHandle()<br>&gt;&gt;     file.enterScope()<br>&gt;&gt;     defer { file.exitScope() }<br>&gt;&gt;  <br>&gt;&gt;     // statements<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt;  <br>&gt;&gt; # Framework Changes / Examples<br>&gt;&gt;  <br>&gt;&gt; As an example of some real-world classes that would be useful with `Scoped`, from Foundation:<br>&gt;&gt;  <br>&gt;&gt; ```swift<br>&gt;&gt; // Would be nice to extend the NSLocking protocol instead, but that&#39;s not supported yet.<br>&gt;&gt; extension NSLock: Scoped {<br>&gt;&gt;     func enterScope() {<br>&gt;&gt;         self.lock()<br>&gt;&gt;     }<br>&gt;&gt;  <br>&gt;&gt;     func exitScope() {<br>&gt;&gt;         self.unlock()<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;  <br>&gt;&gt; extension NSFileHandle: Scoped {<br>&gt;&gt;     func enterScope() {}<br>&gt;&gt;  <br>&gt;&gt;     func exitScope() {<br>&gt;&gt;         self.closeFile()<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt;  <br>&gt;&gt; # Questions and Concerns<br>&gt;&gt;  * Bikeshedding protocol naming and scoping syntax<br>&gt;&gt;  * Should the enter and exit actions be allowed to throw errors?<br>&gt;&gt;  <br>&gt;&gt; -- <br>&gt;&gt; Trent Nadeau<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;  <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/9e658308/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Scoped resources (like C# using statement)</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 30, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 29, 2015, at 8:55 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; An alternative solution is to do what Rust and C++ do, which is to use RAII. Which is to say, instead of introducing a new language construct that&#39;s explicitly tied to a scope, you just use a struct to represent the resource that you hold (e.g. a File that represents an open file). Of course, this does require some changes to structs, notably the addition of a deinit. And if structs have a deinit, then they also need to have a way to restrict copies. This is precisely what Rust does; any struct in Rust that implements Drop (the equivalent to deinit) loses the ability to be implicitly copied (a second trait called Clone provides a .clone() method that is the normal way to copy such non-implicitly-copyable structs).<br></p><p>deinit doesn&#39;t make sense for value types. Classes already support deinit, and you can use withExtendedLifetime to bound the lifetime of a resource-holding class. It would be reasonable to have a scoped lifetime marker similar to ObjC ARC too.<br></p><p>-Joe<br></p><p>&gt; This solution is elegant for a few reasons:<br>&gt;  <br>&gt; 1. Once you allow deinit on structs (which is useful) and deal with the fact that structs are no longer implicitly copyable (because almost all deinit functions on structs won&#39;t work right if they&#39;re called twice, such as on two copies), then RAII just sort of falls out of all of this and doesn&#39;t require any specific language features.<br>&gt; 2. It&#39;s more flexible, because you can actually return the RAII value from a scope in order to extend its lifetime.<br>&gt; 3. The RAII value itself provides the means to access the resource it&#39;s protecting; e.g. a Lock might return a LockGuard RAII value from the .lock() method, and LockGuard provides the means to access the protected value (as opposed to just having the lock sitting next to the value, which makes it trivially easy to accidentally access the value without holding the lock).<br>&gt; 4. In Rust, this pattern also integrates extremely well with Rust&#39;s lifetime system (the system that prevents data races / memory corruption at compile time), because e.g. a LockGuard contains the lifetime of the Lock, which prevents you at compile-time from attempting to lock the Lock while you already have it locked (though it doesn&#39;t prevent deadlocks where you and another thread try and lock two locks in opposite orders, but there is plenty of stuff it does catch).<br>&gt;  <br>&gt; The biggest problem with adding deinit to structs in Swift right now is the fact that we don&#39;t have references, which means you can&#39;t take a RAII struct and pass it to another function without losing it. Heck, you can&#39;t even call a method on it, because `self` on non-mutating methods in Swift is a value and not a reference (although we could hand-wave that away and make `self` in non-mutating RAII methods actually be an &quot;in&quot; reference internally, but this kind of hand-waving doesn&#39;t work when passing the struct as an argument to another function). So we&#39;d actually have to introduce a special &quot;in&quot; reference, which would be like &quot;inout&quot; except it doesn&#39;t actually copy it out (and is guaranteed to actually pass a pointer, although this pointer may be a pointer to a temporary). Except even that fails if you want to have a computed property that returns an existing RAII value (for example, having an Array of these things; barring optimizations, the subscript getter returns a computed value). And you can&#39;t generalize such &quot;in&quot; references beyond function arguments without basically providing raw C pointers. Rust&#39;s lifetime system lets them do it safely, but barring such a system, Swift can&#39;t really do this (I assume it&#39;s obvious why we don&#39;t want to start using raw C pointers everywhere).<br>&gt;  <br>&gt; All that said, I think this is a problem Swift needs to solve, because having non-copyable structs would be very useful. In particular, I _really_ want some way to do atomics in Swift, but the only safe way I can think of to do it requires non-copyable structs (because it&#39;s not correct to do a nonatomic read (such as a memcpy) of an atomic that&#39;s visible to other threads). I suppose you could provide a way to override how struct copies work (e.g. so you could do an atomic read of the old value), but it&#39;s rather problematic to break the assumption that struct copies are cheap.<br>&gt;  <br>&gt; Of course, you could model RAII with classes instead of structs, that just has the overhead of heap allocation (+ atomic reference counting) for every RAII value.<br>&gt;  <br>&gt; -Kevin Ballard<br>&gt;  <br>&gt; On Tue, Dec 29, 2015, at 08:02 PM, Trent Nadeau via swift-evolution wrote:<br>&gt;&gt; # Introduction<br>&gt;&gt;  <br>&gt;&gt; Add a new `Scoped` protocol and enhance the do statement to automatically call enter/exit actions on resources.<br>&gt;&gt;  <br>&gt;&gt; # Motivation<br>&gt;&gt;  <br>&gt;&gt; Resources (e.g., locks, files, sockets, etc.) often need to be scoped to a block, where some action is taken at the start of the block and another is required at the end. Examples include locking and unlocking a lock in a critical section or closing a file at the end of a block.<br>&gt;&gt;  <br>&gt;&gt; Doing this manually is possible using `defer` statements among other options, but this is error prone as a `defer` can be forgotten, `lock`/`unlock` calls for two locks can be switched due to a typo, etc. Having a dedicated language construct for this common case makes it easier to read and write while making code shorter and clearer.<br>&gt;&gt;  <br>&gt;&gt; # Language Survey<br>&gt;&gt;  <br>&gt;&gt; At least three major languages have widely used statements for this use case.<br>&gt;&gt;  <br>&gt;&gt; ## C#<br>&gt;&gt;  <br>&gt;&gt; C# has the `using` statement and the associated `IDisposable` interface.<br>&gt;&gt;  <br>&gt;&gt; ```csharp<br>&gt;&gt; using (StreamReader sr = new StreamReader(filename)) {<br>&gt;&gt;     txt = sr.ReadToEnd();<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt;  <br>&gt;&gt; C#&#39;s solution only handles close/exit actions via the `IDisposable.Dispose()` method and so cannot easily be used with items such as locks; however, C# has the additional `lock` statement for that use case.<br>&gt;&gt;  <br>&gt;&gt; ## Java<br>&gt;&gt;  <br>&gt;&gt; Java has try-with-resources and the associated `AutoCloseable` interface.<br>&gt;&gt;  <br>&gt;&gt; ```java<br>&gt;&gt; try (BufferedReader br = new BufferedReader(new FileReader(path))) {<br>&gt;&gt;     return br.readLine();<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt;  <br>&gt;&gt; Java&#39;s solution only handles close/exit actions via the `AutoCloseable.close()` method and so cannot easily be used with items such as locks; however, Java has the additional `synchronized` statement for that use case.<br>&gt;&gt;  <br>&gt;&gt; ## Python<br>&gt;&gt;  <br>&gt;&gt; Python has with `with` statement and the associated `__enter__` and `__exit__` special methods that classes may implement to become a &quot;context manager&quot;.<br>&gt;&gt;  <br>&gt;&gt; ```python<br>&gt;&gt; with lock, open(path) as my_file:<br>&gt;&gt;     contents = my_file.read()<br>&gt;&gt;     # use contents<br>&gt;&gt; ```<br>&gt;&gt;  <br>&gt;&gt; Python&#39;s solution handles both enter and exit actions and so this one construct is usable for locks as well as resources like sockets and files.<br>&gt;&gt;  <br>&gt;&gt; # Proposed Solution<br>&gt;&gt;  <br>&gt;&gt; We add a new protocol called `Scoped` to the standard library. Types for resources that have enter/exit actions will be extended to add conformance to this protocol.<br>&gt;&gt;  <br>&gt;&gt; The `do` statement will be extended to allow a new `using &lt;resources&gt;` &quot;suffix&quot;.<br>&gt;&gt;  <br>&gt;&gt; # Detailed Design<br>&gt;&gt;  <br>&gt;&gt; The `Scoped` protocol shall be as follows:<br>&gt;&gt;  <br>&gt;&gt; ```swift<br>&gt;&gt; public protocol Scoped {<br>&gt;&gt;     func enterScope()<br>&gt;&gt;     func exitScope()<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt;  <br>&gt;&gt; The compiler statement will accept a new form for resources. For example,<br>&gt;&gt;  <br>&gt;&gt; ```swift<br>&gt;&gt; do using lock, let file = try getFileHandle() {<br>&gt;&gt;     // statements<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt;  <br>&gt;&gt; As can be seen in the example above, the resources can be bindings that already exist (like `lock`) or can be new bindings. Bindings created with `do using` are not available outside of the scope of the `do using`. Only types conforming to `Scoped` may be using with `do using`. Use of non-conforming types will result in a compiler error.<br>&gt;&gt;  <br>&gt;&gt; The above example would be syntactic sugar for the following:<br>&gt;&gt;  <br>&gt;&gt; ```swift<br>&gt;&gt; do {<br>&gt;&gt;     lock.enterScope()<br>&gt;&gt;     defer { lock.exitScope() }<br>&gt;&gt;  <br>&gt;&gt;     let file = try getFileHandle()<br>&gt;&gt;     file.enterScope()<br>&gt;&gt;     defer { file.exitScope() }<br>&gt;&gt;  <br>&gt;&gt;     // statements<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt;  <br>&gt;&gt; # Framework Changes / Examples<br>&gt;&gt;  <br>&gt;&gt; As an example of some real-world classes that would be useful with `Scoped`, from Foundation:<br>&gt;&gt;  <br>&gt;&gt; ```swift<br>&gt;&gt; // Would be nice to extend the NSLocking protocol instead, but that&#39;s not supported yet.<br>&gt;&gt; extension NSLock: Scoped {<br>&gt;&gt;     func enterScope() {<br>&gt;&gt;         self.lock()<br>&gt;&gt;     }<br>&gt;&gt;  <br>&gt;&gt;     func exitScope() {<br>&gt;&gt;         self.unlock()<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;  <br>&gt;&gt; extension NSFileHandle: Scoped {<br>&gt;&gt;     func enterScope() {}<br>&gt;&gt;  <br>&gt;&gt;     func exitScope() {<br>&gt;&gt;         self.closeFile()<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt;  <br>&gt;&gt; # Questions and Concerns<br>&gt;&gt;  * Bikeshedding protocol naming and scoping syntax<br>&gt;&gt;  * Should the enter and exit actions be allowed to throw errors?<br>&gt;&gt;  <br>&gt;&gt; -- <br>&gt;&gt; Trent Nadeau<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/f619ea4c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal] Scoped resources (like C# using statement)</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 30, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 30, 2015, at 9:53 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 29, 2015, at 8:55 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; An alternative solution is to do what Rust and C++ do, which is to use RAII. Which is to say, instead of introducing a new language construct that&#39;s explicitly tied to a scope, you just use a struct to represent the resource that you hold (e.g. a File that represents an open file). Of course, this does require some changes to structs, notably the addition of a deinit. And if structs have a deinit, then they also need to have a way to restrict copies. This is precisely what Rust does; any struct in Rust that implements Drop (the equivalent to deinit) loses the ability to be implicitly copied (a second trait called Clone provides a .clone() method that is the normal way to copy such non-implicitly-copyable structs).<br>&gt; <br>&gt; deinit doesn&#39;t make sense for value types. <br></p><p>It would if we extended the model for value types to be richer, e.g. to introduce the notion of &quot;move only” structs.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/523deea9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Scoped resources (like C# using statement)</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 30, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 30, 2015, at 10:26 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 30, 2015, at 9:53 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 29, 2015, at 8:55 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; An alternative solution is to do what Rust and C++ do, which is to use RAII. Which is to say, instead of introducing a new language construct that&#39;s explicitly tied to a scope, you just use a struct to represent the resource that you hold (e.g. a File that represents an open file). Of course, this does require some changes to structs, notably the addition of a deinit. And if structs have a deinit, then they also need to have a way to restrict copies. This is precisely what Rust does; any struct in Rust that implements Drop (the equivalent to deinit) loses the ability to be implicitly copied (a second trait called Clone provides a .clone() method that is the normal way to copy such non-implicitly-copyable structs).<br>&gt;&gt; <br>&gt;&gt; deinit doesn&#39;t make sense for value types. <br>&gt; <br>&gt; It would if we extended the model for value types to be richer, e.g. to introduce the notion of &quot;move only” structs.<br></p><p>Perhaps, but I feel like it&#39;s a more natural extension of our existing model to support uniquely-owned classes though, which would give you all the same benefits.<br></p><p>-Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/17a56269/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[Proposal] Scoped resources (like C# using statement)</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>December 30, 2015 at 11:00:00am</p></header><div class="content"><p>+1 to Joe’s comment.<br></p><p>&gt; On Dec 30, 2015, at 10:31 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 30, 2015, at 10:26 AM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 30, 2015, at 9:53 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 29, 2015, at 8:55 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; An alternative solution is to do what Rust and C++ do, which is to use RAII. Which is to say, instead of introducing a new language construct that&#39;s explicitly tied to a scope, you just use a struct to represent the resource that you hold (e.g. a File that represents an open file). Of course, this does require some changes to structs, notably the addition of a deinit. And if structs have a deinit, then they also need to have a way to restrict copies. This is precisely what Rust does; any struct in Rust that implements Drop (the equivalent to deinit) loses the ability to be implicitly copied (a second trait called Clone provides a .clone() method that is the normal way to copy such non-implicitly-copyable structs).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; deinit doesn&#39;t make sense for value types. <br>&gt;&gt; <br>&gt;&gt; It would if we extended the model for value types to be richer, e.g. to introduce the notion of &quot;move only” structs.<br>&gt; <br>&gt; Perhaps, but I feel like it&#39;s a more natural extension of our existing model to support uniquely-owned classes though, which would give you all the same benefits.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/c1687c7c/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal] Scoped resources (like C# using statement)</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 30, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 30, 2015, at 10:31 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 30, 2015, at 10:26 AM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 30, 2015, at 9:53 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 29, 2015, at 8:55 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; An alternative solution is to do what Rust and C++ do, which is to use RAII. Which is to say, instead of introducing a new language construct that&#39;s explicitly tied to a scope, you just use a struct to represent the resource that you hold (e.g. a File that represents an open file). Of course, this does require some changes to structs, notably the addition of a deinit. And if structs have a deinit, then they also need to have a way to restrict copies. This is precisely what Rust does; any struct in Rust that implements Drop (the equivalent to deinit) loses the ability to be implicitly copied (a second trait called Clone provides a .clone() method that is the normal way to copy such non-implicitly-copyable structs).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; deinit doesn&#39;t make sense for value types. <br>&gt;&gt; <br>&gt;&gt; It would if we extended the model for value types to be richer, e.g. to introduce the notion of &quot;move only” structs.<br>&gt; <br>&gt; Perhaps, but I feel like it&#39;s a more natural extension of our existing model to support uniquely-owned classes though, which would give you all the same benefits.<br></p><p>So long as it guarantees no heap allocation for the class instance, ok.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/6cfcc6c2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Proposal] Scoped resources (like C# using statement)</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 30, 2015 at 01:00:00pm</p></header><div class="content"><p>A uniquely-owned class that guarantees stack allocation is pretty much<br>the same thing as a move-only value type, isn&#39;t it? The only real<br>difference I can think of is classes allow for subclassing.<br></p><p>-Kevin<br></p><p>On Wed, Dec 30, 2015, at 01:18 PM, Chris Lattner wrote:<br>&gt;<br>&gt;&gt; On Dec 30, 2015, at 10:31 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Dec 30, 2015, at 10:26 AM, Chris Lattner &lt;clattner at apple.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Dec 30, 2015, at 9:53 AM, Joe Groff via swift-evolution &lt;swift-<br>&gt;&gt;&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Dec 29, 2015, at 8:55 PM, Kevin Ballard via swift-evolution &lt;swift-<br>&gt;&gt;&gt;&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; An alternative solution is to do what Rust and C++ do, which is to<br>&gt;&gt;&gt;&gt;&gt; use RAII. Which is to say, instead of introducing a new language<br>&gt;&gt;&gt;&gt;&gt; construct that&#39;s explicitly tied to a scope, you just use a struct<br>&gt;&gt;&gt;&gt;&gt; to represent the resource that you hold (e.g. a File that<br>&gt;&gt;&gt;&gt;&gt; represents an open file). Of course, this does require some<br>&gt;&gt;&gt;&gt;&gt; changes to structs, notably the addition of a deinit. And if<br>&gt;&gt;&gt;&gt;&gt; structs have a deinit, then they also need to have a way to<br>&gt;&gt;&gt;&gt;&gt; restrict copies. This is precisely what Rust does; any struct in<br>&gt;&gt;&gt;&gt;&gt; Rust that implements Drop (the equivalent to deinit) loses the<br>&gt;&gt;&gt;&gt;&gt; ability to be implicitly copied (a second trait called Clone<br>&gt;&gt;&gt;&gt;&gt; provides a .clone() method that is the normal way to copy such non-implicitly-<br>&gt;&gt;&gt;&gt;&gt; copyable structs).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; deinit doesn&#39;t make sense for value types.<br>&gt;&gt;&gt; It would if we extended the model for value types to be richer, e.g.<br>&gt;&gt;&gt; to introduce the notion of &quot;move only” structs.<br>&gt;&gt; Perhaps, but I feel like it&#39;s a more natural extension of our<br>&gt;&gt; existing model to support uniquely-owned classes though, which would<br>&gt;&gt; give you all the same benefits.<br>&gt; So long as it guarantees no heap allocation for the class<br>&gt; instance, ok.<br>&gt;<br>&gt; -Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/5998e1c6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal] Scoped resources (like C# using statement)</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 31, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; On Dec 30, 2015, at 1:22 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; <br>&gt; A uniquely-owned class that guarantees stack allocation is pretty much the same thing as a move-only value type, isn&#39;t it? The only real difference I can think of is classes allow for subclassing.<br></p><p>At this point, we’re talking about two unspecified and hypothetical models, so of course they’re both equivalent and completely different :-)<br></p><p>We should talk about this in more detail later (perhaps next year, perhaps the year after), but I am pretty concerned with saying that unique ownership of classes replaces move-only types.  From a programming model perspective (how the programmer thinks about &amp; designs their code) both capabilities are important.  You want move-only struct types in various cases and unique ownership of class instances.<br></p><p>For example, IMO, a uniquely-owned class instance has to be on the heap, because it would have to convert to a multiply owned reference in many cases, and “moving” a class from the stack to the heap is, uh, complicated.<br></p><p>-Chris<br></p><p><br></p><p>&gt;  <br>&gt; -Kevin<br>&gt;  <br>&gt; On Wed, Dec 30, 2015, at 01:18 PM, Chris Lattner wrote:<br>&gt;&gt;  <br>&gt;&gt;&gt; On Dec 30, 2015, at 10:31 AM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; On Dec 30, 2015, at 10:26 AM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; On Dec 30, 2015, at 9:53 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 29, 2015, at 8:55 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; An alternative solution is to do what Rust and C++ do, which is to use RAII. Which is to say, instead of introducing a new language construct that&#39;s explicitly tied to a scope, you just use a struct to represent the resource that you hold (e.g. a File that represents an open file). Of course, this does require some changes to structs, notably the addition of a deinit. And if structs have a deinit, then they also need to have a way to restrict copies. This is precisely what Rust does; any struct in Rust that implements Drop (the equivalent to deinit) loses the ability to be implicitly copied (a second trait called Clone provides a .clone() method that is the normal way to copy such non-implicitly-copyable structs).<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; deinit doesn&#39;t make sense for value types. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It would if we extended the model for value types to be richer, e.g. to introduce the notion of &quot;move only” structs.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Perhaps, but I feel like it&#39;s a more natural extension of our existing model to support uniquely-owned classes though, which would give you all the same benefits.<br>&gt;&gt; <br>&gt;&gt; So long as it guarantees no heap allocation for the class instance, ok.<br>&gt;&gt;  <br>&gt;&gt; -Chris<br>&gt;  <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/2085930d/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Proposal] Scoped resources (like C# using statement)</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 30, 2015 at 01:00:00pm</p></header><div class="content"><p>On Wed, Dec 30, 2015, at 09:53 AM, Joe Groff wrote:<br>&gt;<br>&gt;&gt; On Dec 29, 2015, at 8:55 PM, Kevin Ballard via swift-evolution &lt;swift-<br>&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; An alternative solution is to do what Rust and C++ do, which is to<br>&gt;&gt; use RAII. Which is to say, instead of introducing a new language<br>&gt;&gt; construct that&#39;s explicitly tied to a scope, you just use a struct to<br>&gt;&gt; represent the resource that you hold (e.g. a File that represents an<br>&gt;&gt; open file). Of course, this does require some changes to structs,<br>&gt;&gt; notably the addition of a deinit. And if structs have a deinit, then<br>&gt;&gt; they also need to have a way to restrict copies. This is precisely<br>&gt;&gt; what Rust does; any struct in Rust that implements Drop (the<br>&gt;&gt; equivalent to deinit) loses the ability to be implicitly copied (a<br>&gt;&gt; second trait called Clone provides a .clone() method that is the<br>&gt;&gt; normal way to copy such non-implicitly-copyable structs).<br>&gt;<br>&gt; deinit doesn&#39;t make sense for value types. Classes already support<br>&gt; deinit, and you can use withExtendedLifetime to bound the lifetime of<br>&gt; a resource-holding class. It would be reasonable to have a scoped<br>&gt; lifetime marker similar to ObjC ARC too.<br></p><p>If you run with the idea that any resource-holding class should also be<br>the mechanism by which you access the resource (e.g. a LockGuard that<br>represents holding the lock and also provides access to the guarded<br>value) then there&#39;s no need for extended lifetimes, because as long as<br>you&#39;re accessing the resource, you&#39;re keeping the resource-holding class<br>alive. I suppose there might be rare cases where you need to extend the<br>lifetime of a resource-holding class even when you&#39;re not accessing the<br>resource, just to guarantee e.g. order of resource releasing, but you<br>can always just say something like `withExtendedLifeetime(&amp;val) {}` at<br>the end of the scope to ensure the value is still alive at that point.<br>Although I&#39;d really like to define `_ = val` as guaranteeing that the<br>value is alive at that point (the expression doesn&#39;t actually do<br>anything, but because it references `val` it expresses the programmer&#39;s<br>intent that `val` should still be alive at that point in time).<br>Alternatively, if we end up with move-only structs (or uniquely-owned<br>classes), we could even define the expression `_ = val` as &quot;dropping&quot;<br>the value , i.e. forcing it to deinit at that spot (because it&#39;s moving<br>the value out of the `val` variable). This would be analogous to Rust&#39;s<br>`std::mem::drop()` function (which is literally defined as `pub fn<br>drop&lt;T&gt;(_x: T) { }` because all it does is move the value into the<br>function and then forget about it).<br></p><p>-Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/c2dabdbe/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Scoped resources (like C# using statement)</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 30, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 30, 2015, at 1:27 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; <br>&gt; On Wed, Dec 30, 2015, at 09:53 AM, Joe Groff wrote:<br>&gt;&gt;  <br>&gt;&gt;&gt; On Dec 29, 2015, at 8:55 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; An alternative solution is to do what Rust and C++ do, which is to use RAII. Which is to say, instead of introducing a new language construct that&#39;s explicitly tied to a scope, you just use a struct to represent the resource that you hold (e.g. a File that represents an open file). Of course, this does require some changes to structs, notably the addition of a deinit. And if structs have a deinit, then they also need to have a way to restrict copies. This is precisely what Rust does; any struct in Rust that implements Drop (the equivalent to deinit) loses the ability to be implicitly copied (a second trait called Clone provides a .clone() method that is the normal way to copy such non-implicitly-copyable structs).<br>&gt;&gt;  <br>&gt;&gt; deinit doesn&#39;t make sense for value types. Classes already support deinit, and you can use withExtendedLifetime to bound the lifetime of a resource-holding class. It would be reasonable to have a scoped lifetime marker similar to ObjC ARC too.<br>&gt;  <br>&gt; If you run with the idea that any resource-holding class should also be the mechanism by which you access the resource (e.g. a LockGuard that represents holding the lock and also provides access to the guarded value) then there&#39;s no need for extended lifetimes, because as long as you&#39;re accessing the resource, you&#39;re keeping the resource-holding class alive. I suppose there might be rare cases where you need to extend the lifetime of a resource-holding class even when you&#39;re not accessing the resource, just to guarantee e.g. order of resource releasing, but you can always just say something like `withExtendedLifeetime(&amp;val) {}` at the end of the scope to ensure the value is still alive at that point. Although I&#39;d really like to define `_ = val` as guaranteeing that the value is alive at that point (the expression doesn&#39;t actually do anything, but because it references `val` it expresses the programmer&#39;s intent that `val` should still be alive at that point in time). Alternatively, if we end up with move-only structs (or uniquely-owned classes), we could even define the expression `_ = val` as &quot;dropping&quot; the value , i.e. forcing it to deinit at that spot (because it&#39;s moving the value out of the `val` variable). This would be analogous to Rust&#39;s `std::mem::drop()` function (which is literally defined as `pub fn drop&lt;T&gt;(_x: T) { }` because all it does is move the value into the function and then forget about it).<br></p><p>Another possibility I&#39;ve thought of is defining `defer { val }` to guarantee that val remains alive until the defer fires on scope exit. That might let us leave `defer` as the one &quot;guarantee something happens exactly at scope exit&quot; language construct.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/585e7a5a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Proposal] Scoped resources (like C# using statement)</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 30, 2015 at 01:00:00pm</p></header><div class="content"><p>On Wed, Dec 30, 2015, at 01:33 PM, Joe Groff wrote:<br>&gt; Another possibility I&#39;ve thought of is defining `defer { val }` to<br>&gt; guarantee that val remains alive until the defer fires on scope exit.<br>&gt; That might let us leave `defer` as the one &quot;guarantee something<br>&gt; happens exactly at scope exit&quot; language construct.<br></p><p>Oh that&#39;s cute. I&#39;d probably want to say `defer { _ = val }` though, to<br>make it obvious that this is intentional.<br></p><p>-Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/7a20eea2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>[Proposal] Scoped resources (like C# using statement)</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>December 31, 2015 at 04:00:00pm</p></header><div class="content"><p>Le 30 déc. 2015 à 16:40, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; On Wed, Dec 30, 2015, at 01:33 PM, Joe Groff wrote:<br>&gt;&gt; Another possibility I&#39;ve thought of is defining `defer { val }` to guarantee that val remains alive until the defer fires on scope exit. That might let us leave `defer` as the one &quot;guarantee something happens exactly at scope exit&quot; language construct.<br>&gt;  <br>&gt; Oh that&#39;s cute. I&#39;d probably want to say `defer { _ = val }` though, to make it obvious that this is intentional.<br></p><p>Or you could make it even more obvious what this is by giving that feature a name. For instance:<br></p><p>	defer { _fixLifetime(val) }<br></p><p>The good thing about this one is that it already works, because that&#39;s what `withExtendedLifetime` does internally. Also, if you search a bit, you&#39;ll end up here with a nice explanation of what that function does.<br>https://github.com/apple/swift/blob/8d9ef80304d7b36e13619ea50e6e76f3ec9221ba/stdlib/public/core/LifetimeManager.swift#L45<br></p><p>So why not simply remove the underscore?<br></p><p>-- <br>Michel Fortin<br>https://michelf.ca<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Proposal] Scoped resources (like C# using statement)</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 31, 2015 at 04:00:00pm</p></header><div class="content"><p>On Thu, Dec 31, 2015, at 01:40 PM, Michel Fortin wrote:<br>&gt; Le 30 déc. 2015 à 16:40, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; &gt; On Wed, Dec 30, 2015, at 01:33 PM, Joe Groff wrote:<br>&gt; &gt;&gt; Another possibility I&#39;ve thought of is defining `defer { val }` to guarantee that val remains alive until the defer fires on scope exit. That might let us leave `defer` as the one &quot;guarantee something happens exactly at scope exit&quot; language construct.<br>&gt; &gt;  <br>&gt; &gt; Oh that&#39;s cute. I&#39;d probably want to say `defer { _ = val }` though, to make it obvious that this is intentional.<br>&gt; <br>&gt; Or you could make it even more obvious what this is by giving that feature a name. For instance:<br>&gt; <br>&gt; 	defer { _fixLifetime(val) }<br>&gt; <br>&gt; The good thing about this one is that it already works, because that&#39;s what `withExtendedLifetime` does internally. Also, if you search a bit, you&#39;ll end up here with a nice explanation of what that function does.<br>&gt; https://github.com/apple/swift/blob/8d9ef80304d7b36e13619ea50e6e76f3ec9221ba/stdlib/public/core/LifetimeManager.swift#L45<br>&gt; <br>&gt; So why not simply remove the underscore?<br></p><p>Because it&#39;s not a very good API? Having some magic function called `fixLifetime()` that keeps values alive is a little weird. `withExtendedLifetime()` is also slightly weird, but it makes more sense than fixLifetime() does, since withExtendedLifetime() is the specific solution to the problem of &quot;I need to ensure this value remains alive for this entire scope because reasons&quot;.<br></p><p>I&#39;d much rather just see the syntax `_ = val` be converted into `Builtin.fixLifetime(val)` because the only reason to write an expression like that is because you want to make sure the value is still alive at that point (that and because it&#39;s not unreasonable for people to assume that `_ = val` will keep the value alive, so it would be nice to make that assumption actually be correct).<br></p><p>-Kevin Ballard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Scoped resources (like C# using statement)</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 31, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; On Dec 31, 2015, at 4:26 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; <br>&gt; On Thu, Dec 31, 2015, at 01:40 PM, Michel Fortin wrote:<br>&gt;&gt; Le 30 déc. 2015 à 16:40, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt; On Wed, Dec 30, 2015, at 01:33 PM, Joe Groff wrote:<br>&gt;&gt;&gt;&gt; Another possibility I&#39;ve thought of is defining `defer { val }` to guarantee that val remains alive until the defer fires on scope exit. That might let us leave `defer` as the one &quot;guarantee something happens exactly at scope exit&quot; language construct.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Oh that&#39;s cute. I&#39;d probably want to say `defer { _ = val }` though, to make it obvious that this is intentional.<br>&gt;&gt; <br>&gt;&gt; Or you could make it even more obvious what this is by giving that feature a name. For instance:<br>&gt;&gt; <br>&gt;&gt; 	defer { _fixLifetime(val) }<br>&gt;&gt; <br>&gt;&gt; The good thing about this one is that it already works, because that&#39;s what `withExtendedLifetime` does internally. Also, if you search a bit, you&#39;ll end up here with a nice explanation of what that function does.<br>&gt;&gt; https://github.com/apple/swift/blob/8d9ef80304d7b36e13619ea50e6e76f3ec9221ba/stdlib/public/core/LifetimeManager.swift#L45<br>&gt;&gt; <br>&gt;&gt; So why not simply remove the underscore?<br>&gt; <br>&gt; Because it&#39;s not a very good API? Having some magic function called `fixLifetime()` that keeps values alive is a little weird. `withExtendedLifetime()` is also slightly weird, but it makes more sense than fixLifetime() does, since withExtendedLifetime() is the specific solution to the problem of &quot;I need to ensure this value remains alive for this entire scope because reasons&quot;.<br>&gt; <br>&gt; I&#39;d much rather just see the syntax `_ = val` be converted into `Builtin.fixLifetime(val)` because the only reason to write an expression like that is because you want to make sure the value is still alive at that point (that and because it&#39;s not unreasonable for people to assume that `_ = val` will keep the value alive, so it would be nice to make that assumption actually be correct).<br></p><p>I don&#39;t think this is obviously true. `val` could be a computed property you just want to force the side effects for. (Computed properties with side effects maybe aren&#39;t a great idea, but there are some in AppKit/UIKit.)<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/af1b9778/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Proposal] Scoped resources (like C# using statement)</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 31, 2015 at 04:00:00pm</p></header><div class="content"><p>On Thu, Dec 31, 2015, at 04:46 PM, Joe Groff wrote:<br>&gt;<br>&gt;&gt; On Dec 31, 2015, at 4:26 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Thu, Dec 31, 2015, at 01:40 PM, Michel Fortin wrote:<br>&gt;&gt;&gt; Le 30 déc. 2015 à 16:40, Kevin Ballard via swift-evolution &lt;swift-<br>&gt;&gt;&gt; evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt;&gt; On Wed, Dec 30, 2015, at 01:33 PM, Joe Groff wrote:<br>&gt;&gt;&gt;&gt;&gt; Another possibility I&#39;ve thought of is defining `defer { val }` to<br>&gt;&gt;&gt;&gt;&gt; guarantee that val remains alive until the defer fires on scope<br>&gt;&gt;&gt;&gt;&gt; exit. That might let us leave `defer` as the one &quot;guarantee<br>&gt;&gt;&gt;&gt;&gt; something happens exactly at scope exit&quot; language construct.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Oh that&#39;s cute. I&#39;d probably want to say `defer { _ = val }`<br>&gt;&gt;&gt;&gt; though, to make it obvious that this is intentional.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Or you could make it even more obvious what this is by giving that<br>&gt;&gt;&gt; feature a name. For instance:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; defer { _fixLifetime(val) }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The good thing about this one is that it already works, because<br>&gt;&gt;&gt; that&#39;s what `withExtendedLifetime` does internally. Also, if you<br>&gt;&gt;&gt; search a bit, you&#39;ll end up here with a nice explanation of what<br>&gt;&gt;&gt; that function does.<br>&gt;&gt;&gt; https://github.com/apple/swift/blob/8d9ef80304d7b36e13619ea50e6e76f3ec9221ba/stdlib/public/core/LifetimeManager.swift#L45<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; So why not simply remove the underscore?<br>&gt;&gt;<br>&gt;&gt; Because it&#39;s not a very good API? Having some magic function called<br>&gt;&gt; `fixLifetime()` that keeps values alive is a little weird.<br>&gt;&gt; `withExtendedLifetime()` is also slightly weird, but it makes more<br>&gt;&gt; sense than fixLifetime() does, since withExtendedLifetime() is the<br>&gt;&gt; specific solution to the problem of &quot;I need to ensure this value<br>&gt;&gt; remains alive for this entire scope because reasons&quot;.<br>&gt;&gt;<br>&gt;&gt; I&#39;d much rather just see the syntax `_ = val` be converted into<br>&gt;&gt; `Builtin.fixLifetime(val)` because the only reason to write an<br>&gt;&gt; expression like that is because you want to make sure the value is<br>&gt;&gt; still alive at that point (that and because it&#39;s not unreasonable for<br>&gt;&gt; people to assume that `_ = val` will keep the value alive, so it<br>&gt;&gt; would be nice to make that assumption actually be correct).<br>&gt;<br>&gt; I don&#39;t think this is obviously true. `val` could be a computed<br>&gt; property you just want to force the side effects for. (Computed<br>&gt; properties with side effects maybe aren&#39;t a great idea, but there are<br>&gt; some in AppKit/UIKit.)<br></p><p>I see two possibilities here:<br></p><p>1. If it&#39;s a computed property, fix the lifetime of the return value<br>   anyway. I don&#39;t think this is particularly helpful though, although<br>   all it would do in practice is prevent early-release if the computed<br>   property is inlined, or<br>2. If it&#39;s a computed property, just don&#39;t fix the lifetime. It seems<br>   fine to me to say `_ = localVar` has the implicit side-effect of<br>   fixing the lifetime of localVar, and if you say `_ =<br>   computedProperty` then that&#39;s just the pre-existing behavior of<br>   evaluating the computed property for its side-effects. No need to fix<br>   the lifetime of the computed property result.<br></p><p>Incidentally, does it makes sense to talk about fixing the lifetime of<br>stored properties? I assume that only really matters for local<br>variables, because stored properties are tied to `self`.<br></p><p>-Kevin<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/c811386a/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Scoped resources (like C# using statement)</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 30, 2015 at 04:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Dec 30, 2015, at 3:33 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 30, 2015, at 1:27 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Wed, Dec 30, 2015, at 09:53 AM, Joe Groff wrote:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; On Dec 29, 2015, at 8:55 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; An alternative solution is to do what Rust and C++ do, which is to use RAII. Which is to say, instead of introducing a new language construct that&#39;s explicitly tied to a scope, you just use a struct to represent the resource that you hold (e.g. a File that represents an open file). Of course, this does require some changes to structs, notably the addition of a deinit. And if structs have a deinit, then they also need to have a way to restrict copies. This is precisely what Rust does; any struct in Rust that implements Drop (the equivalent to deinit) loses the ability to be implicitly copied (a second trait called Clone provides a .clone() method that is the normal way to copy such non-implicitly-copyable structs).<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; deinit doesn&#39;t make sense for value types. Classes already support deinit, and you can use withExtendedLifetime to bound the lifetime of a resource-holding class. It would be reasonable to have a scoped lifetime marker similar to ObjC ARC too.<br>&gt;&gt;  <br>&gt;&gt; If you run with the idea that any resource-holding class should also be the mechanism by which you access the resource (e.g. a LockGuard that represents holding the lock and also provides access to the guarded value) then there&#39;s no need for extended lifetimes, because as long as you&#39;re accessing the resource, you&#39;re keeping the resource-holding class alive. I suppose there might be rare cases where you need to extend the lifetime of a resource-holding class even when you&#39;re not accessing the resource, just to guarantee e.g. order of resource releasing, but you can always just say something like `withExtendedLifeetime(&amp;val) {}` at the end of the scope to ensure the value is still alive at that point. Although I&#39;d really like to define `_ = val` as guaranteeing that the value is alive at that point (the expression doesn&#39;t actually do anything, but because it references `val` it expresses the programmer&#39;s intent that `val` should still be alive at that point in time). Alternatively, if we end up with move-only structs (or uniquely-owned classes), we could even define the expression `_ = val` as &quot;dropping&quot; the value , i.e. forcing it to deinit at that spot (because it&#39;s moving the value out of the `val` variable). This would be analogous to Rust&#39;s `std::mem::drop()` function (which is literally defined as `pub fn drop&lt;T&gt;(_x: T) { }` because all it does is move the value into the function and then forget about it).<br>&gt; <br>&gt; Another possibility I&#39;ve thought of is defining `defer { val }` to guarantee that val remains alive until the defer fires on scope exit. That might let us leave `defer` as the one &quot;guarantee something happens exactly at scope exit&quot; language construct.<br></p><p>+1.  This seems like a really good way to do it.<br></p><p>&gt; <br>&gt; -Joe<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/b983a7c7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a59b0df1d55761e4d340da93232790ea?s=50"></div><header><strong>[Proposal] Scoped resources (like C# using statement)</strong> from <string>Kevin Wooten</string> &lt;kdubb at me.com&gt;<p>December 30, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt;&gt; <br>&gt;&gt; Another possibility I&#39;ve thought of is defining `defer { val }` to guarantee that val remains alive until the defer fires on scope exit. That might let us leave `defer` as the one &quot;guarantee something happens exactly at scope exit&quot; language construct.<br></p><p>What about this…<br></p><p>defer let val = grabOrCreateSomething() {<br>  return;<br>}<br></p><p>Seems natural once you learn guard.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/2dbd35c6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Proposal] Scoped resources (like C# using statement)</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 30, 2015 at 03:00:00pm</p></header><div class="content"><p>On Wed, Dec 30, 2015, at 03:12 PM, Kevin Wooten via swift-evolution wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Another possibility I&#39;ve thought of is defining `defer { val }` to<br>&gt;&gt;&gt; guarantee that val remains alive until the defer fires on scope<br>&gt;&gt;&gt; exit. That might let us leave `defer` as the one &quot;guarantee<br>&gt;&gt;&gt; something happens exactly at scope exit&quot; language construct.<br>&gt;<br>&gt; What about this…<br>&gt;<br>&gt; defer let val = grabOrCreateSomething() {  return; }<br>&gt;<br>&gt; Seems natural once you learn guard.<br></p><p>Natural? I have no idea what you&#39;re expecting that expression to<br>actually do. What is a &quot;defer let&quot;?<br></p><p>-Kevin<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/521f2e36/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Scoped resources (like C# using statement)</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 30, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt; On Dec 30, 2015, at 5:19 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Wed, Dec 30, 2015, at 03:12 PM, Kevin Wooten via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Another possibility I&#39;ve thought of is defining `defer { val }` to guarantee that val remains alive until the defer fires on scope exit. That might let us leave `defer` as the one &quot;guarantee something happens exactly at scope exit&quot; language construct.<br>&gt;&gt;  <br>&gt;&gt; What about this…<br>&gt;&gt;  <br>&gt;&gt; defer let val = grabOrCreateSomething() {<br>&gt;&gt;   return;<br>&gt;&gt; }<br>&gt;&gt;  <br>&gt;&gt; Seems natural once you learn guard.<br>&gt;  <br>&gt; Natural? I have no idea what you&#39;re expecting that expression to actually do. What is a &quot;defer let”?<br></p><p>I think the idea is that a local variable declared with a `defer` modifier has its lifetime extended until the scope exits.  It is a slightly more compact version of what Joe suggested.  But I agree that it has potential for confusion - it reads like it is deferring the initialization of `val` until the scope exits which would be rather pointless.<br></p><p>I do like the idea of making the extended lifetime part of the local variable declaration but I’m not sure about how this specific syntax reads.<br></p><p>&gt;  <br>&gt; -Kevin<br>&gt;  <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/fddb5e37/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a59b0df1d55761e4d340da93232790ea?s=50"></div><header><strong>[Proposal] Scoped resources (like C# using statement)</strong> from <string>Kevin Wooten</string> &lt;kdubb at me.com&gt;<p>December 30, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt; On Dec 30, 2015, at 4:23 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 30, 2015, at 5:19 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Wed, Dec 30, 2015, at 03:12 PM, Kevin Wooten via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; Another possibility I&#39;ve thought of is defining `defer { val }` to guarantee that val remains alive until the defer fires on scope exit. That might let us leave `defer` as the one &quot;guarantee something happens exactly at scope exit&quot; language construct.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; What about this…<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; defer let val = grabOrCreateSomething() {<br>&gt;&gt;&gt;   return;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Seems natural once you learn guard.<br>&gt;&gt;  <br>&gt;&gt; Natural? I have no idea what you&#39;re expecting that expression to actually do. What is a &quot;defer let”?<br>&gt; <br>&gt; I think the idea is that a local variable declared with a `defer` modifier has its lifetime extended until the scope exits.  It is a slightly more compact version of what Joe suggested.  But I agree that it has potential for confusion - it reads like it is deferring the initialization of `val` until the scope exits which would be rather pointless.<br>&gt; <br></p><p>Given our discussion that’s definitely the gist of it, but I do stand corrected.  I guess I meant the syntax felt “familiar” to guard, but I&#39;d agree upon reflection it doesn’t read well.<br></p><p>&gt; I do like the idea of making the extended lifetime part of the local variable declaration but I’m not sure about how this specific syntax reads.<br>&gt; <br>&gt;&gt;  <br>&gt;&gt; -Kevin<br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/d3ca8c05/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Proposal] Scoped resources (like C# using statement)</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 30, 2015 at 04:00:00pm</p></header><div class="content"><p>If we need some way to say &quot;this local variable should extend to the end<br>of the scope&quot;, the most obvious (to me) way to do that is to introduce<br>an attribute that you can add to the variable declaration. This would be<br>similar to Obj-C&#39;s __attribute__((objc_precise_lifetime)), although not<br>quite as wordy. Although I am tempted to say we should go with `defer {<br>_ = val }` because I always like when you can re-use existing language<br>features; that does require we define `_ = val` as extending the<br>lifetime of val to that point, but as I said before I think that&#39;s a<br>perfectly reasonable thing to do.<br></p><p>-Kevin Ballard<br></p><p>On Wed, Dec 30, 2015, at 03:23 PM, Matthew Johnson wrote:<br>&gt;<br>&gt;&gt; On Dec 30, 2015, at 5:19 PM, Kevin Ballard via swift-evolution &lt;swift-<br>&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Wed, Dec 30, 2015, at 03:12 PM, Kevin Wooten via swift-<br>&gt;&gt; evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Another possibility I&#39;ve thought of is defining `defer { val }` to<br>&gt;&gt;&gt;&gt;&gt; guarantee that val remains alive until the defer fires on scope<br>&gt;&gt;&gt;&gt;&gt; exit. That might let us leave `defer` as the one &quot;guarantee<br>&gt;&gt;&gt;&gt;&gt; something happens exactly at scope exit&quot; language construct.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; What about this…<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; defer let val = grabOrCreateSomething() {  return; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Seems natural once you learn guard.<br>&gt;&gt;<br>&gt;&gt; Natural? I have no idea what you&#39;re expecting that expression to<br>&gt;&gt; actually do. What is a &quot;defer let”?<br>&gt;<br>&gt; I think the idea is that a local variable declared with a `defer`<br>&gt; modifier has its lifetime extended until the scope exits.  It is a<br>&gt; slightly more compact version of what Joe suggested.  But I agree that<br>&gt; it has potential for confusion - it reads like it is deferring the<br>&gt; initialization of `val` until the scope exits which would be rather<br>&gt; pointless.<br>&gt;<br>&gt; I do like the idea of making the extended lifetime part of the<br>&gt; local variable declaration but I’m not sure about how this specific<br>&gt; syntax reads.<br>&gt;<br>&gt;&gt;<br>&gt;&gt; -Kevin<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/9a8341e9/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2861bfeb71de9de58206bb6ae750bc2f?s=50"></div><header><strong>[Proposal] Scoped resources (like C# using statement)</strong> from <string>ilya</string> &lt;ilya.nikokoshev at gmail.com&gt;<p>December 31, 2015 at 10:00:00am</p></header><div class="content"><p>Honest question, where&#39;s the guarantee that the optimizer isn&#39;t allowed to<br>optimize defer {val} away?<br></p><p>On Thu, Dec 31, 2015 at 00:33 Joe Groff via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Dec 30, 2015, at 1:27 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt;<br>&gt; On Wed, Dec 30, 2015, at 09:53 AM, Joe Groff wrote:<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Dec 29, 2015, at 8:55 PM, Kevin Ballard via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; An alternative solution is to do what Rust and C++ do, which is to use<br>&gt; RAII. Which is to say, instead of introducing a new language construct<br>&gt; that&#39;s explicitly tied to a scope, you just use a struct to represent the<br>&gt; resource that you hold (e.g. a File that represents an open file). Of<br>&gt; course, this does require some changes to structs, notably the addition of<br>&gt; a deinit. And if structs have a deinit, then they also need to have a way<br>&gt; to restrict copies. This is precisely what Rust does; any struct in Rust<br>&gt; that implements Drop (the equivalent to deinit) loses the ability to be<br>&gt; implicitly copied (a second trait called Clone provides a .clone() method<br>&gt; that is the normal way to copy such non-implicitly-copyable structs).<br>&gt;<br>&gt;<br>&gt; deinit doesn&#39;t make sense for value types. Classes already support deinit,<br>&gt; and you can use withExtendedLifetime to bound the lifetime of a<br>&gt; resource-holding class. It would be reasonable to have a scoped lifetime<br>&gt; marker similar to ObjC ARC too.<br>&gt;<br>&gt;<br>&gt; If you run with the idea that any resource-holding class should also be<br>&gt; the mechanism by which you access the resource (e.g. a LockGuard that<br>&gt; represents holding the lock and also provides access to the guarded value)<br>&gt; then there&#39;s no need for extended lifetimes, because as long as you&#39;re<br>&gt; accessing the resource, you&#39;re keeping the resource-holding class alive. I<br>&gt; suppose there might be rare cases where you need to extend the lifetime of<br>&gt; a resource-holding class even when you&#39;re not accessing the resource, just<br>&gt; to guarantee e.g. order of resource releasing, but you can always just say<br>&gt; something like `withExtendedLifeetime(&amp;val) {}` at the end of the scope to<br>&gt; ensure the value is still alive at that point. Although I&#39;d really like to<br>&gt; define `_ = val` as guaranteeing that the value is alive at that point (the<br>&gt; expression doesn&#39;t actually do anything, but because it references `val` it<br>&gt; expresses the programmer&#39;s intent that `val` should still be alive at that<br>&gt; point in time). Alternatively, if we end up with move-only structs (or<br>&gt; uniquely-owned classes), we could even define the expression `_ = val` as<br>&gt; &quot;dropping&quot; the value , i.e. forcing it to deinit at that spot (because it&#39;s<br>&gt; moving the value out of the `val` variable). This would be analogous to<br>&gt; Rust&#39;s `std::mem::drop()` function (which is literally defined as `pub fn<br>&gt; drop&lt;T&gt;(_x: T) { }` because all it does is move the value into the function<br>&gt; and then forget about it).<br>&gt;<br>&gt;<br>&gt; Another possibility I&#39;ve thought of is defining `defer { val }` to<br>&gt; guarantee that val remains alive until the defer fires on scope exit. That<br>&gt; might let us leave `defer` as the one &quot;guarantee something happens exactly<br>&gt; at scope exit&quot; language construct.<br>&gt;<br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/8f9d0bb8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Scoped resources (like C# using statement)</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 31, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 31, 2015, at 2:48 AM, ilya &lt;ilya.nikokoshev at gmail.com&gt; wrote:<br>&gt; <br>&gt; Honest question, where&#39;s the guarantee that the optimizer isn&#39;t allowed to optimize defer {val} away? <br></p><p>There isn&#39;t one, today. It would be a language change if we wanted to make that guarantee.<br></p><p>-Joe<br></p><p>&gt; On Thu, Dec 31, 2015 at 00:33 Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Dec 30, 2015, at 1:27 PM, Kevin Ballard &lt;kevin at sb.org &lt;mailto:kevin at sb.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Wed, Dec 30, 2015, at 09:53 AM, Joe Groff wrote:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; On Dec 29, 2015, at 8:55 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; An alternative solution is to do what Rust and C++ do, which is to use RAII. Which is to say, instead of introducing a new language construct that&#39;s explicitly tied to a scope, you just use a struct to represent the resource that you hold (e.g. a File that represents an open file). Of course, this does require some changes to structs, notably the addition of a deinit. And if structs have a deinit, then they also need to have a way to restrict copies. This is precisely what Rust does; any struct in Rust that implements Drop (the equivalent to deinit) loses the ability to be implicitly copied (a second trait called Clone provides a .clone() method that is the normal way to copy such non-implicitly-copyable structs).<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; deinit doesn&#39;t make sense for value types. Classes already support deinit, and you can use withExtendedLifetime to bound the lifetime of a resource-holding class. It would be reasonable to have a scoped lifetime marker similar to ObjC ARC too.<br>&gt;&gt;  <br>&gt;&gt; If you run with the idea that any resource-holding class should also be the mechanism by which you access the resource (e.g. a LockGuard that represents holding the lock and also provides access to the guarded value) then there&#39;s no need for extended lifetimes, because as long as you&#39;re accessing the resource, you&#39;re keeping the resource-holding class alive. I suppose there might be rare cases where you need to extend the lifetime of a resource-holding class even when you&#39;re not accessing the resource, just to guarantee e.g. order of resource releasing, but you can always just say something like `withExtendedLifeetime(&amp;val) {}` at the end of the scope to ensure the value is still alive at that point. Although I&#39;d really like to define `_ = val` as guaranteeing that the value is alive at that point (the expression doesn&#39;t actually do anything, but because it references `val` it expresses the programmer&#39;s intent that `val` should still be alive at that point in time). Alternatively, if we end up with move-only structs (or uniquely-owned classes), we could even define the expression `_ = val` as &quot;dropping&quot; the value , i.e. forcing it to deinit at that spot (because it&#39;s moving the value out of the `val` variable). This would be analogous to Rust&#39;s `std::mem::drop()` function (which is literally defined as `pub fn drop&lt;T&gt;(_x: T) { }` because all it does is move the value into the function and then forget about it).<br>&gt; <br>&gt; Another possibility I&#39;ve thought of is defining `defer { val }` to guarantee that val remains alive until the defer fires on scope exit. That might let us leave `defer` as the one &quot;guarantee something happens exactly at scope exit&quot; language construct.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/57b79ebf/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Proposal] Scoped resources (like C# using statement)</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 30, 2015 at 01:00:00pm</p></header><div class="content"><p>IMO the biggest problem with this approach is that it leads to a much more complicated programming model.  The vast majority of structs should be copiable, which gets you into rule-of-five programming (where nearly every nontrivial struct needs to implement init, deinit, copy, assign, move) pretty quickly.  I don’t think Swift should go down this road.  <br></p><p>We do need a way to handle atomics, but I think there are other ways to address some of these concerns, including optimizing away class heap allocations and refcounting in special cases. <br></p><p>-Dave<br></p><p>&gt; On Dec 29, 2015, at 8:55 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; An alternative solution is to do what Rust and C++ do, which is to use RAII. Which is to say, instead of introducing a new language construct that&#39;s explicitly tied to a scope, you just use a struct to represent the resource that you hold (e.g. a File that represents an open file). Of course, this does require some changes to structs, notably the addition of a deinit. And if structs have a deinit, then they also need to have a way to restrict copies. This is precisely what Rust does; any struct in Rust that implements Drop (the equivalent to deinit) loses the ability to be implicitly copied (a second trait called Clone provides a .clone() method that is the normal way to copy such non-implicitly-copyable structs).<br>&gt;  <br>&gt; This solution is elegant for a few reasons:<br>&gt;  <br>&gt; 1. Once you allow deinit on structs (which is useful) and deal with the fact that structs are no longer implicitly copyable (because almost all deinit functions on structs won&#39;t work right if they&#39;re called twice, such as on two copies), then RAII just sort of falls out of all of this and doesn&#39;t require any specific language features.<br>&gt; 2. It&#39;s more flexible, because you can actually return the RAII value from a scope in order to extend its lifetime.<br>&gt; 3. The RAII value itself provides the means to access the resource it&#39;s protecting; e.g. a Lock might return a LockGuard RAII value from the .lock() method, and LockGuard provides the means to access the protected value (as opposed to just having the lock sitting next to the value, which makes it trivially easy to accidentally access the value without holding the lock).<br>&gt; 4. In Rust, this pattern also integrates extremely well with Rust&#39;s lifetime system (the system that prevents data races / memory corruption at compile time), because e.g. a LockGuard contains the lifetime of the Lock, which prevents you at compile-time from attempting to lock the Lock while you already have it locked (though it doesn&#39;t prevent deadlocks where you and another thread try and lock two locks in opposite orders, but there is plenty of stuff it does catch).<br>&gt;  <br>&gt; The biggest problem with adding deinit to structs in Swift right now is the fact that we don&#39;t have references, which means you can&#39;t take a RAII struct and pass it to another function without losing it. Heck, you can&#39;t even call a method on it, because `self` on non-mutating methods in Swift is a value and not a reference (although we could hand-wave that away and make `self` in non-mutating RAII methods actually be an &quot;in&quot; reference internally, but this kind of hand-waving doesn&#39;t work when passing the struct as an argument to another function). So we&#39;d actually have to introduce a special &quot;in&quot; reference, which would be like &quot;inout&quot; except it doesn&#39;t actually copy it out (and is guaranteed to actually pass a pointer, although this pointer may be a pointer to a temporary). Except even that fails if you want to have a computed property that returns an existing RAII value (for example, having an Array of these things; barring optimizations, the subscript getter returns a computed value). And you can&#39;t generalize such &quot;in&quot; references beyond function arguments without basically providing raw C pointers. Rust&#39;s lifetime system lets them do it safely, but barring such a system, Swift can&#39;t really do this (I assume it&#39;s obvious why we don&#39;t want to start using raw C pointers everywhere).<br>&gt;  <br>&gt; All that said, I think this is a problem Swift needs to solve, because having non-copyable structs would be very useful. In particular, I _really_ want some way to do atomics in Swift, but the only safe way I can think of to do it requires non-copyable structs (because it&#39;s not correct to do a nonatomic read (such as a memcpy) of an atomic that&#39;s visible to other threads). I suppose you could provide a way to override how struct copies work (e.g. so you could do an atomic read of the old value), but it&#39;s rather problematic to break the assumption that struct copies are cheap.<br>&gt;  <br>&gt; Of course, you could model RAII with classes instead of structs, that just has the overhead of heap allocation (+ atomic reference counting) for every RAII value.<br>&gt;  <br>&gt; -Kevin Ballard<br>&gt;  <br>&gt; On Tue, Dec 29, 2015, at 08:02 PM, Trent Nadeau via swift-evolution wrote:<br>&gt;&gt; # Introduction<br>&gt;&gt;  <br>&gt;&gt; Add a new `Scoped` protocol and enhance the do statement to automatically call enter/exit actions on resources.<br>&gt;&gt;  <br>&gt;&gt; # Motivation<br>&gt;&gt;  <br>&gt;&gt; Resources (e.g., locks, files, sockets, etc.) often need to be scoped to a block, where some action is taken at the start of the block and another is required at the end. Examples include locking and unlocking a lock in a critical section or closing a file at the end of a block.<br>&gt;&gt;  <br>&gt;&gt; Doing this manually is possible using `defer` statements among other options, but this is error prone as a `defer` can be forgotten, `lock`/`unlock` calls for two locks can be switched due to a typo, etc. Having a dedicated language construct for this common case makes it easier to read and write while making code shorter and clearer.<br>&gt;&gt;  <br>&gt;&gt; # Language Survey<br>&gt;&gt;  <br>&gt;&gt; At least three major languages have widely used statements for this use case.<br>&gt;&gt;  <br>&gt;&gt; ## C#<br>&gt;&gt;  <br>&gt;&gt; C# has the `using` statement and the associated `IDisposable` interface.<br>&gt;&gt;  <br>&gt;&gt; ```csharp<br>&gt;&gt; using (StreamReader sr = new StreamReader(filename)) {<br>&gt;&gt;     txt = sr.ReadToEnd();<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt;  <br>&gt;&gt; C#&#39;s solution only handles close/exit actions via the `IDisposable.Dispose()` method and so cannot easily be used with items such as locks; however, C# has the additional `lock` statement for that use case.<br>&gt;&gt;  <br>&gt;&gt; ## Java<br>&gt;&gt;  <br>&gt;&gt; Java has try-with-resources and the associated `AutoCloseable` interface.<br>&gt;&gt;  <br>&gt;&gt; ```java<br>&gt;&gt; try (BufferedReader br = new BufferedReader(new FileReader(path))) {<br>&gt;&gt;     return br.readLine();<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt;  <br>&gt;&gt; Java&#39;s solution only handles close/exit actions via the `AutoCloseable.close()` method and so cannot easily be used with items such as locks; however, Java has the additional `synchronized` statement for that use case.<br>&gt;&gt;  <br>&gt;&gt; ## Python<br>&gt;&gt;  <br>&gt;&gt; Python has with `with` statement and the associated `__enter__` and `__exit__` special methods that classes may implement to become a &quot;context manager&quot;.<br>&gt;&gt;  <br>&gt;&gt; ```python<br>&gt;&gt; with lock, open(path) as my_file:<br>&gt;&gt;     contents = my_file.read()<br>&gt;&gt;     # use contents<br>&gt;&gt; ```<br>&gt;&gt;  <br>&gt;&gt; Python&#39;s solution handles both enter and exit actions and so this one construct is usable for locks as well as resources like sockets and files.<br>&gt;&gt;  <br>&gt;&gt; # Proposed Solution<br>&gt;&gt;  <br>&gt;&gt; We add a new protocol called `Scoped` to the standard library. Types for resources that have enter/exit actions will be extended to add conformance to this protocol.<br>&gt;&gt;  <br>&gt;&gt; The `do` statement will be extended to allow a new `using &lt;resources&gt;` &quot;suffix&quot;.<br>&gt;&gt;  <br>&gt;&gt; # Detailed Design<br>&gt;&gt;  <br>&gt;&gt; The `Scoped` protocol shall be as follows:<br>&gt;&gt;  <br>&gt;&gt; ```swift<br>&gt;&gt; public protocol Scoped {<br>&gt;&gt;     func enterScope()<br>&gt;&gt;     func exitScope()<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt;  <br>&gt;&gt; The compiler statement will accept a new form for resources. For example,<br>&gt;&gt;  <br>&gt;&gt; ```swift<br>&gt;&gt; do using lock, let file = try getFileHandle() {<br>&gt;&gt;     // statements<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt;  <br>&gt;&gt; As can be seen in the example above, the resources can be bindings that already exist (like `lock`) or can be new bindings. Bindings created with `do using` are not available outside of the scope of the `do using`. Only types conforming to `Scoped` may be using with `do using`. Use of non-conforming types will result in a compiler error.<br>&gt;&gt;  <br>&gt;&gt; The above example would be syntactic sugar for the following:<br>&gt;&gt;  <br>&gt;&gt; ```swift<br>&gt;&gt; do {<br>&gt;&gt;     lock.enterScope()<br>&gt;&gt;     defer { lock.exitScope() }<br>&gt;&gt;  <br>&gt;&gt;     let file = try getFileHandle()<br>&gt;&gt;     file.enterScope()<br>&gt;&gt;     defer { file.exitScope() }<br>&gt;&gt;  <br>&gt;&gt;     // statements<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt;  <br>&gt;&gt; # Framework Changes / Examples<br>&gt;&gt;  <br>&gt;&gt; As an example of some real-world classes that would be useful with `Scoped`, from Foundation:<br>&gt;&gt;  <br>&gt;&gt; ```swift<br>&gt;&gt; // Would be nice to extend the NSLocking protocol instead, but that&#39;s not supported yet.<br>&gt;&gt; extension NSLock: Scoped {<br>&gt;&gt;     func enterScope() {<br>&gt;&gt;         self.lock()<br>&gt;&gt;     }<br>&gt;&gt;  <br>&gt;&gt;     func exitScope() {<br>&gt;&gt;         self.unlock()<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;  <br>&gt;&gt; extension NSFileHandle: Scoped {<br>&gt;&gt;     func enterScope() {}<br>&gt;&gt;  <br>&gt;&gt;     func exitScope() {<br>&gt;&gt;         self.closeFile()<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt;  <br>&gt;&gt; # Questions and Concerns<br>&gt;&gt;  * Bikeshedding protocol naming and scoping syntax<br>&gt;&gt;  * Should the enter and exit actions be allowed to throw errors?<br>&gt;&gt;  <br>&gt;&gt; -- <br>&gt;&gt; Trent Nadeau<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/55650e22/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Proposal] Scoped resources (like C# using statement)</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 30, 2015 at 01:00:00pm</p></header><div class="content"><p>There&#39;s no rule-of-five if you explicitly define (as Rust does) that you<br>cannot override assign/copy/move. In Rust, a copyable struct is always<br>memcpy()&#39;d. Anything that&#39;s not memcpy&#39;d but still wants to support<br>explicit copying conforms to the Clone trait, and the compiler lets such<br>structs automatically derive Clone (the Clone trait provides a single<br>method .clone() that returns a copy of the struct). So it&#39;s basically<br>just init, which we already require (though we infer an init if you<br>don&#39;t otherwise define one), deinit which is totally optional, and then<br>just one line to derive a Clone implementation if appropriate (and of<br>course you can always manually implement Clone if you need special logic<br>to do so, e.g. the Arc type (Atomic Reference Counted) manually<br>implements Clone in order to bump the retain count, but that&#39;s actually<br>pretty rare, usually structs that need to actually do things (like bump<br>retain counts) on clone are composed of smaller pieces (like Arc) that<br>do that automatically).<br></p><p>Overall this system works pretty well. Because you can&#39;t override<br>assign/copy/move, you can move and copy structs around without worry<br>(just as we do in Swift). And if a struct is not copyable, you can<br>invoke .clone() and it&#39;s obvious from the code that you&#39;re doing<br>something  more expensive than just a memcpy(). This system also<br>encourages the use of references when possible because it lets you avoid<br>the potentially-expensive clones (versus overriding copy, where you end<br>up invoking potentially-expensive copies without even realizing it). Of<br>course, this does require actually having references in the language to<br>begin with.<br></p><p>Ultimately, given Swift&#39;s current direction, I&#39;m leaning right now<br>towards the idea of having uniquely-owned stack-allocated classes, and<br>that&#39;s basically just because classes are already a reference type,<br>which makes it a bit easier to explain adding magic that lets you say<br>things like non-mutating methods are acting on a reference (even though<br>it&#39;s stack-allocated) and provides an avenue for doing things like<br>saying things like `func foo(x: ref LockGuard&lt;Bar&gt;)` to represent the<br>idea of a pass-by-reference that&#39;s treated as @noescape (or the<br>alternative, `func foo(x: move LockGuard&lt;Bar&gt;)` that explicitly moves<br>the value, except we do need the @noescape part of passing a reference<br>to a uniquely-owned value so I think annotating the parameter with `ref`<br>or `in` makes more sense).<br></p><p>-Kevin Ballard<br></p><p>On Wed, Dec 30, 2015, at 01:40 PM, Dave Abrahams wrote:<br>&gt;<br>&gt; IMO the biggest problem with this approach is that it leads to a much<br>&gt; more complicated programming model.  The vast majority of structs<br>&gt; *should* be copiable, which gets you into rule-of-five programming<br>&gt; (where nearly every nontrivial struct needs to implement init, deinit,<br>&gt; copy, assign, move) pretty quickly.  I don’t think Swift should go<br>&gt; down this road.<br>&gt;<br>&gt; We do need a way to handle atomics, but I think there are other ways<br>&gt; to address some of these concerns, including optimizing away class<br>&gt; heap allocations and refcounting in special cases.<br>&gt;<br>&gt; -Dave<br>&gt;<br>&gt;&gt; On Dec 29, 2015, at 8:55 PM, Kevin Ballard via swift-evolution &lt;swift-<br>&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; An alternative solution is to do what Rust and C++ do, which is to<br>&gt;&gt; use RAII. Which is to say, instead of introducing a new language<br>&gt;&gt; construct that&#39;s explicitly tied to a scope, you just use a struct to<br>&gt;&gt; represent the resource that you hold (e.g. a File that represents an<br>&gt;&gt; open file). Of course, this does require some changes to structs,<br>&gt;&gt; notably the addition of a deinit. And if structs have a deinit, then<br>&gt;&gt; they also need to have a way to restrict copies. This is precisely<br>&gt;&gt; what Rust does; any struct in Rust that implements Drop (the<br>&gt;&gt; equivalent to deinit) loses the ability to be implicitly copied (a<br>&gt;&gt; second trait called Clone provides a .clone() method that is the<br>&gt;&gt; normal way to copy such non-implicitly-copyable structs).<br>&gt;&gt;<br>&gt;&gt; This solution is elegant for a few reasons:<br>&gt;&gt;<br>&gt;&gt; 1. Once you allow deinit on structs (which is useful) and deal with<br>&gt;&gt;    the fact that structs are no longer implicitly copyable (because<br>&gt;&gt;    almost all deinit functions on structs won&#39;t work right if they&#39;re<br>&gt;&gt;    called twice, such as on two copies), then RAII just sort of falls<br>&gt;&gt;    out of all of this and doesn&#39;t require any specific language<br>&gt;&gt;    features.<br>&gt;&gt; 2. It&#39;s more flexible, because you can actually return the RAII value<br>&gt;&gt;    from a scope in order to extend its lifetime.<br>&gt;&gt; 3. The RAII value itself provides the means to access the resource<br>&gt;&gt;    it&#39;s protecting; e.g. a Lock might return a LockGuard RAII value<br>&gt;&gt;    from the .lock() method, and LockGuard provides the means to<br>&gt;&gt;    access the protected value (as opposed to just having the lock<br>&gt;&gt;    sitting next to the value, which makes it trivially easy to<br>&gt;&gt;    accidentally access the value without holding the lock).<br>&gt;&gt; 4. In Rust, this pattern also integrates extremely well with Rust&#39;s<br>&gt;&gt;    lifetime system (the system that prevents data races / memory<br>&gt;&gt;    corruption at compile time), because e.g. a LockGuard contains the<br>&gt;&gt;    lifetime of the Lock, which prevents you at compile-time from<br>&gt;&gt;    attempting to lock the Lock while you already have it locked<br>&gt;&gt;    (though it doesn&#39;t prevent deadlocks where you and another thread<br>&gt;&gt;    try and lock two locks in opposite orders, but there is plenty of<br>&gt;&gt;    stuff it does catch).<br>&gt;&gt;<br>&gt;&gt; The biggest problem with adding deinit to structs in Swift right now<br>&gt;&gt; is the fact that we don&#39;t have references, which means you can&#39;t take<br>&gt;&gt; a RAII struct and pass it to another function without losing it.<br>&gt;&gt; Heck, you can&#39;t even call a method on it, because `self` on non-<br>&gt;&gt; mutating methods in Swift is a value and not a reference (although we<br>&gt;&gt; could hand-wave that away and make `self` in non-mutating RAII<br>&gt;&gt; methods actually be an &quot;in&quot; reference internally, but this kind of<br>&gt;&gt; hand-waving doesn&#39;t work when passing the struct as an argument to<br>&gt;&gt; another function). So we&#39;d actually have to introduce a special &quot;in&quot;<br>&gt;&gt; reference, which would be like &quot;inout&quot; except it doesn&#39;t actually<br>&gt;&gt; copy it out (and is guaranteed to actually pass a pointer, although<br>&gt;&gt; this pointer may be a pointer to a temporary). Except even that fails<br>&gt;&gt; if you want to have a computed property that returns an existing RAII<br>&gt;&gt; value (for example, having an Array of these things; barring<br>&gt;&gt; optimizations, the subscript getter returns a computed value). And<br>&gt;&gt; you can&#39;t generalize such &quot;in&quot; references beyond function arguments<br>&gt;&gt; without basically providing raw C pointers. Rust&#39;s lifetime system<br>&gt;&gt; lets them do it safely, but barring such a system, Swift can&#39;t really<br>&gt;&gt; do this (I assume it&#39;s obvious why we don&#39;t want to start using raw C<br>&gt;&gt; pointers everywhere).<br>&gt;&gt;<br>&gt;&gt; All that said, I think this is a problem Swift needs to solve,<br>&gt;&gt; because having non-copyable structs would be very useful. In<br>&gt;&gt; particular, I _really_ want some way to do atomics in Swift, but the<br>&gt;&gt; only safe way I can think of to do it requires non-copyable structs<br>&gt;&gt; (because it&#39;s not correct to do a nonatomic read (such as a memcpy)<br>&gt;&gt; of an atomic that&#39;s visible to other threads). I suppose you could<br>&gt;&gt; provide a way to override how struct copies work (e.g. so you could<br>&gt;&gt; do an atomic read of the old value), but it&#39;s rather problematic to<br>&gt;&gt; break the assumption that struct copies are cheap.<br>&gt;&gt;<br>&gt;&gt; Of course, you could model RAII with classes instead of structs, that<br>&gt;&gt; just has the overhead of heap allocation (+ atomic reference<br>&gt;&gt; counting) for every RAII value.<br>&gt;&gt;<br>&gt;&gt; -Kevin Ballard<br>&gt;&gt;<br>&gt;&gt; On Tue, Dec 29, 2015, at 08:02 PM, Trent Nadeau via swift-<br>&gt;&gt; evolution wrote:<br>&gt;&gt;&gt; # Introduction<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Add a new `Scoped` protocol and enhance the do statement to<br>&gt;&gt;&gt; automatically call enter/exit actions on resources.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; # Motivation<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Resources (e.g., locks, files, sockets, etc.) often need to be<br>&gt;&gt;&gt; scoped to a block, where some action is taken at the start of the<br>&gt;&gt;&gt; block and another is required at the end. Examples include locking<br>&gt;&gt;&gt; and unlocking a lock in a critical section or closing a file at the<br>&gt;&gt;&gt; end of a block.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Doing this manually is possible using `defer` statements among other<br>&gt;&gt;&gt; options, but this is error prone as a `defer` can be forgotten,<br>&gt;&gt;&gt; `lock`/`unlock` calls for two locks can be switched due to a typo,<br>&gt;&gt;&gt; etc. Having a dedicated language construct for this common case<br>&gt;&gt;&gt; makes it easier to read and write while making code shorter and<br>&gt;&gt;&gt; clearer.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; # Language Survey<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; At least three major languages have widely used statements for this<br>&gt;&gt;&gt; use case.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ## C#<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; C# has the `using` statement and the associated `IDisposable`<br>&gt;&gt;&gt; interface.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ```csharp using (StreamReader sr = new StreamReader(filename)) {<br>&gt;&gt;&gt; txt = sr.ReadToEnd(); } ```<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; C#&#39;s solution only handles close/exit actions via the<br>&gt;&gt;&gt; `IDisposable.Dispose()` method and so cannot easily be used with<br>&gt;&gt;&gt; items such as locks; however, C# has the additional `lock` statement<br>&gt;&gt;&gt; for that use case.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ## Java<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Java has try-with-resources and the associated `AutoCloseable`<br>&gt;&gt;&gt; interface.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ```java try (BufferedReader br = new BufferedReader(new<br>&gt;&gt;&gt; FileReader(path))) {    return br.readLine(); } ```<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Java&#39;s solution only handles close/exit actions via the<br>&gt;&gt;&gt; `AutoCloseable.close()` method and so cannot easily be used with<br>&gt;&gt;&gt; items such as locks; however, Java has the additional `synchronized`<br>&gt;&gt;&gt; statement for that use case.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ## Python<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Python has with `with` statement and the associated `__enter__` and<br>&gt;&gt;&gt; `__exit__` special methods that classes may implement to become a<br>&gt;&gt;&gt; &quot;context manager&quot;.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ```python with lock, open(path) as my_file:    contents =<br>&gt;&gt;&gt; my_file.read()    # use contents ```<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Python&#39;s solution handles both enter and exit actions and so this<br>&gt;&gt;&gt; one construct is usable for locks as well as resources like sockets<br>&gt;&gt;&gt; and files.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; # Proposed Solution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; We add a new protocol called `Scoped` to the standard library. Types<br>&gt;&gt;&gt; for resources that have enter/exit actions will be extended to add<br>&gt;&gt;&gt; conformance to this protocol.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The `do` statement will be extended to allow a new `using<br>&gt;&gt;&gt; &lt;resources&gt;` &quot;suffix&quot;.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; # Detailed Design<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The `Scoped` protocol shall be as follows:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ```swift public protocol Scoped {    func enterScope()    func<br>&gt;&gt;&gt; exitScope() } ```<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The compiler statement will accept a new form for resources. For<br>&gt;&gt;&gt; example,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ```swift do using lock, let file = try getFileHandle() {    //<br>&gt;&gt;&gt; statements } ```<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; As can be seen in the example above, the resources can be bindings<br>&gt;&gt;&gt; that already exist (like `lock`) or can be new bindings. Bindings<br>&gt;&gt;&gt; created with `do using` are not available outside of the scope of<br>&gt;&gt;&gt; the `do using`. Only types conforming to `Scoped` may be using with<br>&gt;&gt;&gt; `do using`. Use of non-conforming types will result in a compiler<br>&gt;&gt;&gt; error.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The above example would be syntactic sugar for the following:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ```swift do {    lock.enterScope()    defer { lock.exitScope() }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let file = try getFileHandle()    file.enterScope()    defer {<br>&gt;&gt;&gt; file.exitScope() }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; // statements } ```<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; # Framework Changes / Examples<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; As an example of some real-world classes that would be useful with<br>&gt;&gt;&gt; `Scoped`, from Foundation:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ```swift // Would be nice to extend the NSLocking protocol instead,<br>&gt;&gt;&gt; but that&#39;s not supported yet. extension NSLock: Scoped {    func<br>&gt;&gt;&gt; enterScope() {        self.lock()    }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func exitScope() {        self.unlock()    } }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; extension NSFileHandle: Scoped {    func enterScope() {}<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func exitScope() {        self.closeFile()    } } ```<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; # Questions and Concerns<br>&gt;&gt;&gt; * Bikeshedding protocol naming and scoping syntax * Should the enter<br>&gt;&gt;&gt; and exit actions be allowed to throw errors?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Trent Nadeau<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _________________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/e2672a0c/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Proposal] Scoped resources (like C# using statement)</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>December 30, 2015 at 12:00:00pm</p></header><div class="content"><p>It is an appealing idea on first sight, but it makes the language more complex, and I don&#39;t think scoped resources are versatile enough to back justify their inclusion.<br></p><p>The defer feature which is already mentioned in the proposal is very similar — and I expect that will not only be the case for the effect, but also for the usefulness:<br>I rarely use defer… I still like the concept, but I guess our ecosystem just has little need for it.<br></p><p>Tino<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c40db4457ab2c91a0d8006da31b177c6?s=50"></div><header><strong>[Proposal] Scoped resources (like C# using statement)</strong> from <string>Trent Nadeau</string> &lt;tanadeau at gmail.com&gt;<p>December 30, 2015 at 12:00:00pm</p></header><div class="content"><p>Based on the discussion here, I&#39;m withdrawing this proposal.<br></p><p>I created it because of a section in the Error Handling Rationale and<br>Proposal document (<br>https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst)<br>about `using`:<br></p><p>Swift should consider providing a using statement which acquires a<br>resource, holds it for a fixed period of time, optionally binds it to a<br>name, and then releases it whenever the controlled statement exits.<br></p><p>using has many similarities to defer. It does not subsume defer, which is<br>useful for many ad-hoc and tokenless clean-ups. But it is convenient for<br>the common pattern of a type-directed clean-up.<br></p><p>We do not expect this feature to be necessary in the first release.<br></p><p>However, it looks like there isn&#39;t enough need to warrant a language<br>change, at least for now. Is the Rationale doc a living document? If so, it<br>should perhaps be updated to mention that `using` needs a strong use case<br>given the current language features.<br></p><p>Thanks to everyone involved in this discussion.<br>&lt;https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst#c-and-objective-c-interoperation&gt;<br></p><p>On Wed, Dec 30, 2015 at 6:12 AM, Tino Heth &lt;2th at gmx.de&gt; wrote:<br></p><p>&gt; It is an appealing idea on first sight, but it makes the language more<br>&gt; complex, and I don&#39;t think scoped resources are versatile enough to back<br>&gt; justify their inclusion.<br>&gt;<br>&gt; The defer feature which is already mentioned in the proposal is very<br>&gt; similar — and I expect that will not only be the case for the effect, but<br>&gt; also for the usefulness:<br>&gt; I rarely use defer… I still like the concept, but I guess our ecosystem<br>&gt; just has little need for it.<br>&gt;<br>&gt; Tino<br></p><p><br></p><p><br>-- <br>Trent Nadeau<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/785eff74/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
