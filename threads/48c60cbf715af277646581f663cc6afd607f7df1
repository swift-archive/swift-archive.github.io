<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[RFC] #Self</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>May 10, 2016 at 07:00:00am</p></header><div class="content"><p>To focus SE-0068 and narrow its scope, I removed the `#Self` part of the proposal. This offered compile-time substitution of the defining type for a related #Self literal:<br></p><p>A further static identifier, #Self expands to static type of the code it appears within, completing the ways code may want to refer to the type it is declared in. <br></p><p>#Self expands to the static type of the code it is declared within. In value types, this is always the same as Self. In reference types, it refers to the declaring type. #Self will offer a literal textual replacement just like #file, etc.<br></p><p>At Chris&#39;s suggestion, I&#39;m starting a new SE thread to see whether there remains any interest for including #Self in the language. I&#39;m personally happy with the SE-0068 outcome but I didn&#39;t want to undercut anyone like Timothy Wood who had originally spoken up for its inclusion.<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160510/48c67df1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[RFC] #Self</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>May 10, 2016 at 11:00:00pm</p></header><div class="content"><p>Is there an example of a before / after? Thanks.<br></p><p>&gt; On 10 May 2016, at 11:15 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; To focus SE-0068 and narrow its scope, I removed the `#Self` part of the proposal. This offered compile-time substitution of the defining type for a related #Self literal:<br>&gt; <br>&gt; A further static identifier, #Self expands to static type of the code it appears within, completing the ways code may want to refer to the type it is declared in. <br>&gt; <br>&gt; #Self expands to the static type of the code it is declared within. In value types, this is always the same as Self. In reference types, it refers to the declaring type. #Self will offer a literal textual replacement just like #file, etc.<br>&gt; <br>&gt; At Chris&#39;s suggestion, I&#39;m starting a new SE thread to see whether there remains any interest for including #Self in the language. I&#39;m personally happy with the SE-0068 outcome but I didn&#39;t want to undercut anyone like Timothy Wood who had originally spoken up for its inclusion.<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160510/21c3f22b/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[RFC] #Self</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 10, 2016 at 09:00:00am</p></header><div class="content"><p>Can you clarify where would #Self would be allowed?<br></p><p>* property declarations<br>* method signatures<br>* method and computed property bodies<br>* all of the above<br></p><p>I would like to see this and allowed in all of the above.<br></p><p>We should also consider allowing this in protocol requirements.  It would not covary like Self does for return types, instead being fixed by the class that declares conformance.<br></p><p>Sent from my iPad<br></p><p>&gt; On May 10, 2016, at 8:15 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; To focus SE-0068 and narrow its scope, I removed the `#Self` part of the proposal. This offered compile-time substitution of the defining type for a related #Self literal:<br>&gt; <br>&gt; A further static identifier, #Self expands to static type of the code it appears within, completing the ways code may want to refer to the type it is declared in. <br>&gt; <br>&gt; #Self expands to the static type of the code it is declared within. In value types, this is always the same as Self. In reference types, it refers to the declaring type. #Self will offer a literal textual replacement just like #file, etc.<br>&gt; <br>&gt; At Chris&#39;s suggestion, I&#39;m starting a new SE thread to see whether there remains any interest for including #Self in the language. I&#39;m personally happy with the SE-0068 outcome but I didn&#39;t want to undercut anyone like Timothy Wood who had originally spoken up for its inclusion.<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160510/588d6bbb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[RFC] #Self</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>May 10, 2016 at 08:00:00am</p></header><div class="content"><p>As a compile-time substitution, it could be used in any and all of the examples in your bullet list as a literal text replacement..<br></p><p>Quick rundown:<br></p><p>struct A {<br>   ...#Self... // #Self is substituted by A<br>}<br></p><p>class B {<br>    ...#Self... // Self is substituted by B<br>}<br></p><p>class C {<br>   ... #Self... // Self is substituted by C, which is the defining type at compile time<br>}<br></p><p>I&#39;m stepping away from endorsing or pushing this forward. If you want to pick this up and run with it, it&#39;s yours.<br></p><p>-- E<br></p><p><br>&gt; On May 10, 2016, at 8:34 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; Can you clarify where would #Self would be allowed?<br>&gt; <br>&gt; * property declarations<br>&gt; * method signatures<br>&gt; * method and computed property bodies<br>&gt; * all of the above<br>&gt; <br>&gt; I would like to see this and allowed in all of the above.<br>&gt; <br>&gt; We should also consider allowing this in protocol requirements.  It would not covary like Self does for return types, instead being fixed by the class that declares conformance.<br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On May 10, 2016, at 8:15 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; To focus SE-0068 and narrow its scope, I removed the `#Self` part of the proposal. This offered compile-time substitution of the defining type for a related #Self literal:<br>&gt;&gt; <br>&gt;&gt; A further static identifier, #Self expands to static type of the code it appears within, completing the ways code may want to refer to the type it is declared in. <br>&gt;&gt; <br>&gt;&gt; #Self expands to the static type of the code it is declared within. In value types, this is always the same as Self. In reference types, it refers to the declaring type. #Self will offer a literal textual replacement just like #file, etc.<br>&gt;&gt; <br>&gt;&gt; At Chris&#39;s suggestion, I&#39;m starting a new SE thread to see whether there remains any interest for including #Self in the language. I&#39;m personally happy with the SE-0068 outcome but I didn&#39;t want to undercut anyone like Timothy Wood who had originally spoken up for its inclusion.<br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160510/f7d22b59/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[RFC] #Self</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 10, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On May 10, 2016, at 9:50 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; As a compile-time substitution, it could be used in any and all of the examples in your bullet list as a literal text replacement..<br>&gt; <br>&gt; Quick rundown:<br>&gt; <br>&gt; struct A {<br>&gt;    ...#Self... // #Self is substituted by A<br>&gt; }<br>&gt; <br>&gt; class B {<br>&gt;     ...#Self... // Self is substituted by B<br>&gt; }<br>&gt; <br>&gt; class C {<br>&gt;    ... #Self... // Self is substituted by C, which is the defining type at compile time<br>&gt; }<br>&gt; <br>&gt; I&#39;m stepping away from endorsing or pushing this forward. If you want to pick this up and run with it, it&#39;s yours.<br></p><p>I may do this if there is enough support from others.  Lets see what the response is in this thread.  Thanks for starting it.<br></p><p>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br>&gt;&gt; On May 10, 2016, at 8:34 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Can you clarify where would #Self would be allowed?<br>&gt;&gt; <br>&gt;&gt; * property declarations<br>&gt;&gt; * method signatures<br>&gt;&gt; * method and computed property bodies<br>&gt;&gt; * all of the above<br>&gt;&gt; <br>&gt;&gt; I would like to see this and allowed in all of the above.<br>&gt;&gt; <br>&gt;&gt; We should also consider allowing this in protocol requirements.  It would not covary like Self does for return types, instead being fixed by the class that declares conformance.<br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt; On May 10, 2016, at 8:15 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; To focus SE-0068 and narrow its scope, I removed the `#Self` part of the proposal. This offered compile-time substitution of the defining type for a related #Self literal:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A further static identifier, #Self expands to static type of the code it appears within, completing the ways code may want to refer to the type it is declared in. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; #Self expands to the static type of the code it is declared within. In value types, this is always the same as Self. In reference types, it refers to the declaring type. #Self will offer a literal textual replacement just like #file, etc.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; At Chris&#39;s suggestion, I&#39;m starting a new SE thread to see whether there remains any interest for including #Self in the language. I&#39;m personally happy with the SE-0068 outcome but I didn&#39;t want to undercut anyone like Timothy Wood who had originally spoken up for its inclusion.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- E<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160510/e4b9a4e1/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[RFC] #Self</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 10, 2016 at 06:00:00pm</p></header><div class="content"><p>What about #Self in protocols? I.e. is it proposed to have #Self in <br>protocols, where conformance will require a substitution by real type name?<br></p><p>protocol A {<br>     func a() -&gt; Self<br>     func b(c: Self) // b(c: #Self)   ?<br>}<br></p><p>class C: A {<br>     func a() -&gt; Self { return self }<br>     func b(c: C) {} // b(c: #Self) ?<br>}<br></p><p><br>protocol A2 {<br>     var a: Self {get}<br>}<br></p><p>final class C2 : A2 {<br>     var a: C2 { return C2() } // #Self { return #Self() }  ?<br>}<br></p><p>On 10.05.2016 17:50, Erica Sadun via swift-evolution wrote:<br>&gt; As a compile-time substitution, it could be used in any and all of the<br>&gt; examples in your bullet list as a literal text replacement..<br>&gt;<br>&gt; Quick rundown:<br>&gt;<br>&gt; struct A {<br>&gt;    ...#Self... // #Self is substituted by A<br>&gt; }<br>&gt;<br>&gt; class B {<br>&gt;     ...#Self... // Self is substituted by B<br>&gt; }<br>&gt;<br>&gt; class C {<br>&gt;    ... #Self... // Self is substituted by C, which is the defining type at<br>&gt; compile time<br>&gt; }<br>&gt;<br>&gt; I&#39;m stepping away from endorsing or pushing this forward. If you want to<br>&gt; pick this up and run with it, it&#39;s yours.<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt;<br>&gt;&gt; On May 10, 2016, at 8:34 AM, Matthew Johnson &lt;matthew at anandabits.com<br>&gt;&gt; &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Can you clarify where would #Self would be allowed?<br>&gt;&gt;<br>&gt;&gt; * property declarations<br>&gt;&gt; * method signatures<br>&gt;&gt; * method and computed property bodies<br>&gt;&gt; * all of the above<br>&gt;&gt;<br>&gt;&gt; I would like to see this and allowed in all of the above.<br>&gt;&gt;<br>&gt;&gt; We should also consider allowing this in protocol requirements.  It would<br>&gt;&gt; not covary like Self does for return types, instead being fixed by the<br>&gt;&gt; class that declares conformance.<br>&gt;&gt;<br>&gt;&gt; Sent from my iPad<br>&gt;&gt;<br>&gt;&gt; On May 10, 2016, at 8:15 AM, Erica Sadun via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; To focus SE-0068 and narrow its scope, I removed the `#Self` part of the<br>&gt;&gt;&gt; proposal. This offered compile-time substitution of the defining type<br>&gt;&gt;&gt; for a related #Self literal:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     A further static identifier, |#Self| expands to static type of the<br>&gt;&gt;&gt;     code it appears within, completing the ways code may want to refer<br>&gt;&gt;&gt;     to the type it is declared in.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;      *<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         |#Self| expands to the static type of the code it is declared<br>&gt;&gt;&gt;         within. In value types, this is always the same as |Self|. In<br>&gt;&gt;&gt;         reference types, it refers to the declaring type. |#Self| will<br>&gt;&gt;&gt;         offer a literal textual replacement just like |#file|, etc.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; At Chris&#39;s suggestion, I&#39;m starting a new SE thread to see whether there<br>&gt;&gt;&gt; remains any interest for including #Self in the language. I&#39;m personally<br>&gt;&gt;&gt; happy with the SE-0068 outcome but I didn&#39;t want to undercut anyone like<br>&gt;&gt;&gt; Timothy Wood who had originally spoken up for its inclusion.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -- E<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[RFC] #Self</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 10, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On May 10, 2016, at 10:34 AM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; What about #Self in protocols? I.e. is it proposed to have #Self in protocols, where conformance will require a substitution by real type name?<br>&gt; <br>&gt; protocol A {<br>&gt;    func a() -&gt; Self<br>&gt;    func b(c: Self) // b(c: #Self)   ?<br>&gt; }<br></p><p>Self and #Self are different for non-final classes.  In protocol requirements Self would covary and #Self would be fixed by the class that provides conformance.  The distinction is pretty subtle and is <br></p><p>protocol A {<br>   func a() -&gt; Self<br>   func b(c: #Self)<br>}<br></p><p>&gt; <br>&gt; class C: A {<br>&gt;    func a() -&gt; Self { return self }<br>&gt;    func b(c: C) {} // b(c: #Self) ?<br>&gt; }<br></p><p>C is non-final so we must be careful.  C and #Self both refer to the same thing.  Self covaries and would thus refer to the dynamic type of the instance in both signatures and bodies.  This means that a method returning Self must be overridden by all subclasses in order to return the correct type.<br></p><p>One of the advantages of allowing #Self in protocol requirements is that it is one way to solve a problem that has receive significant discussion on the list in the past: retroactively conforming non-final classes to protocols with factory methods that do not need to covary.  There is no way to express a this kind of requirement in the language today.<br></p><p>&gt; <br>&gt; <br>&gt; protocol A2 {<br>&gt;    var a: Self {get}<br>&gt; }<br>&gt; <br>&gt; final class C2 : A2 {<br>&gt;    var a: C2 { return C2() } // #Self { return #Self() }  ?<br>&gt; }<br></p><p>In final classes and value types the type name itself (C2 in this example), Self, and #Self would all reference the same thing.<br></p><p>&gt; <br>&gt; On 10.05.2016 17:50, Erica Sadun via swift-evolution wrote:<br>&gt;&gt; As a compile-time substitution, it could be used in any and all of the<br>&gt;&gt; examples in your bullet list as a literal text replacement..<br>&gt;&gt; <br>&gt;&gt; Quick rundown:<br>&gt;&gt; <br>&gt;&gt; struct A {<br>&gt;&gt;   ...#Self... // #Self is substituted by A<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class B {<br>&gt;&gt;    ...#Self... // Self is substituted by B<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class C {<br>&gt;&gt;   ... #Self... // Self is substituted by C, which is the defining type at<br>&gt;&gt; compile time<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I&#39;m stepping away from endorsing or pushing this forward. If you want to<br>&gt;&gt; pick this up and run with it, it&#39;s yours.<br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 10, 2016, at 8:34 AM, Matthew Johnson &lt;matthew at anandabits.com<br>&gt;&gt;&gt; &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Can you clarify where would #Self would be allowed?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * property declarations<br>&gt;&gt;&gt; * method signatures<br>&gt;&gt;&gt; * method and computed property bodies<br>&gt;&gt;&gt; * all of the above<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would like to see this and allowed in all of the above.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We should also consider allowing this in protocol requirements.  It would<br>&gt;&gt;&gt; not covary like Self does for return types, instead being fixed by the<br>&gt;&gt;&gt; class that declares conformance.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On May 10, 2016, at 8:15 AM, Erica Sadun via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; To focus SE-0068 and narrow its scope, I removed the `#Self` part of the<br>&gt;&gt;&gt;&gt; proposal. This offered compile-time substitution of the defining type<br>&gt;&gt;&gt;&gt; for a related #Self literal:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    A further static identifier, |#Self| expands to static type of the<br>&gt;&gt;&gt;&gt;    code it appears within, completing the ways code may want to refer<br>&gt;&gt;&gt;&gt;    to the type it is declared in.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     *<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;        |#Self| expands to the static type of the code it is declared<br>&gt;&gt;&gt;&gt;        within. In value types, this is always the same as |Self|. In<br>&gt;&gt;&gt;&gt;        reference types, it refers to the declaring type. |#Self| will<br>&gt;&gt;&gt;&gt;        offer a literal textual replacement just like |#file|, etc.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; At Chris&#39;s suggestion, I&#39;m starting a new SE thread to see whether there<br>&gt;&gt;&gt;&gt; remains any interest for including #Self in the language. I&#39;m personally<br>&gt;&gt;&gt;&gt; happy with the SE-0068 outcome but I didn&#39;t want to undercut anyone like<br>&gt;&gt;&gt;&gt; Timothy Wood who had originally spoken up for its inclusion.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- E<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[RFC] #Self</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 10, 2016 at 07:00:00pm</p></header><div class="content"><p>Thank you for answers, just to clarify:<br></p><p>On 10.05.2016 18:47, Matthew Johnson wrote:<br>&gt;<br>&gt;&gt; On May 10, 2016, at 10:34 AM, Vladimir.S via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; What about #Self in protocols? I.e. is it proposed to have #Self in<br>&gt;&gt; protocols, where conformance will require a substitution by real type<br>&gt;&gt; name?<br>&gt;&gt;<br>&gt;&gt; protocol A { func a() -&gt; Self func b(c: Self) // b(c: #Self)   ? }<br>&gt;<br>&gt; Self and #Self are different for non-final classes.  In protocol<br>&gt; requirements Self would covary and #Self would be fixed by the class<br>&gt; that provides conformance.  The distinction is pretty subtle and is<br>&gt;<br>&gt; protocol A { func a() -&gt; Self func b(c: #Self) }<br></p><p>Yes, Self and #Self sometimes is not the same, and sometimes is the same.<br>Here I asked about b() method. No questions regarding a() method.<br></p><p>So, after #Self will be introduced, this definition will be correct:<br></p><p>protocol A {<br>	func a() -&gt; Self<br>	func b(c: #Self)<br>}<br></p><p>and be exactly the same as<br></p><p>protocol A {<br>	func a() -&gt; Self<br>	func b(c: Self)<br>}<br></p><p>Will both variants coexist? I&#39;d prefer compiler to be strict in this case <br>and allows only #Self in b() method, as this is more correct and explicit <br>declaration, i.e. func b(c: Self) in protocol A really means func b(c: <br>#Self). No?<br></p><p>&gt;<br>&gt;&gt;<br>&gt;&gt; class C: A { func a() -&gt; Self { return self } func b(c: C) {} // b(c:<br>&gt;&gt; #Self) ? }<br>&gt;<br>&gt; C is non-final so we must be careful.  C and #Self both refer to the<br>&gt; same thing.  Self covaries and would thus refer to the dynamic type of<br>&gt; the instance in both signatures and bodies.  This means that a method<br>&gt; returning Self must be overridden by all subclasses in order to return<br>&gt; the correct type.<br></p><p>Yes, I believe it is all clear with a() method. This is why I placed the <br>commend with #Self for `b` method only<br></p><p>&gt;<br>&gt; One of the advantages of allowing #Self in protocol requirements is that<br>&gt; it is one way to solve a problem that has receive significant discussion<br>&gt; on the list in the past: retroactively conforming non-final classes to<br>&gt; protocols with factory methods that do not need to covary.  There is no<br>&gt; way to express a this kind of requirement in the language today.<br>&gt;<br></p><p>Could you please illustrate this in a couple lines of code? Just to fully <br>understand.<br></p><p>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; protocol A2 { var a: Self {get} }<br>&gt;&gt;<br>&gt;&gt; final class C2 : A2 { var a: C2 { return C2() } // #Self { return<br>&gt;&gt; #Self() }  ? }<br>&gt;<br>&gt; In final classes and value types the type name itself (C2 in this<br>&gt; example), Self, and #Self would all reference the same thing.<br>&gt;<br></p><p>Exactly in my example, you can&#39;t use `Self` keyword in class:<br></p><p>final class C2 : A2 {<br>     var a: Self { return Self() } // error<br>}<br></p><p>but I expect to be able to have:<br></p><p>final class C2 : A2 {<br>     var a: #Self { return #Self() }<br>}<br></p><p>&gt;&gt;<br>&gt;&gt; On 10.05.2016 17:50, Erica Sadun via swift-evolution wrote:<br>&gt;&gt;&gt; As a compile-time substitution, it could be used in any and all of<br>&gt;&gt;&gt; the examples in your bullet list as a literal text replacement..<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Quick rundown:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; struct A { ...#Self... // #Self is substituted by A }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; class B { ...#Self... // Self is substituted by B }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; class C { ... #Self... // Self is substituted by C, which is the<br>&gt;&gt;&gt; defining type at compile time }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;m stepping away from endorsing or pushing this forward. If you<br>&gt;&gt;&gt; want to pick this up and run with it, it&#39;s yours.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -- E<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On May 10, 2016, at 8:34 AM, Matthew Johnson<br>&gt;&gt;&gt;&gt; &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Can you clarify where would #Self would be allowed?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; * property declarations * method signatures * method and computed<br>&gt;&gt;&gt;&gt; property bodies * all of the above<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I would like to see this and allowed in all of the above.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; We should also consider allowing this in protocol requirements.<br>&gt;&gt;&gt;&gt; It would not covary like Self does for return types, instead being<br>&gt;&gt;&gt;&gt; fixed by the class that declares conformance.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On May 10, 2016, at 8:15 AM, Erica Sadun via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; To focus SE-0068 and narrow its scope, I removed the `#Self`<br>&gt;&gt;&gt;&gt;&gt; part of the proposal. This offered compile-time substitution of<br>&gt;&gt;&gt;&gt;&gt; the defining type for a related #Self literal:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; A further static identifier, |#Self| expands to static type of<br>&gt;&gt;&gt;&gt;&gt; the code it appears within, completing the ways code may want to<br>&gt;&gt;&gt;&gt;&gt; refer to the type it is declared in.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; *<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; |#Self| expands to the static type of the code it is declared<br>&gt;&gt;&gt;&gt;&gt; within. In value types, this is always the same as |Self|. In<br>&gt;&gt;&gt;&gt;&gt; reference types, it refers to the declaring type. |#Self| will<br>&gt;&gt;&gt;&gt;&gt; offer a literal textual replacement just like |#file|, etc.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; At Chris&#39;s suggestion, I&#39;m starting a new SE thread to see<br>&gt;&gt;&gt;&gt;&gt; whether there remains any interest for including #Self in the<br>&gt;&gt;&gt;&gt;&gt; language. I&#39;m personally happy with the SE-0068 outcome but I<br>&gt;&gt;&gt;&gt;&gt; didn&#39;t want to undercut anyone like Timothy Wood who had<br>&gt;&gt;&gt;&gt;&gt; originally spoken up for its inclusion.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; -- E<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt;&gt;&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[RFC] #Self</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 10, 2016 at 11:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 10, 2016, at 11:25 AM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt; <br>&gt; Thank you for answers, just to clarify:<br>&gt; <br>&gt;&gt; On 10.05.2016 18:47, Matthew Johnson wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On May 10, 2016, at 10:34 AM, Vladimir.S via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What about #Self in protocols? I.e. is it proposed to have #Self in<br>&gt;&gt;&gt; protocols, where conformance will require a substitution by real type<br>&gt;&gt;&gt; name?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol A { func a() -&gt; Self func b(c: Self) // b(c: #Self)   ? }<br>&gt;&gt; <br>&gt;&gt; Self and #Self are different for non-final classes.  In protocol<br>&gt;&gt; requirements Self would covary and #Self would be fixed by the class<br>&gt;&gt; that provides conformance.  The distinction is pretty subtle and is<br>&gt;&gt; <br>&gt;&gt; protocol A { func a() -&gt; Self func b(c: #Self) }<br>&gt; <br>&gt; Yes, Self and #Self sometimes is not the same, and sometimes is the same.<br>&gt; Here I asked about b() method. No questions regarding a() method.<br>&gt; <br>&gt; So, after #Self will be introduced, this definition will be correct:<br>&gt; <br>&gt; protocol A {<br>&gt;    func a() -&gt; Self<br>&gt;    func b(c: #Self)<br>&gt; }<br>&gt; <br>&gt; and be exactly the same as<br>&gt; <br>&gt; protocol A {<br>&gt;    func a() -&gt; Self<br>&gt;    func b(c: Self)<br>&gt; }<br>&gt; <br>&gt; Will both variants coexist? I&#39;d prefer compiler to be strict in this case and allows only #Self in b() method, as this is more correct and explicit declaration, i.e. func b(c: Self) in protocol A really means func b(c: #Self). No?<br></p><p>Agree.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class C: A { func a() -&gt; Self { return self } func b(c: C) {} // b(c:<br>&gt;&gt;&gt; #Self) ? }<br>&gt;&gt; <br>&gt;&gt; C is non-final so we must be careful.  C and #Self both refer to the<br>&gt;&gt; same thing.  Self covaries and would thus refer to the dynamic type of<br>&gt;&gt; the instance in both signatures and bodies.  This means that a method<br>&gt;&gt; returning Self must be overridden by all subclasses in order to return<br>&gt;&gt; the correct type.<br>&gt; <br>&gt; Yes, I believe it is all clear with a() method. This is why I placed the commend with #Self for `b` method only<br>&gt; <br>&gt;&gt; <br>&gt;&gt; One of the advantages of allowing #Self in protocol requirements is that<br>&gt;&gt; it is one way to solve a problem that has receive significant discussion<br>&gt;&gt; on the list in the past: retroactively conforming non-final classes to<br>&gt;&gt; protocols with factory methods that do not need to covary.  There is no<br>&gt;&gt; way to express a this kind of requirement in the language today.<br>&gt;&gt; <br>&gt; <br>&gt; Could you please illustrate this in a couple lines of code? Just to fully understand.<br></p><p>protocol A {<br>  static func createWithString(s: String) -&gt; Self<br>}<br></p><p>extension NSURL: A {<br>  // cannot conform because NSURL is non-final<br>}<br></p><p>If we could define a protocol requirement that didn&#39;t covary (using #Self or whatever) we would be able to write the desired conformance.<br></p><p>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol A2 { var a: Self {get} }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; final class C2 : A2 { var a: C2 { return C2() } // #Self { return<br>&gt;&gt;&gt; #Self() }  ? }<br>&gt;&gt; <br>&gt;&gt; In final classes and value types the type name itself (C2 in this<br>&gt;&gt; example), Self, and #Self would all reference the same thing.<br>&gt;&gt; <br>&gt; <br>&gt; Exactly in my example, you can&#39;t use `Self` keyword in class:<br>&gt; <br>&gt; final class C2 : A2 {<br>&gt;    var a: Self { return Self() } // error<br>&gt; }<br>&gt; <br>&gt; but I expect to be able to have:<br>&gt; <br>&gt; final class C2 : A2 {<br>&gt;    var a: #Self { return #Self() }<br>&gt; }<br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 10.05.2016 17:50, Erica Sadun via swift-evolution wrote:<br>&gt;&gt;&gt;&gt; As a compile-time substitution, it could be used in any and all of<br>&gt;&gt;&gt;&gt; the examples in your bullet list as a literal text replacement..<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Quick rundown:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct A { ...#Self... // #Self is substituted by A }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class B { ...#Self... // Self is substituted by B }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class C { ... #Self... // Self is substituted by C, which is the<br>&gt;&gt;&gt;&gt; defining type at compile time }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m stepping away from endorsing or pushing this forward. If you<br>&gt;&gt;&gt;&gt; want to pick this up and run with it, it&#39;s yours.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- E<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 10, 2016, at 8:34 AM, Matthew Johnson<br>&gt;&gt;&gt;&gt;&gt; &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Can you clarify where would #Self would be allowed?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; * property declarations * method signatures * method and computed<br>&gt;&gt;&gt;&gt;&gt; property bodies * all of the above<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I would like to see this and allowed in all of the above.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; We should also consider allowing this in protocol requirements.<br>&gt;&gt;&gt;&gt;&gt; It would not covary like Self does for return types, instead being<br>&gt;&gt;&gt;&gt;&gt; fixed by the class that declares conformance.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 10, 2016, at 8:15 AM, Erica Sadun via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:sw<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[RFC] #Self</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 10, 2016 at 08:00:00pm</p></header><div class="content"><p>As I understand, please correct me, this proposal will not solve this <br>problem. The proposed solution just to introduce #Self as replacement for <br>concrete name of currently declared type.<br></p><p>And actually I think(I don&#39;t understand?) something is wrong with what you <br>want to achieve..<br></p><p>Let&#39;s imagine we have non-final class:<br></p><p>class C {<br>     static func f() -&gt; C { return C() }<br>}<br></p><p>and, as class is not final, we can have subclasses :<br></p><p>class D : C {<br>}<br></p><p>Now we introduce the protocol:<br></p><p>protocol A {<br>     static func f() -&gt; #Self  // let&#39;s imagine #Self can be in this place<br>                           // in test code I used C instead of #Self here<br>}<br></p><p>And conform C to A, so this says &quot;C will return C when we call f()&quot;<br></p><p>extension C: A {<br>   // let&#39;s imagine it is OK here, C.f() returns #Self which is C<br>}<br></p><p>But now, we have a problem with D - as C conforms to protocol A, D also <br>conforms to protocol A :<br></p><p>var c = C()<br>var d = D()<br></p><p>if c is A {print(&quot;c is A&quot;)}  // c is A<br>if d is A {print(&quot;d is A&quot;)}  // d is A<br></p><p>But...<br></p><p>print(C.f())  // main.C<br>print(D.f())  // main.C oops! D.f() does not return its #Self, i.e. main.D<br></p><p><br>On 10.05.2016 19:37, Matthew Johnson wrote:<br>&gt;&gt;&gt; Could you please illustrate this in a couple lines of code? Just to<br>&gt;&gt;&gt; fully understand.<br>&gt; protocol A { static func createWithString(s: String) -&gt; Self }<br>&gt;<br>&gt; extension NSURL: A { // cannot conform because NSURL is non-final }<br>&gt;<br>&gt; If we could define a protocol requirement that didn&#39;t covary (using<br>&gt; #Self or whatever) we would be able to write the desired conformance.<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[RFC] #Self</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 10, 2016 at 12:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 10, 2016, at 12:33 PM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt; <br>&gt; As I understand, please correct me, this proposal will not solve this problem. The proposed solution just to introduce #Self as replacement for concrete name of currently declared type.<br>&gt; <br>&gt; And actually I think(I don&#39;t understand?) something is wrong with what you want to achieve..<br>&gt; <br>&gt; Let&#39;s imagine we have non-final class:<br>&gt; <br>&gt; class C {<br>&gt;    static func f() -&gt; C { return C() }<br>&gt; }<br>&gt; <br>&gt; and, as class is not final, we can have subclasses :<br>&gt; <br>&gt; class D : C {<br>&gt; }<br>&gt; <br>&gt; Now we introduce the protocol:<br>&gt; <br>&gt; protocol A {<br>&gt;    static func f() -&gt; #Self  // let&#39;s imagine #Self can be in this place<br>&gt;                          // in test code I used C instead of #Self here<br>&gt; }<br>&gt; <br>&gt; And conform C to A, so this says &quot;C will return C when we call f()&quot;<br>&gt; <br>&gt; extension C: A {<br>&gt;  // let&#39;s imagine it is OK here, C.f() returns #Self which is C<br>&gt; }<br>&gt; <br>&gt; But now, we have a problem with D - as C conforms to protocol A, D also conforms to protocol A :<br>&gt; <br>&gt; var c = C()<br>&gt; var d = D()<br>&gt; <br>&gt; if c is A {print(&quot;c is A&quot;)}  // c is A<br>&gt; if d is A {print(&quot;d is A&quot;)}  // d is A<br>&gt; <br>&gt; But...<br>&gt; <br>&gt; print(C.f())  // main.C<br>&gt; print(D.f())  // main.C oops! D.f() does not return its #Self, i.e. main.D<br></p><p>No, the whole point is that D.f() returns C because C is the requirement of &#39;f&#39; is declared to return #Self which is C where the protocol conformance is declared and implemented.  If you want a covariant requirement you would use Self as the return type, not #Self.<br></p><p><br>&gt; <br>&gt; <br>&gt; On 10.05.2016 19:37, Matthew Johnson wrote:<br>&gt;&gt;&gt;&gt; Could you please illustrate this in a couple lines of code? Just to<br>&gt;&gt;&gt;&gt; fully understand.<br>&gt;&gt; protocol A { static func createWithString(s: String) -&gt; Self }<br>&gt;&gt; <br>&gt;&gt; extension NSURL: A { // cannot conform because NSURL is non-final }<br>&gt;&gt; <br>&gt;&gt; If we could define a protocol requirement that didn&#39;t covary (using<br>&gt;&gt; #Self or whatever) we would be able to write the desired conformance.<br>&gt;&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[RFC] #Self</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 10, 2016 at 09:00:00pm</p></header><div class="content"><p>On 10.05.2016 20:50, Matthew Johnson wrote:<br>&gt; No, the whole point is that D.f() returns C because C is the requirement<br>&gt; of &#39;f&#39; is declared to return #Self which is C where the protocol<br>&gt; conformance is declared and implemented.  If you want a covariant<br>&gt; requirement you would use Self as the return type, not #Self.<br></p><p>I just followed your example with NSURL.. Probably I don&#39;t understand the <br>point, but you said you want to conform a non-final class to protocol with <br>method -&gt; #Self.<br></p><p> &gt;---------------------&lt;<br>protocol A { static func createWithString(s: String) -&gt; Self }<br>extension NSURL: A { // cannot conform because NSURL is non-final }<br></p><p>If we could define a protocol requirement that didn&#39;t covary (using<br>#Self or whatever) we would be able to write the desired conformance.<br> &gt;---------------------&lt;<br></p><p>And I don&#39;t understand how do you want to achieve the target, as even if we <br>&#39;invent&#39; #Self, this (as I understand) can&#39;t work as class is not final. <br>Just like with &#39;simple&#39; Self - class must be final to conform. Thank you <br>for clarification.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[RFC] #Self</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 10, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On May 10, 2016, at 1:38 PM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt; <br>&gt; On 10.05.2016 20:50, Matthew Johnson wrote:<br>&gt;&gt; No, the whole point is that D.f() returns C because C is the requirement<br>&gt;&gt; of &#39;f&#39; is declared to return #Self which is C where the protocol<br>&gt;&gt; conformance is declared and implemented.  If you want a covariant<br>&gt;&gt; requirement you would use Self as the return type, not #Self.<br>&gt; <br>&gt; I just followed your example with NSURL.. Probably I don&#39;t understand the point, but you said you want to conform a non-final class to protocol with method -&gt; #Self.<br>&gt; <br>&gt; &gt;---------------------&lt;<br>&gt; protocol A { static func createWithString(s: String) -&gt; Self }<br>&gt; extension NSURL: A { // cannot conform because NSURL is non-final }<br>&gt; <br>&gt; If we could define a protocol requirement that didn&#39;t covary (using<br>&gt; #Self or whatever) we would be able to write the desired conformance.<br>&gt; &gt;---------------------&lt;<br>&gt; <br>&gt; And I don&#39;t understand how do you want to achieve the target, as even if we &#39;invent&#39; #Self, this (as I understand) can&#39;t work as class is not final. Just like with &#39;simple&#39; Self - class must be final to conform. Thank you for clarification.<br></p><p>No, class would not need to be final to conform to a requirement returning #Self.  The difference is that with Self covaries and #Self does not.  This means you do not need to guarantee that all subclasses override a requirement that returns #Self, while you do need to guarantee that all subclasses override a requirement that returns Self.  <br></p><p>The requirement to guarantee that all subclasses provide this override is the reason you cannot declare conformance in the case of requirements returning Self.  Since this isnâ€™t necessary for #Self (will probably have a different name) the class does not need to be final in order to conform.<br></p><p>-Matthew<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[RFC] #Self</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 11, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; No, class would not need to be final to conform to a requirement <br>returning #Self.  The difference is that with Self covaries and #Self does <br>not.  This means you *do not need* to guarantee that all subclasses <br>override a requirement that returns #Self, while you do need to guarantee <br>that all subclasses override a requirement that returns Self.<br></p><p>I&#39;m probably slow these day, but I(and probably someone else) just can&#39;t <br>understand this. Thank you for your patience in explaining this:<br>Just after you conforms *base* class to *any* protocol, any possible <br>subclass *must* (you *have to* guarantee this) conform the same protocol.<br></p><p>class A {..}<br>class B:A {..}<br>class C:A {..}<br>protocol D {..}<br>extension A: D {}<br>-&gt; now B&amp;C and any other existed and *possible* subclass *must* conforms to <br>the same protocol D just because of inheritance. As soon as they are <br>subclass of A, they *must* be `is D` and *must* have the methods that <br>return #Self. No?<br></p><p>On 10.05.2016 22:04, Matthew Johnson wrote:<br>&gt;<br>&gt;&gt; On May 10, 2016, at 1:38 PM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On 10.05.2016 20:50, Matthew Johnson wrote:<br>&gt;&gt;&gt; No, the whole point is that D.f() returns C because C is the requirement<br>&gt;&gt;&gt; of &#39;f&#39; is declared to return #Self which is C where the protocol<br>&gt;&gt;&gt; conformance is declared and implemented.  If you want a covariant<br>&gt;&gt;&gt; requirement you would use Self as the return type, not #Self.<br>&gt;&gt;<br>&gt;&gt; I just followed your example with NSURL.. Probably I don&#39;t understand the point, but you said you want to conform a non-final class to protocol with method -&gt; #Self.<br>&gt;&gt;<br>&gt;&gt;&gt; ---------------------&lt;<br>&gt;&gt; protocol A { static func createWithString(s: String) -&gt; Self }<br>&gt;&gt; extension NSURL: A { // cannot conform because NSURL is non-final }<br>&gt;&gt;<br>&gt;&gt; If we could define a protocol requirement that didn&#39;t covary (using<br>&gt;&gt; #Self or whatever) we would be able to write the desired conformance.<br>&gt;&gt;&gt; ---------------------&lt;<br>&gt;&gt;<br>&gt;&gt; And I don&#39;t understand how do you want to achieve the target, as even if we &#39;invent&#39; #Self, this (as I understand) can&#39;t work as class is not final. Just like with &#39;simple&#39; Self - class must be final to conform. Thank you for clarification.<br>&gt;<br>&gt; No, class would not need to be final to conform to a requirement returning #Self.  The difference is that with Self covaries and #Self does not.  This means you do not need to guarantee that all subclasses override a requirement that returns #Self, while you do need to guarantee that all subclasses override a requirement that returns Self.<br>&gt;<br>&gt; The requirement to guarantee that all subclasses provide this override is the reason you cannot declare conformance in the case of requirements returning Self.  Since this isnâ€™t necessary for #Self (will probably have a different name) the class does not need to be final in order to conform.<br>&gt;<br>&gt; -Matthew<br>&gt;<br>&gt; .<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[RFC] #Self</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 11, 2016 at 08:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 11, 2016, at 1:22 AM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt; <br>&gt; &gt; No, class would not need to be final to conform to a requirement returning #Self.  The difference is that with Self covaries and #Self does not.  This means you *do not need* to guarantee that all subclasses override a requirement that returns #Self, while you do need to guarantee that all subclasses override a requirement that returns Self.<br>&gt; <br>&gt; I&#39;m probably slow these day, but I(and probably someone else) just can&#39;t understand this. Thank you for your patience in explaining this:<br>&gt; Just after you conforms *base* class to *any* protocol, any possible subclass *must* (you *have to* guarantee this) conform the same protocol.<br>&gt; <br>&gt; class A {..}<br>&gt; class B:A {..}<br>&gt; class C:A {..}<br>&gt; protocol D {..}<br>&gt; extension A: D {}<br>&gt; -&gt; now B&amp;C and any other existed and *possible* subclass *must* conforms to the same protocol D just because of inheritance. As soon as they are subclass of A, they *must* be `is D` and *must* have the methods that return #Self. No?<br></p><p>Yes, they must and will conform.  The distinction is that if the protocol has requirements returning Self all subclasses must override those requirements and to return their type because the inherited implementation returns their supertype.  With #Self (or Type as we&#39;re now calling it) they would not need to override those requirements because the ancestor that initially declared conformance provides an inherited implementation that remains valid for all of its descendants.<br></p><p>&gt; <br>&gt;&gt; On 10.05.2016 22:04, Matthew Johnson wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On May 10, 2016, at 1:38 PM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 10.05.2016 20:50, Matthew Johnson wrote:<br>&gt;&gt;&gt;&gt; No, the whole point is that D.f() returns C because C is the requirement<br>&gt;&gt;&gt;&gt; of &#39;f&#39; is declared to return #Self which is C where the protocol<br>&gt;&gt;&gt;&gt; conformance is declared and implemented.  If you want a covariant<br>&gt;&gt;&gt;&gt; requirement you would use Self as the return type, not #Self.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I just followed your example with NSURL.. Probably I don&#39;t understand the point, but you said you want to conform a non-final class to protocol with method -&gt; #Self.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ---------------------&lt;<br>&gt;&gt;&gt; protocol A { static func createWithString(s: String) -&gt; Self }<br>&gt;&gt;&gt; extension NSURL: A { // cannot conform because NSURL is non-final }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If we could define a protocol requirement that didn&#39;t covary (using<br>&gt;&gt;&gt; #Self or whatever) we would be able to write the desired conformance.<br>&gt;&gt;&gt;&gt; ---------------------&lt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And I don&#39;t understand how do you want to achieve the target, as even if we &#39;invent&#39; #Self, this (as I understand) can&#39;t work as class is not final. Just like with &#39;simple&#39; Self - class must be final to conform. Thank you for clarification.<br>&gt;&gt; <br>&gt;&gt; No, class would not need to be final to conform to a requirement returning #Self.  The difference is that with Self covaries and #Self does not.  This means you do not need to guarantee that all subclasses override a requirement that returns #Self, while you do need to guarantee that all subclasses override a requirement that returns Self.<br>&gt;&gt; <br>&gt;&gt; The requirement to guarantee that all subclasses provide this override is the reason you cannot declare conformance in the case of requirements returning Self.  Since this isnâ€™t necessary for #Self (will probably have a different name) the class does not need to be final in order to conform.<br>&gt;&gt; <br>&gt;&gt; -Matthew<br>&gt;&gt; <br>&gt;&gt; .<br>&gt;&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[RFC] #Self</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 11, 2016 at 05:00:00pm</p></header><div class="content"><p>On 11.05.2016 16:42, Matthew Johnson wrote:<br>&gt; With #Self (or Type as we&#39;re now calling it) they would not need to<br>&gt; override those requirements because the ancestor that initially declared<br>&gt; conformance provides an inherited implementation that remains valid for<br>&gt; all of its descendants.<br></p><p>OK.. I see your point, thank you. But probably we thinks differently about <br>the #Self &#39;behavior&#39; and how it should be treated in case of protocol <br>conformance.<br></p><p>First of all, the initial proposal (which I base all my understanding on):<br>On 10.05.2016 16:15, Erica Sadun via swift-evolution wrote:<br> &gt;----------------------------------&lt;<br>To focus SE-0068 and narrow its scope, I removed the `#Self` part of the <br>proposal. This offered compile-time substitution of the defining type for a <br>related #Self literal:<br></p><p>     A further static identifier, #Self expands to static type of the code <br>it appears within, completing the ways code may want to refer to the type <br>it is declared in.<br></p><p>         #Self expands to the static type of the code it is declared <br>within. In value types, this is always the same as Self. In reference <br>types, it refers to the declaring type. #Self will offer a literal textual <br>replacement just like #file, etc.<br> &gt;----------------------------------&lt;<br></p><p>So, again, we have protocol<br></p><p>protocol A {<br>   func f()-&gt;#Self<br>}<br></p><p>What does it mean for me? : Each class C, conformed to protocol A, should <br>have func f() that returns exactly this class.<br></p><p>so, let&#39;s have<br></p><p>class B: A {<br>   func f()-&gt;B {} // conforms to protocol<br>// or could be written as(the same):<br>//func f()-&gt;#Self {} // conforms to protocol<br>}<br></p><p>class C: A {<br>   func f()-&gt;C {} // conforms to protocol<br>}<br></p><p>class D: A {<br>   func f()-&gt;D {} // conforms to protocol<br>}<br></p><p>and now, you want to conform some existed non-final class to A protocol:<br></p><p>class E {<br>   func f()-&gt;E {} // just has such method<br>}<br></p><p>extension E: A {} // seems like OK at this step<br></p><p>after this, what&#39;s the state of some existed derived from E classes ?<br></p><p>class F: E {}<br>class G: F {}<br></p><p>You conformed the base class E to A protocol. This automatically *reuqire* <br>that F &amp; G also conforms to A protocol. They *must* be `is A`.<br>But I insist, they does not conform to A protocol as I understand the #Self <br>proposal.<br></p><p>F().f() *must*(because of protocol A) return instance of F, but F only has <br>f()-&gt;C from base class<br></p><p>G().f() *must*(because of protocol A) return instance of G, but G only has <br>f()-&gt;C from base class<br></p><p>This is why I don&#39;t understand how #Self could help to achieve the target <br>with NSURL conformance.<br>These are my points. Please point if I&#39;m wrong somewhere.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[RFC] #Self</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 11, 2016 at 09:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 11, 2016, at 9:33 AM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; On 11.05.2016 16:42, Matthew Johnson wrote:<br>&gt;&gt; With #Self (or Type as we&#39;re now calling it) they would not need to<br>&gt;&gt; override those requirements because the ancestor that initially declared<br>&gt;&gt; conformance provides an inherited implementation that remains valid for<br>&gt;&gt; all of its descendants.<br>&gt; <br>&gt; OK.. I see your point, thank you. But probably we thinks differently about the #Self &#39;behavior&#39; and how it should be treated in case of protocol conformance.<br>&gt; <br>&gt; First of all, the initial proposal (which I base all my understanding on):<br>&gt; On 10.05.2016 16:15, Erica Sadun via swift-evolution wrote:<br>&gt; &gt;----------------------------------&lt;<br>&gt; To focus SE-0068 and narrow its scope, I removed the `#Self` part of the proposal. This offered compile-time substitution of the defining type for a related #Self literal:<br>&gt; <br>&gt;    A further static identifier, #Self expands to static type of the code it appears within, completing the ways code may want to refer to the type it is declared in.<br>&gt; <br>&gt;        #Self expands to the static type of the code it is declared within. In value types, this is always the same as Self. In reference types, it refers to the declaring type. #Self will offer a literal textual replacement just like #file, etc.<br>&gt; &gt;----------------------------------&lt;<br>&gt; <br>&gt; So, again, we have protocol<br>&gt; <br>&gt; protocol A {<br>&gt;  func f()-&gt;#Self<br>&gt; }<br>&gt; <br>&gt; What does it mean for me? : Each class C, conformed to protocol A, should have func f() that returns exactly this class.<br>&gt; <br>&gt; so, let&#39;s have<br>&gt; <br>&gt; class B: A {<br>&gt;  func f()-&gt;B {} // conforms to protocol<br>&gt; // or could be written as(the same):<br>&gt; //func f()-&gt;#Self {} // conforms to protocol<br>&gt; }<br>&gt; <br>&gt; class C: A {<br>&gt;  func f()-&gt;C {} // conforms to protocol<br>&gt; }<br>&gt; <br>&gt; class D: A {<br>&gt;  func f()-&gt;D {} // conforms to protocol<br>&gt; }<br>&gt; <br>&gt; and now, you want to conform some existed non-final class to A protocol:<br>&gt; <br>&gt; class E {<br>&gt;  func f()-&gt;E {} // just has such method<br>&gt; }<br>&gt; <br>&gt; extension E: A {} // seems like OK at this step<br>&gt; <br>&gt; after this, what&#39;s the state of some existed derived from E classes ?<br>&gt; <br>&gt; class F: E {}<br>&gt; class G: F {}<br>&gt; <br>&gt; You conformed the base class E to A protocol. This automatically *reuqire* that F &amp; G also conforms to A protocol. They *must* be `is A`.<br>&gt; But I insist, they does not conform to A protocol as I understand the #Self proposal.<br>&gt; <br>&gt; F().f() *must*(because of protocol A) return instance of F, but F only has f()-&gt;C from base class<br>&gt; <br>&gt; G().f() *must*(because of protocol A) return instance of G, but G only has f()-&gt;C from base class<br></p><p>I think you meant E here, not C.<br></p><p>&gt; <br>&gt; This is why I don&#39;t understand how #Self could help to achieve the target with NSURL conformance.<br>&gt; These are my points. Please point if I&#39;m wrong somewhere.<br></p><p>You are describing the behavior of Self, not #Self.  <br></p><p>&gt;        #Self expands to the static type of the code it is declared within. In value types, this is always the same as Self. In reference types, it refers to the declaring type.<br></p><p>For implementations of protocol requirements the declaring type is the type that declares conformance.<br></p><p>Self is covariant, #Self (or Type) is invariant.  That is the difference.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160511/9ae33835/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[RFC] #Self</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 11, 2016 at 06:00:00pm</p></header><div class="content"><p>On 11.05.2016 17:42, Matthew Johnson wrote:<br>&gt; You are describing the behavior of Self, not #Self.<br></p><p>Well.. Yes :-) I.e. I wanted to show that `-&gt;#Self` requirement in <br>protocol(from my point of view) will produce issues just like `-&gt;Self`<br></p><p><br>&gt;<br>&gt;&gt;        #Self expands to the static type of the code it is declared<br>&gt;&gt; within. In value types, this is always the same as Self. In reference<br>&gt;&gt; types, it refers to the *declaring* type.<br>&gt;<br>&gt; For implementations of protocol requirements the declaring type is the type<br>&gt; that declares conformance.<br>&gt;<br>&gt; Self is covariant, #Self (or Type) is invariant.  That is the difference.<br></p><p>There is some misunderstanding between us.<br>Most likely this is because of my terrible English. (Btw, sorry for this)<br></p><p>I just can&#39;t understand, how do you understand the `A` protocol conformance <br>for F &amp; G classes in my examples?<br></p><p>In your word, with implemented #Self, F &amp; G `is A` ? If so, how exactly <br>they conform to protocol that says F &amp; G *must* have `f` that returns <br>#Self. What is #Self for F &amp; G classes that should be returned in f()?<br>Right now I think that your idea just can not be implemented at all based <br>on *initial* #Self proposal.<br></p><p>Probably you(we) need another proposal, like BaseSelf (or SuperSelf) that <br>means &quot;this class or any its base class&quot;, then I understand how such a <br>`f()-&gt;BaseSelf` protocol requirement can be applied to E class and also be <br>true for F&amp;G classes (as f() inherited from base class will return instance <br>of E which is base for both).<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[RFC] #Self</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 11, 2016 at 10:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 11, 2016, at 10:43 AM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 11.05.2016 17:42, Matthew Johnson wrote:<br>&gt;&gt; You are describing the behavior of Self, not #Self.<br>&gt; <br>&gt; Well.. Yes :-) I.e. I wanted to show that `-&gt;#Self` requirement in protocol(from my point of view) will produce issues just like `-&gt;Self`<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;       #Self expands to the static type of the code it is declared<br>&gt;&gt;&gt; within. In value types, this is always the same as Self. In reference<br>&gt;&gt;&gt; types, it refers to the *declaring* type.<br>&gt;&gt; <br>&gt;&gt; For implementations of protocol requirements the declaring type is the type<br>&gt;&gt; that declares conformance.<br>&gt;&gt; <br>&gt;&gt; Self is covariant, #Self (or Type) is invariant.  That is the difference.<br>&gt; <br>&gt; There is some misunderstanding between us.<br>&gt; Most likely this is because of my terrible English. (Btw, sorry for this)<br>&gt; <br>&gt; I just can&#39;t understand, how do you understand the `A` protocol conformance for F &amp; G classes in my examples?<br>&gt; <br>&gt; In your word, with implemented #Self, F &amp; G `is A` ? If so, how exactly they conform to protocol that says F &amp; G *must* have `f` that returns #Self. What is #Self for F &amp; G classes that should be returned in f()?<br>&gt; Right now I think that your idea just can not be implemented at all based on *initial* #Self proposal.<br></p><p>&#39;f&#39; would return E for E, F and G.  Because the conformance is declared by E the requirement to return #Self is fixed as an invariant requirement to return E for all potential subclasses.<br></p><p>&gt; <br>&gt; Probably you(we) need another proposal, like BaseSelf (or SuperSelf) that means &quot;this class or any its base class&quot;, then I understand how such a `f()-&gt;BaseSelf` protocol requirement can be applied to E class and also be true for F&amp;G classes (as f() inherited from base class will return instance of E which is base for both).<br></p><p>This is exactly what #Self (or Type) does.  The behavior you have been describing is the behavior of Self which already exists.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[RFC] #Self</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 11, 2016 at 07:00:00pm</p></header><div class="content"><p>Well, I believe I understand now what *you mean* under #Self. OK. Thank you <br>for clarifications.<br>In my terminology &#39;this&#39; could be called BaseSelf. Your &quot;thing&quot; just can <br>not be called #Self.<br>IMO in initial proposal #Self means not more than placeholder for the <br>concrete type name(inside type declaration or inside protocol).<br></p><p>You propose just something different, more advanced than initial #Self, you <br>propose not some static &quot;thing&quot; but extended behavior if #Self is a return <br>type of protocol requirement.<br></p><p>I strictly against to couple the initial proposal of #Self and your <br>proposal for extended features (for protocol conformance of `-&gt;#Self`).<br>Please be clear and obvious regarding the name of that feature. I really <br>think the behavior you propose can not be called #Self(or Type)<br></p><p>What I suggest: de-couple these proposals to:<br></p><p>a) initial proposal of #Self as placeholder for concrete type name. Choose <br>the name for it. Probably StaticSelf, or Type, or somehting else<br></p><p>b) your proposal for BaseSelf feature. I&#39;ll definitely support it with just <br>name changed to clearly reflect its propose.<br></p><p>On 11.05.2016 18:58, Matthew Johnson wrote:<br>&gt; &#39;f&#39; would return E for E, F and G.  Because the conformance is declared<br>&gt; by E the requirement to return #Self is fixed as an invariant<br>&gt; requirement to return E for all potential subclasses.<br>&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Probably you(we) need another proposal, like BaseSelf (or SuperSelf)<br>&gt;&gt;&gt; that means &quot;this class or any its base class&quot;, then I understand how<br>&gt;&gt;&gt; such a `f()-&gt;BaseSelf` protocol requirement can be applied to E<br>&gt;&gt;&gt; class and also be true for F&amp;G classes (as f() inherited from base<br>&gt;&gt;&gt; class will return instance of E which is base for both).<br>&gt; This is exactly what #Self (or Type) does.  The behavior you have been<br>&gt; describing is the behavior of Self which already exists.<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[RFC] #Self</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 11, 2016 at 01:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 11, 2016, at 11:43 AM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt; <br>&gt; Well, I believe I understand now what *you mean* under #Self. OK. Thank you for clarifications.<br>&gt; In my terminology &#39;this&#39; could be called BaseSelf. Your &quot;thing&quot; just can not be called #Self.<br>&gt; IMO in initial proposal #Self means not more than placeholder for the concrete type name(inside type declaration or inside protocol).<br>&gt; <br>&gt; You propose just something different, more advanced than initial #Self, you propose not some static &quot;thing&quot; but extended behavior if #Self is a return type of protocol requirement.<br>&gt; <br>&gt; I strictly against to couple the initial proposal of #Self and your proposal for extended features (for protocol conformance of `-&gt;#Self`).<br>&gt; Please be clear and obvious regarding the name of that feature. I really think the behavior you propose can not be called #Self(or Type)<br>&gt; <br>&gt; What I suggest: de-couple these proposals to:<br>&gt; <br>&gt; a) initial proposal of #Self as placeholder for concrete type name. Choose the name for it. Probably StaticSelf, or Type, or somehting else<br>&gt; <br>&gt; b) your proposal for BaseSelf feature. I&#39;ll definitely support it with just name changed to clearly reflect its propose.<br></p><p>I don&#39;t believe the initial proposal stated how it would behave in a protocol.  However I do believe the feature I am talking about covers all of the use cases Erica had in mind while also providing useful semantics when used in a protocol requirement.  Erica, please correct me if I&#39;m wrong.<br></p><p>You want to make the semantics of #Self / Type be covariant when used in a protocol requirement.  This makes no sense to me as it is explicitly *not* covariant when used within a class declaration.  We already have a covariant construct (Self) and the proposal is to introduce an invariant construct (#Self or Type).  The invariant semantic should be consistent regardless of whether it is used in a protocol requirement or a type declaration.<br></p><p>IMO BaseSelf is a poor choice of name for something that is supposed to be valid syntax in value types as well as classes.<br></p><p>&gt; <br>&gt;&gt; On 11.05.2016 18:58, Matthew Johnson wrote:<br>&gt;&gt; &#39;f&#39; would return E for E, F and G.  Because the conformance is declared<br>&gt;&gt; by E the requirement to return #Self is fixed as an invariant<br>&gt;&gt; requirement to return E for all potential subclasses.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Probably you(we) need another proposal, like BaseSelf (or SuperSelf)<br>&gt;&gt;&gt;&gt; that means &quot;this class or any its base class&quot;, then I understand how<br>&gt;&gt;&gt;&gt; such a `f()-&gt;BaseSelf` protocol requirement can be applied to E<br>&gt;&gt;&gt;&gt; class and also be true for F&amp;G classes (as f() inherited from base<br>&gt;&gt;&gt;&gt; class will return instance of E which is base for both).<br>&gt;&gt; This is exactly what #Self (or Type) does.  The behavior you have been<br>&gt;&gt; describing is the behavior of Self which already exists.<br>&gt;&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[RFC] #Self</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 12, 2016 at 06:00:00pm</p></header><div class="content"><p>Inline<br></p><p>On 11.05.2016 21:31, Matthew Johnson wrote:<br>&gt;<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt;&gt; On May 11, 2016, at 11:43 AM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Well, I believe I understand now what *you mean* under #Self. OK.<br>&gt;&gt; Thank you for clarifications. In my terminology &#39;this&#39; could be called<br>&gt;&gt; BaseSelf. Your &quot;thing&quot; just can not be called #Self. IMO in initial<br>&gt;&gt; proposal #Self means not more than placeholder for the concrete type<br>&gt;&gt; name(inside type declaration or inside protocol).<br>&gt;&gt;<br>&gt;&gt; You propose just something different, more advanced than initial<br>&gt;&gt; #Self, you propose not some static &quot;thing&quot; but extended behavior if<br>&gt;&gt; #Self is a return type of protocol requirement.<br>&gt;&gt;<br>&gt;&gt; I strictly against to couple the initial proposal of #Self and your<br>&gt;&gt; proposal for extended features (for protocol conformance of<br>&gt;&gt; `-&gt;#Self`). Please be clear and obvious regarding the name of that<br>&gt;&gt; feature. I really think the behavior you propose can not be called<br>&gt;&gt; #Self(or Type)<br>&gt;&gt;<br>&gt;&gt; What I suggest: de-couple these proposals to:<br>&gt;&gt;<br>&gt;&gt; a) initial proposal of #Self as placeholder for concrete type name.<br>&gt;&gt; Choose the name for it. Probably StaticSelf, or Type, or somehting<br>&gt;&gt; else<br>&gt;&gt;<br>&gt;&gt; b) your proposal for BaseSelf feature. I&#39;ll definitely support it with<br>&gt;&gt; just name changed to clearly reflect its propose.<br>&gt;<br>&gt; I don&#39;t believe the initial proposal stated how it would behave in a<br>&gt; protocol.  However I do believe the feature I am talking about covers<br>&gt; all of the use cases Erica had in mind while also providing useful<br>&gt; semantics when used in a protocol requirement.  Erica, please correct me<br>&gt; if I&#39;m wrong.<br></p><p>Well.. Yes, I also don&#39;t see statements regarding how `-&gt;#Self` would <br>behave in a protocol in initial proposal. *This is why* I suggest to <br>de-couple what *was* in initial proposall, and what you are suggesting as <br>*addition* to the proposal.<br></p><p>Again. I fully support the behavior you suggest, but I strongly feel like <br>&#39;that&#39; #Self can&#39;t be named #Self, as some derived(from conformed class) <br>class X does not return &#39;self&#39;. It return &#39;self or one of base classes&#39;. <br>Let&#39;s call it &#39;SelfOrBase&#39; for now.<br></p><p>What we have now:<br></p><p>protocol A {<br>   func f1() -&gt; Self<br>   func f2(s: Self)<br>}<br></p><p>struct S: A {<br>   func f1() -&gt; S/*#Self*/ {return self}<br>   func f2(s: S/*#Self*/) {}<br>}<br></p><p>class C: A {<br>   func f1() -&gt; Self /*only Self, can&#39;t write C here*/ {return self}<br>   func f2(s: C/*#Self*/) {}<br>}<br></p><p>final class FC: A {<br>   func f1() -&gt; Self /*can write FC here, ==#Self*/ {return self}<br>   func f2(s: FC/*#Self*/) {}<br>}<br></p><p>I believe, for clarity, after we introduce #Self(or whatever name it will <br>have) we need to require `#Self` in protocol as type of method parameter:<br></p><p>protocol A {<br>   func f1() -&gt; Self // this could be Self and could be #Self<br>   func f2(s: #Self) // this always will be #Self in implementation<br></p><p>   // this should not be allowed any more<br>   //func f2(s: Self)<br>}<br></p><p>struct S: A {<br>   // as you see we&#39;d have `-&gt;#Self` in implementation<br>   func f1() -&gt; #Self {return self}<br>   func f2(s: #Self) {}<br>}<br></p><p>class C: A {<br>   func f1() -&gt; Self /*only Self, can&#39;t write C here*/ {return self}<br>   func f2(s: #Self) {}<br>}<br></p><p>final class FC: A {<br>   func f1() -&gt; Self /*can write FC here, ==#Self*/ {return self}<br>   func f2(s: #Self) {}<br>}<br></p><p>The above is what *I think* was in initial proposal regarding #Self.<br></p><p>About your suggestion. I just trying to understand it in details.<br>Please point me where I understand your suggestion incorrectly.<br></p><p>Do you think about such start points? :<br></p><p>class Base {<br>   func f() -&gt; Base  {return Base()}<br>}<br></p><p>class Derived1: Base {<br>   override func f() -&gt; Derived1  {return Derived1()}<br>}<br></p><p>class Derived2: Base {<br>   override func f() -&gt; Derived2  {return Derived2()}<br>}<br></p><p>If so, do you want to introduce such a protocol:<br></p><p>protocol A {<br>     func f() -&gt; #Self<br>}<br></p><p>and then conforms Base class to it? :<br></p><p>extension Base : A {}<br></p><p>To be able to use :<br></p><p>let a : A = Derived2()<br>let some = a.f() // you expect some.dynamicType is Derived2<br></p><p>I understand correctly?<br></p><p>At this point you say that all is OK and #Self works as expected, each <br>class returns really #Self and protocol conformation applied.<br>But I believe this is not true. We *can* have this:<br></p><p>class Derived3: Base {<br>   // no override for f(). will be used from base class<br>}<br></p><p>Now. What does Derived3().f() returns? It returns instance of Base.<br>Is #Self for Derived3 equals to `Base` ? No.<br>Does Derived3 conforms to protocol `A` in this case? No.<br>But it *must* conform as you think you can conform its base class.<br>This is the problem I see.<br></p><p>This is why I think it must be something separate from #Self, like <br>SelfOrBase - in this case, protocol will looks like:<br></p><p>protocol A {<br>     func f() -&gt; SelfOrBase<br>}<br></p><p>then you can conform Base to A,<br></p><p>extension Base : A {}<br></p><p>and Derived3 fully conforms to this protocol(it returns instance of base <br>class), all is OK and all is consistent.<br></p><p>If I&#39;m wrong somewhere please point me with clarification. Thank you.<br></p><p>&gt;<br>&gt; You want to make the semantics of #Self / Type be covariant when used in<br>&gt; a protocol requirement.  This makes no sense to me as it is explicitly<br>&gt; *not* covariant when used within a class declaration.  We already have a<br>&gt; covariant construct (Self) and the proposal is to introduce an invariant<br>&gt; construct (#Self or Type).  The invariant semantic should be consistent<br>&gt; regardless of whether it is used in a protocol requirement or a type<br>&gt; declaration.<br>&gt;<br>&gt; IMO BaseSelf is a poor choice of name for something that is supposed to<br>&gt; be valid syntax in value types as well as classes.<br>&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; On 11.05.2016 18:58, Matthew Johnson wrote: &#39;f&#39; would return E for<br>&gt;&gt;&gt; E, F and G.  Because the conformance is declared by E the<br>&gt;&gt;&gt; requirement to return #Self is fixed as an invariant requirement to<br>&gt;&gt;&gt; return E for all potential subclasses.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Probably you(we) need another proposal, like BaseSelf (or<br>&gt;&gt;&gt;&gt;&gt; SuperSelf) that means &quot;this class or any its base class&quot;, then I<br>&gt;&gt;&gt;&gt;&gt; understand how such a `f()-&gt;BaseSelf` protocol requirement can<br>&gt;&gt;&gt;&gt;&gt; be applied to E class and also be true for F&amp;G classes (as f()<br>&gt;&gt;&gt;&gt;&gt; inherited from base class will return instance of E which is<br>&gt;&gt;&gt;&gt;&gt; base for both).<br>&gt;&gt;&gt; This is exactly what #Self (or Type) does.  The behavior you have<br>&gt;&gt;&gt; been describing is the behavior of Self which already exists.<br>&gt;&gt;&gt;<br>&gt;<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[RFC] #Self</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 12, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On May 12, 2016, at 10:19 AM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt; <br>&gt; Inline<br>&gt; <br>&gt; On 11.05.2016 21:31, Matthew Johnson wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt;&gt; On May 11, 2016, at 11:43 AM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Well, I believe I understand now what *you mean* under #Self. OK.<br>&gt;&gt;&gt; Thank you for clarifications. In my terminology &#39;this&#39; could be called<br>&gt;&gt;&gt; BaseSelf. Your &quot;thing&quot; just can not be called #Self. IMO in initial<br>&gt;&gt;&gt; proposal #Self means not more than placeholder for the concrete type<br>&gt;&gt;&gt; name(inside type declaration or inside protocol).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You propose just something different, more advanced than initial<br>&gt;&gt;&gt; #Self, you propose not some static &quot;thing&quot; but extended behavior if<br>&gt;&gt;&gt; #Self is a return type of protocol requirement.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I strictly against to couple the initial proposal of #Self and your<br>&gt;&gt;&gt; proposal for extended features (for protocol conformance of<br>&gt;&gt;&gt; `-&gt;#Self`). Please be clear and obvious regarding the name of that<br>&gt;&gt;&gt; feature. I really think the behavior you propose can not be called<br>&gt;&gt;&gt; #Self(or Type)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What I suggest: de-couple these proposals to:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; a) initial proposal of #Self as placeholder for concrete type name.<br>&gt;&gt;&gt; Choose the name for it. Probably StaticSelf, or Type, or somehting<br>&gt;&gt;&gt; else<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; b) your proposal for BaseSelf feature. I&#39;ll definitely support it with<br>&gt;&gt;&gt; just name changed to clearly reflect its propose.<br>&gt;&gt; <br>&gt;&gt; I don&#39;t believe the initial proposal stated how it would behave in a<br>&gt;&gt; protocol.  However I do believe the feature I am talking about covers<br>&gt;&gt; all of the use cases Erica had in mind while also providing useful<br>&gt;&gt; semantics when used in a protocol requirement.  Erica, please correct me<br>&gt;&gt; if I&#39;m wrong.<br>&gt; <br>&gt; Well.. Yes, I also don&#39;t see statements regarding how `-&gt;#Self` would behave in a protocol in initial proposal. *This is why* I suggest to de-couple what *was* in initial proposall, and what you are suggesting as *addition* to the proposal.<br>&gt; <br>&gt; Again. I fully support the behavior you suggest, but I strongly feel like &#39;that&#39; #Self can&#39;t be named #Self, as some derived(from conformed class) class X does not return &#39;self&#39;. It return &#39;self or one of base classes&#39;. Let&#39;s call it &#39;SelfOrBase&#39; for now.<br>&gt; <br>&gt; What we have now:<br>&gt; <br>&gt; protocol A {<br>&gt;  func f1() -&gt; Self<br>&gt;  func f2(s: Self)<br>&gt; }<br>&gt; <br>&gt; struct S: A {<br>&gt;  func f1() -&gt; S/*#Self*/ {return self}<br>&gt;  func f2(s: S/*#Self*/) {}<br>&gt; }<br>&gt; <br>&gt; class C: A {<br>&gt;  func f1() -&gt; Self /*only Self, can&#39;t write C here*/ {return self}<br>&gt;  func f2(s: C/*#Self*/) {}<br>&gt; }<br>&gt; <br>&gt; final class FC: A {<br>&gt;  func f1() -&gt; Self /*can write FC here, ==#Self*/ {return self}<br>&gt;  func f2(s: FC/*#Self*/) {}<br>&gt; }<br>&gt; <br>&gt; I believe, for clarity, after we introduce #Self(or whatever name it will have) we need to require `#Self` in protocol as type of method parameter:<br>&gt; <br>&gt; protocol A {<br>&gt;  func f1() -&gt; Self // this could be Self and could be #Self<br></p><p>What in the original proposal makes you think Self and #Self would be interchangeable here?  Again, the proposal was for #Self to be invariant.  Self is covariant.  Those are very different things.  <br></p><p>The semantics in the original proposal were unspecified with regards to protocols.  I am simply extending it to retain the invariant semantics that the proposal *did* specified when it is used as a protocol requirement.<br></p><p>&gt;  func f2(s: #Self) // this always will be #Self in implementation<br>&gt; <br>&gt;  // this should not be allowed any more<br>&gt;  //func f2(s: Self)<br>&gt; }<br>&gt; <br>&gt; struct S: A {<br>&gt;  // as you see we&#39;d have `-&gt;#Self` in implementation<br>&gt;  func f1() -&gt; #Self {return self}<br>&gt;  func f2(s: #Self) {}<br>&gt; }<br>&gt; <br>&gt; class C: A {<br>&gt;  func f1() -&gt; Self /*only Self, can&#39;t write C here*/ {return self}<br>&gt;  func f2(s: #Self) {}<br>&gt; }<br>&gt; <br>&gt; final class FC: A {<br>&gt;  func f1() -&gt; Self /*can write FC here, ==#Self*/ {return self}<br>&gt;  func f2(s: #Self) {}<br>&gt; }<br>&gt; <br>&gt; The above is what *I think* was in initial proposal regarding #Self.<br>&gt; <br>&gt; About your suggestion. I just trying to understand it in details.<br>&gt; Please point me where I understand your suggestion incorrectly.<br>&gt; <br>&gt; Do you think about such start points? :<br>&gt; <br>&gt; class Base {<br>&gt;  func f() -&gt; Base  {return Base()}<br>&gt; }<br>&gt; <br>&gt; class Derived1: Base {<br>&gt;  override func f() -&gt; Derived1  {return Derived1()}<br>&gt; }<br>&gt; <br>&gt; class Derived2: Base {<br>&gt;  override func f() -&gt; Derived2  {return Derived2()}<br>&gt; }<br>&gt; <br>&gt; If so, do you want to introduce such a protocol:<br>&gt; <br>&gt; protocol A {<br>&gt;    func f() -&gt; #Self<br>&gt; }<br>&gt; <br>&gt; and then conforms Base class to it? :<br>&gt; <br>&gt; extension Base : A {}<br>&gt; <br>&gt; To be able to use :<br>&gt; <br>&gt; let a : A = Derived2()<br>&gt; let some = a.f() // you expect some.dynamicType is Derived2<br></p><p>The protocol specifies #Self (or Type, which we are not calling it).  It is conformed to by Base.  This means the return type of `f` is only guaranteed to be Base.  It *may* be Derived2, but it need not be.  Obviously given this example we know it is Derived2 because we can see the implementation but the type system does not.  This means `some` has type of Base.  Its dynamicsType *may* be Derived2 (and again in this case we can see that it will be) but that is not guaranteed by the type system.<br></p><p>&gt; <br>&gt; I understand correctly?<br>&gt; <br>&gt; At this point you say that all is OK and #Self works as expected, each class returns really #Self and protocol conformation applied.<br>&gt; But I believe this is not true. We *can* have this:<br>&gt; <br>&gt; class Derived3: Base {<br>&gt;  // no override for f(). will be used from base class<br>&gt; }<br>&gt; <br>&gt; Now. What does Derived3().f() returns? It returns instance of Base.<br>&gt; Is #Self for Derived3 equals to `Base` ? No.<br>&gt; Does Derived3 conforms to protocol `A` in this case? No.<br>&gt; But it *must* conform as you think you can conform its base class.<br>&gt; This is the problem I see.<br></p><p>What you are missing is that #Self is not the same as Self.  It is invariant.  A was originally conformed to by Base.  The requirement is invariant and becomes fixed by the conformance declaration.  In this case it is fixed to Base.<br></p><p>You have not explained why you think #Self should be invariant when used in a type context and covariant when used in a protocol context.  This expectation is what is confusing you.  If you really what that semantic I think the burden is on you to make the case that we need something with this mixed semantic.  I think it is much more confusing than having separate constructs for covariant and invariant semantics.<br></p><p>&gt; <br>&gt; This is why I think it must be something separate from #Self, like SelfOrBase - in this case, protocol will looks like:<br>&gt; <br>&gt; protocol A {<br>&gt;    func f() -&gt; SelfOrBase<br>&gt; }<br>&gt; <br>&gt; then you can conform Base to A,<br>&gt; <br>&gt; extension Base : A {}<br>&gt; <br>&gt; and Derived3 fully conforms to this protocol(it returns instance of base class), all is OK and all is consistent.<br>&gt; <br>&gt; If I&#39;m wrong somewhere please point me with clarification. Thank you.<br></p><p>Again, what you are calling SelfOrBase is *exactly* what I am calling Type (or #Self).  It has consistent invariant semantics in all contexts.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; You want to make the semantics of #Self / Type be covariant when used in<br>&gt;&gt; a protocol requirement.  This makes no sense to me as it is explicitly<br>&gt;&gt; *not* covariant when used within a class declaration.  We already have a<br>&gt;&gt; covariant construct (Self) and the proposal is to introduce an invariant<br>&gt;&gt; construct (#Self or Type).  The invariant semantic should be consistent<br>&gt;&gt; regardless of whether it is used in a protocol requirement or a type<br>&gt;&gt; declaration.<br>&gt;&gt; <br>&gt;&gt; IMO BaseSelf is a poor choice of name for something that is supposed to<br>&gt;&gt; be valid syntax in value types as well as classes.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 11.05.2016 18:58, Matthew Johnson wrote: &#39;f&#39; would return E for<br>&gt;&gt;&gt;&gt; E, F and G.  Because the conformance is declared by E the<br>&gt;&gt;&gt;&gt; requirement to return #Self is fixed as an invariant requirement to<br>&gt;&gt;&gt;&gt; return E for all potential subclasses.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Probably you(we) need another proposal, like BaseSelf (or<br>&gt;&gt;&gt;&gt;&gt;&gt; SuperSelf) that means &quot;this class or any its base class&quot;, then I<br>&gt;&gt;&gt;&gt;&gt;&gt; understand how such a `f()-&gt;BaseSelf` protocol requirement can<br>&gt;&gt;&gt;&gt;&gt;&gt; be applied to E class and also be true for F&amp;G classes (as f()<br>&gt;&gt;&gt;&gt;&gt;&gt; inherited from base class will return instance of E which is<br>&gt;&gt;&gt;&gt;&gt;&gt; base for both).<br>&gt;&gt;&gt;&gt; This is exactly what #Self (or Type) does.  The behavior you have<br>&gt;&gt;&gt;&gt; been describing is the behavior of Self which already exists.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160512/59b25f46/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[RFC] #Self</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 12, 2016 at 08:00:00pm</p></header><div class="content"><p>Inline<br></p><p>On 12.05.2016 18:36, Matthew Johnson wrote:<br>&gt;&gt; I believe, for clarity, after we introduce #Self(or whatever name it will<br>&gt;&gt; have) we need to require `#Self` in protocol as type of method parameter:<br>&gt;&gt;<br>&gt;&gt; protocol A {<br>&gt;&gt;  func f1() -&gt; Self // this could be Self and could be #Self<br>&gt;<br>&gt; What in the original proposal makes you think Self and #Self would be<br>&gt; interchangeable here?  Again, the proposal was for #Self to be invariant.<br>&gt;  Self is covariant.  Those are very different things.<br></p><p>Just incorrect comment for my code. Please add in mind *in implementation* <br>to the end of the comment. I don&#39;t mean that they can be interchangeable in <br>protocol definition, no, I mean at the moment of implementation `-&gt;Self` <br>could became `-&gt;Self` or `-&gt;#Self` depending on where it will be <br>implemented. Examples of implementation was below.<br></p><p>&gt;<br>&gt; The semantics in the original proposal were unspecified with regards to<br>&gt; protocols.  I am simply extending it to retain the invariant semantics that<br>&gt; the proposal *did* specified when it is used as a protocol requirement.<br>&gt;<br></p><p>IMO your suggestion can not be coupled with initial proposal.<br>And I mean the recent(last) proposal in email I quoted in one of previous <br>message, where nothing was said regarding protocols.<br></p><p>...<br>&gt;&gt; let a : A = Derived2()<br>&gt;&gt; let some = a.f() // you expect some.dynamicType is Derived2<br>&gt;<br>&gt; The protocol specifies #Self (or Type, which we are not calling it).  It is<br>&gt; conformed to by Base.  This means the return type of `f` is only guaranteed<br>&gt; to be Base.  It *may* be Derived2, but it need not be.  Obviously given<br>&gt; this example we know it is Derived2 because we can see the implementation<br>&gt; but the type system does not.  This means `some` has type of Base.  Its<br>&gt; dynamicsType *may* be Derived2 (and again in this case we can see that it<br>&gt; will be) but that is not guaranteed by the type system.<br>&gt;<br></p><p>I&#39;m tired ;-)<br>You are trying to couple two IMO different things.<br>`#Self` as parameter&#39;s type in protocol and inside class/struct means <br>&#39;placeholder for exactly this concrete type name in implementation&#39;. Not <br>base class!<br>I can&#39;t understand how you can extend this meaning to &quot;derived class <br>conforms to -&gt;#Self, but returns some base class&quot;.<br></p><p>&gt; What you are missing is that #Self is not the same as Self.  It is<br>&gt; invariant.  A was originally conformed to by Base.  The requirement is<br>&gt; invariant and becomes fixed by the conformance declaration.  In this case<br>&gt; it is fixed to Base.<br></p><p>Again. I&#39;m not missing this. It is clear they are no the same. Please point <br>where exactly I missed this.<br>But you are trying to use the same keyword `#Self`(or Type,not important) <br>in meaning &#39;this concrete type&#39; and in &#39;this or base type&#39;.<br></p><p>&gt;<br>&gt; You have not explained why you think #Self should be invariant when used in<br>&gt; a type context and covariant when used in a protocol context.  This<br>&gt; expectation is what is confusing you.  If you really what that semantic I<br>&gt; think the burden is on you to make the case that we need something with<br>&gt; this mixed semantic.  I think it is much more confusing than having<br>&gt; separate constructs for covariant and invariant semantics.<br></p><p>Just because of meaning(description) of #Self in initial proposal and its <br>behavior at the implementation side(inside type body).<br></p><p>If you extend the meaning of your `#Self` to &#39;any type in hierarchy of that <br>type&#39;, that I can understand.<br></p><p>&gt; Again, what you are calling SelfOrBase is *exactly* what I am calling Type<br>&gt; (or #Self).  It has consistent invariant semantics in all contexts.<br></p><p>Again ;-), Yes. And I&#39;m against to name your &#39;thing&#39; with the same name as <br>#Self(or Type) because they mean different things, different behavior.<br></p><p>Actually I think I got your points, I can&#39;t accept them and it seems like <br>there is no some &#39;common&#39; solution. You think that it is OK to have <br>`-&gt;#Self` in protocol requirements in meaning &quot;self of any base class&quot;, but <br>I can&#39;t accept and understand this.<br></p><p>Thank you for discussion, probably I need to re-think all of this and find <br>out that I was not right. I&#39;ll let then know ;-)<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[RFC] #Self</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 12, 2016 at 08:00:00pm</p></header><div class="content"><p>I absolutely share Matthewâ€™s view of #Self (or whatever it ends up being called) and think this is really needed.<br></p><p>On the other hand I donâ€™t think that a simple placeholder for the defining type is necessary as proposed by Vladimir, especially not if it is the third variant of something Self-like. <br></p><p>-Thorsten<br></p><p><br>&gt; Am 12.05.2016 um 17:36 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On May 12, 2016, at 10:19 AM, Vladimir.S &lt;svabox at gmail.com &lt;mailto:svabox at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Inline<br>&gt;&gt; <br>&gt;&gt; On 11.05.2016 21:31, Matthew Johnson wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 11, 2016, at 11:43 AM, Vladimir.S &lt;svabox at gmail.com &lt;mailto:svabox at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Well, I believe I understand now what *you mean* under #Self. OK.<br>&gt;&gt;&gt;&gt; Thank you for clarifications. In my terminology &#39;this&#39; could be called<br>&gt;&gt;&gt;&gt; BaseSelf. Your &quot;thing&quot; just can not be called #Self. IMO in initial<br>&gt;&gt;&gt;&gt; proposal #Self means not more than placeholder for the concrete type<br>&gt;&gt;&gt;&gt; name(inside type declaration or inside protocol).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You propose just something different, more advanced than initial<br>&gt;&gt;&gt;&gt; #Self, you propose not some static &quot;thing&quot; but extended behavior if<br>&gt;&gt;&gt;&gt; #Self is a return type of protocol requirement.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I strictly against to couple the initial proposal of #Self and your<br>&gt;&gt;&gt;&gt; proposal for extended features (for protocol conformance of<br>&gt;&gt;&gt;&gt; `-&gt;#Self`). Please be clear and obvious regarding the name of that<br>&gt;&gt;&gt;&gt; feature. I really think the behavior you propose can not be called<br>&gt;&gt;&gt;&gt; #Self(or Type)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What I suggest: de-couple these proposals to:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; a) initial proposal of #Self as placeholder for concrete type name.<br>&gt;&gt;&gt;&gt; Choose the name for it. Probably StaticSelf, or Type, or somehting<br>&gt;&gt;&gt;&gt; else<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; b) your proposal for BaseSelf feature. I&#39;ll definitely support it with<br>&gt;&gt;&gt;&gt; just name changed to clearly reflect its propose.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t believe the initial proposal stated how it would behave in a<br>&gt;&gt;&gt; protocol.  However I do believe the feature I am talking about covers<br>&gt;&gt;&gt; all of the use cases Erica had in mind while also providing useful<br>&gt;&gt;&gt; semantics when used in a protocol requirement.  Erica, please correct me<br>&gt;&gt;&gt; if I&#39;m wrong.<br>&gt;&gt; <br>&gt;&gt; Well.. Yes, I also don&#39;t see statements regarding how `-&gt;#Self` would behave in a protocol in initial proposal. *This is why* I suggest to de-couple what *was* in initial proposall, and what you are suggesting as *addition* to the proposal.<br>&gt;&gt; <br>&gt;&gt; Again. I fully support the behavior you suggest, but I strongly feel like &#39;that&#39; #Self can&#39;t be named #Self, as some derived(from conformed class) class X does not return &#39;self&#39;. It return &#39;self or one of base classes&#39;. Let&#39;s call it &#39;SelfOrBase&#39; for now.<br>&gt;&gt; <br>&gt;&gt; What we have now:<br>&gt;&gt; <br>&gt;&gt; protocol A {<br>&gt;&gt;  func f1() -&gt; Self<br>&gt;&gt;  func f2(s: Self)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct S: A {<br>&gt;&gt;  func f1() -&gt; S/*#Self*/ {return self}<br>&gt;&gt;  func f2(s: S/*#Self*/) {}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class C: A {<br>&gt;&gt;  func f1() -&gt; Self /*only Self, can&#39;t write C here*/ {return self}<br>&gt;&gt;  func f2(s: C/*#Self*/) {}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; final class FC: A {<br>&gt;&gt;  func f1() -&gt; Self /*can write FC here, ==#Self*/ {return self}<br>&gt;&gt;  func f2(s: FC/*#Self*/) {}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I believe, for clarity, after we introduce #Self(or whatever name it will have) we need to require `#Self` in protocol as type of method parameter:<br>&gt;&gt; <br>&gt;&gt; protocol A {<br>&gt;&gt;  func f1() -&gt; Self // this could be Self and could be #Self<br>&gt; <br>&gt; What in the original proposal makes you think Self and #Self would be interchangeable here?  Again, the proposal was for #Self to be invariant.  Self is covariant.  Those are very different things.  <br>&gt; <br>&gt; The semantics in the original proposal were unspecified with regards to protocols.  I am simply extending it to retain the invariant semantics that the proposal *did* specified when it is used as a protocol requirement.<br>&gt; <br>&gt;&gt;  func f2(s: #Self) // this always will be #Self in implementation<br>&gt;&gt; <br>&gt;&gt;  // this should not be allowed any more<br>&gt;&gt;  //func f2(s: Self)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct S: A {<br>&gt;&gt;  // as you see we&#39;d have `-&gt;#Self` in implementation<br>&gt;&gt;  func f1() -&gt; #Self {return self}<br>&gt;&gt;  func f2(s: #Self) {}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class C: A {<br>&gt;&gt;  func f1() -&gt; Self /*only Self, can&#39;t write C here*/ {return self}<br>&gt;&gt;  func f2(s: #Self) {}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; final class FC: A {<br>&gt;&gt;  func f1() -&gt; Self /*can write FC here, ==#Self*/ {return self}<br>&gt;&gt;  func f2(s: #Self) {}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; The above is what *I think* was in initial proposal regarding #Self.<br>&gt;&gt; <br>&gt;&gt; About your suggestion. I just trying to understand it in details.<br>&gt;&gt; Please point me where I understand your suggestion incorrectly.<br>&gt;&gt; <br>&gt;&gt; Do you think about such start points? :<br>&gt;&gt; <br>&gt;&gt; class Base {<br>&gt;&gt;  func f() -&gt; Base  {return Base()}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class Derived1: Base {<br>&gt;&gt;  override func f() -&gt; Derived1  {return Derived1()}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class Derived2: Base {<br>&gt;&gt;  override func f() -&gt; Derived2  {return Derived2()}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; If so, do you want to introduce such a protocol:<br>&gt;&gt; <br>&gt;&gt; protocol A {<br>&gt;&gt;    func f() -&gt; #Self<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; and then conforms Base class to it? :<br>&gt;&gt; <br>&gt;&gt; extension Base : A {}<br>&gt;&gt; <br>&gt;&gt; To be able to use :<br>&gt;&gt; <br>&gt;&gt; let a : A = Derived2()<br>&gt;&gt; let some = a.f() // you expect some.dynamicType is Derived2<br>&gt; <br>&gt; The protocol specifies #Self (or Type, which we are not calling it).  It is conformed to by Base.  This means the return type of `f` is only guaranteed to be Base.  It *may* be Derived2, but it need not be.  Obviously given this example we know it is Derived2 because we can see the implementation but the type system does not.  This means `some` has type of Base.  Its dynamicsType *may* be Derived2 (and again in this case we can see that it will be) but that is not guaranteed by the type system.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; I understand correctly?<br>&gt;&gt; <br>&gt;&gt; At this point you say that all is OK and #Self works as expected, each class returns really #Self and protocol conformation applied.<br>&gt;&gt; But I believe this is not true. We *can* have this:<br>&gt;&gt; <br>&gt;&gt; class Derived3: Base {<br>&gt;&gt;  // no override for f(). will be used from base class<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Now. What does Derived3().f() returns? It returns instance of Base.<br>&gt;&gt; Is #Self for Derived3 equals to `Base` ? No.<br>&gt;&gt; Does Derived3 conforms to protocol `A` in this case? No.<br>&gt;&gt; But it *must* conform as you think you can conform its base class.<br>&gt;&gt; This is the problem I see.<br>&gt; <br>&gt; What you are missing is that #Self is not the same as Self.  It is invariant.  A was originally conformed to by Base.  The requirement is invariant and becomes fixed by the conformance declaration.  In this case it is fixed to Base.<br>&gt; <br>&gt; You have not explained why you think #Self should be invariant when used in a type context and covariant when used in a protocol context.  This expectation is what is confusing you.  If you really what that semantic I think the burden is on you to make the case that we need something with this mixed semantic.  I think it is much more confusing than having separate constructs for covariant and invariant semantics.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; This is why I think it must be something separate from #Self, like SelfOrBase - in this case, protocol will looks like:<br>&gt;&gt; <br>&gt;&gt; protocol A {<br>&gt;&gt;    func f() -&gt; SelfOrBase<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; then you can conform Base to A,<br>&gt;&gt; <br>&gt;&gt; extension Base : A {}<br>&gt;&gt; <br>&gt;&gt; and Derived3 fully conforms to this protocol(it returns instance of base class), all is OK and all is consistent.<br>&gt;&gt; <br>&gt;&gt; If I&#39;m wrong somewhere please point me with clarification. Thank you.<br>&gt; <br>&gt; Again, what you are calling SelfOrBase is *exactly* what I am calling Type (or #Self).  It has consistent invariant semantics in all contexts.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You want to make the semantics of #Self / Type be covariant when used in<br>&gt;&gt;&gt; a protocol requirement.  This makes no sense to me as it is explicitly<br>&gt;&gt;&gt; *not* covariant when used within a class declaration.  We already have a<br>&gt;&gt;&gt; covariant construct (Self) and the proposal is to introduce an invariant<br>&gt;&gt;&gt; construct (#Self or Type).  The invariant semantic should be consistent<br>&gt;&gt;&gt; regardless of whether it is used in a protocol requirement or a type<br>&gt;&gt;&gt; declaration.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; IMO BaseSelf is a poor choice of name for something that is supposed to<br>&gt;&gt;&gt; be valid syntax in value types as well as classes.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 11.05.2016 18:58, Matthew Johnson wrote: &#39;f&#39; would return E for<br>&gt;&gt;&gt;&gt;&gt; E, F and G.  Because the conformance is declared by E the<br>&gt;&gt;&gt;&gt;&gt; requirement to return #Self is fixed as an invariant requirement to<br>&gt;&gt;&gt;&gt;&gt; return E for all potential subclasses.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Probably you(we) need another proposal, like BaseSelf (or<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; SuperSelf) that means &quot;this class or any its base class&quot;, then I<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; understand how such a `f()-&gt;BaseSelf` protocol requirement can<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; be applied to E class and also be true for F&amp;G classes (as f()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; inherited from base class will return instance of E which is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; base for both).<br>&gt;&gt;&gt;&gt;&gt; This is exactly what #Self (or Type) does.  The behavior you have<br>&gt;&gt;&gt;&gt;&gt; been describing is the behavior of Self which already exists.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160512/ca23d82a/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[RFC] #Self</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May 11, 2016 at 03:00:00pm</p></header><div class="content"><p>That explanation is succinct and cogent. I can see the need for this<br>proposed behavior. Having just played around with conforming classes to<br>protocols, I think #Self is rather clear, but Type would be a little<br>mystifying.<br></p><p>On Wed, May 11, 2016 at 08:43 Matthew Johnson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; &gt; On May 11, 2016, at 1:22 AM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; &gt; No, class would not need to be final to conform to a requirement<br>&gt; returning #Self.  The difference is that with Self covaries and #Self does<br>&gt; not.  This means you *do not need* to guarantee that all subclasses<br>&gt; override a requirement that returns #Self, while you do need to guarantee<br>&gt; that all subclasses override a requirement that returns Self.<br>&gt; &gt;<br>&gt; &gt; I&#39;m probably slow these day, but I(and probably someone else) just can&#39;t<br>&gt; understand this. Thank you for your patience in explaining this:<br>&gt; &gt; Just after you conforms *base* class to *any* protocol, any possible<br>&gt; subclass *must* (you *have to* guarantee this) conform the same protocol.<br>&gt; &gt;<br>&gt; &gt; class A {..}<br>&gt; &gt; class B:A {..}<br>&gt; &gt; class C:A {..}<br>&gt; &gt; protocol D {..}<br>&gt; &gt; extension A: D {}<br>&gt; &gt; -&gt; now B&amp;C and any other existed and *possible* subclass *must* conforms<br>&gt; to the same protocol D just because of inheritance. As soon as they are<br>&gt; subclass of A, they *must* be `is D` and *must* have the methods that<br>&gt; return #Self. No?<br>&gt;<br>&gt; Yes, they must and will conform.  The distinction is that if the protocol<br>&gt; has requirements returning Self all subclasses must override those<br>&gt; requirements and to return their type because the inherited implementation<br>&gt; returns their supertype.  With #Self (or Type as we&#39;re now calling it) they<br>&gt; would not need to override those requirements because the ancestor that<br>&gt; initially declared conformance provides an inherited implementation that<br>&gt; remains valid for all of its descendants.<br>&gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On 10.05.2016 22:04, Matthew Johnson wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On May 10, 2016, at 1:38 PM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; On 10.05.2016 20:50, Matthew Johnson wrote:<br>&gt; &gt;&gt;&gt;&gt; No, the whole point is that D.f() returns C because C is the<br>&gt; requirement<br>&gt; &gt;&gt;&gt;&gt; of &#39;f&#39; is declared to return #Self which is C where the protocol<br>&gt; &gt;&gt;&gt;&gt; conformance is declared and implemented.  If you want a covariant<br>&gt; &gt;&gt;&gt;&gt; requirement you would use Self as the return type, not #Self.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; I just followed your example with NSURL.. Probably I don&#39;t understand<br>&gt; the point, but you said you want to conform a non-final class to protocol<br>&gt; with method -&gt; #Self.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; ---------------------&lt;<br>&gt; &gt;&gt;&gt; protocol A { static func createWithString(s: String) -&gt; Self }<br>&gt; &gt;&gt;&gt; extension NSURL: A { // cannot conform because NSURL is non-final }<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; If we could define a protocol requirement that didn&#39;t covary (using<br>&gt; &gt;&gt;&gt; #Self or whatever) we would be able to write the desired conformance.<br>&gt; &gt;&gt;&gt;&gt; ---------------------&lt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; And I don&#39;t understand how do you want to achieve the target, as even<br>&gt; if we &#39;invent&#39; #Self, this (as I understand) can&#39;t work as class is not<br>&gt; final. Just like with &#39;simple&#39; Self - class must be final to conform. Thank<br>&gt; you for clarification.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; No, class would not need to be final to conform to a requirement<br>&gt; returning #Self.  The difference is that with Self covaries and #Self does<br>&gt; not.  This means you do not need to guarantee that all subclasses override<br>&gt; a requirement that returns #Self, while you do need to guarantee that all<br>&gt; subclasses override a requirement that returns Self.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; The requirement to guarantee that all subclasses provide this override<br>&gt; is the reason you cannot declare conformance in the case of requirements<br>&gt; returning Self.  Since this isnâ€™t necessary for #Self (will probably have a<br>&gt; different name) the class does not need to be final in order to conform.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; -Matthew<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; .<br>&gt; &gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160511/eccc15b0/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[RFC] #Self</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 10, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On May 10, 2016, at 7:50 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; As a compile-time substitution, it could be used in any and all of the examples in your bullet list as a literal text replacement..<br>&gt; <br>&gt; Quick rundown:<br>&gt; <br>&gt; struct A {<br>&gt;    ...#Self... // #Self is substituted by A<br>&gt; }<br>&gt; <br>&gt; class B {<br>&gt;     ...#Self... // Self is substituted by B<br>&gt; }<br>&gt; <br>&gt; class C {<br>&gt;    ... #Self... // Self is substituted by C, which is the defining type at compile time<br>&gt; }<br></p><p>I think it would be surprising if #Self produced the name of the enclosing static type: Self produces the dynamic type, and weâ€™d want to preserve consistency if it were named #Self.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06130940a44c84dfc6c5aeabfd8482f8?s=50"></div><header><strong>[RFC] #Self</strong> from <string>Timothy Wood</string> &lt;tjw at me.com&gt;<p>May 10, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On May 10, 2016, at 8:56 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On May 10, 2016, at 7:50 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; As a compile-time substitution, it could be used in any and all of the examples in your bullet list as a literal text replacement..<br>&gt;&gt; <br>&gt;&gt; Quick rundown:<br>&gt;&gt; <br>&gt;&gt; struct A {<br>&gt;&gt;   ...#Self... // #Self is substituted by A<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class B {<br>&gt;&gt;    ...#Self... // Self is substituted by B<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class C {<br>&gt;&gt;   ... #Self... // Self is substituted by C, which is the defining type at compile time<br>&gt;&gt; }<br>&gt; <br>&gt; I think it would be surprising if #Self produced the name of the enclosing static type: Self produces the dynamic type, and weâ€™d want to preserve consistency if it were named #Self.<br></p><p><br>Iâ€™m not sure I understand this comment -- if #Self should mean the same as Self, why would it get added? My whole point in suggesting #Self was that it mirrored #file and #line in that it was a compile time replacement of some static information.<br></p><p>-tim<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160510/5833b95a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[RFC] #Self</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 10, 2016 at 11:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 10, 2016, at 11:01 AM, Timothy Wood via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On May 10, 2016, at 8:56 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On May 10, 2016, at 7:50 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As a compile-time substitution, it could be used in any and all of the examples in your bullet list as a literal text replacement..<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Quick rundown:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct A {<br>&gt;&gt;&gt;   ...#Self... // #Self is substituted by A<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class B {<br>&gt;&gt;&gt;    ...#Self... // Self is substituted by B<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class C {<br>&gt;&gt;&gt;   ... #Self... // Self is substituted by C, which is the defining type at compile time<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I think it would be surprising if #Self produced the name of the enclosing static type: Self produces the dynamic type, and weâ€™d want to preserve consistency if it were named #Self.<br>&gt; <br>&gt; <br>&gt; Iâ€™m not sure I understand this comment -- if #Self should mean the same as Self, why would it get added? My whole point in suggesting #Self was that it mirrored #file and #line in that it was a compile time replacement of some static information.<br></p><p>It isn&#39;t at all the same.  Self is covariant with the dynamic context.  #Self, #Type, #StaticType or whatever we call it is statically determined by the lexical context.<br></p><p>&gt; <br>&gt; -tim<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160510/f9ec9d3a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06130940a44c84dfc6c5aeabfd8482f8?s=50"></div><header><strong>[RFC] #Self</strong> from <string>Timothy Wood</string> &lt;tjw at me.com&gt;<p>May 10, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On May 10, 2016, at 9:05 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; It isn&#39;t at all the same.  Self is covariant with the dynamic context.  #Self, #Type, #StaticType or whatever we call it is statically determined by the lexical context.<br></p><p>Yes. That is what the # distinguishes, in my original suggesting for the previous proposal. Using a different term altogether introduces more ambiguity by raising questions about what other ways the two  things differ. With `#Self`, I read that naturally as the compile-time (â€œ#â€) version of the thing being compiled (â€œSelfâ€).<br></p><p>-tim<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160510/9913eb7f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[RFC] #Self</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 10, 2016 at 11:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 10, 2016, at 11:12 AM, Timothy Wood &lt;tjw at me.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 10, 2016, at 9:05 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; It isn&#39;t at all the same.  Self is covariant with the dynamic context.  #Self, #Type, #StaticType or whatever we call it is statically determined by the lexical context.<br>&gt; <br>&gt; Yes. That is what the # distinguishes, in my original suggesting for the previous proposal. Using a different term altogether introduces more ambiguity by raising questions about what other ways the two  things differ. With `#Self`, I read that naturally as the compile-time (â€œ#â€) version of the thing being compiled (â€œSelfâ€).<br></p><p>Yep, understood.  It&#39;s perfectly clear to me but I understand why Chris is concerned about it having potential to confuse people.  It is a pretty subtle difference especially since Self and #Self are the same in some contexts.  In any case, I would be content to live with any name that wins out.<br></p><p>&gt; <br>&gt; -tim<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160510/2efb3434/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06130940a44c84dfc6c5aeabfd8482f8?s=50"></div><header><strong>[RFC] #Self</strong> from <string>Timothy Wood</string> &lt;tjw at me.com&gt;<p>May 10, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On May 10, 2016, at 9:28 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; Yep, understood.  It&#39;s perfectly clear to me but I understand why Chris is concerned about it having potential to confuse people.  It is a pretty subtle difference especially since Self and #Self are the same in some contexts.  In any case, I would be content to live with any name that wins out.<br></p><p>Ah, OK -- it sounds like we just differ on what would be least confusing =)<br></p><p>The other proposed name of #StaticSelf, seems like it would be very clear (if a bit redundant and longer than needed, once youâ€™ve come across it once or twice). I could certainly live with #StaticSelf.<br></p><p>-tim<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[RFC] #Self</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 10, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; Am 10.05.2016 um 18:41 schrieb Timothy Wood via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; On May 10, 2016, at 9:28 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; Yep, understood.  It&#39;s perfectly clear to me but I understand why Chris is concerned about it having potential to confuse people.  It is a pretty subtle difference especially since Self and #Self are the same in some contexts.  In any case, I would be content to live with any name that wins out.<br>&gt; <br>&gt; Ah, OK -- it sounds like we just differ on what would be least confusing =)<br>&gt; <br>&gt; The other proposed name of #StaticSelf, seems like it would be very clear (if a bit redundant and longer than needed, once youâ€™ve come across it once or twice). I could certainly live with #StaticSelf.<br></p><p>In that case StaticSelf would be sufficient IMHO. The # should only be needed to distinguish between Self and #Self.<br></p><p>So:<br></p><p>Self, #Self<br>Self, StaticSelf<br>DynamicSelf, StaticSelf<br></p><p><br>As far as I understand #Self should be the type of the implementor (ImplementorSelf?) or conforming type (ConformingSelf?).<br>How would this work with default methods?<br></p><p>protocol A {<br>	func f() -&gt; #Self<br>	init()<br>}<br></p><p>extension A {<br>	func f() -&gt; #Self { return init() }	// what type has #Self here?<br>}<br></p><p>class C : A {}<br></p><p>let c = C().f()	// what type has c here?<br></p><p>-Thorsten<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[RFC] #Self</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 10, 2016 at 01:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 10, 2016, at 12:59 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Am 10.05.2016 um 18:41 schrieb Timothy Wood via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 10, 2016, at 9:28 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt; Yep, understood.  It&#39;s perfectly clear to me but I understand why Chris is concerned about it having potential to confuse people.  It is a pretty subtle difference especially since Self and #Self are the same in some contexts.  In any case, I would be content to live with any name that wins out.<br>&gt;&gt; <br>&gt;&gt; Ah, OK -- it sounds like we just differ on what would be least confusing =)<br>&gt;&gt; <br>&gt;&gt; The other proposed name of #StaticSelf, seems like it would be very clear (if a bit redundant and longer than needed, once youâ€™ve come across it once or twice). I could certainly live with #StaticSelf.<br>&gt; <br>&gt; In that case StaticSelf would be sufficient IMHO. The # should only be needed to distinguish between Self and #Self.<br>&gt; <br>&gt; So:<br>&gt; <br>&gt; Self, #Self<br>&gt; Self, StaticSelf<br>&gt; DynamicSelf, StaticSelf<br>&gt; <br>&gt; <br>&gt; As far as I understand #Self should be the type of the implementor (ImplementorSelf?) or conforming type (ConformingSelf?).<br>&gt; How would this work with default methods?<br>&gt; <br>&gt; protocol A {<br>&gt;    func f() -&gt; #Self<br>&gt;    init()<br>&gt; }<br>&gt; <br>&gt; extension A {<br>&gt;    func f() -&gt; #Self { return init() }    // what type has #Self here?<br>&gt; }<br></p><p>The conforming type.  C in your example.  If we have &#39;class D: C&#39; and it overrides &#39;f&#39; the override would have a return type of C, not D.  The returned instance could be of type D since it is a subtype of C.  We could also explore allowing overrides to have a covariant return type, it just wouldn&#39;t be visible when accessed via the protocol through a generic constraint or an existential (those would only guarantee C, the type that declared the conformance.<br></p><p>&gt; <br>&gt; class C : A {}<br>&gt; <br>&gt; let c = C().f()    // what type has c here?<br>&gt; <br>&gt; -Thorsten<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[RFC] #Self</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 10, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On May 10, 2016, at 9:01 AM, Timothy Wood &lt;tjw at me.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 10, 2016, at 8:56 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On May 10, 2016, at 7:50 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As a compile-time substitution, it could be used in any and all of the examples in your bullet list as a literal text replacement..<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Quick rundown:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct A {<br>&gt;&gt;&gt;   ...#Self... // #Self is substituted by A<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class B {<br>&gt;&gt;&gt;    ...#Self... // Self is substituted by B<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class C {<br>&gt;&gt;&gt;   ... #Self... // Self is substituted by C, which is the defining type at compile time<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I think it would be surprising if #Self produced the name of the enclosing static type: Self produces the dynamic type, and weâ€™d want to preserve consistency if it were named #Self.<br>&gt; <br>&gt; <br>&gt; Iâ€™m not sure I understand this comment -- if #Self should mean the same as Self, why would it get added? My whole point in suggesting #Self was that it mirrored #file and #line in that it was a compile time replacement of some static information.<br></p><p>I think I misunderstood â€œtextual replacementâ€ to mean that #Self returns a string.<br></p><p>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160510/07cb1126/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[RFC] #Self</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 10, 2016 at 11:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 10, 2016, at 10:56 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 10, 2016, at 7:50 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; As a compile-time substitution, it could be used in any and all of the examples in your bullet list as a literal text replacement..<br>&gt;&gt; <br>&gt;&gt; Quick rundown:<br>&gt;&gt; <br>&gt;&gt; struct A {<br>&gt;&gt;   ...#Self... // #Self is substituted by A<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class B {<br>&gt;&gt;    ...#Self... // Self is substituted by B<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class C {<br>&gt;&gt;   ... #Self... // Self is substituted by C, which is the defining type at compile time<br>&gt;&gt; }<br>&gt; <br>&gt; I think it would be surprising if #Self produced the name of the enclosing static type: Self produces the dynamic type, and weâ€™d want to preserve consistency if it were named #Self.<br></p><p>That&#39;s a fair critique.  Having a more distinct name will make it clear that the behavior is completely unrelated to Self.<br></p><p>How about #Type or #StaticType?<br></p><p>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[RFC] #Self</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 10, 2016 at 09:00:00am</p></header><div class="content"><p>I&#39;m partial to #This or #ThisType.<br></p><p>/bikeshed<br></p><p>Austin<br></p><p>&gt; On May 10, 2016, at 9:03 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt;&gt; On May 10, 2016, at 10:56 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 10, 2016, at 7:50 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As a compile-time substitution, it could be used in any and all of the examples in your bullet list as a literal text replacement..<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Quick rundown:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct A {<br>&gt;&gt;&gt;  ...#Self... // #Self is substituted by A<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class B {<br>&gt;&gt;&gt;   ...#Self... // Self is substituted by B<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class C {<br>&gt;&gt;&gt;  ... #Self... // Self is substituted by C, which is the defining type at compile time<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I think it would be surprising if #Self produced the name of the enclosing static type: Self produces the dynamic type, and weâ€™d want to preserve consistency if it were named #Self.<br>&gt; <br>&gt; That&#39;s a fair critique.  Having a more distinct name will make it clear that the behavior is completely unrelated to Self.<br>&gt; <br>&gt; How about #Type or #StaticType?<br>&gt; <br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160510/b73d8501/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[RFC] #Self</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 10, 2016 at 11:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 10, 2016, at 11:05 AM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; I&#39;m partial to #This or #ThisType.<br>&gt; <br></p><p>Can you elaborate on why?  This feels out of place to me in the Swift and Objective-C world.<br></p><p>&gt; /bikeshed<br>&gt; <br>&gt; Austin<br>&gt; <br>&gt;&gt; On May 10, 2016, at 9:03 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 10, 2016, at 10:56 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 10, 2016, at 7:50 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As a compile-time substitution, it could be used in any and all of the examples in your bullet list as a literal text replacement..<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Quick rundown:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct A {<br>&gt;&gt;&gt;&gt;  ...#Self... // #Self is substituted by A<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class B {<br>&gt;&gt;&gt;&gt;   ...#Self... // Self is substituted by B<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class C {<br>&gt;&gt;&gt;&gt;  ... #Self... // Self is substituted by C, which is the defining type at compile time<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think it would be surprising if #Self produced the name of the enclosing static type: Self produces the dynamic type, and weâ€™d want to preserve consistency if it were named #Self.<br>&gt;&gt; <br>&gt;&gt; That&#39;s a fair critique.  Having a more distinct name will make it clear that the behavior is completely unrelated to Self.<br>&gt;&gt; <br>&gt;&gt; How about #Type or #StaticType?<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160510/a1ab258d/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[RFC] #Self</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 10, 2016 at 07:00:00pm</p></header><div class="content"><p>I think we should be explicit, so my vote is #StaticSelf. And I&#39;d prefer we <br>have DynamicSelf instead of current `Self`<br></p><p>On 10.05.2016 19:03, Matthew Johnson via swift-evolution wrote:<br>&gt; How about #Type or #StaticType?<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[RFC] #Self</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 10, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On May 10, 2016, at 9:03 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class C {<br>&gt;&gt;&gt;  ... #Self... // Self is substituted by C, which is the defining type at compile time<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I think it would be surprising if #Self produced the name of the enclosing static type: Self produces the dynamic type, and weâ€™d want to preserve consistency if it were named #Self.<br>&gt; <br>&gt; That&#39;s a fair critique.  Having a more distinct name will make it clear that the behavior is completely unrelated to Self.<br>&gt; <br>&gt; How about #Type or #StaticType?<br></p><p>Either of those would make more sense to me than using # as a distinguisher for dynamic vs static.  This isnâ€™t what we use # for.<br></p><p>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160510/0f335177/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[RFC] #Self</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 10, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On May 10, 2016, at 1:43 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 10, 2016, at 9:03 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class C {<br>&gt;&gt;&gt;&gt;  ... #Self... // Self is substituted by C, which is the defining type at compile time<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think it would be surprising if #Self produced the name of the enclosing static type: Self produces the dynamic type, and weâ€™d want to preserve consistency if it were named #Self.<br>&gt;&gt; <br>&gt;&gt; That&#39;s a fair critique.  Having a more distinct name will make it clear that the behavior is completely unrelated to Self.<br>&gt;&gt; <br>&gt;&gt; How about #Type or #StaticType?<br>&gt; <br>&gt; Either of those would make more sense to me than using # as a distinguisher for dynamic vs static.  This isnâ€™t what we use # for.<br>&gt; <br></p><p>Another suggestion was StaticSelf.  Any opinion on that one?  Also, do you think we should just drop the # altogether?<br></p><p>If we find a name we can agree on and there is no significant opposition is this a proposal that could make it into Swift 3?  I would be willing to write one if that is the case.<br></p><p>-Matthew<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160510/f68fc203/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[RFC] #Self</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 10, 2016 at 02:00:00pm</p></header><div class="content"><p>On May 10, 2016, at 12:03 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That&#39;s a fair critique.  Having a more distinct name will make it clear that the behavior is completely unrelated to Self.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; How about #Type or #StaticType?<br>&gt;&gt; <br>&gt;&gt; Either of those would make more sense to me than using # as a distinguisher for dynamic vs static.  This isnâ€™t what we use # for.<br>&gt;&gt; <br>&gt; <br>&gt; Another suggestion was StaticSelf.  Any opinion on that one?  Also, do you think we should just drop the # altogether?<br>&gt; <br>&gt; If we find a name we can agree on and there is no significant opposition is this a proposal that could make it into Swift 3?  I would be willing to write one if that is the case.<br></p><p>I havenâ€™t thought about this in depth and completely misunderstood the proposal before :-)<br></p><p>If I understand, this is simply a shortcut to avoid having to spell out the static type name, most useful when copying/pasting code or when the type name is long.  That argues for keeping it short (a knock against StaticSelf).  Also, I think it would make sense to drop the #: Self doesnâ€™t have it for example, and that is the closest relative.<br></p><p>That said, Iâ€™m not sure I understand the concrete use-cases.  When is this concept important?  When is â€œSelfâ€ not good enough?<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160510/9bb7f992/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[RFC] #Self</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 10, 2016 at 04:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 10, 2016, at 4:01 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; On May 10, 2016, at 12:03 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That&#39;s a fair critique.  Having a more distinct name will make it clear that the behavior is completely unrelated to Self.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; How about #Type or #StaticType?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Either of those would make more sense to me than using # as a distinguisher for dynamic vs static.  This isnâ€™t what we use # for.<br>&gt;&gt; <br>&gt;&gt; Another suggestion was StaticSelf.  Any opinion on that one?  Also, do you think we should just drop the # altogether?<br>&gt;&gt; <br>&gt;&gt; If we find a name we can agree on and there is no significant opposition is this a proposal that could make it into Swift 3?  I would be willing to write one if that is the case.<br>&gt; <br>&gt; I havenâ€™t thought about this in depth and completely misunderstood the proposal before :-)<br>&gt; <br>&gt; If I understand, this is simply a shortcut to avoid having to spell out the static type name, most useful when copying/pasting code or when the type name is long.  That argues for keeping it short (a knock against StaticSelf).  Also, I think it would make sense to drop the #: Self doesnâ€™t have it for example, and that is the closest relative.<br></p><p>Good point about keeping it short.  &#39;Type&#39; seems like the best candidate.<br></p><p>&gt; <br>&gt; That said, Iâ€™m not sure I understand the concrete use-cases.  When is this concept important?  When is â€œSelfâ€ not good enough?<br></p><p>The only case where there is new functionality is when this is used in a protocol requirement.  I gave an example earlier today.  <br></p><p>It also provides a shortcut for verbose type names, although that is relatively unimportant.<br></p><p>&gt; <br>&gt; -Chris<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160510/ea3cce59/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e7e554db1f80d7d6041d92edd5145698?s=50"></div><header><strong>[RFC] #Self</strong> from <string>Hooman Mehr</string> &lt;hooman at mac.com&gt;<p>May 10, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On May 10, 2016, at 2:49 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; That said, Iâ€™m not sure I understand the concrete use-cases.  When is this concept important?  When is â€œSelfâ€ not good enough?<br>&gt; <br>&gt; The only case where there is new functionality is when this is used in a protocol requirement.  I gave an example earlier today.  <br></p><p>This functionality is the key: Ability of an open (non-final) class to conform to a protocol that lets it return an instance of the conforming type (itself). Self does not work for that and we canâ€™t change its behavior (or can we?) So one solution seems to be Mattâ€™s proposal. This functionality is important for me and an example use case is class clusters. For the client code it is sealed and acts just like a final class, but internally it may return a subclass that is an implementation detail. We should be able to do this.<br></p><p>Hooman<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160510/0506a656/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[RFC] #Self</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 10, 2016 at 05:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 10, 2016, at 5:24 PM, Hooman Mehr &lt;hooman at mac.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On May 10, 2016, at 2:49 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; That said, Iâ€™m not sure I understand the concrete use-cases.  When is this concept important?  When is â€œSelfâ€ not good enough?<br>&gt;&gt; <br>&gt;&gt; The only case where there is new functionality is when this is used in a protocol requirement.  I gave an example earlier today.  <br>&gt; <br>&gt; This functionality is the key: Ability of an open (non-final) class to conform to a protocol that lets it return an instance of the conforming type (itself). Self does not work for that and we canâ€™t change its behavior (or can we?) So one solution seems to be Mattâ€™s proposal. This functionality is important for me and an example use case is class clusters. For the client code it is sealed and acts just like a final class, but internally it may return a subclass that is an implementation detail. We should be able to do this.<br></p><p>Agree and this is why I am willing to write the proposal for this.  There was a discussion a few months ago about this problem and a few solutions were kicked around.  The biggest problem with this approach at the time was lack of a good name, which I believe we now have in Type.<br></p><p>I&#39;m going to let the discussion continue for a day or two and will write a proposal if no significant counter arguments arise.<br></p><p>-Matthew<br></p><p>&gt; <br>&gt; Hooman<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160510/79e3175c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[RFC] #Self</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May 10, 2016 at 05:00:00pm</p></header><div class="content"><p>If the use case is to support certain protocol requirements rather than<br>avoiding the recitation of long names, then it doesn&#39;t have to be short.<br>IMO, `Type` is problematic because there&#39;s nothing in the meaning of the<br>word to distinguish from `Self`, and in any case it&#39;s already used for the<br>metatype type. `StaticSelf` is unambiguous.<br></p><p><br>On Tue, May 10, 2016 at 5:32 PM, Matthew Johnson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; On May 10, 2016, at 5:24 PM, Hooman Mehr &lt;hooman at mac.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On May 10, 2016, at 2:49 PM, Matthew Johnson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; That said, Iâ€™m not sure I understand the concrete use-cases.  When is this<br>&gt; concept important?  When is â€œSelfâ€ not good enough?<br>&gt;<br>&gt;<br>&gt; The only case where there is new functionality is when this is used in a<br>&gt; protocol requirement.  I gave an example earlier today.<br>&gt;<br>&gt;<br>&gt; This functionality is the key: Ability of an open (non-final) class to<br>&gt; conform to a protocol that lets it return an instance of the conforming<br>&gt; type (itself). Self does not work for that and we canâ€™t change its behavior<br>&gt; (or can we?) So one solution seems to be Mattâ€™s proposal. This<br>&gt; functionality is important for me and an example use case is class<br>&gt; clusters. For the client code it is sealed and acts just like a final<br>&gt; class, but internally it may return a subclass that is an implementation<br>&gt; detail. We should be able to do this.<br>&gt;<br>&gt;<br>&gt; Agree and this is why I am willing to write the proposal for this.  There<br>&gt; was a discussion a few months ago about this problem and a few solutions<br>&gt; were kicked around.  The biggest problem with this approach at the time was<br>&gt; lack of a good name, which I believe we now have in Type.<br>&gt;<br>&gt; I&#39;m going to let the discussion continue for a day or two and will write a<br>&gt; proposal if no significant counter arguments arise.<br>&gt;<br>&gt; -Matthew<br>&gt;<br>&gt;<br>&gt; Hooman<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160510/97da3898/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[RFC] #Self</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 10, 2016 at 05:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 10, 2016, at 5:42 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; If the use case is to support certain protocol requirements rather than avoiding the recitation of long names, then it doesn&#39;t have to be short. IMO, `Type` is problematic because there&#39;s nothing in the meaning of the word to distinguish from `Self`, and in any case it&#39;s already used for the metatype type. `StaticSelf` is unambiguous.<br></p><p>I think both are valid uses so short is better but I agree that the distinction from Self is more readily apparent with StaticSelf.  I could live with either one.<br></p><p>&gt; <br>&gt; <br>&gt;&gt; On Tue, May 10, 2016 at 5:32 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt;&gt; On May 10, 2016, at 5:24 PM, Hooman Mehr &lt;hooman at mac.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 10, 2016, at 2:49 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; That said, Iâ€™m not sure I understand the concrete use-cases.  When is this concept important?  When is â€œSelfâ€ not good enough?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The only case where there is new functionality is when this is used in a protocol requirement.  I gave an example earlier today.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This functionality is the key: Ability of an open (non-final) class to conform to a protocol that lets it return an instance of the conforming type (itself). Self does not work for that and we canâ€™t change its behavior (or can we?) So one solution seems to be Mattâ€™s proposal. This functionality is important for me and an example use case is class clusters. For the client code it is sealed and acts just like a final class, but internally it may return a subclass that is an implementation detail. We should be able to do this.<br>&gt;&gt; <br>&gt;&gt; Agree and this is why I am willing to write the proposal for this.  There was a discussion a few months ago about this problem and a few solutions were kicked around.  The biggest problem with this approach at the time was lack of a good name, which I believe we now have in Type.<br>&gt;&gt; <br>&gt;&gt; I&#39;m going to let the discussion continue for a day or two and will write a proposal if no significant counter arguments arise.<br>&gt;&gt; <br>&gt;&gt; -Matthew<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hooman<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160510/49fceb5a/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[RFC] #Self</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>May 11, 2016 at 11:00:00am</p></header><div class="content"><p>I think Type fits really well. Because every class, struct, and enum gets a static member called â€˜Typeâ€™. But you can only use it outside the declaration (String.Type), not inside.<br></p><p>So similar to how types declared inside can be referenced:<br></p><p>struct A {<br>  enum Kind {<br>    case cat<br>    case dog<br>  }<br></p><p>  var kind: Kind // Use nested type here; I donâ€™t have to write A.Kind<br>}<br></p><p><br>We could use Type in a similar way:<br></p><p>struct B {<br>  // This gets created automatically for every type, and is accessible today from B.Type<br>  //metatype Type { â€¦ }<br></p><p>  var children: [Type] // Use here in the same way as Kind above<br>}<br></p><p><br>&gt; On 11 May 2016, at 8:32 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On May 10, 2016, at 5:24 PM, Hooman Mehr &lt;hooman at mac.com &lt;mailto:hooman at mac.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 10, 2016, at 2:49 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; That said, Iâ€™m not sure I understand the concrete use-cases.  When is this concept important?  When is â€œSelfâ€ not good enough?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The only case where there is new functionality is when this is used in a protocol requirement.  I gave an example earlier today.  <br>&gt;&gt; <br>&gt;&gt; This functionality is the key: Ability of an open (non-final) class to conform to a protocol that lets it return an instance of the conforming type (itself). Self does not work for that and we canâ€™t change its behavior (or can we?) So one solution seems to be Mattâ€™s proposal. This functionality is important for me and an example use case is class clusters. For the client code it is sealed and acts just like a final class, but internally it may return a subclass that is an implementation detail. We should be able to do this.<br>&gt; <br>&gt; Agree and this is why I am willing to write the proposal for this.  There was a discussion a few months ago about this problem and a few solutions were kicked around.  The biggest problem with this approach at the time was lack of a good name, which I believe we now have in Type.<br>&gt; <br>&gt; I&#39;m going to let the discussion continue for a day or two and will write a proposal if no significant counter arguments arise.<br>&gt; <br>&gt; -Matthew<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Hooman<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160511/fed070b5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[RFC] #Self</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May 10, 2016 at 09:00:00pm</p></header><div class="content"><p>On Tue, May 10, 2016 at 8:45 PM, Patrick Smith via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I think Type fits really well. Because every class, struct, and enum gets<br>&gt; a static member called â€˜Typeâ€™. But you can only use it outside the<br>&gt; declaration (String.Type), not inside.<br>&gt;<br>&gt; So similar to how types declared inside can be referenced:<br>&gt;<br>&gt; struct A {<br>&gt;   enum Kind {<br>&gt;     case cat<br>&gt;     case dog<br>&gt;   }<br>&gt;<br>&gt;   var kind: Kind // Use nested type here; I donâ€™t have to write A.Kind<br>&gt; }<br>&gt;<br>&gt;<br>&gt; We could use Type in a similar way:<br>&gt;<br>&gt; struct B {<br>&gt;   // This gets created automatically for every type, and is accessible<br>&gt; today from B.Type<br>&gt;   //metatype Type { â€¦ }<br>&gt;<br>&gt;   var children: [Type] // Use here in the same way as Kind above<br>&gt; }<br>&gt;<br></p><p>That&#39;s neat! My issue with it is that the analysis breaks down with<br>protocols. If we extend it there, it&#39;s difficult to rationalize why Type<br>has to mean the static type of the conforming class and Self has to mean<br>the dynamic type.<br></p><p><br>&gt;<br>&gt;<br>&gt; On 11 May 2016, at 8:32 AM, Matthew Johnson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; On May 10, 2016, at 5:24 PM, Hooman Mehr &lt;hooman at mac.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On May 10, 2016, at 2:49 PM, Matthew Johnson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; That said, Iâ€™m not sure I understand the concrete use-cases.  When is this<br>&gt; concept important?  When is â€œSelfâ€ not good enough?<br>&gt;<br>&gt;<br>&gt; The only case where there is new functionality is when this is used in a<br>&gt; protocol requirement.  I gave an example earlier today.<br>&gt;<br>&gt;<br>&gt; This functionality is the key: Ability of an open (non-final) class to<br>&gt; conform to a protocol that lets it return an instance of the conforming<br>&gt; type (itself). Self does not work for that and we canâ€™t change its behavior<br>&gt; (or can we?) So one solution seems to be Mattâ€™s proposal. This<br>&gt; functionality is important for me and an example use case is class<br>&gt; clusters. For the client code it is sealed and acts just like a final<br>&gt; class, but internally it may return a subclass that is an implementation<br>&gt; detail. We should be able to do this.<br>&gt;<br>&gt;<br>&gt; Agree and this is why I am willing to write the proposal for this.  There<br>&gt; was a discussion a few months ago about this problem and a few solutions<br>&gt; were kicked around.  The biggest problem with this approach at the time was<br>&gt; lack of a good name, which I believe we now have in Type.<br>&gt;<br>&gt; I&#39;m going to let the discussion continue for a day or two and will write a<br>&gt; proposal if no significant counter arguments arise.<br>&gt;<br>&gt; -Matthew<br>&gt;<br>&gt;<br>&gt; Hooman<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160510/3a8a39dd/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[RFC] #Self</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May 10, 2016 at 05:00:00pm</p></header><div class="content"><p>On Tue, May 10, 2016 at 5:24 PM, Hooman Mehr via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On May 10, 2016, at 2:49 PM, Matthew Johnson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; That said, Iâ€™m not sure I understand the concrete use-cases.  When is this<br>&gt; concept important?  When is â€œSelfâ€ not good enough?<br>&gt;<br>&gt;<br>&gt; The only case where there is new functionality is when this is used in a<br>&gt; protocol requirement.  I gave an example earlier today.<br>&gt;<br>&gt;<br>&gt; This functionality is the key: Ability of an open (non-final) class to<br>&gt; conform to a protocol that lets it return an instance of the conforming<br>&gt; type (itself). Self does not work for that and we canâ€™t change its behavior<br>&gt; (or can we?) So one solution seems to be Mattâ€™s proposal. This<br>&gt; functionality is important for me and an example use case is class<br>&gt; clusters. For the client code it is sealed and acts just like a final<br>&gt; class, but internally it may return a subclass that is an implementation<br>&gt; detail. We should be able to do this.<br>&gt;<br></p><p>Help me understand this. Maybe an example will help. Why is it a problem to<br>return the subclass instead of the base class?<br></p><p><br>&gt;<br>&gt; Hooman<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160510/0f4267ef/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[RFC] #Self</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 10, 2016 at 05:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 10, 2016, at 5:46 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Tue, May 10, 2016 at 5:24 PM, Hooman Mehr via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 10, 2016, at 2:49 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; That said, Iâ€™m not sure I understand the concrete use-cases.  When is this concept important?  When is â€œSelfâ€ not good enough?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The only case where there is new functionality is when this is used in a protocol requirement.  I gave an example earlier today.  <br>&gt;&gt; <br>&gt;&gt; This functionality is the key: Ability of an open (non-final) class to conform to a protocol that lets it return an instance of the conforming type (itself). Self does not work for that and we canâ€™t change its behavior (or can we?) So one solution seems to be Mattâ€™s proposal. This functionality is important for me and an example use case is class clusters. For the client code it is sealed and acts just like a final class, but internally it may return a subclass that is an implementation detail. We should be able to do this.<br>&gt; <br>&gt; Help me understand this. Maybe an example will help. Why is it a problem to return the subclass instead of the base class?<br>&gt;  <br></p><p>The problem is that there is no way to guarantee that all subclasses of a non-final class provide the necessary override.  See the NSURL example I posted earlier today.<br></p><p>&gt;&gt; <br>&gt;&gt; Hooman<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160510/fd837086/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06130940a44c84dfc6c5aeabfd8482f8?s=50"></div><header><strong>[RFC] #Self</strong> from <string>Timothy Wood</string> &lt;tjw at me.com&gt;<p>May 10, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On May 10, 2016, at 2:01 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; That said, Iâ€™m not sure I understand the concrete use-cases.  When is this concept important?  When is â€œSelfâ€ not good enough?<br></p><p>From my old mail on the subject:<br></p><p>&gt; I would love to see a way to get the type of the &quot;enclosing thing at compile timeâ€. In my particular case, Iâ€™m using the type as a generic parameter to tag a created resource with something like:<br>&gt; <br>&gt; class Client: PropertyOwner {<br>&gt; 	let intProperty = Client.property(â€œnameâ€, Int(0))<br>&gt; }<br>&gt; <br>&gt; where PropertyOwner has a static property&lt;Owner, DataType&gt;(...)<br>&gt; <br>&gt; With `Self` meaning the static version of the thing being compiled, I could at least write:<br>&gt; <br>&gt; class Client: PropertyOwner {<br>&gt; 	let intProperty = Self.property(â€œnameâ€, Int(0))<br>&gt; }<br>&gt; <br>&gt; which would have the benefit of being harder to mess up due to copy-pasting between different PropertyOwner implementors.<br></p><p><br>and<br></p><p>&gt; I was thinking about the syntax a bit further and it seems like the capability that would be added is like #file, in that it does some compile-time textual replacement. So, perhaps #Self would work?<br>&gt; <br>&gt; Also, along these lines, I would find use for call-site interpolation like #file has. I could then do a free function version of my property() call that was something like:<br>&gt; <br>&gt; 	func property(ownerType: PropertyOwner.Type = #Self, ...) { }<br>&gt; <br>&gt; which would only be callable from w/in things conforming to or subclassing PropertyOwner.<br></p><p><br></p><p>-tim<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160510/2b88e0a3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[RFC] #Self</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 10, 2016 at 05:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 10, 2016, at 5:41 PM, Timothy Wood &lt;tjw at me.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 10, 2016, at 2:01 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; That said, Iâ€™m not sure I understand the concrete use-cases.  When is this concept important?  When is â€œSelfâ€ not good enough?<br>&gt; <br>&gt; From my old mail on the subject:<br>&gt; <br>&gt;&gt; I would love to see a way to get the type of the &quot;enclosing thing at compile timeâ€. In my particular case, Iâ€™m using the type as a generic parameter to tag a created resource with something like:<br>&gt;&gt; <br>&gt;&gt; class Client: PropertyOwner {<br>&gt;&gt; 	let intProperty = Client.property(â€œnameâ€, Int(0))<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; where PropertyOwner has a static property&lt;Owner, DataType&gt;(...)<br>&gt;&gt; <br>&gt;&gt; With `Self` meaning the static version of the thing being compiled, I could at least write:<br>&gt;&gt; <br>&gt;&gt; class Client: PropertyOwner {<br>&gt;&gt; 	let intProperty = Self.property(â€œnameâ€, Int(0))<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; which would have the benefit of being harder to mess up due to copy-pasting between different PropertyOwner implementors.<br>&gt; <br>&gt; <br>&gt; and<br>&gt; <br>&gt;&gt; I was thinking about the syntax a bit further and it seems like the capability that would be added is like #file, in that it does some compile-time textual replacement. So, perhaps #Self would work?<br>&gt;&gt; <br>&gt;&gt; Also, along these lines, I would find use for call-site interpolation like #file has. I could then do a free function version of my property() call that was something like:<br>&gt;&gt; <br>&gt;&gt; 	func property(ownerType: PropertyOwner.Type = #Self, ...) { }<br>&gt;&gt; <br>&gt;&gt; which would only be callable from w/in things conforming to or subclassing PropertyOwner.<br></p><p>Ahh, this is different than what I have been talking about as it statically evaluates at the call site rather than the declaration site.  Sorry, I think I missed your earlier post.<br></p><p>One question about this - how would it work if this method was called in a lexical con txt without an enclosing type declaration?  Would that be an error or would it just require a parameter to be passed?<br></p><p>If we call what I am talking about Type and we also want this behavior we should call it #Type as it would be the static type at the call site.  But they are separate ideas and should be separate proposals.<br></p><p>&gt; <br>&gt; <br>&gt; -tim<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160510/eb9af88a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06130940a44c84dfc6c5aeabfd8482f8?s=50"></div><header><strong>[RFC] #Self</strong> from <string>Timothy Wood</string> &lt;tjw at me.com&gt;<p>May 10, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On May 10, 2016, at 3:53 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Ahh, this is different than what I have been talking about as it statically evaluates at the call site rather than the declaration site.  Sorry, I think I missed your earlier post.<br></p><p>This would be no different from #file or #line in a default argument position, I think. If you use it in normal code:<br></p><p>	let cls = #Self<br></p><p>it would evaluate as weâ€™ve been discussing elsewhere here. I have had cases though, where using in a default parameter slot would be useulf (assuming it evaluates like #file and #line in those cases).<br></p><p><br>&gt; One question about this - how would it work if this method was called in a lexical con txt without an enclosing type declaration?  Would that be an error or would it just require a parameter to be passed?<br></p><p>I would expect it to be an error if there were no enclosing type and the parameter wasnâ€™t specified (but yeah, passing an explicit type should work).<br></p><p>&gt; If we call what I am talking about Type and we also want this behavior we should call it #Type as it would be the static type at the call site.  But they are separate ideas and should be separate proposals.<br></p><p>Again, this would only be the case in a default argument position; it would work just like the other â€œ#â€ symbols.<br></p><p>-tim<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160510/7cd37ad1/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06130940a44c84dfc6c5aeabfd8482f8?s=50"></div><header><strong>[RFC] #Self</strong> from <string>Timothy Wood</string> &lt;tjw at me.com&gt;<p>May 10, 2016 at 08:00:00am</p></header><div class="content"><p>The initial three cases Iâ€™d considered were:<br></p><p>1) Textual replacement inside struct/enum/class. This avoids longer boilerplate repetition, making code easier to read and refactor.<br></p><p>2) Default method arguments, like #file and #line, evaluated at the call site, not implementation site. So:<br></p><p>	--- A.swift ---<br></p><p>	class A {<br>		static func register(_ cls: A.Type = #Self.self)<br>	}<br></p><p>	--- B.swift ---<br></p><p>	class B : A {<br>		static func foo() {<br>			register()<br>		}<br>	}<br></p><p>	In this case, the `cls` argument would resolve to B.self (with the â€˜.selfâ€™ bits possibly not being needed in Swift 3).<br></p><p>3) Adoption points in protocols.<br></p><p>	protocol P {<br>		static func implementingClass() -&gt; P.Type {<br>			return #Self.self<br>		}<br>	}<br></p><p>	class A : P {}<br>	class B : A {}<br></p><p>	A.implementingClass() and B.implementingClass() would both return A.self<br></p><p><br>I suspect that case 1 is the easiest to discuss, but all three make sense to me personally. Perhaps they should be separate proposals, perhaps not. Also, Iâ€™m not sure if the implementation would have any ABI/resilience concerns (particularly for #2 and #3 where when crossing module boundaries.<br></p><p>-tim<br></p><p><br></p><p>&gt; On May 10, 2016, at 7:50 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; As a compile-time substitution, it could be used in any and all of the examples in your bullet list as a literal text replacement..<br>&gt; <br>&gt; Quick rundown:<br>&gt; <br>&gt; struct A {<br>&gt;    ...#Self... // #Self is substituted by A<br>&gt; }<br>&gt; <br>&gt; class B {<br>&gt;     ...#Self... // Self is substituted by B<br>&gt; }<br>&gt; <br>&gt; class C {<br>&gt;    ... #Self... // Self is substituted by C, which is the defining type at compile time<br>&gt; }<br>&gt; <br>&gt; I&#39;m stepping away from endorsing or pushing this forward. If you want to pick this up and run with it, it&#39;s yours.<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br>&gt;&gt; On May 10, 2016, at 8:34 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Can you clarify where would #Self would be allowed?<br>&gt;&gt; <br>&gt;&gt; * property declarations<br>&gt;&gt; * method signatures<br>&gt;&gt; * method and computed property bodies<br>&gt;&gt; * all of the above<br>&gt;&gt; <br>&gt;&gt; I would like to see this and allowed in all of the above.<br>&gt;&gt; <br>&gt;&gt; We should also consider allowing this in protocol requirements.  It would not covary like Self does for return types, instead being fixed by the class that declares conformance.<br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt; On May 10, 2016, at 8:15 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; To focus SE-0068 and narrow its scope, I removed the `#Self` part of the proposal. This offered compile-time substitution of the defining type for a related #Self literal:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A further static identifier, #Self expands to static type of the code it appears within, completing the ways code may want to refer to the type it is declared in. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; #Self expands to the static type of the code it is declared within. In value types, this is always the same as Self. In reference types, it refers to the declaring type. #Self will offer a literal textual replacement just like #file, etc.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; At Chris&#39;s suggestion, I&#39;m starting a new SE thread to see whether there remains any interest for including #Self in the language. I&#39;m personally happy with the SE-0068 outcome but I didn&#39;t want to undercut anyone like Timothy Wood who had originally spoken up for its inclusion.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- E<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160510/ebc948ac/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
