<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4bb2d8cd29d26d7067e8b62a5e1cbf95?s=50"></div><header><strong>[Pitch] Extend Any.Type to allow construction of bound generic types</strong> from <string>Joanna Carter</string> &lt;joanna at carterconsulting.org.uk&gt;<p>April 17, 2016 at 03:00:00pm</p></header><div class="content"><p>I often find myself needing to construct an instance of a bound generic type at runtime, in much the same manner as I would a &quot;standard&quot; type.<br></p><p>e.g.<br></p><p>As for a standard type…<br></p><p>let aType = Int.Type<br></p><p>let anInt = aType.init(0)<br></p><p>I also want to be able to use the same mechanism for a generic type…<br></p><p>struct MyStruct&lt;T: Equatable /*, etc */&gt;<br>{<br>  var value: T?<br>}<br></p><p>let paramType = // type from streaming or reflection compliant with Equatable<br></p><p>let structType = MyStruct&lt;paramType&gt;.self<br></p><p>let f = structType.init()<br></p><p><br>At present, the following compiler error is raised…<br></p><p>&#39;paramType&#39; is not a type<br></p><p>I am  the only one to require this behaviour? If not, do we want a proposal? If so, could you let me know your views on its worthiness?<br></p><p>Joanna<br></p><p>--<br>Joanna Carter<br>Carter Consulting<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Pitch] Extend Any.Type to allow construction of bound generic types</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>April 18, 2016 at 08:00:00am</p></header><div class="content"><p>I would also find this useful, should this be part of completing generics?<br></p><p>On Monday, 18 April 2016, Joanna Carter via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I often find myself needing to construct an instance of a bound generic<br>&gt; type at runtime, in much the same manner as I would a &quot;standard&quot; type.<br>&gt;<br>&gt; e.g.<br>&gt;<br>&gt; As for a standard type…<br>&gt;<br>&gt; let aType = Int.Type<br>&gt;<br>&gt; let anInt = aType.init(0)<br>&gt;<br>&gt; I also want to be able to use the same mechanism for a generic type…<br>&gt;<br>&gt; struct MyStruct&lt;T: Equatable /*, etc */&gt;<br>&gt; {<br>&gt;   var value: T?<br>&gt; }<br>&gt;<br>&gt; let paramType = // type from streaming or reflection compliant with<br>&gt; Equatable<br>&gt;<br>&gt; let structType = MyStruct&lt;paramType&gt;.self<br>&gt;<br>&gt; let f = structType.init()<br>&gt;<br>&gt;<br>&gt; At present, the following compiler error is raised…<br>&gt;<br>&gt; &#39;paramType&#39; is not a type<br>&gt;<br>&gt; I am  the only one to require this behaviour? If not, do we want a<br>&gt; proposal? If so, could you let me know your views on its worthiness?<br>&gt;<br>&gt; Joanna<br>&gt;<br>&gt; --<br>&gt; Joanna Carter<br>&gt; Carter Consulting<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br>-- <br>-- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160418/b5f5a1f6/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Pitch] Extend Any.Type to allow construction of bound generic types</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>April 18, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Apr 17, 2016, at 7:13 AM, Joanna Carter via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I often find myself needing to construct an instance of a bound generic type at runtime, in much the same manner as I would a &quot;standard&quot; type.<br>&gt; <br>&gt; e.g.<br>&gt; <br>&gt; As for a standard type…<br>&gt; <br>&gt; let aType = Int.Type<br>&gt; <br>&gt; let anInt = aType.init(0)<br>&gt; <br>&gt; I also want to be able to use the same mechanism for a generic type…<br>&gt; <br>&gt; struct MyStruct&lt;T: Equatable /*, etc */&gt;<br>&gt; {<br>&gt;  var value: T?<br>&gt; }<br>&gt; <br>&gt; let paramType = // type from streaming or reflection compliant with Equatable<br>&gt; <br>&gt; let structType = MyStruct&lt;paramType&gt;.self<br>&gt; <br>&gt; let f = structType.init()<br>&gt; <br>&gt; <br>&gt; At present, the following compiler error is raised…<br>&gt; <br>&gt; &#39;paramType&#39; is not a type<br>&gt; <br>&gt; I am  the only one to require this behaviour? If not, do we want a proposal? If so, could you let me know your views on its worthiness?<br></p><p><br>In programming-language circles, this feature is called “dependent types” (see, e.g., https://en.wikipedia.org/wiki/Dependent_type), and it introduces significant complicates into a type system. For example, determining whether two types are equivalent becomes a run-time property rather than a compile-time property. I don’t know if Swift will end with a dependently-typed type system. To get there, we would need a number of very strongly-motivating use cases illustrating how common programming tasks can be improved with dependent types,  and we would need to solid plan for managing the complexity—both implementation complexity in the compiler’s type checker and also the language complexity seen by Swift user’s when they encounter this feature. <br></p><p>	- Doug<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4bb2d8cd29d26d7067e8b62a5e1cbf95?s=50"></div><header><strong>[Pitch] Extend Any.Type to allow construction of bound generic types</strong> from <string>Joanna Carter</string> &lt;joanna at carterconsulting.org.uk&gt;<p>April 20, 2016 at 04:00:00pm</p></header><div class="content"><p>Hi Doug<br></p><p>&gt; In programming-language circles, this feature is called “dependent types” (see, e.g., https://en.wikipedia.org/wiki/Dependent_type), and it introduces significant complicates into a type system. For example, determining whether two types are equivalent becomes a run-time property rather than a compile-time property. I don’t know if Swift will end with a dependently-typed type system. To get there, we would need a number of very strongly-motivating use cases illustrating how common programming tasks can be improved with dependent types,  and we would need to solid plan for managing the complexity—both implementation complexity in the compiler’s type checker and also the language complexity seen by Swift user’s when they encounter this feature.<br></p><p>I must admit to being ever so slightly confused about your connection with &quot;dependent types&quot;; in all my years of programming, I have never come across the context of the expression as found in the article cited. Anything that needs algebraic formulae to explain is far too complicated for mere mortal programmers and I am willing to state that I certainly didn&#39;t understand more than a few words.<br></p><p>All I am postulating is the ability to create instances of generic types, bound to (a) parameter type(s) in the same manner as is currently possible with non-generic types.<br></p><p>To bring it down to basics, take the example of wanting to create an array of a given type of objects:<br></p><p>    let aType: Any.Type = Int.self<br>    <br>    var arr = [aType]<br></p><p>… creates an array of Any.type…<br>    <br>    let aType: Any.Type = Int.self<br>    <br>    var arr = [aType]()<br></p><p>… results in an error &quot;Invalid use of &#39;()&#39; to call a value of non-function type &#39;[Any.Type]&#39;&quot;<br></p><p>    let aType: Any.Type = Int.self<br>    <br>    var arr = Array&lt;aType&gt;() <br>    <br>… results in an error &quot;&#39;aType&#39; is not a type&quot;<br></p><p>  <br>So, how are we meant to be able to create arrays, or any other generic type that require to be bound to a type known only at runtime?<br></p><p>In C#, We have the Type class, which contains useful properties like isGenericType, isConstructedGenericType and methods like GetGenericArguments() and, most important to this use case, MakeGenericType(Type []).<br></p><p>I would make a strong argument for completing Swift generics by including such facilities in Any.Type, so that:<br></p><p>1. we do not have to use the somewhat cumbersome Mirror mechanism<br></p><p>2. we can do something useful with instances of Any.Type, which, at present, does absolutely nothing.<br></p><p>Adding similar functionality to C#&#39;s Type class to Any.Type would break absolutely zero code but would make life a whole load easier for those of us who are power users of generics. Otherwise, FMPOV, Swift generics are but a pale imitation of the concept and very much second class citizens in the language.<br></p><p>Joanna<br></p><p>--<br>Joanna Carter<br>Carter Consulting<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[Pitch] Extend Any.Type to allow construction of bound generic types</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>April 20, 2016 at 12:00:00pm</p></header><div class="content"><p>Just a quick thought, but isn&#39;t this what NSArray is for?  If you know the type of a thing at runtime, it&#39;s probably best to use the part of the language that will help you most in that area: the Objective-C bridge.  <br></p><p>Doug is right that this is the shade of dependent types and would require a computation rule in the type system.  For example, what type does Array have here:<br></p><p>// In some far-off module<br></p><p>func DefeatOptimizer() -&gt; Bool { return false }<br></p><p>// Back home again<br></p><p>var ty = Any.Type<br>for i in (0..&lt;INT_MAX) {<br>    sleep(i)<br>    if DefeatOptimizer() { return; }<br>    if (i % 2 == 0) {<br>      ty = Int.self<br>    } <br>    if (i % 2 == 1)  {<br>      ty = String.self<br>    }<br>}<br>var arr = Array&lt;ty&gt;()<br></p><p>To which you might say &quot;clearly it&#39;s Array&lt;ty&gt; like you said!&quot; but the type system still maintains a phase distinction between types and values so we&#39;ll have to compute it and that would be a little ridiculous, right?  If you wanted to clean this up, you might require something like the C++ constexpr restriction on the computation rule, but I can counter by recursing.  OK, so remove recursion.  What about a large stack of (potentially unoptimizable) branches?  Remove branching.  Now we&#39;re left with, well, your example and we&#39;re back to square one.<br></p><p>~Robert Widmann<br></p><p>2016/04/20 11:36、Joanna Carter via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br></p><p>&gt; Hi Doug<br>&gt; <br>&gt;&gt; In programming-language circles, this feature is called “dependent types” (see, e.g., https://en.wikipedia.org/wiki/Dependent_type), and it introduces significant complicates into a type system. For example, determining whether two types are equivalent becomes a run-time property rather than a compile-time property. I don’t know if Swift will end with a dependently-typed type system. To get there, we would need a number of very strongly-motivating use cases illustrating how common programming tasks can be improved with dependent types,  and we would need to solid plan for managing the complexity―both implementation complexity in the compiler’s type checker and also the language complexity seen by Swift user’s when they encounter this feature.<br>&gt; <br>&gt; I must admit to being ever so slightly confused about your connection with &quot;dependent types&quot;; in all my years of programming, I have never come across the context of the expression as found in the article cited. Anything that needs algebraic formulae to explain is far too complicated for mere mortal programmers and I am willing to state that I certainly didn&#39;t understand more than a few words.<br>&gt; <br>&gt; All I am postulating is the ability to create instances of generic types, bound to (a) parameter type(s) in the same manner as is currently possible with non-generic types.<br>&gt; <br>&gt; To bring it down to basics, take the example of wanting to create an array of a given type of objects:<br>&gt; <br>&gt;    let aType: Any.Type = Int.self<br>&gt; <br>&gt;    var arr = [aType]<br>&gt; <br>&gt; … creates an array of Any.type…<br>&gt; <br>&gt;    let aType: Any.Type = Int.self<br>&gt; <br>&gt;    var arr = [aType]()<br>&gt; <br>&gt; … results in an error &quot;Invalid use of &#39;()&#39; to call a value of non-function type &#39;[Any.Type]&#39;&quot;<br>&gt; <br>&gt;    let aType: Any.Type = Int.self<br>&gt; <br>&gt;    var arr = Array&lt;aType&gt;() <br>&gt; <br>&gt; … results in an error &quot;&#39;aType&#39; is not a type&quot;<br>&gt; <br>&gt; <br>&gt; So, how are we meant to be able to create arrays, or any other generic type that require to be bound to a type known only at runtime?<br>&gt; <br>&gt; In C#, We have the Type class, which contains useful properties like isGenericType, isConstructedGenericType and methods like GetGenericArguments() and, most important to this use case, MakeGenericType(Type []).<br>&gt; <br>&gt; I would make a strong argument for completing Swift generics by including such facilities in Any.Type, so that:<br>&gt; <br>&gt; 1. we do not have to use the somewhat cumbersome Mirror mechanism<br>&gt; <br>&gt; 2. we can do something useful with instances of Any.Type, which, at present, does absolutely nothing.<br>&gt; <br>&gt; Adding similar functionality to C#&#39;s Type class to Any.Type would break absolutely zero code but would make life a whole load easier for those of us who are power users of generics. Otherwise, FMPOV, Swift generics are but a pale imitation of the concept and very much second class citizens in the language.<br>&gt; <br>&gt; Joanna<br>&gt; <br>&gt; --<br>&gt; Joanna Carter<br>&gt; Carter Consulting<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Pitch] Extend Any.Type to allow construction of bound generic types</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>April 20, 2016 at 10:00:00am</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On Apr 20, 2016, at 8:36 AM, Joanna Carter &lt;joanna at carterconsulting.org.uk&gt; wrote:<br>&gt; <br>&gt; Hi Doug<br>&gt; <br>&gt;&gt; In programming-language circles, this feature is called “dependent types” (see, e.g., https://en.wikipedia.org/wiki/Dependent_type), and it introduces significant complicates into a type system. For example, determining whether two types are equivalent becomes a run-time property rather than a compile-time property. I don’t know if Swift will end with a dependently-typed type system. To get there, we would need a number of very strongly-motivating use cases illustrating how common programming tasks can be improved with dependent types,  and we would need to solid plan for managing the complexity—both implementation complexity in the compiler’s type checker and also the language complexity seen by Swift user’s when they encounter this feature.<br>&gt; <br>&gt; I must admit to being ever so slightly confused about your connection with &quot;dependent types&quot;; in all my years of programming, I have never come across the context of the expression as found in the article cited. Anything that needs algebraic formulae to explain is far too complicated for mere mortal programmers and I am willing to state that I certainly didn&#39;t understand more than a few words.<br></p><p>Programming language theory (PL) tends to be painfully formal; much of what Swift&#39;s type system can be describe in PL  formalisms as well. <br></p><p>My point is that your suggestion falls into a known theoretical framework that adds significant complications to the type system (and compiler pipeline in general). That complexity needs to be understood and managed. <br></p><p>&gt; <br>&gt; All I am postulating is the ability to create instances of generic types, bound to (a) parameter type(s) in the same manner as is currently possible with non-generic types.<br></p><p>Yes. It&#39;s bringing runtime type information into the static type system. <br></p><p>&gt; <br>&gt; To bring it down to basics, take the example of wanting to create an array of a given type of objects:<br>&gt; <br>&gt;    let aType: Any.Type = Int.self<br>&gt; <br>&gt;    var arr = [aType]<br>&gt; <br>&gt; … creates an array of Any.type…<br>&gt; <br>&gt;    let aType: Any.Type = Int.self<br>&gt; <br>&gt;    var arr = [aType]()<br>&gt; <br>&gt; … results in an error &quot;Invalid use of &#39;()&#39; to call a value of non-function type &#39;[Any.Type]&#39;&quot;<br>&gt; <br>&gt;    let aType: Any.Type = Int.self<br>&gt; <br>&gt;    var arr = Array&lt;aType&gt;() <br>&gt; <br>&gt; … results in an error &quot;&#39;aType&#39; is not a type&quot;<br>&gt; <br>&gt; <br>&gt; So, how are we meant to be able to create arrays, or any other generic type that require to be bound to a type known only at runtime?<br></p><p>[Any] is a heterogenous array of elements whose types are known only at runtime. <br></p><p>&gt; In C#, We have the Type class, which contains useful properties like isGenericType, isConstructedGenericType and methods like GetGenericArguments() and, most important to this use case, MakeGenericType(Type []).<br></p><p>This is a reflection facility. Swift should get better reflection, but that&#39;s a very different thing from dependent types. <br></p><p>&gt; <br>&gt; I would make a strong argument for completing Swift generics by including such facilities in Any.Type, so that:<br>&gt; <br>&gt; 1. we do not have to use the somewhat cumbersome Mirror mechanism<br>&gt; <br>&gt; 2. we can do something useful with instances of Any.Type, which, at present, does absolutely nothing.<br>&gt; <br>&gt; Adding similar functionality to C#&#39;s Type class to Any.Type would break absolutely zero code but would make life a whole load easier for those of us who are power users of generics. Otherwise, FMPOV, Swift generics are but a pale imitation of the concept and very much second class citizens <br></p><p>It&#39;s a stretch to call reflection part of the generics system, but it is a feature were interested in improving upon in the future. <br></p><p>  - Doug<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[Pitch] Extend Any.Type to allow construction of bound generic types</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>April 20, 2016 at 11:00:00pm</p></header><div class="content"><p>If I needed functionality like this, I would create an enum with a case and associated value for every type I needed.<br>enum AnyValue : Equatable {  case int(Int)  case string(String)  // etc}<br></p><p>Patrick<br></p><p><br></p><p><br>On Sun, Apr 17, 2016 at 7:13 AM -0700, &quot;Joanna Carter via swift-evolution&quot; &lt;swift-evolution at swift.org&gt; wrote:<br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br>I often find myself needing to construct an instance of a bound generic type at runtime, in much the same manner as I would a &quot;standard&quot; type.<br></p><p>e.g.<br></p><p>As for a standard type…<br></p><p>let aType = Int.Type<br></p><p>let anInt = aType.init(0)<br></p><p>I also want to be able to use the same mechanism for a generic type…<br></p><p>struct MyStruct<br>{<br>  var value: T?<br>}<br></p><p>let paramType = // type from streaming or reflection compliant with Equatable<br></p><p>let structType = MyStruct.self<br></p><p>let f = structType.init()<br></p><p><br>At present, the following compiler error is raised…<br></p><p>&#39;paramType&#39; is not a type<br></p><p>I am  the only one to require this behaviour? If not, do we want a proposal? If so, could you let me know your views on its worthiness?<br></p><p>Joanna<br></p><p>--<br>Joanna Carter<br>Carter Consulting<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160420/56964821/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
