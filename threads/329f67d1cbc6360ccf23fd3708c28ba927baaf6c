<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b2fc174169a3054f2e9bcb366884b02b?s=50"></div><header><strong>SR-104: Improve Crash-Safety when Importing Objective-C Code Without Nullability Attributes</strong> from <string>Fabian Ehrentraud</string> &lt;Fabian.Ehrentraud at willhaben.at&gt;<p>December  8, 2015 at 12:00:00pm</p></header><div class="content"><p>Swift code accessing Objective-C methods can easily crash - if the Objective-C code does not include nullability attributes, the code is brought as implicitly unwrapped into Swift, where unsafe accesses do not produce compiler warnings.<br></p><p>I created issue SR-104 for this, but as suggested by Jordan Rose it should be discussed on this mailing list first.<br></p><p>Short example:<br></p><p>// Objective-C  <br>- (NSString *)giveMeAString { return nil; }  <br></p><p>// Swift  <br>func thisWillCrash() {  <br>    let string = someObjectiveCObject.giveMeAString()  <br>    let length = string.length // crash  <br>}<br></p><p>The ClangImporter could handle this issue in several safer ways:<br></p><p>1. Only import declarations that are nullability annotated (as proposed by Greg Parker)<br>Positive side effect would be that it would motivate to write nullability annotations.<br></p><p>2. Import un-annotated code as Optional<br>Values would need to be unwrapped every time, which does not hurt too much due to the easy use of the `?` syntactic sugar.<br></p><p>What do you think? Would this make Swift more safe when used together with Objective-C?<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c0eafab7106ab63b8db4025e57c1a8d2?s=50"></div><header><strong>SR-104: Improve Crash-Safety when Importing Objective-C Code Without Nullability Attributes</strong> from <string>Javier Soto</string> &lt;javier.api at gmail.com&gt;<p>December  8, 2015 at 03:00:00pm</p></header><div class="content"><p>I think the decision to import Obj-C APIs with implicitly unwrapped<br>optionals was a very pragmatic decision at the time. However, given it&#39;s<br>been over a year (I think?) since the nullability specifiers have been<br>available, I agree with you this could now be improved.<br></p><p>I personally prefer #2: it mimics the old Obj-C behavior (&quot;calling a method<br>on nil doesn&#39;t do anything and any method can take or return nil&quot;) if you<br>use &quot;?.&quot; everywhere. This would be somewhat cumbersome, but like you say<br>would encourage library developers to add these specifiers.<br>In practice, many developers will work with Apple&#39;s frameworks, and Apple<br>has done a great job tagged all/most of their APIs!<br>On Tue, Dec 8, 2015 at 4:09 AM Fabian Ehrentraud via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Swift code accessing Objective-C methods can easily crash - if the<br>&gt; Objective-C code does not include nullability attributes, the code is<br>&gt; brought as implicitly unwrapped into Swift, where unsafe accesses do not<br>&gt; produce compiler warnings.<br>&gt;<br>&gt; I created issue SR-104 for this, but as suggested by Jordan Rose it should<br>&gt; be discussed on this mailing list first.<br>&gt;<br>&gt; Short example:<br>&gt;<br>&gt; // Objective-C<br>&gt; - (NSString *)giveMeAString { return nil; }<br>&gt;<br>&gt; // Swift<br>&gt; func thisWillCrash() {<br>&gt;     let string = someObjectiveCObject.giveMeAString()<br>&gt;     let length = string.length // crash<br>&gt; }<br>&gt;<br>&gt; The ClangImporter could handle this issue in several safer ways:<br>&gt;<br>&gt; 1. Only import declarations that are nullability annotated (as proposed by<br>&gt; Greg Parker)<br>&gt; Positive side effect would be that it would motivate to write nullability<br>&gt; annotations.<br>&gt;<br>&gt; 2. Import un-annotated code as Optional<br>&gt; Values would need to be unwrapped every time, which does not hurt too much<br>&gt; due to the easy use of the `?` syntactic sugar.<br>&gt;<br>&gt; What do you think? Would this make Swift more safe when used together with<br>&gt; Objective-C?<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-- <br>Javier Soto<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/7425f848/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>SR-104: Improve Crash-Safety when Importing Objective-C Code Without Nullability Attributes</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December  8, 2015 at 10:00:00pm</p></header><div class="content"><p>&gt; On Dec 8, 2015, at 4:09 AM, Fabian Ehrentraud via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Swift code accessing Objective-C methods can easily crash - if the Objective-C code does not include nullability attributes, the code is brought as implicitly unwrapped into Swift, where unsafe accesses do not produce compiler warnings.<br>&gt; <br>&gt; I created issue SR-104 for this, but as suggested by Jordan Rose it should be discussed on this mailing list first.<br>&gt; <br>&gt; Short example:<br>&gt; <br>&gt; // Objective-C  <br>&gt; - (NSString *)giveMeAString { return nil; }  <br>&gt; <br>&gt; // Swift  <br>&gt; func thisWillCrash() {  <br>&gt;    let string = someObjectiveCObject.giveMeAString()  <br>&gt;    let length = string.length // crash  <br>&gt; }<br>&gt; <br>&gt; The ClangImporter could handle this issue in several safer ways:<br>&gt; <br>&gt; 1. Only import declarations that are nullability annotated (as proposed by Greg Parker)<br>&gt; Positive side effect would be that it would motivate to write nullability annotations.<br></p><p>This seems unfortunate to me, because it would severely hamper interoperating with Objective-C and *C* APIs that have not been audited.  While Apple is keen to audit their APIs, I doubt that all the linux system headers will get updated in a timely manner and users don’t generally have a way to do anything about that.<br></p><p>&gt; 2. Import un-annotated code as Optional<br>&gt; Values would need to be unwrapped every time, which does not hurt too much due to the easy use of the `?` syntactic sugar.<br></p><p>This is a very interesting idea, one I haven’t considered recently.  I agree with you that this is worth considering, and I would love to see IUO just get summarily deleted :-)<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>SR-104: Improve Crash-Safety when Importing Objective-C Code Without Nullability Attributes</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>December  8, 2015 at 11:00:00pm</p></header><div class="content"><p>&gt; On Dec 8, 2015, at 10:11 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Dec 8, 2015, at 4:09 AM, Fabian Ehrentraud via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; 1. Only import declarations that are nullability annotated (as proposed by Greg Parker)<br>&gt;&gt; Positive side effect would be that it would motivate to write nullability annotations.<br>&gt; <br>&gt; This seems unfortunate to me, because it would severely hamper interoperating with Objective-C and *C* APIs that have not been audited.  While Apple is keen to audit their APIs, I doubt that all the linux system headers will get updated in a timely manner and users don’t generally have a way to do anything about that.<br></p><p>I&#39;m not sure that Apple will get all of its headers audited in a timely manner either. Platform APIs have long tails.<br></p><p>This would make bring-up of a new platform awfully painful, too. You wouldn&#39;t be able to do anything with your shiny new port of Swift without annotating a bunch of that platform&#39;s headers somehow.<br></p><p>Measuring the impact of not-importing or ugly-importing unannotated API should be a straightforward experiment using a modified Swift importer. <br>1. Hack the importer to record every un-annotated API that it sees.<br>2. Run the custom importer against some platform&#39;s SDK.<br>3. Look at the results and try to imagine how bad the world would be if those APIs were harder to use or missing entirely.<br></p><p><br>-- <br>Greg Parker     gparker at apple.com     Runtime Wrangler<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b2fc174169a3054f2e9bcb366884b02b?s=50"></div><header><strong>SR-104: Improve Crash-Safety when Importing Objective-C Code Without Nullability Attributes</strong> from <string>Fabian Ehrentraud</string> &lt;Fabian.Ehrentraud at willhaben.at&gt;<p>December  9, 2015 at 03:00:00pm</p></header><div class="content"><p>Would it be possible to output meaningful compile errors when calling an API method from Swift, that was not imported due to missing nullability annotations? If not, this could easily result in a lot of misspent developer time trying to find the issue why this method could not be called. There is a similar issue right now when trying to access a Swift class/method missing the @objc specifier from Objective-C.<br>Importing un-annotated code as Optional would not have these issues.<br></p><p>&gt; On 09.12.2015, at 08:04, Greg Parker &lt;gparker at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 8, 2015, at 10:11 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 8, 2015, at 4:09 AM, Fabian Ehrentraud via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. Only import declarations that are nullability annotated (as proposed by Greg Parker)<br>&gt;&gt;&gt; Positive side effect would be that it would motivate to write nullability annotations.<br>&gt;&gt; <br>&gt;&gt; This seems unfortunate to me, because it would severely hamper interoperating with Objective-C and *C* APIs that have not been audited.  While Apple is keen to audit their APIs, I doubt that all the linux system headers will get updated in a timely manner and users don’t generally have a way to do anything about that.<br>&gt; <br>&gt; I&#39;m not sure that Apple will get all of its headers audited in a timely manner either. Platform APIs have long tails.<br>&gt; <br>&gt; This would make bring-up of a new platform awfully painful, too. You wouldn&#39;t be able to do anything with your shiny new port of Swift without annotating a bunch of that platform&#39;s headers somehow.<br>&gt; <br>&gt; Measuring the impact of not-importing or ugly-importing unannotated API should be a straightforward experiment using a modified Swift importer. <br>&gt; 1. Hack the importer to record every un-annotated API that it sees.<br>&gt; 2. Run the custom importer against some platform&#39;s SDK.<br>&gt; 3. Look at the results and try to imagine how bad the world would be if those APIs were harder to use or missing entirely.<br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Greg Parker     gparker at apple.com     Runtime Wrangler<br>&gt; <br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b2fc174169a3054f2e9bcb366884b02b?s=50"></div><header><strong>SR-104: Improve Crash-Safety when Importing Objective-C Code Without Nullability Attributes</strong> from <string>Fabian Ehrentraud</string> &lt;Fabian.Ehrentraud at willhaben.at&gt;<p>December 10, 2015 at 11:00:00am</p></header><div class="content"><p>Are there any objections to variant 2 &quot;Import un-annotated code as Optional&quot;? If not, I would create the proposal. <br></p><p>&gt; Am 09.12.2015 um 07:11 schrieb Chris Lattner &lt;clattner at apple.com&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 8, 2015, at 4:09 AM, Fabian Ehrentraud via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Swift code accessing Objective-C methods can easily crash - if the Objective-C code does not include nullability attributes, the code is brought as implicitly unwrapped into Swift, where unsafe accesses do not produce compiler warnings.<br>&gt;&gt; <br>&gt;&gt; I created issue SR-104 for this, but as suggested by Jordan Rose it should be discussed on this mailing list first.<br>&gt;&gt; <br>&gt;&gt; Short example:<br>&gt;&gt; <br>&gt;&gt; // Objective-C  <br>&gt;&gt; - (NSString *)giveMeAString { return nil; }  <br>&gt;&gt; <br>&gt;&gt; // Swift  <br>&gt;&gt; func thisWillCrash() {  <br>&gt;&gt;   let string = someObjectiveCObject.giveMeAString()  <br>&gt;&gt;   let length = string.length // crash  <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; The ClangImporter could handle this issue in several safer ways:<br>&gt;&gt; <br>&gt;&gt; 1. Only import declarations that are nullability annotated (as proposed by Greg Parker)<br>&gt;&gt; Positive side effect would be that it would motivate to write nullability annotations.<br>&gt; <br>&gt; This seems unfortunate to me, because it would severely hamper interoperating with Objective-C and *C* APIs that have not been audited.  While Apple is keen to audit their APIs, I doubt that all the linux system headers will get updated in a timely manner and users don’t generally have a way to do anything about that.<br>&gt; <br>&gt;&gt; 2. Import un-annotated code as Optional<br>&gt;&gt; Values would need to be unwrapped every time, which does not hurt too much due to the easy use of the `?` syntactic sugar.<br>&gt; <br>&gt; This is a very interesting idea, one I haven’t considered recently.  I agree with you that this is worth considering, and I would love to see IUO just get summarily deleted :-)<br>&gt; <br>&gt; -Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b2fc174169a3054f2e9bcb366884b02b?s=50"></div><header><strong>SR-104: Improve Crash-Safety when Importing Objective-C Code Without Nullability Attributes</strong> from <string>Fabian Ehrentraud</string> &lt;Fabian.Ehrentraud at willhaben.at&gt;<p>December 10, 2015 at 04:00:00pm</p></header><div class="content"><p>I created the proposal, no PR yet. Is something missing / everything clear?<br>https://github.com/fabb/swift-evolution/blob/import_as_optional_by_default/proposals/0008-import-as-optional-by-default.md<br></p><p><br>On 10.12.2015, at 12:42, Fabian Ehrentraud via swift-evolution &lt;swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br></p><p>Are there any objections to variant 2 &quot;Import un-annotated code as Optional&quot;? If not, I would create the proposal.<br></p><p>Am 09.12.2015 um 07:11 schrieb Chris Lattner &lt;clattner at apple.com&lt;mailto:clattner at apple.com&gt;&gt;:<br></p><p><br>On Dec 8, 2015, at 4:09 AM, Fabian Ehrentraud via swift-evolution &lt;swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br></p><p>Swift code accessing Objective-C methods can easily crash - if the Objective-C code does not include nullability attributes, the code is brought as implicitly unwrapped into Swift, where unsafe accesses do not produce compiler warnings.<br></p><p>I created issue SR-104 for this, but as suggested by Jordan Rose it should be discussed on this mailing list first.<br></p><p>Short example:<br></p><p>// Objective-C<br>- (NSString *)giveMeAString { return nil; }<br></p><p>// Swift<br>func thisWillCrash() {<br> let string = someObjectiveCObject.giveMeAString()<br> let length = string.length // crash<br>}<br></p><p>The ClangImporter could handle this issue in several safer ways:<br></p><p>1. Only import declarations that are nullability annotated (as proposed by Greg Parker)<br>Positive side effect would be that it would motivate to write nullability annotations.<br></p><p>This seems unfortunate to me, because it would severely hamper interoperating with Objective-C and *C* APIs that have not been audited.  While Apple is keen to audit their APIs, I doubt that all the linux system headers will get updated in a timely manner and users don’t generally have a way to do anything about that.<br></p><p>2. Import un-annotated code as Optional<br>Values would need to be unwrapped every time, which does not hurt too much due to the easy use of the `?` syntactic sugar.<br></p><p>This is a very interesting idea, one I haven’t considered recently.  I agree with you that this is worth considering, and I would love to see IUO just get summarily deleted :-)<br></p><p>-Chris<br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/da3b4983/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>SR-104: Improve Crash-Safety when Importing Objective-C Code Without Nullability Attributes</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>December 10, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 10, 2015, at 3:42 AM, Fabian Ehrentraud via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Are there any objections to variant 2 &quot;Import un-annotated code as Optional&quot;? If not, I would create the proposal. <br></p><p>I’m opposed to this. <br></p><p>First of all, this affects a lot of APIs. I went ahead and grepped through the API dumps over at<br></p><p>	https://github.com/apple/swift-3-api-guidelines-review<br></p><p>to see how often implicitly-unwrapped optionals came through in the Cocoa APIs, and there are lots of them. For example, on OS X, grepping for !’s finds:<br></p><p>	4132 functions/methods<br>	2281 properties<br>	409 initializers<br></p><p>On iOS, which has a smaller number of overall APIs, the numbers are still pretty big:<br>	1071 functions/methods<br>	320 properties<br>	134 initializers<br></p><p>This may be a slight oversampling of the data—some of those might be explicitly annotated as _Null_unspecified in the (Objective-)C headers, some might be unavailable—but the scale of the impact here is very, very large.<br></p><p>Most of the implicitly unwrapped optionals we currently get from (Objective-)C APIs can, in fact, never be nil. Forcing programmers to deal with all of these values as full optionals leads to a ton of optional-related boilerplate that doesn’t actual help users write better code. Rather, it dilutes the effectiveness of optionals as a language feature: optionals should mean “nil matters here, think about it carefully!”. But if some large number of optionals people deal with on a day-to-day basis are instead “the compiler didn’t know, so you have to write !”, the useful meaning of the “true” optionals gets lost in the noise.<br></p><p>That said, I’d love for implicitly-unwrapped optionals to be used less often, and getting them further out of the type system would be beneficial for the Swift experience.<br></p><p>	- Doug<br></p><p>&gt; <br>&gt;&gt; Am 09.12.2015 um 07:11 schrieb Chris Lattner &lt;clattner at apple.com&gt;:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 8, 2015, at 4:09 AM, Fabian Ehrentraud via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift code accessing Objective-C methods can easily crash - if the Objective-C code does not include nullability attributes, the code is brought as implicitly unwrapped into Swift, where unsafe accesses do not produce compiler warnings.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I created issue SR-104 for this, but as suggested by Jordan Rose it should be discussed on this mailing list first.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Short example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Objective-C  <br>&gt;&gt;&gt; - (NSString *)giveMeAString { return nil; }  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Swift  <br>&gt;&gt;&gt; func thisWillCrash() {  <br>&gt;&gt;&gt;  let string = someObjectiveCObject.giveMeAString()  <br>&gt;&gt;&gt;  let length = string.length // crash  <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The ClangImporter could handle this issue in several safer ways:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. Only import declarations that are nullability annotated (as proposed by Greg Parker)<br>&gt;&gt;&gt; Positive side effect would be that it would motivate to write nullability annotations.<br>&gt;&gt; <br>&gt;&gt; This seems unfortunate to me, because it would severely hamper interoperating with Objective-C and *C* APIs that have not been audited.  While Apple is keen to audit their APIs, I doubt that all the linux system headers will get updated in a timely manner and users don’t generally have a way to do anything about that.<br>&gt;&gt; <br>&gt;&gt;&gt; 2. Import un-annotated code as Optional<br>&gt;&gt;&gt; Values would need to be unwrapped every time, which does not hurt too much due to the easy use of the `?` syntactic sugar.<br>&gt;&gt; <br>&gt;&gt; This is a very interesting idea, one I haven’t considered recently.  I agree with you that this is worth considering, and I would love to see IUO just get summarily deleted :-)<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b2fc174169a3054f2e9bcb366884b02b?s=50"></div><header><strong>SR-104: Improve Crash-Safety when Importing Objective-C Code Without Nullability Attributes</strong> from <string>Fabian Ehrentraud</string> &lt;Fabian.Ehrentraud at willhaben.at&gt;<p>December 10, 2015 at 09:00:00pm</p></header><div class="content"><p>Too bad to hear you are opposed to the change.<br>Thank you for the hint at the API dumps - this is really something that should be referenced in the proposal.<br></p><p>&gt; First of all, this affects a lot of APIs. I went ahead and grepped through the API dumps [...] to see how often implicitly-unwrapped optionals came through in the Cocoa APIs, and there are lots of them. For example, on OS X, grepping for !’s finds:<br></p><p>We should come to a common way to count the occurrences of affected APIs (despite that users would also need to adapt for un-annotated 3rd-party frameworks, and the own mixed&amp;matched application code).<br>When I counted, it resulted in less than half the numbers for initializers and functions/methods.<br></p><p>There are many comment lines in the API dumps that contain /*! - we should not count those.<br>Also for functions/methods, input-parameters do not matter, due to automatic Optional wrapping on the Swift side. Maybe closure parameters that have implicitly unwrapped optional arguments themselves should be counted too. (anything else?)<br></p><p>Initializers:<br></p><p>Should we only count &quot;init!&quot; instances?<br>$ grep init! . | wc -l<br>=&gt; OSX 152, iOS 42<br></p><p>Other initializers containing ! in another place (I guess not relevant for the proposal)<br>$ grep -r ! . | grep init | grep -v &#39;\/\*\!&#39; | grep -v init!<br></p><p>Functions/Methods:<br></p><p>Only counting those that have a return type with an implicitly unwrapped optional. This does not take into account closure parameters that have implicitly unwrapped optional arguments themselves though.<br>$ grep -r ! . | grep func | grep &#39;\-&gt;&#39; | grep -v &#39;\/\*\!&#39; | grep -e &#39;\!$&#39; | wc -l<br>=&gt; OSX 1577, iOS 452<br></p><p>Properties:<br></p><p>$ grep -r ! . | grep -e &quot;let &quot; | grep -v &#39;\/\*\!&#39; | wc -l<br>=&gt; OSX 1120, iOS 336<br></p><p>Constants:<br></p><p>I noticed there are many constants that get translated to implicitly unwrapped optionals (e.g. in iOS CoreFoundation.swift). Would they be affected by the change in this proposal? Or are they &quot;explicitly set to implicitly unwrapped&quot; by the importer?<br></p><p><br>&gt; Most of the implicitly unwrapped optionals we currently get from (Objective-)C APIs can, in fact, never be nil. Forcing programmers to deal with all of these values as full optionals leads to a ton of optional-related boilerplate that doesn’t actual help users write better code. Rather, it dilutes the effectiveness of optionals as a language feature: optionals should mean “nil matters here, think about it carefully!”. But if some large number of optionals people deal with on a day-to-day basis are instead “the compiler didn’t know, so you have to write !”, the useful meaning of the “true” optionals gets lost in the noise.<br></p><p>I think exactly the opposite. If an API has not yet been audited, the client needs to consult the documentation if a return value can ever be nil. If not, she might explicitly and knowingly unwrap the value safely or non-safely. I deem this a good thing, as it prevents unknowingly unsafe use. I do not think that it would get in the way, as the syntactic sugar for Optionals is quite minimal. Also when the API gets audited for nullability later on, the compiler will hint which optional unwrappings have been rendered unnecessary.<br></p><p><br></p><p>&gt; On 10.12.2015, at 19:27, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 10, 2015, at 3:42 AM, Fabian Ehrentraud via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Are there any objections to variant 2 &quot;Import un-annotated code as Optional&quot;? If not, I would create the proposal. <br>&gt; <br>&gt; I’m opposed to this. <br>&gt; <br>&gt; First of all, this affects a lot of APIs. I went ahead and grepped through the API dumps over at<br>&gt; <br>&gt; 	https://github.com/apple/swift-3-api-guidelines-review<br>&gt; <br>&gt; to see how often implicitly-unwrapped optionals came through in the Cocoa APIs, and there are lots of them. For example, on OS X, grepping for !’s finds:<br>&gt; <br>&gt; 	4132 functions/methods<br>&gt; 	2281 properties<br>&gt; 	409 initializers<br>&gt; <br>&gt; On iOS, which has a smaller number of overall APIs, the numbers are still pretty big:<br>&gt; 	1071 functions/methods<br>&gt; 	320 properties<br>&gt; 	134 initializers<br>&gt; <br>&gt; This may be a slight oversampling of the data—some of those might be explicitly annotated as _Null_unspecified in the (Objective-)C headers, some might be unavailable—but the scale of the impact here is very, very large.<br>&gt; <br>&gt; Most of the implicitly unwrapped optionals we currently get from (Objective-)C APIs can, in fact, never be nil. Forcing programmers to deal with all of these values as full optionals leads to a ton of optional-related boilerplate that doesn’t actual help users write better code. Rather, it dilutes the effectiveness of optionals as a language feature: optionals should mean “nil matters here, think about it carefully!”. But if some large number of optionals people deal with on a day-to-day basis are instead “the compiler didn’t know, so you have to write !”, the useful meaning of the “true” optionals gets lost in the noise.<br>&gt; <br>&gt; That said, I’d love for implicitly-unwrapped optionals to be used less often, and getting them further out of the type system would be beneficial for the Swift experience.<br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Am 09.12.2015 um 07:11 schrieb Chris Lattner &lt;clattner at apple.com&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 8, 2015, at 4:09 AM, Fabian Ehrentraud via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Swift code accessing Objective-C methods can easily crash - if the Objective-C code does not include nullability attributes, the code is brought as implicitly unwrapped into Swift, where unsafe accesses do not produce compiler warnings.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I created issue SR-104 for this, but as suggested by Jordan Rose it should be discussed on this mailing list first.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Short example:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // Objective-C  <br>&gt;&gt;&gt;&gt; - (NSString *)giveMeAString { return nil; }  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // Swift  <br>&gt;&gt;&gt;&gt; func thisWillCrash() {  <br>&gt;&gt;&gt;&gt; let string = someObjectiveCObject.giveMeAString()  <br>&gt;&gt;&gt;&gt; let length = string.length // crash  <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The ClangImporter could handle this issue in several safer ways:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. Only import declarations that are nullability annotated (as proposed by Greg Parker)<br>&gt;&gt;&gt;&gt; Positive side effect would be that it would motivate to write nullability annotations.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This seems unfortunate to me, because it would severely hamper interoperating with Objective-C and *C* APIs that have not been audited.  While Apple is keen to audit their APIs, I doubt that all the linux system headers will get updated in a timely manner and users don’t generally have a way to do anything about that.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2. Import un-annotated code as Optional<br>&gt;&gt;&gt;&gt; Values would need to be unwrapped every time, which does not hurt too much due to the easy use of the `?` syntactic sugar.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a very interesting idea, one I haven’t considered recently.  I agree with you that this is worth considering, and I would love to see IUO just get summarily deleted :-)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ac9ffe13f5587e6a3a2e697f63a415fe?s=50"></div><header><strong>SR-104: Improve Crash-Safety when Importing Objective-C Code Without Nullability Attributes</strong> from <string>Michał Kałużny</string> &lt;maku at justmaku.org&gt;<p>December 10, 2015 at 10:00:00pm</p></header><div class="content"><p>I, on the other hand, totally agree with this proposal, even though it would break a lot of existing code. I believe that forcing the unwrap doesn’t cost much, especially with the new guard syntax introduced in Swift 2.0. This is obviously not a change that can be done in a minor release, but because we are in process of getting Swift 3.0 I believe we could introduce such behavior. This would somewhat force both Apple and 3rd party developers to make them use the nullability keywords even more in their code.<br></p><p>Regards,<br>M. <br></p><p>&gt; On Dec 10, 2015, at 10:22 PM, Fabian Ehrentraud via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Too bad to hear you are opposed to the change.<br>&gt; Thank you for the hint at the API dumps - this is really something that should be referenced in the proposal.<br>&gt; <br>&gt;&gt; First of all, this affects a lot of APIs. I went ahead and grepped through the API dumps [...] to see how often implicitly-unwrapped optionals came through in the Cocoa APIs, and there are lots of them. For example, on OS X, grepping for !’s finds:<br>&gt; <br>&gt; We should come to a common way to count the occurrences of affected APIs (despite that users would also need to adapt for un-annotated 3rd-party frameworks, and the own mixed&amp;matched application code).<br>&gt; When I counted, it resulted in less than half the numbers for initializers and functions/methods.<br>&gt; <br>&gt; There are many comment lines in the API dumps that contain /*! - we should not count those.<br>&gt; Also for functions/methods, input-parameters do not matter, due to automatic Optional wrapping on the Swift side. Maybe closure parameters that have implicitly unwrapped optional arguments themselves should be counted too. (anything else?)<br>&gt; <br>&gt; Initializers:<br>&gt; <br>&gt; Should we only count &quot;init!&quot; instances?<br>&gt; $ grep init! . | wc -l<br>&gt; =&gt; OSX 152, iOS 42<br>&gt; <br>&gt; Other initializers containing ! in another place (I guess not relevant for the proposal)<br>&gt; $ grep -r ! . | grep init | grep -v &#39;\/\*\!&#39; | grep -v init!<br>&gt; <br>&gt; Functions/Methods:<br>&gt; <br>&gt; Only counting those that have a return type with an implicitly unwrapped optional. This does not take into account closure parameters that have implicitly unwrapped optional arguments themselves though.<br>&gt; $ grep -r ! . | grep func | grep &#39;\-&gt;&#39; | grep -v &#39;\/\*\!&#39; | grep -e &#39;\!$&#39; | wc -l<br>&gt; =&gt; OSX 1577, iOS 452<br>&gt; <br>&gt; Properties:<br>&gt; <br>&gt; $ grep -r ! . | grep -e &quot;let &quot; | grep -v &#39;\/\*\!&#39; | wc -l<br>&gt; =&gt; OSX 1120, iOS 336<br>&gt; <br>&gt; Constants:<br>&gt; <br>&gt; I noticed there are many constants that get translated to implicitly unwrapped optionals (e.g. in iOS CoreFoundation.swift). Would they be affected by the change in this proposal? Or are they &quot;explicitly set to implicitly unwrapped&quot; by the importer?<br>&gt; <br>&gt; <br>&gt;&gt; Most of the implicitly unwrapped optionals we currently get from (Objective-)C APIs can, in fact, never be nil. Forcing programmers to deal with all of these values as full optionals leads to a ton of optional-related boilerplate that doesn’t actual help users write better code. Rather, it dilutes the effectiveness of optionals as a language feature: optionals should mean “nil matters here, think about it carefully!”. But if some large number of optionals people deal with on a day-to-day basis are instead “the compiler didn’t know, so you have to write !”, the useful meaning of the “true” optionals gets lost in the noise.<br>&gt; <br>&gt; I think exactly the opposite. If an API has not yet been audited, the client needs to consult the documentation if a return value can ever be nil. If not, she might explicitly and knowingly unwrap the value safely or non-safely. I deem this a good thing, as it prevents unknowingly unsafe use. I do not think that it would get in the way, as the syntactic sugar for Optionals is quite minimal. Also when the API gets audited for nullability later on, the compiler will hint which optional unwrappings have been rendered unnecessary.<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On 10.12.2015, at 19:27, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 10, 2015, at 3:42 AM, Fabian Ehrentraud via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Are there any objections to variant 2 &quot;Import un-annotated code as Optional&quot;? If not, I would create the proposal. <br>&gt;&gt; <br>&gt;&gt; I’m opposed to this. <br>&gt;&gt; <br>&gt;&gt; First of all, this affects a lot of APIs. I went ahead and grepped through the API dumps over at<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-3-api-guidelines-review<br>&gt;&gt; <br>&gt;&gt; to see how often implicitly-unwrapped optionals came through in the Cocoa APIs, and there are lots of them. For example, on OS X, grepping for !’s finds:<br>&gt;&gt; <br>&gt;&gt; 	4132 functions/methods<br>&gt;&gt; 	2281 properties<br>&gt;&gt; 	409 initializers<br>&gt;&gt; <br>&gt;&gt; On iOS, which has a smaller number of overall APIs, the numbers are still pretty big:<br>&gt;&gt; 	1071 functions/methods<br>&gt;&gt; 	320 properties<br>&gt;&gt; 	134 initializers<br>&gt;&gt; <br>&gt;&gt; This may be a slight oversampling of the data—some of those might be explicitly annotated as _Null_unspecified in the (Objective-)C headers, some might be unavailable—but the scale of the impact here is very, very large.<br>&gt;&gt; <br>&gt;&gt; Most of the implicitly unwrapped optionals we currently get from (Objective-)C APIs can, in fact, never be nil. Forcing programmers to deal with all of these values as full optionals leads to a ton of optional-related boilerplate that doesn’t actual help users write better code. Rather, it dilutes the effectiveness of optionals as a language feature: optionals should mean “nil matters here, think about it carefully!”. But if some large number of optionals people deal with on a day-to-day basis are instead “the compiler didn’t know, so you have to write !”, the useful meaning of the “true” optionals gets lost in the noise.<br>&gt;&gt; <br>&gt;&gt; That said, I’d love for implicitly-unwrapped optionals to be used less often, and getting them further out of the type system would be beneficial for the Swift experience.<br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 09.12.2015 um 07:11 schrieb Chris Lattner &lt;clattner at apple.com&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 8, 2015, at 4:09 AM, Fabian Ehrentraud via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Swift code accessing Objective-C methods can easily crash - if the Objective-C code does not include nullability attributes, the code is brought as implicitly unwrapped into Swift, where unsafe accesses do not produce compiler warnings.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I created issue SR-104 for this, but as suggested by Jordan Rose it should be discussed on this mailing list first.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Short example:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // Objective-C  <br>&gt;&gt;&gt;&gt;&gt; - (NSString *)giveMeAString { return nil; }  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // Swift  <br>&gt;&gt;&gt;&gt;&gt; func thisWillCrash() {  <br>&gt;&gt;&gt;&gt;&gt; let string = someObjectiveCObject.giveMeAString()  <br>&gt;&gt;&gt;&gt;&gt; let length = string.length // crash  <br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The ClangImporter could handle this issue in several safer ways:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 1. Only import declarations that are nullability annotated (as proposed by Greg Parker)<br>&gt;&gt;&gt;&gt;&gt; Positive side effect would be that it would motivate to write nullability annotations.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This seems unfortunate to me, because it would severely hamper interoperating with Objective-C and *C* APIs that have not been audited.  While Apple is keen to audit their APIs, I doubt that all the linux system headers will get updated in a timely manner and users don’t generally have a way to do anything about that.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2. Import un-annotated code as Optional<br>&gt;&gt;&gt;&gt;&gt; Values would need to be unwrapped every time, which does not hurt too much due to the easy use of the `?` syntactic sugar.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is a very interesting idea, one I haven’t considered recently.  I agree with you that this is worth considering, and I would love to see IUO just get summarily deleted :-)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>SR-104: Improve Crash-Safety when Importing Objective-C Code Without Nullability Attributes</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>December 10, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; On Dec 10, 2015, at 1:22 PM, Fabian Ehrentraud &lt;Fabian.Ehrentraud at willhaben.at&gt; wrote:<br>&gt; <br>&gt; Too bad to hear you are opposed to the change.<br>&gt; Thank you for the hint at the API dumps - this is really something that should be referenced in the proposal.<br>&gt; <br>&gt;&gt; First of all, this affects a lot of APIs. I went ahead and grepped through the API dumps [...] to see how often implicitly-unwrapped optionals came through in the Cocoa APIs, and there are lots of them. For example, on OS X, grepping for !’s finds:<br>&gt; <br>&gt; We should come to a common way to count the occurrences of affected APIs (despite that users would also need to adapt for un-annotated 3rd-party frameworks, and the own mixed&amp;matched application code).<br>&gt; When I counted, it resulted in less than half the numbers for initializers and functions/methods.<br>&gt; <br>&gt; There are many comment lines in the API dumps that contain /*! - we should not count those.<br></p><p>I didn’t, FWIW. Just “func”, “init”, or “var” lines that include !. <br></p><p>&gt; Also for functions/methods, input-parameters do not matter, due to automatic Optional wrapping on the Swift side. Maybe closure parameters that have implicitly unwrapped optional arguments themselves should be counted too. (anything else?)<br></p><p>Input parameters do matter, because their type communicates something: an optional input parameter says that “nil” has a meaning. An implicitly unwrapped optional input parameter says “check the docs!”. If we apply your proposal, you’re communicating meaning that “nil” is accepted in these input parameters when in fact the original (Objective-)C API never said such a thing, and very likely doesn’t permit “nil”. That actually makes it harder to use these APIs safely; at least when there are IUOs, we’re communicating “don’t know” to let the programmer decide what to do.<br></p><p>&gt; Initializers:<br>&gt; <br>&gt; Should we only count &quot;init!&quot; instances?<br>&gt; $ grep init! . | wc -l<br>&gt; =&gt; OSX 152, iOS 42<br>&gt; <br>&gt; Other initializers containing ! in another place (I guess not relevant for the proposal)<br>&gt; $ grep -r ! . | grep init | grep -v &#39;\/\*\!&#39; | grep -v init!<br>&gt; <br>&gt; Functions/Methods:<br>&gt; <br>&gt; Only counting those that have a return type with an implicitly unwrapped optional. This does not take into account closure parameters that have implicitly unwrapped optional arguments themselves though.<br>&gt; $ grep -r ! . | grep func | grep &#39;\-&gt;&#39; | grep -v &#39;\/\*\!&#39; | grep -e &#39;\!$&#39; | wc -l<br>&gt; =&gt; OSX 1577, iOS 452<br>&gt; <br>&gt; Properties:<br>&gt; <br>&gt; $ grep -r ! . | grep -e &quot;let &quot; | grep -v &#39;\/\*\!&#39; | wc -l<br>&gt; =&gt; OSX 1120, iOS 336<br>&gt; <br></p><p>This is still a large number of APIs that will require additional effort, where the common case is that you don’t care (because most things should be non-optional).<br></p><p><br>&gt; Constants:<br>&gt; <br>&gt; I noticed there are many constants that get translated to implicitly unwrapped optionals (e.g. in iOS CoreFoundation.swift). Would they be affected by the change in this proposal? Or are they &quot;explicitly set to implicitly unwrapped&quot; by the importer?<br></p><p>You can grep for “ull_unspecified” in the SDK to find the cases where things are explicitly set to implicitly unwrapped optionals; I doubt there are many.<br></p><p>&gt;&gt; Most of the implicitly unwrapped optionals we currently get from (Objective-)C APIs can, in fact, never be nil. Forcing programmers to deal with all of these values as full optionals leads to a ton of optional-related boilerplate that doesn’t actual help users write better code. Rather, it dilutes the effectiveness of optionals as a language feature: optionals should mean “nil matters here, think about it carefully!”. But if some large number of optionals people deal with on a day-to-day basis are instead “the compiler didn’t know, so you have to write !”, the useful meaning of the “true” optionals gets lost in the noise.<br>&gt; <br>&gt; I think exactly the opposite. If an API has not yet been audited, the client needs to consult the documentation if a return value can ever be nil. If not, she might explicitly and knowingly unwrap the value safely or non-safely. I deem this a good thing, as it prevents unknowingly unsafe use. I do not think that it would get in the way, as the syntactic sugar for Optionals is quite minimal. Also when the API gets audited for nullability later on, the compiler will hint which optional unwrappings have been rendered unnecessary.<br></p><p>You’re discounting my main argument, which is that the safety provided by optionals is contingent on the nil case being interesting most of the time. That’s generally true in “pure” Swift code—Swift programmers use optionals when nil matters—and it’s generally true in imported (Objective-)C code that has been audited, but your change would create a lot of optionals where “nil” isn’t actually interesting in practice.<br></p><p>	- Doug<br></p><p>&gt; <br>&gt; <br>&gt;&gt; On 10.12.2015, at 19:27, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 10, 2015, at 3:42 AM, Fabian Ehrentraud via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Are there any objections to variant 2 &quot;Import un-annotated code as Optional&quot;? If not, I would create the proposal. <br>&gt;&gt; <br>&gt;&gt; I’m opposed to this. <br>&gt;&gt; <br>&gt;&gt; First of all, this affects a lot of APIs. I went ahead and grepped through the API dumps over at<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-3-api-guidelines-review<br>&gt;&gt; <br>&gt;&gt; to see how often implicitly-unwrapped optionals came through in the Cocoa APIs, and there are lots of them. For example, on OS X, grepping for !’s finds:<br>&gt;&gt; <br>&gt;&gt; 	4132 functions/methods<br>&gt;&gt; 	2281 properties<br>&gt;&gt; 	409 initializers<br>&gt;&gt; <br>&gt;&gt; On iOS, which has a smaller number of overall APIs, the numbers are still pretty big:<br>&gt;&gt; 	1071 functions/methods<br>&gt;&gt; 	320 properties<br>&gt;&gt; 	134 initializers<br>&gt;&gt; <br>&gt;&gt; This may be a slight oversampling of the data—some of those might be explicitly annotated as _Null_unspecified in the (Objective-)C headers, some might be unavailable—but the scale of the impact here is very, very large.<br>&gt;&gt; <br>&gt;&gt; Most of the implicitly unwrapped optionals we currently get from (Objective-)C APIs can, in fact, never be nil. Forcing programmers to deal with all of these values as full optionals leads to a ton of optional-related boilerplate that doesn’t actual help users write better code. Rather, it dilutes the effectiveness of optionals as a language feature: optionals should mean “nil matters here, think about it carefully!”. But if some large number of optionals people deal with on a day-to-day basis are instead “the compiler didn’t know, so you have to write !”, the useful meaning of the “true” optionals gets lost in the noise.<br>&gt;&gt; <br>&gt;&gt; That said, I’d love for implicitly-unwrapped optionals to be used less often, and getting them further out of the type system would be beneficial for the Swift experience.<br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 09.12.2015 um 07:11 schrieb Chris Lattner &lt;clattner at apple.com&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 8, 2015, at 4:09 AM, Fabian Ehrentraud via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Swift code accessing Objective-C methods can easily crash - if the Objective-C code does not include nullability attributes, the code is brought as implicitly unwrapped into Swift, where unsafe accesses do not produce compiler warnings.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I created issue SR-104 for this, but as suggested by Jordan Rose it should be discussed on this mailing list first.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Short example:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // Objective-C  <br>&gt;&gt;&gt;&gt;&gt; - (NSString *)giveMeAString { return nil; }  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // Swift  <br>&gt;&gt;&gt;&gt;&gt; func thisWillCrash() {  <br>&gt;&gt;&gt;&gt;&gt; let string = someObjectiveCObject.giveMeAString()  <br>&gt;&gt;&gt;&gt;&gt; let length = string.length // crash  <br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The ClangImporter could handle this issue in several safer ways:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 1. Only import declarations that are nullability annotated (as proposed by Greg Parker)<br>&gt;&gt;&gt;&gt;&gt; Positive side effect would be that it would motivate to write nullability annotations.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This seems unfortunate to me, because it would severely hamper interoperating with Objective-C and *C* APIs that have not been audited.  While Apple is keen to audit their APIs, I doubt that all the linux system headers will get updated in a timely manner and users don’t generally have a way to do anything about that.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2. Import un-annotated code as Optional<br>&gt;&gt;&gt;&gt;&gt; Values would need to be unwrapped every time, which does not hurt too much due to the easy use of the `?` syntactic sugar.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is a very interesting idea, one I haven’t considered recently.  I agree with you that this is worth considering, and I would love to see IUO just get summarily deleted :-)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b2fc174169a3054f2e9bcb366884b02b?s=50"></div><header><strong>SR-104: Improve Crash-Safety when Importing Objective-C Code Without Nullability Attributes</strong> from <string>Fabian Ehrentraud</string> &lt;Fabian.Ehrentraud at willhaben.at&gt;<p>December 11, 2015 at 08:00:00am</p></header><div class="content"><p>On 10.12.2015, at 23:28, Douglas Gregor &lt;dgregor at apple.com&lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br></p><p><br>On Dec 10, 2015, at 1:22 PM, Fabian Ehrentraud &lt;Fabian.Ehrentraud at willhaben.at&lt;mailto:Fabian.Ehrentraud at willhaben.at&gt;&gt; wrote:<br></p><p>Too bad to hear you are opposed to the change.<br>Thank you for the hint at the API dumps - this is really something that should be referenced in the proposal.<br></p><p>First of all, this affects a lot of APIs. I went ahead and grepped through the API dumps [...] to see how often implicitly-unwrapped optionals came through in the Cocoa APIs, and there are lots of them. For example, on OS X, grepping for !’s finds:<br></p><p>We should come to a common way to count the occurrences of affected APIs (despite that users would also need to adapt for un-annotated 3rd-party frameworks, and the own mixed&amp;matched application code).<br>When I counted, it resulted in less than half the numbers for initializers and functions/methods.<br></p><p>There are many comment lines in the API dumps that contain /*! - we should not count those.<br></p><p>I didn’t, FWIW. Just “func”, “init”, or “var” lines that include !.<br></p><p>Some comment lines are included, yes, like this one for example:<br>./OSX/WebKit.swift:  /*! @abstract The URL of the initial request that created this item.<br></p><p><br>Also for functions/methods, input-parameters do not matter, due to automatic Optional wrapping on the Swift side. Maybe closure parameters that have implicitly unwrapped optional arguments themselves should be counted too. (anything else?)<br></p><p>Input parameters do matter, because their type communicates something: an optional input parameter says that “nil” has a meaning. An implicitly unwrapped optional input parameter says “check the docs!”. If we apply your proposal, you’re communicating meaning that “nil” is accepted in these input parameters when in fact the original (Objective-)C API never said such a thing, and very likely doesn’t permit “nil”. That actually makes it harder to use these APIs safely; at least when there are IUOs, we’re communicating “don’t know” to let the programmer decide what to do.<br></p><p>Ok this is a valid point. As keeping input parameters as implicitly unwrapped would not reduce the desired improvement of crash-resilience of this proposal, this could be explicitly exempted in the proposal.<br>Could you help me out? Which other kinds of parameters would benefit from defaulting to Optional? For one I guess closures which have non-annotated parameters themselves. In-Out Parameters? Is there a concrete method that springs to your mind as an example?<br></p><p><br>Initializers:<br></p><p>Should we only count &quot;init!&quot; instances?<br>$ grep init! . | wc -l<br>=&gt; OSX 152, iOS 42<br></p><p>Other initializers containing ! in another place (I guess not relevant for the proposal)<br>$ grep -r ! . | grep init | grep -v &#39;\/\*\!&#39; | grep -v init!<br></p><p>Functions/Methods:<br></p><p>Only counting those that have a return type with an implicitly unwrapped optional. This does not take into account closure parameters that have implicitly unwrapped optional arguments themselves though.<br>$ grep -r ! . | grep func | grep &#39;\-&gt;&#39; | grep -v &#39;\/\*\!&#39; | grep -e &#39;\!$&#39; | wc -l<br>=&gt; OSX 1577, iOS 452<br></p><p>Properties:<br></p><p>$ grep -r ! . | grep -e &quot;let &quot; | grep -v &#39;\/\*\!&#39; | wc -l<br>=&gt; OSX 1120, iOS 336<br></p><p><br>This is still a large number of APIs that will require additional effort, where the common case is that you don’t care (because most things should be non-optional).<br></p><p>Yes, but &quot;don&#39;t care&quot; should be a decision, not an oversight. Writing that ! yourself reminds you of that.<br></p><p>Please also consider non-API use cases of this proposal. If you have a big Objective-C app, and try to add some Swift code, e.g. by adding an Extension in Swift, your new Swift code is bound to call a lot of you own old Objective-C code. You do not get to see the methods the way Swift sees it.<br></p><p>E.g. you have a code snippet:<br></p><p>func someSwiftFuncInAnExtension() {<br></p><p>myDataModel.someProperty.someMethod()<br>}<br></p><p>You do not immediately see if myDataModel, someProperty or someMethod is written in Objective-C and missing nullability annotations. Swift should help you writing safe code.<br></p><p><br></p><p>Constants:<br></p><p>I noticed there are many constants that get translated to implicitly unwrapped optionals (e.g. in iOS CoreFoundation.swift). Would they be affected by the change in this proposal? Or are they &quot;explicitly set to implicitly unwrapped&quot; by the importer?<br></p><p>You can grep for “ull_unspecified” in the SDK to find the cases where things are explicitly set to implicitly unwrapped optionals; I doubt there are many.<br></p><p>Ok, thank you, so we do not need to consider those. I found 12 in iOS, in the 3 headers &quot;NSExtensionContext.h&quot;, &quot;NSExtensionItem.h&quot; and &quot;NSItemProvider.h&quot;.<br></p><p><br>Most of the implicitly unwrapped optionals we currently get from (Objective-)C APIs can, in fact, never be nil. Forcing programmers to deal with all of these values as full optionals leads to a ton of optional-related boilerplate that doesn’t actual help users write better code. Rather, it dilutes the effectiveness of optionals as a language feature: optionals should mean “nil matters here, think about it carefully!”. But if some large number of optionals people deal with on a day-to-day basis are instead “the compiler didn’t know, so you have to write !”, the useful meaning of the “true” optionals gets lost in the noise.<br></p><p>I think exactly the opposite. If an API has not yet been audited, the client needs to consult the documentation if a return value can ever be nil. If not, she might explicitly and knowingly unwrap the value safely or non-safely. I deem this a good thing, as it prevents unknowingly unsafe use. I do not think that it would get in the way, as the syntactic sugar for Optionals is quite minimal. Also when the API gets audited for nullability later on, the compiler will hint which optional unwrappings have been rendered unnecessary.<br></p><p>You’re discounting my main argument, which is that the safety provided by optionals is contingent on the nil case being interesting most of the time. That’s generally true in “pure” Swift code—Swift programmers use optionals when nil matters—and it’s generally true in imported (Objective-)C code that has been audited, but your change would create a lot of optionals where “nil” isn’t actually interesting in practice.<br></p><p>Have I understood it right that your argument is that defaulting to Optionals would would make them loose their meaning and result in programmers just use ! too often, also in cases where the nil case should properly be handled? I see the point. And I&#39;m thankful for this constructive discussion.<br></p><p>Nonetheless I think that Swift preventing unintentional mistakes would be something to strive for. Have you got alternative ideas on how to deal with the issue this proposal tries to address?<br></p><p><br>- Doug<br></p><p><br></p><p>On 10.12.2015, at 19:27, Douglas Gregor &lt;dgregor at apple.com&lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br></p><p><br>On Dec 10, 2015, at 3:42 AM, Fabian Ehrentraud via swift-evolution &lt;swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br></p><p>Are there any objections to variant 2 &quot;Import un-annotated code as Optional&quot;? If not, I would create the proposal.<br></p><p>I’m opposed to this.<br></p><p>First of all, this affects a lot of APIs. I went ahead and grepped through the API dumps over at<br></p><p>https://github.com/apple/swift-3-api-guidelines-review<br></p><p>to see how often implicitly-unwrapped optionals came through in the Cocoa APIs, and there are lots of them. For example, on OS X, grepping for !’s finds:<br></p><p>4132 functions/methods<br>2281 properties<br>409 initializers<br></p><p>On iOS, which has a smaller number of overall APIs, the numbers are still pretty big:<br>1071 functions/methods<br>320 properties<br>134 initializers<br></p><p>This may be a slight oversampling of the data—some of those might be explicitly annotated as _Null_unspecified in the (Objective-)C headers, some might be unavailable—but the scale of the impact here is very, very large.<br></p><p>Most of the implicitly unwrapped optionals we currently get from (Objective-)C APIs can, in fact, never be nil. Forcing programmers to deal with all of these values as full optionals leads to a ton of optional-related boilerplate that doesn’t actual help users write better code. Rather, it dilutes the effectiveness of optionals as a language feature: optionals should mean “nil matters here, think about it carefully!”. But if some large number of optionals people deal with on a day-to-day basis are instead “the compiler didn’t know, so you have to write !”, the useful meaning of the “true” optionals gets lost in the noise.<br></p><p>That said, I’d love for implicitly-unwrapped optionals to be used less often, and getting them further out of the type system would be beneficial for the Swift experience.<br></p><p>- Doug<br></p><p><br>Am 09.12.2015 um 07:11 schrieb Chris Lattner &lt;clattner at apple.com&gt;:<br></p><p><br>On Dec 8, 2015, at 4:09 AM, Fabian Ehrentraud via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>Swift code accessing Objective-C methods can easily crash - if the Objective-C code does not include nullability attributes, the code is brought as implicitly unwrapped into Swift, where unsafe accesses do not produce compiler warnings.<br></p><p>I created issue SR-104 for this, but as suggested by Jordan Rose it should be discussed on this mailing list first.<br></p><p>Short example:<br></p><p>// Objective-C<br>- (NSString *)giveMeAString { return nil; }<br></p><p>// Swift<br>func thisWillCrash() {<br>let string = someObjectiveCObject.giveMeAString()<br>let length = string.length // crash<br>}<br></p><p>The ClangImporter could handle this issue in several safer ways:<br></p><p>1. Only import declarations that are nullability annotated (as proposed by Greg Parker)<br>Positive side effect would be that it would motivate to write nullability annotations.<br></p><p>This seems unfortunate to me, because it would severely hamper interoperating with Objective-C and *C* APIs that have not been audited.  While Apple is keen to audit their APIs, I doubt that all the linux system headers will get updated in a timely manner and users don’t generally have a way to do anything about that.<br></p><p>2. Import un-annotated code as Optional<br>Values would need to be unwrapped every time, which does not hurt too much due to the easy use of the `?` syntactic sugar.<br></p><p>This is a very interesting idea, one I haven’t considered recently.  I agree with you that this is worth considering, and I would love to see IUO just get summarily deleted :-)<br></p><p>-Chris<br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/f4a1219b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>SR-104: Improve Crash-Safety when Importing Objective-C Code Without Nullability Attributes</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>December 11, 2015 at 09:00:00pm</p></header><div class="content"><p>&gt; On Dec 11, 2015, at 12:08 AM, Fabian Ehrentraud &lt;Fabian.Ehrentraud at willhaben.at&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On 10.12.2015, at 23:28, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 10, 2015, at 1:22 PM, Fabian Ehrentraud &lt;Fabian.Ehrentraud at willhaben.at &lt;mailto:Fabian.Ehrentraud at willhaben.at&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; Most of the implicitly unwrapped optionals we currently get from (Objective-)C APIs can, in fact, never be nil. Forcing programmers to deal with all of these values as full optionals leads to a ton of optional-related boilerplate that doesn’t actual help users write better code. Rather, it dilutes the effectiveness of optionals as a language feature: optionals should mean “nil matters here, think about it carefully!”. But if some large number of optionals people deal with on a day-to-day basis are instead “the compiler didn’t know, so you have to write !”, the useful meaning of the “true” optionals gets lost in the noise.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think exactly the opposite. If an API has not yet been audited, the client needs to consult the documentation if a return value can ever be nil. If not, she might explicitly and knowingly unwrap the value safely or non-safely. I deem this a good thing, as it prevents unknowingly unsafe use. I do not think that it would get in the way, as the syntactic sugar for Optionals is quite minimal. Also when the API gets audited for nullability later on, the compiler will hint which optional unwrappings have been rendered unnecessary.<br>&gt;&gt; <br>&gt;&gt; You’re discounting my main argument, which is that the safety provided by optionals is contingent on the nil case being interesting most of the time. That’s generally true in “pure” Swift code—Swift programmers use optionals when nil matters—and it’s generally true in imported (Objective-)C code that has been audited, but your change would create a lot of optionals where “nil” isn’t actually interesting in practice.<br>&gt; <br>&gt; Have I understood it right that your argument is that defaulting to Optionals would would make them loose their meaning and result in programmers just use ! too often, also in cases where the nil case should properly be handled? I see the point. And I&#39;m thankful for this constructive discussion.<br>&gt; <br>&gt; Nonetheless I think that Swift preventing unintentional mistakes would be something to strive for. Have you got alternative ideas on how to deal with the issue this proposal tries to address?<br></p><p><br>I honestly don’t have alternative ideas here—implicitly unwrapped optionals is the best solution that we could find to balance the goals of making it easy to write correct code vs. not pushing too much boilerplate on users, and while I want to continue to make them less common in Swift, I don’t think changing the Clang importer is the right answer.<br></p><p>	- Doug<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/6c21b914/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b2fc174169a3054f2e9bcb366884b02b?s=50"></div><header><strong>SR-104: Improve Crash-Safety when Importing Objective-C Code Without Nullability Attributes</strong> from <string>Fabian Ehrentraud</string> &lt;Fabian.Ehrentraud at willhaben.at&gt;<p>December 12, 2015 at 09:00:00am</p></header><div class="content"><p>Am 12.12.2015 um 06:03 schrieb Douglas Gregor &lt;dgregor at apple.com&lt;mailto:dgregor at apple.com&gt;&gt;:<br></p><p><br>On Dec 11, 2015, at 12:08 AM, Fabian Ehrentraud &lt;Fabian.Ehrentraud at willhaben.at&lt;mailto:Fabian.Ehrentraud at willhaben.at&gt;&gt; wrote:<br></p><p><br>On 10.12.2015, at 23:28, Douglas Gregor &lt;dgregor at apple.com&lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br></p><p><br>On Dec 10, 2015, at 1:22 PM, Fabian Ehrentraud &lt;Fabian.Ehrentraud at willhaben.at&lt;mailto:Fabian.Ehrentraud at willhaben.at&gt;&gt; wrote:<br></p><p>Most of the implicitly unwrapped optionals we currently get from (Objective-)C APIs can, in fact, never be nil. Forcing programmers to deal with all of these values as full optionals leads to a ton of optional-related boilerplate that doesn’t actual help users write better code. Rather, it dilutes the effectiveness of optionals as a language feature: optionals should mean “nil matters here, think about it carefully!”. But if some large number of optionals people deal with on a day-to-day basis are instead “the compiler didn’t know, so you have to write !”, the useful meaning of the “true” optionals gets lost in the noise.<br></p><p>I think exactly the opposite. If an API has not yet been audited, the client needs to consult the documentation if a return value can ever be nil. If not, she might explicitly and knowingly unwrap the value safely or non-safely. I deem this a good thing, as it prevents unknowingly unsafe use. I do not think that it would get in the way, as the syntactic sugar for Optionals is quite minimal. Also when the API gets audited for nullability later on, the compiler will hint which optional unwrappings have been rendered unnecessary.<br></p><p>You’re discounting my main argument, which is that the safety provided by optionals is contingent on the nil case being interesting most of the time. That’s generally true in “pure” Swift code—Swift programmers use optionals when nil matters—and it’s generally true in imported (Objective-)C code that has been audited, but your change would create a lot of optionals where “nil” isn’t actually interesting in practice.<br></p><p>Have I understood it right that your argument is that defaulting to Optionals would would make them loose their meaning and result in programmers just use ! too often, also in cases where the nil case should properly be handled? I see the point. And I&#39;m thankful for this constructive discussion.<br></p><p>Nonetheless I think that Swift preventing unintentional mistakes would be something to strive for. Have you got alternative ideas on how to deal with the issue this proposal tries to address?<br></p><p>I honestly don’t have alternative ideas here—implicitly unwrapped optionals is the best solution that we could find to balance the goals of making it easy to write correct code vs. not pushing too much boilerplate on users, and while I want to continue to make them less common in Swift, I don’t think changing the Clang importer is the right answer.<br></p><p>- Doug<br></p><p><br>Would it be technically possible to have a different behavior for Cocoa APIs vs. own Application Code and integrated 3rd-party Frameworks?<br></p><p>The Cocoa API is pretty well documented, and I think IUOs don&#39;t hurt too much there, as opposed to the other two. Also if nullabillity annotations are missing from the latter two, they can be added. So the necessary boilerplate !/? would remind the users in a safe manner.<br></p><p>I&#39;m unhappy with defaulting to IUOs as it has a bad impact on mixed projects. In pure ObjC it was expected that nil could be returned but mostly ignored as it could not hurt if methods were called on it, so not too many crashes arose. In a pure Swift project one can stay away from IUOs and avoid that nil issue alltogether if one stays away from forced unwrapping. But as soon as the two are used together, for example when migrating to Swift, crashes can be hidden in every line. And there are no compiler warnings, no analyzer inspections or anything that can help to find these lines.<br></p><p>That said, here is an alternative idea. A new compiler warning &quot;Access to Objective-C method/function/property/initializer that misses nullability annotations&quot;. I guess this warning should not be shown for Cocoa APIs.<br>Would this result in even more work than the original proposal? Would it harm productivity if &quot;Treat warnings as errors&quot; is activated?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151212/260d1dc5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>SR-104: Improve Crash-Safety when Importing Objective-C Code Without Nullability Attributes</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>December 12, 2015 at 12:00:00pm</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On Dec 12, 2015, at 1:13 AM, Fabian Ehrentraud &lt;Fabian.Ehrentraud at willhaben.at&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Am 12.12.2015 um 06:03 schrieb Douglas Gregor &lt;dgregor at apple.com&gt;:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 11, 2015, at 12:08 AM, Fabian Ehrentraud &lt;Fabian.Ehrentraud at willhaben.at&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 10.12.2015, at 23:28, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 10, 2015, at 1:22 PM, Fabian Ehrentraud &lt;Fabian.Ehrentraud at willhaben.at&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; Most of the implicitly unwrapped optionals we currently get from (Objective-)C APIs can, in fact, never be nil. Forcing programmers to deal with all of these values as full optionals leads to a ton of optional-related boilerplate that doesn’t actual help users write better code. Rather, it dilutes the effectiveness of optionals as a language feature: optionals should mean “nil matters here, think about it carefully!”. But if some large number of optionals people deal with on a day-to-day basis are instead “the compiler didn’t know, so you have to write !”, the useful meaning of the “true” optionals gets lost in the noise.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think exactly the opposite. If an API has not yet been audited, the client needs to consult the documentation if a return value can ever be nil. If not, she might explicitly and knowingly unwrap the value safely or non-safely. I deem this a good thing, as it prevents unknowingly unsafe use. I do not think that it would get in the way, as the syntactic sugar for Optionals is quite minimal. Also when the API gets audited for nullability later on, the compiler will hint which optional unwrappings have been rendered unnecessary.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You’re discounting my main argument, which is that the safety provided by optionals is contingent on the nil case being interesting most of the time. That’s generally true in “pure” Swift code—Swift programmers use optionals when nil matters—and it’s generally true in imported (Objective-)C code that has been audited, but your change would create a lot of optionals where “nil” isn’t actually interesting in practice.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Have I understood it right that your argument is that defaulting to Optionals would would make them loose their meaning and result in programmers just use ! too often, also in cases where the nil case should properly be handled? I see the point. And I&#39;m thankful for this constructive discussion.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Nonetheless I think that Swift preventing unintentional mistakes would be something to strive for. Have you got alternative ideas on how to deal with the issue this proposal tries to address?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I honestly don’t have alternative ideas here—implicitly unwrapped optionals is the best solution that we could find to balance the goals of making it easy to write correct code vs. not pushing too much boilerplate on users, and while I want to continue to make them less common in Swift, I don’t think changing the Clang importer is the right answer.<br>&gt;&gt; <br>&gt;&gt; - Doug<br>&gt; <br>&gt; Would it be technically possible to have a different behavior for Cocoa APIs vs. own Application Code and integrated 3rd-party Frameworks?<br></p><p>Somewhat. One can distinguish between &quot;system&quot; and &quot;user&quot; frameworks. <br></p><p>&gt; The Cocoa API is pretty well documented, and I think IUOs don&#39;t hurt too much there, as opposed to the other two. Also if nullabillity annotations are missing from the latter two, they can be added. So the necessary boilerplate !/? would remind the users in a safe manner. <br>&gt; <br>&gt; I&#39;m unhappy with defaulting to IUOs as it has a bad impact on mixed projects. In pure ObjC it was expected that nil could be returned but mostly ignored as it could not hurt if methods were called on it, so not too many crashes arose. In a pure Swift project one can stay away from IUOs and avoid that nil issue alltogether if one stays away from forced unwrapping. But as soon as the two are used together, for example when migrating to Swift, crashes can be hidden in every line. And there are no compiler warnings, no analyzer inspections or anything that can help to find these lines. <br>&gt; <br>&gt; That said, here is an alternative idea. A new compiler warning &quot;Access to Objective-C method/function/property/initializer that misses nullability annotations&quot;. I guess this warning should not be shown for Cocoa APIs. <br>&gt; Would this result in even more work than the original proposal?<br></p><p>No, it&#39;s easier because warnings (especially opt-in ones) have far less impact on existing code. I think what you&#39;re asking for is a warning when implicitly unwrapping an IUO when we inferred the IUO from a lack of nullability information in the Objective-C API. For me, that&#39;s no longer even a language proposal: it&#39;s a smallish proposal for an opt-in warning. <br></p><p>&gt; Would it harm productivity if &quot;Treat warnings as errors&quot; is activated?<br></p><p>If it&#39;s opt-in or one can selectively downgrade it to a warning, it shouldn&#39;t harm productivity.<br></p><p>  - Doug<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151212/25310042/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b2fc174169a3054f2e9bcb366884b02b?s=50"></div><header><strong>SR-104: Improve Crash-Safety when Importing Objective-C Code Without Nullability Attributes</strong> from <string>Fabian Ehrentraud</string> &lt;Fabian.Ehrentraud at willhaben.at&gt;<p>December 12, 2015 at 10:00:00pm</p></header><div class="content"><p>Am 12.12.2015 um 21:34 schrieb Douglas Gregor &lt;dgregor at apple.com&lt;mailto:dgregor at apple.com&gt;&gt;:<br></p><p><br></p><p>Sent from my iPhone<br></p><p>On Dec 12, 2015, at 1:13 AM, Fabian Ehrentraud &lt;Fabian.Ehrentraud at willhaben.at&lt;mailto:Fabian.Ehrentraud at willhaben.at&gt;&gt; wrote:<br></p><p><br>Am 12.12.2015 um 06:03 schrieb Douglas Gregor &lt;dgregor at apple.com&lt;mailto:dgregor at apple.com&gt;&gt;:<br></p><p><br>On Dec 11, 2015, at 12:08 AM, Fabian Ehrentraud &lt;Fabian.Ehrentraud at willhaben.at&lt;mailto:Fabian.Ehrentraud at willhaben.at&gt;&gt; wrote:<br></p><p><br>On 10.12.2015, at 23:28, Douglas Gregor &lt;dgregor at apple.com&lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br></p><p><br>On Dec 10, 2015, at 1:22 PM, Fabian Ehrentraud &lt;Fabian.Ehrentraud at willhaben.at&lt;mailto:Fabian.Ehrentraud at willhaben.at&gt;&gt; wrote:<br></p><p>Most of the implicitly unwrapped optionals we currently get from (Objective-)C APIs can, in fact, never be nil. Forcing programmers to deal with all of these values as full optionals leads to a ton of optional-related boilerplate that doesn’t actual help users write better code. Rather, it dilutes the effectiveness of optionals as a language feature: optionals should mean “nil matters here, think about it carefully!”. But if some large number of optionals people deal with on a day-to-day basis are instead “the compiler didn’t know, so you have to write !”, the useful meaning of the “true” optionals gets lost in the noise.<br></p><p>I think exactly the opposite. If an API has not yet been audited, the client needs to consult the documentation if a return value can ever be nil. If not, she might explicitly and knowingly unwrap the value safely or non-safely. I deem this a good thing, as it prevents unknowingly unsafe use. I do not think that it would get in the way, as the syntactic sugar for Optionals is quite minimal. Also when the API gets audited for nullability later on, the compiler will hint which optional unwrappings have been rendered unnecessary.<br></p><p>You’re discounting my main argument, which is that the safety provided by optionals is contingent on the nil case being interesting most of the time. That’s generally true in “pure” Swift code—Swift programmers use optionals when nil matters—and it’s generally true in imported (Objective-)C code that has been audited, but your change would create a lot of optionals where “nil” isn’t actually interesting in practice.<br></p><p>Have I understood it right that your argument is that defaulting to Optionals would would make them loose their meaning and result in programmers just use ! too often, also in cases where the nil case should properly be handled? I see the point. And I&#39;m thankful for this constructive discussion.<br></p><p>Nonetheless I think that Swift preventing unintentional mistakes would be something to strive for. Have you got alternative ideas on how to deal with the issue this proposal tries to address?<br></p><p>I honestly don’t have alternative ideas here—implicitly unwrapped optionals is the best solution that we could find to balance the goals of making it easy to write correct code vs. not pushing too much boilerplate on users, and while I want to continue to make them less common in Swift, I don’t think changing the Clang importer is the right answer.<br></p><p>- Doug<br></p><p><br>Would it be technically possible to have a different behavior for Cocoa APIs vs. own Application Code and integrated 3rd-party Frameworks?<br></p><p>Somewhat. One can distinguish between &quot;system&quot; and &quot;user&quot; frameworks.<br></p><p>Great. I guess restricting the change just to &quot;user&quot; frameworks would be a very good balance between safety and boilerplate.<br></p><p><br>The Cocoa API is pretty well documented, and I think IUOs don&#39;t hurt too much there, as opposed to the other two. Also if nullabillity annotations are missing from the latter two, they can be added. So the necessary boilerplate !/? would remind the users in a safe manner.<br></p><p>I&#39;m unhappy with defaulting to IUOs as it has a bad impact on mixed projects. In pure ObjC it was expected that nil could be returned but mostly ignored as it could not hurt if methods were called on it, so not too many crashes arose. In a pure Swift project one can stay away from IUOs and avoid that nil issue alltogether if one stays away from forced unwrapping. But as soon as the two are used together, for example when migrating to Swift, crashes can be hidden in every line. And there are no compiler warnings, no analyzer inspections or anything that can help to find these lines.<br></p><p>That said, here is an alternative idea. A new compiler warning &quot;Access to Objective-C method/function/property/initializer that misses nullability annotations&quot;. I guess this warning should not be shown for Cocoa APIs.<br>Would this result in even more work than the original proposal?<br></p><p>No, it&#39;s easier because warnings (especially opt-in ones) have far less impact on existing code. I think what you&#39;re asking for is a warning when implicitly unwrapping an IUO when we inferred the IUO from a lack of nullability information in the Objective-C API.<br></p><p>Yes excactly. I guess explicitly force unwrapping should not produce a warning, as it is obvious then that something unsafe happens.<br>It would be debatable if 2 separate warnings should be created, one for &quot;system&quot; and one for &quot;user&quot; frameworks.<br></p><p>For me, that&#39;s no longer even a language proposal: it&#39;s a smallish proposal for an opt-in warning.<br></p><p>Would it harm productivity if &quot;Treat warnings as errors&quot; is activated?<br></p><p>If it&#39;s opt-in or one can selectively downgrade it to a warning, it shouldn&#39;t harm productivity.<br></p><p>  - Doug<br></p><p>Especially together with &quot;treat warnings as errors&quot; the second proposal should provide approximately the same level of safety, or am I missing something?<br></p><p>As either proposal would help with the underlying issue, how should we proceed? Should I write down both variants in a single proposal and let the community decide in the review?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151212/4b0da401/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b2fc174169a3054f2e9bcb366884b02b?s=50"></div><header><strong>SR-104: Improve Crash-Safety when Importing Objective-C Code Without Nullability Attributes</strong> from <string>Fabian Ehrentraud</string> &lt;Fabian.Ehrentraud at willhaben.at&gt;<p>December 15, 2015 at 06:00:00pm</p></header><div class="content"><p>I added the second solution idea to the proposal, and created the PR. Looking forward to reviews!<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b2fc174169a3054f2e9bcb366884b02b?s=50"></div><header><strong>SR-104: Improve Crash-Safety when Importing Objective-C Code Without Nullability Attributes</strong> from <string>Fabian Ehrentraud</string> &lt;Fabian.Ehrentraud at willhaben.at&gt;<p>January 29, 2016 at 07:00:00am</p></header><div class="content"><p>Too bad to hear the PR was rejected by the Core Team. I&#39;m sad about it, but the reasoning sounds valid.<br></p><p>Solution #2 is asking for a warning, which is outside the scope of the Swift evolution process.<br></p><p>I was a bit baffled by this information at first, but it&#39;s true that the goals of the Swift evolution process state that. I&#39;m not sure though, how to propose additional warnings, when I only have the idea and no code to provide as a PR? The Contributing guidelines do not clarify that case. Should I just create a ticket at bugs.swift.org&lt;http://bugs.swift.org&gt;?<br></p><p><br></p><p>The now-closed proposal PR is to be found here: https://github.com/apple/swift-evolution/pull/61<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/3259da66/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>SR-104: Improve Crash-Safety when Importing Objective-C Code Without Nullability Attributes</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January 29, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 28, 2016, at 11:35 PM, Fabian Ehrentraud &lt;Fabian.Ehrentraud at willhaben.at&gt; wrote:<br>&gt; <br>&gt; Too bad to hear the PR was rejected by the Core Team. I&#39;m sad about it, but the reasoning sounds valid.<br>&gt; <br>&gt;&gt; Solution #2 is asking for a warning, which is outside the scope of the Swift evolution process.<br>&gt; <br>&gt; I was a bit baffled by this information at first, but it&#39;s true that the goals of the Swift evolution process state that. I&#39;m not sure though, how to propose additional warnings, when I only have the idea and no code to provide as a PR? The Contributing guidelines do not clarify that case. Should I just create a ticket at bugs.swift.org &lt;http://bugs.swift.org/&gt;?<br></p><p>A warning is a feature of the compiler, so filing a feature request at bugs.swift.org is appropriate. <br></p><p>	- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/8dc4b2f5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b2fc174169a3054f2e9bcb366884b02b?s=50"></div><header><strong>SR-104: Improve Crash-Safety when Importing Objective-C Code Without Nullability Attributes</strong> from <string>Fabian Ehrentraud</string> &lt;Fabian.Ehrentraud at willhaben.at&gt;<p>January 30, 2016 at 10:00:00am</p></header><div class="content"><p>Allright, I updated the original ticket with the solution incorporating new warnings. I hope this improvement has a chance of getting into Swift 3.<br></p><p>https://bugs.swift.org/browse/SR-104<br></p><p><br></p><p>On 29.01.2016, at 19:23, Douglas Gregor &lt;dgregor at apple.com&lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br></p><p><br>On Jan 28, 2016, at 11:35 PM, Fabian Ehrentraud &lt;Fabian.Ehrentraud at willhaben.at&lt;mailto:Fabian.Ehrentraud at willhaben.at&gt;&gt; wrote:<br></p><p>Too bad to hear the PR was rejected by the Core Team. I&#39;m sad about it, but the reasoning sounds valid.<br></p><p>Solution #2 is asking for a warning, which is outside the scope of the Swift evolution process.<br></p><p>I was a bit baffled by this information at first, but it&#39;s true that the goals of the Swift evolution process state that. I&#39;m not sure though, how to propose additional warnings, when I only have the idea and no code to provide as a PR? The Contributing guidelines do not clarify that case. Should I just create a ticket at bugs.swift.org&lt;http://bugs.swift.org/&gt;?<br></p><p>A warning is a feature of the compiler, so filing a feature request at bugs.swift.org&lt;http://bugs.swift.org/&gt; is appropriate.<br></p><p>- Doug<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160130/93ef1dd4/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>SR-104: Improve Crash-Safety when Importing Objective-C Code Without Nullability Attributes</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>December 11, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 10, 2015, at 14:28 , Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; I noticed there are many constants that get translated to implicitly unwrapped optionals (e.g. in iOS CoreFoundation.swift). Would they be affected by the change in this proposal? Or are they &quot;explicitly set to implicitly unwrapped&quot; by the importer?<br>&gt; <br>&gt; You can grep for “ull_unspecified” in the SDK to find the cases where things are explicitly set to implicitly unwrapped optionals; I doubt there are many.<br></p><p>Please don&#39;t forget null_resettable properties, of which there are probably several. Until we have a good answer for Swift here, that&#39;s one more reason to keep IUOs.<br></p><p>(The other major feature that uses IUOs is two-phase initialization, like IBOutlets. I don&#39;t think we have an answer for that yet either.)<br></p><p>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/2a6b9b36/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>SR-104: Improve Crash-Safety when Importing Objective-C Code Without Nullability Attributes</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>December 12, 2015 at 07:00:00am</p></header><div class="content"><p>&gt; (The other major feature that uses IUOs is two-phase initialization, like IBOutlets. I don&#39;t think we have an answer for that yet either.)<br></p><p>Other examples include stuff created in viewDidLoad of a view controller, and fields initialized in the second phase.<br></p><p>I love IUOs, I think they should stay in the interest of ! non-proliferation.<br></p><p>A.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b2fc174169a3054f2e9bcb366884b02b?s=50"></div><header><strong>SR-104: Improve Crash-Safety when Importing Objective-C Code Without Nullability Attributes</strong> from <string>Fabian Ehrentraud</string> &lt;Fabian.Ehrentraud at willhaben.at&gt;<p>December 12, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; <br>&gt; On 12.12.2015, at 02:15, Andrey Tarantsov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; (The other major feature that uses IUOs is two-phase initialization, like IBOutlets. I don&#39;t think we have an answer for that yet either.)<br>&gt; <br>&gt; Other examples include stuff created in viewDidLoad of a view controller, and fields initialized in the second phase.<br>&gt; <br>&gt; I love IUOs, I think they should stay in the interest of ! non-proliferation.<br></p><p>Willingly placed IUOs would stay untouched by this proposal. Only the ones generated by missing nullability annotations in Objective-C code would be translated to Optionals.<br></p><p>&gt; <br>&gt; A.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
