<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0b7bdc0c491a18e4aad6ae6004c3601?s=50"></div><header><strong>Closure Syntax</strong> from <string>Ethan Diamond</string> &lt;edgewood7558 at gmail.com&gt;<p>December 27, 2015 at 02:00:00pm</p></header><div class="content"><p>I realize this is on the commonly rejected list, but I really find closure<br>syntax to be one of the more unintuitive and unreadable parts of Swift so<br>I&#39;d like to try to influence it. &quot;Clarity at the point of use&quot; is one of<br>the main stated goals of Swift, and the fact that<br>http://goshdarnclosuresyntax.com/ exists shows me that it&#39;s not just me<br>that thinks the syntax could be improved. I believe that we can get very<br>close to the same results in line length and expressiveness while making<br>the language much more readable and clear.<br></p><p>Let&#39;s start with a few use cases to illustrate what I mean when I say that<br>reading closure syntax is difficult. Most programmers scan left to right,<br>so when I see this property declaration:<br></p><p>var thing: Int<br></p><p>My brain reads that as a property of a class that&#39;s an integer. Unless of<br>course there&#39;s this:<br></p><p>var thing: Int -&gt; Int<br></p><p>Boom, context switch. If you&#39;ve read &quot;Int&quot; than any following syntax should<br>be a modifier on Int. For example, Int? works great, because in my head<br>it&#39;s still an Integer, just an optional form of that Integer. While it&#39;s<br>not a huge change in that example, lets take a more complicated one:<br></p><p>var thing: (String -&gt; (), Int, (Int, Int) -&gt; Bool)) -&gt; Bool<br></p><p>Reading that left to right requires all sorts of context switching in my<br>brain. I can&#39;t even tell at first glance how many params are in that<br>closure. Reading left to right, you read &quot;First parameter, string, no wait,<br>closure that takes string, and returns void. Second param, Int. Third<br>param, tuple with two ints, no wait, closure that takes two ints and<br>returns bool.&quot; I just doesn&#39;t have much clarity.<br></p><p>I believe it&#39;s already been proposed, but I don&#39;t feel there&#39;s a strong<br>enough difference between a closure and a function to justify a different<br>syntax. Let&#39;s replace my examples above with anonymous function syntax.<br></p><p>var thing: func (Int) -&gt; Int<br></p><p>Reading left to right, it reads the way that I think about it &quot;A function<br>that takes an integer and returns an integer.&quot;<br></p><p>var thing: func(func (String), Int, func (Int, Int) -&gt; Bool) -&gt; Bool<br></p><p>Again, reading left to right this is a win. &quot;Thing is an anonymous<br>function. First param, a function that takes a string. Second param, Int.<br>Third param, a function that takes two ints and returns bool.&quot; It reads<br>like people think.<br></p><p>Another strength is it lets us both use the same syntax for closures as we<br>would expect, while letting us use just about all of the same shorthands we<br>gain with closures. We could call normally like this, with the return type<br>implied when async is called:<br></p><p>func async(callback: func (Bool) -&gt; Bool))<br></p><p>async(func (successful: Bool) {<br>   return !successful<br>});<br></p><p>We could still permit this:<br></p><p>func async(callback: func ())<br></p><p>async {<br>  //Do callback stuff here<br>}<br></p><p>We could still permit this:<br></p><p>func sort(sortfunc: func(Int, Int) -&gt; Bool)<br></p><p>sort {<br>  $0 &gt; $1<br>}<br></p><p>We could add this:<br></p><p>let greaterThan: func (number: Int) -&gt; Bool = {<br>   number &gt; 5<br>}<br></p><p>There would also be a few small wins, such as no longer needing &quot;()&quot; to<br>represent a void return, since any function without a return type would<br>imply a void return.<br></p><p>I understand that a big part of the decision for current closure syntax is<br>to help the compiler, but I believe by doing so you&#39;re going against the<br>main principles you laid out in your api design guidelines (<br>https://swift.org/documentation/api-design-guidelines.html). Current<br>closure syntax is not clear and breaks precedent of all other function like<br>declarations having the parameters listed outside of the curly braces.<br></p><p>Thanks for listening, and great job on Swift so far.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151227/5f323bb6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Closure Syntax</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 28, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt; On Dec 27, 2015, at 2:30 PM, Ethan Diamond via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I realize this is on the commonly rejected list, but I really find closure syntax to be one of the more unintuitive and unreadable parts of Swift so I&#39;d like to try to influence it. &quot;Clarity at the point of use&quot; is one of the main stated goals of Swift, and the fact that http://goshdarnclosuresyntax.com/ &lt;http://goshdarnclosuresyntax.com/&gt; exists shows me that it&#39;s not just me that thinks the syntax could be improved. I believe that we can get very close to the same results in line length and expressiveness while making the language much more readable and clear.<br></p><p>FWIW, I think that web site exists as a continuation of the “blocks” web site.<br></p><p>From your description, it sounds like you might want to try out nested functions.  They have a more explicit syntax, and still provide the same “closure” power as closure expressions.<br></p><p>-Chris<br></p><p>&gt; <br>&gt; Let&#39;s start with a few use cases to illustrate what I mean when I say that reading closure syntax is difficult. Most programmers scan left to right, so when I see this property declaration:<br>&gt; <br>&gt; var thing: Int<br>&gt; <br>&gt; My brain reads that as a property of a class that&#39;s an integer. Unless of course there&#39;s this:<br>&gt; <br>&gt; var thing: Int -&gt; Int<br>&gt; <br>&gt; Boom, context switch. If you&#39;ve read &quot;Int&quot; than any following syntax should be a modifier on Int. For example, Int? works great, because in my head it&#39;s still an Integer, just an optional form of that Integer. While it&#39;s not a huge change in that example, lets take a more complicated one:<br>&gt; <br>&gt; var thing: (String -&gt; (), Int, (Int, Int) -&gt; Bool)) -&gt; Bool<br>&gt; <br>&gt; Reading that left to right requires all sorts of context switching in my brain. I can&#39;t even tell at first glance how many params are in that closure. Reading left to right, you read &quot;First parameter, string, no wait, closure that takes string, and returns void. Second param, Int. Third param, tuple with two ints, no wait, closure that takes two ints and returns bool.&quot; I just doesn&#39;t have much clarity.<br>&gt; <br>&gt; I believe it&#39;s already been proposed, but I don&#39;t feel there&#39;s a strong enough difference between a closure and a function to justify a different syntax. Let&#39;s replace my examples above with anonymous function syntax.<br>&gt; <br>&gt; var thing: func (Int) -&gt; Int<br>&gt; <br>&gt; Reading left to right, it reads the way that I think about it &quot;A function that takes an integer and returns an integer.&quot;<br>&gt; <br>&gt; var thing: func(func (String), Int, func (Int, Int) -&gt; Bool) -&gt; Bool<br>&gt; <br>&gt; Again, reading left to right this is a win. &quot;Thing is an anonymous function. First param, a function that takes a string. Second param, Int. Third param, a function that takes two ints and returns bool.&quot; It reads like people think.<br>&gt; <br>&gt; Another strength is it lets us both use the same syntax for closures as we would expect, while letting us use just about all of the same shorthands we gain with closures. We could call normally like this, with the return type implied when async is called:<br>&gt; <br>&gt; func async(callback: func (Bool) -&gt; Bool))<br>&gt; <br>&gt; async(func (successful: Bool) {<br>&gt;    return !successful<br>&gt; });<br>&gt; <br>&gt; We could still permit this:<br>&gt; <br>&gt; func async(callback: func ())<br>&gt; <br>&gt; async {<br>&gt;   //Do callback stuff here<br>&gt; }<br>&gt; <br>&gt; We could still permit this:<br>&gt; <br>&gt; func sort(sortfunc: func(Int, Int) -&gt; Bool)<br>&gt; <br>&gt; sort {<br>&gt;   $0 &gt; $1<br>&gt; }<br>&gt; <br>&gt; We could add this:<br>&gt; <br>&gt; let greaterThan: func (number: Int) -&gt; Bool = {<br>&gt;    number &gt; 5<br>&gt; }<br>&gt; <br>&gt; There would also be a few small wins, such as no longer needing &quot;()&quot; to represent a void return, since any function without a return type would imply a void return.<br>&gt; <br>&gt; I understand that a big part of the decision for current closure syntax is to help the compiler, but I believe by doing so you&#39;re going against the main principles you laid out in your api design guidelines (https://swift.org/documentation/api-design-guidelines.html &lt;https://swift.org/documentation/api-design-guidelines.html&gt;). Current closure syntax is not clear and breaks precedent of all other function like declarations having the parameters listed outside of the curly braces.<br>&gt; <br>&gt; Thanks for listening, and great job on Swift so far.<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151228/36331bf3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0b7bdc0c491a18e4aad6ae6004c3601?s=50"></div><header><strong>Closure Syntax</strong> from <string>Ethan Diamond</string> &lt;edgewood7558 at gmail.com&gt;<p>December 29, 2015 at 04:00:00pm</p></header><div class="content"><p>I guess the core of the question for me is why have the concept of a<br>closure at all when they&#39;re harder to read while acting the same way that<br>functions do? I&#39;m not a huge fan of Javascript, but the consistancy between<br>function declarations and anonymous functions is something I feel they got<br>right. JS syntax for everything that receives parameters and possibly<br>returns a value is entirely consistent.<br></p><p>Let&#39;s take the anonymous function style:<br></p><p>func asyncWithCallback(_ : func (String) -&gt; Bool)<br></p><p>asyncWithCallback(func (param) {<br>    return param == &quot;string&quot;<br>})<br></p><p>Particularly for someone new to the language is both clearer and shorter<br>than this, which makes the caller rewrite the return type in the closure:<br></p><p>func asyncWithCallback(_ : String -&gt; Bool)<br></p><p>asyncWithCallback {<br>  (param: String) -&gt; Bool in<br>  return param == &quot;string&quot;<br>}<br></p><p>It still fits your unwritten rule to be able to compose language features<br>in Swift, assuming you leave the same syntactic sugar:<br></p><p>func if (_ control: Bool, _ path: func ()) {<br></p><p>  if (control) {<br></p><p>     path()<br></p><p>  }<br></p><p>}<br></p><p>if (a == b) {<br></p><p>  //LETS DO SOME STUFF<br></p><p>}<br></p><p>I know it&#39;s a big change to the language, but I feel like it&#39;s better<br>in just about every case I can think of without losing the Swiftiness<br>we all enjoy. It certainly makes this easier to read. Even in one of<br>the examples in the Swift guide<br>(https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Closures.html)<br>you&#39;re essentially using the syntax i&#39;m proposing on the incrementer:<br></p><p>func makeIncrementer(forIncrement amount: Int) -&gt; () -&gt; Int {<br></p><p>    var runningTotal = 0<br></p><p>    func incrementer() -&gt; Int {<br></p><p>        runningTotal += amount<br></p><p>        return runningTotal<br></p><p>    }<br></p><p>    return incrementer<br></p><p>}<br></p><p>I can&#39;t really fix the unclear chained return in the declaration, but<br>doesn&#39;t the return of the anonymous function look similar to the<br>above, just as you would expect?<br></p><p>func makeIncrementer(forIncrement amount: Int) -&gt; func() -&gt; Int {<br></p><p>   var runningTotal = 0<br></p><p>   return func () -&gt; Int {<br></p><p>    runningTotal += amount<br></p><p>    return runningTotal<br></p><p>  }<br></p><p>}<br></p><p>But if I wanted to use closure syntax, It&#39;d be different from the<br>example above in the Swift handbook for no real good reason:<br></p><p>func makeIncrementer(forIncrement amount: Int) -&gt; () -&gt; Int {<br></p><p>    var runningTotal = 0<br></p><p>    return {<br></p><p>        () -&gt; Int in<br></p><p>        runningTotal += amount<br></p><p>        return runningTotal<br></p><p>    }<br></p><p>}<br></p><p>In the commonly rejected list, Jordan wrote:<br></p><p>&quot;We thought a lot about this, and settled on the current syntax<br>(inside the braces) for several reasons, the main one being that it&#39;s<br>much easier to parse. Without this, the compiler would have to stop<br>whatever it&#39;s currently doing when it sees &#39;-&gt;&#39;.&quot;<br></p><p>I don&#39;t believe that&#39;s a problem when using the proposed func syntax,<br>since by definition &quot;-&gt;&quot; will only follow a func (param) statement in<br>all cases. The compiler can make more assumptions about what it&#39;s<br>parsing. I think it might limit what you have to work with to the<br>compilers benefit.<br></p><p>Thanks,<br></p><p>- Ethan<br></p><p><br>On Mon, Dec 28, 2015 at 5:44 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Dec 27, 2015, at 2:30 PM, Ethan Diamond via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I realize this is on the commonly rejected list, but I really find closure<br>&gt; syntax to be one of the more unintuitive and unreadable parts of Swift so<br>&gt; I&#39;d like to try to influence it. &quot;Clarity at the point of use&quot; is one of<br>&gt; the main stated goals of Swift, and the fact that<br>&gt; http://goshdarnclosuresyntax.com/ exists shows me that it&#39;s not just me<br>&gt; that thinks the syntax could be improved. I believe that we can get very<br>&gt; close to the same results in line length and expressiveness while making<br>&gt; the language much more readable and clear.<br>&gt;<br>&gt;<br>&gt; FWIW, I think that web site exists as a continuation of the “blocks” web<br>&gt; site.<br>&gt;<br>&gt; From your description, it sounds like you might want to try out nested<br>&gt; functions.  They have a more explicit syntax, and still provide the same<br>&gt; “closure” power as closure expressions.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br>&gt; Let&#39;s start with a few use cases to illustrate what I mean when I say that<br>&gt; reading closure syntax is difficult. Most programmers scan left to right,<br>&gt; so when I see this property declaration:<br>&gt;<br>&gt; var thing: Int<br>&gt;<br>&gt; My brain reads that as a property of a class that&#39;s an integer. Unless of<br>&gt; course there&#39;s this:<br>&gt;<br>&gt; var thing: Int -&gt; Int<br>&gt;<br>&gt; Boom, context switch. If you&#39;ve read &quot;Int&quot; than any following syntax<br>&gt; should be a modifier on Int. For example, Int? works great, because in my<br>&gt; head it&#39;s still an Integer, just an optional form of that Integer. While<br>&gt; it&#39;s not a huge change in that example, lets take a more complicated one:<br>&gt;<br>&gt; var thing: (String -&gt; (), Int, (Int, Int) -&gt; Bool)) -&gt; Bool<br>&gt;<br>&gt; Reading that left to right requires all sorts of context switching in my<br>&gt; brain. I can&#39;t even tell at first glance how many params are in that<br>&gt; closure. Reading left to right, you read &quot;First parameter, string, no wait,<br>&gt; closure that takes string, and returns void. Second param, Int. Third<br>&gt; param, tuple with two ints, no wait, closure that takes two ints and<br>&gt; returns bool.&quot; I just doesn&#39;t have much clarity.<br>&gt;<br>&gt; I believe it&#39;s already been proposed, but I don&#39;t feel there&#39;s a strong<br>&gt; enough difference between a closure and a function to justify a different<br>&gt; syntax. Let&#39;s replace my examples above with anonymous function syntax.<br>&gt;<br>&gt; var thing: func (Int) -&gt; Int<br>&gt;<br>&gt; Reading left to right, it reads the way that I think about it &quot;A function<br>&gt; that takes an integer and returns an integer.&quot;<br>&gt;<br>&gt; var thing: func(func (String), Int, func (Int, Int) -&gt; Bool) -&gt; Bool<br>&gt;<br>&gt; Again, reading left to right this is a win. &quot;Thing is an anonymous<br>&gt; function. First param, a function that takes a string. Second param, Int.<br>&gt; Third param, a function that takes two ints and returns bool.&quot; It reads<br>&gt; like people think.<br>&gt;<br>&gt; Another strength is it lets us both use the same syntax for closures as we<br>&gt; would expect, while letting us use just about all of the same shorthands we<br>&gt; gain with closures. We could call normally like this, with the return type<br>&gt; implied when async is called:<br>&gt;<br>&gt; func async(callback: func (Bool) -&gt; Bool))<br>&gt;<br>&gt; async(func (successful: Bool) {<br>&gt;    return !successful<br>&gt; });<br>&gt;<br>&gt; We could still permit this:<br>&gt;<br>&gt; func async(callback: func ())<br>&gt;<br>&gt; async {<br>&gt;   //Do callback stuff here<br>&gt; }<br>&gt;<br>&gt; We could still permit this:<br>&gt;<br>&gt; func sort(sortfunc: func(Int, Int) -&gt; Bool)<br>&gt;<br>&gt; sort {<br>&gt;   $0 &gt; $1<br>&gt; }<br>&gt;<br>&gt; We could add this:<br>&gt;<br>&gt; let greaterThan: func (number: Int) -&gt; Bool = {<br>&gt;    number &gt; 5<br>&gt; }<br>&gt;<br>&gt; There would also be a few small wins, such as no longer needing &quot;()&quot; to<br>&gt; represent a void return, since any function without a return type would<br>&gt; imply a void return.<br>&gt;<br>&gt; I understand that a big part of the decision for current closure syntax is<br>&gt; to help the compiler, but I believe by doing so you&#39;re going against the<br>&gt; main principles you laid out in your api design guidelines (<br>&gt; https://swift.org/documentation/api-design-guidelines.html). Current<br>&gt; closure syntax is not clear and breaks precedent of all other function like<br>&gt; declarations having the parameters listed outside of the curly braces.<br>&gt;<br>&gt; Thanks for listening, and great job on Swift so far.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151229/45e234c8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Closure Syntax</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>December 29, 2015 at 11:00:00pm</p></header><div class="content"><p>&gt; On Dec 29, 2015, at 5:18 PM, Ethan Diamond via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I guess the core of the question for me is why have the concept of a closure at all when they&#39;re harder to read while acting the same way that functions do? I&#39;m not a huge fan of Javascript, but the consistancy between function declarations and anonymous functions is something I feel they got right. JS syntax for everything that receives parameters and possibly returns a value is entirely consistent. <br></p><p>Some of this is because Javascript doesn&#39;t have to declare types or return values and it is even loose with arguments and is somewhat confusing (and dynamic) with “this”. For Swift, which requires knowledge about the arguments and return values needed by callers, it makes sense to have two different syntaxes depending on whether or not this knowledge is being defined by contract or being inferred by context.<br></p><p>And with ES2015 there are now multiple styles, partially to resolve the issues with capturing “this” and partially because writing “function” everywhere is visually distracting.<br></p><p>&gt; Let&#39;s take the anonymous function style:<br>&gt; <br>&gt; func asyncWithCallback(_ : func (String) -&gt; Bool)<br>&gt; <br>&gt; asyncWithCallback(func (param) {<br>&gt;     return param == &quot;string&quot;<br>&gt; })<br>&gt; <br>&gt; Particularly for someone new to the language is both clearer and shorter than this, which makes the caller rewrite the return type in the closure:<br>&gt; <br>&gt; func asyncWithCallback(_ : String -&gt; Bool)<br>&gt; <br>&gt; asyncWithCallback {<br>&gt;   (param: String) -&gt; Bool in<br>&gt;   return param == &quot;string&quot;<br>&gt; }<br></p><p>Or I could use:<br>asyncWithCallback {<br>    param in<br>    return param == &quot;string&quot;<br>}<br></p><p>or even:<br>asyncWithCallback { $0 == &quot;string” }<br></p><p>A function defines a name and a contract for use and definition, while closures are only semantically valid once defined by a context. I can understand the stylistic desire to have closures declare arguments outside a block and to be closer to function syntax. However, using “func&quot; anonymously to indicate a different syntax with a different set of options, potentially inferred input types, and an inferred existence of output as well as output type might be equally confusing. Perhaps another keyword could be used for this purpose. <br></p><p>However this new keyword would need to work with, and avoid adding visual distraction to, the “$0 == “string” case above.<br></p><p>&gt; <br>&gt; It still fits your unwritten rule to be able to compose language features in Swift, assuming you leave the same syntactic sugar: <br>&gt; func if (_ control: Bool, _ path: func ()) {<br>&gt;   if (control) {<br>&gt;      path()<br>&gt;   }<br>&gt; }<br>&gt; if (a == b) {<br>&gt;   //LETS DO SOME STUFF<br>&gt; }<br>You probably realize this but closures and blocks have different control flow, so for instance the above would absorb/malfunction on returns as well as attempts to break/continue outer loops.<br></p><p>-DW<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151229/1e7d702f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0b7bdc0c491a18e4aad6ae6004c3601?s=50"></div><header><strong>Closure Syntax</strong> from <string>Ethan Diamond</string> &lt;edgewood7558 at gmail.com&gt;<p>December 30, 2015 at 11:00:00am</p></header><div class="content"><p>Reasonable. That all makes sense.<br></p><p>For clarity&#39;s sake, there&#39;s really two syntactic issues that I think would<br>be good to address. The first, which I think is the far bigger problem,<br>which is that right now a list of params with closures is very hard to<br>read. For example, this requires mental effort to decode whether this is<br>returning an Int, or a closure returning an Int:<br></p><p>func makeIncrementer(forIncrement amount: Int) -&gt; () -&gt; Int {<br></p><p>}<br></p><p>And the second being that stylistically, having the params on the<br>inside of the closure is breaking precedent of params outside of the<br>block of code without gaining much.<br></p><p>Perhaps we could adopt the Obj-C ^ as a closure indicator. I think<br>with existing Swift syntax, a lot of the confusion that caused<br>www.fuckingblocksyntax.com would be avoided.<br></p><p>=== Local variable / property ===:<br></p><p>var closure = ^(Int) -&gt; Bool<br></p><p>or<br></p><p>var closure = ^(number: Int) -&gt; Bool {<br></p><p>    if (number == 3) { return true }<br></p><p>}<br></p><p>=== Method param ===<br></p><p>func makeIncrementer(forIncrement amount: Int) -&gt; ^() -&gt; Int {<br></p><p>or<br></p><p>func makeIncrementer(forIncrement amount: Int) -&gt; ^(() -&gt; Int) {<br></p><p>=== Argument ===<br></p><p>func makeIncrementer(forIncrement amount: ^((Int) -&gt; Bool)) -&gt; Bool {}<br></p><p>makeIncrementer(forIncrement: ^(number: Int) {<br></p><p>   if (number == 3) { return true }<br></p><p>})<br></p><p>=== typealias ===<br></p><p>typealias CustomType = ^(String) -&gt; Bool<br></p><p>=== Takes no params, returns void (We take for granted if there&#39;s no<br>return, it&#39;s void) ===<br></p><p>^()<br></p><p><br>And I think we can use all the shorthands we currently use:<br></p><p><br>=== Calling no params, takes void ===<br></p><p>functionWithVoidCallback {<br></p><p>   //Do a thing<br></p><p>}<br></p><p><br>=== Using $0 $1 syntax ===<br></p><p>func compare(_ comparator: ^(a: Int, b: Int) -&gt; Bool) { }<br></p><p>compare {<br></p><p>  %0 &gt; %1<br></p><p>}<br></p><p>By having ^ mark an upcoming closure, I think it&#39;s a lot easier to<br>follow what&#39;s going on with declarations because as you read left to<br>right, you&#39;re prepped that a closure syntax is coming up as you read<br>left to right. It also allows you to keep the params outside of the<br>closure, which I think is a win. Closure params would also have the<br>same syntax everywhere, and be extremely similar to normal method<br>calls which would be easier for new Swift users.<br></p><p>-E<br></p><p><br>On Tue, Dec 29, 2015 at 10:13 PM, David Waite &lt;david at alkaline-solutions.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt; On Dec 29, 2015, at 5:18 PM, Ethan Diamond via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I guess the core of the question for me is why have the concept of a<br>&gt; closure at all when they&#39;re harder to read while acting the same way that<br>&gt; functions do? I&#39;m not a huge fan of Javascript, but the consistancy between<br>&gt; function declarations and anonymous functions is something I feel they got<br>&gt; right. JS syntax for everything that receives parameters and possibly<br>&gt; returns a value is entirely consistent.<br>&gt;<br>&gt;<br>&gt; Some of this is because Javascript doesn&#39;t have to declare types or return<br>&gt; values and it is even loose with arguments and is somewhat confusing (and<br>&gt; dynamic) with “this”. For Swift, which requires knowledge about the<br>&gt; arguments and return values needed by callers, it makes sense to have two<br>&gt; different syntaxes depending on whether or not this knowledge is being<br>&gt; defined by contract or being inferred by context.<br>&gt;<br>&gt; And with ES2015 there are now multiple styles, partially to resolve the<br>&gt; issues with capturing “this” and partially because writing “function”<br>&gt; everywhere is visually distracting.<br>&gt;<br>&gt; Let&#39;s take the anonymous function style:<br>&gt;<br>&gt; func asyncWithCallback(_ : func (String) -&gt; Bool)<br>&gt;<br>&gt; asyncWithCallback(func (param) {<br>&gt;     return param == &quot;string&quot;<br>&gt; })<br>&gt;<br>&gt; Particularly for someone new to the language is both clearer and shorter<br>&gt; than this, which makes the caller rewrite the return type in the closure:<br>&gt;<br>&gt; func asyncWithCallback(_ : String -&gt; Bool)<br>&gt;<br>&gt; asyncWithCallback {<br>&gt;   (param: String) -&gt; Bool in<br>&gt;   return param == &quot;string&quot;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Or I could use:<br>&gt;<br>&gt; asyncWithCallback {<br>&gt;     param in<br>&gt;     return param == &quot;string&quot;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; or even:<br>&gt;<br>&gt; asyncWithCallback { $0 == &quot;string” }<br>&gt;<br>&gt;<br>&gt; A function defines a name and a contract for use and definition, while<br>&gt; closures are only semantically valid once defined by a context. I can<br>&gt; understand the stylistic desire to have closures declare arguments outside<br>&gt; a block and to be closer to function syntax. However, using “func&quot;<br>&gt; anonymously to indicate a different syntax with a different set of options,<br>&gt; potentially inferred input types, and an inferred existence of output as<br>&gt; well as output type might be equally confusing. Perhaps another keyword<br>&gt; could be used for this purpose.<br>&gt;<br>&gt; However this new keyword would need to work with, and avoid adding visual<br>&gt; distraction to, the “$0 == “string” case above.<br>&gt;<br>&gt;<br>&gt; It still fits your unwritten rule to be able to compose language features<br>&gt; in Swift, assuming you leave the same syntactic sugar:<br>&gt;<br>&gt; func if (_ control: Bool, _ path: func ()) {<br>&gt;<br>&gt;   if (control) {<br>&gt;<br>&gt;      path()<br>&gt;<br>&gt;   }<br>&gt;<br>&gt; }<br>&gt;<br>&gt; if (a == b) {<br>&gt;<br>&gt;   //LETS DO SOME STUFF<br>&gt;<br>&gt; }<br>&gt;<br>&gt; You probably realize this but closures and blocks have different control<br>&gt; flow, so for instance the above would absorb/malfunction on returns as well<br>&gt; as attempts to break/continue outer loops.<br>&gt;<br>&gt; -DW<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/3351381d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Closure Syntax</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>December 30, 2015 at 07:00:00pm</p></header><div class="content"><p>&gt; For clarity&#39;s sake, there&#39;s really two syntactic issues that I think would be good to address. The first, which I think is the far bigger problem, which is that right now a list of params with closures is very hard to read. For example, this requires mental effort to decode whether this is returning an Int, or a closure returning an Int:<br>&gt; <br>&gt; func makeIncrementer(forIncrement amount: Int) -&gt; () -&gt; Int {<br>&gt; }<br>I look at currying like a right-associative operator (like the ternary operator, or assignments in languages like C). There is a function that takes no arguments and returns an int, that you get from a function that takes an int argument.<br></p><p>Changing this to say<br>&gt; func makeIncrementer(forIncrement amount: Int) -&gt; func () -&gt; Int {<br>feels like it is changing the behavior to that of a non-associative operator. <br></p><p>One interesting result would be if by removing the ternary operator as it stands today and changing how currying heppens, swift wound up having no right associative operators left in core.<br>&gt; And the second being that stylistically, having the params on the inside of the closure is breaking precedent of params outside of the block of code without gaining much. <br>&gt; Perhaps we could adopt the Obj-C ^ as a closure indicator. I think with existing Swift syntax, a lot of the confusion that caused www.fuckingblocksyntax.com &lt;http://www.fuckingblocksyntax.com/&gt; would be avoided.<br>&lt;snip&gt;<br>&gt; makeIncrementer(forIncrement: ^(number: Int) {<br>&gt;    if (number == 3) { return true }<br>&gt; })<br>Why does the block now have to be declared within the function parameters?<br>Why do I have to declare the type of number now?<br>Why do I *not* have to declare the return type as being a boolean?<br>Would this syntax still support single expression implicit returns, e.g. current Swift<br></p><p>&gt; [1,2,3].map() { number in number == 3 }<br>$R0: [Bool] = 3 values {<br>  [0] = false<br>  [1] = false<br>  [2] = true<br>}<br>&gt; By having ^ mark an upcoming closure, I think it&#39;s a lot easier to follow what&#39;s going on with declarations because as you read left to right, you&#39;re prepped that a closure syntax is coming up as you read left to right. It also allows you to keep the params outside of the closure, which I think is a win. Closure params would also have the same syntax everywhere, and be extremely similar to normal method calls which would be easier for new Swift users. <br>There are three pieces at play here IMHO:<br>1. How functions (global and on types) are declared and implemented<br>2. How function specifications are indicated as types<br>3. How anonymous functions are declared and implemented<br></p><p>When I declare a global or type-specific function, I can specify its name and arguments, assign external names to them (as well as internal names), and declare my return value. The types, even if generic, must be known for the function implementation to pass semantic checks.<br></p><p>The syntax for functions as types are really just a list of input and output types. There are not (for instance) named parameter requirements on the implementing functions. But the input and return types must be known to declare a new function type.<br></p><p>Anonymous functions assume a great deal of type information from the context in which they are used. This is why you can get away with not declaring input types or even input names (using $0, $1, etc), the return type or even if a value is returned. The code is mapped into the context it is needed, then semantic evaluation is done.<br></p><p>You are attempting to change #2 and #3 at the same time, when really they have quite different needs. I assume the reason anonymous functions (aka closures in Swift) have their argument names on the inside of the block is because the argument names have no external bearing whatsoever. Considering I may or may not declare type information or even give all the parameters names, this makes a certain kind of sense. If you were to move the argument names outside the block, you would need a syntax specifically for that. There are enough options that reusing the same base syntax between 1 and 3 or 2 and 3 would likely just _feel_ wrong.<br></p><p>There are enough rules about escape analysis to possibly make sense to have function blocks, do blocks, repeat blocks, switch blocks, for…in blocks, etc all be considered ‘kinds’ of blocks, and for closure blocks to be on that list. It possibly makes sense for them to have a keyword just like all the other blocks to simplify compiler and human visual parsing. But I don’t envy the effort of redesigning and redecorating that particular bike shed :-)<br></p><p>-DW<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/4a21f8a1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0b7bdc0c491a18e4aad6ae6004c3601?s=50"></div><header><strong>Closure Syntax</strong> from <string>Ethan Diamond</string> &lt;edgewood7558 at gmail.com&gt;<p>December 31, 2015 at 06:00:00pm</p></header><div class="content"><p>*There are three pieces at play here IMHO:*<br>*1. How functions (global and on types) are declared and implemented*<br>*2. How function specifications are indicated as types*<br>*3. How anonymous functions are declared and implemented*<br></p><p>Agreed, so lets flush out the rules a little more and see if we can find a<br>common language for all three, since they&#39;re interconnected. For the sake<br>of clarity, I&#39;m going to refer to closures as blocks, since they&#39;re<br>effectively the same thing. I think we should begin with these three rules:<br></p><p>1. Let&#39;s try to keep precedent for function calls, since blocks are pretty<br>much functions<br>2. A ^ signifies that we are now entering a block context with regards to<br>syntax<br>3. Just as in a lot of the rest of Swift, let&#39;s infer information we can,<br>but optionally allow it to be respecified if it makes the syntax clearer<br></p><p>&gt;From there, I think the solution to your #2 (*How function specifications<br>are indicated as types) *naturally presents itself. This is a normal<br>function declaration:<br></p><p>func funcName(param) -&gt; return_type<br></p><p>A block is effectively a function without a name - an anonymous function.<br>So we remove the name. I also agree with your earlier points that func is<br>inappropriate terminology for what we&#39;re trying to do so we remove that<br>too. Using the ^ rule to signify a block, we get these options, which I<br>think should both be valid:<br></p><p>^(param) -&gt; return_type<br>^((param) -&gt; return_type)<br></p><p>Which I find to be easier to read than the current closure type:<br></p><p>(param) -&gt; return_type<br></p><p>because it shares syntax with tuples up until the -&gt;, the () are optional<br>making the param share syntax with whatever type the param is, and because<br>when nested closure type syntax become particularly nasty to read.<br></p><p>Indeed, I think it gives us the opportunity for one more gain here. We have<br>functions with named parameters because of Swift&#39;s goal of clarity. This<br>gives us the opportunity for blocks to also have named parameters. Which<br>one of these is better?<br></p><p>func fetchHTML(callback: (String, Int) -&gt; Error?)<br></p><p>or<br></p><p>func fetchHTML(callback: ^(url: String, allowedResponseCode: Int) -&gt; Error?)<br></p><p>The named params aren&#39;t enforced when the block is defined, but provides<br>hints for the Swift user who defines the block body. They can rename those<br>params if they want, but it gives them a hint on how those params will be<br>used, and will autocomplete when they go to write the body with those names.<br></p><p>&gt;From there, I think we have the answer to your question #1 as well (*How<br>functions are declared and implemented) *in that aside from using our new<br>block type syntax for their params, they are completely unchanged. However,<br>the new block type syntax makes function declarations easier to read.<br></p><p>As I listed before, we take this, which I find hard to read at a glance:<br></p><p>func makeIncrementer(forIncrement amount: Int) -&gt; () -&gt; Int { ... }<br></p><p>and replace it with something better:<br></p><p>func makeIncrementer(forIncrement amount: Int) -&gt; ^() -&gt; Int { ... }<br></p><p>or, what I feel should be an option with the ^ syntax:<br></p><p>func makeIncrementer(forIncrement amount: Int) -&gt; ^(() -&gt; Int) { ... }<br></p><p>I don&#39;t think you can look at that and tell me it&#39;s not clearer to read.<br></p><p>Your point 3 (*How anonymous functions are declared and implemented) *is a<br>bit trickier to explain, but I think the explanation arises naturally from<br>the three rules.<br></p><p>Let&#39;s start with rule 1, and look at the way we already define an call a<br>function:<br></p><p>func isNumberFour(number: Int) -&gt; Bool {<br>    return number == 4<br>}<br>isNumberFour(4)<br></p><p>Because we already know the param type and the return type, we don&#39;t need<br>to respecify that information when we call the function. Using the same<br>logic we used to come up with the block type syntax - removing &quot;func&quot; and<br>since it has no name, basically using ^ as a signifier - we&#39;re going to be<br>able to reason out exactly what this would look like:<br></p><p>^(number: Int) -&gt; Bool {<br>    return number == 4<br>}<br></p><p>Let&#39;s take the case where a function has a block as a parameter:<br></p><p>func isNumberFour(calculateNumber: ^((Int) -&gt; Int)) -&gt; Bool<br></p><p>How do I call this? If we&#39;re not using rule 3, inferring what we can, we<br>would write out this, which I think should be valid syntax if desired by<br>Swift&#39;s users:<br></p><p>let isFour: Bool = isNumberFour(calculateNumber: ^(number: Int) -&gt; Int {<br>    return number * 2<br>})<br></p><p>But there&#39;s no reason to be that verbose. We have the isNumberFour<br>declaration. Much like we don&#39;t need to specify that isFour is a Bool,<br>Swift should also allow this:<br></p><p>let isFour = isNumberFour(calculateNumber: ^(number) {<br>   return number * 2<br>})<br></p><p>The compiler already knows enough about the block for that to work. We<br>named the Int param for the calculateNumber block, so autocomplete can<br>finish this for us. However, I also think it should be valid to be able to<br>change the name when the block&#39;s body is defined. So this would also be<br>valid:<br></p><p>let isFour = isNumberFour(calculateNumber: ^(amount) {<br>   return amount * 2<br>})<br></p><p>So the rules we follow are pretty simple. When the block&#39;s body is defined,<br>we only require users to specify the data the compiler can&#39;t infer, while<br>having the option to specify the rest. I believe this is exactly what we&#39;re<br>doing already with closures, we&#39;re just moving the part preceding the &quot;in&quot;<br>to the outside of the method and prefixing it with a ^. It makes closures<br>easier to reason about the syntax, and easier to read.<br></p><p>There are a few shorthands that would go with it. Let&#39;s take the var /<br>property case. Without using rule 3, removing syntax we can infer, we get<br>this:<br></p><p>var isNumberFour: ^(number: Int) -&gt; Bool = ^(number: Int) -&gt; Bool {<br>    return number == 4<br>}<br>isNumberFour(4)<br></p><p>But we already know the parameters, return type, and name of the<br>parameters. So following rule 3, we can reduce this to:<br></p><p>var isNumberFour: ^(Int) -&gt; Bool = ^(number) {<br>    return number == 4<br>}<br></p><p>But I would propose we allow this shorthand, since it&#39;s nicer to read:<br></p><p>var isNumberFour: ^(number: Int) -&gt; Bool = {<br>    return number == 4<br>}<br></p><p>As previously said, if there&#39;s no return type specified, we assume void.<br>Also, if there&#39;s no params and returns void, you can bypass the ^() all<br>together. So:<br></p><p>func async(_ callback: ^())<br></p><p>async(^() {<br>  //Do the callback<br>})<br></p><p>could still be written as:<br></p><p>async {<br>  //Do the callback<br>}<br></p><p>Much like closures in current Swift, if we want to use the $0 $1 shorthand,<br>we can also skip the block param piece:<br></p><p>func sort(_ comparator:^((a: Int, b: Int) -&gt; Bool))<br></p><p>sort(^(a, b) {<br>  return a &gt; b<br>})<br></p><p>could be written as:<br></p><p>sort {<br>  return $0 &gt; $1<br>}<br></p><p>And to answer your question, &quot;Would this syntax still support single<br>expression implicit returns, e.g. current Swift,&quot; the answer is still yes:<br></p><p>[1,2,3].map(^(number) {number == 3})<br></p><p>I feel like this syntax feels intuitive, gets rid of the weird &quot;in&quot; syntax,<br>and is closer to the function syntax people are used to. It also makes<br>reading block types easier, particularly when nested. I know there&#39;s a lot<br>of closure momentum to overcome at this point, but I really the time it<br>would take to change this would be worth it down the road.<br></p><p>-E<br></p><p><br>On Wed, Dec 30, 2015 at 6:48 PM, David Waite &lt;david at alkaline-solutions.com&gt;<br>wrote:<br></p><p>&gt; For clarity&#39;s sake, there&#39;s really two syntactic issues that I think would<br>&gt; be good to address. The first, which I think is the far bigger problem,<br>&gt; which is that right now a list of params with closures is very hard to<br>&gt; read. For example, this requires mental effort to decode whether this is<br>&gt; returning an Int, or a closure returning an Int:<br>&gt;<br>&gt; func makeIncrementer(forIncrement amount: Int) -&gt; () -&gt; Int {<br>&gt;<br>&gt; }<br>&gt;<br>&gt; I look at currying like a right-associative operator (like the ternary<br>&gt; operator, or assignments in languages like C). There is a function that<br>&gt; takes no arguments and returns an int, that you get from a function that<br>&gt; takes an int argument.<br>&gt;<br>&gt; Changing this to say<br>&gt;<br>&gt; func makeIncrementer(forIncrement amount: Int) -&gt; func () -&gt; Int {<br>&gt;<br>&gt; feels like it is changing the behavior to that of a non-associative<br>&gt; operator.<br>&gt;<br>&gt; One interesting result would be if by removing the ternary operator as it<br>&gt; stands today and changing how currying heppens, swift wound up having no<br>&gt; right associative operators left in core.<br>&gt;<br>&gt; And the second being that stylistically, having the params on the inside of the closure is breaking precedent of params outside of the block of code without gaining much.<br>&gt;<br>&gt; Perhaps we could adopt the Obj-C ^ as a closure indicator. I think with existing Swift syntax, a lot of the confusion that caused www.fuckingblocksyntax.com would be avoided.<br>&gt;<br>&gt; &lt;snip&gt;<br>&gt;<br>&gt; makeIncrementer(forIncrement: ^(number: Int) {<br>&gt;<br>&gt;    if (number == 3) { return true }<br>&gt;<br>&gt; })<br>&gt;<br>&gt; Why does the block now have to be declared within the function parameters?<br>&gt; Why do I have to declare the type of number now?<br>&gt; Why do I *not* have to declare the return type as being a boolean?<br>&gt; Would this syntax still support single expression implicit returns, e.g.<br>&gt; current Swift<br>&gt;<br>&gt; &gt; [1,2,3].map() { number in number == 3 }<br>&gt; $R0: [Bool] = 3 values {<br>&gt;   [0] = false<br>&gt;   [1] = false<br>&gt;   [2] = true<br>&gt; }<br>&gt;<br>&gt; By having ^ mark an upcoming closure, I think it&#39;s a lot easier to follow what&#39;s going on with declarations because as you read left to right, you&#39;re prepped that a closure syntax is coming up as you read left to right. It also allows you to keep the params outside of the closure, which I think is a win. Closure params would also have the same syntax everywhere, and be extremely similar to normal method calls which would be easier for new Swift users.<br>&gt;<br>&gt; There are three pieces at play here IMHO:<br>&gt; 1. How functions (global and on types) are declared and implemented<br>&gt; 2. How function specifications are indicated as types<br>&gt; 3. How anonymous functions are declared and implemented<br>&gt;<br>&gt; When I declare a global or type-specific function, I can specify its name<br>&gt; and arguments, assign external names to them (as well as internal names),<br>&gt; and declare my return value. The types, even if generic, must be known for<br>&gt; the function implementation to pass semantic checks.<br>&gt;<br>&gt; The syntax for functions as types are really just a list of input and<br>&gt; output types. There are not (for instance) named parameter requirements on<br>&gt; the implementing functions. But the input and return types must be known to<br>&gt; declare a new function type.<br>&gt;<br>&gt; Anonymous functions assume a great deal of type information from the<br>&gt; context in which they are used. This is why you can get away with not<br>&gt; declaring input types or even input names (using $0, $1, etc), the return<br>&gt; type or even if a value is returned. The code is mapped into the context it<br>&gt; is needed, then semantic evaluation is done.<br>&gt;<br>&gt; You are attempting to change #2 and #3 at the same time, when really they<br>&gt; have quite different needs. I assume the reason anonymous functions (aka<br>&gt; closures in Swift) have their argument names on the inside of the block is<br>&gt; because the argument names have no external bearing whatsoever. Considering<br>&gt; I may or may not declare type information or even give all the parameters<br>&gt; names, this makes a certain kind of sense. If you were to move the argument<br>&gt; names outside the block, you would need a syntax specifically for that.<br>&gt; There are enough options that reusing the same base syntax between 1 and 3<br>&gt; or 2 and 3 would likely just _feel_ wrong.<br>&gt;<br>&gt; There are enough rules about escape analysis to possibly make sense to<br>&gt; have function blocks, do blocks, repeat blocks, switch blocks, for…in<br>&gt; blocks, etc all be considered ‘kinds’ of blocks, and for closure blocks to<br>&gt; be on that list. It possibly makes sense for them to have a keyword just<br>&gt; like all the other blocks to simplify compiler and human visual parsing.<br>&gt; But I don’t envy the effort of redesigning and redecorating that particular<br>&gt; bike shed :-)<br>&gt;<br>&gt; -DW<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/da11afeb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Closure Syntax</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 31, 2015 at 09:00:00pm</p></header><div class="content"><p>On Dec 31, 2015, at 6:16 PM, Ethan Diamond via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; There are three pieces at play here IMHO:<br>&gt; 1. How functions (global and on types) are declared and implemented<br>&gt; 2. How function specifications are indicated as types<br>&gt; 3. How anonymous functions are declared and implemented<br>&gt; <br>&gt; Agreed, so lets flush out the rules a little more and see if we can find a common language for all three, since they&#39;re interconnected. For the sake of clarity, I&#39;m going to refer to closures as blocks, since they&#39;re effectively the same thing. I think we should begin with these three rules:<br>&gt; <br>&gt; 1. Let&#39;s try to keep precedent for function calls, since blocks are pretty much functions<br>&gt; 2. A ^ signifies that we are now entering a block context with regards to syntax<br>&gt; 3. Just as in a lot of the rest of Swift, let&#39;s infer information we can, but optionally allow it to be respecified if it makes the syntax clearer<br></p><p>I can’t believe that you’re seriously considering use of ^ for closure syntax, it is one of the most hated aspects of ObjC’s blocks. :-) :-)  FWIW, I’m the one to blame for the use of caret in ObjC’s block’s syntax.  In my defense, this was necessary to fit blocks into the C grammar - everything everyone hates about blocks declaration syntax is shared with C function pointer syntax.  That &quot;problem to be solved” doesn’t exist in the Swift grammar, so I don’t see why we’d carry it over.<br></p><p>More generally, we are extremely unlikely to make a change to the basic declaration syntax of swift (e.g. func, var, etc) or closure expressions.  They have been carefully considered, and work well in practice.  I don’t see a reason to make a change here.<br></p><p>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/6a89b54f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e2303da56647c283b6d8e58d5831faca?s=50"></div><header><strong>Closure Syntax</strong> from <string>Joseph Bell</string> &lt;joe at iachieved.it&gt;<p>January  1, 2016 at 11:00:00am</p></header><div class="content"><p>+1 to not introduce ^ for closure syntax.<br></p><p>On Thu, Dec 31, 2015 at 11:26 PM, Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Dec 31, 2015, at 6:16 PM, Ethan Diamond via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; *There are three pieces at play here IMHO:*<br>&gt; *1. How functions (global and on types) are declared and implemented*<br>&gt; *2. How function specifications are indicated as types*<br>&gt; *3. How anonymous functions are declared and implemented*<br>&gt;<br>&gt; Agreed, so lets flush out the rules a little more and see if we can find a<br>&gt; common language for all three, since they&#39;re interconnected. For the sake<br>&gt; of clarity, I&#39;m going to refer to closures as blocks, since they&#39;re<br>&gt; effectively the same thing. I think we should begin with these three rules:<br>&gt;<br>&gt; 1. Let&#39;s try to keep precedent for function calls, since blocks are pretty<br>&gt; much functions<br>&gt; 2. A ^ signifies that we are now entering a block context with regards to<br>&gt; syntax<br>&gt; 3. Just as in a lot of the rest of Swift, let&#39;s infer information we can,<br>&gt; but optionally allow it to be respecified if it makes the syntax clearer<br>&gt;<br>&gt;<br>&gt; I can’t believe that you’re seriously considering use of ^ for closure<br>&gt; syntax, it is one of the most hated aspects of ObjC’s blocks. :-) :-)<br>&gt;  FWIW, I’m the one to blame for the use of caret in ObjC’s block’s syntax.<br>&gt; In my defense, this was necessary to fit blocks into the C grammar -<br>&gt; everything everyone hates about blocks declaration syntax is shared with C<br>&gt; function pointer syntax.  That &quot;problem to be solved” doesn’t exist in the<br>&gt; Swift grammar, so I don’t see why we’d carry it over.<br>&gt;<br>&gt; More generally, we are extremely unlikely to make a change to the basic<br>&gt; declaration syntax of swift (e.g. func, var, etc) or closure expressions.<br>&gt; They have been carefully considered, and work well in practice.  I don’t<br>&gt; see a reason to make a change here.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160101/9b7e0847/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0b7bdc0c491a18e4aad6ae6004c3601?s=50"></div><header><strong>Closure Syntax</strong> from <string>Ethan Diamond</string> &lt;edgewood7558 at gmail.com&gt;<p>January  1, 2016 at 02:00:00pm</p></header><div class="content"><p>FWIW I don&#39;t think the backlash to the use of ^ with Obj-C blocks was<br>because of the carat itself, but because of the inconsistency of the syntax<br>in different contexts. Sometimes the return type was after the ^, sometimes<br>before. Sometimes you had to use (^). Sometimes the carat had the name of<br>the block with it ^functionName. None of it fit in with the [object<br>methodName] syntax of the language itself.<br></p><p>However, none of those problems exist with block syntax in Swift - it would<br>be consistent all the way through. I guess what I&#39;m getting at is that I<br>hope when Swift was being designed that the carat syntax wasn&#39;t considered<br>because of some benefit of the current syntax, and not from fear of the<br>initial backlash from people who didn&#39;t like Obj-C block syntax. I can&#39;t<br>speak to language design with respect to the compiler since I have no<br>experience in that area, but from a programming perspective, there are a<br>lot of benefits of block syntax over closure syntax and no benefits of<br>closures over block syntax.<br></p><p>- Block syntax clarifies some hard to read function declarations such as:<br></p><p>func makeIncrementer(forIncrement amount: Int) -&gt; () -&gt; Int&quot;<br></p><p>- There is no other syntax in Swift where the body&#39;s parameters are named<br>inside the body. Everyone else has the ( inputs are named ) { body } syntax<br>- (some of these are implied):<br></p><p>  for (index in indices) { //Something with index }<br>  func doThing(index: Int) { //Something with index }<br>  if (let index = index) { //Something with index }<br></p><p>- You save the in keyword for for-in loops<br>- I showed earlier how it allows for parameter naming when defining a<br>closure type, which would be useful for autocompletion of blocks<br></p><p>Anyway, if closure syntax is unofficially set in stone then that&#39;s that. I<br>still appreciate you taking the time to listen.<br></p><p>-E<br></p><p><br></p><p>On Thu, Dec 31, 2015 at 9:26 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br></p><p>&gt; On Dec 31, 2015, at 6:16 PM, Ethan Diamond via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; *There are three pieces at play here IMHO:*<br>&gt; *1. How functions (global and on types) are declared and implemented*<br>&gt; *2. How function specifications are indicated as types*<br>&gt; *3. How anonymous functions are declared and implemented*<br>&gt;<br>&gt; Agreed, so lets flush out the rules a little more and see if we can find a<br>&gt; common language for all three, since they&#39;re interconnected. For the sake<br>&gt; of clarity, I&#39;m going to refer to closures as blocks, since they&#39;re<br>&gt; effectively the same thing. I think we should begin with these three rules:<br>&gt;<br>&gt; 1. Let&#39;s try to keep precedent for function calls, since blocks are pretty<br>&gt; much functions<br>&gt; 2. A ^ signifies that we are now entering a block context with regards to<br>&gt; syntax<br>&gt; 3. Just as in a lot of the rest of Swift, let&#39;s infer information we can,<br>&gt; but optionally allow it to be respecified if it makes the syntax clearer<br>&gt;<br>&gt;<br>&gt; I can’t believe that you’re seriously considering use of ^ for closure<br>&gt; syntax, it is one of the most hated aspects of ObjC’s blocks. :-) :-)<br>&gt;  FWIW, I’m the one to blame for the use of caret in ObjC’s block’s syntax.<br>&gt; In my defense, this was necessary to fit blocks into the C grammar -<br>&gt; everything everyone hates about blocks declaration syntax is shared with C<br>&gt; function pointer syntax.  That &quot;problem to be solved” doesn’t exist in the<br>&gt; Swift grammar, so I don’t see why we’d carry it over.<br>&gt;<br>&gt; More generally, we are extremely unlikely to make a change to the basic<br>&gt; declaration syntax of swift (e.g. func, var, etc) or closure expressions.<br>&gt; They have been carefully considered, and work well in practice.  I don’t<br>&gt; see a reason to make a change here.<br>&gt;<br>&gt; -Chris<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160101/c2fd706b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>Closure Syntax</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>January  1, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jan 1, 2016, at 4:21 PM, Ethan Diamond via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; FWIW I don&#39;t think the backlash to the use of ^ with Obj-C blocks was because of the carat itself, but because of the inconsistency of the syntax in different contexts. Sometimes the return type was after the ^, sometimes before. Sometimes you had to use (^). Sometimes the carat had the name of the block with it ^functionName. None of it fit in with the [object methodName] syntax of the language itself. <br></p><p>I’ll drop in a straight-up objection to the carat. The infix arrow syntax is perfectly clear, and in mathematical contexts has proved its readability since long before there were programming languages. Contra the proposal, there’s nothing wrong with this:<br></p><p>  func makeIncrementer(forIncrement amount: Int) -&gt; () -&gt; Int<br></p><p>The carat, on the other hand, is noise. Only habituation to Obj-C blocks makes it seem like anything else.<br></p><p>I _do_ agree that the { foo, bar in … } syntax is clumsy, both graphically and grammatically. Definitely not my favorite part of Swift. I don’t find the carat a compelling fix, however.<br></p><p>Cheers,<br></p><p>Paul<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160101/58c84d72/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Closure Syntax</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January  1, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jan 1, 2016, at 2:21 PM, Ethan Diamond &lt;edgewood7558 at gmail.com&gt; wrote:<br>&gt; <br>&gt; FWIW I don&#39;t think the backlash to the use of ^ with Obj-C blocks was because of the carat itself,<br></p><p>Fair enough, different people have different objections.  I’m sure some people love blocks syntax :-)<br></p><p>&gt; but because of the inconsistency of the syntax in different contexts. Sometimes the return type was after the ^, sometimes before. Sometimes you had to use (^). Sometimes the carat had the name of the block with it ^functionName. None of it fit in with the [object methodName] syntax of the language itself. <br></p><p>No, it fit perfectly with C.  Blocks are an extension to C, not technically an Objective-C extension.<br></p><p>&gt; Anyway, if closure syntax is unofficially set in stone then that&#39;s that. I still appreciate you taking the time to listen.<br></p><p>I understand the other points you make, but again, we’re pretty happy with closure syntax as is.  Keeping the arguments inside the closure has a ton of advantages for the expression grammar (making it possible to parse :-) and allows trailing closures to emulate builtin statements.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Closure Syntax</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>January  1, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jan 1, 2016, at 5:05 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 1, 2016, at 2:21 PM, Ethan Diamond &lt;edgewood7558 at gmail.com &lt;mailto:edgewood7558 at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; FWIW I don&#39;t think the backlash to the use of ^ with Obj-C blocks was because of the carat itself,<br>&gt; <br>&gt; Fair enough, different people have different objections.  I’m sure some people love blocks syntax :-)<br>&gt; <br>&gt;&gt; but because of the inconsistency of the syntax in different contexts. Sometimes the return type was after the ^, sometimes before. Sometimes you had to use (^). Sometimes the carat had the name of the block with it ^functionName. None of it fit in with the [object methodName] syntax of the language itself. <br>&gt; <br>&gt; No, it fit perfectly with C.  Blocks are an extension to C, not technically an Objective-C extension.<br></p><p>I wouldn’t say it fit perfectly. It matched C’s function pointer syntax, so it fit as well as that. However, C’s function pointer syntax is kind of horrible, so.<br></p><p>Not that that is the fault of anyone on the Objective-C team, of course.<br></p><p>Charles<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160101/a92516cf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8993e184f091e98f018c07d96ac4731f?s=50"></div><header><strong>Closure Syntax</strong> from <string>John Joyce</string> &lt;uchuugaka at icloud.com&gt;<p>January  2, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jan 2, 2016, at 9:41 AM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 1, 2016, at 5:05 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 1, 2016, at 2:21 PM, Ethan Diamond &lt;edgewood7558 at gmail.com &lt;mailto:edgewood7558 at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; FWIW I don&#39;t think the backlash to the use of ^ with Obj-C blocks was because of the carat itself,<br>&gt;&gt; <br>&gt;&gt; Fair enough, different people have different objections.  I’m sure some people love blocks syntax :-)<br>&gt;&gt; <br>&gt;&gt;&gt; but because of the inconsistency of the syntax in different contexts. Sometimes the return type was after the ^, sometimes before. Sometimes you had to use (^). Sometimes the carat had the name of the block with it ^functionName. None of it fit in with the [object methodName] syntax of the language itself. <br>&gt;&gt; <br>&gt;&gt; No, it fit perfectly with C.  Blocks are an extension to C, not technically an Objective-C extension.<br>&gt; <br>&gt; I wouldn’t say it fit perfectly. It matched C’s function pointer syntax, so it fit as well as that. However, C’s function pointer syntax is kind of horrible, so.<br>&gt; <br>&gt; Not that that is the fault of anyone on the Objective-C team, of course.<br>&gt; <br>&gt; Charles<br>&gt; <br>In the context of C, it is as good as it can be, and actually a bit nicer than some function pointers are, though you can always C your way to something nicer looking which the typedefs generally do (or if the old preprocessor define macros).<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160102/06b66ee6/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
