<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/14f382feb5f0dd3d3700edf8d6156aa9?s=50"></div><header><strong>[pitch] make @nonobjc the default</strong> from <string>Jay Abbott</string> &lt;jay at abbott.me.uk&gt;<p>October 18, 2016 at 11:00:00pm</p></header><div class="content"><p>Currently, if you extend a class that comes from obj-c, Swift assumes you<br>want to make those methods available to call from obj-c code. If you add<br>operators, you must declare them as @nonobjc otherwise the bridging header<br>which is generated declares obj-c methods with the operator character as<br>the method name, which isn&#39;t valid in obj-c and causes compile errors.<br></p><p>I&#39;m just wondering how others feel about this - my feeling is that a Swift<br>developer should not have to know anything about obj-c when doing Swifty<br>things to a bridged class from a framework (such as extending it). As far<br>as they are concerned the framework class should compile the same as if it<br>were fully implemented in Swift.<br></p><p>Thoughts?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161018/70db63cd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[pitch] make @nonobjc the default</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>October 18, 2016 at 07:00:00pm</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On Oct 18, 2016, at 4:00 PM, Jay Abbott via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Currently, if you extend a class that comes from obj-c, Swift assumes you want to make those methods available to call from obj-c code. If you add operators, you must declare them as @nonobjc otherwise the bridging header which is generated declares obj-c methods with the operator character as the method name, which isn&#39;t valid in obj-c and causes compile errors.<br></p><p>The operators bit is an outright bug, which I believe has already been fixed in master. <br></p><p>&gt; I&#39;m just wondering how others feel about this - my feeling is that a Swift developer should not have to know anything about obj-c when doing Swifty things to a bridged class from a framework (such as extending it). As far as they are concerned the framework class should compile the same as if it were fully implemented in Swift.<br></p><p>Modulo bugs like the above, I think we already have this property? Swift declarations are exposed to Objective-C if they can be. One doesn&#39;t generally have to think about it unless you&#39;re trying to use those declarations from Objective-C. <br></p><p>&gt; Thoughts?<br></p><p>I actually thought you were going further with this, eliminating the inferred @objc except in cases where it&#39;s needed to work with an existing framework. That&#39;s something I&#39;d love to see someone working on.<br></p><p>  - Doug<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/14f382feb5f0dd3d3700edf8d6156aa9?s=50"></div><header><strong>[pitch] make @nonobjc the default</strong> from <string>Jay Abbott</string> &lt;jay at abbott.me.uk&gt;<p>October 19, 2016 at 11:00:00am</p></header><div class="content"><p>Ok, good to know that&#39;s just a bug. But I still think that implicit @objc<br>should be removed. For bridged classes with obj-c-specific interfaces (for<br>example a method that takes a selector), it would be better if the<br>Swift-side interface was forced to make a Swifty interface that hides it.<br>This way, the people maintaining an interface have to either a) write a<br>wrapper with a Swifty interface; or b) explicitly cop out and use @objc and<br>inform their users that they may also have to do the same in some<br>situations; or c) persuade their employers to let them port the whole thing<br>to pure Swift, which sounds like a lot of fun and is probably what they<br>really want to do :D.<br></p><p>I&#39;m not really sure how this works though, at what level this is applied?<br>Maybe it&#39;s more to do with the default build settings in Xcode than Swift<br>itself? I just would rather see Swift stand alone by default.<br></p><p><br></p><p>On Wed, 19 Oct 2016 at 03:51 Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt;<br>&gt; Sent from my iPhone<br>&gt;<br>&gt; &gt; On Oct 18, 2016, at 4:00 PM, Jay Abbott via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Currently, if you extend a class that comes from obj-c, Swift assumes<br>&gt; you want to make those methods available to call from obj-c code. If you<br>&gt; add operators, you must declare them as @nonobjc otherwise the bridging<br>&gt; header which is generated declares obj-c methods with the operator<br>&gt; character as the method name, which isn&#39;t valid in obj-c and causes compile<br>&gt; errors.<br>&gt;<br>&gt; The operators bit is an outright bug, which I believe has already been<br>&gt; fixed in master.<br>&gt;<br>&gt; &gt; I&#39;m just wondering how others feel about this - my feeling is that a<br>&gt; Swift developer should not have to know anything about obj-c when doing<br>&gt; Swifty things to a bridged class from a framework (such as extending it).<br>&gt; As far as they are concerned the framework class should compile the same as<br>&gt; if it were fully implemented in Swift.<br>&gt;<br>&gt; Modulo bugs like the above, I think we already have this property? Swift<br>&gt; declarations are exposed to Objective-C if they can be. One doesn&#39;t<br>&gt; generally have to think about it unless you&#39;re trying to use those<br>&gt; declarations from Objective-C.<br>&gt;<br>&gt; &gt; Thoughts?<br>&gt;<br>&gt; I actually thought you were going further with this, eliminating the<br>&gt; inferred @objc except in cases where it&#39;s needed to work with an existing<br>&gt; framework. That&#39;s something I&#39;d love to see someone working on.<br>&gt;<br>&gt;   - Doug<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161019/def36837/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[pitch] make @nonobjc the default</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>October 19, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Oct 19, 2016, at 4:53 AM, Jay Abbott &lt;jay at abbott.me.uk&gt; wrote:<br>&gt; <br>&gt; Ok, good to know that&#39;s just a bug. But I still think that implicit @objc should be removed.<br></p><p>Oh, I agree that implicit @objc should be removed. I suspect it’s responsible for a nontrivial amount of code bloat and unnecessary Objective-C selector collisions.<br></p><p>&gt; For bridged classes with obj-c-specific interfaces (for example a method that takes a selector), it would be better if the Swift-side interface was forced to make a Swifty interface that hides it. This way, the people maintaining an interface have to either a) write a wrapper with a Swifty interface; or b) explicitly cop out and use @objc and inform their users that they may also have to do the same in some situations; or c) persuade their employers to let them port the whole thing to pure Swift, which sounds like a lot of fun and is probably what they really want to do :D.<br></p><p>I don’t quite view explicit @objc as a cop-out—it’s a useful tool to limit the amount of glue code one needs to write.<br></p><p>&gt; I&#39;m not really sure how this works though, at what level this is applied? Maybe it&#39;s more to do with the default build settings in Xcode than Swift itself? I just would rather see Swift stand alone by default.<br></p><p>I think it’s a Swift language change: we should only infer ‘@objc’ when the API<br></p><p>	* Overrides of an @objc API,<br>	* Satisfies a requirement of an @objc protocol, or<br>	* Uses a Swift feature that requires the Objective-C runtime (e.g., @NSManaged, @IBAction, currently ‘dynamic’ although that feels wrong to me)<br></p><p>It’s hard to justify pushing for this in Swift 4 stage 1, because changing defaults doesn’t affect the ABI, but it’s something I’d love to see us do at some point in Swift 4.<br></p><p>	- Doug<br></p><p>&gt; <br>&gt; <br>&gt; <br>&gt; On Wed, 19 Oct 2016 at 03:51 Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt; &gt; On Oct 18, 2016, at 4:00 PM, Jay Abbott via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Currently, if you extend a class that comes from obj-c, Swift assumes you want to make those methods available to call from obj-c code. If you add operators, you must declare them as @nonobjc otherwise the bridging header which is generated declares obj-c methods with the operator character as the method name, which isn&#39;t valid in obj-c and causes compile errors.<br>&gt; <br>&gt; The operators bit is an outright bug, which I believe has already been fixed in master.<br>&gt; <br>&gt; &gt; I&#39;m just wondering how others feel about this - my feeling is that a Swift developer should not have to know anything about obj-c when doing Swifty things to a bridged class from a framework (such as extending it). As far as they are concerned the framework class should compile the same as if it were fully implemented in Swift.<br>&gt; <br>&gt; Modulo bugs like the above, I think we already have this property? Swift declarations are exposed to Objective-C if they can be. One doesn&#39;t generally have to think about it unless you&#39;re trying to use those declarations from Objective-C.<br>&gt; <br>&gt; &gt; Thoughts?<br>&gt; <br>&gt; I actually thought you were going further with this, eliminating the inferred @objc except in cases where it&#39;s needed to work with an existing framework. That&#39;s something I&#39;d love to see someone working on.<br>&gt; <br>&gt;   - Doug<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161019/0545a35a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[pitch] make @nonobjc the default</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>October 19, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Oct 19, 2016, at 9:35 AM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 19, 2016, at 4:53 AM, Jay Abbott &lt;jay at abbott.me.uk &lt;mailto:jay at abbott.me.uk&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Ok, good to know that&#39;s just a bug. But I still think that implicit @objc should be removed.<br>&gt; <br>&gt; Oh, I agree that implicit @objc should be removed. I suspect it’s responsible for a nontrivial amount of code bloat and unnecessary Objective-C selector collisions.<br>&gt; <br>&gt;&gt; For bridged classes with obj-c-specific interfaces (for example a method that takes a selector), it would be better if the Swift-side interface was forced to make a Swifty interface that hides it. This way, the people maintaining an interface have to either a) write a wrapper with a Swifty interface; or b) explicitly cop out and use @objc and inform their users that they may also have to do the same in some situations; or c) persuade their employers to let them port the whole thing to pure Swift, which sounds like a lot of fun and is probably what they really want to do :D.<br>&gt; <br>&gt; I don’t quite view explicit @objc as a cop-out—it’s a useful tool to limit the amount of glue code one needs to write.<br>&gt; <br>&gt;&gt; I&#39;m not really sure how this works though, at what level this is applied? Maybe it&#39;s more to do with the default build settings in Xcode than Swift itself? I just would rather see Swift stand alone by default.<br>&gt; <br>&gt; I think it’s a Swift language change: we should only infer ‘@objc’ when the API<br>&gt; <br>&gt; 	* Overrides of an @objc API,<br>&gt; 	* Satisfies a requirement of an @objc protocol, or<br>&gt; 	* Uses a Swift feature that requires the Objective-C runtime (e.g., @NSManaged, @IBAction, currently ‘dynamic’ although that feels wrong to me)<br></p><p>It might also be nice if referring to a method with #selector automatically tried to make it @objc.<br></p><p>-Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161019/928be5f0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[pitch] make @nonobjc the default</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>October 19, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Oct 19, 2016, at 10:37 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Oct 19, 2016, at 9:35 AM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 19, 2016, at 4:53 AM, Jay Abbott &lt;jay at abbott.me.uk &lt;mailto:jay at abbott.me.uk&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Ok, good to know that&#39;s just a bug. But I still think that implicit @objc should be removed. <br>&gt;&gt; <br>&gt;&gt; Oh, I agree that implicit @objc should be removed. I suspect it’s responsible for a nontrivial amount of code bloat and unnecessary Objective-C selector collisions.<br>&gt;&gt; <br>&gt;&gt;&gt; For bridged classes with obj-c-specific interfaces (for example a method that takes a selector), it would be better if the Swift-side interface was forced to make a Swifty interface that hides it. This way, the people maintaining an interface have to either a) write a wrapper with a Swifty interface; or b) explicitly cop out and use @objc and inform their users that they may also have to do the same in some situations; or c) persuade their employers to let them port the whole thing to pure Swift, which sounds like a lot of fun and is probably what they really want to do :D.<br>&gt;&gt; <br>&gt;&gt; I don’t quite view explicit @objc as a cop-out—it’s a useful tool to limit the amount of glue code one needs to write.<br>&gt;&gt; <br>&gt;&gt;&gt; I&#39;m not really sure how this works though, at what level this is applied? Maybe it&#39;s more to do with the default build settings in Xcode than Swift itself? I just would rather see Swift stand alone by default.<br>&gt;&gt; <br>&gt;&gt; I think it’s a Swift language change: we should only infer ‘@objc’ when the API<br>&gt;&gt; <br>&gt;&gt; 	* Overrides of an @objc API,<br>&gt;&gt; 	* Satisfies a requirement of an @objc protocol, or<br>&gt;&gt; 	* Uses a Swift feature that requires the Objective-C runtime (e.g., @NSManaged, @IBAction, currently ‘dynamic’ although that feels wrong to me)<br>&gt; <br>&gt; It might also be nice if referring to a method with #selector automatically tried to make it @objc.<br></p><p>It might, although I don’t love the impact on the implementation: we either end up creating one-off categories associated with the references to non- at objc methods or our type checker has to process function bodies to answer the question “is this method exposed to Objective-C”?<br></p><p>	- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161019/e8f011ed/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[pitch] make @nonobjc the default</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>October 19, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Oct 19, 2016, at 10:53 AM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Oct 19, 2016, at 10:37 AM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Oct 19, 2016, at 9:35 AM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 19, 2016, at 4:53 AM, Jay Abbott &lt;jay at abbott.me.uk &lt;mailto:jay at abbott.me.uk&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Ok, good to know that&#39;s just a bug. But I still think that implicit @objc should be removed. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Oh, I agree that implicit @objc should be removed. I suspect it’s responsible for a nontrivial amount of code bloat and unnecessary Objective-C selector collisions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For bridged classes with obj-c-specific interfaces (for example a method that takes a selector), it would be better if the Swift-side interface was forced to make a Swifty interface that hides it. This way, the people maintaining an interface have to either a) write a wrapper with a Swifty interface; or b) explicitly cop out and use @objc and inform their users that they may also have to do the same in some situations; or c) persuade their employers to let them port the whole thing to pure Swift, which sounds like a lot of fun and is probably what they really want to do :D.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don’t quite view explicit @objc as a cop-out—it’s a useful tool to limit the amount of glue code one needs to write.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m not really sure how this works though, at what level this is applied? Maybe it&#39;s more to do with the default build settings in Xcode than Swift itself? I just would rather see Swift stand alone by default.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think it’s a Swift language change: we should only infer ‘@objc’ when the API<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	* Overrides of an @objc API,<br>&gt;&gt;&gt; 	* Satisfies a requirement of an @objc protocol, or<br>&gt;&gt;&gt; 	* Uses a Swift feature that requires the Objective-C runtime (e.g., @NSManaged, @IBAction, currently ‘dynamic’ although that feels wrong to me)<br>&gt;&gt; <br>&gt;&gt; It might also be nice if referring to a method with #selector automatically tried to make it @objc.<br>&gt; <br>&gt; It might, although I don’t love the impact on the implementation: we either end up creating one-off categories associated with the references to non- at objc methods or our type checker has to process function bodies to answer the question “is this method exposed to Objective-C”?<br></p><p>I don&#39;t think Sema necessarily needs to be involved. We could collect the full set of ObjC methods we need to emit for a class in a module and defer building a single category or class method table to IRGen time.<br></p><p>-Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161019/17253d2c/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[pitch] make @nonobjc the default</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>October 19, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Oct 19, 2016, at 12:37 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 19, 2016, at 9:35 AM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 19, 2016, at 4:53 AM, Jay Abbott &lt;jay at abbott.me.uk &lt;mailto:jay at abbott.me.uk&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Ok, good to know that&#39;s just a bug. But I still think that implicit @objc should be removed.<br>&gt;&gt; <br>&gt;&gt; Oh, I agree that implicit @objc should be removed. I suspect it’s responsible for a nontrivial amount of code bloat and unnecessary Objective-C selector collisions.<br>&gt;&gt; <br>&gt;&gt;&gt; For bridged classes with obj-c-specific interfaces (for example a method that takes a selector), it would be better if the Swift-side interface was forced to make a Swifty interface that hides it. This way, the people maintaining an interface have to either a) write a wrapper with a Swifty interface; or b) explicitly cop out and use @objc and inform their users that they may also have to do the same in some situations; or c) persuade their employers to let them port the whole thing to pure Swift, which sounds like a lot of fun and is probably what they really want to do :D.<br>&gt;&gt; <br>&gt;&gt; I don’t quite view explicit @objc as a cop-out—it’s a useful tool to limit the amount of glue code one needs to write.<br>&gt;&gt; <br>&gt;&gt;&gt; I&#39;m not really sure how this works though, at what level this is applied? Maybe it&#39;s more to do with the default build settings in Xcode than Swift itself? I just would rather see Swift stand alone by default.<br>&gt;&gt; <br>&gt;&gt; I think it’s a Swift language change: we should only infer ‘@objc’ when the API<br>&gt;&gt; <br>&gt;&gt; 	* Overrides of an @objc API,<br>&gt;&gt; 	* Satisfies a requirement of an @objc protocol, or<br>&gt;&gt; 	* Uses a Swift feature that requires the Objective-C runtime (e.g., @NSManaged, @IBAction, currently ‘dynamic’ although that feels wrong to me)<br>&gt; <br>&gt; It might also be nice if referring to a method with #selector automatically tried to make it @objc.<br></p><p>How would this work?  In all other cases it is clear that a method will become @objc at the declaration site.  In this case it would not be.<br></p><p>&gt; <br>&gt; -Joe<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161019/cb2eaa91/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[pitch] make @nonobjc the default</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>October 19, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Oct 19, 2016, at 11:24 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Oct 19, 2016, at 12:37 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 19, 2016, at 9:35 AM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 19, 2016, at 4:53 AM, Jay Abbott &lt;jay at abbott.me.uk &lt;mailto:jay at abbott.me.uk&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Ok, good to know that&#39;s just a bug. But I still think that implicit @objc should be removed. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Oh, I agree that implicit @objc should be removed. I suspect it’s responsible for a nontrivial amount of code bloat and unnecessary Objective-C selector collisions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For bridged classes with obj-c-specific interfaces (for example a method that takes a selector), it would be better if the Swift-side interface was forced to make a Swifty interface that hides it. This way, the people maintaining an interface have to either a) write a wrapper with a Swifty interface; or b) explicitly cop out and use @objc and inform their users that they may also have to do the same in some situations; or c) persuade their employers to let them port the whole thing to pure Swift, which sounds like a lot of fun and is probably what they really want to do :D.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don’t quite view explicit @objc as a cop-out—it’s a useful tool to limit the amount of glue code one needs to write.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m not really sure how this works though, at what level this is applied? Maybe it&#39;s more to do with the default build settings in Xcode than Swift itself? I just would rather see Swift stand alone by default.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think it’s a Swift language change: we should only infer ‘@objc’ when the API<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	* Overrides of an @objc API,<br>&gt;&gt;&gt; 	* Satisfies a requirement of an @objc protocol, or<br>&gt;&gt;&gt; 	* Uses a Swift feature that requires the Objective-C runtime (e.g., @NSManaged, @IBAction, currently ‘dynamic’ although that feels wrong to me)<br>&gt;&gt; <br>&gt;&gt; It might also be nice if referring to a method with #selector automatically tried to make it @objc.<br>&gt; <br>&gt; How would this work?  In all other cases it is clear that a method will become @objc at the declaration site.  In this case it would not be.<br></p><p>If we move to this on-demand model for @objc-ness, then it seems to me we can potentially get away from @objc having to be a thing. The constraints on being representable in ObjC can still be enforced by the operation that demands an ObjC method, whether that be an attribute on the declaration itself or an operation that references the declaration.<br></p><p>-Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161019/c3e9f3fd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[pitch] make @nonobjc the default</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>October 19, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Oct 19, 2016, at 1:26 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; If we move to this on-demand model for @objc-ness, then it seems to me we can potentially get away from @objc having to be a thing. The constraints on being representable in ObjC can still be enforced by the operation that demands an ObjC method, whether that be an attribute on the declaration itself or an operation that references the declaration.<br></p><p>Unless you’re making a library or a plugin or something that can’t completely know whether it’s being accessed by Objective-C clients.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161019/95b93e34/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
