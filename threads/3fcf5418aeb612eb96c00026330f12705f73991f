<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Draft] Expanded min/max algorithms</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April 19, 2016 at 11:00:00am</p></header><div class="content"><p>on Sat Apr 16 2016, Nate Cook &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hello all,<br>&gt;<br>&gt; Attached is a draft of a proposal to expand the min and max sequence APIs to<br>&gt; better handle collections and to support future sorted sequences/collections.<br>&gt; The proposal is in a gist here and inlined below—would love to hear any comments<br>&gt; or feedback before submitting the proposal.<br>&gt;<br>&gt; Nate<br>&gt;<br>&gt; Proposal: Expanded min/max algorithms<br>&gt;<br>&gt; This proposal would expand on the min() and max() sequence methods to add<br>&gt; methods that return the corresponding index for a collection, efficiently find<br>&gt; the minimum and maximum elements or indices at the same time, and provide<br>&gt; extension points for sorted collections to provide all these results more<br>&gt; efficiently.<br>&gt;<br>&gt; Related Bugs: SR-889 and SR-890<br>&gt;<br>&gt; Motivation<br>&gt;<br>&gt; The Sequence protocol currently offers min() and max() methods that return the<br>&gt; minimum and maximum elements of a sequence or collection. Unfortunately, there<br>&gt; are applications where these methods do not provide enough flexibility to be<br>&gt; useful.<br>&gt;<br>&gt; First, if the user of a collection wants not just to get the minimum value but<br>&gt; also to operate on it in some way (e.g., mutation or just accessing it multiple<br>&gt; times), she would need the index of the minimum element. The current APIs don&#39;t<br>&gt; support that, so she would need to write her own.<br>&gt;<br>&gt; Second, the writer of a sorted collection is currently unable to provide<br>&gt; efficient responses to the min() and max() methods when used in a generic<br>&gt; context, even though these should be O(1) operations. Just like Set can respond<br>&gt; quickly to contains(_:) even in a generic context, so too should new sorted<br>&gt; collections be able to optimize their responses.<br>&gt;<br>&gt; Finally, getting the minimum and maximum elements (or indices) of a collection<br>&gt; or sequence currently requires calling both min() and max(). With two calls,<br>&gt; every element is iterated and compared twice. When you need both results,<br>&gt; finding both the minimum and the maximum at the same time is more efficient,<br>&gt; requiring only a single pass and 25% fewer comparisons.<br>&gt;<br>&gt; Proposed solution<br>&gt;<br>&gt; This proposal has three parts:<br>&gt;<br>&gt; 1   Adding minIndex() and maxIndex() methods to Collection that return the index<br>&gt;   of the minimum and maximum elements, respectively.<br>&gt;<br>&gt;   let numbers = [30, 40, 10, 20, 60, 50]<br>&gt;<br>&gt; if let i = numbers.minIndex() {<br>&gt;     print(&quot;\(i): \(numbers[i])&quot;)               // 2: 10<br>&gt; }<br></p><p>Just with regard to naming, I don&#39;t think these work.  I read “minIndex”<br>as “the minimum index,” and since we expect all indices to be<br>comparable, that clearly implies c.minIndex() == c.startIndex.  I think<br>you&#39;d need “c.indexOfMin()”<br></p><p>I am also really reluctant to add specialized algorithms for things<br>that can be trivially composed out of existing parts, e.g.<br></p><p>     c.indices.min { c[$0] &lt; c[$1] }<br></p><p>Once we start down this road, we very quickly end up with mapValues,<br>mapKeys, indexOfMinimumKey, etc.<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Draft] Expanded min/max algorithms</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>April 19, 2016 at 10:00:00pm</p></header><div class="content"><p>Agree with notes about minIndex vs indexOfMin. Seems clear for me the later <br>should be chosen. We have .min() so it is naturally to have .indexOfMin<br></p><p>But I disagree on specialized algorithms. Can&#39;t understand, how custom-made <br>function with block with comparision is better than handful, clear and <br>explicit method. Btw, I feel your &quot;composition&quot; is not obvious on what is <br>going on from first look and if instance name is somethingDescriptive <br>you&#39;ll have very long expression instead of method with clear name and <br>obvious meaning.<br></p><p>What is wrong to have a set of useful and explicit methods for basic <br>operations on array, map, set etc?<br></p><p>On 19.04.2016 21:12, Dave Abrahams via swift-evolution wrote:<br>&gt; Just with regard to naming, I don&#39;t think these work.  I read “minIndex”<br>&gt; as “the minimum index,” and since we expect all indices to be<br>&gt; comparable, that clearly implies c.minIndex() == c.startIndex.  I think<br>&gt; you&#39;d need “c.indexOfMin()”<br>&gt;<br>&gt; I am also really reluctant to add specialized algorithms for things<br>&gt; that can be trivially composed out of existing parts, e.g.<br>&gt;<br>&gt;      c.indices.min { c[$0] &lt; c[$1] }<br>&gt;<br>&gt; Once we start down this road, we very quickly end up with mapValues,<br>&gt; mapKeys, indexOfMinimumKey, etc.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Draft] Expanded min/max algorithms</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April 19, 2016 at 03:00:00pm</p></header><div class="content"><p>on Tue Apr 19 2016, &quot;Vladimir.S&quot; &lt;svabox-AT-gmail.com&gt; wrote:<br></p><p>&gt; Agree with notes about minIndex vs indexOfMin. Seems clear for me the<br>&gt; later should be chosen. We have .min() so it is naturally to have<br>&gt; .indexOfMin<br>&gt;<br>&gt; But I disagree on specialized algorithms. Can&#39;t understand, how<br>&gt; custom-made function with block with comparision is better than<br>&gt; handful, clear and explicit method. <br></p><p>It&#39;s important, as a baseline, for the library to provide all the right<br>primitives that you can combine to easily get most jobs done.  After<br>that, the bar for expanding the API surface area gets much higher,<br>because greater API surface area means more complexity for users to<br>confront.  The usual criterion is, “is it hard to write (correctly and<br>performantly) yourself?”  I think this one fails that test.<br></p><p>&gt; Btw, I feel your &quot;composition&quot; is not obvious on what is going on from<br>&gt; first look and if instance name is somethingDescriptive you&#39;ll have<br>&gt; very long expression instead of method with clear name and obvious<br>&gt; meaning.<br>&gt;<br>&gt; What is wrong to have a set of useful and explicit methods for basic<br>&gt; operations on array, map, set etc?<br></p><p>Nothing at all, but there&#39;s a balance to be maintained between design<br>coherence, graspability of the whole API, convenience, and many other<br>factors.<br></p><p>&gt;<br>&gt;<br>&gt; On 19.04.2016 21:12, Dave Abrahams via swift-evolution wrote:<br>&gt;&gt; Just with regard to naming, I don&#39;t think these work.  I read “minIndex”<br>&gt;&gt; as “the minimum index,” and since we expect all indices to be<br>&gt;&gt; comparable, that clearly implies c.minIndex() == c.startIndex.  I think<br>&gt;&gt; you&#39;d need “c.indexOfMin()”<br>&gt;&gt;<br>&gt;&gt; I am also really reluctant to add specialized algorithms for things<br>&gt;&gt; that can be trivially composed out of existing parts, e.g.<br>&gt;&gt;<br>&gt;&gt;      c.indices.min { c[$0] &lt; c[$1] }<br>&gt;&gt;<br>&gt;&gt; Once we start down this road, we very quickly end up with mapValues,<br>&gt;&gt; mapKeys, indexOfMinimumKey, etc.<br></p><p>-- <br>Dave<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
