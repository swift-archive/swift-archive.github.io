<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>July  5, 2016 at 04:00:00pm</p></header><div class="content"><p>Hello Swift community,<br></p><p>The review of &quot;SE-0117: Default classes to be non-subclassable publicly&quot; begins now and runs through July 11. The proposal is available here:<br></p><p>	https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br></p><p>Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br></p><p>	https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>or, if you would like to keep your feedback private, directly to the review manager.<br></p><p>What goes into a review?<br></p><p>The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br></p><p>	* What is your evaluation of the proposal?<br>	* Is the problem being addressed significant enough to warrant a change to Swift?<br>	* Does this proposal fit well with the feel and direction of Swift?<br>	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>More information about the Swift evolution process is available at<br></p><p>	https://github.com/apple/swift-evolution/blob/master/process.md<br></p><p>Thank you,<br></p><p>-Chris Lattner<br>Review Manager<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>July  5, 2016 at 04:00:00pm</p></header><div class="content"><p>I&#39;ll bite.<br></p><p>On Tue, Jul 5, 2016 at 4:11 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt;         * What is your evaluation of the proposal?<br>&gt;<br></p><p>Strong +1. I like this proposal because it forces programmers vending a<br>public API to think about their extension points, and it also provides<br>guarantees to consumers of library and framework APIs as to whether the<br>framework developer intended for a particular class or member to serve as<br>an extension point. More controversially, I like it because it trades off<br>short-term subclass-based hacks in favor of a library ecosystem years down<br>the line that will be significantly higher in quality than it would<br>otherwise be - both because it&#39;ll be harder to write misbehaving code, and<br>because it&#39;ll support an emerging culture in which API design merits more<br>careful consideration than it would otherwise get.<br></p><p>I am largely unmoved by arguments involving Cocoa or misdesigned libraries:<br>Apple framework engineers will annotate their frameworks however they want<br>no matter what default we choose; the possibility of badly written code<br>would argue against things like access control, static typing, &#39;noescape&#39;<br>by default, the lack of swizzling, or any of a huge number of features that<br>could conceivably be used to patch misbehaving code. Developers working in<br>the Apple ecosystem can always fall back to Objective-C as an escape hatch<br>if they really need to monkey-patch Apple framework classes.<br></p><p>I have a question: one of the alternative syntaxes (&quot;public(subclassable)&quot;)<br>is listed as a potential candidate for expansion when resilience is<br>implemented. Is there a description of a potential resilience syntax for<br>the primary proposal?<br></p><p><br>&gt;         * Is the problem being addressed significant enough to warrant a<br>&gt; change to Swift?<br>&gt;<br></p><p>Yes.<br></p><p><br>&gt;         * Does this proposal fit well with the feel and direction of Swift?<br>&gt;<br></p><p>Most definitely. For example, making closures non-escaping by default fits<br>into the same model: expose only the most limited guarantees by default,<br>with easy discoverability of more powerful guarantees should a framework<br>author wish to use them. Another example is the raw pointer API proposal<br>currently in the works. In this context, &quot;limited&quot; is not a liability, it<br>is an asset: the more narrow the default semantics are, the easier it is<br>for users to reason about the correctness of their code, and the more<br>aggressively the compiler can optimize.<br></p><p>Indirectly, this proposal may also encourage framework authors to more<br>carefully consider whether classes or protocols are better suited as<br>extension points for their particular applications.<br></p><p><br>&gt;         * If you have used other languages or libraries with a similar<br>&gt; feature, how do you feel that this proposal compares to those?<br>&gt;<br></p><p>n/a<br></p><p><br>&gt;         * How much effort did you put into your review? A glance, a quick<br>&gt; reading, or an in-depth study?<br>&gt;<br></p><p>I read through the proposal carefully, and have read/participated in most<br>of the threads on the topic over the past few months.<br></p><p><br>&gt;<br>&gt; More information about the Swift evolution process is available at<br>&gt;<br>&gt;         https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;<br>&gt; Thank you,<br>&gt;<br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution-announce mailing list<br>&gt; swift-evolution-announce at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution-announce<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160705/a5f37714/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July  5, 2016 at 08:00:00pm</p></header><div class="content"><p>Extremely strong +1 from me on this proposal.  It is the best default for many, many reasons (stated in the proposal and in Austin&#39;s review).  It improves safety, facilitates and encourages reasoning about code, and will result in an ecosystem of overall higher quality.<br></p><p>Sent from my iPad<br></p><p>&gt; On Jul 5, 2016, at 6:49 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;ll bite.<br>&gt; <br>&gt;&gt; On Tue, Jul 5, 2016 at 4:11 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;         * What is your evaluation of the proposal?<br>&gt; <br>&gt; Strong +1. I like this proposal because it forces programmers vending a public API to think about their extension points, and it also provides guarantees to consumers of library and framework APIs as to whether the framework developer intended for a particular class or member to serve as an extension point. More controversially, I like it because it trades off short-term subclass-based hacks in favor of a library ecosystem years down the line that will be significantly higher in quality than it would otherwise be - both because it&#39;ll be harder to write misbehaving code, and because it&#39;ll support an emerging culture in which API design merits more careful consideration than it would otherwise get.<br>&gt; <br>&gt; I am largely unmoved by arguments involving Cocoa or misdesigned libraries: Apple framework engineers will annotate their frameworks however they want no matter what default we choose; the possibility of badly written code would argue against things like access control, static typing, &#39;noescape&#39; by default, the lack of swizzling, or any of a huge number of features that could conceivably be used to patch misbehaving code. Developers working in the Apple ecosystem can always fall back to Objective-C as an escape hatch if they really need to monkey-patch Apple framework classes.<br>&gt; <br>&gt; I have a question: one of the alternative syntaxes (&quot;public(subclassable)&quot;) is listed as a potential candidate for expansion when resilience is implemented. Is there a description of a potential resilience syntax for the primary proposal?<br>&gt;  <br>&gt;&gt;         * Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; <br>&gt; Yes.<br>&gt;  <br>&gt;&gt;         * Does this proposal fit well with the feel and direction of Swift?<br>&gt; <br>&gt; Most definitely. For example, making closures non-escaping by default fits into the same model: expose only the most limited guarantees by default, with easy discoverability of more powerful guarantees should a framework author wish to use them. Another example is the raw pointer API proposal currently in the works. In this context, &quot;limited&quot; is not a liability, it is an asset: the more narrow the default semantics are, the easier it is for users to reason about the correctness of their code, and the more aggressively the compiler can optimize.<br>&gt; <br>&gt; Indirectly, this proposal may also encourage framework authors to more carefully consider whether classes or protocols are better suited as extension points for their particular applications. <br>&gt;  <br>&gt;&gt;         * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; <br>&gt; n/a<br>&gt;  <br>&gt;&gt;         * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; I read through the proposal carefully, and have read/participated in most of the threads on the topic over the past few months.<br>&gt;  <br>&gt;&gt; <br>&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt; <br>&gt;&gt;         https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt; <br>&gt;&gt; Thank you,<br>&gt;&gt; <br>&gt;&gt; -Chris Lattner<br>&gt;&gt; Review Manager<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution-announce mailing list<br>&gt;&gt; swift-evolution-announce at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution-announce<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160705/df47d4ac/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cc80e78263eebbb13817a36ed5f3a701?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Nikita Leonov</string> &lt;nikita.leonov at gmail.com&gt;<p>July  5, 2016 at 05:00:00pm</p></header><div class="content"><p>+1 with modifications. In my team we write “final class” a lot. We also do have a lot of internal frameworks and an ability to guide external frameworks uses is important for us. We have a lot of candidates in our frameworks that should be inheritable internally, but we do not recommend to extend them outside of framework.<br></p><p>My biggest worry with this proposal is already highlighted in a section &quot;Modifier spelling alternatives”. Proposal introduces a set of new keywords to express relatively similar concept as current `final` keyword. We currently have already an ability to limit inheritance by use `final`, but we can not define a scope. However we also have keywords to define an accessibility scope:<br>* public — accessible everywhere<br>* internal — accessible within a module<br>* private — accessible within a file<br></p><p>For example, by leveraging existing keywords we can write code like following:<br>final(internal) class Foo {<br>  final(private) func bar() {<br>  }<br>} <br>So the class `Foo` is inheritable within a module, but method bar is overridable only within same file. <br>There is also optional `final(public)` that literally means no limitations on inheritance that can be used to indicate that class or method is `final(public)` on purpose by design. We use the similar approach in our code base with `internal`, while it is default keyword for classes and functions we still write it to show that it is internal by design and no public / private keyword missing.<br></p><p>Also with suggestion above we can default `final` to `final(private)`to keep backwards compatibility. <br></p><p>Best,<br>Nikita Leonov<br></p><p>&gt; On Jul 5, 2016, at 4:11 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;SE-0117: Default classes to be non-subclassable publicly&quot; begins now and runs through July 11. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution-announce mailing list<br>&gt; swift-evolution-announce at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution-announce<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bab03b11d4cd60804cf4a6ba68589430?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Kevin Lundberg</string> &lt;kevin at klundberg.com&gt;<p>July  5, 2016 at 08:00:00pm</p></header><div class="content"><p>* What is your evaluation of the proposal?<br></p><p>-1 as is. I do not want to be constrained by authors of libraries or<br>frameworks into interacting with a system in only the ways they forsee.<br>By making the default be non-subclassable, if a designer does not put<br>thought into all the ways a class can be used then I as a consumer of<br>the library am penalized.<br></p><p>Another point I can think of is mocking in tests. I&#39;m unaware of any<br>fully featured mocking solution in swift, and subclassing a class to<br>override methods for mocking purposes is one way to make unit tests work<br>with third party dependencies. If a class was not designed for<br>subclassing, then writing tests where the class&#39;s behavior needs to be<br>suppressed would not be possible. One could write a facade between the<br>system under test and the dependency, but if the dependency is only used<br>in a one or a few places then that becomes a lot of extra boilerplate<br>code to write, especially if that process needed to happen many times.<br></p><p>I understand the value of this behavior though, and I would prefer that<br>this behavior becomes opt-in instead of opt-out. One possible<br>illustration (not meant as definitive syntax):<br></p><p>public(final) class Thing {}<br>public(final) func doSomething() {}<br></p><p>where the symbols are publicly final, but lesser access scopes are open.<br></p><p><br>* Is the problem being addressed significant enough to warrant a change<br>to Swift?<br></p><p>Some change here would be welcome, but as I said I think the inverse<br>situation is a better solution.<br></p><p>* Does this proposal fit well with the feel and direction of Swift?<br></p><p>It partially does, as giving developers tools to protect things they know are critical or sensitive is a good idea, but it should not come at the cost of a client&#39;s freedom to use a library in ways that fall outside of the original predictions of the author.<br></p><p><br>* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>The main other language I&#39;ve used is C# that does this at the method<br>level (where overridable methods must be marked with the `virtual`<br>keyword).<br></p><p>I&#39;ve had issues before when working with third party C# code where the<br>author didn&#39;t declare a method as virtual, but the problem I was trying<br>to solve required me to override that method. Luckily the code was open<br>source, so I just embedded and edited the source into my project instead<br>of using the prebuilt binaries, but that becomes a maintenance headache,<br>and it is not possible for components that do not make the source available.<br></p><p><br>* How much effort did you put into your review? A glance, a quick<br>reading, or an in-depth study?<br></p><p>In depth study, and some participation on some of the initial threads<br>about this topic.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>July  5, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Jul 5, 2016, at 5:54 PM, Kevin Lundberg via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; * What is your evaluation of the proposal?<br>&gt; <br>&gt; -1 as is. I do not want to be constrained by authors of libraries or<br>&gt; frameworks into interacting with a system in only the ways they forsee.<br>&gt; By making the default be non-subclassable, if a designer does not put<br>&gt; thought into all the ways a class can be used then I as a consumer of<br>&gt; the library am penalized.<br></p><p>Out of curiosity, what is your feeling about “internal” as the default level of access control?  It seems that following your concern to its logical conclusion would lead to a design where all members of a public class would be forced to be public.  After all, the author of a library or framework may not forsee the need to interact with a member that they did not explicitly mark public.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>July  6, 2016 at 07:00:00pm</p></header><div class="content"><p>Regards<br>LM<br>(From mobile)<br></p><p>&gt; On Jul 6, 2016, at 7:52 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 5, 2016, at 5:54 PM, Kevin Lundberg via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; * What is your evaluation of the proposal?<br>&gt;&gt; <br>&gt;&gt; -1 as is. I do not want to be constrained by authors of libraries or<br>&gt;&gt; frameworks into interacting with a system in only the ways they forsee.<br>&gt;&gt; By making the default be non-subclassable, if a designer does not put<br>&gt;&gt; thought into all the ways a class can be used then I as a consumer of<br>&gt;&gt; the library am penalized.<br>&gt; <br>&gt; Out of curiosity, what is your feeling about “internal” as the default level of access control?  It seems that following your concern to its logical conclusion would lead to a design where all members of a public class would be forced to be public.  After all, the author of a library or framework may not forsee the need to interact with a member that they did not explicitly mark public<br></p><p>Can&#39;t really help for feel like it is training wheels all around... or padlocks on every kitchen cupboards. What if this had been the philosophy from swift 0.1, what would the ecosystem look like today? (genuine question to which I do not have the answer)<br></p><p>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bab03b11d4cd60804cf4a6ba68589430?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Kevin Lundberg</string> &lt;kevin at klundberg.com&gt;<p>July  6, 2016 at 09:00:00pm</p></header><div class="content"><p>On 7/6/2016 1:52 AM, Chris Lattner wrote:<br></p><p>&gt;&gt; On Jul 5, 2016, at 5:54 PM, Kevin Lundberg via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; * What is your evaluation of the proposal?<br>&gt;&gt;<br>&gt;&gt; -1 as is. I do not want to be constrained by authors of libraries or<br>&gt;&gt; frameworks into interacting with a system in only the ways they forsee.<br>&gt;&gt; By making the default be non-subclassable, if a designer does not put<br>&gt;&gt; thought into all the ways a class can be used then I as a consumer of<br>&gt;&gt; the library am penalized.<br>&gt; Out of curiosity, what is your feeling about “internal” as the default level of access control?  It seems that following your concern to its logical conclusion would lead to a design where all members of a public class would be forced to be public.  After all, the author of a library or framework may not forsee the need to interact with a member that they did not explicitly mark public.<br>&gt;<br>&gt; -Chris<br></p><p>I can appreciate this argument, but I would hope that my viewpoint is a<br>bit more nuanced than that :). To turn the tables a bit, one could argue<br>that, taken to the proposal&#39;s logical conclusion, writable properties<br>should not be publicly writable for safety&#39;s sake. Instead, they should<br>be required to be explicitly marked as publicly settable if needed as it<br>should be up to the author of that type to carefully consider how safe<br>it is for others to mutate the state of their types. Yet today both<br>sides of a property are given the same access level unless one<br>explicitly restricts the visibility of it&#39;s setter. The current behavior<br>(of properties specifically, and the access control feature as a whole)<br>achieves a balance of convenience, power, and safety that I am happy with.<br></p><p>The proposed change however sacrifices too much convenience for a<br>greater sense of safety and control by default. It&#39;s not possible to<br>accidentally override a method like it is in java or objective-c, so the<br>proposal won&#39;t help people who might accidentally override something. If<br>a developer tries to override a method or class they probably have a<br>specific reason in mind for doing so, and taking away the options that<br>this ability presents, by nature of it being the default behavior,<br>doesn&#39;t sit well with me as it has the potential to take away a good<br>tool from my toolbox.<br></p><p>I agree that API authors should have the power to restrict this<br>dimension of a type&#39;s usage, but I feel that it should be a conscious<br>choice to do so.<br></p><p>- Kevin<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>July  5, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; 	* What is your evaluation of the proposal?<br></p><p>I think it&#39;s ultimately a good idea. Being noncommittal about subclassability/overridability—and thus forbidding it in public scope, but not making any promises about what the module does internally—is the alternative that preserves the most freedom for the module, and therefore the most appropriate default.<br></p><p>However, I don&#39;t like the `subclassable` and `overridable` keywords. They read like opposites of `final` with no implications for access level; I could easily imagine somebody marking an internal class `subclassable` assuming that it merely means it can be subclassed internally, and being very surprised (or even not noticing!) that the class has been made public. They&#39;re also long and cumbersome; that might be seen as a positive, but I think it will increase the inevitable backlash against this change.<br></p><p>I prefer the keyword `open`, which sounds like it could be a statement about the item&#39;s accessibility—and even sounds like it ought to be &quot;more public than public&quot;—and is short enough that it ought to be difficult to grumble about the change. It also means that both classes and members use the same keyword, and gives us a keyword that we can later use to &quot;open&quot; other things in the language, such as allowing you to extend enums with new cases.<br></p><p>I think Kevin Lundberg is right to worry about testability, but I don&#39;t think that has to prevent this change. Instead, we should permit `@testable` imports to subclass/override things that are not publicly subclassable/overridable, and thus a module built with &quot;Enable Testability&quot; on can&#39;t actually assume there are no subclasses/overrides of `internal` classes/members even if it doesn&#39;t see any. This will block optimizations in debug builds, but not in release builds. The proposal should be edited to explain this `@testable` behavior.<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes.<br></p><p>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>I don&#39;t think I have.<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>Quick reading of the final proposal, but I also contributed to previous discussion.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>July  5, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jul 5, 2016, at 6:45 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt; <br>&gt; I think it&#39;s ultimately a good idea. Being noncommittal about subclassability/overridability—and thus forbidding it in public scope, but not making any promises about what the module does internally—is the alternative that preserves the most freedom for the module, and therefore the most appropriate default.<br>&gt; <br>&gt; However, I don&#39;t like the `subclassable` and `overridable` keywords. They read like opposites of `final` with no implications for access level; I could easily imagine somebody marking an internal class `subclassable` assuming that it merely means it can be subclassed internally, and being very surprised (or even not noticing!) that the class has been made public. They&#39;re also long and cumbersome; that might be seen as a positive, but I think it will increase the inevitable backlash against this change.<br>&gt; <br>&gt; I prefer the keyword `open`, which sounds like it could be a statement about the item&#39;s accessibility—and even sounds like it ought to be &quot;more public than public&quot;—and is short enough that it ought to be difficult to grumble about the change. It also means that both classes and members use the same keyword, and gives us a keyword that we can later use to &quot;open&quot; other things in the language, such as allowing you to extend enums with new cases.<br></p><p>Agreed; I also prefer &quot;open&quot; to having two different long keywords that don&#39;t (at least to my ear) imply &quot;public&quot;.<br></p><p>&gt; I think Kevin Lundberg is right to worry about testability, but I don&#39;t think that has to prevent this change. Instead, we should permit `@testable` imports to subclass/override things that are not publicly subclassable/overridable, and thus a module built with &quot;Enable Testability&quot; on can&#39;t actually assume there are no subclasses/overrides of `internal` classes/members even if it doesn&#39;t see any. This will block optimizations in debug builds, but not in release builds. The proposal should be edited to explain this `@testable` behavior.<br></p><p>IIUC the basic design of @testable is to treat the tests for the testable thing as existing within its module, so I think this just falls out.  I agree that it should be spelled out in the proposal, though.<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July  5, 2016 at 08:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jul 5, 2016, at 8:53 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Jul 5, 2016, at 6:45 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    * What is your evaluation of the proposal?<br>&gt;&gt; <br>&gt;&gt; I think it&#39;s ultimately a good idea. Being noncommittal about subclassability/overridability—and thus forbidding it in public scope, but not making any promises about what the module does internally—is the alternative that preserves the most freedom for the module, and therefore the most appropriate default.<br>&gt;&gt; <br>&gt;&gt; However, I don&#39;t like the `subclassable` and `overridable` keywords. They read like opposites of `final` with no implications for access level; I could easily imagine somebody marking an internal class `subclassable` assuming that it merely means it can be subclassed internally, and being very surprised (or even not noticing!) that the class has been made public. They&#39;re also long and cumbersome; that might be seen as a positive, but I think it will increase the inevitable backlash against this change.<br>&gt;&gt; <br>&gt;&gt; I prefer the keyword `open`, which sounds like it could be a statement about the item&#39;s accessibility—and even sounds like it ought to be &quot;more public than public&quot;—and is short enough that it ought to be difficult to grumble about the change. It also means that both classes and members use the same keyword, and gives us a keyword that we can later use to &quot;open&quot; other things in the language, such as allowing you to extend enums with new cases.<br>&gt; <br>&gt; Agreed; I also prefer &quot;open&quot; to having two different long keywords that don&#39;t (at least to my ear) imply &quot;public&quot;.<br></p><p>+1.  I agree that the keywords in the proposal don&#39;t feel like they imply public and do feel like they might be required even internally, a really unfortunate combination.<br></p><p>&gt; <br>&gt;&gt; I think Kevin Lundberg is right to worry about testability, but I don&#39;t think that has to prevent this change. Instead, we should permit `@testable` imports to subclass/override things that are not publicly subclassable/overridable, and thus a module built with &quot;Enable Testability&quot; on can&#39;t actually assume there are no subclasses/overrides of `internal` classes/members even if it doesn&#39;t see any. This will block optimizations in debug builds, but not in release builds. The proposal should be edited to explain this `@testable` behavior.<br>&gt; <br>&gt; IIUC the basic design of @testable is to treat the tests for the testable thing as existing within its module, so I think this just falls out.  I agree that it should be spelled out in the proposal, though.<br>&gt; <br>&gt; John.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bab03b11d4cd60804cf4a6ba68589430?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Kevin Lundberg</string> &lt;kevin at klundberg.com&gt;<p>July  6, 2016 at 12:00:00am</p></header><div class="content"><p>I hadn&#39;t considered @testable, and it may be one way to mitigate the<br>trouble this could cause in tests, so thank you both for bringing it up<br>as the proposal should definitely account for it. I&#39;m curious though how<br>this would solve the case of trying to subclass a module&#39;s class in a<br>test where you don&#39;t have the source? If you don&#39;t have control over the<br>source, you can&#39;t rebuild it to enable testability, and it might even be<br>desirable for someone to refuse to distribute a binary with testability<br>enabled if doing so might reveal proprietary information or lead to a<br>possible security problem with their library.<br></p><p><br>On 7/5/2016 9:53 PM, John McCall via swift-evolution wrote:<br>&gt;&gt; On Jul 5, 2016, at 6:45 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt;&gt; I think it&#39;s ultimately a good idea. Being noncommittal about subclassability/overridability—and thus forbidding it in public scope, but not making any promises about what the module does internally—is the alternative that preserves the most freedom for the module, and therefore the most appropriate default.<br>&gt;&gt;<br>&gt;&gt; However, I don&#39;t like the `subclassable` and `overridable` keywords. They read like opposites of `final` with no implications for access level; I could easily imagine somebody marking an internal class `subclassable` assuming that it merely means it can be subclassed internally, and being very surprised (or even not noticing!) that the class has been made public. They&#39;re also long and cumbersome; that might be seen as a positive, but I think it will increase the inevitable backlash against this change.<br>&gt;&gt;<br>&gt;&gt; I prefer the keyword `open`, which sounds like it could be a statement about the item&#39;s accessibility—and even sounds like it ought to be &quot;more public than public&quot;—and is short enough that it ought to be difficult to grumble about the change. It also means that both classes and members use the same keyword, and gives us a keyword that we can later use to &quot;open&quot; other things in the language, such as allowing you to extend enums with new cases.<br>&gt; Agreed; I also prefer &quot;open&quot; to having two different long keywords that don&#39;t (at least to my ear) imply &quot;public&quot;.<br>&gt;<br>&gt;&gt; I think Kevin Lundberg is right to worry about testability, but I don&#39;t think that has to prevent this change. Instead, we should permit `@testable` imports to subclass/override things that are not publicly subclassable/overridable, and thus a module built with &quot;Enable Testability&quot; on can&#39;t actually assume there are no subclasses/overrides of `internal` classes/members even if it doesn&#39;t see any. This will block optimizations in debug builds, but not in release builds. The proposal should be edited to explain this `@testable` behavior.<br>&gt; IIUC the basic design of @testable is to treat the tests for the testable thing as existing within its module, so I think this just falls out.  I agree that it should be spelled out in the proposal, though.<br>&gt;<br>&gt; John.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>July  6, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jul 5, 2016, at 9:11 PM, Kevin Lundberg &lt;kevin at klundberg.com&gt; wrote:<br>&gt; <br>&gt; I hadn&#39;t considered @testable, and it may be one way to mitigate the<br>&gt; trouble this could cause in tests, so thank you both for bringing it up<br>&gt; as the proposal should definitely account for it. I&#39;m curious though how<br>&gt; this would solve the case of trying to subclass a module&#39;s class in a<br>&gt; test where you don&#39;t have the source? If you don&#39;t have control over the<br>&gt; source, you can&#39;t rebuild it to enable testability, and it might even be<br>&gt; desirable for someone to refuse to distribute a binary with testability<br>&gt; enabled if doing so might reveal proprietary information or lead to a<br>&gt; possible security problem with their library.<br></p><p>Our testing design is only intended to allow first-party tests to break the<br>normal access restrictions.  It seems to me that other tests should be<br>treating their external dependencies as black boxes and use their normal API.<br></p><p>John.<br></p><p>&gt; <br>&gt; <br>&gt; On 7/5/2016 9:53 PM, John McCall via swift-evolution wrote:<br>&gt;&gt;&gt; On Jul 5, 2016, at 6:45 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt;&gt;&gt; I think it&#39;s ultimately a good idea. Being noncommittal about subclassability/overridability—and thus forbidding it in public scope, but not making any promises about what the module does internally—is the alternative that preserves the most freedom for the module, and therefore the most appropriate default.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; However, I don&#39;t like the `subclassable` and `overridable` keywords. They read like opposites of `final` with no implications for access level; I could easily imagine somebody marking an internal class `subclassable` assuming that it merely means it can be subclassed internally, and being very surprised (or even not noticing!) that the class has been made public. They&#39;re also long and cumbersome; that might be seen as a positive, but I think it will increase the inevitable backlash against this change.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I prefer the keyword `open`, which sounds like it could be a statement about the item&#39;s accessibility—and even sounds like it ought to be &quot;more public than public&quot;—and is short enough that it ought to be difficult to grumble about the change. It also means that both classes and members use the same keyword, and gives us a keyword that we can later use to &quot;open&quot; other things in the language, such as allowing you to extend enums with new cases.<br>&gt;&gt; Agreed; I also prefer &quot;open&quot; to having two different long keywords that don&#39;t (at least to my ear) imply &quot;public&quot;.<br>&gt;&gt; <br>&gt;&gt;&gt; I think Kevin Lundberg is right to worry about testability, but I don&#39;t think that has to prevent this change. Instead, we should permit `@testable` imports to subclass/override things that are not publicly subclassable/overridable, and thus a module built with &quot;Enable Testability&quot; on can&#39;t actually assume there are no subclasses/overrides of `internal` classes/members even if it doesn&#39;t see any. This will block optimizations in debug builds, but not in release builds. The proposal should be edited to explain this `@testable` behavior.<br>&gt;&gt; IIUC the basic design of @testable is to treat the tests for the testable thing as existing within its module, so I think this just falls out.  I agree that it should be spelled out in the proposal, though.<br>&gt;&gt; <br>&gt;&gt; John.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>July  5, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Jul 5, 2016, at 6:53 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; I think Kevin Lundberg is right to worry about testability, but I don&#39;t think that has to prevent this change. Instead, we should permit `@testable` imports to subclass/override things that are not publicly subclassable/overridable, and thus a module built with &quot;Enable Testability&quot; on can&#39;t actually assume there are no subclasses/overrides of `internal` classes/members even if it doesn&#39;t see any. This will block optimizations in debug builds, but not in release builds. The proposal should be edited to explain this `@testable` behavior.<br>&gt; <br>&gt; IIUC the basic design of @testable is to treat the tests for the testable thing as existing within its module, so I think this just falls out.  I agree that it should be spelled out in the proposal, though.<br></p><p>That makes sense to me.  Please explicitly add that to the proposal, thank you!<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>July  6, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jul 5, 2016, at 10:56 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt; On Jul 5, 2016, at 6:53 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think Kevin Lundberg is right to worry about testability, but I don&#39;t think that has to prevent this change. Instead, we should permit `@testable` imports to subclass/override things that are not publicly subclassable/overridable, and thus a module built with &quot;Enable Testability&quot; on can&#39;t actually assume there are no subclasses/overrides of `internal` classes/members even if it doesn&#39;t see any. This will block optimizations in debug builds, but not in release builds. The proposal should be edited to explain this `@testable` behavior.<br>&gt;&gt; <br>&gt;&gt; IIUC the basic design of @testable is to treat the tests for the testable thing as existing within its module, so I think this just falls out.  I agree that it should be spelled out in the proposal, though.<br>&gt; <br>&gt; That makes sense to me.  Please explicitly add that to the proposal, thank you!<br></p><p>Done.<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>July  8, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jul 6, 2016, at 09:16, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Jul 5, 2016, at 10:56 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt;&gt; On Jul 5, 2016, at 6:53 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think Kevin Lundberg is right to worry about testability, but I don&#39;t think that has to prevent this change. Instead, we should permit `@testable` imports to subclass/override things that are not publicly subclassable/overridable, and thus a module built with &quot;Enable Testability&quot; on can&#39;t actually assume there are no subclasses/overrides of `internal` classes/members even if it doesn&#39;t see any. This will block optimizations in debug builds, but not in release builds. The proposal should be edited to explain this `@testable` behavior.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; IIUC the basic design of @testable is to treat the tests for the testable thing as existing within its module, so I think this just falls out.  I agree that it should be spelled out in the proposal, though.<br>&gt;&gt; <br>&gt;&gt; That makes sense to me.  Please explicitly add that to the proposal, thank you!<br>&gt; <br>&gt; Done.<br></p><p>This really isn’t the model for @testable, as evidenced by the fact that top-level names in the testing module still shadow names from the imported module, and that you can refer to the name fully-qualified. Instead, the model is that @testable makes ‘internal&#39; things ‘public&#39;. I think this would make them ‘subclassable’/‘overridable’/‘open’ instead where relevant.<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160708/b4a525eb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>July 11, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jul 8, 2016, at 8:41 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;&gt; On Jul 6, 2016, at 09:16, John McCall via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 5, 2016, at 10:56 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; On Jul 5, 2016, at 6:53 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think Kevin Lundberg is right to worry about testability, but I don&#39;t think that has to prevent this change. Instead, we should permit `@testable` imports to subclass/override things that are not publicly subclassable/overridable, and thus a module built with &quot;Enable Testability&quot; on can&#39;t actually assume there are no subclasses/overrides of `internal` classes/members even if it doesn&#39;t see any. This will block optimizations in debug builds, but not in release builds. The proposal should be edited to explain this `@testable` behavior.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; IIUC the basic design of @testable is to treat the tests for the testable thing as existing within its module, so I think this just falls out.  I agree that it should be spelled out in the proposal, though.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That makes sense to me.  Please explicitly add that to the proposal, thank you!<br>&gt;&gt; <br>&gt;&gt; Done.<br>&gt; <br>&gt; This really isn’t the model for @testable, as evidenced by the fact that top-level names in the testing module still shadow names from the imported module, and that you can refer to the name fully-qualified. Instead, the model is that @testable makes ‘internal&#39; things ‘public&#39;. I think this would make them ‘subclassable’/‘overridable’/‘open’ instead where relevant.<br></p><p>Right, sorry, I mis-spoke.  The intent of @testable is to allow tests to have special privileges as if they were part of the same module, but of course it doesn&#39;t actually make them part of the same module, and there any number of lookup / redeclaration differences.<br></p><p>Still, we&#39;re agreed on how that principle applies here:  tests should be able to subclass / override things arbitrarily from the things they @testably import.<br></p><p>John.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/34211eb9/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>July  6, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jul 5, 2016, at 8:45 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I think Kevin Lundberg is right to worry about testability, but I don&#39;t think that has to prevent this change. Instead, we should permit `@testable` imports to subclass/override things that are not publicly subclassable/overridable, and thus a module built with &quot;Enable Testability&quot; on can&#39;t actually assume there are no subclasses/overrides of `internal` classes/members even if it doesn&#39;t see any.<br></p><p>+1 to this. To me, @testable means “import as if it were internal to this module.”<br></p><p>P<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>July  6, 2016 at 04:00:00am</p></header><div class="content"><p>&gt; On 6 Jul 2016, at 01:11, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;SE-0117: Default classes to be non-subclassable publicly&quot; begins now and runs through July 11. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt; ...<br>&gt; 	* What is your evaluation of the proposal?<br></p><p>+1. I really enjoy designing elegant, well-defined APIs and this behaviour for classes has bothered me for some time.<br></p><p>On the other hand, I have also subclassed things that weren’t meant to be subclassed (e.g. I believe UITabBar was an awkward one back in the day, and UINavigationController has so many broken behaviours it’s almost a requirement to subclass and patch it, even though I believe Apple disapproves). I could fall back to Objective-C, but that’s an implementation detail. In some theoretical future with an all-Swift UIKit, what do I do about those issues?<br></p><p>After thinking about it, I decided that in this theoretical future, no App would be able to use those hacks, and so all Apps would have the same broken behaviours and degrade the quality of the platform to such an extent that Apple is forced to do something about it. Ultimately, that’s exactly what we want; they need to see broken Apps everywhere in order to prioritise fixes. That improves code quality all-around.<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yup<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yup, but I don’t like “subclassable class”. My preferences are:<br></p><p>#1 - “extendable class”    // explicitly clear about what I’m allowing<br>#2 - “open class”             // this is a bit vague - open how? How is it different from public?<br></p><p><br>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>I prefer this over “sealed”. Making classes extendable requires careful consideration, and should be explicit.<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I read through it a few times, and also the discussion last week. The problem has bugged me for a long time, and this is a pretty straightforward solution that integrates well with Swift (providing the keyword changes =] )<br></p><p>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br></p><p>My pleasure!<br></p><p>Karl<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>July  5, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jul 5, 2016, at 7:16 PM, Karl via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; #1 - “extendable class”    // explicitly clear about what I’m allowing<br></p><p>The problem is that it&#39;s very clear about what you&#39;re allowing—you&#39;re allowing `extension`s. Which of course isn&#39;t *actually* what you&#39;re allowing.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>July  6, 2016 at 07:00:00am</p></header><div class="content"><p>Huge +1.<br></p><p>Question about inheritance though:<br></p><p>class A {} // Not publicly subclassable <br>subclassable class B: A {} // Publicly subclassable<br>class C: B {} // Not publicly subclassable? Or is the subclassability inherited? <br></p><p>I&#39;m not a big fan of the subclassable keyword either since it&#39;s quite long, not to mention it contains &quot;class&quot; which is the next keyword, making it visually repetitive.<br></p><p>I&#39;d prefer open on both class and func to introduce only one keyword instead of two and possibly make it as a modifier of public to keep it in line with private(set)...<br></p><p>&gt; On Jul 6, 2016, at 1:11 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;SE-0117: Default classes to be non-subclassable publicly&quot; begins now and runs through July 11. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fb40b031ffdd8f92686a2a4f4caf0c68?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Guillermo Peralta Scura</string> &lt;gperaltascura at gmail.com&gt;<p>July  6, 2016 at 05:00:00am</p></header><div class="content"><p>+1. I&#39;d prefer the &quot;open&quot; keyword though, and use it as a modifier of<br>public.<br></p><p>El mié., 6 jul. 2016 a las 1:24, Charlie Monroe via swift-evolution (&lt;<br>swift-evolution at swift.org&gt;) escribió:<br></p><p>&gt; Huge +1.<br>&gt;<br>&gt; Question about inheritance though:<br>&gt;<br>&gt; class A {} // Not publicly subclassable<br>&gt; subclassable class B: A {} // Publicly subclassable<br>&gt; class C: B {} // Not publicly subclassable? Or is the subclassability<br>&gt; inherited?<br>&gt;<br>&gt; I&#39;m not a big fan of the subclassable keyword either since it&#39;s quite<br>&gt; long, not to mention it contains &quot;class&quot; which is the next keyword, making<br>&gt; it visually repetitive.<br>&gt;<br>&gt; I&#39;d prefer open on both class and func to introduce only one keyword<br>&gt; instead of two and possibly make it as a modifier of public to keep it in<br>&gt; line with private(set)...<br>&gt;<br>&gt; &gt; On Jul 6, 2016, at 1:11 AM, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Hello Swift community,<br>&gt; &gt;<br>&gt; &gt; The review of &quot;SE-0117: Default classes to be non-subclassable publicly&quot;<br>&gt; begins now and runs through July 11. The proposal is available here:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt; &gt;<br>&gt; &gt; Reviews are an important part of the Swift evolution process. All<br>&gt; reviews should be sent to the swift-evolution mailing list at<br>&gt; &gt;<br>&gt; &gt;       https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt; or, if you would like to keep your feedback private, directly to the<br>&gt; review manager.<br>&gt; &gt;<br>&gt; &gt; What goes into a review?<br>&gt; &gt;<br>&gt; &gt; The goal of the review process is to improve the proposal under review<br>&gt; through constructive criticism and contribute to the direction of Swift.<br>&gt; When writing your review, here are some questions you might want to answer<br>&gt; in your review:<br>&gt; &gt;<br>&gt; &gt;       * What is your evaluation of the proposal?<br>&gt; &gt;       * Is the problem being addressed significant enough to warrant a<br>&gt; change to Swift?<br>&gt; &gt;       * Does this proposal fit well with the feel and direction of Swift?<br>&gt; &gt;       * If you have used other languages or libraries with a similar<br>&gt; feature, how do you feel that this proposal compares to those?<br>&gt; &gt;       * How much effort did you put into your review? A glance, a quick<br>&gt; reading, or an in-depth study?<br>&gt; &gt;<br>&gt; &gt; More information about the Swift evolution process is available at<br>&gt; &gt;<br>&gt; &gt;       https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; &gt;<br>&gt; &gt; Thank you,<br>&gt; &gt;<br>&gt; &gt; -Chris Lattner<br>&gt; &gt; Review Manager<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160706/2cda71e0/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July  6, 2016 at 06:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jul 6, 2016, at 12:24 AM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Huge +1.<br>&gt; <br>&gt; Question about inheritance though:<br>&gt; <br>&gt; class A {} // Not publicly subclassable <br>&gt; subclassable class B: A {} // Publicly subclassable<br>&gt; class C: B {} // Not publicly subclassable? Or is the subclassability inherited? <br></p><p>This is a great question.  There are really two questions: <br></p><p>Can B be marked &quot;subclassable&quot; even though its superclass isn&#39;t?  Allowing this allows creation of new classes with A as an ancestor.  Since this is explicitly opt-in all within the same module I&#39;m inclined to say we should allow it.  <br></p><p>Is subclassability inherited by in-module subclasses?  This seems to me opposed to the spirit of closed by default.  I think it is better to require annotation on *every* class an method that is open to extension outside the module, regardless of what choice a superclass makes,<br></p><p>This gives module authors the most control over *exactly* which classes can be used as superclasses outside the module (A and C don&#39;t need to be subclassable just because B needs to be.<br></p><p>-Matthew<br></p><p>&gt; <br>&gt; I&#39;m not a big fan of the subclassable keyword either since it&#39;s quite long, not to mention it contains &quot;class&quot; which is the next keyword, making it visually repetitive.<br>&gt; <br>&gt; I&#39;d prefer open on both class and func to introduce only one keyword instead of two and possibly make it as a modifier of public to keep it in line with private(set)...<br>&gt; <br>&gt;&gt; On Jul 6, 2016, at 1:11 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello Swift community,<br>&gt;&gt; <br>&gt;&gt; The review of &quot;SE-0117: Default classes to be non-subclassable publicly&quot; begins now and runs through July 11. The proposal is available here:<br>&gt;&gt; <br>&gt;&gt;    https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt;&gt; <br>&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt; <br>&gt;&gt;    https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt;&gt; <br>&gt;&gt; What goes into a review?<br>&gt;&gt; <br>&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt; <br>&gt;&gt;    * What is your evaluation of the proposal?<br>&gt;&gt;    * Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt;    * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;    * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt;    * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt; <br>&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt; <br>&gt;&gt;    https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt; <br>&gt;&gt; Thank you,<br>&gt;&gt; <br>&gt;&gt; -Chris Lattner<br>&gt;&gt; Review Manager<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>July 10, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; Am 06.07.2016 um 13:39 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt;&gt; On Jul 6, 2016, at 12:24 AM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Huge +1.<br>&gt;&gt; <br>&gt;&gt; Question about inheritance though:<br>&gt;&gt; <br>&gt;&gt; class A {} // Not publicly subclassable <br>&gt;&gt; subclassable class B: A {} // Publicly subclassable<br>&gt;&gt; class C: B {} // Not publicly subclassable? Or is the subclassability inherited?<br>&gt; <br>&gt; This is a great question.  There are really two questions: <br>&gt; <br>&gt; Can B be marked &quot;subclassable&quot; even though its superclass isn&#39;t?  Allowing this allows creation of new classes with A as an ancestor.  Since this is explicitly opt-in all within the same module I&#39;m inclined to say we should allow it.  <br>&gt; <br>&gt; Is subclassability inherited by in-module subclasses?  This seems to me opposed to the spirit of closed by default.  I think it is better to require annotation on *every* class an method that is open to extension outside the module, regardless of what choice a superclass makes,<br>&gt; <br>&gt; This gives module authors the most control over *exactly* which classes can be used as superclasses outside the module (A and C don&#39;t need to be subclassable just because B needs to be.<br></p><p>I totally agree with both points.<br></p><p>-Thorsten <br></p><p><br>&gt; <br>&gt; -Matthew<br>&gt; <br>&gt;&gt; <br>&gt;&gt; I&#39;m not a big fan of the subclassable keyword either since it&#39;s quite long, not to mention it contains &quot;class&quot; which is the next keyword, making it visually repetitive.<br>&gt;&gt; <br>&gt;&gt; I&#39;d prefer open on both class and func to introduce only one keyword instead of two and possibly make it as a modifier of public to keep it in line with private(set)...<br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 6, 2016, at 1:11 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The review of &quot;SE-0117: Default classes to be non-subclassable publicly&quot; begins now and runs through July 11. The proposal is available here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What goes into a review?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   * What is your evaluation of the proposal?<br>&gt;&gt;&gt;   * Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt;&gt;   * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;   * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt;&gt;   * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thank you,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris Lattner<br>&gt;&gt;&gt; Review Manager<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ab8ff5d36ad4f40d7905509956e5c706?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Jacopo Andrea Giola</string> &lt;swift-evolution at jacopo.giola.org&gt;<p>July  6, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; 	* What is your evaluation of the proposal?<br></p><p>Strong +1 with the modifications proposed by Brent, I think that a single, short keyword is preferable to two different ones, and `open` is a perfect candidate that express its intent very well.<br></p><p>The only question that it raises is, a public class can be extended with a protocol defined in another module? I think that this aspect is not addresses in the proposal, or I have missed it completely.<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes indeed! This will fit nicely with the secure aspect of the Swift language, and will avoid cases where the library authors will try to discourage subclassing inside the comments in the class declaration file.<br></p><p>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>N/A<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I’ve read the proposal<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>July  6, 2016 at 01:00:00pm</p></header><div class="content"><p>-0.5 I think preventing subclassing is a bad idea, sometimes there are bugs<br>which can only be resolved by subclassing and this removes a lot of power<br>from app makers.<br></p><p>On 6 July 2016 at 13:23, Jacopo Andrea Giola via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt;       * What is your evaluation of the proposal?<br>&gt;<br>&gt; Unless someone can prove to me why we wouldn&#39;t need this for fixing bugs I<br>&gt; still thing this is only a good system to hint at the developer that they<br>&gt; shouldn&#39;t be using this class unless they have to.<br>&gt;<br>&gt; I could envision the compiler using the overide keyword to force the<br>&gt; developer to acknowledge they are using a non-reccomended class like so:<br>&gt;<br>&gt; // This class implements a polyfill which fixes a bug in the keychain class<br>&gt; override class PolyfillForKeychainBug: Keychain {<br>&gt;<br>&gt; }<br>&gt;<br>&gt; Without this the compiler would throw an error &quot;Non-open class can&#39;t be<br>&gt; overridden without `override` keyword&quot;<br>&gt;<br>&gt; &gt;       * Does this proposal fit well with the feel and direction of Swift?<br>&gt;<br>&gt; ​It does in terms of safety but not in terms of simplicity.​<br>&gt;<br>&gt;<br>&gt; &gt;       * If you have used other languages or libraries with a similar<br>&gt; feature, how do you feel that this proposal compares to those?<br>&gt;<br>&gt; ​It works like Java but I never liked final​<br>&gt;<br>&gt;<br></p><p>&gt; &gt;       * How much effort did you put into your review? A glance, a quick<br>&gt; reading, or an in-depth study?<br>&gt;<br>&gt; I’ve read the proposal<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160706/bd4c14f7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>July  6, 2016 at 09:00:00am</p></header><div class="content"><p>+1 from me.<br></p><p>I share similar concerns about &#39;easily&#39; allowing subclassing within the<br>module and testability but I am completely for this idea.<br></p><p>On Wed, Jul 6, 2016 at 8:33 AM, James Campbell via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; -0.5 I think preventing subclassing is a bad idea, sometimes there are<br>&gt; bugs which can only be resolved by subclassing and this removes a lot of<br>&gt; power from app makers.<br>&gt;<br>&gt; On 6 July 2016 at 13:23, Jacopo Andrea Giola via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; &gt;       * What is your evaluation of the proposal?<br>&gt;&gt;<br>&gt;&gt; Unless someone can prove to me why we wouldn&#39;t need this for fixing bugs<br>&gt;&gt; I still thing this is only a good system to hint at the developer that they<br>&gt;&gt; shouldn&#39;t be using this class unless they have to.<br>&gt;&gt;<br>&gt;&gt; I could envision the compiler using the overide keyword to force the<br>&gt;&gt; developer to acknowledge they are using a non-reccomended class like so:<br>&gt;&gt;<br>&gt;&gt; // This class implements a polyfill which fixes a bug in the keychain<br>&gt;&gt; class<br>&gt;&gt; override class PolyfillForKeychainBug: Keychain {<br>&gt;&gt;<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Without this the compiler would throw an error &quot;Non-open class can&#39;t be<br>&gt;&gt; overridden without `override` keyword&quot;<br>&gt;&gt;<br>&gt;&gt; &gt;       * Does this proposal fit well with the feel and direction of<br>&gt;&gt; Swift?<br>&gt;&gt;<br>&gt;&gt; ​It does in terms of safety but not in terms of simplicity.​<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &gt;       * If you have used other languages or libraries with a similar<br>&gt;&gt; feature, how do you feel that this proposal compares to those?<br>&gt;&gt;<br>&gt;&gt; ​It works like Java but I never liked final​<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;&gt; &gt;       * How much effort did you put into your review? A glance, a quick<br>&gt;&gt; reading, or an in-depth study?<br>&gt;&gt;<br>&gt;&gt; I’ve read the proposal<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160706/5e132433/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/27407b330bb87a134e4c50318fdd2ad1?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Aditya Krishnadevan</string> &lt;aditya at adityakd.me&gt;<p>July  8, 2016 at 04:00:00am</p></header><div class="content"><p>I agree with everything James has to say here. Making classes<br>non-subclassable by default is not optimal.<br>A lot of fixes for small bugs in UIKit involve using a subclass that<br>overrides at method or slightly modified behaviour as a temporary patch<br>until the issue is fixed at the framework level.<br>Preventing this *and* introducing a new keyword simply adds to the<br>complexity without bringing too much to the table.<br></p><p>Aditya Krishnadevan.<br></p><p>On 06-Jul-2016, at 6:03 PM, James Campbell via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>-0.5 I think preventing subclassing is a bad idea, sometimes there are bugs<br>which can only be resolved by subclassing and this removes a lot of power<br>from app makers.<br></p><p>On 6 July 2016 at 13:23, Jacopo Andrea Giola via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt;       * What is your evaluation of the proposal?<br>&gt;<br>&gt; Unless someone can prove to me why we wouldn&#39;t need this for fixing bugs I<br>&gt; still thing this is only a good system to hint at the developer that they<br>&gt; shouldn&#39;t be using this class unless they have to.<br>&gt;<br>&gt; I could envision the compiler using the overide keyword to force the<br>&gt; developer to acknowledge they are using a non-reccomended class like so:<br>&gt;<br>&gt; // This class implements a polyfill which fixes a bug in the keychain class<br>&gt; override class PolyfillForKeychainBug: Keychain {<br>&gt;<br>&gt; }<br>&gt;<br>&gt; Without this the compiler would throw an error &quot;Non-open class can&#39;t be<br>&gt; overridden without `override` keyword&quot;<br>&gt;<br>&gt; &gt;       * Does this proposal fit well with the feel and direction of Swift?<br>&gt;<br>&gt; ​It does in terms of safety but not in terms of simplicity.​<br>&gt;<br>&gt;<br>&gt; &gt;       * If you have used other languages or libraries with a similar<br>&gt; feature, how do you feel that this proposal compares to those?<br>&gt;<br>&gt; ​It works like Java but I never liked final​<br>&gt;<br>&gt;<br></p><p>&gt; &gt;       * How much effort did you put into your review? A glance, a quick<br>&gt; reading, or an in-depth study?<br>&gt;<br>&gt; I’ve read the proposal<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160708/57409459/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0f13ec2f877f56e92f812fc00a6a035?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Felipe Cypriano</string> &lt;felipe at cypriano.me&gt;<p>July  7, 2016 at 05:00:00pm</p></header><div class="content"><p>To be fair and practical with the proposal it does not remove the<br>ability to inherit any of the UIKit classes because all Objective-C<br>classes are imported as &quot;open&quot;.<br> <br>Food for thought on inheritance-is-the-only-fix, how have we worked all<br>these years with C libraries like Security, Foundation, Core Graphics,<br>GCD, and so on if C doesn&#39;t have inheritance? My point here is not to<br>suggest anything other than to keep an open mind, the proposal is not<br>removing OO from Swift. It is definitely a non conventional approach<br>when compared to other languages, Kotlin is the only language with<br>something similar but I have never used it.<br> <br>I have seen a lot of problems being solved by inheritance that could be<br>solved by composition in a way that was more reliable, testable, and<br>clear. When I asked why inheritance the answer is most of the time<br>because that is the way they know how to do things, like it was the only<br>tool available. I think Swift has as opportunity to increase software<br>quality by providing good defaults that make developers understand what<br>are the consequences of their choices. Maybe I&#39;m too optimistic.<br> <br> <br>On Thu, Jul 7, 2016, at 16:01, Aditya Krishnadevan via swift-evolution wrote:<br>&gt; I agree with everything James has to say here. Making classes non-<br>&gt; subclassable by default is not optimal.<br>&gt; A lot of fixes for small bugs in UIKit involve using a subclass that<br>&gt; overrides at method or slightly modified behaviour as a temporary<br>&gt; patch until the issue is fixed at the framework level.<br>&gt; Preventing this *and* introducing a new keyword simply adds to the<br>&gt; complexity without bringing too much to the table.<br>&gt;<br>&gt; Aditya Krishnadevan.<br>&gt;<br>&gt; On 06-Jul-2016, at 6:03 PM, James Campbell via swift-evolution &lt;swift-<br>&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt; -0.5 I think preventing subclassing is a bad idea, sometimes there<br>&gt;&gt; are bugs which can only be resolved by subclassing and this removes a<br>&gt;&gt; lot of power from app makers.<br>&gt;&gt;<br>&gt;&gt; On 6 July 2016 at 13:23, Jacopo Andrea Giola via swift-evolution &lt;swift-<br>&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;       * What is your evaluation of the proposal?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Unless someone can prove to me why we wouldn&#39;t need this for<br>&gt;&gt;&gt; fixing bugs I still thing this is only a good system to hint at<br>&gt;&gt;&gt; the developer that they shouldn&#39;t be using this class unless they<br>&gt;&gt;&gt; have to.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I could envision the compiler using the overide keyword to force<br>&gt;&gt;&gt; the developer to acknowledge they are using a non-reccomended class<br>&gt;&gt;&gt; like so:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; // This class implements a polyfill which fixes a bug in the<br>&gt;&gt;&gt; keychain class<br>&gt;&gt;&gt; override class PolyfillForKeychainBug: Keychain {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Without this the compiler would throw an error &quot;Non-open class can&#39;t<br>&gt;&gt;&gt; be overridden without `override` keyword&quot;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;       * Does this proposal fit well with the feel and direction of<br>&gt;&gt;&gt; &gt;         Swift?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It does in terms of safety but not in terms of simplicity.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;       * If you have used other languages or libraries with a<br>&gt;&gt;&gt; &gt;         similar feature, how do you feel that this proposal<br>&gt;&gt;&gt; &gt;         compares to those?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It works like Java but I never liked final<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; &gt;       * How much effort did you put into your review? A glance, a<br>&gt;&gt;&gt; &gt;         quick reading, or an in-depth study?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I’ve read the proposal<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;  swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br> <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160707/b0094db2/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>July  6, 2016 at 05:00:00pm</p></header><div class="content"><p>On 06.07.2016 2:11, Chris Lattner via swift-evolution wrote:<br>&gt; 	* What is your evaluation of the proposal?<br></p><p>Not sure. If we want to be clear about what can be done with public <br>class/method outside the module, and I agree this is an important question, <br>IMO we should to force a developer to explicitly mark the class/method as <br>&#39;public&amp;final&#39; or as &#39;public&amp;open&#39;. I.e. the developer of module/framework <br>should explicitly decide if he/she wants or don&#39;t want to allow for <br>subclassable/overridable.<br></p><p>If one writes &#39;public class&#39; - does this means that he/she *decided* to not <br>allow subclasses for this class or just *forgot* to decide this?<br></p><p>Also, IMO the suggested &#39;subclassable class&#39; / &#39;overridable func&#39; has no <br>relations to access scope but to ability for extension of the class. So <br>these keywords just should not replace the &#39;public&#39;, but should be used in <br>conjunction.<br></p><p>So, my -1 to proposed &#39;subclassable&#39;\&#39;overridable&#39; as *replacement* for <br>&#39;public&#39;. They confuse and not clear if it is public or modifiers for <br>&#39;internal&#39; scope.<br>My +1 to alternatives like &#39;public(subclassable)&#39; or &#39;public subclassable&#39;<br></p><p>My 0.0 for the idea of default non-subclassable `public`. I believe it is <br>important for developer to decide what should be allowed to his/her public <br>class, so Swift should force the developer to explicitely decide this.<br>My +1 to require &#39;public(final)&#39; or &#39;public(subclassable)&#39;, not just &#39;public&#39;.<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>July  6, 2016 at 09:00:00am</p></header><div class="content"><p>+1 except for the choice of names if I understand it correctly, but I want to make sure I understand it correctly.<br></p><p>The scenario I want to to make sure I understand is what happens for a class-cluster type pattern like the following:<br></p><p>  // Module A:<br>  public class PublicBaseClass {<br>    func someMethod() { /* placeholder here */ }<br>  }<br></p><p>  private class PrivateSubclass : PublicBaseClass {<br>    override func someMethod() { /* new logic here */ }<br>  }<br></p><p>…I think this would make `PublicBaseClass` effectively “final” (e.g. non-subclassable) from outside of Module A, but `PrivateSubclass` (and similar constructs, etc.) would still be allowed and work as one would expect?<br></p><p>If so, that’s what I’d want semantically, so +1 on that for the semantics.<br></p><p>*But*, that behavior means that it is *very* confusing to be using `subclassable` and `overridable` for what they mean in this protocol.<br></p><p>I usually stay out of bike shedding but these attributes are really poorly named IMHO; I’d *highly recommend* something like either the ugly-but-explicit `externally_subclassable` / `externally_overrideable` or something else entirely (like maybe `open`?) that avoids the confusion.<br></p><p>Apologies if this has already come up or is based upon a misunderstanding of the proposal.<br></p><p>&gt; On Jul 5, 2016, at 6:11 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;SE-0117: Default classes to be non-subclassable publicly&quot; begins now and runs through July 11. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>July  6, 2016 at 04:00:00pm</p></header><div class="content"><p>-1, against all odds.<br></p><p>I can&#39;t fight the feeling that many fans of ideas like this believe that good designed libraries come for free by simply adding restrictions — which, at least in my opinion, just isn&#39;t true:<br>No matter what the defaults are, good libraries are hard to build, so I predict this proposal would not only fail in increasing framework quality, but also will make it much harder for users of those frameworks to work around their flaws, which are just a natural part of every software.<br></p><p>The change would be less painful than final by default, and most normal developers wouldn&#39;t have to suffer (at least with their own code), but their is still confusion to expect:<br>When you tell someone about a &quot;subclassable&quot; modifier, the natural expectation is that this is needed for every class you want to subclass...<br></p><p>It&#39;s similar with overridable, but additionally, this would destroy a possible way to annotate a method that can be overridden, but not called, which I&#39;d consider as quite useful.<br>So, at least I vote for a modification that overridable doesn&#39;t imply public — not only because it&#39;s more powerful, but also because implying things is a complication<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>no, I question there is a problem with the status quo at all<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>(does anyone ever write something here that contradicts his own evaluation? ;-)<br></p><p>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>Not exactly the same, but C++ with its &quot;virtual&quot; is similar (C++ at its time had the excuse of better performance for the inconvenience; I don&#39;t think this small benefit should be important for Swift)<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>Just read the proposal and the messages, and took part in similar discussions before<br></p><p>Tino<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d9dbc0dfeb74eab8dd9bbd9cbd84680?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Jose Cheyo Jimenez</string> &lt;cheyo at masters3d.com&gt;<p>July  6, 2016 at 08:00:00am</p></header><div class="content"><p>&gt;    * What is your evaluation of the proposal?<br>Plus one. Open is my keyword of choice. <br></p><p>&gt;    * Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes. But I think some sort of patch ability should be introduced as a compromised. <br>http://article.gmane.org/gmane.comp.lang.swift.evolution/1805/match=patch+sealed<br></p><p>Perhaps a way to have an extension on a sealed class to be marked as a patch that is able to hook up to the willSet/didSet on a sealed property or be able to run before or after a method function. I think something like this could ease the pain of a completely closed to patching system. <br></p><p>&gt;    * Does this proposal fit well with the feel and direction of Swift?<br>Yes. <br>&gt;    * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;    * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>Moderate effort. <br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160706/6ed2e507/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>July  6, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; The review of &quot;SE-0117: Default classes to be non-subclassable publicly&quot; begins now and runs through July 11. The proposal is available here:<br>&gt;<br>&gt;         https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt;<br>&gt;         * What is your evaluation of the proposal?<br></p><p>+1. Being able to control how a class from my libraries are going to<br>be used by third-parties could enable a better designed API with more<br>control of how it is intended to be used. I&#39;m just not fond of using<br>the proposed keywords (&#39;subclassable&#39; and &#39;overridable&#39;) as they feel<br>more like protocol or attribute names; I&#39;d be more inclined to use the<br>alternative &#39;public open&#39; instead, or &#39;public(open)&#39; as a second<br>option.<br></p><p>&gt;         * Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>I&#39;d say it is significant to every language.<br></p><p>&gt;         * Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes.<br></p><p>&gt;         * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>C# uses the keyword &#39;virtual&#39; to explicitly mark methods that can be<br>overriden (not considered in the alternatives but I&#39;m not a big fan of<br>it).<br></p><p>&gt;         * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I&#39;ve took (a small) part on the thread discussing this proposal but<br>followed it closely<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>July  6, 2016 at 08:00:00pm</p></header><div class="content"><p>Leonardo, how is defaulting to final/sealed helping you write better libraries than having a final keyword for what you need to close instead?<br></p><p>Sent from my iPhone<br></p><p>On 6 Jul 2016, at 16:48, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; The review of &quot;SE-0117: Default classes to be non-subclassable publicly&quot; begins now and runs through July 11. The proposal is available here:<br>&gt;&gt; <br>&gt;&gt;        https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt;&gt; <br>&gt;&gt;        * What is your evaluation of the proposal?<br>&gt; <br>&gt; +1. Being able to control how a class from my libraries are going to<br>&gt; be used by third-parties could enable a better designed API with more<br>&gt; control of how it is intended to be used. I&#39;m just not fond of using<br>&gt; the proposed keywords (&#39;subclassable&#39; and &#39;overridable&#39;) as they feel<br>&gt; more like protocol or attribute names; I&#39;d be more inclined to use the<br>&gt; alternative &#39;public open&#39; instead, or &#39;public(open)&#39; as a second<br>&gt; option.<br>&gt; <br>&gt;&gt;        * Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; <br>&gt; I&#39;d say it is significant to every language.<br>&gt; <br>&gt;&gt;        * Does this proposal fit well with the feel and direction of Swift?<br>&gt; <br>&gt; Yes.<br>&gt; <br>&gt;&gt;        * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; <br>&gt; C# uses the keyword &#39;virtual&#39; to explicitly mark methods that can be<br>&gt; overriden (not considered in the alternatives but I&#39;m not a big fan of<br>&gt; it).<br>&gt; <br>&gt;&gt;        * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; I&#39;ve took (a small) part on the thread discussing this proposal but<br>&gt; followed it closely<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>July  6, 2016 at 04:00:00pm</p></header><div class="content"><p>Intention.<br></p><p>IMO, intention may lead to more secure systems (and libraries). By<br>having to explicitly final everything I have to choose with parts of<br>my class/library would be locked and have to worry and check if any<br>public thing could be used to exploit it or make the system work in a<br>way I did not intended to. Also, final will prevent anyone including<br>me from extending/overriding. Defaulting to final would require from<br>me to explicitly declare the open endpoints in my libraries, so I<br>could explicitly open only the ones that are really intended to be<br>used in that way by third-parties.<br></p><p>As an example, I&#39;m working on a system which has an internal<br>representation of Files and Folders using a common superclass (lets<br>call it Entry). I would like for other developers to be able to create<br>new entry types (not only inheriting from File) but I do not wish for<br>them to extend from Folder or any of its subclasses (specialised<br>folders). By using final I can prevent others from extending my Folder<br>but I cannot extend it myself and thus need another mechanism for<br>achieving this behaviour without bloating the Folder class with all<br>its specialisations. This proposal would allow me to make my Folder<br>and its subclasses publicly available/usable but would prevent others<br>from subclassing and thus misusing them in ways I did not intend them<br>to. The same rationale applies to methods.<br></p><p>L<br></p><p>On 6 July 2016 at 16:09, Goffredo Marocchi &lt;panajev at gmail.com&gt; wrote:<br>&gt; Leonardo, how is defaulting to final/sealed helping you write better libraries than having a final keyword for what you need to close instead?<br>&gt;<br>&gt; Sent from my iPhone<br>&gt;<br>&gt; On 6 Jul 2016, at 16:48, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;&gt; The review of &quot;SE-0117: Default classes to be non-subclassable publicly&quot; begins now and runs through July 11. The proposal is available here:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;        https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;        * What is your evaluation of the proposal?<br>&gt;&gt;<br>&gt;&gt; +1. Being able to control how a class from my libraries are going to<br>&gt;&gt; be used by third-parties could enable a better designed API with more<br>&gt;&gt; control of how it is intended to be used. I&#39;m just not fond of using<br>&gt;&gt; the proposed keywords (&#39;subclassable&#39; and &#39;overridable&#39;) as they feel<br>&gt;&gt; more like protocol or attribute names; I&#39;d be more inclined to use the<br>&gt;&gt; alternative &#39;public open&#39; instead, or &#39;public(open)&#39; as a second<br>&gt;&gt; option.<br>&gt;&gt;<br>&gt;&gt;&gt;        * Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt;<br>&gt;&gt; I&#39;d say it is significant to every language.<br>&gt;&gt;<br>&gt;&gt;&gt;        * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;<br>&gt;&gt; Yes.<br>&gt;&gt;<br>&gt;&gt;&gt;        * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt;<br>&gt;&gt; C# uses the keyword &#39;virtual&#39; to explicitly mark methods that can be<br>&gt;&gt; overriden (not considered in the alternatives but I&#39;m not a big fan of<br>&gt;&gt; it).<br>&gt;&gt;<br>&gt;&gt;&gt;        * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt;<br>&gt;&gt; I&#39;ve took (a small) part on the thread discussing this proposal but<br>&gt;&gt; followed it closely<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>July  6, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jul 6, 2016, at 12:35 PM, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Intention.<br>&gt; <br>&gt; IMO, intention may lead to more secure systems (and libraries). By<br>&gt; having to explicitly final everything I have to choose with parts of<br>&gt; my class/library would be locked and have to worry and check if any<br>&gt; public thing could be used to exploit it or make the system work in a<br>&gt; way I did not intended to. Also, final will prevent anyone including<br>&gt; me from extending/overriding. Defaulting to final would require from<br>&gt; me to explicitly declare the open endpoints in my libraries, so I<br>&gt; could explicitly open only the ones that are really intended to be<br>&gt; used in that way by third-parties.<br>&gt; <br>&gt; As an example, I&#39;m working on a system which has an internal<br>&gt; representation of Files and Folders using a common superclass (lets<br>&gt; call it Entry). I would like for other developers to be able to create<br>&gt; new entry types (not only inheriting from File) but I do not wish for<br>&gt; them to extend from Folder or any of its subclasses (specialised<br>&gt; folders). By using final I can prevent others from extending my Folder<br>&gt; but I cannot extend it myself and thus need another mechanism for<br>&gt; achieving this behaviour without bloating the Folder class with all<br>&gt; its specialisations. This proposal would allow me to make my Folder<br>&gt; and its subclasses publicly available/usable but would prevent others<br>&gt; from subclassing and thus misusing them in ways I did not intend them<br>&gt; to. The same rationale applies to methods.<br></p><p>I would underline this and add that the &quot;final&quot; workflow doesn&#39;t work very well<br>for methods.  You&#39;ve started with a final class, but now you want to allow<br>subclasses, so you remove the &quot;final&quot;... and now you have to carefully<br>add it back to every method and property on your class, because the default<br>is non-final.  And every time you modify the class in the future, you have to<br>remember to think about &quot;final&quot; for everything you add.  Forbidding external<br>overrides is the safer default assumption.<br></p><p>The default is also better for programmers using the library, because the<br>class author&#39;s intent is much clearer.  I&#39;ve maintained plenty of OO code where<br>subclassers weren&#39;t sure how they were supposed to customize the behavior<br>of the superclass, and so they just overrode a ton of different methods and repeated<br>the same logic in every place instead of using the already-defined extension<br>points (or asking for a new one).  Result: an unmaintainable subclass and a<br>superclass that can&#39;t be changed without breaking everything.<br></p><p>John.<br></p><p>&gt; <br>&gt; L<br>&gt; <br>&gt; On 6 July 2016 at 16:09, Goffredo Marocchi &lt;panajev at gmail.com&gt; wrote:<br>&gt;&gt; Leonardo, how is defaulting to final/sealed helping you write better libraries than having a final keyword for what you need to close instead?<br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt; On 6 Jul 2016, at 16:48, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; The review of &quot;SE-0117: Default classes to be non-subclassable publicly&quot; begins now and runs through July 11. The proposal is available here:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       * What is your evaluation of the proposal?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +1. Being able to control how a class from my libraries are going to<br>&gt;&gt;&gt; be used by third-parties could enable a better designed API with more<br>&gt;&gt;&gt; control of how it is intended to be used. I&#39;m just not fond of using<br>&gt;&gt;&gt; the proposed keywords (&#39;subclassable&#39; and &#39;overridable&#39;) as they feel<br>&gt;&gt;&gt; more like protocol or attribute names; I&#39;d be more inclined to use the<br>&gt;&gt;&gt; alternative &#39;public open&#39; instead, or &#39;public(open)&#39; as a second<br>&gt;&gt;&gt; option.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       * Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;d say it is significant to every language.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; C# uses the keyword &#39;virtual&#39; to explicitly mark methods that can be<br>&gt;&gt;&gt; overriden (not considered in the alternatives but I&#39;m not a big fan of<br>&gt;&gt;&gt; it).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;ve took (a small) part on the thread discussing this proposal but<br>&gt;&gt;&gt; followed it closely<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0f13ec2f877f56e92f812fc00a6a035?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Felipe Cypriano</string> &lt;felipe at cypriano.me&gt;<p>July  6, 2016 at 06:00:00pm</p></header><div class="content"><p>Strong +1 for me, separating access control from &quot;open-to-subclasses&quot; is<br>a great feature. Leonardo&#39;s example of why final is not enough is great.<br> <br>My stance is that Swift should be safe by default, predictable, and the<br>compiler should know enough about the code to actually help me and this<br>proposal fits this.<br> <br>About testability, I don&#39;t think we should downplay how to test &quot;sealed&quot;<br>classes from outside the framework. I do agree that the class should be<br>treated as a black box with only public APIs available, but testing how<br>my app is using those APIs  should be possible somehow.<br> <br>Last but not least, I don&#39;t like the proposed subclassable/overridable,<br>specially because they imply public.<br> <br> <br>On Wed, Jul 6, 2016, at 12:35, Leonardo Pessoa via swift-evolution wrote:<br>&gt; Intention.<br>&gt;<br>&gt; IMO, intention may lead to more secure systems (and libraries). By<br>&gt; having to explicitly final everything I have to choose with parts of<br>&gt; my class/library would be locked and have to worry and check if any<br>&gt; public thing could be used to exploit it or make the system work in a<br>&gt; way I did not intended to. Also, final will prevent anyone including<br>&gt; me from extending/overriding. Defaulting to final would require from<br>&gt; me to explicitly declare the open endpoints in my libraries, so I<br>&gt; could explicitly open only the ones that are really intended to be<br>&gt; used in that way by third-parties.<br>&gt;<br>&gt; As an example, I&#39;m working on a system which has an internal<br>&gt; representation of Files and Folders using a common superclass (lets<br>&gt; call it Entry). I would like for other developers to be able to create<br>&gt; new entry types (not only inheriting from File) but I do not wish for<br>&gt; them to extend from Folder or any of its subclasses (specialised<br>&gt; folders). By using final I can prevent others from extending my Folder<br>&gt; but I cannot extend it myself and thus need another mechanism for<br>&gt; achieving this behaviour without bloating the Folder class with all<br>&gt; its specialisations. This proposal would allow me to make my Folder<br>&gt; and its subclasses publicly available/usable but would prevent others<br>&gt; from subclassing and thus misusing them in ways I did not intend them<br>&gt; to. The same rationale applies to methods.<br>&gt;<br>&gt; L<br>&gt;<br>&gt; On 6 July 2016 at 16:09, Goffredo Marocchi &lt;panajev at gmail.com&gt; wrote:<br>&gt;&gt; Leonardo, how is defaulting to final/sealed helping you write better<br>&gt;&gt; libraries than having a final keyword for what you need to close<br>&gt;&gt; instead?<br>&gt;&gt;<br>&gt;&gt; Sent from my iPhone<br>&gt;&gt;<br>&gt;&gt; On 6 Jul 2016, at 16:48, Leonardo Pessoa via swift-evolution &lt;swift-<br>&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;&gt; The review of &quot;SE-0117: Default classes to be non-subclassable<br>&gt;&gt;&gt;&gt; publicly&quot; begins now and runs through July 11. The proposal is<br>&gt;&gt;&gt;&gt; available here:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;       * What is your evaluation of the proposal?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; +1. Being able to control how a class from my libraries are going to<br>&gt;&gt;&gt; be used by third-parties could enable a better designed API<br>&gt;&gt;&gt; with more<br>&gt;&gt;&gt; control of how it is intended to be used. I&#39;m just not fond of using<br>&gt;&gt;&gt; the proposed keywords (&#39;subclassable&#39; and &#39;overridable&#39;) as<br>&gt;&gt;&gt; they feel<br>&gt;&gt;&gt; more like protocol or attribute names; I&#39;d be more inclined to<br>&gt;&gt;&gt; use the<br>&gt;&gt;&gt; alternative &#39;public open&#39; instead, or &#39;public(open)&#39; as a second<br>&gt;&gt;&gt; option.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;       * Is the problem being addressed significant enough to<br>&gt;&gt;&gt;&gt;         warrant a change to Swift?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;d say it is significant to every language.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;       * Does this proposal fit well with the feel and direction of<br>&gt;&gt;&gt;&gt;         Swift?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Yes.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;       * If you have used other languages or libraries with a<br>&gt;&gt;&gt;&gt;         similar feature, how do you feel that this proposal<br>&gt;&gt;&gt;&gt;         compares to those?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; C# uses the keyword &#39;virtual&#39; to explicitly mark methods that can be<br>&gt;&gt;&gt; overriden (not considered in the alternatives but I&#39;m not a big<br>&gt;&gt;&gt; fan of<br>&gt;&gt;&gt; it).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;       * How much effort did you put into your review? A glance, a<br>&gt;&gt;&gt;&gt;         quick reading, or an in-depth study?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;ve took (a small) part on the thread discussing this proposal but<br>&gt;&gt;&gt; followed it closely<br>&gt;&gt;&gt; _________________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br> <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160706/f445d1b9/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Michael Peternell</string> &lt;michael.peternell at gmx.at&gt;<p>July  6, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; Am 06.07.2016 um 01:11 schrieb Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;SE-0117: Default classes to be non-subclassable publicly&quot; begins now and runs through July 11. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br></p><p>-1<br>I think it&#39;s a step backwards.<br>If we really think that Swift is meant as a language for beginners then this is certainly the wrong direction to go to. Having to use a special keyword to allow a class to be subclassed from outside the module looks like the compiler has to perform some extra effort to add this &quot;subclassability feature&quot;.<br></p><p>It&#39;s not bad to allow sealing of classes. I don&#39;t see real value in it though. And `sealed` should not be the default. Either the class if final or not: for me that&#39;s a valuable distinction. &quot;sealed vs. unsealed&quot; is not.<br></p><p>The proposal is another try to prevent people from misusing the language. But misusing the language will always be possible and will always be easy. All these attempts will make the language just more complicated or harder to understand. I don&#39;t buy the performance argument either, i.e. that &quot;sealed by default&quot; will improve performance considerably for non-contrived use-cases. But I&#39;m sure you will find that out a few months after the proposal is implemented :-/<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>No<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>No, I don&#39;t think so.<br>If you have a ParentClass and a SubClass, and the ParentClass is sealed while the SubClass is subclassable. What happens? No matter how this question is answered, I don&#39;t like the answer. (compile error =&gt; bad. || make it as the user wishes =&gt; bad; what do we gain by letting ParentClass remain sealed? || make ParentClass implicitly subclassable too =&gt; bad.)<br></p><p>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>No<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>Participated in early discussions which didn&#39;t convince me at all.<br></p><p>-Michael<br></p><p>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>July  6, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; If you have a ParentClass and a SubClass, and the ParentClass is sealed while the SubClass is subclassable. What happens? No matter how this question is answered, I don&#39;t like the answer. (compile error =&gt; bad. || make it as the user wishes =&gt; bad; what do we gain by letting ParentClass remain sealed? || make ParentClass implicitly subclassable too =&gt; bad.)<br>I&#39;m happy that there are not only supporters for this proposal, but imho the example is no compelling argument:<br>With no doubt, I&#39;d expect I can subclass only SubClass — like I can&#39;t instantiate an abstract class, which is just fine for its children.<br>ParentClass might do some dangerous things that don&#39;t happen in SubClass, so there might even be a use-case (but imho it would be better if I could mark ParentClass as internal in this situation).<br></p><p>But imho there is another aspect I haven&#39;t read about yet:<br>&quot;final by default&quot; would have had direct impact on any developer, while this proposal merely changes things for those who create libraries…<br>So, the question is: How will those be build?<br></p><p>If you live in a world of secrets and non-disclosure, I can understand that sealed is desirable — but that&#39;s not the future I want to see, and github is a good indication that others share this opinion.<br></p><p>If you share the sympathy for Open source, the two scenarios are as follows:<br>We stick with &quot;open by default&quot;; users of libraries will use them in ways that the creator hasn&#39;t thought of before, and bugs will show up.<br>But: We know how to deal with bugs, that&#39;s our job! So in the best case, we find the reason for the bad behavior, create a pull request, and everyone is happy.<br></p><p>With &quot;sealed by default&quot;, the situation changes:<br>Users are protected from some simple bugs, but nonetheless, they&#39;ll encounter situations where the library doesn&#39;t do exactly what they want.<br>So, you take a look at the source, find the problem, and fix it.<br>It&#39;s no bug at all, it&#39;s just a tiny degree of freedom that is missing because it wasn&#39;t important to the author.<br>You can create a pull request as well, but it doesn&#39;t offer a real improvement to the author, who is already busy with dozens of similar requests by other users -&gt; you end up with a custom branch with all the housekeeping associated with it.<br></p><p>So overall, I&#39;m quite sure that the proposal won&#39;t improve software quality, but rather degrade it.<br></p><p>Tino<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>July  7, 2016 at 07:00:00am</p></header><div class="content"><p>Regards<br>LM<br>(From mobile)<br></p><p>&gt; On Jul 6, 2016, at 10:39 PM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; If you have a ParentClass and a SubClass, and the ParentClass is sealed while the SubClass is subclassable. What happens? No matter how this question is answered, I don&#39;t like the answer. (compile error =&gt; bad. || make it as the user wishes =&gt; bad; what do we gain by letting ParentClass remain sealed? || make ParentClass implicitly subclassable too =&gt; bad.)<br>&gt; I&#39;m happy that there are not only supporters for this proposal, but imho the example is no compelling argument:<br>&gt; With no doubt, I&#39;d expect I can subclass only SubClass — like I can&#39;t instantiate an abstract class, which is just fine for its children.<br>&gt; ParentClass might do some dangerous things that don&#39;t happen in SubClass, so there might even be a use-case (but imho it would be better if I could mark ParentClass as internal in this situation).<br>&gt; <br>&gt; But imho there is another aspect I haven&#39;t read about yet:<br>&gt; &quot;final by default&quot; would have had direct impact on any developer, while this proposal merely changes things for those who create libraries…<br>&gt; So, the question is: How will those be build?<br>&gt; <br>&gt; If you live in a world of secrets and non-disclosure, I can understand that sealed is desirable — but that&#39;s not the future I want to see, and github is a good indication that others share this opinion.<br>&gt; <br>&gt; If you share the sympathy for Open source, the two scenarios are as follows:<br>&gt; We stick with &quot;open by default&quot;; users of libraries will use them in ways that the creator hasn&#39;t thought of before, and bugs will show up.<br>&gt; But: We know how to deal with bugs, that&#39;s our job! So in the best case, we find the reason for the bad behavior, create a pull request, and everyone is happy.<br>&gt; <br>&gt; With &quot;sealed by default&quot;, the situation changes:<br>&gt; Users are protected from some simple bugs, but nonetheless, they&#39;ll encounter situations where the library doesn&#39;t do exactly what they want.<br>&gt; So, you take a look at the source, find the problem, and fix it.<br>&gt; It&#39;s no bug at all, it&#39;s just a tiny degree of freedom that is missing because it wasn&#39;t important to the author.<br>&gt; You can create a pull request as well, but it doesn&#39;t offer a real improvement to the author, who is already busy with dozens of similar requests by other users -&gt; you end up with a custom branch with all the housekeeping associated with it.<br>&gt; <br>&gt; So overall, I&#39;m quite sure that the proposal won&#39;t improve software quality, but rather degrade it.<br></p><p>:) <br></p><p>&gt; Tino<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c72bd3ba434ad651a5d8d3d79f2d4c49?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Scott James Remnant</string> &lt;scott at netsplit.com&gt;<p>July  6, 2016 at 12:00:00pm</p></header><div class="content"><p>-1<br></p><p>This proposal makes Swift a more confusing language.<br></p><p><br>Swift already has a mechanism for creating public subclassable classes and non-subclassable classes:<br></p><p>  public class SubclassableParentClass { }<br></p><p>  public final class NonSubclassableParentClass { }<br></p><p>This mechanism also applies to methods, properties, and subscripts:<br></p><p>  public func bar() {}<br></p><p>  public final func foo() {}<br></p><p>The proposal makes no effort to remove this existing syntax.<br></p><p>The very fact that this would be legitimate syntax as a result is a bad omen to me:<br></p><p>  subclassable final class ConfusedParentClass {<br></p><p>    overridable final func quuz() {}<br></p><p>  }<br></p><p>The proposal doesn’t even address what that would do, the obvious answer is “compiler error,” but a better answer would be a language design that didn’t allow for this kind of ambiguity.<br></p><p><br>Conflating access control and finality is confusing. The proposal actually even goes as far to argue that—“conflates” is a word I took from the proposal—but it’s solution *is* a conflation in of its right, because the only way to explain the results is in terms of both:<br></p><p>classes, methods, properties, and subscripts with access control of `internal`, `file private`, and `private` are overridable by code that can access them, to prevent this add the `final` keyword.<br>classes with access control of `public` are not overridable by code that can access them, to allow this replace the `public` keyword with the `subclassable` keyword.<br>methods, properties, and subscripts with access control of `public` are not overridable by code that can access them, to allow this replace the `public` keyword with the `overridable` keyword.<br></p><p>Not only is this complicated, and confusing, it isn’t even consistent: to deny overriding or subclassing you add the same keyword; but to allow overriding or subclassing you replace one keyword with two different ones, depending on which you’re doing.<br></p><p><br>I agree that the alternative of flipping the default, and replacing `final` with `nonfinal` is also undesirable. One of the nicer features of the Swift language design is that the language is easiest for app developers working within a single module, where it can be assumed that “everyone is an adult.” Breaking this to support the less common case of Public API Designers would be a step backwards; their case is important, but it shouldn’t come at a penalty.<br></p><p>Scott<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160706/ccc56c87/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>July  6, 2016 at 04:00:00pm</p></header><div class="content"><p>Scott, you really got a point here: should this proposal pass, I<br>believe the final keyword should be removed as it would be already the<br>default behaviour and thus unnecessary. I don&#39;t think this is on the<br>proposal.<br></p><p>L<br></p><p>On 6 July 2016 at 16:47, Scott James Remnant via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; -1<br>&gt;<br>&gt; This proposal makes Swift a more confusing language.<br>&gt;<br>&gt;<br>&gt; Swift already has a mechanism for creating public subclassable classes and<br>&gt; non-subclassable classes:<br>&gt;<br>&gt;   public class SubclassableParentClass { }<br>&gt;<br>&gt;   public final class NonSubclassableParentClass { }<br>&gt;<br>&gt; This mechanism also applies to methods, properties, and subscripts:<br>&gt;<br>&gt;   public func bar() {}<br>&gt;<br>&gt;   public final func foo() {}<br>&gt;<br>&gt; The proposal makes no effort to remove this existing syntax.<br>&gt;<br>&gt; The very fact that this would be legitimate syntax as a result is a bad omen<br>&gt; to me:<br>&gt;<br>&gt;   subclassable final class ConfusedParentClass {<br>&gt;<br>&gt;     overridable final func quuz() {}<br>&gt;<br>&gt;   }<br>&gt;<br>&gt; The proposal doesn’t even address what that would do, the obvious answer is<br>&gt; “compiler error,” but a better answer would be a language design that didn’t<br>&gt; allow for this kind of ambiguity.<br>&gt;<br>&gt;<br>&gt; Conflating access control and finality is confusing. The proposal actually<br>&gt; even goes as far to argue that—“conflates” is a word I took from the<br>&gt; proposal—but it’s solution *is* a conflation in of its right, because the<br>&gt; only way to explain the results is in terms of both:<br>&gt;<br>&gt; classes, methods, properties, and subscripts with access control of<br>&gt; `internal`, `file private`, and `private` are overridable by code that can<br>&gt; access them, to prevent this add the `final` keyword.<br>&gt; classes with access control of `public` are not overridable by code that can<br>&gt; access them, to allow this replace the `public` keyword with the<br>&gt; `subclassable` keyword.<br>&gt; methods, properties, and subscripts with access control of `public` are not<br>&gt; overridable by code that can access them, to allow this replace the `public`<br>&gt; keyword with the `overridable` keyword.<br>&gt;<br>&gt;<br>&gt; Not only is this complicated, and confusing, it isn’t even consistent: to<br>&gt; deny overriding or subclassing you add the same keyword; but to allow<br>&gt; overriding or subclassing you replace one keyword with two different ones,<br>&gt; depending on which you’re doing.<br>&gt;<br>&gt;<br>&gt; I agree that the alternative of flipping the default, and replacing `final`<br>&gt; with `nonfinal` is also undesirable. One of the nicer features of the Swift<br>&gt; language design is that the language is easiest for app developers working<br>&gt; within a single module, where it can be assumed that “everyone is an adult.”<br>&gt; Breaking this to support the less common case of Public API Designers would<br>&gt; be a step backwards; their case is important, but it shouldn’t come at a<br>&gt; penalty.<br>&gt;<br>&gt; Scott<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c72bd3ba434ad651a5d8d3d79f2d4c49?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Scott James Remnant</string> &lt;scott at netsplit.com&gt;<p>July  6, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jul 6, 2016, at 12:50 PM, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br>&gt; <br>&gt; Scott, you really got a point here: should this proposal pass, I<br>&gt; believe the final keyword should be removed as it would be already the<br>&gt; default behaviour and thus unnecessary. I don&#39;t think this is on the<br>&gt; proposal.<br>&gt; <br></p><p>Removing the `final` keyword would mean there would be no way to have a class of `internal` (default) scope that subclasses and another class of `internal` (default) scope and overrides a method of `internal` (default) scope.<br></p><p>Scott<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>July  6, 2016 at 05:00:00pm</p></header><div class="content"><p>Scott, I think your writing got a bit confuse but, if I got your<br>intention right, since you are the owner of the class, you may choose<br>to subclass it or not internally, no questions asked. I need no finals<br>in my apps and I only subclass if I intend to. If you are in control<br>of your own code, why would you need to ensure there would be no<br>subclassing/overriding? I&#39;m not opposed to keeping the keyword if it<br>is important to anyone to be sure of that for internals. As for what<br>is public you will gain better control of what other people do to your<br>classes and methods.<br></p><p>L<br></p><p>On 6 July 2016 at 16:56, Scott James Remnant &lt;scott at netsplit.com&gt; wrote:<br>&gt;<br>&gt;&gt; On Jul 6, 2016, at 12:50 PM, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Scott, you really got a point here: should this proposal pass, I<br>&gt;&gt; believe the final keyword should be removed as it would be already the<br>&gt;&gt; default behaviour and thus unnecessary. I don&#39;t think this is on the<br>&gt;&gt; proposal.<br>&gt;&gt;<br>&gt;<br>&gt; Removing the `final` keyword would mean there would be no way to have a class of `internal` (default) scope that subclasses and another class of `internal` (default) scope and overrides a method of `internal` (default) scope.<br>&gt;<br>&gt; Scott<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c72bd3ba434ad651a5d8d3d79f2d4c49?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Scott James Remnant</string> &lt;scott at netsplit.com&gt;<p>July  6, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; <br>&gt; On Jul 6, 2016, at 1:16 PM, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br>&gt; <br>&gt; Scott, I think your writing got a bit confuse but, if I got your<br>&gt; intention right, since you are the owner of the class, you may choose<br>&gt; to subclass it or not internally, no questions asked.<br></p><p>No.<br></p><p>This is how the language exists today:<br></p><p>1a. Default access control is `internal`, and may be modified by adding the `public`, `fileprivate`, or `private` keyword, as appropriate.<br></p><p>1b. All classes may be subclassed, and all methods, properties, and subscripts overridden. This can be prevented by adding the `final` keyword.<br></p><p>The two concepts are very separate, and I think this is a good thing.<br></p><p><br>What this proposal suggests, whether or not `final` is kept or removed, is that the two concepts become conflated:<br></p><p>2a. Default access control is `internal`, and may be modified by adding the `public`, `fileprivate`, or `private` keyword, as appropriate.<br></p><p>2b. Non-`public` classes may be subclassed, and non-`public` methods, properties, and subscripts overridden. This can be prevented by adding the `final` keyword.<br></p><p>2c. `public` classes may not be subclassed. To allow this replace the `public` keyword with `subclassable`<br></p><p>2d. `public` methods, properties, and subscripts may not be overridden. To allow this replace the `public` keyword with `overiddable`.<br></p><p><br>Removing the `final` keyword means a change to 2b above. The first option is simply to throw it away, in which case you end up with:<br></p><p>3a. Default access control is `internal`, and may be modified by adding the `public`, `fileprivate`, or `private` keyword, as appropriate.<br></p><p>3b. Non-`public` classes may be subclassed, and non-`public` methods, properties, and subscripts overridden. This can be never be prevented.<br></p><p>3c. `public` classes may not be subclassed. To allow this replace the `public` keyword with `subclassable`<br></p><p>3d. `public` methods, properties, and subscripts may not be overridden. To allow this replace the `public` keyword with `overiddable`.<br></p><p><br>The second option is to throw it away, and adjust the default behavior so it truly is `final` as removing the keyword would imply. Then you end up with:<br></p><p>4a. Default access control is `internal`, and may be modified by adding the `public`, `fileprivate`, or `private` keyword, as appropriate.<br></p><p>4b. Non-`public` classes may not be subclassed, and non-`public` methods, properties, and subscripts may not be overridden. This can never be allowed.<br></p><p>4c. `public` classes may not be subclassed. To allow this replace the `public` keyword with `subclassable`<br></p><p>4d. `public` methods, properties, and subscripts may not be overridden. To allow this replace the `public` keyword with `overiddable`.<br></p><p><br>To me all of these options take a clean, easy-to-understand, language design (1) and turn it into various states of mess. Removing the `final` keyword not only makes it a mess, but removes functionality—the ability to have a mix of final and non-final classes, methods, properties, and subscripts, accessible only within your own module.<br></p><p>Scott<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>July  6, 2016 at 06:00:00pm</p></header><div class="content"><p>So I did get what you meant right. Now tell me: if a class or method<br>is internal to your module (and you know internal means only you,<br>throught your source code, inside your app or library can extend it),<br>do you really need to mark anything as final for any reason? Final on<br>any non-publics is a restriction you put on yourself, you will always<br>have the power to lift that at any time (as long as you still own the<br>code, of course) so you are always in control of your subclasses and<br>overrides. All the time. It&#39;s up to you to subclass/override or not.<br>This is different from what you make public: you either have no<br>control or you have to fine grain control making everything final. You<br>regain that control over your publics with this proposal.<br></p><p>You can also try and simplify your outlines reducing X.c and X.d to a<br>single entry as it is the same rule applied to two different elements<br>of the language. Using one single keyword (such as in &#39;open&#39;) would<br>make it clearer and that is why I prefer to have only one keyword.<br></p><p>So, AFAICS, number 3 is how it should be with this proposal. As for<br>keeping the final keyword (sticking with number 2), I think it is up<br>to the community. I myself don&#39;t see any reason/need for it should<br>this proposal pass.<br></p><p>L<br></p><p>On 6 July 2016 at 17:32, Scott James Remnant &lt;scott at netsplit.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Jul 6, 2016, at 1:16 PM, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Scott, I think your writing got a bit confuse but, if I got your<br>&gt;&gt; intention right, since you are the owner of the class, you may choose<br>&gt;&gt; to subclass it or not internally, no questions asked.<br>&gt;<br>&gt; No.<br>&gt;<br>&gt; This is how the language exists today:<br>&gt;<br>&gt; 1a. Default access control is `internal`, and may be modified by adding the `public`, `fileprivate`, or `private` keyword, as appropriate.<br>&gt;<br>&gt; 1b. All classes may be subclassed, and all methods, properties, and subscripts overridden. This can be prevented by adding the `final` keyword.<br>&gt;<br>&gt; The two concepts are very separate, and I think this is a good thing.<br>&gt;<br>&gt;<br>&gt; What this proposal suggests, whether or not `final` is kept or removed, is that the two concepts become conflated:<br>&gt;<br>&gt; 2a. Default access control is `internal`, and may be modified by adding the `public`, `fileprivate`, or `private` keyword, as appropriate.<br>&gt;<br>&gt; 2b. Non-`public` classes may be subclassed, and non-`public` methods, properties, and subscripts overridden. This can be prevented by adding the `final` keyword.<br>&gt;<br>&gt; 2c. `public` classes may not be subclassed. To allow this replace the `public` keyword with `subclassable`<br>&gt;<br>&gt; 2d. `public` methods, properties, and subscripts may not be overridden. To allow this replace the `public` keyword with `overiddable`.<br>&gt;<br>&gt;<br>&gt; Removing the `final` keyword means a change to 2b above. The first option is simply to throw it away, in which case you end up with:<br>&gt;<br>&gt; 3a. Default access control is `internal`, and may be modified by adding the `public`, `fileprivate`, or `private` keyword, as appropriate.<br>&gt;<br>&gt; 3b. Non-`public` classes may be subclassed, and non-`public` methods, properties, and subscripts overridden. This can be never be prevented.<br>&gt;<br>&gt; 3c. `public` classes may not be subclassed. To allow this replace the `public` keyword with `subclassable`<br>&gt;<br>&gt; 3d. `public` methods, properties, and subscripts may not be overridden. To allow this replace the `public` keyword with `overiddable`.<br>&gt;<br>&gt;<br>&gt; The second option is to throw it away, and adjust the default behavior so it truly is `final` as removing the keyword would imply. Then you end up with:<br>&gt;<br>&gt; 4a. Default access control is `internal`, and may be modified by adding the `public`, `fileprivate`, or `private` keyword, as appropriate.<br>&gt;<br>&gt; 4b. Non-`public` classes may not be subclassed, and non-`public` methods, properties, and subscripts may not be overridden. This can never be allowed.<br>&gt;<br>&gt; 4c. `public` classes may not be subclassed. To allow this replace the `public` keyword with `subclassable`<br>&gt;<br>&gt; 4d. `public` methods, properties, and subscripts may not be overridden. To allow this replace the `public` keyword with `overiddable`.<br>&gt;<br>&gt;<br>&gt; To me all of these options take a clean, easy-to-understand, language design (1) and turn it into various states of mess. Removing the `final` keyword not only makes it a mess, but removes functionality—the ability to have a mix of final and non-final classes, methods, properties, and subscripts, accessible only within your own module.<br>&gt;<br>&gt; Scott<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c72bd3ba434ad651a5d8d3d79f2d4c49?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Scott James Remnant</string> &lt;scott at netsplit.com&gt;<p>July  6, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jul 6, 2016, at 2:13 PM, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br>&gt; <br>&gt; So I did get what you meant right. Now tell me: if a class or method<br>&gt; is internal to your module (and you know internal means only you,<br>&gt; throught your source code, inside your app or library can extend it),<br>&gt; do you really need to mark anything as final for any reason? Final on<br>&gt; any non-publics is a restriction you put on yourself, you will always<br>&gt; have the power to lift that at any time (as long as you still own the<br>&gt; code, of course) so you are always in control of your subclasses and<br>&gt; overrides. All the time. It&#39;s up to you to subclass/override or not.<br>&gt; This is different from what you make public: you either have no<br>&gt; control or you have to fine grain control making everything final. You<br>&gt; regain that control over your publics with this proposal.<br>&gt; <br></p><p>The same argument could be applied to why we have `fileprivate` and `private`, if a class or method is internal to my module, why do I need to mark anything as further private for any reason?<br></p><p>There are a whole bunch of answers; perhaps the module is maintained by a team of twenty people, and the class is intended to be sub-classed within the team, so it’s a level of “internal public.” It doesn’t even have to be a team, maybe I’m writing a utility class that I know I’ll use for years, and I know I’ll forget my rationale later down the line and make the mistake of overriding something I shouldn’t.<br></p><p>Removing `final` is a whole proposal unto itself that I would also -1, it’s not covered by this one, so at this point this is a rabbit hole.<br></p><p>Scott<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c72bd3ba434ad651a5d8d3d79f2d4c49?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Scott James Remnant</string> &lt;scott at netsplit.com&gt;<p>July  6, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jul 6, 2016, at 2:13 PM, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br>&gt; <br>&gt; You can also try and simplify your outlines reducing X.c and X.d to a<br>&gt; single entry as it is the same rule applied to two different elements<br>&gt; of the language. Using one single keyword (such as in &#39;open&#39;) would<br>&gt; make it clearer and that is why I prefer to have only one keyword.<br>&gt; <br></p><p>I didn’t simply the outlines precisely because the proposal suggests two keywords.<br></p><p>One keyword does solve this problem, but not the problem of conflation of finality and access control.<br>You end up with this matrix:<br></p><p>  access      | can override | final<br> -------------+--------------+-------<br>  open        | yes          | Error - “class cannot be open and final&quot;<br>  public      | no           | Error - “public class is already final by default&quot;<br>  internal    | yes          | final<br>  fileprivate | yes          | final<br>  private     | yes          | final<br></p><p>This is way more confusing than the current language:<br></p><p>  access      | can override | final<br> -------------+--------------+-------<br>  public      | yes          | final<br>  internal    | yes          | final<br>  fileprivate | yes          | final<br>  private     | yes          | final<br></p><p>I strongly favor a programming language that doesn’t introduce compiler errors to solve problems that could be solved by cleaner syntax.<br></p><p>Since it’s already necessary to place the `public` keyword in front of every class, method, property, or subscript that you intend to make public, the developer is already thinking about the public API. Typing `public final` instead of `public` is an extra keyword, it’s not an extra cognitive burden since that cognition is already taking place.<br></p><p>Scott<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160706/476b7806/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>July  6, 2016 at 06:00:00pm</p></header><div class="content"><p>I don&#39;t disagree with you on &#39;fileprivate&#39; and &#39;private&#39; being<br>unnecessary and we may stick to the proposal at hand and leave the<br>&#39;final&#39; issue to another proposal, should anyone else care (I myself<br>don&#39;t mind if it sticks around - just have to not use it).<br></p><p>As for the conflict, I don&#39;t see it. Can you declare a &#39;public private<br>class&#39;? I think it is just the same with &#39;open&#39; and &#39;final&#39;. And there<br>is no need to introduce an error for being redundant with &#39;public<br>final&#39; either.<br></p><p>L<br></p><p>On 6 July 2016 at 18:36, Scott James Remnant &lt;scott at netsplit.com&gt; wrote:<br>&gt;<br>&gt; On Jul 6, 2016, at 2:13 PM, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br>&gt;<br>&gt; You can also try and simplify your outlines reducing X.c and X.d to a<br>&gt; single entry as it is the same rule applied to two different elements<br>&gt; of the language. Using one single keyword (such as in &#39;open&#39;) would<br>&gt; make it clearer and that is why I prefer to have only one keyword.<br>&gt;<br>&gt;<br>&gt; I didn’t simply the outlines precisely because the proposal suggests two<br>&gt; keywords.<br>&gt;<br>&gt; One keyword does solve this problem, but not the problem of conflation of<br>&gt; finality and access control.<br>&gt; You end up with this matrix:<br>&gt;<br>&gt;   access      | can override | final<br>&gt;  -------------+--------------+-------<br>&gt;   open        | yes          | Error - “class cannot be open and final&quot;<br>&gt;   public      | no           | Error - “public class is already final by<br>&gt; default&quot;<br>&gt;   internal    | yes          | final<br>&gt;   fileprivate | yes          | final<br>&gt;   private     | yes          | final<br>&gt;<br>&gt; This is way more confusing than the current language:<br>&gt;<br>&gt;   access      | can override | final<br>&gt;  -------------+--------------+-------<br>&gt;   public      | yes          | final<br>&gt;   internal    | yes          | final<br>&gt;   fileprivate | yes          | final<br>&gt;   private     | yes          | final<br>&gt;<br>&gt; I strongly favor a programming language that doesn’t introduce compiler<br>&gt; errors to solve problems that could be solved by cleaner syntax.<br>&gt;<br>&gt; Since it’s already necessary to place the `public` keyword in front of every<br>&gt; class, method, property, or subscript that you intend to make public, the<br>&gt; developer is already thinking about the public API. Typing `public final`<br>&gt; instead of `public` is an extra keyword, it’s not an extra cognitive burden<br>&gt; since that cognition is already taking place.<br>&gt;<br>&gt; Scott<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July  6, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jul 6, 2016, at 4:36 PM, Scott James Remnant via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 6, 2016, at 2:13 PM, Leonardo Pessoa &lt;me at lmpessoa.com &lt;mailto:me at lmpessoa.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; You can also try and simplify your outlines reducing X.c and X.d to a<br>&gt;&gt; single entry as it is the same rule applied to two different elements<br>&gt;&gt; of the language. Using one single keyword (such as in &#39;open&#39;) would<br>&gt;&gt; make it clearer and that is why I prefer to have only one keyword.<br>&gt;&gt; <br>&gt; <br>&gt; I didn’t simply the outlines precisely because the proposal suggests two keywords.<br>&gt; <br>&gt; One keyword does solve this problem, but not the problem of conflation of finality and access control.<br>&gt; You end up with this matrix:<br>&gt; <br>&gt;   access      | can override | final<br>&gt;  -------------+--------------+-------<br>&gt;   open        | yes          | Error - “class cannot be open and final”<br></p><p>Of course this produces a compile error.  Open means “can subclass” which directly contradicts final.<br></p><p>&gt;   public      | no           | Error - “public class is already final by default”<br></p><p>This is not true.  Public classes will *not* be “final by default”.  It *will* be possible to subclass them within their declaring module.  If they need to be final they will still need to be marked as such.  <br></p><p>With that in mind, the your “can override” column (do you really mean “can subclass” here?) is also not correct.  The correct answer is “yes, within the module”.  The fundamental difference for this row is that there are some scopes which can *see* the type without the ability to subclass it.  There is no problem with this, it is *exactly* what we want. <br></p><p>The purpose of this proposal is precisely to give library authors the ability to have more fine grained control over what capabilities their library exposes to users.<br></p><p>&gt;   internal    | yes          | final<br>&gt;   fileprivate | yes          | final<br>&gt;   private     | yes          | final<br>&gt; <br>&gt; This is way more confusing than the current language:<br>&gt; <br>&gt;   access      | can override | final<br>&gt;  -------------+--------------+-------<br>&gt;   public      | yes          | final<br>&gt;   internal    | yes          | final<br>&gt;   fileprivate | yes          | final<br>&gt;   private     | yes          | final<br>&gt; <br>&gt; I strongly favor a programming language that doesn’t introduce compiler errors to solve problems that could be solved by cleaner syntax.<br>&gt; <br>&gt; Since it’s already necessary to place the `public` keyword in front of every class, method, property, or subscript that you intend to make public, the developer is already thinking about the public API. Typing `public final` instead of `public` is an extra keyword, it’s not an extra cognitive burden since that cognition is already taking place.<br></p><p>As you can see from the points above, `public final` is something very different than both `public` and `public subclass able` (or `open`) under the current proposal.  It is not a question of cleaner syntax.  It is a question of whether we want to give library authors more fine grained control.<br></p><p>-Matthew<br></p><p>&gt; <br>&gt; Scott<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160706/75f32e26/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c72bd3ba434ad651a5d8d3d79f2d4c49?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Scott James Remnant</string> &lt;scott at netsplit.com&gt;<p>July  6, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jul 6, 2016, at 2:47 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; This is not true.  Public classes will *not* be “final by default”.  It *will* be possible to subclass them within their declaring module.  If they need to be final they will still need to be marked as such.  <br>&gt; <br>&gt; With that in mind, the your “can override” column (do you really mean “can subclass” here?) is also not correct.  The correct answer is “yes, within the module”.  The fundamental difference for this row is that there are some scopes which can *see* the type without the ability to subclass it.  There is no problem with this, it is *exactly* what we want.  <br></p><p>So would this be more accurate?<br></p><p>  access      | can access    | can subclass/  | final<br>              |               | override where |<br> -------------+---------------+----------------+-------<br>  open        | all scopes    | all scopes     | Error<br>  public      | all scopes    | within module  | final<br>  internal    | within module | within module  | final<br>  fileprivate | within file   | within file    | final<br>  private     | within scope  | within scope   | final<br></p><p>&gt; The purpose of this proposal is precisely to give library authors the ability to have more fine grained control over what capabilities their library exposes to users.<br>&gt; <br></p><p>I don’t have an issue with the purpose, I have an issue with doing it by conflating access control and finality, and making the language confusing as a result.<br></p><p>Assuming the above table matches your expectation, compare it with the same matrix for the language as it is today:<br></p><p>  access      | can access    | can subclass/  | final<br>              |               | override where |<br> -------------+---------------+----------------+-------<br>  public      | all scopes    | all scopes     | final<br>  internal    | within module | within module  | final<br>  fileprivate | within file   | within file    | final<br>  private     | within scope  | within scope   | final<br></p><p>The existing table is clean, it’s easy to understand; the two concepts are entirely separate from each other. The access control keyword defines where a class, method, property, or subscript can be accessed from; the `final` keyword defines whether or not it can be subclassed or overridden.<br></p><p><br>To give you an example of the confusion, here is code made perfectly legal by SE-0025:<br></p><p>  public final class Example {<br></p><p>    overridable func foo() {}<br></p><p>  }<br></p><p>Scott<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160706/0676b61e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July  6, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jul 6, 2016, at 5:13 PM, Scott James Remnant &lt;scott at netsplit.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 6, 2016, at 2:47 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This is not true.  Public classes will *not* be “final by default”.  It *will* be possible to subclass them within their declaring module.  If they need to be final they will still need to be marked as such.  <br>&gt;&gt; <br>&gt;&gt; With that in mind, the your “can override” column (do you really mean “can subclass” here?) is also not correct.  The correct answer is “yes, within the module”.  The fundamental difference for this row is that there are some scopes which can *see* the type without the ability to subclass it.  There is no problem with this, it is *exactly* what we want.  <br>&gt; <br>&gt; So would this be more accurate?<br>&gt; <br>&gt;   access      | can access    | can subclass/  | final<br>&gt;               |               | override where |<br>&gt;  -------------+---------------+----------------+-------<br>&gt;   open        | all scopes    | all scopes     | Error<br>&gt;   public      | all scopes    | within module  | final<br>&gt;   internal    | within module | within module  | final<br>&gt;   fileprivate | within file   | within file    | final<br>&gt;   private     | within scope  | within scope   | final<br></p><p>If you want to view “open” as an access modifier, then yes.<br></p><p>&gt; <br>&gt;&gt; The purpose of this proposal is precisely to give library authors the ability to have more fine grained control over what capabilities their library exposes to users.<br>&gt;&gt; <br>&gt; <br>&gt; I don’t have an issue with the purpose, I have an issue with doing it by conflating access control and finality, and making the language confusing as a result.<br></p><p>It’s not conflating access control and finality.<br></p><p>It is also possible to view “open” and “sealed&quot; as part of an “inheritability&quot; hierarchy rather than the access control hierarchy. <br></p><p>final                    - never subclassable / overridable<br>sealed (default)  - subclassable / overridable *within* the declaring module<br>open                   - always subclassable / overridable<br></p><p>In some sense, “open” intersects access control and inheritability:  it only makes sense on a public declarations and therefore implies public (whether we allow public to be inferred or not).<br></p><p>&gt; <br>&gt; Assuming the above table matches your expectation, compare it with the same matrix for the language as it is today:<br>&gt; <br>&gt;   access      | can access    | can subclass/  | final<br>&gt;               |               | override where |<br>&gt;  -------------+---------------+----------------+-------<br>&gt;   public      | all scopes    | all scopes     | final<br>&gt;   internal    | within module | within module  | final<br>&gt;   fileprivate | within file   | within file    | final<br>&gt;   private     | within scope  | within scope   | final<br>&gt; <br>&gt; The existing table is clean, it’s easy to understand; the two concepts are entirely separate from each other. The access control keyword defines where a class, method, property, or subscript can be accessed from; the `final` keyword defines whether or not it can be subclassed or overridden.<br></p><p>Many of us believe “final” is too blunt a tool.  There are many cases where final cannot be used but you still don’t want external users subclassing or overriding.  <br></p><p>We would like a more precise tool for these circumstances and believe if it is going to exist in Swift it should be the default.  Its behavior follows the principle of requiring programmers to explicitly make decisions about what behavior is exposed outside of a module.  You may not like that principle, but it is one that has been embraced by the language.<br></p><p>&gt; <br>&gt; <br>&gt; To give you an example of the confusion, here is code made perfectly legal by SE-0025:<br>&gt; <br>&gt;   public final class Example {<br>&gt; <br>&gt;     overridable func foo() {}<br>&gt; <br>&gt;   }<br></p><p>I have no idea how you think this is related to SE-0025 (scoped access control).  I also don’t understand why you think an `overridable` method in a `final` class would be legal under any proposal.  That is nonsense and clearly in error.<br></p><p>-Matthew<br></p><p>&gt; <br>&gt; Scott<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160706/47053e7c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c72bd3ba434ad651a5d8d3d79f2d4c49?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Scott James Remnant</string> &lt;scott at netsplit.com&gt;<p>July  6, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jul 6, 2016, at 4:34 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; Many of us believe “final” is too blunt a tool.  There are many cases where final cannot be used but you still don’t want external users subclassing or overriding.  <br>&gt; <br>&gt; We would like a more precise tool for these circumstances and believe if it is going to exist in Swift it should be the default.  Its behavior follows the principle of requiring programmers to explicitly make decisions about what behavior is exposed outside of a module.  You may not like that principle, but it is one that has been embraced by the language.<br>&gt; <br></p><p>I am all for these things, and would be in favor of a proposal that does this cleanly(*)… the proposal text I reviewed does not.<br></p><p>* e.g. the final/sealed/open keywords you suggest, with sealed being the new default, makes a huge amount of sense to me and feels clean, since it keeps access and finality separate, and as you say, explicitly make decisions in a manner otherwise consistent with the language.<br></p><p>Scott<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160706/46691aab/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July  6, 2016 at 07:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jul 6, 2016, at 6:39 PM, Scott James Remnant &lt;scott at netsplit.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 6, 2016, at 4:34 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Many of us believe “final” is too blunt a tool.  There are many cases where final cannot be used but you still don’t want external users subclassing or overriding.  <br>&gt;&gt; <br>&gt;&gt; We would like a more precise tool for these circumstances and believe if it is going to exist in Swift it should be the default.  Its behavior follows the principle of requiring programmers to explicitly make decisions about what behavior is exposed outside of a module.  You may not like that principle, but it is one that has been embraced by the language.<br>&gt; <br>&gt; I am all for these things, and would be in favor of a proposal that does this cleanly(*)… the proposal text I reviewed does not.<br>&gt; <br>&gt; * e.g. the final/sealed/open keywords you suggest, with sealed being the new default, makes a huge amount of sense to me and feels clean, since it keeps access and finality separate, and as you say, explicitly make decisions in a manner otherwise consistent with the language.<br></p><p>Great!  I agree with you that the specific details of the proposal can be improved.  The core team is free to &quot;accept with revision&quot; and that&#39;s what I hope they do in this case.<br></p><p>&gt; <br>&gt; Scott<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160706/cf3f0ca3/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c72bd3ba434ad651a5d8d3d79f2d4c49?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Scott James Remnant</string> &lt;scott at netsplit.com&gt;<p>July  6, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jul 6, 2016, at 4:34 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; To give you an example of the confusion, here is code made perfectly legal by SE-0025:<br>&gt;&gt; <br>&gt;&gt;   public final class Example {<br>&gt;&gt; <br>&gt;&gt;     overridable func foo() {}<br>&gt;&gt; <br>&gt;&gt;   }<br>&gt; <br>&gt; I have no idea how you think this is related to SE-0025 (scoped access control).  I also don’t understand why you think an `overridable` method in a `final` class would be legal under any proposal.  That is nonsense and clearly in error.<br>&gt; <br></p><p>SE-0117, which we are reviewing here, in its introduction introduces the new `subclassable` and `overridable` modifiers in a discussion about `public`, and indicates that they are used instead of that keyword. This to me strongly implies that these are in the same family as the access control modifiers.<br></p><p>SE-0025 removes the error when the access of a member within a type is less restrictive, thus removes the error that would otherwise occur with the above code.<br></p><p><br>Consider this another strong argument for keeping access and inheritability separate, the following code would be obviously an error/warning since `open` makes no sense within a `final` class:<br></p><p>  public final class Example {<br></p><p>    public open func foo() {}<br></p><p>  }<br></p><p>Clarity is always a goal for Swift. This to me has more of it than replacing `public`.<br></p><p>Scott<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160706/4bce3eaf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July  6, 2016 at 07:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jul 6, 2016, at 6:47 PM, Scott James Remnant &lt;scott at netsplit.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Jul 6, 2016, at 4:34 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To give you an example of the confusion, here is code made perfectly legal by SE-0025:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   public final class Example {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     overridable func foo() {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; I have no idea how you think this is related to SE-0025 (scoped access control).  I also don’t understand why you think an `overridable` method in a `final` class would be legal under any proposal.  That is nonsense and clearly in error.<br>&gt; <br>&gt; SE-0117, which we are reviewing here, in its introduction introduces the new `subclassable` and `overridable` modifiers in a discussion about `public`, and indicates that they are used instead of that keyword. This to me strongly implies that these are in the same family as the access control modifiers.<br>&gt; <br>&gt; SE-0025 removes the error when the access of a member within a type is less restrictive, thus removes the error that would otherwise occur with the above code.<br></p><p>SE-0025 says nothing about final though.  I really don&#39;t think we would allow overridable in a final class in any case.<br></p><p>I do think it&#39;s fair to point out that details like is are not fully specified in the proposal and  should be (in order to avoid another round of cleanup similar to what was necessary for SE-0025).<br></p><p>&gt; <br>&gt; <br>&gt; Consider this another strong argument for keeping access and inheritability separate, the following code would be obviously an error/warning since `open` makes no sense within a `final` class:<br>&gt; <br>&gt;   public final class Example {<br>&gt; <br>&gt;     public open func foo() {}<br>&gt; <br>&gt;   }<br>&gt; <br>&gt; Clarity is always a goal for Swift. This to me has more of it than replacing `public`.<br>&gt; <br>&gt; Scott<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160706/de4a7e0d/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>July  6, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; The review of &quot;SE-0117: Default classes to be non-subclassable publicly&quot; begins now and runs through July 11. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt; <br></p><p>I posted this somewhere else in another thread, but I still think a slightly different approach to all of the access namings might make more sense:<br></p><p>- everything is “sealed&quot; within its module by default, no keyword for this<br></p><p>- use “export” (formerly “public”) to mean “visible outside of the module, no subclassing or overriding externally, but overriding and subclasses allowed internally unless otherwise restricted”<br></p><p>- use “export(public)” to mean “visible outside of the module, can be subclassed or overridden externally”<br></p><p>- “export final” means that the class/method is also final within its own module<br></p><p>- using “export(public) final” *probably* doesn’t make sense, but would mean overriding/subclasses allowed externally, but not internally<br></p><p>My argument for “export” here is that it is the logical inverse of “import” which is how you get another module’s stuff into your module in the first place.<br></p><p>Then I would want to consider a rename of “internal” to “public” and “fileprivate” to “internal” so the complete list would be:<br></p><p>export - accessible outside of the module<br>public - accessible anywhere within the module<br>private - accessible only within the scope <br>internal - accessible within the same source file<br></p><p>In this way, there is nice symmetry between import/export, and then again between public/private. The source-file-based grouping of “internal” now has a name that is more unique and not immediately related to the other access keywords, either, which makes sense since it’s on a slightly different axis.<br></p><p>After all of this, the “export(public)” case rational would seem to be logical - you’re saying that the symbol is accessible outside of *this* module and subclassable/overridable within the “public” context of whatever module is importing it - hence using both “export” and “public”.<br></p><p>So anyway, I don’t know if this counts as a -1 vote or not or if this is even coherent, but this is my feedback at the moment. :)<br></p><p>l8r<br>Sean<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>July  6, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; * What is your evaluation of the proposal?<br></p><p>+1, with bikeshedding.<br></p><p>To me, “subclassable” does not imply “public.” If I hadn’t read this proposal, I would be likely to declare an internal class subclassable, and then be shocked when it was exposed as public!<br></p><p>If it’s part of my public API, I want to see the word “public” on it. That should not be implicit under any circumstances. I strongly prefer any one of these to the standalone “subclassable:”<br></p><p>	• public(subclassable)<br>	• public(open)<br>	• public(extensible)<br></p><p>The extra verbosity is tolerable because subclassability by design is (should be!) the exception, not the rule.<br></p><p>&gt; * Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes, it fits two patterns of Swift’s general design:<br></p><p>if one choice is the default, it is the safer one; and<br>consequential design decisions are explicit. Implicitness is reserved for obvious / redundant information that becomes noise and interferes with readability.<br></p><p>To that end…<br></p><p>&gt; * Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>…open public classes run against general precedent in the language, so yes.<br></p><p>As programmers grow used to Swift, they will increasingly lean on the compiler to prompt them when there is an important type design issue to consider, or when they are doing something that compromises type safety. The absence of a compiler warning becomes important information.<br></p><p>This means that making open classes the default is not just aesthetically suboptimal; it is actively misleading.<br></p><p>&gt; * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>No. In all the OO languages I’ve used, classes are open by default. That raises a question: is this really a good idea? Aren’t we ignoring established precedent? What about all the unauthorized subclassing we’ve done in the past?<br></p><p>I’m sympathetic to those accustomed to Objective-C, Ruby, Javascript, Python, and other languages with more fungible type systems who argue that it’s unreasonable to expect us all to use classes only as library authors intend. Monkey patching has saved many a day, they’d say. And it’s true, it has! I rely on it.<br></p><p>My counterargument: the ecosystem is changing.<br></p><p>In the era of increased open sourcing, easy forking, and more community-driven development, this concern is less severe than it used to be. I rarely use any closed-sourced libraries for iOS development. If I need to tweak some library and non-subclassibility is getting in the way, then I can fork it — and perhaps even contribute my changes back to improve the upstream project. In an open source world, “closed by default” makes a lot more sense.<br></p><p>The big exception to this is Apple itself, and the direction of this proposal implies a large cultural shift in how Apple deals with its developer community. Having the Swift language so aggressively prevent the dubious, brittle, bad-idea-but-it-gets-the-job-done workarounds that the Obj-C runtime allowed means that Apple’s platforms are going to have to be more consciously extensible, more transparent in their design decisions, and more responsive to unanticipated needs. This community right here is an exemplar.<br></p><p>Here’s thing: this big shift goes far, far beyond this proposal. Swift already rules out most any form of messing with a library’s assumptions about its own design. With or without the proposal, Apple is already getting on board with the new regime of stricter typing and more hermetically sealed libraries. They’re already going to have to make API design decisions about how and where extensibility is allowed with unprecedented caution.<br></p><p>This proposal hardly alters that tipping balance; it just removes a design inconsistency.<br></p><p>&gt; * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I read the proposal carefully, the discussion thread not at all.<br></p><p>Cheers,<br></p><p>Paul<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160706/e741430d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>July  6, 2016 at 09:00:00pm</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On 6 Jul 2016, at 21:22, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; In the era of increased open sourcing, easy forking, and more community-driven development, this concern is less severe than it used to be. I rarely use any closed-sourced libraries for iOS development. If I need to tweak some library and non-subclassibility is getting in the way, then I can fork it — and perhaps even contribute my changes back to improve the upstream project. In an open source world, “closed by default” makes a lot more sense.<br></p><p>Maintaining a fork, realistically often without hope of upstream merging, your changes is feels like a very business unfriendly idea and less scalable than it sounds in many environments.<br></p><p>I see closed by default as part of the movement some people seem to be embracing of opt-out model in which freedom and versatility is forcefully restrained, making the language more complex and exotic/breaking conventions for the sake of protecting people from themselves, instead of opt-in models which require programmers to be diligent and know when to constrain themselves while enjoying more flexible defaults.<br>I am not asking for JavaScript, but I do not want this language to go the complete polar opposite, more dogmatic than C++ or Java.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>July  6, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jul 6, 2016, at 3:41 PM, Goffredo Marocchi &lt;panajev at gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; On 6 Jul 2016, at 21:22, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; In the era of increased open sourcing, easy forking, and more community-driven development, this concern is less severe than it used to be. I rarely use any closed-sourced libraries for iOS development. If I need to tweak some library and non-subclassibility is getting in the way, then I can fork it — and perhaps even contribute my changes back to improve the upstream project. In an open source world, “closed by default” makes a lot more sense.<br>&gt; <br>&gt; Maintaining a fork, realistically often without hope of upstream merging, your changes is feels like a very business unfriendly idea and less scalable than it sounds in many environments.<br></p><p>It certainly has its problems, but in practice it’s no worse than brittle workarounds such as unintended subclassing.<br></p><p>In the case of forking, upgrading a library comes with the cost of merging changes. In the case of brittle subclassing, upgrading a library comes with the cost of your patches suddenly breaking. In either case, you have a body of code which is tightly coupled to an external library in ways that the library&#39;s author isn’t monitoring for breakage.<br></p><p>In my experience, forking is usually the less costly route because it gives more control. Modern version control makes maintaining a fork over time much easier than it used to be — and the ever-improving social dynamics of pull requests make forks less likely to live on forever.<br></p><p>Cheers,<br></p><p>Paul<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>July  6, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jul 6, 2016, at 1:41 PM, Goffredo Marocchi via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Sent from my iPhone<br>&gt; <br>&gt;&gt; On 6 Jul 2016, at 21:22, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; In the era of increased open sourcing, easy forking, and more community-driven development, this concern is less severe than it used to be. I rarely use any closed-sourced libraries for iOS development. If I need to tweak some library and non-subclassibility is getting in the way, then I can fork it — and perhaps even contribute my changes back to improve the upstream project. In an open source world, “closed by default” makes a lot more sense.<br>&gt; <br>&gt; Maintaining a fork, realistically often without hope of upstream merging, your changes is feels like a very business unfriendly idea and less scalable than it sounds in many environments.<br>&gt; <br>&gt; I see closed by default as part of the movement some people seem to be embracing of opt-out model in which freedom and versatility is forcefully restrained, making the language more complex and exotic/breaking conventions for the sake of protecting people from themselves, instead of opt-in models which require programmers to be diligent and know when to constrain themselves while enjoying more flexible defaults.<br>&gt; I am not asking for JavaScript, but I do not want this language to go the complete polar opposite, more dogmatic than C++ or Java.<br></p><p>This proposal is specifically targeting library interfaces.  It&#39;s not a slippery slope towards locking things down at a sub-library level because (1) we&#39;ve already considered and rejected the analogous sub-library-level proposal (as &quot;final by default&quot;) and (2) almost all of the justifications are tied to the specific problems that arise with library interfaces.<br></p><p>In general, Swift already treats library interfaces as a special point at which a lot of considerations change.  The most prominent example of that is access control, but there are a lot of other examples that will become more apparent as we complete the resilience model, solidify the ABI, and start really supporting binary distribution of libraries.  The basic idea is that library designers face a set of language problems that other programmers don&#39;t, and the language ought to understand that and provide a different set of features and defaults.  This is a language design that&#39;s made possible by Swift&#39;s relatively strong commitment to defining and enforcing library boundaries, as opposed to the languages you list.  To me, this is a great way to only get dogmatism when it&#39;s actually useful and necessary.<br></p><p>John.<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>July  7, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt;  In an open source world, “closed by default” makes a lot more sense.<br>That sounds Orwellian to me: <br>War is Peace, Freedom is Slavery, Ignorance is Strength — and sealed is open?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160707/170a2dd7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>July  7, 2016 at 02:00:00pm</p></header><div class="content"><p>lol :)<br></p><p>On Thu, Jul 7, 2016 at 1:41 PM, Tino Heth via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt;  In an open source world, “closed by default” makes a lot more sense.<br>&gt;<br>&gt; That sounds Orwellian to me:<br>&gt; War is Peace, Freedom is Slavery, Ignorance is Strength — and sealed is<br>&gt; open?<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160707/7a29b004/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/15ed660cd9d971062f9dd5084932a698?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>David Rönnqvist</string> &lt;david.ronnqvist at gmail.com&gt;<p>July  6, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt;   * What is your evaluation of the proposal?<br></p><p>+1 (almost exclusively)<br></p><p>Writing good library code is hard and a lot of code isn&#39;t actually written to be externally subclasses (and trying to plan for subclassing can be difficult). Our team also writes &quot;final class&quot; in a lot of places and I don&#39;t like it (but wouldn&#39;t want final by default either).<br></p><p>This proposal feels like a sensible trade off to me. Having to intentionally mark classes for public subclassability leads to better safety (only classes being intended for external subclassing actually being subclassable), clarity (by documenting what&#39;s designed for subclassing/overriding), performance (by enabling optimizations if a class isn&#39;t subclasses internally) while still providing convenience within the module (enabling the authoring team to subclass and not having to put final throughout).<br></p><p>There is some negative with regards to limiting the ability to patch third party code, but I think the benefits of this proposal are worth that.<br></p><p>The behavior of Objective-C classes and @testablity are an important part of this proposal.<br></p><p>Bike sheding:<br></p><p>The subclassable/overridable pair read well on their own but it&#39;s not obvious to me that subclassable is also public and that it&#39;s not needed internally. This could be helped by requiring &quot;subclassable&quot; classes to also be marked &quot;public&quot; and making it an error to declare a class as &quot;internal subclassable&quot; or &quot;private subclassable&quot; (all 3 could have a simple fix-it).<br></p><p>I would also be fine with either &quot;open&quot; or &quot;extensible&quot; (although I could see &quot;extensible&quot; being interpreted as &quot;can have extensions&quot; instead of &quot;can be subclasses&quot;).<br></p><p>&gt;    * Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;    * Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes. Being safe by default is well aligned with Swift. I would also argue that the same applies to being explicit about the authors intentions where it&#39;s needed. <br></p><p>&gt;    * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>None. Objective-C is completely open and I can&#39;t recall any other language that differentiates between &quot;public&quot; and &quot;public subclassable&quot;.<br></p><p>&gt;    * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p><br>Read the proposal and the review feedback so far.<br></p><p>- David<br></p><p>&gt; On 6 Jul 2016, at 01:11, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;SE-0117: Default classes to be non-subclassable publicly&quot; begins now and runs through July 11. The proposal is available here:<br>&gt; <br>&gt;    https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt;    https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt;    * What is your evaluation of the proposal?<br>&gt;    * Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;    * Does this proposal fit well with the feel and direction of Swift?<br>&gt;    * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;    * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt;    https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b1fc4ed1ed8e138ef0a87fd3e91c83a4?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Ricardo Parada</string> &lt;rparada at mac.com&gt;<p>July  6, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Jul 5, 2016, at 7:11 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;SE-0117: Default classes to be non-subclassable publicly&quot; begins now and runs through July 11. The proposal is available here:<br>&gt; <br>&gt;    https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt; <br>&gt;    * What is your evaluation of the proposal?<br></p><p>-1<br></p><p>Perhaps because this is so different from what I have seen in other languages and used for so many years. I have not worked with a language that uses non-subclassable/ non-overridable as the default. <br></p><p>I think that by default classes should be subclassable, not the other way around. I am afraid that developers will not take the time to specify which methods are overridable resulting in libraries that are difficult to patch, extend. <br></p><p>In my 26+ years of object-oriented design and programming (other languages, Objective-C since 1990 and Java since 2001) I have worked with object oriented libraries and subclassed methods that the authors probably never anticipated. I have been able to fix problems, enhance classes by creating subclasses with fixes and enhanced behavior. <br></p><p>In java for example I have seen that sometimes I would have been able to fix bugs or enhance the existing classes had the author not chosen a method to be protected or private. Sometimes they had a good reason but sometimes they didn&#39;t.  Is have been able to survive using an awesome library that was discontinued and end-of-lifed thanks to subclassing that has allowed me to fix problems and enhance over the years as the Java language kept evolving. <br></p><p>In general I like to design classes with methods that have a very well defined purpose / logic. Such methods are potentially overridable. I find that making a method private or final can be selfish / restrictive at times and I choose it carefully for implementation details that are better served by going through the public methods. <br></p><p>I think that making a class not subclassable by default is restrictive / limiting / selfish. <br></p><p>Sometimes the extension points are clear. <br>I also think that every other method with a well defined purpose / logic is also potentially an extension point. <br></p><p>In my experience we should allow the developer to override by default.  That is how I design my classes and every method / property. <br></p><p>I use private for the stuff that is obvious that should not be exposed. <br></p><p>In the motivation section performance is also mentioned as driving this proposal. However I don&#39;t see any study that supports that. I would like to see that. This should not be taken lightly. <br></p><p>Let&#39;s imagine that performance is important for a library that is heavily used and that the classes are not the type that you usually override. Wouldn&#39;t we be better served  by being able to seal the class, i.e. &quot;public sealed class Foo&quot;  and then for the methods / properties that are clear extension points should be flagged overridable.  I would prefer something like that. And I think it would be more intuitive. <br></p><p><br>&gt;    * Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>No. <br></p><p>&gt;    * Does this proposal fit well with the feel and direction of Swift?<br></p><p>I think it is counter-intuitive. I don&#39;t think that reading &quot;public class Foo&quot; would make anyone think that Foo is non-subclassable. <br></p><p>On the other hand, reading &quot;public class sealed Foo&quot; would suggest to the reader that the class can be overridden but only the methods that are flagged as overridable. <br></p><p>If we wanted to prohibit overriding then we could use &quot;public final class Foo&quot; without any extension points. Then nobody would be able to subclass and it would be an error to try to flag a method / property as overridable.      <br></p><p><br>&gt;    * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>I don&#39;t recall having seen this behavior in the languages that I have worked with. <br></p><p>&gt;    * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I read the whole proposal and have been thinking about the implications for a few hours. <br></p><p>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt;    https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution-announce mailing list<br>&gt; swift-evolution-announce at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution-announce<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160706/e485c3a0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>July  7, 2016 at 06:00:00am</p></header><div class="content"><p>&gt; On Jul 7, 2016, at 1:10 AM, Ricardo Parada via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; In the motivation section performance is also mentioned as driving this proposal. However I don&#39;t see any study that supports that. I would like to see that. This should not be taken lightly. <br></p><p>There kind of was a discussion on this.<br></p><p>John McCall (http://article.gmane.org/gmane.comp.lang.swift.evolution/22111 &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/22111&gt;)<br></p><p>&gt; Finally, the specific form of devirtualization in question here, where a method is proven to never be overridden (again, very common for accessors!), can have a significant impact separate from any calls because the method essentially no longer needs to be virtual.  That is, it can be removed from the virtual method tables completely, and we may be able to completely avoid emitting it.  That shrinks the size of global memory (and the binary), decrease the amount of work that has to be done at load-time, and improves locality within the virtual table.<br></p><p><br>I remember that he&#39;s mentioned some benchmark final vs. non-final where the difference was in some cases staggering. In general, when you enable whole-module optimization, the compiler can treat all classes within the module as final and optimize mainly accessing properties since they are then known to be final...<br></p><p><br></p><p>&gt; <br>&gt; Let&#39;s imagine that performance is important for a library that is heavily used and that the classes are not the type that you usually override. Wouldn&#39;t we be better served  by being able to seal the class, i.e. &quot;public sealed class Foo&quot;  and then for the methods / properties that are clear extension points should be flagged overridable.  I would prefer something like that. And I think it would be more intuitive. <br>&gt; <br>&gt; <br>&gt;&gt;    * Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; <br>&gt; No. <br>&gt; <br>&gt;&gt;    * Does this proposal fit well with the feel and direction of Swift?<br>&gt; <br>&gt; I think it is counter-intuitive. I don&#39;t think that reading &quot;public class Foo&quot; would make anyone think that Foo is non-subclassable. <br>&gt; <br>&gt; On the other hand, reading &quot;public class sealed Foo&quot; would suggest to the reader that the class can be overridden but only the methods that are flagged as overridable. <br>&gt; <br>&gt; If we wanted to prohibit overriding then we could use &quot;public final class Foo&quot; without any extension points. Then nobody would be able to subclass and it would be an error to try to flag a method / property as overridable.      <br>&gt; <br>&gt; <br>&gt;&gt;    * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; <br>&gt; I don&#39;t recall having seen this behavior in the languages that I have worked with. <br>&gt; <br>&gt;&gt;    * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; I read the whole proposal and have been thinking about the implications for a few hours. <br>&gt; <br>&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt; <br>&gt;&gt;    https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt;&gt; <br>&gt;&gt; Thank you,<br>&gt;&gt; <br>&gt;&gt; -Chris Lattner<br>&gt;&gt; Review Manager<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution-announce mailing list<br>&gt;&gt; swift-evolution-announce at swift.org &lt;mailto:swift-evolution-announce at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution-announce &lt;https://lists.swift.org/mailman/listinfo/swift-evolution-announce&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160707/424039ea/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>July  7, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jul 5, 2016, at 4:11 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;SE-0117: Default classes to be non-subclassable publicly&quot; begins now and runs through July 11. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br></p><p>I think the goals are laudable but a -1 to the proposal as written. It conflates different things and magically having different behavior inside and outside the module. It seems to add a higher cognitive burden than is really necessary… I imagine trying to explain the behavior to a Swift newcomer and it never being clear on the first attempt. Subclassability is a separate concern from visibility, plus final doesn’t cleanly compose with this design.<br></p><p>IMHO It makes no sense to have a member that is public, non-virtual to external consumers, but overridable to internal consumers. If that’s the case, why not just use a protocol to completely hide the type? It just doesn’t seem like a common case to me.<br></p><p><br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes<br></p><p>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>C# makes members non-virtual by default, so visibility naturally controls who can see the type and virtual controls subclassing/overriding. Of course C# has protected, which controls visibility to subclassers so you can mark things as internal protected virtual, then the overall type as public virtual. Someone can still subclass but it doesn’t matter because they can’t override anything as all the protected override points are internal… not that it was very common!<br></p><p>When you’re designing things for easy subclassing I found it much more useful to offer protected members as the override points without letting subclassers override the public interface. Much less opportunity for them to screw things up, forget to call super, etc. In the rare case where I wanted to allow them to skip super’s implementation I just added that as a parameter to the protected member.<br></p><p><br>Russ<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>July  8, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; Chris Lattner wrote:<br>&gt; <br>&gt; The review of &quot;SE-0117: Default classes to be non-subclassable publicly&quot; begins now and runs through July 11. The proposal is available here:<br>&gt; <br>&gt;    https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt; <br>&gt;    * What is your evaluation of the proposal?<br></p><p>+0.9. I&#39;m positive with making the subclassability of exported classes explicit, but I&#39;d reconsider the keywords proposed.<br></p><p>Given how the ecosystem has shaped up so far, there are very few cases where Swift classes could be realistically patched by subclassing and overriding. Instead, forking and recontributing open-source code is the better way to go. From my OOP in any programming languages, almost all unplanned (by library author) uses of subclassing have become terrible hacks that were hard to maintain in application code. And I don&#39;t want to imagine having to maintain a library that multiple users have patched by subclassing without a documentation of the contract between the superclass and its subclasses.<br></p><p>In Swift, classes seem to be most essentially about reference semantics and not so much about inheritance. With that, I think it&#39;s better that unlimited subclassing becomes a conscious choice by the library author, so that we also increase the probability of remembering to document what can be overridden and how. Originally, I would&#39;ve even supported making `final` the default, but adding the new &quot;sealed&quot; inheritance mode is a very good compromise that makes life easier when writing application code.<br></p><p>Sealed classes also open a new language design opportunity where `switch` cases can be proven total given a sealed class type as argument.<br></p><p>However, I also think we shouldn&#39;t merge the the `public` modifier with the newly proposed keywords. From the alternatives mentioned so far, I&#39;d give my +1 to `public open class/func` or the spelling `public(open) class`. In this position, I think it&#39;ll be unambiguous given context whether `open` acts as a keyword or not.<br></p><p>Alternatively, we could reuse the `super` keyword in this context; the only minor issue I can see in `public super class` (besides that &quot;superclass&quot; should be written without a space) is that public unsealed classes aren&#39;t the only publicly visible superclasses (sealed classes are also publicly superclasses of their public subclasses). Well, and that the &quot;superfunc&quot; in `public super func` would be an unfamiliar term, even if it&#39;s easily taught as the kind of function which you should consider calling as `super.foo(...)` somewhere in an override.<br></p><p>The proposal also left open whether the subclassability is inherited in subclasses. I think it&#39;s clear that the answer is &quot;no&quot;, and thus every subclass of a publicly subclassable superclass is only publicly subclassable if explicitly marked so.<br></p><p>&gt;    * Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes, Swift should use language design opportunities like this to statically encourage thoughtful library design.<br></p><p>&gt;    * Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes. It also doesn&#39;t take away the option yo make well-thought use of OOP better in the future, such as abstract classes.<br></p><p>&gt;    * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>N/A.<br></p><p>&gt;    * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>Quick reading or a bit more.<br></p><p>— Pyry<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be09ed656d5d90501c958b001261f218?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Jeremy Pereira</string> &lt;jeremy.j.pereira at googlemail.com&gt;<p>July  8, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On 6 Jul 2016, at 00:11, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; <br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br></p><p>-1<br></p><p>In general terms, the philosophy “you are not allowed to do stuff with my classes unless I say so” is repugnant to me. Also, the breakages in existing code would be more serious than usual.<br></p><p>The specifics:<br></p><p>Firstly, making a class public does not provide “two different” capabilities, it provides one: the class is now accessible outside the module. Using a class includes instantiating it, calling functions, accessing properties and also subclassing non final classes and methods. If you choose to make a method or class public you are already having to carefully consider its design perhaps adding guards for parameters validationetc. In this context, adding final is not really onerous.<br></p><p>Secondly, if you don’t want to go to the trouble of making your class work properly, you already have the option of making it final.<br></p><p>Thirdly, this is a huge breaking change. Not only is it a breaking change, but for a lot of people, the breakages will be outside of their control. Consider if I publish a module with a class with public methods and you subclass it in your code. Once this change is implemented, my code will still compile and pass its unit tests but your code is now broken and you are dependent on me changing my code to fix your code. <br></p><p>Fourthly, the optimisation point is a red herring. Premature optimisation is the root of all evil, they say. This is premature optimisation. In any program, the number of methods where eliminating dynamic dispatch would provide a visible benefit is tiny. In those cases, you can add the word final to the declaration (after proper performance testing).<br></p><p><br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>The functionality to stop people subclassing and overriding where it would be dangerous to do so already exists and this coupled with the serious problem of breaking code where the fix is outside the developer’s control makes it a very bad change indeed.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>No. Swift feels to me like a really nice powerful language that is easy to program in. Hopefully the direction of Swift is more of the same. This change is going the other way.<br></p><p>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>I have used many languages with classes with inheritance: Java, C++, Python, Objective-C, C#, Smalltalk. They all more or less follow the current Swift convention (in C++ you had to explicitly say if a method was virtual and that could be quite confusing).<br></p><p><br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I read the proposal and some of the other responses.<br></p><p><br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c40db4457ab2c91a0d8006da31b177c6?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Trent Nadeau</string> &lt;tanadeau at gmail.com&gt;<p>July  8, 2016 at 11:00:00am</p></header><div class="content"><p>On Tue, Jul 5, 2016 at 7:11 PM, Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hello Swift community,<br>&gt;<br>&gt; The review of &quot;SE-0117: Default classes to be non-subclassable publicly&quot;<br>&gt; begins now and runs through July 11. The proposal is available here:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt; should be sent to the swift-evolution mailing list at<br>&gt;<br>&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the<br>&gt; review manager.<br>&gt;<br>&gt; What goes into a review?<br>&gt;<br>&gt; The goal of the review process is to improve the proposal under review<br>&gt; through constructive criticism and contribute to the direction of Swift.<br>&gt; When writing your review, here are some questions you might want to answer<br>&gt; in your review:<br>&gt;<br>&gt;         * What is your evaluation of the proposal?<br>&gt;<br>A strong +1 to the new default. I agree with others that having two<br>keywords that also conflate/imply public access is less than ideal. Having<br>a `public(open) class` or `public open class` would be better in my opinion.<br></p><p>&gt;         * Is the problem being addressed significant enough to warrant a<br>&gt; change to Swift?<br>&gt;<br>Yes.<br></p><p>&gt;         * Does this proposal fit well with the feel and direction of Swift?<br>&gt;<br>Yes. Requiring extra keywords and safety at module boundaries to clarify<br>intent has been a philosophy toward Swift language changes.<br></p><p>&gt;         * If you have used other languages or libraries with a similar<br>&gt; feature, how do you feel that this proposal compares to those?<br>&gt;<br>N/A<br></p><p>&gt;         * How much effort did you put into your review? A glance, a quick<br>&gt; reading, or an in-depth study?<br>&gt;<br>Read the proposal as well as this and earlier discussions.<br></p><p>&gt;<br>&gt; More information about the Swift evolution process is available at<br>&gt;<br>&gt;         https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;<br>&gt; Thank you,<br>&gt;<br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br></p><p>-- <br>Trent Nadeau<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160708/e92329a5/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>July  8, 2016 at 09:00:00pm</p></header><div class="content"><p>[Proposal: https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md ]<br></p><p>John has done a tremendous job supporting this proposal; the position he’s articulated very closely matches mine. Thank you to both John and Javier. <br></p><p>I wanted to share a concrete use case that Daniel Dunbar relayed to me. He was working on a closed class hierarchy like the ones discussed here, where all of the subclasses are within a single module, but they are all public. The class also has a required initializer for dynamic construction, so that they could write something like this:<br></p><p>internal struct ModelContext { /*…*/ }<br></p><p>public class ModelBase {<br>  internal required init(context: ModelContext) { /*…*/ }<br>  // …<br>}<br>public class SimpleModel: ModelBase {<br>  internal required init(context: ModelContext) { /*…*/ }<br>}<br>public class MoreComplicatedModel: ModelBase { /*…*/ }<br></p><p>// (within some other type)<br>public func instantiateModelObject&lt;Model: ModelBase&gt;(_ type: Model) -&gt; Model {<br>  return type.init(context: self.context)<br>}<br></p><p>That is, a public entry point calls a required initializer with an internal argument type. This is the only way to instantiate Model objects, and the internal context type doesn’t leak out into the public API.<br></p><p>Of course, Swift doesn’t allow this. If someone outside of the module subclasses ModelBase, there’s no way for them to provide the dynamically-dispatched &#39;init(context:)’, because they don’t have access to the internal ModelContext. The author of the library has to make the required initializers public, and either set the ModelContext separately or make it public as well. Even though no one outside the module should be using these APIs.<br></p><p>If ModelBase were public-but-not-subclassable, however, the code is perfectly fine. The initializer and the helper type don’t need to be public, and clients of the library see only what they need.<br></p><p>This is just one use case. I don’t want to say it’s a general model for everyone’s code. However, it does point to a desire for public-and-not-subclassable classes; any other solution would either require the library author making more things public, or the compiler making it possible to accidentally call an unimplemented initializer.<br></p><p>I’ll send a separate message with my thoughts as the primary author of the Library Evolution model, to keep those discussions distinct. That one will have a bit more ideology in it. :-)<br></p><p>Jordan<br></p><p>P.S. “Why not use protocols?” When a protocol has an initializer requirement, it still forces all subclasses of a conforming class to provide an implementation, i.e. the conforming class’s initializer still needs to be declared ‘required’. That means it’s subject to the same restriction: a required initializer must have as much access as the containing class.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160708/2f002783/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>July  9, 2016 at 08:00:00am</p></header><div class="content"><p>Regards<br>(From mobile)<br></p><p>&gt; On Jul 9, 2016, at 6:39 AM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; [Proposal: https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md ]<br>&gt; <br>&gt; John has done a tremendous job supporting this proposal; the position he’s articulated very closely matches mine. Thank you to both John and Javier. <br>&gt; <br>&gt; I wanted to share a concrete use case that Daniel Dunbar relayed to me. He was working on a closed class hierarchy like the ones discussed here, where all of the subclasses are within a single module, but they are all public. The class also has a required initializer for dynamic construction, so that they could write something like this:<br>&gt; <br>&gt; internal struct ModelContext { /*…*/ }<br>&gt; <br>&gt; public class ModelBase {<br>&gt;   internal required init(context: ModelContext) { /*…*/ }<br>&gt;   // …<br>&gt; }<br>&gt; public class SimpleModel: ModelBase {<br>&gt;   internal required init(context: ModelContext) { /*…*/ }<br>&gt; }<br>&gt; public class MoreComplicatedModel: ModelBase { /*…*/ }<br>&gt; <br>&gt; // (within some other type)<br>&gt; public func instantiateModelObject&lt;Model: ModelBase&gt;(_ type: Model) -&gt; Model {<br>&gt;   return type.init(context: self.context)<br>&gt; }<br>&gt; <br>&gt; That is, a public entry point calls a required initializer with an internal argument type. This is the only way to instantiate Model objects, and the internal context type doesn’t leak out into the public API.<br></p><p>Then could it be that in the end it is the entire scaffolding that is poorly structured and in need of fixing, rather than altering the language to make the scaffolding work?<br></p><p><br>&gt; <br>&gt; Of course, Swift doesn’t allow this. If someone outside of the module subclasses ModelBase, there’s no way for them to provide the dynamically-dispatched &#39;init(context:)’, because they don’t have access to the internal ModelContext. The author of the library has to make the required initializers public, and either set the ModelContext separately or make it public as well. Even though no one outside the module should be using these APIs.<br>&gt; <br>&gt; If ModelBase were public-but-not-subclassable, however, the code is perfectly fine. The initializer and the helper type don’t need to be public, and clients of the library see only what they need.<br>&gt; <br>&gt; This is just one use case. I don’t want to say it’s a general model for everyone’s code. However, it does point to a desire for public-and-not-subclassable classes; any other solution would either require the library author making more things public, or the compiler making it possible to accidentally call an unimplemented initializer.<br>&gt; <br>&gt; I’ll send a separate message with my thoughts as the primary author of the Library Evolution model, to keep those discussions distinct. That one will have a bit more ideology in it. :-)<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; P.S. “Why not use protocols?” When a protocol has an initializer requirement, it still forces all subclasses of a conforming class to provide an implementation, i.e. the conforming class’s initializer still needs to be declared ‘required’. That means it’s subject to the same restriction: a required initializer must have as much access as the containing class.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160709/59f4b75d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>July 10, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jul 8, 2016, at 23:47, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Regards<br>&gt; (From mobile)<br>&gt; <br>&gt; On Jul 9, 2016, at 6:39 AM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; [Proposal: https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md&gt; ]<br>&gt;&gt; <br>&gt;&gt; John has done a tremendous job supporting this proposal; the position he’s articulated very closely matches mine. Thank you to both John and Javier. <br>&gt;&gt; <br>&gt;&gt; I wanted to share a concrete use case that Daniel Dunbar relayed to me. He was working on a closed class hierarchy like the ones discussed here, where all of the subclasses are within a single module, but they are all public. The class also has a required initializer for dynamic construction, so that they could write something like this:<br>&gt;&gt; <br>&gt;&gt; internal struct ModelContext { /*…*/ }<br>&gt;&gt; <br>&gt;&gt; public class ModelBase {<br>&gt;&gt;   internal required init(context: ModelContext) { /*…*/ }<br>&gt;&gt;   // …<br>&gt;&gt; }<br>&gt;&gt; public class SimpleModel: ModelBase {<br>&gt;&gt;   internal required init(context: ModelContext) { /*…*/ }<br>&gt;&gt; }<br>&gt;&gt; public class MoreComplicatedModel: ModelBase { /*…*/ }<br>&gt;&gt; <br>&gt;&gt; // (within some other type)<br>&gt;&gt; public func instantiateModelObject&lt;Model: ModelBase&gt;(_ type: Model) -&gt; Model {<br>&gt;&gt;   return type.init(context: self.context)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; That is, a public entry point calls a required initializer with an internal argument type. This is the only way to instantiate Model objects, and the internal context type doesn’t leak out into the public API.<br>&gt; <br>&gt; Then could it be that in the end it is the entire scaffolding that is poorly structured and in need of fixing, rather than altering the language to make the scaffolding work?<br></p><p>I’m afraid it isn’t my codebase, so I can’t speak to this directly, but I don’t see anything wrong with this pattern. Dynamic initialization is useful, and internal, component-specific context is hardly uncommon; if the library used either of these alone we would likely have no problem with it. Two features not composing well does sometimes indicate a flaw in the design.<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160710/0c0c96ca/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>July  9, 2016 at 09:00:00am</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On 9 Jul 2016, at 05:39, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Of course, Swift doesn’t allow this. If someone outside of the module subclasses ModelBase, there’s no way for them to provide the dynamically-dispatched &#39;init(context:)’, because they don’t have access to the internal ModelContext.<br></p><p>Shouldn&#39;t Swift allow this? Wouldn&#39;t it be better if we found a different way to handle this than a brute force &quot;you shall only subclass if I think you should&quot;? Is that really an impossible cause that is worth us going completely the opposite direction of most programming languages?<br></p><p>Can you tell me why the onus should not be on you, on library authors, to use final or an equivalent keyword to indicate no subclassing is allowed and thus make this intentional?<br></p><p>I am really not sold on why classes should not be subclassable by default. Not all classes suffer of the problem you mention and for those cases you should be able to express your intention explicitly. I am quite against this being a compiler default.<br></p><p>I think that security by ignorance, which is what automagically enforced rules tend to produce over time, does have some side effects.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>July 10, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jul 9, 2016, at 01:44, Goffredo Marocchi &lt;panajev at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt;&gt; On 9 Jul 2016, at 05:39, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Of course, Swift doesn’t allow this. If someone outside of the module subclasses ModelBase, there’s no way for them to provide the dynamically-dispatched &#39;init(context:)’, because they don’t have access to the internal ModelContext.<br>&gt; <br>&gt; Shouldn&#39;t Swift allow this? Wouldn&#39;t it be better if we found a different way to handle this than a brute force &quot;you shall only subclass if I think you should&quot;? Is that really an impossible cause that is worth us going completely the opposite direction of most programming languages?<br></p><p>There is no way to implement the required initializer from outside the module, because it uses an internal type, so what we’re looking for is that any subclasses from outside the module will never have the required initializer invoked on them. I suppose it would still be safe to allow a subclass from outside the module that did not provide any of its own initializers, but that seems like an even more complicated rule.<br></p><p>(It’s not sufficient to say that the dynamic initializers would just trap at run-time, because it’s possible that the base class has no public initializers.)<br></p><p>&gt; <br>&gt; Can you tell me why the onus should not be on you, on library authors, to use final or an equivalent keyword to indicate no subclassing is allowed and thus make this intentional?<br>&gt; <br>&gt; I am really not sold on why classes should not be subclassable by default. Not all classes suffer of the problem you mention and for those cases you should be able to express your intention explicitly. I am quite against this being a compiler default.<br></p><p>I admit that this use case says nothing about whether “sealed” should be the default or just available.<br></p><p>&gt; I think that security by ignorance, which is what automagically enforced rules tend to produce over time, does have some side effects.<br></p><p>This isn’t really a security issue; it’s a compiler-aided correctness issue. I’ll go more into that in my other email.<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160710/19c102e5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5af07e950f10c7c1df1c44bed055c1eb?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Daniel Steinberg</string> &lt;daniel at dimsumthinking.com&gt;<p>July 10, 2016 at 09:00:00pm</p></header><div class="content"><p>To highlight your comment below - I would favor “sealed” being available, I’m not sure I would favor it being the default.<br></p><p>Would it help to perhaps split this into two proposals. First, decide on the issue of sealable being available first and syntax for it. If this passes then a second proposal that examines whether it should be the default?<br></p><p>Best,<br></p><p>Daniel<br></p><p>&gt; On Jul 10, 2016, at 8:49 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 9, 2016, at 01:44, Goffredo Marocchi &lt;panajev at gmail.com &lt;mailto:panajev at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt;&gt; On 9 Jul 2016, at 05:39, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Of course, Swift doesn’t allow this. If someone outside of the module subclasses ModelBase, there’s no way for them to provide the dynamically-dispatched &#39;init(context:)’, because they don’t have access to the internal ModelContext.<br>&gt;&gt; <br>&gt;&gt; Shouldn&#39;t Swift allow this? Wouldn&#39;t it be better if we found a different way to handle this than a brute force &quot;you shall only subclass if I think you should&quot;? Is that really an impossible cause that is worth us going completely the opposite direction of most programming languages?<br>&gt; <br>&gt; There is no way to implement the required initializer from outside the module, because it uses an internal type, so what we’re looking for is that any subclasses from outside the module will never have the required initializer invoked on them. I suppose it would still be safe to allow a subclass from outside the module that did not provide any of its own initializers, but that seems like an even more complicated rule.<br>&gt; <br>&gt; (It’s not sufficient to say that the dynamic initializers would just trap at run-time, because it’s possible that the base class has no public initializers.)<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Can you tell me why the onus should not be on you, on library authors, to use final or an equivalent keyword to indicate no subclassing is allowed and thus make this intentional?<br>&gt;&gt; <br>&gt;&gt; I am really not sold on why classes should not be subclassable by default. Not all classes suffer of the problem you mention and for those cases you should be able to express your intention explicitly. I am quite against this being a compiler default.<br>&gt; <br>&gt; I admit that this use case says nothing about whether “sealed” should be the default or just available.<br>&gt; <br>&gt;&gt; I think that security by ignorance, which is what automagically enforced rules tend to produce over time, does have some side effects.<br>&gt; <br>&gt; This isn’t really a security issue; it’s a compiler-aided correctness issue. I’ll go more into that in my other email.<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160710/8a12dcc4/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b445c56e0a166b2a11e7527bf3de32?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Paul Norton</string> &lt;tripleshotsoftware at gmail.com&gt;<p>July  8, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; 	* What is your evaluation of the proposal?<br>-1 <br></p><p>Once, for an extended portion of my career, I worked in a &#39;developer support&#39; type role for a large C++ API. I had daily contact with developers who were consuming that API.<br>Because of that experience, I am fully convinced that library authors will never imagine all the ways developers will use a library&#39;s API.<br>Of course there&#39;s more to it, but I really think the reasons why this is the wrong direction have been well expressed by others.<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>No, I don&#39;t believe so. I also think it would eventually force a second change; some sort of override to the default, at which point we&#39;ve extended the language further to get closer to where we started.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>I don&#39;t believe it does. <br></p><p>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>N/A<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I have read the proposal, followed this discussion here but none of the previous discussion <br></p><p>Paul<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>July  9, 2016 at 03:00:00pm</p></header><div class="content"><p>On Tue, Jul 5, 2016, at 04:11 PM, Chris Lattner wrote:<br>&gt; 	* What is your evaluation of the proposal?<br></p><p>Mixed bag.<br></p><p>I&#39;m a big fan of sealed-by-default for classes. But I want a keyword (e.g. `sealed`) for this so I can be explicit about it too. Just as I sometimes mark methods as `internal` to make it clear to the reader that I didn&#39;t simply forget the access modifier, I would want to mark certain classes as `sealed` to make it obvious that I made a deliberate choice.<br></p><p>On the flip side, I&#39;m very against sealed-by-default for functions. My general feeling is that, if my class is subclassable, marking certain public methods as non-overridable is the exception rather than the norm. Anecdotally, in the Postmates app, most of our Swift classes are explicitly marked as `final` (which supports sealed-by-default for classes), but for the subclassable classes, I&#39;m pretty sure that _none_ of our methods are marked `final`.<br></p><p>Also, I think the keyword `subclassable` is kind of cumbersome. I&#39;m much more in favor of `open`, or possibly `public(open)` since this keyword only applies to public classes (or public methods, if I&#39;m overriding a sealed method from my parent).<br></p><p>And finally, I think we need to make the Swift migrator automatically mark public non-final declarations as `open`, otherwise we have a *huge* backwards compatibility hazard for all third-party Swift frameworks.<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes. It&#39;s making things safer by default, and matches the default internal access level.<br></p><p>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>A quick reading of the proposal, then reading part of this massive review thread and skimming the rest.<br></p><p>-Kevin Ballard<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/30e3591a1afb94308593c435111126c1?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Andre</string> &lt;pyunpyun at me.com&gt;<p>July 10, 2016 at 09:00:00pm</p></header><div class="content"><p>This has been a very interesting and educational thread.<br>Thanks to everyone who kindly replied to me and explained things.<br></p><p>Here is my 2¢…<br></p><p>&gt;  * What is your evaluation of the proposal?<br>+0 as it stands… <br>+1 if there could be a reliable way for us to explicitly un-seal a sealed class for those times where its absolutely necessary.<br></p><p>If its at all feasible… maybe something like ...<br></p><p><br>public class MyWorkaroundClass : @forceOpen(YourSealedClass) {  //Obligatory Compiler Warning Occurs    <br>    public override func @forceOpen(brokenFunc()) {/*FIXME*/}<br>}<br>(The above is just a rough idea, please don&#39;t yell at me for the ugliness... 🙂)<br></p><p>Just like we have forced unwrapping of optionals (for only when we really need it), I believe that we should be able to force unseal when we truly need it;<br></p><p>Another +1 if the keyword is changed from subclassable/overridable to something less confusing… since people might be easily be misled and think that even within thier own module if they don&#39;t mark it subclassable it won’t be subclassable… perhaps &quot;open&quot; is the better keyword…<br></p><p>public open class MyOpenClass {      <br>    public open func openFunc() {/*OVERRIDE ME!*/}<br>}<br>In this case, &quot;open&quot; can only apply to public classes/methods/accessors, anything else using &quot;open&quot; (&quot;private open&quot; etc) will be an obvious error.<br></p><p>Please note that I am not against this proposal in theory; only that I would humbly request that the two items above be at least considered and I will happily jump on board.<br></p><p>&gt;  * Is the problem being addressed significant enough to warrant a change to Swift?<br>I do think it is, because the potential upsides are many, such as better fencing between modules and users of those modules, potential performance gains and making it more explicit to a library writer what he/she is going to make public and also modifiable by consumers of the provided API.<br></p><p>Again though, I would be reticent to agree 100% if there werent a way to punch though that fence when we need to, not allowing such a thing makes the environment too rigid/unproductive and thats not the Swift I want to continue using. Swift is not C++ minus the C… is it?<br></p><p>&gt;  * Does this proposal fit well with the feel and direction of Swift?<br>I think overall it does because swift encourages more ad-hoc composition than inheritance based, so making inheritability more explicit does seem to fit in with the direction of Swift… although the lack of ability to escape that limitation just like we have with forced unwrapped optionals makes me feel its at the same time not fully in line with the direction of swift… hence the +0 instead of a full +1.<br></p><p>&gt;  * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>Someone here brought up Kotlin, but I have only dabbled with it.. It seems similar to that from what I can read… but I have no experience with writing or consuming a library in Kotlin.<br></p><p>&gt;  * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I have been wrestling with this in my mind since late last year when it first appeared on the swift-evolution list as a general discussion. <br>I was originally very very strongly -1 on this (especially coming from an Objective-C background), but after reading the proposal and everyones replies both for and against, and thinking again deeply about my own code, have come around to believe that there are potential gains for this that are worthwhile, but only if some flexibility remains in the language to work around classes that are both closed-source and has a defect that is needed to workaround though subclassing.<br>——<br></p><p>Pros<br>Better Fencing Between Modules<br>Potential Performance Gains<br>Subclassing is Discouraged Unless its Explicitly Thought About<br></p><p>Cons<br>Unable to Override a Method/Accessor on a Class that Needs Fixing but is Closed Source <br>You are at the total mercy of the framework author… (this one is pretty big to be honest)<br>	<br></p><p>&quot;Unknowns&quot; that make it hard to judge...<br></p><p>What effect this will really have on the community… <br>What true objective performance benefits we can expect from inter-module optimization…<br>Will this really make libraries any better?<br></p><p><br>——<br></p><p>Other thoughts...<br>While it can be said that because most libraries are open source, the need to subclass is lower now than ever -we can just go in and fix something and send a pull request-  those of us trapped in large corporations that have (usually poorly supported) SDKs shoved down our throats by the suits need a certain level of flexibility to work arounds things… <br></p><p>In debating to support this or not, I am reminded of comments by many here: http://mjtsai.com/blog/2015/12/21/swift-proposal-for-default-final/<br></p><p>——<br></p><p><br>Thanks,<br></p><p>Andre<br></p><p><br>&gt; 2016/07/06 8:11、Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; のメール：<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;SE-0117: Default classes to be non-subclassable publicly&quot; begins now and runs through July 11. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160710/700c6595/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>July 10, 2016 at 08:00:00pm</p></header><div class="content"><p>[Proposal: https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md ]<br></p><p>(This is my second response to this proposal. The previous message shared a use case where public-but-non-subclassable made things work out much better with required initializers. This one has a bit more ideology in it.)<br></p><p>As many people have said already, this proposal is quite beneficial to library designers attempting to reason about their code, not just now but in the future as well. The model laid out in the Library Evolution document &lt;http://jrose-apple.github.io/swift-library-evolution/&gt; (often referred to as “resilience”) supports Swift libraries that want to preserve a stable binary and source interface.<br></p><p>In the Swift 2 model (and what’s currently described in that document), a public class must be final or non-final at the time it is published. It’s clearly not safe to add ‘final&#39; in a later version of the library, because a client might already have a subclass; it’s also not safe to remove ‘final’ because existing clients may have been compiled assuming there are no subclasses.<br></p><p>(Of course, we can remove this optimization, and make ‘final’ a semantic contract only. I’m deliberately avoiding most discussion of performance, but in this parenthetical I’ll note that Swift makes it possible to write code that is slower than Objective-C. This is considered acceptable because the compiler can often optimize it for a particular call site. For those who want more information about the current implementation of some of Swift’s features, I suggest watching the “Understanding Swift Performance &lt;https://developer.apple.com/videos/play/wwdc2016/416/&gt;” talk from this year’s WWDC.)<br></p><p>With this proposal, a public class can be non-publicly-subclassable or publicly-subclassable. Once a class is publicly-subclassable (“open”), you can’t go back, of course. But a class that’s not initially open could become open in a future release of the library. All existing clients would already be equipped to deal with this, because there might be subclasses inside the library. On the other hand, the class can also be marked ‘final’, if the library author later realizes there will never be any subclasses and that both client authors and the compiler should know this.<br></p><p>One point that’s not covered in this proposal is whether making a class ‘open’ applies retroactively, i.e. if MagicLib 1.2 is the first version that makes the Magician class ‘open’, can clients deploy back to MagicLib 1.0 and expect their subclasses to work? My inclination is to say no; if it’s possible for a non-open method to be overridden in the future, a library author has to write their library as if it will be overridden now, and there’s no point in making it non-open in the first place. That would make ‘open’ a “versioned attribute &lt;http://jrose-apple.github.io/swift-library-evolution/#publishing-versioned-api&gt;” in the terminology of Library Evolution, whatever the syntax ends up being.<br></p><p>---<br></p><p>Okay, so why is this important?<br></p><p>It all comes down to reasoning about your program’s behavior. When you use a class, you’re relying on the documented behavior of that class. More concretely, the methods on the class have preconditions (“performSegue(withIdentifier:sender:) should not be called on a view controller that didn’t come from a storyboard”) and postconditions (“after calling loadViewIfNeeded(), the view controller’s view will be loaded”). When you call a method, you’re responsible for satisfying its preconditions so it can deliver on the postconditions.<br></p><p>I used UIViewController as an example, but it applies just as much to your own methods. When you call a method in your own module—maybe written by you, maybe by a coworker, maybe by an open source contributor—you’re expecting some particular behavior and output given the inputs and the current state of the program. That is, you just need to satisfy its preconditions so it can deliver on the postconditions. If it’s a method in your module, though, you might not have taken the trouble to formalize the preconditions and postconditions, since you can just go look at the implementation. Even if your expectations are violated, you’ll probably notice, because the conflict of understanding is within your own module.<br></p><p>Public overriding changes all this. While an overridable method may have particular preconditions and postconditions, it’s possible that the overrider will get that wrong, which means the library author can no longer reason about the behavior of their program. If they do a poor job documenting the preconditions and postconditions, the client and the library will almost certainly disagree about the expected behavior of a particular method, and the program won’t work correctly.<br></p><p>&quot;Doesn’t a library author have to figure out the preconditions and postconditions for a method anyway when making it public?&quot; Well, not to the same extent. It’s perfectly acceptable for a library author to document stronger preconditions and weaker postconditions than are strictly necessary. (Maybe &#39;performSegue(withIdentifier:sender:)’ has a mode that can work without storyboards, but UIKit isn’t promising that it will work.) When a library author lets people override their method, though, they&#39;re promising that the method will never be called with a weaker precondition than documented, and that nothing within their library will expect a stronger postcondition than documented.<br></p><p>(By the way, the way to look at overriding a method is the inverse of calling a method: you need to deliver on the postconditions, and you can assume the caller has satisfied the preconditions. If your understanding of those preconditions and postconditions is wrong, your program won’t work correctly, just like when you’re calling a method.)<br></p><p>This all goes double when a library author wants to release a new version of their library with different behavior. In order to make sure existing callers don’t break, they have to make sure all of the library’s documented preconditions are no stronger and postconditions are no weaker for public API. In order to make sure existing subclassers don’t break, they have to make sure all of the library’s documented preconditions are no weaker and postconditions are no stronger for overridable API.<br></p><p>(For a very concrete example of this, say you’re calling a method with the type &#39;(Int?) -&gt; Int’, and you’re passing nil. The new version of the library can’t decide to make the parameter non-optional or the return value optional, because that would break your code. Similarly, if you’re overriding a method with the type ‘(Int) -&gt; Int?’, and returning nil, the new version of the library can’t decide to make the parameter optional or the return value non-optional, because that would break your code.)<br></p><p>So, &quot;non-publicly-subclassable&quot; is a way to ease the burden on a library author. They should be thinking about preconditions and postconditions in their program anyway, but not having to worry about all the things a client might do for a method that shouldn’t be overridden means they can actually reason about the behavior—and thus the correctness—of their own program, both now and for future releases.<br></p><p>---<br></p><p>I agree with several people on this thread that non-publicly-subclassable-by-default is the same idea as internal-by-default: it means that you have to explicitly decide to support a capability before clients can start relying on it, and you are very unlikely to do so by accident. The default is “safe” in that a library author can change their mind without breaking existing clients.<br></p><p>I agree with John that even today, the entry points that happen to be public in the types that happen to be public classes are unlikely to be good entry points for fixing bugs in someone else&#39;s library. Disallowing overriding these particular entry points when a client already can&#39;t override internal methods, methods on structs, methods that use internal types, or top-level functions doesn’t really seem like a loss to me.<br></p><p>Library design is important. Controlling the public interface of a library allows for better reasoning about the behavior of code, better security (i.e. better protection of user data), and better maintainability. And whether something can be overridden is part of that interface.<br></p><p>Thanks again to Javier and John for putting this proposal together.<br>Jordan<br></p><p>P.S. There’s also an argument to be made for public-but-not-conformable protocols, i.e. protocols that can be used in generics and as values outside of a module, but cannot be conformed to. This is important for many of the same reasons as it is for classes, and we’ve gotten a few requests for it. (While you can get a similar effect using an enum, that’s a little less natural for code reuse via protocol extensions.)<br></p><p>P.P.S. For those who will argue against “better security”, you’re correct: this doesn’t prevent an attack, and I don’t have much expertise in this area. However, I have talked to developers distributing binary frameworks (despite our warnings that it isn’t supported) who have asked us for various features to keep it from being easy.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160710/63cebd4f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 10, 2016 at 11:00:00pm</p></header><div class="content"><p>On Sun, Jul 10, 2016 at 10:38 PM, Jordan Rose via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; [Proposal:<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt; ]<br>&gt;<br>&gt; (This is my second response to this proposal. The previous message shared<br>&gt; a use case where public-but-non-subclassable made things work out much<br>&gt; better with required initializers. This one has a bit more ideology in it.)<br>&gt;<br>&gt; As many people have said already, this proposal is quite beneficial to<br>&gt; library designers attempting to reason about their code, not just now but<br>&gt; in the future as well. The model laid out in the Library Evolution<br>&gt; document &lt;http://jrose-apple.github.io/swift-library-evolution/&gt; (often<br>&gt; referred to as “resilience”) supports Swift libraries that want to preserve<br>&gt; a stable binary and source interface.<br>&gt;<br>&gt; In the Swift 2 model (and what’s currently described in that document), a<br>&gt; public class must be final or non-final at the time it is published. It’s<br>&gt; clearly not safe to *add* ‘final&#39; in a later version of the library,<br>&gt; because a client might already have a subclass; it’s also not safe to<br>&gt; *remove* ‘final’ because existing clients may have been compiled assuming<br>&gt; there are no subclasses.<br>&gt;<br>&gt; (Of course, we can remove this optimization, and make ‘final’ a semantic<br>&gt; contract only. I’m deliberately avoiding most discussion of performance,<br>&gt; but in this parenthetical I’ll note that Swift makes it possible to write<br>&gt; code that is *slower* than Objective-C. This is considered acceptable<br>&gt; because the compiler can often optimize it for a particular call site. For<br>&gt; those who want more information about the current implementation of some of<br>&gt; Swift’s features, I suggest watching the “Understanding Swift Performance<br>&gt; &lt;https://developer.apple.com/videos/play/wwdc2016/416/&gt;” talk from this<br>&gt; year’s WWDC.)<br>&gt;<br>&gt; With this proposal, a public class can be non-publicly-subclassable or<br>&gt; publicly-subclassable. Once a class is publicly-subclassable (“open”), you<br>&gt; can’t go back, of course. But a class that’s not initially open could<br>&gt; *become* open in a future release of the library. All existing clients<br>&gt; would already be equipped to deal with this, because there might be<br>&gt; subclasses *inside* the library. On the other hand, the class can *also* be<br>&gt; marked ‘final’, if the library author later realizes there will never be<br>&gt; any subclasses and that both client authors and the compiler should know<br>&gt; this.<br>&gt;<br>&gt; One point that’s not covered in this proposal is whether making a class<br>&gt; ‘open’ applies retroactively, i.e. if MagicLib 1.2 is the first version<br>&gt; that makes the Magician class ‘open’, can clients deploy back to MagicLib<br>&gt; 1.0 and expect their subclasses to work? My inclination is to say no; if<br>&gt; it’s possible for a non-open method to be overridden in the future, a<br>&gt; library author has to write their library as if it will be overridden now,<br>&gt; and there’s no point in making it non-open in the first place. That would<br>&gt; make ‘open’ a “versioned attribute<br>&gt; &lt;http://jrose-apple.github.io/swift-library-evolution/#publishing-versioned-api&gt;”<br>&gt; in the terminology of Library Evolution, whatever the syntax ends up being.<br>&gt;<br>&gt; ---<br>&gt;<br>&gt; Okay, so why is this important?<br>&gt;<br>&gt; It all comes down to reasoning about your program’s behavior. When you use<br>&gt; a class, you’re relying on the documented behavior of that class. More<br>&gt; concretely, the methods on the class have preconditions<br>&gt; (“performSegue(withIdentifier:sender:) should not be called on a view<br>&gt; controller that didn’t come from a storyboard”) and postconditions (“after<br>&gt; calling loadViewIfNeeded(), the view controller’s view will be loaded”).<br>&gt; When you call a method, you’re responsible for satisfying its preconditions<br>&gt; so it can deliver on the postconditions.<br>&gt;<br>&gt; I used UIViewController as an example, but it applies just as much to your<br>&gt; own methods. When you call a method in your own module—maybe written by<br>&gt; you, maybe by a coworker, maybe by an open source contributor—you’re<br>&gt; expecting some particular behavior and output given the inputs and the<br>&gt; current state of the program. That is, you just need to satisfy its<br>&gt; preconditions so it can deliver on the postconditions. If it’s a method in<br>&gt; your module, though, you might not have taken the trouble to formalize the<br>&gt; preconditions and postconditions, since you can just go look at the<br>&gt; implementation. Even if your expectations are violated, you’ll probably<br>&gt; notice, because the conflict of understanding is within your own module.<br>&gt;<br>&gt; Public overriding changes all this. While an overridable method may have<br>&gt; particular preconditions and postconditions, it’s possible that the<br>&gt; overrider will get that wrong, which means the library author can no longer<br>&gt; reason about the behavior of their program. If they do a poor job<br>&gt; documenting the preconditions and postconditions, the client and the<br>&gt; library will almost certainly disagree about the expected behavior of a<br>&gt; particular method, and the program won’t work correctly.<br>&gt;<br>&gt; &quot;Doesn’t a library author have to figure out the preconditions and<br>&gt; postconditions for a method anyway when making it public?&quot; Well, not to the<br>&gt; same extent. It’s perfectly acceptable for a library author to document<br>&gt; stronger preconditions and weaker postconditions than are strictly<br>&gt; necessary. (Maybe &#39;performSegue(withIdentifier:sender:)’ has a mode that<br>&gt; can work without storyboards, but UIKit isn’t promising that it will work.)<br>&gt; When a library author lets people override their method, though, they&#39;re<br>&gt; promising that the method will never be called with a weaker precondition<br>&gt; than documented, and that nothing within their library will expect a<br>&gt; stronger postcondition than documented.<br>&gt;<br>&gt; (By the way, the way to look at overriding a method is the inverse of<br>&gt; calling a method: *you* need to deliver on the postconditions, and you<br>&gt; can assume the *caller* has satisfied the preconditions. If your<br>&gt; understanding of those preconditions and postconditions is wrong, your<br>&gt; program won’t work correctly, just like when you’re calling a method.)<br>&gt;<br>&gt; This all goes double when a library author wants to release a new version<br>&gt; of their library with different behavior. In order to make sure existing<br>&gt; callers don’t break, they have to make sure all of the library’s documented<br>&gt; preconditions are no stronger and postconditions are no weaker for public<br>&gt; API. In order to make sure existing subclassers don’t break, they have to<br>&gt; make sure all of the library’s documented preconditions are no *weaker* and<br>&gt; postconditions are no *stronger* for overridable API.<br>&gt;<br>&gt; (For a very concrete example of this, say you’re calling a method with the<br>&gt; type &#39;(Int?) -&gt; Int’, and you’re passing nil. The new version of the<br>&gt; library can’t decide to make the parameter non-optional or the return value<br>&gt; optional, because that would break your code. Similarly, if you’re<br>&gt; *overriding* a method with the type ‘(Int) -&gt; Int?’, and *returning* nil,<br>&gt; the new version of the library can’t decide to make the parameter<br>&gt; *optional* or the return value *non-*optional, because *that* would break<br>&gt; your code.)<br>&gt;<br>&gt; So, &quot;non-publicly-subclassable&quot; is a way to ease the burden on a library<br>&gt; author. They should be thinking about preconditions and postconditions in<br>&gt; their program *anyway,* but not having to worry about all the things a<br>&gt; client might do for a method that *shouldn’t* be overridden means they<br>&gt; can actually reason about the behavior—and thus the correctness—of their<br>&gt; own program, both now and for future releases.<br>&gt;<br>&gt; ---<br>&gt;<br>&gt; I agree with several people on this thread that<br>&gt; non-publicly-subclassable-by-default is the same idea as<br>&gt; internal-by-default: it means that you have to explicitly decide to support<br>&gt; a capability before clients can start relying on it, and you are very<br>&gt; unlikely to do so by accident. The default is “safe” in that a library<br>&gt; author can change their mind without breaking existing clients.<br>&gt;<br>&gt; I agree with John that even today, the entry points that *happen* to be<br>&gt; public in the types that *happen* to be public classes are unlikely to be<br>&gt; good entry points for fixing bugs in someone else&#39;s library. Disallowing<br>&gt; overriding these particular entry points when a client already can&#39;t<br>&gt; override internal methods, methods on structs, methods that use internal<br>&gt; types, or top-level functions doesn’t really seem like a loss to me.<br>&gt;<br>&gt; Library design is important. Controlling the public interface of a library<br>&gt; allows for better reasoning about the behavior of code, better security<br>&gt; (i.e. better protection of user data), and better maintainability. And<br>&gt; whether something can be overridden is part of that interface.<br>&gt;<br>&gt; Thanks again to Javier and John for putting this proposal together.<br>&gt; Jordan<br>&gt;<br>&gt; P.S. There’s also an argument to be made for public-but-not-conformable<br>&gt; protocols, i.e. protocols that can be used in generics and as values<br>&gt; outside of a module, but cannot be conformed to. This is important for many<br>&gt; of the same reasons as it is for classes, and we’ve gotten a few requests<br>&gt; for it. (While you can get a similar effect using an enum, that’s a little<br>&gt; less natural for code reuse via protocol extensions.)<br>&gt;<br></p><p>Would public-but-not-conformable protocols by default be the next step,<br>then, in Swift&#39;s evolution?<br></p><p><br>&gt; P.P.S. For those who will argue against “better security”, you’re correct:<br>&gt; this *doesn’t* prevent an attack, and I *don’t* have much expertise in<br>&gt; this area. However, I *have* talked to developers distributing binary<br>&gt; frameworks (despite our warnings that it isn’t supported) who have asked us<br>&gt; for various features to keep it from being *easy.*<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160710/4543f23b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>July 11, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; P.S. There’s also an argument to be made for public-but-not-conformable protocols, i.e. protocols that can be used in generics and as values outside of a module, but cannot be conformed to. This is important for many of the same reasons as it is for classes, and we’ve gotten a few requests for it. (While you can get a similar effect using an enum, that’s a little less natural for code reuse via protocol extensions.)<br>&gt; <br>&gt; Would public-but-not-conformable protocols by default be the next step, then, in Swift&#39;s evolution?<br></p><p>I personally think it’s a reasonable place to go next, which is why I brought it up. However, I don’t think it’s critical enough to get into Swift 3 when we’re already so busy, and when there are multiple non-source-breaking ways to get a similar effect later: adding a “sealed” annotation (so, giving up on “by default” for protocols) and allowing requirements to have more narrow access than the protocol (thus making it impossible to conform).<br></p><p>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/c3a16370/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 11, 2016 at 01:00:00pm</p></header><div class="content"><p>On Mon, Jul 11, 2016 at 11:10 AM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br></p><p>&gt; P.S. There’s also an argument to be made for public-but-not-conformable<br>&gt;&gt; protocols, i.e. protocols that can be used in generics and as values<br>&gt;&gt; outside of a module, but cannot be conformed to. This is important for many<br>&gt;&gt; of the same reasons as it is for classes, and we’ve gotten a few requests<br>&gt;&gt; for it. (While you can get a similar effect using an enum, that’s a little<br>&gt;&gt; less natural for code reuse via protocol extensions.)<br>&gt;&gt;<br>&gt;<br>&gt; Would public-but-not-conformable protocols by default be the next step,<br>&gt; then, in Swift&#39;s evolution?<br>&gt;<br>&gt;<br>&gt; I personally think it’s a reasonable place to go next, which is why I<br>&gt; brought it up. However, I don’t think it’s critical enough to get into<br>&gt; Swift 3 when we’re already so busy, and when there are multiple<br>&gt; non-source-breaking ways to get a similar effect later: adding a “sealed”<br>&gt; annotation (so, giving up on “by default” for protocols) and allowing<br>&gt; requirements to have more narrow access than the protocol (thus making it<br>&gt; impossible to conform).<br>&gt;<br></p><p>FWIW, if we give up on &quot;by default&quot; for classes, &quot;sealed&quot; could also be a<br>post-Swift 3 matter here as well. IMO, if the core team finds the reasoning<br>here persuasive enough to have sealed-by-default for classes, I&#39;d hope for<br>the same treatment for protocols on that time frame, because as you say<br>much of the rationale behind the change is analogous for both protocols and<br>classes.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/c2465423/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July 11, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jul 11, 2016, at 1:49 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Mon, Jul 11, 2016 at 11:10 AM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt; P.S. There’s also an argument to be made for public-but-not-conformable protocols, i.e. protocols that can be used in generics and as values outside of a module, but cannot be conformed to. This is important for many of the same reasons as it is for classes, and we’ve gotten a few requests for it. (While you can get a similar effect using an enum, that’s a little less natural for code reuse via protocol extensions.)<br>&gt;&gt; <br>&gt;&gt; Would public-but-not-conformable protocols by default be the next step, then, in Swift&#39;s evolution?<br>&gt; <br>&gt; I personally think it’s a reasonable place to go next, which is why I brought it up. However, I don’t think it’s critical enough to get into Swift 3 when we’re already so busy, and when there are multiple non-source-breaking ways to get a similar effect later: adding a “sealed” annotation (so, giving up on “by default” for protocols) and allowing requirements to have more narrow access than the protocol (thus making it impossible to conform).<br>&gt; <br>&gt; FWIW, if we give up on &quot;by default&quot; for classes, &quot;sealed&quot; could also be a post-Swift 3 matter here as well. IMO, if the core team finds the reasoning here persuasive enough to have sealed-by-default for classes, I&#39;d hope for the same treatment for protocols on that time frame, because as you say much of the rationale behind the change is analogous for both protocols and classes.<br></p><p>On the topic of protocols, there are really two avenues for “sealing”’ them.  One is conformances and the other is refinements.  There are more nuances to consider in a design for sealing protocols.<br></p><p>If we’re going to continue discussing sealing protocols we should probably start a new thread.  However, I think we should wait unless someone from the core team decides it is worth discussing during the Swift 3 timeframe.<br></p><p>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/1b9ac200/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>July 11, 2016 at 01:00:00pm</p></header><div class="content"><p>I haven&#39;t read the whole Library Evolution document, but one important part is written right at the top:<br></p><p>&gt; This model is largely not of interest to libraries that are bundled with their clients (distribution via source, static library, or embedded/sandboxed dynamic library, as used by the Swift Package Manager &lt;https://swift.org/package-manager/&gt;)<br></p><p><br>So there are compelling arguments to &quot;seal&quot; the Apple-libraries, and it&#39;s reasonable to enforce sealing on them.<br>But if sealed is the right default for those libraries, it is not automatically the right default for all other libraries out there, because those are developed in a completely different manner.<br>So, instead making sealed the default for Swift, I believe it is much more sound to just make it the default for the standard frameworks:<br>This doesn&#39;t break compatibility, it&#39;s imho more convenient for the majority, and I guess there is enough manpower to manage the annotations for Cocoa and other frameworks (which is tedious labor for single developers, but no issue for a large company). <br></p><p>&gt; Am 11.07.2016 um 05:38 schrieb Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; While an overridable method may have particular preconditions and postconditions, it’s possible that the overrider will get that wrong, which means the library author can no longer reason about the behavior of their program.<br>Once again a situation where we have to differentiate wether we encourage open source or not:<br>In OS, users of a library become the allies of its author — they can put stress on his model, they can find its flaws and they can show him how to improve.<br>The ability to take a piece of code and start playing with it is a fantastic trait, and this is actively discouraged by imposing limits not because they make sense, but only because the original author didn&#39;t take the time to reason about the status.<br></p><p>For software that grows &quot;organically&quot;, documentation is more useful than simple rules...<br>I like the concept of version blocks, and it could work in the other direction as well: We could have a &quot;experimental&quot;-modifier that would give the library author a way to offer hints for its clients, but leaves the final decision up to them. This would be much more granular than a plain &quot;final&quot; which not only protects those who want to stay on the safe side, but also repels the bold developers who&#39;d willingly help improving the code in question.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/2d9e6dda/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>July 11, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jul 11, 2016, at 04:34, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt; <br>&gt; I haven&#39;t read the whole Library Evolution document, but one important part is written right at the top:<br>&gt; <br>&gt;&gt; This model is largely not of interest to libraries that are bundled with their clients (distribution via source, static library, or embedded/sandboxed dynamic library, as used by the Swift Package Manager &lt;https://swift.org/package-manager/&gt;)<br>&gt; <br>&gt; <br>&gt; So there are compelling arguments to &quot;seal&quot; the Apple-libraries, and it&#39;s reasonable to enforce sealing on them.<br>&gt; But if sealed is the right default for those libraries, it is not automatically the right default for all other libraries out there, because those are developed in a completely different manner.<br>&gt; So, instead making sealed the default for Swift, I believe it is much more sound to just make it the default for the standard frameworks:<br>&gt; This doesn&#39;t break compatibility, it&#39;s imho more convenient for the majority, and I guess there is enough manpower to manage the annotations for Cocoa and other frameworks (which is tedious labor for single developers, but no issue for a large company). <br></p><p>The binary compatibility concerns are less important, but the ability of a library author to reason about behavior is still critical. Here’s a scenario I really don’t want to see happen:<br></p><p>1. Client X adds a dependency on library A, via the package manager. They override a public method in library A to get the behavior they want.<br>2. Library A ships an update which fixes many bugs and security issues, and happens to eliminate the internal calls to the public method A was using. That is, overriding Athat method no longer has any effect within library A; only clients see the difference.<br>3. The developer for client X goes to their manager and asks for time to fix the issue. The manager tells them not to update right now, but maybe after this next release.<br>4. Client X never gets a new version of Library A ever again.<br></p><p>This hypothetical scenario happened because the client and the library had differing notions about what you could do with this particular public method. From the library point of view, this shouldn’t be a source-breaking change because they never expected it to do anything; from the client point of view, the program does a perfectly normal thing of overriding a public API and the library has capriciously broken it.<br></p><p>I guess another way of saying this is that library authors avoid these miscommunications by &quot;under-promising”, and if that “under-promising” is something that’s actually in the language instead of maybe/maybe-not being documented, then both sides are much more likely to be on the same page.<br></p><p><br>&gt; <br>&gt;&gt; Am 11.07.2016 um 05:38 schrieb Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt; While an overridable method may have particular preconditions and postconditions, it’s possible that the overrider will get that wrong, which means the library author can no longer reason about the behavior of their program.<br>&gt; Once again a situation where we have to differentiate wether we encourage open source or not:<br>&gt; In OS, users of a library become the allies of its author — they can put stress on his model, they can find its flaws and they can show him how to improve.<br>&gt; The ability to take a piece of code and start playing with it is a fantastic trait, and this is actively discouraged by imposing limits not because they make sense, but only because the original author didn&#39;t take the time to reason about the status.<br></p><p>This is completely true, but I don’t see it as having much to do with subclassing. If a library is open source, most of your “playing with it” will be modifying the original code, not using a subclass. This is especially true given how many Swift libraries are made up of just structs, enums, and protocols. Additionally, “build for testing” will also allow subclassing sealed classes (though not final classes, since the ‘final’ is part of the semantics rather than just controlling access).<br></p><p><br>&gt; For software that grows &quot;organically&quot;, documentation is more useful than simple rules...<br>&gt; I like the concept of version blocks, and it could work in the other direction as well: We could have a &quot;experimental&quot;-modifier that would give the library author a way to offer hints for its clients, but leaves the final decision up to them. This would be much more granular than a plain &quot;final&quot; which not only protects those who want to stay on the safe side, but also repels the bold developers who&#39;d willingly help improving the code in question.<br></p><p>If you were writing a library, what would make you decide between “experimental” and not?<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/6fccf399/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9df907a6d7a4e317834a3c3816987a8a?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Andre Elder</string> &lt;son_gohan at mac.com&gt;<p>July 12, 2016 at 06:00:00am</p></header><div class="content"><p>2016/07/12 6:08、Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br></p><p>&gt; <br>&gt;&gt; On Jul 11, 2016, at 04:34, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I haven&#39;t read the whole Library Evolution document, but one important part is written right at the top:<br>&gt;&gt; <br>&gt;&gt;&gt; This model is largely not of interest to libraries that are bundled with their clients (distribution via source, static library, or embedded/sandboxed dynamic library, as used by the Swift Package Manager)<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; So there are compelling arguments to &quot;seal&quot; the Apple-libraries, and it&#39;s reasonable to enforce sealing on them.<br>&gt;&gt; But if sealed is the right default for those libraries, it is not automatically the right default for all other libraries out there, because those are developed in a completely different manner.<br>&gt;&gt; So, instead making sealed the default for Swift, I believe it is much more sound to just make it the default for the standard frameworks:<br>&gt;&gt; This doesn&#39;t break compatibility, it&#39;s imho more convenient for the majority, and I guess there is enough manpower to manage the annotations for Cocoa and other frameworks (which is tedious labor for single developers, but no issue for a large company). <br>&gt; <br>&gt; The binary compatibility concerns are less important, but the ability of a library author to reason about behavior is still critical. Here’s a scenario I really don’t want to see happen:<br>&gt; <br>&gt; 1. Client X adds a dependency on library A, via the package manager. They override a public method in library A to get the behavior they want.<br>&gt; 2. Library A ships an update which fixes many bugs and security issues, and happens to eliminate the internal calls to the public method A was using. That is, overriding Athat method no longer has any effect within library A; only clients see the difference.<br>&gt; 3. The developer for client X goes to their manager and asks for time to fix the issue. The manager tells them not to update right now, but maybe after this next release.<br>&gt; 4. Client X never gets a new version of Library A ever again.<br>&gt; <br>&gt; This hypothetical scenario happened because the client and the library had differing notions about what you could do with this particular public method. From the library point of view, this shouldn’t be a source-breaking change because they never expected it to do anything; from the client point of view, the program does a perfectly normal thing of overriding a public API and the library has capriciously broken it.<br>This is a very compelling argument and totally logical.<br></p><p>I will change my vote to +0.5 in this case... still not sure about lack of workaround for the off-case but I am in complete agreement with the reasoning of this proposal, thanks for explaining it further... <br></p><p>I guess maybe the thing that bothers some people is that it&#39;s forced instead of being a warning/annotation that could be ignored if necessary... of course that definition of &quot;necessary&quot; would be another sticking point &gt;_&lt;.<br></p><p>&gt; I guess another way of saying this is that library authors avoid these miscommunications by &quot;under-promising”, and if that “under-promising” is something that’s actually in the language instead of maybe/maybe-not being documented, then both sides are much more likely to be on the same page.<br>Yes, this is very good and important point.<br></p><p>It&#39;s very appreciated that so many people have taken the time to thoughtfully reply to the questions and talking points, especially Jordan and Mathew! I have learned a lot here...<br></p><p>Andre<br></p><p>&gt;&gt; <br>&gt;&gt;&gt; Am 11.07.2016 um 05:38 schrieb Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; While an overridable method may have particular preconditions and postconditions, it’s possible that the overrider will get that wrong, which means the library author can no longer reason about the behavior of their program.<br>&gt;&gt; Once again a situation where we have to differentiate wether we encourage open source or not:<br>&gt;&gt; In OS, users of a library become the allies of its author ― they can put stress on his model, they can find its flaws and they can show him how to improve.<br>&gt;&gt; The ability to take a piece of code and start playing with it is a fantastic trait, and this is actively discouraged by imposing limits not because they make sense, but only because the original author didn&#39;t take the time to reason about the status.<br>&gt; <br>&gt; This is completely true, but I don’t see it as having much to do with subclassing. If a library is open source, most of your “playing with it” will be modifying the original code, not using a subclass. This is especially true given how many Swift libraries are made up of just structs, enums, and protocols. Additionally, “build for testing” will also allow subclassing sealed classes (though not final classes, since the ‘final’ is part of the semantics rather than just controlling access).<br>&gt; <br>&gt; <br>&gt;&gt; For software that grows &quot;organically&quot;, documentation is more useful than simple rules...<br>&gt;&gt; I like the concept of version blocks, and it could work in the other direction as well: We could have a &quot;experimental&quot;-modifier that would give the library author a way to offer hints for its clients, but leaves the final decision up to them. This would be much more granular than a plain &quot;final&quot; which not only protects those who want to stay on the safe side, but also repels the bold developers who&#39;d willingly help improving the code in question.<br>&gt; <br>&gt; If you were writing a library, what would make you decide between “experimental” and not?<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>iPadから送信<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160712/2507631f/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>July 12, 2016 at 10:00:00pm</p></header><div class="content"><p>Thanks for the detailed answer — I didn&#39;t expect it.<br></p><p>I&#39;ll re-order the original message, since you had a genuine question (to bad for me if it was just a rhetorical one :) whose answer might be more interesting than the pointless remarks afterwards ;-)<br></p><p>&gt; If you were writing a library, what would make you decide between “experimental” and not?<br></p><p>I guess I would mark everything immature/experimental/whatever on release (as long as it&#39;s not to hard to do so…), and then decide step by step wether a method should be public, overridable, private — or removed completely ;-)<br>Of course, there wouldn&#39;t be an universal scale, but most likely each developer/team would keep a reliable standard (some developers are very careful, some are bolder…)<br>If we are honest, a &quot;sealed&quot; that is only applied because it is the default is actually &quot;experimental&quot; — and in the age of open source, I don&#39;t think this should be equivalent to &quot;you can&#39;t use this&quot; (some conservative developers consider Swift itself to be immature ;-)<br>The whole concept is just a spontaneous idea, and maybe I&#39;d come to the conclusion I actually don&#39;t like it; but as we can mark stuff as deprecated to notify users that they should stop using a certain method, it might as well be useful to annotate something as unstable to prevent certain developers start using a method (yet).<br></p><p>Now for the remarks — they are pointless indeed, because I&#39;m not expecting to change the mind of anyone with a well-grounded opinion<br>&gt; The binary compatibility concerns are less important, but the ability of a library author to reason about behavior is still critical. Here’s a scenario I really don’t want to see happen:<br>&gt; <br>&gt; 1. Client X adds a dependency on library A, via the package manager. They override a public method in library A to get the behavior they want.<br>&gt; 2. Library A ships an update which fixes many bugs and security issues, and happens to eliminate the internal calls to the public method A was using. That is, overriding Athat method no longer has any effect within library A; only clients see the difference.<br>&gt; 3. The developer for client X goes to their manager and asks for time to fix the issue. The manager tells them not to update right now, but maybe after this next release.<br>&gt; 4. Client X never gets a new version of Library A ever again.<br></p><p>Imho this is remarkable in two aspects:<br>It is the first real example I&#39;m aware of where I see a true problem, and it &quot;overthrows&quot; (there might be a less dramatic word I&#39;m not aware of) the position that &quot;sealed&quot; primarily solves a problem for library-authors.<br></p><p>I agree that this problem is much less likely with sealed as default, but there&#39;s another one in this scenario:<br>Client X depends on the later-removed feature in Library A — but as this feature isn&#39;t accessible for him, he won&#39;t ever start using Library A at all…<br>None the less, I have to admit that I actually prefer the problem in the sealed-scenario, as it doesn&#39;t directly effect developer T, but rather pointy-haired boss Y, who just lost a potential customer ;-)<br></p><p>I can&#39;t resist to add another culinary comparison to Jonathan Hull&#39;s excellent knife-analogy:<br>As the owner of a restaurant, would you fill your menu with food that&#39;s easy to cook to please your chef, or would you rather include food that tastes fantastic to please your customers?<br></p><p>&gt; I guess another way of saying this is that library authors avoid these miscommunications by &quot;under-promising”, and if that “under-promising” is something that’s actually in the language instead of maybe/maybe-not being documented, then both sides are much more likely to be on the same page.<br>Damn, maybe I should have put this in front… why make false promises at all, when you just can tell the truth?<br></p><p>Best regards,<br>Tino<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>July 12, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jul 12, 2016, at 13:44, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt; <br>&gt; Thanks for the detailed answer — I didn&#39;t expect it.<br>&gt; <br>&gt; I&#39;ll re-order the original message, since you had a genuine question (to bad for me if it was just a rhetorical one :) whose answer might be more interesting than the pointless remarks afterwards ;-)<br>&gt; <br>&gt;&gt; If you were writing a library, what would make you decide between “experimental” and not?<br>&gt; <br>&gt; I guess I would mark everything immature/experimental/whatever on release (as long as it&#39;s not to hard to do so…), and then decide step by step wether a method should be public, overridable, private — or removed completely ;-)<br>&gt; Of course, there wouldn&#39;t be an universal scale, but most likely each developer/team would keep a reliable standard (some developers are very careful, some are bolder…)<br>&gt; If we are honest, a &quot;sealed&quot; that is only applied because it is the default is actually &quot;experimental&quot; — and in the age of open source, I don&#39;t think this should be equivalent to &quot;you can&#39;t use this&quot; (some conservative developers consider Swift itself to be immature ;-)<br>&gt; The whole concept is just a spontaneous idea, and maybe I&#39;d come to the conclusion I actually don&#39;t like it; but as we can mark stuff as deprecated to notify users that they should stop using a certain method, it might as well be useful to annotate something as unstable to prevent certain developers start using a method (yet).<br></p><p>No, it was a genuine question. I don’t think I agree with your answer, but I’m glad to hear it.<br></p><p><br>&gt; <br>&gt; Now for the remarks — they are pointless indeed, because I&#39;m not expecting to change the mind of anyone with a well-grounded opinion<br>&gt;&gt; The binary compatibility concerns are less important, but the ability of a library author to reason about behavior is still critical. Here’s a scenario I really don’t want to see happen:<br>&gt;&gt; <br>&gt;&gt; 1. Client X adds a dependency on library A, via the package manager. They override a public method in library A to get the behavior they want.<br>&gt;&gt; 2. Library A ships an update which fixes many bugs and security issues, and happens to eliminate the internal calls to the public method A was using. That is, overriding Athat method no longer has any effect within library A; only clients see the difference.<br>&gt;&gt; 3. The developer for client X goes to their manager and asks for time to fix the issue. The manager tells them not to update right now, but maybe after this next release.<br>&gt;&gt; 4. Client X never gets a new version of Library A ever again.<br>&gt; <br>&gt; Imho this is remarkable in two aspects:<br>&gt; It is the first real example I&#39;m aware of where I see a true problem, and it &quot;overthrows&quot; (there might be a less dramatic word I&#39;m not aware of) the position that &quot;sealed&quot; primarily solves a problem for library-authors.<br>&gt; <br>&gt; I agree that this problem is much less likely with sealed as default, but there&#39;s another one in this scenario:<br>&gt; Client X depends on the later-removed feature in Library A — but as this feature isn&#39;t accessible for him, he won&#39;t ever start using Library A at all…<br>&gt; None the less, I have to admit that I actually prefer the problem in the sealed-scenario, as it doesn&#39;t directly effect developer T, but rather pointy-haired boss Y, who just lost a potential customer ;-)<br>&gt; <br>&gt; I can&#39;t resist to add another culinary comparison to Jonathan Hull&#39;s excellent knife-analogy:<br>&gt; As the owner of a restaurant, would you fill your menu with food that&#39;s easy to cook to please your chef, or would you rather include food that tastes fantastic to please your customers?<br>&gt; <br>&gt;&gt; I guess another way of saying this is that library authors avoid these miscommunications by &quot;under-promising”, and if that “under-promising” is something that’s actually in the language instead of maybe/maybe-not being documented, then both sides are much more likely to be on the same page.<br>&gt; Damn, maybe I should have put this in front… why make false promises at all, when you just can tell the truth?<br></p><p><br>Publishing a library is a promise of something. It ought to only be promises the library author wants to make. If “the truth” is “the implementation in the current version of the library”, that’s definitely not what a library author should promise. That’s true for plenty of things, not just whether or not overriding is expected.<br></p><p>(A client might prefer that the current implementation is what’s promised, but in practice that’s almost never what either side actually wants.)<br></p><p>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160712/7829ccc8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>July 13, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; Publishing a library is a promise of something. It ought to only be promises the library author wants to make. If “the truth” is “the implementation in the current version of the library”, that’s definitely not what a library author should promise. That’s true for plenty of things, not just whether or not overriding is expected.<br>Correct, library users shouldn&#39;t have to puzzle over the authors intention, but I wasn&#39;t referring to source when I wrote about truth.<br>A good library should strive for flexibility, and don&#39;t impose restrictions that aren&#39;t necessary — &quot;lack of extendability&quot; imho is no promise an author should want to make.<br>So, what if he wants to promise extendability, but just isn&#39;t sure he will be able to stand by this promise? Instead of forcing him into lies, we could as well accept the reality of &quot;I&#39;m not sure&quot;, which imho would be the most reasonably default, as it doesn&#39;t pretend an explicit choice when there is only uncertainty.<br></p><p>Jonathan Hull outlined an alternative to 0117 (http://article.gmane.org/gmane.comp.lang.swift.evolution/23761 &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/23761&gt;) which takes that into account — and imho has additional benefits:<br>- More power (for example, UIView.drawRect and other methods that shouldn&#39;t be called by clients could be modeled)<br>- Less confusion (&quot;What&#39;s the point of subclassable and overridable? It has no effect on the ability to subclass and override in my app at all!&quot;)<br></p><p>Tino<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160713/a88cfad9/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July 11, 2016 at 07:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jul 10, 2016, at 10:38 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; [Proposal: https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md ]<br>&gt; <br>&gt; (This is my second response to this proposal. The previous message shared a use case where public-but-non-subclassable made things work out much better with required initializers. This one has a bit more ideology in it.)<br>&gt; <br>&gt; As many people have said already, this proposal is quite beneficial to library designers attempting to reason about their code, not just now but in the future as well. The model laid out in the Library Evolution document (often referred to as “resilience”) supports Swift libraries that want to preserve a stable binary and source interface.<br>&gt; <br>&gt; In the Swift 2 model (and what’s currently described in that document), a public class must be final or non-final at the time it is published. It’s clearly not safe to add ‘final&#39; in a later version of the library, because a client might already have a subclass; it’s also not safe to remove ‘final’ because existing clients may have been compiled assuming there are no subclasses.<br>&gt; <br>&gt; (Of course, we can remove this optimization, and make ‘final’ a semantic contract only. I’m deliberately avoiding most discussion of performance, but in this parenthetical I’ll note that Swift makes it possible to write code that is slower than Objective-C. This is considered acceptable because the compiler can often optimize it for a particular call site. For those who want more information about the current implementation of some of Swift’s features, I suggest watching the “Understanding Swift Performance” talk from this year’s WWDC.)<br>&gt; <br>&gt; With this proposal, a public class can be non-publicly-subclassable or publicly-subclassable. Once a class is publicly-subclassable (“open”), you can’t go back, of course. But a class that’s not initially open could become open in a future release of the library. All existing clients would already be equipped to deal with this, because there might be subclasses inside the library. On the other hand, the class can also be marked ‘final’, if the library author later realizes there will never be any subclasses and that both client authors and the compiler should know this.<br>&gt; <br>&gt; One point that’s not covered in this proposal is whether making a class ‘open’ applies retroactively, i.e. if MagicLib 1.2 is the first version that makes the Magician class ‘open’, can clients deploy back to MagicLib 1.0 and expect their subclasses to work? My inclination is to say no; if it’s possible for a non-open method to be overridden in the future, a library author has to write their library as if it will be overridden now, and there’s no point in making it non-open in the first place. That would make ‘open’ a “versioned attribute” in the terminology of Library Evolution, whatever the syntax ends up being.<br>&gt; <br>&gt; ---<br>&gt; <br>&gt; Okay, so why is this important?<br>&gt; <br>&gt; It all comes down to reasoning about your program’s behavior. When you use a class, you’re relying on the documented behavior of that class. More concretely, the methods on the class have preconditions (“performSegue(withIdentifier:sender:) should not be called on a view controller that didn’t come from a storyboard”) and postconditions (“after calling loadViewIfNeeded(), the view controller’s view will be loaded”). When you call a method, you’re responsible for satisfying its preconditions so it can deliver on the postconditions.<br>&gt; <br>&gt; I used UIViewController as an example, but it applies just as much to your own methods. When you call a method in your own module—maybe written by you, maybe by a coworker, maybe by an open source contributor—you’re expecting some particular behavior and output given the inputs and the current state of the program. That is, you just need to satisfy its preconditions so it can deliver on the postconditions. If it’s a method in your module, though, you might not have taken the trouble to formalize the preconditions and postconditions, since you can just go look at the implementation. Even if your expectations are violated, you’ll probably notice, because the conflict of understanding is within your own module.<br>&gt; <br>&gt; Public overriding changes all this. While an overridable method may have particular preconditions and postconditions, it’s possible that the overrider will get that wrong, which means the library author can no longer reason about the behavior of their program. If they do a poor job documenting the preconditions and postconditions, the client and the library will almost certainly disagree about the expected behavior of a particular method, and the program won’t work correctly.<br>&gt; <br>&gt; &quot;Doesn’t a library author have to figure out the preconditions and postconditions for a method anyway when making it public?&quot; Well, not to the same extent. It’s perfectly acceptable for a library author to document stronger preconditions and weaker postconditions than are strictly necessary. (Maybe &#39;performSegue(withIdentifier:sender:)’ has a mode that can work without storyboards, but UIKit isn’t promising that it will work.) When a library author lets people override their method, though, they&#39;re promising that the method will never be called with a weaker precondition than documented, and that nothing within their library will expect a stronger postcondition than documented.<br>&gt; <br>&gt; (By the way, the way to look at overriding a method is the inverse of calling a method: you need to deliver on the postconditions, and you can assume the caller has satisfied the preconditions. If your understanding of those preconditions and postconditions is wrong, your program won’t work correctly, just like when you’re calling a method.)<br>&gt; <br>&gt; This all goes double when a library author wants to release a new version of their library with different behavior. In order to make sure existing callers don’t break, they have to make sure all of the library’s documented preconditions are no stronger and postconditions are no weaker for public API. In order to make sure existing subclassers don’t break, they have to make sure all of the library’s documented preconditions are no weaker and postconditions are no stronger for overridable API.<br>&gt; <br>&gt; (For a very concrete example of this, say you’re calling a method with the type &#39;(Int?) -&gt; Int’, and you’re passing nil. The new version of the library can’t decide to make the parameter non-optional or the return value optional, because that would break your code. Similarly, if you’re overriding a method with the type ‘(Int) -&gt; Int?’, and returning nil, the new version of the library can’t decide to make the parameter optional or the return value non-optional, because that would break your code.)<br>&gt; <br>&gt; So, &quot;non-publicly-subclassable&quot; is a way to ease the burden on a library author. They should be thinking about preconditions and postconditions in their program anyway, but not having to worry about all the things a client might do for a method that shouldn’t be overridden means they can actually reason about the behavior—and thus the correctness—of their own program, both now and for future releases.<br>&gt; <br>&gt; ---<br>&gt; <br>&gt; I agree with several people on this thread that non-publicly-subclassable-by-default is the same idea as internal-by-default: it means that you have to explicitly decide to support a capability before clients can start relying on it, and you are very unlikely to do so by accident. The default is “safe” in that a library author can change their mind without breaking existing clients.<br>&gt; <br>&gt; I agree with John that even today, the entry points that happen to be public in the types that happen to be public classes are unlikely to be good entry points for fixing bugs in someone else&#39;s library. Disallowing overriding these particular entry points when a client already can&#39;t override internal methods, methods on structs, methods that use internal types, or top-level functions doesn’t really seem like a loss to me.<br>&gt; <br>&gt; Library design is important. Controlling the public interface of a library allows for better reasoning about the behavior of code, better security (i.e. better protection of user data), and better maintainability. And whether something can be overridden is part of that interface.<br>&gt; <br>&gt; Thanks again to Javier and John for putting this proposal together.<br>&gt; Jordan<br></p><p>Thanks for this really excellent, detailed analysis of the rationale for making sealed the default Jordan! <br></p><p>&gt; <br>&gt; P.S. There’s also an argument to be made for public-but-not-conformable protocols, i.e. protocols that can be used in generics and as values outside of a module, but cannot be conformed to. This is important for many of the same reasons as it is for classes, and we’ve gotten a few requests for it. (While you can get a similar effect using an enum, that’s a little less natural for code reuse via protocol extensions.)<br></p><p>FYI - I have been planning to propose exactly this feature for protocols once we get past the Swift 3 additive feature freeze.<br></p><p>&gt; <br>&gt; P.P.S. For those who will argue against “better security”, you’re correct: this doesn’t prevent an attack, and I don’t have much expertise in this area. However, I have talked to developers distributing binary frameworks (despite our warnings that it isn’t supported) who have asked us for various features to keep it from being easy.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/8cc542ef/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/73a38bb7bc9528e31098defe30e68ea4?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Jean-Daniel Dupas</string> &lt;mailing at xenonium.com&gt;<p>July 11, 2016 at 04:00:00pm</p></header><div class="content"><p>Just a though, but why sealed classes have to be completely unsubclassable ?<br></p><p>Wouldn&#39;t it be possible to allow the user to subclass sealed class, but deny overriding of any public member.<br></p><p>I see a use case where a user want to extends an existing model by adding new properties and new methods to an object but can’t use composition because doing that will prevent to pass that object to the framework that expect the base object.<br></p><p>That would let user override existing class to extends them, but should not cause any side effect in the way the class should behave, and so would not affects preconditions and postconditions, and should not prevent optimization in whole module compilation, as the methods of the base class are considered final outside of the module.<br></p><p>Of course, it will introduce some fragility in the library, as adding new methods may conflict with user subclass methods, but no more than what would append if the user write extension to add new methods to the model.<br></p><p>&gt; Le 11 juil. 2016 à 05:38, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; [Proposal: https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md&gt; ]<br>&gt; <br>&gt; (This is my second response to this proposal. The previous message shared a use case where public-but-non-subclassable made things work out much better with required initializers. This one has a bit more ideology in it.)<br>&gt; <br>&gt; As many people have said already, this proposal is quite beneficial to library designers attempting to reason about their code, not just now but in the future as well. The model laid out in the Library Evolution document &lt;http://jrose-apple.github.io/swift-library-evolution/&gt; (often referred to as “resilience”) supports Swift libraries that want to preserve a stable binary and source interface.<br>&gt; <br>&gt; In the Swift 2 model (and what’s currently described in that document), a public class must be final or non-final at the time it is published. It’s clearly not safe to add ‘final&#39; in a later version of the library, because a client might already have a subclass; it’s also not safe to remove ‘final’ because existing clients may have been compiled assuming there are no subclasses.<br>&gt; <br>&gt; (Of course, we can remove this optimization, and make ‘final’ a semantic contract only. I’m deliberately avoiding most discussion of performance, but in this parenthetical I’ll note that Swift makes it possible to write code that is slower than Objective-C. This is considered acceptable because the compiler can often optimize it for a particular call site. For those who want more information about the current implementation of some of Swift’s features, I suggest watching the “Understanding Swift Performance &lt;https://developer.apple.com/videos/play/wwdc2016/416/&gt;” talk from this year’s WWDC.)<br>&gt; <br>&gt; With this proposal, a public class can be non-publicly-subclassable or publicly-subclassable. Once a class is publicly-subclassable (“open”), you can’t go back, of course. But a class that’s not initially open could become open in a future release of the library. All existing clients would already be equipped to deal with this, because there might be subclasses inside the library. On the other hand, the class can also be marked ‘final’, if the library author later realizes there will never be any subclasses and that both client authors and the compiler should know this.<br>&gt; <br>&gt; One point that’s not covered in this proposal is whether making a class ‘open’ applies retroactively, i.e. if MagicLib 1.2 is the first version that makes the Magician class ‘open’, can clients deploy back to MagicLib 1.0 and expect their subclasses to work? My inclination is to say no; if it’s possible for a non-open method to be overridden in the future, a library author has to write their library as if it will be overridden now, and there’s no point in making it non-open in the first place. That would make ‘open’ a “versioned attribute &lt;http://jrose-apple.github.io/swift-library-evolution/#publishing-versioned-api&gt;” in the terminology of Library Evolution, whatever the syntax ends up being.<br>&gt; <br>&gt; ---<br>&gt; <br>&gt; Okay, so why is this important?<br>&gt; <br>&gt; It all comes down to reasoning about your program’s behavior. When you use a class, you’re relying on the documented behavior of that class. More concretely, the methods on the class have preconditions (“performSegue(withIdentifier:sender:) should not be called on a view controller that didn’t come from a storyboard”) and postconditions (“after calling loadViewIfNeeded(), the view controller’s view will be loaded”). When you call a method, you’re responsible for satisfying its preconditions so it can deliver on the postconditions.<br>&gt; <br>&gt; I used UIViewController as an example, but it applies just as much to your own methods. When you call a method in your own module—maybe written by you, maybe by a coworker, maybe by an open source contributor—you’re expecting some particular behavior and output given the inputs and the current state of the program. That is, you just need to satisfy its preconditions so it can deliver on the postconditions. If it’s a method in your module, though, you might not have taken the trouble to formalize the preconditions and postconditions, since you can just go look at the implementation. Even if your expectations are violated, you’ll probably notice, because the conflict of understanding is within your own module.<br>&gt; <br>&gt; Public overriding changes all this. While an overridable method may have particular preconditions and postconditions, it’s possible that the overrider will get that wrong, which means the library author can no longer reason about the behavior of their program. If they do a poor job documenting the preconditions and postconditions, the client and the library will almost certainly disagree about the expected behavior of a particular method, and the program won’t work correctly.<br>&gt; <br>&gt; &quot;Doesn’t a library author have to figure out the preconditions and postconditions for a method anyway when making it public?&quot; Well, not to the same extent. It’s perfectly acceptable for a library author to document stronger preconditions and weaker postconditions than are strictly necessary. (Maybe &#39;performSegue(withIdentifier:sender:)’ has a mode that can work without storyboards, but UIKit isn’t promising that it will work.) When a library author lets people override their method, though, they&#39;re promising that the method will never be called with a weaker precondition than documented, and that nothing within their library will expect a stronger postcondition than documented.<br>&gt; <br>&gt; (By the way, the way to look at overriding a method is the inverse of calling a method: you need to deliver on the postconditions, and you can assume the caller has satisfied the preconditions. If your understanding of those preconditions and postconditions is wrong, your program won’t work correctly, just like when you’re calling a method.)<br>&gt; <br>&gt; This all goes double when a library author wants to release a new version of their library with different behavior. In order to make sure existing callers don’t break, they have to make sure all of the library’s documented preconditions are no stronger and postconditions are no weaker for public API. In order to make sure existing subclassers don’t break, they have to make sure all of the library’s documented preconditions are no weaker and postconditions are no stronger for overridable API.<br>&gt; <br>&gt; (For a very concrete example of this, say you’re calling a method with the type &#39;(Int?) -&gt; Int’, and you’re passing nil. The new version of the library can’t decide to make the parameter non-optional or the return value optional, because that would break your code. Similarly, if you’re overriding a method with the type ‘(Int) -&gt; Int?’, and returning nil, the new version of the library can’t decide to make the parameter optional or the return value non-optional, because that would break your code.)<br>&gt; <br>&gt; So, &quot;non-publicly-subclassable&quot; is a way to ease the burden on a library author. They should be thinking about preconditions and postconditions in their program anyway, but not having to worry about all the things a client might do for a method that shouldn’t be overridden means they can actually reason about the behavior—and thus the correctness—of their own program, both now and for future releases.<br>&gt; <br>&gt; ---<br>&gt; <br>&gt; I agree with several people on this thread that non-publicly-subclassable-by-default is the same idea as internal-by-default: it means that you have to explicitly decide to support a capability before clients can start relying on it, and you are very unlikely to do so by accident. The default is “safe” in that a library author can change their mind without breaking existing clients.<br>&gt; <br>&gt; I agree with John that even today, the entry points that happen to be public in the types that happen to be public classes are unlikely to be good entry points for fixing bugs in someone else&#39;s library. Disallowing overriding these particular entry points when a client already can&#39;t override internal methods, methods on structs, methods that use internal types, or top-level functions doesn’t really seem like a loss to me.<br>&gt; <br>&gt; Library design is important. Controlling the public interface of a library allows for better reasoning about the behavior of code, better security (i.e. better protection of user data), and better maintainability. And whether something can be overridden is part of that interface.<br>&gt; <br>&gt; Thanks again to Javier and John for putting this proposal together.<br>&gt; Jordan<br>&gt; <br>&gt; P.S. There’s also an argument to be made for public-but-not-conformable protocols, i.e. protocols that can be used in generics and as values outside of a module, but cannot be conformed to. This is important for many of the same reasons as it is for classes, and we’ve gotten a few requests for it. (While you can get a similar effect using an enum, that’s a little less natural for code reuse via protocol extensions.)<br>&gt; <br>&gt; P.P.S. For those who will argue against “better security”, you’re correct: this doesn’t prevent an attack, and I don’t have much expertise in this area. However, I have talked to developers distributing binary frameworks (despite our warnings that it isn’t supported) who have asked us for various features to keep it from being easy.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/0fcdf902/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>July 11, 2016 at 12:00:00pm</p></header><div class="content"><p>Jean, given this proposal it will be possible if the developer of the<br>library intends so. You&#39;ll have to have unsealed classes to be able to<br>subclass them and unsealed methods so you can override. It is possible<br>to just allow subclassing without allowing overriding, just like<br>final.<br></p><p>As for conflicts I don&#39;t think so. If you declare a new method with<br>the same name as an existing one without overriding, it will become a<br>new method and the base class won&#39;t even know that new method exists.<br>C# allows this but uses the keyword new (instead of override) to<br>clarify a new method is being introduced instead of the existing one<br>but as far as I see there is no such need in Swift. I&#39;m also not sure<br>we can override a method inside an extension but if so, this provides<br>a new point of extension inside a class that is not subclassable.<br></p><p>L<br></p><p><br>On 11 July 2016 at 11:21, Jean-Daniel Dupas via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Just a though, but why sealed classes have to be completely unsubclassable ?<br>&gt;<br>&gt; Wouldn&#39;t it be possible to allow the user to subclass sealed class, but deny<br>&gt; overriding of any public member.<br>&gt;<br>&gt; I see a use case where a user want to extends an existing model by adding<br>&gt; new properties and new methods to an object but can’t use composition<br>&gt; because doing that will prevent to pass that object to the framework that<br>&gt; expect the base object.<br>&gt;<br>&gt; That would let user override existing class to extends them, but should not<br>&gt; cause any side effect in the way the class should behave, and so would not<br>&gt; affects preconditions and postconditions, and should not prevent<br>&gt; optimization in whole module compilation, as the methods of the base class<br>&gt; are considered final outside of the module.<br>&gt;<br>&gt; Of course, it will introduce some fragility in the library, as adding new<br>&gt; methods may conflict with user subclass methods, but no more than what would<br>&gt; append if the user write extension to add new methods to the model.<br>&gt;<br>&gt; Le 11 juil. 2016 à 05:38, Jordan Rose via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;<br>&gt; [Proposal:<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt; ]<br>&gt;<br>&gt; (This is my second response to this proposal. The previous message shared a<br>&gt; use case where public-but-non-subclassable made things work out much better<br>&gt; with required initializers. This one has a bit more ideology in it.)<br>&gt;<br>&gt; As many people have said already, this proposal is quite beneficial to<br>&gt; library designers attempting to reason about their code, not just now but in<br>&gt; the future as well. The model laid out in the Library Evolution document<br>&gt; (often referred to as “resilience”) supports Swift libraries that want to<br>&gt; preserve a stable binary and source interface.<br>&gt;<br>&gt; In the Swift 2 model (and what’s currently described in that document), a<br>&gt; public class must be final or non-final at the time it is published. It’s<br>&gt; clearly not safe to add ‘final&#39; in a later version of the library, because a<br>&gt; client might already have a subclass; it’s also not safe to remove ‘final’<br>&gt; because existing clients may have been compiled assuming there are no<br>&gt; subclasses.<br>&gt;<br>&gt; (Of course, we can remove this optimization, and make ‘final’ a semantic<br>&gt; contract only. I’m deliberately avoiding most discussion of performance, but<br>&gt; in this parenthetical I’ll note that Swift makes it possible to write code<br>&gt; that is slower than Objective-C. This is considered acceptable because the<br>&gt; compiler can often optimize it for a particular call site. For those who<br>&gt; want more information about the current implementation of some of Swift’s<br>&gt; features, I suggest watching the “Understanding Swift Performance” talk from<br>&gt; this year’s WWDC.)<br>&gt;<br>&gt; With this proposal, a public class can be non-publicly-subclassable or<br>&gt; publicly-subclassable. Once a class is publicly-subclassable (“open”), you<br>&gt; can’t go back, of course. But a class that’s not initially open could become<br>&gt; open in a future release of the library. All existing clients would already<br>&gt; be equipped to deal with this, because there might be subclasses inside the<br>&gt; library. On the other hand, the class can also be marked ‘final’, if the<br>&gt; library author later realizes there will never be any subclasses and that<br>&gt; both client authors and the compiler should know this.<br>&gt;<br>&gt; One point that’s not covered in this proposal is whether making a class<br>&gt; ‘open’ applies retroactively, i.e. if MagicLib 1.2 is the first version that<br>&gt; makes the Magician class ‘open’, can clients deploy back to MagicLib 1.0 and<br>&gt; expect their subclasses to work? My inclination is to say no; if it’s<br>&gt; possible for a non-open method to be overridden in the future, a library<br>&gt; author has to write their library as if it will be overridden now, and<br>&gt; there’s no point in making it non-open in the first place. That would make<br>&gt; ‘open’ a “versioned attribute” in the terminology of Library Evolution,<br>&gt; whatever the syntax ends up being.<br>&gt;<br>&gt; ---<br>&gt;<br>&gt; Okay, so why is this important?<br>&gt;<br>&gt; It all comes down to reasoning about your program’s behavior. When you use a<br>&gt; class, you’re relying on the documented behavior of that class. More<br>&gt; concretely, the methods on the class have preconditions<br>&gt; (“performSegue(withIdentifier:sender:) should not be called on a view<br>&gt; controller that didn’t come from a storyboard”) and postconditions (“after<br>&gt; calling loadViewIfNeeded(), the view controller’s view will be loaded”).<br>&gt; When you call a method, you’re responsible for satisfying its preconditions<br>&gt; so it can deliver on the postconditions.<br>&gt;<br>&gt; I used UIViewController as an example, but it applies just as much to your<br>&gt; own methods. When you call a method in your own module—maybe written by you,<br>&gt; maybe by a coworker, maybe by an open source contributor—you’re expecting<br>&gt; some particular behavior and output given the inputs and the current state<br>&gt; of the program. That is, you just need to satisfy its preconditions so it<br>&gt; can deliver on the postconditions. If it’s a method in your module, though,<br>&gt; you might not have taken the trouble to formalize the preconditions and<br>&gt; postconditions, since you can just go look at the implementation. Even if<br>&gt; your expectations are violated, you’ll probably notice, because the conflict<br>&gt; of understanding is within your own module.<br>&gt;<br>&gt; Public overriding changes all this. While an overridable method may have<br>&gt; particular preconditions and postconditions, it’s possible that the<br>&gt; overrider will get that wrong, which means the library author can no longer<br>&gt; reason about the behavior of their program. If they do a poor job<br>&gt; documenting the preconditions and postconditions, the client and the library<br>&gt; will almost certainly disagree about the expected behavior of a particular<br>&gt; method, and the program won’t work correctly.<br>&gt;<br>&gt; &quot;Doesn’t a library author have to figure out the preconditions and<br>&gt; postconditions for a method anyway when making it public?&quot; Well, not to the<br>&gt; same extent. It’s perfectly acceptable for a library author to document<br>&gt; stronger preconditions and weaker postconditions than are strictly<br>&gt; necessary. (Maybe &#39;performSegue(withIdentifier:sender:)’ has a mode that can<br>&gt; work without storyboards, but UIKit isn’t promising that it will work.) When<br>&gt; a library author lets people override their method, though, they&#39;re<br>&gt; promising that the method will never be called with a weaker precondition<br>&gt; than documented, and that nothing within their library will expect a<br>&gt; stronger postcondition than documented.<br>&gt;<br>&gt; (By the way, the way to look at overriding a method is the inverse of<br>&gt; calling a method: you need to deliver on the postconditions, and you can<br>&gt; assume the caller has satisfied the preconditions. If your understanding of<br>&gt; those preconditions and postconditions is wrong, your program won’t work<br>&gt; correctly, just like when you’re calling a method.)<br>&gt;<br>&gt; This all goes double when a library author wants to release a new version of<br>&gt; their library with different behavior. In order to make sure existing<br>&gt; callers don’t break, they have to make sure all of the library’s documented<br>&gt; preconditions are no stronger and postconditions are no weaker for public<br>&gt; API. In order to make sure existing subclassers don’t break, they have to<br>&gt; make sure all of the library’s documented preconditions are no weaker and<br>&gt; postconditions are no stronger for overridable API.<br>&gt;<br>&gt; (For a very concrete example of this, say you’re calling a method with the<br>&gt; type &#39;(Int?) -&gt; Int’, and you’re passing nil. The new version of the library<br>&gt; can’t decide to make the parameter non-optional or the return value<br>&gt; optional, because that would break your code. Similarly, if you’re<br>&gt; overriding a method with the type ‘(Int) -&gt; Int?’, and returning nil, the<br>&gt; new version of the library can’t decide to make the parameter optional or<br>&gt; the return value non-optional, because that would break your code.)<br>&gt;<br>&gt; So, &quot;non-publicly-subclassable&quot; is a way to ease the burden on a library<br>&gt; author. They should be thinking about preconditions and postconditions in<br>&gt; their program anyway, but not having to worry about all the things a client<br>&gt; might do for a method that shouldn’t be overridden means they can actually<br>&gt; reason about the behavior—and thus the correctness—of their own program,<br>&gt; both now and for future releases.<br>&gt;<br>&gt; ---<br>&gt;<br>&gt; I agree with several people on this thread that<br>&gt; non-publicly-subclassable-by-default is the same idea as<br>&gt; internal-by-default: it means that you have to explicitly decide to support<br>&gt; a capability before clients can start relying on it, and you are very<br>&gt; unlikely to do so by accident. The default is “safe” in that a library<br>&gt; author can change their mind without breaking existing clients.<br>&gt;<br>&gt; I agree with John that even today, the entry points that happen to be public<br>&gt; in the types that happen to be public classes are unlikely to be good entry<br>&gt; points for fixing bugs in someone else&#39;s library. Disallowing overriding<br>&gt; these particular entry points when a client already can&#39;t override internal<br>&gt; methods, methods on structs, methods that use internal types, or top-level<br>&gt; functions doesn’t really seem like a loss to me.<br>&gt;<br>&gt; Library design is important. Controlling the public interface of a library<br>&gt; allows for better reasoning about the behavior of code, better security<br>&gt; (i.e. better protection of user data), and better maintainability. And<br>&gt; whether something can be overridden is part of that interface.<br>&gt;<br>&gt; Thanks again to Javier and John for putting this proposal together.<br>&gt; Jordan<br>&gt;<br>&gt; P.S. There’s also an argument to be made for public-but-not-conformable<br>&gt; protocols, i.e. protocols that can be used in generics and as values outside<br>&gt; of a module, but cannot be conformed to. This is important for many of the<br>&gt; same reasons as it is for classes, and we’ve gotten a few requests for it.<br>&gt; (While you can get a similar effect using an enum, that’s a little less<br>&gt; natural for code reuse via protocol extensions.)<br>&gt;<br>&gt; P.P.S. For those who will argue against “better security”, you’re correct:<br>&gt; this doesn’t prevent an attack, and I don’t have much expertise in this<br>&gt; area. However, I have talked to developers distributing binary frameworks<br>&gt; (despite our warnings that it isn’t supported) who have asked us for various<br>&gt; features to keep it from being easy.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>July 11, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jul 11, 2016, at 08:13, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br>&gt; <br>&gt; Jean, given this proposal it will be possible if the developer of the<br>&gt; library intends so. You&#39;ll have to have unsealed classes to be able to<br>&gt; subclass them and unsealed methods so you can override. It is possible<br>&gt; to just allow subclassing without allowing overriding, just like<br>&gt; final.<br>&gt; <br>&gt; As for conflicts I don&#39;t think so. If you declare a new method with<br>&gt; the same name as an existing one without overriding, it will become a<br>&gt; new method and the base class won&#39;t even know that new method exists.<br>&gt; C# allows this but uses the keyword new (instead of override) to<br>&gt; clarify a new method is being introduced instead of the existing one<br>&gt; but as far as I see there is no such need in Swift. I&#39;m also not sure<br>&gt; we can override a method inside an extension but if so, this provides<br>&gt; a new point of extension inside a class that is not subclassable.<br></p><p>This is something you’d need if the client were itself a library that couldn’t break backwards-compatibility by renaming its conflicting method. We could either have a “new” or “nonoverriding” annotation or a way to rename methods while preserving their binary interface, but <br></p><p>You cannot safely override a method inside an extension unless you also control the original method. See my analysis in this draft of a future proposal &lt;https://github.com/jrose-apple/swift-evolution/blob/dc5b0cd7d646c161ede08800cdb4ec90286c6a44/proposals/nnnn-overridable-members-in-extensions.md&gt;.<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/67d3da32/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>July 11, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Jul 11, 2016, at 07:21, Jean-Daniel Dupas &lt;mailing at xenonium.com&gt; wrote:<br>&gt; <br>&gt; Just a though, but why sealed classes have to be completely unsubclassable ?<br>&gt; <br>&gt; Wouldn&#39;t it be possible to allow the user to subclass sealed class, but deny overriding of any public member.<br>&gt; <br>&gt; I see a use case where a user want to extends an existing model by adding new properties and new methods to an object but can’t use composition because doing that will prevent to pass that object to the framework that expect the base object.<br>&gt; <br>&gt; That would let user override existing class to extends them, but should not cause any side effect in the way the class should behave, and so would not affects preconditions and postconditions, and should not prevent optimization in whole module compilation, as the methods of the base class are considered final outside of the module.<br>&gt; <br>&gt; Of course, it will introduce some fragility in the library, as adding new methods may conflict with user subclass methods, but no more than what would append if the user write extension to add new methods to the model.<br></p><p>DaveA and I actually talked about this, and IIRC we decided it was completely safe semantically, and only left a few optimization opportunities on the table (things like knowing what a deinitializer might or might not do). However, we felt it was a more complicated model that still ended up with the “de facto sealed” case of all initializers being non-public, and so it wasn’t worth stopping at that point in the design space.<br></p><p>(It was a while ago, so I might have forgotten something else relevant.)<br></p><p>Jordan<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/73a38bb7bc9528e31098defe30e68ea4?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Jean-Daniel Dupas</string> &lt;mailing at xenonium.com&gt;<p>July 11, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; Le 11 juil. 2016 à 17:43, Jordan Rose &lt;jordan_rose at apple.com&gt; a écrit :<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 11, 2016, at 07:21, Jean-Daniel Dupas &lt;mailing at xenonium.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Just a though, but why sealed classes have to be completely unsubclassable ?<br>&gt;&gt; <br>&gt;&gt; Wouldn&#39;t it be possible to allow the user to subclass sealed class, but deny overriding of any public member.<br>&gt;&gt; <br>&gt;&gt; I see a use case where a user want to extends an existing model by adding new properties and new methods to an object but can’t use composition because doing that will prevent to pass that object to the framework that expect the base object.<br>&gt;&gt; <br>&gt;&gt; That would let user override existing class to extends them, but should not cause any side effect in the way the class should behave, and so would not affects preconditions and postconditions, and should not prevent optimization in whole module compilation, as the methods of the base class are considered final outside of the module.<br>&gt;&gt; <br>&gt;&gt; Of course, it will introduce some fragility in the library, as adding new methods may conflict with user subclass methods, but no more than what would append if the user write extension to add new methods to the model.<br>&gt; <br>&gt; DaveA and I actually talked about this, and IIRC we decided it was completely safe semantically, and only left a few optimization opportunities on the table (things like knowing what a deinitializer might or might not do). However, we felt it was a more complicated model that still ended up with the “de facto sealed” case of all initializers being non-public, and so it wasn’t worth stopping at that point in the design space.<br>&gt; <br>&gt; (It was a while ago, so I might have forgotten something else relevant.)<br>&gt; <br>&gt; Jordan<br>&gt; <br></p><p>OK,<br></p><p>Thanks for the explanation and the long argumentation about why sealed by default make sens. You made me change my stance about the proposal. I just hope the seal keyword will be properly explained and will not make subclassing a second class citizen by discouraging developer to support it.<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c65faa002b79348ac10e1fb9c1a9ad83?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Colin Cornaby</string> &lt;colin.cornaby at mac.com&gt;<p>July 11, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>Extremely strong -1.<br></p><p>I understand the performance benefit, but it’s extremely problematic if you’ve used other languages like C++ that make the same tradeoff. The performance benefit also seems unnecessary for a lot of code, and if you need the performance, it’s easy enough to mark the class final.<br></p><p>Being able to subclass is critical not only to OOP design, but also Cocoa design. Making classes final by default will mean that a lot of classes will unnecessarily not support subclassing, which can complicate design.<br></p><p>This also strongly affects unit testing by getting rid of one of the easiest ways to mock input and output to a unit. It’s not enough to say third party code should be treated as black box. One of the best ways to test input and output from an object is to subclass the objects it communicates to and override the entry points. The biggest gaps I have in my code coverage are where I talk to non-virtual-by-default C++ methods and I can’t mock the output from those modules to hit all my cases.<br></p><p>As someone who writes an API for my day job, I am perfectly fine marking things as final by hand when necessary (when I finally get to jump to Swift.) It’s not inconvenient at all. I would much rather favor making public inheritance issues easier to surface in Swift. Public inheritance can be tricky, but this feels a bit like cutting off our noses to spite our own face. If you are a responsible public API vendor, you should be thinking about inheritance, or marking as final. And it’s wiping out one of Swift and Obj-C’s major advantages over C++.<br></p><p>The “final should be default because adding final after the fact is destructive” arguments are interesting, but ultimately not convincing to me. If you thought your class was safe for subclassing, but it ultimately wasn’t, this solves nothing. You’ll mark your class as subclassable, and you will ship it, and there will be issues, but it will still be too late to take things back. If you know your class is not safe for subclassing, you should mark it as final. There is no advantage here in that scenario.<br></p><p>This is all part of building a safe public API. Public API design can be difficult, but if you don’t understand safe subclassing designs, you are likely to miss the issues and mark your class as subclassable and ship it anyway. Again, the best way to tackle this is to find better ways to surface the issues. Making final the default still doesn’t solve the core issues of people not understanding the right design.<br></p><p>(I’d, ironically enough, be a lot more open to this proposal if Swift supported more dynamic things like proxies that could let you emulate subclassing without actually doing so. But I think that’s veering away from relatability of the language)<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e910871dda004717de19e83626308b5a?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Tony Allevato</string> &lt;allevato at google.com&gt;<p>July 11, 2016 at 07:00:00pm</p></header><div class="content"><p>On Tue, Jul 5, 2016 at 4:11 PM Chris Lattner &lt;clattner at apple.com&gt; wrote:<br></p><p>&gt; Hello Swift community,<br>&gt;<br>&gt; The review of &quot;SE-0117: Default classes to be non-subclassable publicly&quot;<br>&gt; begins now and runs through July 11. The proposal is available here:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt; should be sent to the swift-evolution mailing list at<br>&gt;<br>&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the<br>&gt; review manager.<br>&gt;<br>&gt; What goes into a review?<br>&gt;<br>&gt; The goal of the review process is to improve the proposal under review<br>&gt; through constructive criticism and contribute to the direction of Swift.<br>&gt; When writing your review, here are some questions you might want to answer<br>&gt; in your review:<br>&gt;<br>&gt;         * What is your evaluation of the proposal?<br>&gt;<br></p><p>+1. As a big proponent of API reviews for code that&#39;s going to end up being<br>used by others, I think sealed-by-default forces authors to think about how<br>their code might end up being used by others more so than more-permissive<br>alternatives. Seeing a keyword that marks a class as unsealed is a good<br>opportunity to start a conversation in a code review.<br></p><p>Given that Swift tries to encourage the use of value types over reference<br>types in many places, which can&#39;t be subclassed anyway, I don&#39;t think this<br>change should be a significant burden. I&#39;m in the process of implementing a<br>fairly large library that&#39;s about 95% value types and 5% reference types.<br>The reference types are more of an implementation detail than a hierarchy<br>of types, so I would have them be final anyway. This is completely<br>anecdotal, of course, but it&#39;s a testament IMO to how differently Swift has<br>me thinking about the way I structure my APIs, and subclassing has been<br>mostly replaced by protocol extensions and composition.<br></p><p>I&#39;m not compelled by the arguments that we need subclassing to fix bad<br>APIs, because that&#39;s absolutely not what subclassing is intended for. It&#39;s<br>a hack, and it&#39;s not a cure-all—it relies on being able to override the<br>correct methods and inject custom behavior in the first place. The argument<br>shouldn&#39;t be &quot;we need open subclassing or we can&#39;t fix broken APIs&quot;; that&#39;s<br>a false choice. It should be &quot;we need *something* to fix broken APIs&quot;, and<br>that &quot;something&quot; should be proposed and the need for it should be argued in<br>its own right. The ability to fix a sealed broken API does have value, but<br>it is inherently unsafe because you might be making assumptions about<br>pre/post-conditions that the original class author didn&#39;t think about, and<br>those assumptions could become invalid in the future (or might rely on<br>internal implementation details that you cannot predict). Rather than<br>abusing a construct that is not suited for that purpose, those arguing for<br>the need for that functionality should propose something more appropriate.<br>This would be a win-win; we&#39;d have a clean way of expressing API<br>boundaries, and an unsafe-but-acknowledged-as-such way of hooking into APIs<br>if a trap door is needed. (Of course, with Swift at such a young age, it&#39;s<br>hard to know what the needs for that are until we have some more mature<br>libraries to present as use cases.)<br></p><p><br></p><p>&gt;         * Is the problem being addressed significant enough to warrant a<br>&gt; change to Swift?<br>&gt;<br></p><p>Yes.<br></p><p><br></p><p>&gt;         * Does this proposal fit well with the feel and direction of Swift?<br>&gt;<br></p><p>Yes. The behavior that classes are unsealed within the same module but<br>sealed by default outside the module aligns nicely with the way internal<br>visibility already works in the language. Newcomers and app developers<br>don&#39;t have to think about it, but those who want to release code for others<br>to use must; I think that&#39;s the right level of responsibility.<br></p><p><br></p><p>&gt;         * If you have used other languages or libraries with a similar<br>&gt; feature, how do you feel that this proposal compares to those?<br></p><p>        * How much effort did you put into your review? A glance, a quick<br>&gt; reading, or an in-depth study?<br>&gt;<br></p><p>Read the proposal and followed the heated discussion in the review thread.<br></p><p><br></p><p>&gt;<br>&gt; More information about the Swift evolution process is available at<br>&gt;<br>&gt;         https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;<br>&gt; Thank you,<br>&gt;<br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution-announce mailing list<br>&gt; swift-evolution-announce at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution-announce<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/071bae94/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>July 11, 2016 at 10:00:00pm</p></header><div class="content"><p>Regards<br>(From mobile)<br></p><p>&gt; On Jul 11, 2016, at 9:43 PM, Tony Allevato via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Tue, Jul 5, 2016 at 4:11 PM Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt; Hello Swift community,<br>&gt;&gt; <br>&gt;&gt; The review of &quot;SE-0117: Default classes to be non-subclassable publicly&quot; begins now and runs through July 11. The proposal is available here:<br>&gt;&gt; <br>&gt;&gt;         https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt;&gt; <br>&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt; <br>&gt;&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt;&gt; <br>&gt;&gt; What goes into a review?<br>&gt;&gt; <br>&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt; <br>&gt;&gt;         * What is your evaluation of the proposal?<br>&gt; <br>&gt; +1. As a big proponent of API reviews for code that&#39;s going to end up being used by others, I think sealed-by-default forces authors to think about how their code might end up being used by others more so than more-permissive alternatives<br></p><p>Believing that joe lambda devs might think about their code more because the compiler is going to prevent certain obscure behavior from happening seems IMHO like a blattant negation of what history tells us about human nature. Given 2 choices, most of us will choose the one involving the least amount of thinking or work; and given 2 choices with different amount of responsibilities, most of use will choose the least amount of perceived individual responsibility. Psychology 101, demonstrated in many experimentations.<br></p><p>Doing it because the core team wants to do it has the merrit of recognizing that in the end, they hold the keyboard and should be free to write whatever they fancy, regardless of where the choir sings. Simple and clear.<br>Design by consensus is the worst form of design, and the Linux kernel would never have made it to where it is today if Linus had not ignored what he had to when he had to. Happens what must happen.. and there should be no need for the half baked logic that has sometimes been invoked.<br></p><p>&gt; . Seeing a keyword that marks a class as unsealed is a good opportunity to start a conversation in a code review.<br></p><p>I have honestly never seen ios devs doing that, including in large corps. Most devs I met were lone guys or small shops working on several things in parallel, with no code review and much less discussions about software design. <br></p><p>&gt; Given that Swift tries to encourage the use of value types over reference types in many places, which can&#39;t be subclassed anyway, I don&#39;t think this change should be a significant burden. I&#39;m in the process of implementing a fairly large library that&#39;s about 95% value types and 5% reference types. The reference types are more of an implementation detail than a hierarchy of types, so I would have them be final anyway. This is completely anecdotal, of course, but it&#39;s a testament IMO to how differently Swift has me thinking about the way I structure my APIs, and subclassing has been mostly replaced by protocol extensions and composition.<br>&gt; <br>&gt; I&#39;m not compelled by the arguments that we need subclassing to fix bad APIs, because that&#39;s absolutely not what subclassing is intended for. It&#39;s a hack, and it&#39;s not a cure-all—it relies on being able to override the correct methods and inject custom behavior in the first place. The argument shouldn&#39;t be &quot;we need open subclassing or we can&#39;t fix broken APIs&quot;; that&#39;s a false choice. It should be &quot;we need *something* to fix broken APIs&quot;, and that &quot;something&quot; should be proposed and the need for it should be argued in its own right. The ability to fix a sealed broken API does have value, but it is inherently unsafe because you might be making assumptions about pre/post-conditions that the original class author didn&#39;t think about, and those assumptions could become invalid in the future (or might rely on internal implementation details that you cannot predict). Rather than abusing a construct that is not suited for that purpose, those arguing for the need for that functionality should propose something more appropriate. This would be a win-win; we&#39;d have a clean way of expressing API boundaries, and an unsafe-but-acknowledged-as-such way of hooking into APIs if a trap door is needed. (Of course, with Swift at such a young age, it&#39;s hard to know what the needs for that are until we have some more mature libraries to present as use cases.)<br>&gt; <br>&gt;  <br>&gt;&gt;         * Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; <br>&gt; Yes.<br>&gt; <br>&gt;  <br>&gt;&gt;         * Does this proposal fit well with the feel and direction of Swift?<br>&gt; <br>&gt; Yes. The behavior that classes are unsealed within the same module but sealed by default outside the module aligns nicely with the way internal visibility already works in the language. Newcomers and app developers don&#39;t have to think about it, but those who want to release code for others to use must; I think that&#39;s the right level of responsibility.<br>&gt; <br>&gt;  <br>&gt;&gt;         * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt;         * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; Read the proposal and followed the heated discussion in the review thread.<br>&gt; <br>&gt;  <br>&gt;&gt; <br>&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt; <br>&gt;&gt;         https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt; <br>&gt;&gt; Thank you,<br>&gt;&gt; <br>&gt;&gt; -Chris Lattner<br>&gt;&gt; Review Manager<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution-announce mailing list<br>&gt;&gt; swift-evolution-announce at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution-announce<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/65f51ef4/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>July 12, 2016 at 07:00:00am</p></header><div class="content"><p>+1 for the feature, +0.5 for being it the default and -1 for they syntax.<br>I&#39;d prefer `open`, maybe `public(open)` or probably better `public open`.<br></p><p>I think library design is important and so this is a problem worth solving. I read the proposal and followed the discussion.<br></p><p>-Thorsten <br></p><p>&gt; Am 06.07.2016 um 01:11 schrieb Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;SE-0117: Default classes to be non-subclassable publicly&quot; begins now and runs through July 11. The proposal is available here:<br>&gt; <br>&gt;    https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt;    https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt;    * What is your evaluation of the proposal?<br>&gt;    * Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;    * Does this proposal fit well with the feel and direction of Swift?<br>&gt;    * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;    * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt;    https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ad5d998258bab37d23bc9555b0d6c237?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Max Desiatov</string> &lt;max.desiatov at gmail.com&gt;<p>July 12, 2016 at 12:00:00pm</p></header><div class="content"><p>-1. I strongly oppose this proposal and think that it adds substantial<br>complexity to the language with introduction of yet another set of keywords<br>that are similar to `final` and visibility modifiers, but work differently.<br>The proposal doesn&#39;t cover the behaviour of `final` and having `final` and<br>`overridable`/`subclassable` in the language at the same time would make it<br>more complex and harder to learn.<br></p><p>&gt; 06.07.2016 01:11 Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt; &gt;<br>&gt; &gt; Hello Swift community,<br>&gt; &gt;<br>&gt; &gt; The review of &quot;SE-0117: Default classes to be non-subclassable publicly&quot;<br>&gt; begins now and runs through July 11. The proposal is available here:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt; &gt;<br>&gt; &gt; Reviews are an important part of the Swift evolution process. All<br>&gt; reviews should be sent to the swift-evolution mailing list at<br>&gt; &gt;<br>&gt; &gt;    https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt; or, if you would like to keep your feedback private, directly to the<br>&gt; review manager.<br>&gt; &gt;<br>&gt; &gt; What goes into a review?<br>&gt; &gt;<br>&gt; &gt; The goal of the review process is to improve the proposal under review<br>&gt; through constructive criticism and contribute to the direction of Swift.<br>&gt; When writing your review, here are some questions you might want to answer<br>&gt; in your review:<br>&gt; &gt;<br>&gt; &gt;    * What is your evaluation of the proposal?<br>&gt; &gt;    * Is the problem being addressed significant enough to warrant a<br>&gt; change to Swift?<br>&gt; &gt;    * Does this proposal fit well with the feel and direction of Swift?<br>&gt; &gt;    * If you have used other languages or libraries with a similar<br>&gt; feature, how do you feel that this proposal compares to those?<br>&gt; &gt;    * How much effort did you put into your review? A glance, a quick<br>&gt; reading, or an in-depth study?<br>&gt; &gt;<br>&gt; &gt; More information about the Swift evolution process is available at<br>&gt; &gt;<br>&gt; &gt;    https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; &gt;<br>&gt; &gt; Thank you,<br>&gt; &gt;<br>&gt; &gt; -Chris Lattner<br>&gt; &gt; Review Manager<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160712/083c9255/attachment-0001.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>July 12, 2016 at 12:00:00am</p></header><div class="content"><p>-1 for this proposal, but +1 for solving the issues it raises<br></p><p>Regardless of what ends up being the defaults, I’m a very strong -1 on conflating visibility and subclassability/extendability.<br></p><p>- Dave Sweeris<br></p><p>&gt; On Jul 5, 2016, at 6:11 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;SE-0117: Default classes to be non-subclassable publicly&quot; begins now and runs through July 11.<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
