<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>Proposal: willGet</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>December 13, 2015 at 01:00:00pm</p></header><div class="content"><p>I can see several potential problems with this proposal, but it’s straightforward in concept, so I’m throwing it out for everyone to pick apart.<br></p><p><br>MOTIVATION<br></p><p>Siesta has several API calls that, like UIView hierarchies for example, should only be used from the main thread. (Yes, there are good design reasons for this. I’ll spare you the details.)<br></p><p>I have an assertMainThread() sanity check designed to catch developer thread usage mistakes at development time. I’m running through my public methods, adding calls where appropriate.<br></p><p>However, what I _really_ want to guard is not methods but properties. I’d need to add assertMainThread() in far fewer places, and would achieve better coverage, if I could attach it to property access.<br></p><p><br>PROPOSAL<br></p><p>Provide a “willGet” decorator for properties.<br></p><p>It cannot affect the returned value, and thus does not make the property a computed property. That means it can be attached even to let properties:<br></p><p>    let foo: String {<br>        willGet { assertMainThread() }<br>    }<br></p><p>Possible uses:<br></p><p>	access preconditions<br>	logging<br>	access counting / profiling<br></p><p><br>ALTERNATIVES<br></p><p>Of course I can do this:<br></p><p>    var foo: String {<br>        get {<br>            assertMainThread()<br>            return _foo<br>        }<br>        set {<br>            assertMainThread()<br>           _foo = newValue<br>        }<br>    }<br></p><p>    private var _foo: String<br></p><p>…but that gets messy when multiplied over all properties. Much nicer to do this:<br></p><p>    var foo: String {<br>        willGet { assertMainThread() }<br>        willSet { assertMainThread() }<br>    }<br></p><p><br>QUESTIONS / CRITIQUES<br></p><p>I know there’s talk on the core team of some more robust property decoration mechanism. Does this already fold into that effort?<br></p><p>Should willGet allow side effects? If so, does the existence of mutating getters in structs play out nonsensically?<br></p><p>Does this complicate the computed / non-computed property distinction for the compiler?<br></p><p>Does this preclude useful optimizations?<br></p><p>Does this open the door to horrible, horrible code? Wait, I know the answer to that one. It is a programming language feature … so yes, yes it does.<br></p><p>Cheers,<br></p><p>Paul<br></p><p><br>–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––<br>https://innig.net • @inthehands • http://siestaframework.com/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: willGet</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 13, 2015 at 01:00:00pm</p></header><div class="content"><p>On Dec 13, 2015, at 11:23 AM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; PROPOSAL<br>&gt; <br>&gt; Provide a “willGet” decorator for properties.<br>&gt; <br>&gt; It cannot affect the returned value, and thus does not make the property a computed property. That means it can be attached even to let properties:<br>&gt; <br>&gt;    let foo: String {<br>&gt;        willGet { assertMainThread() }<br>&gt;    }<br></p><p>My opinion is that this is too narrow to be worth complicating the language for.  Property observers are simply sugar for computed getters, and we only did them in Swift 1 because they use-cases they covered were so common.  The hope is that we can eliminate them as a language concept and move them out to the standard library as well.<br></p><p>&gt; QUESTIONS / CRITIQUES<br>&gt; <br>&gt; I know there’s talk on the core team of some more robust property decoration mechanism. Does this already fold into that effort?<br></p><p>Yes, I believe that this should be covered by that work, which is great. :-)<br></p><p>&gt; Should willGet allow side effects? If so, does the existence of mutating getters in structs play out nonsensically?<br></p><p>It depends on what you mean.  Swift does support “mutating getters”, but that means the getter cannot be used on a “let” value of that type.  If you mean side effects in general (e.g. calling print) then that would be fine (but probably still not a great idea for predictability :-)<br></p><p>&gt; Does this complicate the computed / non-computed property distinction for the compiler?<br></p><p>No, this is sugar for computed properties.<br></p><p>&gt; Does this preclude useful optimizations?<br></p><p>As stated, probably not.<br></p><p>&gt; Does this open the door to horrible, horrible code? Wait, I know the answer to that one. It is a programming language feature … so yes, yes it does.<br></p><p>exactly! :-)<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>Proposal: willGet</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>December 13, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt;&gt; I know there’s talk on the core team of some more robust property decoration mechanism. Does this already fold into that effort?<br>&gt; <br>&gt; Yes, I believe that this should be covered by that work, which is great. :-)<br></p><p>Then I’d plop it in as a use case (admittedly one of the less compelling ones) for that work, and drop this proposal.<br></p><p>Is any of that work public yet? It sounds exciting. (Apologies if that question is a repeat; I confess that I have not followed every single message on this list.)<br></p><p>Cheers, P<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: willGet</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 13, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 13, 2015, at 1:48 PM, Paul Cantrell &lt;cantrell at pobox.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; I know there’s talk on the core team of some more robust property decoration mechanism. Does this already fold into that effort?<br>&gt;&gt; <br>&gt;&gt; Yes, I believe that this should be covered by that work, which is great. :-)<br>&gt; <br>&gt; Then I’d plop it in as a use case (admittedly one of the less compelling ones) for that work, and drop this proposal.<br>&gt; <br>&gt; Is any of that work public yet?<br></p><p>Not yet. Joe Groff is driving the proposal, but has a number of other things on his plate as well.  Our goal is to get it out before our holiday break, which starts Dec 24, but it might slip into the new year depending on how other things go.<br></p><p>-Chris<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>Proposal: willGet</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>December 14, 2015 at 09:00:00am</p></header><div class="content"><p>Hi, this is an alternative to your proposal, taking into account Chris&#39;<br>comments.<br></p><p>You could add precondition and postcondition on protocol methods and<br>properties, for example:<br></p><p>protocol Configurable {<br>    typealias Configuration<br></p><p>    var configured: Bool {<br>        @non-mutating get<br>        set { precondition { configured == false } }<br>    }<br></p><p>    // unsure if this syntax is confusing, but it&#39;s consistent with get/set<br>    func configure(configuration: Configuration) {<br>        precondition { configured == false }<br>        postcondition { configured == true }<br>    }<br>}<br></p><p>The terms precondition, postcondition and @non-mutating are up for debate.<br></p><p>Importantly: conditions would have to be side-effect free and return a<br>Bool. They would work just like an assertion, and output their condition on<br>failure (ie. &quot;Failed precondition: &#39;configured == false&#39;!&quot;).<br></p><p>By side-effect free I mean:<br> * They would only be able to read properties (instance, or external)<br>annotated as @non-mutating.<br> * They can run methods (instance, or external) marked as @non-mutating.<br> * Things like print(...) cannot be used, the program should be free to<br>optimise these out.<br></p><p>This annotation may be used like @noescape. It would have to be verified by<br>the compiler, it may be done automatically (iirc. LLVM has a similar<br>annotation) but that could lower programmer awareness.<br></p><p>If it&#39;s possible to check the conditions at compile-time it would be great<br>to do so, there&#39;s a proposal for compile time evaluation of expressions<br>which may be relevant.<br></p><p>Another example, you could add assertMainThread() to a `get` precondition<br>if assertMainThread is marked as side-effect free.<br></p><p><br></p><p><br>On Mon, Dec 14, 2015 at 8:48 AM, Paul Cantrell via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt;&gt; I know there’s talk on the core team of some more robust property<br>&gt; decoration mechanism. Does this already fold into that effort?<br>&gt; &gt;<br>&gt; &gt; Yes, I believe that this should be covered by that work, which is great.<br>&gt; :-)<br>&gt;<br>&gt; Then I’d plop it in as a use case (admittedly one of the less compelling<br>&gt; ones) for that work, and drop this proposal.<br>&gt;<br>&gt; Is any of that work public yet? It sounds exciting. (Apologies if that<br>&gt; question is a repeat; I confess that I have not followed every single<br>&gt; message on this list.)<br>&gt;<br>&gt; Cheers, P<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/e4c0a1df/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0eaab3d5d1d4428f74a711f724f2eb47?s=50"></div><header><strong>Proposal: willGet</strong> from <string>Etan Kissling</string> &lt;kissling at oberon.ch&gt;<p>December 14, 2015 at 08:00:00pm</p></header><div class="content"><p>Yay for Design by Contract. (https://www.eiffel.com/values/design-by-contract/introduction/ &lt;https://www.eiffel.com/values/design-by-contract/introduction/&gt;)<br></p><p>Don&#39;t forget Invariants, though - these have to hold globally, after each client called method has run to completion.<br></p><p>Would be very nice to get these into the language as it could allow for asserting certain correctness aspects statically.<br>Also nice to have the contracts show up in a public interface view as an addition to comments,<br>because these are typically much more precise when writing down a specification.<br></p><p>C#&#39;s CodeContracts are unfortunately not often used, as a binary rewriter needs to be configured as an additional build step.<br>https://msdn.microsoft.com/en-us/library/dd264808%28v=vs.110%29.aspx?f=255&amp;MSPPError=-2147217396 &lt;https://msdn.microsoft.com/en-us/library/dd264808(v=vs.110).aspx?f=255&amp;MSPPError=-2147217396&gt;<br></p><p>An additional problem with Contracts is that it&#39;s not a principle that&#39;s understood by everyone.<br>And to push these through a code base, everyone needs to be willing to apply them properly.<br></p><p><br>Etan<br></p><p><br></p><p><br>&gt; On 13 Dec 2015, at 23:44, Andrew Bennett via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi, this is an alternative to your proposal, taking into account Chris&#39; comments.<br>&gt; <br>&gt; You could add precondition and postcondition on protocol methods and properties, for example:<br>&gt; <br>&gt; protocol Configurable {<br>&gt;     typealias Configuration<br>&gt; <br>&gt;     var configured: Bool {<br>&gt;         @non-mutating get<br>&gt;         set { precondition { configured == false } }<br>&gt;     }<br>&gt; <br>&gt;     // unsure if this syntax is confusing, but it&#39;s consistent with get/set<br>&gt;     func configure(configuration: Configuration) {<br>&gt;         precondition { configured == false }<br>&gt;         postcondition { configured == true }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; The terms precondition, postcondition and @non-mutating are up for debate.<br>&gt; <br>&gt; Importantly: conditions would have to be side-effect free and return a Bool. They would work just like an assertion, and output their condition on failure (ie. &quot;Failed precondition: &#39;configured == false&#39;!&quot;).<br>&gt; <br>&gt; By side-effect free I mean:<br>&gt;  * They would only be able to read properties (instance, or external) annotated as @non-mutating.<br>&gt;  * They can run methods (instance, or external) marked as @non-mutating.<br>&gt;  * Things like print(...) cannot be used, the program should be free to optimise these out.<br>&gt; <br>&gt; This annotation may be used like @noescape. It would have to be verified by the compiler, it may be done automatically (iirc. LLVM has a similar annotation) but that could lower programmer awareness.<br>&gt; <br>&gt; If it&#39;s possible to check the conditions at compile-time it would be great to do so, there&#39;s a proposal for compile time evaluation of expressions which may be relevant.<br>&gt; <br>&gt; Another example, you could add assertMainThread() to a `get` precondition if assertMainThread is marked as side-effect free.<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; On Mon, Dec 14, 2015 at 8:48 AM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt; I know there’s talk on the core team of some more robust property decoration mechanism. Does this already fold into that effort?<br>&gt; &gt;<br>&gt; &gt; Yes, I believe that this should be covered by that work, which is great. :-)<br>&gt; <br>&gt; Then I’d plop it in as a use case (admittedly one of the less compelling ones) for that work, and drop this proposal.<br>&gt; <br>&gt; Is any of that work public yet? It sounds exciting. (Apologies if that question is a repeat; I confess that I have not followed every single message on this list.)<br>&gt; <br>&gt; Cheers, P<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/2db8a265/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 801 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/2db8a265/attachment.sig&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
