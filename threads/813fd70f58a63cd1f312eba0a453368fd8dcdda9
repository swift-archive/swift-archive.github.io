<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>Proposal: Automatic Wrapper Synthesis / &quot;deriving&quot;</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>December  4, 2015 at 03:00:00pm</p></header><div class="content"><p># A `wrapper` / `deriving` Construct<br></p><p>I&#39;m sure a construct along these lines has been requested numerous times and is hopefully already on the roadmap.<br></p><p>The point of this email is to put out a reasonably-*concrete* sketch as a way of soliciting community feedback on the specifics of how such a construct might look-and-work within Swift; hopefully I’ve gone far-enough to be interesting, but not too much further than that.<br></p><p>## Design Sketch<br></p><p>It ought to be possible to write something like this:<br></p><p>    // an example:<br>    struct SectionIndex<br>      wrapping Int<br>      as index<br>      satisfying precondition { $0 &gt;= 0 }<br>      deriving Equatable, Comparable, Hashable {<br>      // declaration can continue in here<br>    }<br>  <br>...which, when compiled, would be &quot;expanded&quot; along these lines:<br></p><p>    struct SectionIndex {<br>    <br>      // would have been `wrappedValue` w/out the `as index` clause<br>      let index: Int<br>    <br>      init(_ index: Int) {<br>        precondition(index &gt;= 0) <br>        // ^ would have been assert(index &gt;= 0) <br>        //   had we used `satisfying { $0 &gt;= 0 }`,<br>        //   and omitted entirely had we omitted a `satisfying` clause<br>        self.index = index<br>      }<br>          <br>    }<br>    <br>    extension SectionIndex : Equatable {<br>    }<br>    <br>    // synthesized unless explicitly written-out<br>    func ==(lhs: SectionIndex, rhs: SectionIndex) -&gt; Bool {<br>      return lhs.index == rhs.index<br>    }<br>    <br>    // same for Comparable, Hashable, all done in the obvious way    <br></p><p>    // there’s a lot of utility in synthesizing something like this,<br>    //  I can expand on it if necessary:<br>    extension SectionIndex: ValueWrapperType {<br>      typealias WrappedType = Int<br>    }<br></p><p>...where each method/init/subscript/etc in the derived protocols gets synthesized at compile-time, if not explicitly implemented; similarly, if not explicitly-declared, the derived protocols&#39; typealiases can be synthesized in obvious ways, and it seems acceptable to simply fail to compile (and inform the user of the need to make an explicit-declaration) in cases where such synthesis is impossible.<br></p><p>I think this enough to sketch the way the feature would look and how it would work. <br></p><p>I’m curious at this point to hear if there’s anything already on the roadmap and/or other community thoughts.<br></p><p>## Postscript<br></p><p>I&#39;m aware that some of this can be done today via protocol extensions, but at least at present that technique has some serious drawbacks; I point it out only b/c it&#39;s possible Swift will wind up with enough improvements to protocol extensions to make a dedicated wrapper-synthesis, language-level feature unnecessary.<br></p><p>Additionally, although the sketch above *could* be implemented today via an external code-generation tool, the looming presence of a &quot;standard&quot; package manager makes it seem better to have this construct baked into the official tooling if possible.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Proposal: Automatic Wrapper Synthesis / &quot;deriving&quot;</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>December  4, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; On Dec 4, 2015, at 1:19 PM, plx &lt;plxswift at icloud.com&gt; wrote:<br>&gt; # A `wrapper` / `deriving` Construct<br>&gt; <br>&gt; I&#39;m sure a construct along these lines has been requested numerous times and is hopefully already on the roadmap.<br>&gt; <br>&gt; The point of this email is to put out a reasonably-*concrete* sketch as a way of soliciting community feedback on the specifics of how such a construct might look-and-work within Swift; hopefully I’ve gone far-enough to be interesting, but not too much further than that.<br>&gt; <br>&gt; ## Design Sketch<br>&gt; <br>&gt; It ought to be possible to write something like this:<br>&gt; <br>&gt;    // an example:<br>&gt;    struct SectionIndex<br>&gt;      wrapping Int<br>&gt;      as index<br>&gt;      satisfying precondition { $0 &gt;= 0 }<br>&gt;      deriving Equatable, Comparable, Hashable {<br>&gt;      // declaration can continue in here<br>&gt;    }<br>&gt; <br>&gt; ...which, when compiled, would be &quot;expanded&quot; along these lines:<br>&gt; <br>&gt;    struct SectionIndex {<br>&gt; <br>&gt;      // would have been `wrappedValue` w/out the `as index` clause<br>&gt;      let index: Int<br>&gt; <br>&gt;      init(_ index: Int) {<br>&gt;        precondition(index &gt;= 0) <br>&gt;        // ^ would have been assert(index &gt;= 0) <br>&gt;        //   had we used `satisfying { $0 &gt;= 0 }`,<br>&gt;        //   and omitted entirely had we omitted a `satisfying` clause<br>&gt;        self.index = index<br>&gt;      }<br>&gt; <br>&gt;    }<br>&gt; <br>&gt;    extension SectionIndex : Equatable {<br>&gt;    }<br>&gt; <br>&gt;    // synthesized unless explicitly written-out<br>&gt;    func ==(lhs: SectionIndex, rhs: SectionIndex) -&gt; Bool {<br>&gt;      return lhs.index == rhs.index<br>&gt;    }<br>&gt; <br>&gt;    // same for Comparable, Hashable, all done in the obvious way    <br>&gt; <br>&gt;    // there’s a lot of utility in synthesizing something like this,<br>&gt;    //  I can expand on it if necessary:<br>&gt;    extension SectionIndex: ValueWrapperType {<br>&gt;      typealias WrappedType = Int<br>&gt;    }<br>&gt; <br>&gt; ...where each method/init/subscript/etc in the derived protocols gets synthesized at compile-time, if not explicitly implemented; similarly, if not explicitly-declared, the derived protocols&#39; typealiases can be synthesized in obvious ways, and it seems acceptable to simply fail to compile (and inform the user of the need to make an explicit-declaration) in cases where such synthesis is impossible.<br>&gt; <br>&gt; I think this enough to sketch the way the feature would look and how it would work. <br></p><p>I’m not sure what work is being done by “wrapping X as Y” here; it seems like just another way of expressing a stored property.<br></p><p>I think we’re all interested in a “deriving” proposal.  However, the key problem that a serious proposal would have to address is not picking the syntax, but describing how derivation would actually work.  We’d prefer not to just hard-code rules in the compiler for specific protocols.<br></p><p>For example, derivation presumably involves recursively invoking the given operation on each of the stored properties (what does “on” mean? which parameters are changed, and which are passed through?) and then merging the results (how?).<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>Proposal: Automatic Wrapper Synthesis / &quot;deriving&quot;</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>December  4, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt; On Dec 4, 2015, at 4:26 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Dec 4, 2015, at 1:19 PM, plx &lt;plxswift at icloud.com&gt; wrote:<br>&gt;&gt; # A `wrapper` / `deriving` Construct<br>&gt;&gt; <br>&gt;&gt; I&#39;m sure a construct along these lines has been requested numerous times and is hopefully already on the roadmap.<br>&gt;&gt; <br>&gt;&gt; The point of this email is to put out a reasonably-*concrete* sketch as a way of soliciting community feedback on the specifics of how such a construct might look-and-work within Swift; hopefully I’ve gone far-enough to be interesting, but not too much further than that.<br>&gt;&gt; <br>&gt;&gt; ## Design Sketch<br>&gt;&gt; <br>&gt;&gt; It ought to be possible to write something like this:<br>&gt;&gt; <br>&gt;&gt;   // an example:<br>&gt;&gt;   struct SectionIndex<br>&gt;&gt;     wrapping Int<br>&gt;&gt;     as index<br>&gt;&gt;     satisfying precondition { $0 &gt;= 0 }<br>&gt;&gt;     deriving Equatable, Comparable, Hashable {<br>&gt;&gt;     // declaration can continue in here<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; ...which, when compiled, would be &quot;expanded&quot; along these lines:<br>&gt;&gt; <br>&gt;&gt;   struct SectionIndex {<br>&gt;&gt; <br>&gt;&gt;     // would have been `wrappedValue` w/out the `as index` clause<br>&gt;&gt;     let index: Int<br>&gt;&gt; <br>&gt;&gt;     init(_ index: Int) {<br>&gt;&gt;       precondition(index &gt;= 0) <br>&gt;&gt;       // ^ would have been assert(index &gt;= 0) <br>&gt;&gt;       //   had we used `satisfying { $0 &gt;= 0 }`,<br>&gt;&gt;       //   and omitted entirely had we omitted a `satisfying` clause<br>&gt;&gt;       self.index = index<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;   extension SectionIndex : Equatable {<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;   // synthesized unless explicitly written-out<br>&gt;&gt;   func ==(lhs: SectionIndex, rhs: SectionIndex) -&gt; Bool {<br>&gt;&gt;     return lhs.index == rhs.index<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;   // same for Comparable, Hashable, all done in the obvious way    <br>&gt;&gt; <br>&gt;&gt;   // there’s a lot of utility in synthesizing something like this,<br>&gt;&gt;   //  I can expand on it if necessary:<br>&gt;&gt;   extension SectionIndex: ValueWrapperType {<br>&gt;&gt;     typealias WrappedType = Int<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; ...where each method/init/subscript/etc in the derived protocols gets synthesized at compile-time, if not explicitly implemented; similarly, if not explicitly-declared, the derived protocols&#39; typealiases can be synthesized in obvious ways, and it seems acceptable to simply fail to compile (and inform the user of the need to make an explicit-declaration) in cases where such synthesis is impossible.<br>&gt;&gt; <br>&gt;&gt; I think this enough to sketch the way the feature would look and how it would work. <br>&gt; <br>&gt; I’m not sure what work is being done by “wrapping X as Y” here; it seems like just another way of expressing a stored property.<br>&gt; <br>&gt; I think we’re all interested in a “deriving” proposal.  However, the key problem that a serious proposal would have to address is not picking the syntax, but describing how derivation would actually work.  We’d prefer not to just hard-code rules in the compiler for specific protocols.<br>&gt; <br>&gt; For example, derivation presumably involves recursively invoking the given operation on each of the stored properties (what does “on” mean? which parameters are changed, and which are passed through?) and then merging the results (how?).<br>&gt; <br>&gt; John.<br></p><p>Apologies for leaving too much out.<br></p><p>I meant to propose that the `deriving` in this place would enforce the wrapper type only wrapped a single stored value, warranting the distinct syntax; I seem to have edited-out both an explicit statement that this assumed a single-stored-property and to have omitted a comment in the `//declaration can continue in here` that no additional stored-properties could be declared (analogous to the rules current applied within extensions).<br></p><p>Yes, constraining a `deriving` construct to only support wrappers containing a single stored property would, on the one hand, be somewhat limiting, but on the other hand it would seemingly allow trivial solutions to the issues you bring up:<br></p><p>- `on` is unambiguous as there’s only one thing it can be “on&quot;<br>- there’s no ordering-of-operations to have to worry about<br>- there’s no merging-of-results to have to worry about<br>- i’m guessing there’s no parameters needing to getting changed (but I’m not 100% on what you mean here)<br>- there’s no associated-type incoherency to worry about (unless user error introduces it)<br></p><p>…there’s least one tricky case (if you want the wrapper to replace one of the wrapped type’s typealiases with a wrapper).<br></p><p>…and at least for me, there’s enough value in that simplified wrapper-synthesis / deriving-type construct to take the time to check community interest. <br></p><p>Thanks for taking the time to read and send feedback.<br></p><p>PS:<br></p><p>On the other hand, if this becomes writable:<br></p><p>    protocol WrapperType {<br>       typealias WrappedValue<br>       var wrappedValue: { get }<br>    }<br></p><p>    extension WrapperType : Equatable where WrappedValue: Equatable {<br>    }<br></p><p>    func ==&lt;W:WrapperType where W.WrappedValue:Equatable&gt;(lhs: W, rhs: W) -&gt; Bool {<br>      return lhs.wrappedValue == rhs.wrappedValue<br>    }<br></p><p>…etc., then it’s possible (albeit moderately unpleasant) to just write suitable glue logic out longhand on an as-needed basis (and with the caveat that all types wrapping T would potentially adopt all of T’s protocols even when potentially undesirable).<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/e604e794/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
