<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/495b09a6e3af4f90f6a531b39de76076?s=50"></div><header><strong>Reconsidering SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>Tian Zhang</string> &lt;khaos.tian at gmail.com&gt;<p>January 26, 2016 at 03:00:00pm</p></header><div class="content"><p>I’m also curious how most people fix “guard var” or “if var”? Especially for checking a class object for protocol conformation and set variable on the object?<br></p><p>like in this case,<br></p><p>&gt; if var vc = vc as? ControlPanelConfigurationProtocol {<br>&gt;         vc.servicePresentationObject = service<br>&gt;         vc.presentAsPanel = true<br>&gt; }<br></p><p><br>become<br></p><p>&gt; if let vc = vc as? ControlPanelConfigurationProtocol {<br>&gt;         var vc = vc<br>&gt; <br>&gt;         vc.servicePresentationObject = service<br>&gt;         vc.presentAsPanel = true<br>&gt; }<br></p><p>I saw a few people suggest to create a method on the protocol like “configureObject(...)” with all potential args and have the object to figure it out but doing so I feel we’re losing the benefits offered by property observation for the underlying object. Using pattern “if let” with a “var” in the block just to make the property mutable again feels really strange.<br></p><p>Best Wishes,<br>Tian<br>&gt; An alternative would certainly be interesting but I would prefer to take it one step at a time and avoid being hasty so we can come up with something really great. What did most of your var fixes look like, by the way? Did you end up changing the layout of your value types or did you decide to add more vars?<br>&gt; <br>&gt; David<br>&gt; <br>&gt; &gt; On Jan 24, 2016, at 7:19 PM, Zach Waldowski via swift-evolution &lt;swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt; &gt; <br>&gt; &gt; -1<br>&gt; &gt; <br>&gt; &gt; Having already adopted the syntax in my projects in anticipation of 2.2,<br>&gt; &gt; the increase in clarity at the expense of terseness is appreciated. A<br>&gt; &gt; proposal should not be discussing an alternative, not a rollback.<br>&gt; &gt; <br>&gt; &gt; Cheers!<br>&gt; &gt; Zachary Waldowski<br>&gt; &gt; zach at waldowski.me &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt; <br>&gt; &gt; On Fri, Jan 22, 2016, at 12:26 PM, David Farler via swift-evolution<br>&gt; &gt; wrote:<br>&gt; &gt;&gt; Hello everyone,<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; I&#39;d like to reconsider SE-0003 for Swift 3 and propose cancelling the<br>&gt; &gt;&gt; change in its entirety. After collecting feedback since Swift&#39;s open<br>&gt; &gt;&gt; source launch, I no longer feel this is a good move and there are a few<br>&gt; &gt;&gt; reasons why.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; There are two main patterns that the removal penalizes:<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; - Get-Modify-Reassign<br>&gt; &gt;&gt; - Get-Modify-Return<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; I&#39;ve found that many of the problems with this proposal stem from the<br>&gt; &gt;&gt; uses before and after the &quot;Modify&quot; part, before returning or reassigning<br>&gt; &gt;&gt; with the new value.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; I&#39;ve seen a few common responses to the var removal. Consider a<br>&gt; &gt;&gt; `Rectangle` struct:<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; <br>&gt; &gt;&gt; struct Rectangle {<br>&gt; &gt;&gt; var origin: (x: Double, y: Double)<br>&gt; &gt;&gt; var size: (width: Double, height: Double)<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; <br>&gt; &gt;&gt; Even with mutable variables `origin` and `size`, this pattern would be<br>&gt; &gt;&gt; impossible:<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; <br>&gt; &gt;&gt; var selection = getRectangularSelection()<br>&gt; &gt;&gt; if var rect = selection?.rect {<br>&gt; &gt;&gt; // Mutate `rect` ...<br>&gt; &gt;&gt; selection.rect = rect<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; <br>&gt; &gt;&gt; So, one might shadow the variable, which is not ideal:<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; <br>&gt; &gt;&gt; var selection = getRectangularSelection()<br>&gt; &gt;&gt; if let rect = selection?.rect {<br>&gt; &gt;&gt; var rect = rect // Not so great<br>&gt; &gt;&gt; // Mutate `rect` ...<br>&gt; &gt;&gt; selection.rect = rect<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; <br>&gt; &gt;&gt; Or, you might make a transformation function on `Rect`:<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; <br>&gt; &gt;&gt; struct Rectangle {<br>&gt; &gt;&gt; var origin: (x: Double, y: Double)<br>&gt; &gt;&gt; var size: (width: Double, height: Double)<br>&gt; &gt;&gt; func withOrigin(x: Double, y: Double) -&gt; Rect {<br>&gt; &gt;&gt;   var r = self<br>&gt; &gt;&gt;   r.origin = (x, y)<br>&gt; &gt;&gt;   return r<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; <br>&gt; &gt;&gt; This is a much better solution than shadowing but you would need one of<br>&gt; &gt;&gt; these for any property that you want to mutate and I think you&#39;ll agree<br>&gt; &gt;&gt; that it doesn&#39;t scale with the language we have today. This response begs<br>&gt; &gt;&gt; for a kind of initializer that takes all of the fields of the original<br>&gt; &gt;&gt; struct except any that you want to override:<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; <br>&gt; &gt;&gt; if let rect = selection?.rect.with(origin: newOrigin) {<br>&gt; &gt;&gt; // ...<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; <br>&gt; &gt;&gt; Straw syntax, but maybe you&#39;ll see something along these lines on<br>&gt; &gt;&gt; swift-evolution in the future, which would provide a clear alternative to<br>&gt; &gt;&gt; direct mutation patterns. Even then, I think having complementary<br>&gt; &gt;&gt; patterns in the language isn&#39;t a bad thing.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; These problems come up with the other variable bindings but the one that<br>&gt; &gt;&gt; ended up bothering me the most was `guard var`:<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; <br>&gt; &gt;&gt; func transform(selection: Rect?) {<br>&gt; &gt;&gt; guard let rect = selection else { return }<br>&gt; &gt;&gt; var _rect = rect<br>&gt; &gt;&gt; // Mutate `_rect` ...<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; <br>&gt; &gt;&gt; One of the guard statement&#39;s main purposes is to conditionally bind a<br>&gt; &gt;&gt; value as a peer in its own scope, not an inner scope like if statements.<br>&gt; &gt;&gt; Not having var makes the guard statement much weaker.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; There is certainly a bit of confusion about the nuances between value and<br>&gt; &gt;&gt; reference semantics, who owns a value and when, how effects are<br>&gt; &gt;&gt; propagated back to values, but I think we can attack the problem with<br>&gt; &gt;&gt; more finesse.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; Value types are one of the attractive features of Swift – because of<br>&gt; &gt;&gt; their semantics, mutating algorithms are written in a familiar style but<br>&gt; &gt;&gt; keeping effects limited to your unique reference. I don&#39;t think we should<br>&gt; &gt;&gt; give that up now to address confusion about semantics, out of principle,<br>&gt; &gt;&gt; or in anticipation of new language features. I propose cancelling this<br>&gt; &gt;&gt; change for Swift 3 and continue to allow `var` in the grammar everywhere<br>&gt; &gt;&gt; it occurs in Swift 2.2.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; Regards,<br>&gt; &gt;&gt; David<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160126/9b4f5ed0/attachment.html&gt;<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
