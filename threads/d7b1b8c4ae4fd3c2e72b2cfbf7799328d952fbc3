<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>Streamlining closures</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>December 13, 2015 at 06:00:00am</p></header><div class="content"><p>Dear all, <br></p><p>first of all, thank you for giving the community the opportunity to influence the future of Swift. This is a strong move, which shows how passionate the Swift team is about their language and how you guys want to make it the best. <br></p><p>Personally, I am a huge fan of streamlined, logically concise concepts as well as syntax in programming languages. This is an area where Swift both excels at (love what you do with types in the compiler) but also sometimes lacking, as there seems to be a lot of idiosyncrasy, as evident from the huge number of language keywords and compiler attributes.  Here, I would like to discuss some of the idiosyncrasy with closures. As I am trying to throw some random ideas out there, my post might be a bit chaotic, so please bear with me.  Besides, I literally started playing around with Swift only few hours ago (I know, I know, I’m late), so my practical knowledge of the language is very limited. <br></p><p>1. I always wondered about the specific closure syntax { A -&gt; B in … }. The type annotation is within the block for some reason and the there is the keyword ‘in’, which is usually associated with the for loop. My proposal would be to change this to simply:<br></p><p>   A -&gt; B { … }<br></p><p>That is, the closure declaration closely mirrors the function declaration, but without the &#39;func name’ part. This is far from being just a cosmetic change though. Rather, it has some far-reaching consequences to how the concept of closure is applied to the language, but I believe that this would make Swift much more streamlined and concise (and also solve some other issues in the process). <br></p><p>The crucial point is that the type annotation is (and should be) optional. Which means that every code block { … } is a closure. I think this fundamentally makes a lot of sense. So, a function declaration is just a closure associated with a name identifier (aka. injected into the namespace). Similarly, code blocks used in statements such as for and do have local lexical scope, which makes them essentially compatible closures as far as I can see. <br></p><p>Essentially, this approach radically simplifies the language both from the syntax standpoint — closures and funcs are using the same syntax, the notion of code blocks is removed from the language; but also from the semantics standpoint. For instance, one can give more formal definitions for statements, which opens the path of treating statements as expressions (see https://lists.swift.org/pipermail/swift-evolution/2015-December/000133.html &lt;https://lists.swift.org/pipermail/swift-evolution/2015-December/000133.html&gt;). For instance, current if is of type (Bool, ()-&gt;())-&gt;(), but it can easily be redeclared as (Bool, ()-&gt;T)-&gt;T, which opens way to nice things like <br></p><p>  let x = if(…) { .. some complex setup code..; value1} else { … other code..; value2}<br></p><p>Similarly, do can be used to incapsulate auxiliary computations in the local scope (see below).<br></p><p>2. Another closure limitation is that return type inference does not work with longer closures (but they should). Here a particular use case.  Due to my work, I program a lot with R (which is sometimes a neat language in its own right). A particular paradigm I find very useful is to use anonymous code blocks in local scope to prevent namespace pollution, e.g. (in R code)<br></p><p> dataset &lt;- local({<br>   a &lt;- some_computation<br>   b &lt;- some_computation<br></p><p>   a combined with b<br>})<br></p><p>// a and b are not visible in the outer scope anymore<br></p><p>In JavaScript, people often use anonymous functions for the same effect. The nice thing about this paradigm is that it allows one to properly isolate data dependency from each other, give the compiler a better sense of variable lifespan and overall make your code much nicer to read. Of course, in Swift  this can be done with nested functions or closures, but its the question of aesthetics. At any rate, the R function is very easy to emulate in Swift:<br></p><p> func local&lt;T&gt;(closure: () -&gt; T) -&gt; T {<br>     return closure()<br> }<br></p><p>which works beautifully, e.g.<br></p><p> let (a1,a2) = local({return(1, 2)}<br></p><p>However, if I want to use more complex code, I need to explicitly declare the closure type:<br></p><p>   let (a1, a2) = local({ () -&gt; (Int, Int) in<br>     let x2 = x*2<br></p><p>     return (x2, x2+1)<br>   })<br></p><p><br>This is bulky, and frankly, unnecessary, as the compiler can easily infer the return type of the closure. <br></p><p>BTW, combined with proposal in 1., this style of programming just becomes the beautiful<br></p><p>let (a1, a2) = do {<br>  .. do something ..<br> return(…, …) // or simply (…, …)<br>}<br></p><p><br>Summary TL;DR version of the proposal: <br></p><p>replace the {A-&gt;B in …} closure syntax by A-&gt;B {…} — where type declaration is optional, remove the concept of code block (replace it by closure) and statements that take blocks/closures typed expressions. Improve type inference for return values. Current syntactic sugar for closures such as anonymous arguments and last line as return values should be preserved. <br></p><p>Advantages: streamlines the language, solves a number of issues at the same time (idiosyncrasy, operators as expressions). In the end, makes the language easier to use and also to understand conceptually. <br></p><p>Disadvantages: I honestly can’t see a single one<br></p><p>Implementation challenge: would requires a parser change that might be non-trivial. I can also imagine that a lot of refactoring in the compiler code is necessary in regards to how statements work — but this might pay off as in the end, the compiler only needs to deal with closures and calls, which simplifies optimisation. And Swift is already great at aggressive inlining of closures. <br></p><p>Impact on existing code: the syntax of closure declarations can be automatically ported as the rewrite rule is trivial. As far as I can see, changing code blocks to closures won’t have any impact on the semantics of the control structures, because the blocks are already using lexical scope. <br></p><p>Eager to hear your thoughts on this!<br></p><p>Cheers, <br></p><p>Taras<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151213/d7b1fbc3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Streamlining closures</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>December 13, 2015 at 09:00:00am</p></header><div class="content"><p>Hi Taras,<br></p><p>I don&#39;t think the syntax { x in ... } is a hindrance for your proposal of turning all code blocks into closures, as all code blocks currently have no arguments and in that case both variants look the same. All code blocks with the exception of function bodies but I think having these looking different is ok.<br></p><p>An advantage of the current syntax is that you can leave off the parentheses when calling a closure if it is the last argument which already enables the syntax you would like for &quot;local&quot;:<br></p><p>let x = local {<br>        ...<br>}<br></p><p>This requires having the arguments inside the braces to allow for things like these:<br></p><p>someCollection.forEach { x in ... }<br>File.open(&quot;some/path&quot;) { file in ... } // having the file closed automatically<br></p><p>Such usage patterns would look awkward with arguments outside of the braces and they are very common and very useful.<br></p><p>Actually I was very surprised to see that your example with &quot;local&quot; returning a tuple did not work. The type inferencer should be able to infer the result type T to be a tuple without problems.<br></p><p>-Thorsten <br></p><p>&gt; Am 13.12.2015 um 05:14 schrieb Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Dear all, <br>&gt; <br>&gt; first of all, thank you for giving the community the opportunity to influence the future of Swift. This is a strong move, which shows how passionate the Swift team is about their language and how you guys want to make it the best. <br>&gt; <br>&gt; Personally, I am a huge fan of streamlined, logically concise concepts as well as syntax in programming languages. This is an area where Swift both excels at (love what you do with types in the compiler) but also sometimes lacking, as there seems to be a lot of idiosyncrasy, as evident from the huge number of language keywords and compiler attributes.  Here, I would like to discuss some of the idiosyncrasy with closures. As I am trying to throw some random ideas out there, my post might be a bit chaotic, so please bear with me.  Besides, I literally started playing around with Swift only few hours ago (I know, I know, I’m late), so my practical knowledge of the language is very limited. <br>&gt; <br>&gt; 1. I always wondered about the specific closure syntax { A -&gt; B in … }. The type annotation is within the block for some reason and the there is the keyword ‘in’, which is usually associated with the for loop. My proposal would be to change this to simply:<br>&gt; <br>&gt;    A -&gt; B { … }<br>&gt; <br>&gt; That is, the closure declaration closely mirrors the function declaration, but without the &#39;func name’ part. This is far from being just a cosmetic change though. Rather, it has some far-reaching consequences to how the concept of closure is applied to the language, but I believe that this would make Swift much more streamlined and concise (and also solve some other issues in the process). <br>&gt; <br>&gt; The crucial point is that the type annotation is (and should be) optional. Which means that every code block { … } is a closure. I think this fundamentally makes a lot of sense. So, a function declaration is just a closure associated with a name identifier (aka. injected into the namespace). Similarly, code blocks used in statements such as for and do have local lexical scope, which makes them essentially compatible closures as far as I can see. <br>&gt; <br>&gt; Essentially, this approach radically simplifies the language both from the syntax standpoint — closures and funcs are using the same syntax, the notion of code blocks is removed from the language; but also from the semantics standpoint. For instance, one can give more formal definitions for statements, which opens the path of treating statements as expressions (see https://lists.swift.org/pipermail/swift-evolution/2015-December/000133.html). For instance, current if is of type (Bool, ()-&gt;())-&gt;(), but it can easily be redeclared as (Bool, ()-&gt;T)-&gt;T, which opens way to nice things like <br>&gt; <br>&gt;   let x = if(…) { .. some complex setup code..; value1} else { … other code..; value2}<br>&gt; <br>&gt; Similarly, do can be used to incapsulate auxiliary computations in the local scope (see below).<br>&gt; <br>&gt; 2. Another closure limitation is that return type inference does not work with longer closures (but they should). Here a particular use case.  Due to my work, I program a lot with R (which is sometimes a neat language in its own right). A particular paradigm I find very useful is to use anonymous code blocks in local scope to prevent namespace pollution, e.g. (in R code)<br>&gt; <br>&gt;  dataset &lt;- local({<br>&gt;    a &lt;- some_computation<br>&gt;    b &lt;- some_computation<br>&gt; <br>&gt;    a combined with b<br>&gt; })<br>&gt; <br>&gt; // a and b are not visible in the outer scope anymore<br>&gt; <br>&gt; In JavaScript, people often use anonymous functions for the same effect. The nice thing about this paradigm is that it allows one to properly isolate data dependency from each other, give the compiler a better sense of variable lifespan and overall make your code much nicer to read. Of course, in Swift  this can be done with nested functions or closures, but its the question of aesthetics. At any rate, the R function is very easy to emulate in Swift:<br>&gt; <br>&gt;  func local&lt;T&gt;(closure: () -&gt; T) -&gt; T {<br>&gt;      return closure()<br>&gt;  }<br>&gt; <br>&gt; which works beautifully, e.g.<br>&gt; <br>&gt;  let (a1,a2) = local({return(1, 2)}<br>&gt; <br>&gt; However, if I want to use more complex code, I need to explicitly declare the closure type:<br>&gt; <br>&gt;    let (a1, a2) = local({ () -&gt; (Int, Int) in<br>&gt;      let x2 = x*2<br>&gt; <br>&gt;      return (x2, x2+1)<br>&gt;    })<br>&gt; <br>&gt; <br>&gt; This is bulky, and frankly, unnecessary, as the compiler can easily infer the return type of the closure. <br>&gt; <br>&gt; BTW, combined with proposal in 1., this style of programming just becomes the beautiful<br>&gt; <br>&gt; let (a1, a2) = do {<br>&gt;   .. do something ..<br>&gt;  return(…, …) // or simply (…, …)<br>&gt; }<br>&gt; <br>&gt; <br>&gt; Summary TL;DR version of the proposal: <br>&gt; <br>&gt; replace the {A-&gt;B in …} closure syntax by A-&gt;B {…} — where type declaration is optional, remove the concept of code block (replace it by closure) and statements that take blocks/closures typed expressions. Improve type inference for return values. Current syntactic sugar for closures such as anonymous arguments and last line as return values should be preserved. <br>&gt; <br>&gt; Advantages: streamlines the language, solves a number of issues at the same time (idiosyncrasy, operators as expressions). In the end, makes the language easier to use and also to understand conceptually. <br>&gt; <br>&gt; Disadvantages: I honestly can’t see a single one<br>&gt; <br>&gt; Implementation challenge: would requires a parser change that might be non-trivial. I can also imagine that a lot of refactoring in the compiler code is necessary in regards to how statements work — but this might pay off as in the end, the compiler only needs to deal with closures and calls, which simplifies optimisation. And Swift is already great at aggressive inlining of closures. <br>&gt; <br>&gt; Impact on existing code: the syntax of closure declarations can be automatically ported as the rewrite rule is trivial. As far as I can see, changing code blocks to closures won’t have any impact on the semantics of the control structures, because the blocks are already using lexical scope. <br>&gt; <br>&gt; Eager to hear your thoughts on this!<br>&gt; <br>&gt; Cheers, <br>&gt; <br>&gt; Taras <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151213/5dae563c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>Streamlining closures</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>December 13, 2015 at 03:00:00pm</p></header><div class="content"><p>How would you write this with the new syntax?<br></p><p>someAsyncFunction() { error in<br>    // …<br>}<br></p><p>This doesn&#39;t make sense (like Thorsten explained earlier):<br></p><p>someAsyncFunction() error {<br>    // …<br>}<br></p><p>I agree though that &quot;in&quot; is confusing and I never understood what &quot;in&quot;<br>means here.<br>Since &quot;do&quot; is no longer used for loops but code blocks it would make sense<br>to replace &quot;in&quot; with &quot;do&quot;.<br></p><p>someAsyncFunction() { error do<br>    // …<br>}<br></p><p><br>On Sun, Dec 13, 2015 at 9:42 AM, Thorsten Seitz via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hi Taras,<br>&gt;<br>&gt; I don&#39;t think the syntax { x in ... } is a hindrance for your proposal of<br>&gt; turning all code blocks into closures, as all code blocks currently have no<br>&gt; arguments and in that case both variants look the same. All code blocks<br>&gt; with the exception of function bodies but I think having these looking<br>&gt; different is ok.<br>&gt;<br>&gt; An advantage of the current syntax is that you can leave off the<br>&gt; parentheses when calling a closure if it is the last argument which already<br>&gt; enables the syntax you would like for &quot;local&quot;:<br>&gt;<br>&gt; let x = local {<br>&gt;         ...<br>&gt; }<br>&gt;<br>&gt; This requires having the arguments inside the braces to allow for things<br>&gt; like these:<br>&gt;<br>&gt; someCollection.forEach { x in ... }<br>&gt; File.open(&quot;some/path&quot;) { file in ... } // having the file closed<br>&gt; automatically<br>&gt;<br>&gt; Such usage patterns would look awkward with arguments outside of the<br>&gt; braces and they are very common and very useful.<br>&gt;<br>&gt; Actually I was very surprised to see that your example with &quot;local&quot;<br>&gt; returning a tuple did not work. The type inferencer should be able to infer<br>&gt; the result type T to be a tuple without problems.<br>&gt;<br>&gt; -Thorsten<br>&gt;<br>&gt; Am 13.12.2015 um 05:14 schrieb Taras Zakharko via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt;<br>&gt; Dear all,<br>&gt;<br>&gt; first of all, thank you for giving the community the opportunity to<br>&gt; influence the future of Swift. This is a strong move, which shows how<br>&gt; passionate the Swift team is about their language and how you guys want to<br>&gt; make it the best.<br>&gt;<br>&gt; Personally, I am a huge fan of streamlined, logically concise concepts as<br>&gt; well as syntax in programming languages. This is an area where Swift both<br>&gt; excels at (love what you do with types in the compiler) but also sometimes<br>&gt; lacking, as there seems to be a lot of idiosyncrasy, as evident from the<br>&gt; huge number of language keywords and compiler attributes.  Here, I would<br>&gt; like to discuss some of the idiosyncrasy with closures. As I am trying to<br>&gt; throw some random ideas out there, my post might be a bit chaotic, so<br>&gt; please bear with me.  Besides, I literally started playing around with<br>&gt; Swift only few hours ago (I know, I know, I’m late), so my practical<br>&gt; knowledge of the language is very limited.<br>&gt;<br>&gt; 1. I always wondered about the specific closure syntax { A -&gt; B in … }.<br>&gt; The type annotation is within the block for some reason and the there is<br>&gt; the keyword ‘in’, which is usually associated with the for loop. My<br>&gt; proposal would be to change this to simply:<br>&gt;<br>&gt;    A -&gt; B { … }<br>&gt;<br>&gt; That is, the closure declaration closely mirrors the function declaration,<br>&gt; but without the &#39;func name’ part. This is far from being just a cosmetic<br>&gt; change though. Rather, it has some far-reaching consequences to how the<br>&gt; concept of closure is applied to the language, but I believe that this<br>&gt; would make Swift much more streamlined and concise (and also solve some<br>&gt; other issues in the process).<br>&gt;<br>&gt; The crucial point is that the type annotation is (and should be) optional.<br>&gt; Which means that every code block { … } is a closure. I think this<br>&gt; fundamentally makes a lot of sense. So, a function declaration is just a<br>&gt; closure associated with a name identifier (aka. injected into the<br>&gt; namespace). Similarly, code blocks used in statements such as for and do<br>&gt; have local lexical scope, which makes them essentially compatible closures<br>&gt; as far as I can see.<br>&gt;<br>&gt; Essentially, this approach radically simplifies the language both from the<br>&gt; syntax standpoint — closures and funcs are using the same syntax, the<br>&gt; notion of code blocks is removed from the language; but also from the<br>&gt; semantics standpoint. For instance, one can give more formal definitions<br>&gt; for statements, which opens the path of treating statements as expressions<br>&gt; (see<br>&gt; https://lists.swift.org/pipermail/swift-evolution/2015-December/000133.html).<br>&gt; For instance, current if is of type (Bool, ()-&gt;())-&gt;(), but it can easily<br>&gt; be redeclared as (Bool, ()-&gt;T)-&gt;T, which opens way to nice things like<br>&gt;<br>&gt;   let x = if(…) { .. some complex setup code..; value1} else { … other<br>&gt; code..; value2}<br>&gt;<br>&gt; Similarly, do can be used to incapsulate auxiliary computations in the<br>&gt; local scope (see below).<br>&gt;<br>&gt; 2. Another closure limitation is that return type inference does not work<br>&gt; with longer closures (but they should). Here a particular use case.  Due to<br>&gt; my work, I program a lot with R (which is sometimes a neat language in its<br>&gt; own right). A particular paradigm I find very useful is to use anonymous<br>&gt; code blocks in local scope to prevent namespace pollution, e.g. (in R code)<br>&gt;<br>&gt;  dataset &lt;- local({<br>&gt;    a &lt;- some_computation<br>&gt;    b &lt;- some_computation<br>&gt;<br>&gt;    a combined with b<br>&gt; })<br>&gt;<br>&gt; // a and b are not visible in the outer scope anymore<br>&gt;<br>&gt; In JavaScript, people often use anonymous functions for the same effect.<br>&gt; The nice thing about this paradigm is that it allows one to properly<br>&gt; isolate data dependency from each other, give the compiler a better sense<br>&gt; of variable lifespan and overall make your code much nicer to read. Of<br>&gt; course, in Swift  this can be done with nested functions or closures, but<br>&gt; its the question of aesthetics. At any rate, the R function is very easy to<br>&gt; emulate in Swift:<br>&gt;<br>&gt;  func local&lt;T&gt;(closure: () -&gt; T) -&gt; T {<br>&gt;      return closure()<br>&gt;  }<br>&gt;<br>&gt; which works beautifully, e.g.<br>&gt;<br>&gt;  let (a1,a2) = local({return(1, 2)}<br>&gt;<br>&gt; However, if I want to use more complex code, I need to explicitly declare<br>&gt; the closure type:<br>&gt;<br>&gt;    let (a1, a2) = local({ () -&gt; (Int, Int) in<br>&gt;      let x2 = x*2<br>&gt;<br>&gt;      return (x2, x2+1)<br>&gt;    })<br>&gt;<br>&gt;<br>&gt; This is bulky, and frankly, unnecessary, as the compiler can easily infer<br>&gt; the return type of the closure.<br>&gt;<br>&gt; BTW, combined with proposal in 1., this style of programming just becomes<br>&gt; the beautiful<br>&gt;<br>&gt; let (a1, a2) = do {<br>&gt;   .. do something ..<br>&gt;  return(…, …) // or simply (…, …)<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Summary TL;DR version of the proposal:<br>&gt;<br>&gt; replace the {A-&gt;B in …} closure syntax by A-&gt;B {…} — where type<br>&gt; declaration is optional, remove the concept of code block (replace it by<br>&gt; closure) and statements that take blocks/closures typed expressions.<br>&gt; Improve type inference for return values. Current syntactic sugar for<br>&gt; closures such as anonymous arguments and last line as return values should<br>&gt; be preserved.<br>&gt;<br>&gt; Advantages: streamlines the language, solves a number of issues at the<br>&gt; same time (idiosyncrasy, operators as expressions). In the end, makes the<br>&gt; language easier to use and also to understand conceptually.<br>&gt;<br>&gt; Disadvantages: I honestly can’t see a single one<br>&gt;<br>&gt; Implementation challenge: would requires a parser change that might be<br>&gt; non-trivial. I can also imagine that a lot of refactoring in the compiler<br>&gt; code is necessary in regards to how statements work — but this might pay<br>&gt; off as in the end, the compiler only needs to deal with closures and calls,<br>&gt; which simplifies optimisation. And Swift is already great at aggressive<br>&gt; inlining of closures.<br>&gt;<br>&gt; Impact on existing code: the syntax of closure declarations can be<br>&gt; automatically ported as the rewrite rule is trivial. As far as I can see,<br>&gt; changing code blocks to closures won’t have any impact on the semantics of<br>&gt; the control structures, because the blocks are already using lexical scope.<br>&gt;<br>&gt; Eager to hear your thoughts on this!<br>&gt;<br>&gt; Cheers,<br>&gt;<br>&gt; Taras<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151213/c0d97fb6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>Streamlining closures</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>December 13, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; On 13 Dec 2015, at 15:26, Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br>&gt; <br>&gt; How would you write this with the new syntax?<br></p><p><br>&gt; On 13 Dec 2015, at 09:42, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt; <br>&gt; I don&#39;t think the syntax { x in ... } is a hindrance for your proposal of turning all code blocks into closures, as all code blocks currently have no arguments and in that case both variants look the same. All code blocks with the exception of function bodies but I think having these looking different is ok.<br></p><p><br>Point well taken :)<br></p><p>Other suggestions (out of top of my head) would be<br></p><p>// lambda-calculus inspired, but potentially confusing<br>someAsyncFunction()  { error .<br>    // …<br>}<br></p><p>// like above, kind of constructor notation, my personal favourite so far<br>someAsyncFunction()  { error |<br>    // …<br>}<br></p><p>// lest idiosyncratic but also verbose and ugly<br>someAsyncFunction()  func(error) { <br>    // …<br>}<br></p><p>But you are right of course that the syntax I proposed in the original mail does not work with these examples. Again, its more of a cosmetic thing anyway. I think the other point (streamlining the concept of closures in the language) is more important. <br></p><p>&gt; On 13 Dec 2015, at 09:42, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br></p><p>&gt; Actually I was very surprised to see that your example with &quot;local&quot; returning a tuple did not work. The type inferencer should be able to infer the result type T to be a tuple without problems.<br></p><p>Yep, I was also quite surprised. But it does not work for me as of Xcode 7C68<br></p><p>Cheers, <br></p><p> Taras<br></p><p>P.S. Thorsten, sorry for wrong reply, I am not using mailing lists often and the behaviour of the mail client is a bit confusing. <br></p><p><br>&gt; On 13 Dec 2015, at 15:26, Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br>&gt; <br>&gt; How would you write this with the new syntax?<br>&gt; <br>&gt; someAsyncFunction() { error in<br>&gt;     // …<br>&gt; }<br>&gt; <br>&gt; This doesn&#39;t make sense (like Thorsten explained earlier):<br>&gt; <br>&gt; someAsyncFunction() error {<br>&gt;     // …<br>&gt; }<br>&gt; <br>&gt; I agree though that &quot;in&quot; is confusing and I never understood what &quot;in&quot; means here.<br>&gt; Since &quot;do&quot; is no longer used for loops but code blocks it would make sense to replace &quot;in&quot; with &quot;do&quot;. <br>&gt; <br>&gt; someAsyncFunction() { error do<br>&gt;     // …<br>&gt; }<br>&gt; <br>&gt; <br>&gt; On Sun, Dec 13, 2015 at 9:42 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Hi Taras,<br>&gt; <br>&gt; I don&#39;t think the syntax { x in ... } is a hindrance for your proposal of turning all code blocks into closures, as all code blocks currently have no arguments and in that case both variants look the same. All code blocks with the exception of function bodies but I think having these looking different is ok.<br>&gt; <br>&gt; An advantage of the current syntax is that you can leave off the parentheses when calling a closure if it is the last argument which already enables the syntax you would like for &quot;local&quot;:<br>&gt; <br>&gt; let x = local {<br>&gt;         ...<br>&gt; }<br>&gt; <br>&gt; This requires having the arguments inside the braces to allow for things like these:<br>&gt; <br>&gt; someCollection.forEach { x in ... }<br>&gt; File.open(&quot;some/path&quot;) { file in ... } // having the file closed automatically<br>&gt; <br>&gt; Such usage patterns would look awkward with arguments outside of the braces and they are very common and very useful.<br>&gt; <br>&gt; Actually I was very surprised to see that your example with &quot;local&quot; returning a tuple did not work. The type inferencer should be able to infer the result type T to be a tuple without problems.<br>&gt; <br>&gt; -Thorsten <br>&gt; <br>&gt; Am 13.12.2015 um 05:14 schrieb Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; <br>&gt;&gt; Dear all, <br>&gt;&gt; <br>&gt;&gt; first of all, thank you for giving the community the opportunity to influence the future of Swift. This is a strong move, which shows how passionate the Swift team is about their language and how you guys want to make it the best. <br>&gt;&gt; <br>&gt;&gt; Personally, I am a huge fan of streamlined, logically concise concepts as well as syntax in programming languages. This is an area where Swift both excels at (love what you do with types in the compiler) but also sometimes lacking, as there seems to be a lot of idiosyncrasy, as evident from the huge number of language keywords and compiler attributes.  Here, I would like to discuss some of the idiosyncrasy with closures. As I am trying to throw some random ideas out there, my post might be a bit chaotic, so please bear with me.  Besides, I literally started playing around with Swift only few hours ago (I know, I know, I’m late), so my practical knowledge of the language is very limited. <br>&gt;&gt; <br>&gt;&gt; 1. I always wondered about the specific closure syntax { A -&gt; B in … }. The type annotation is within the block for some reason and the there is the keyword ‘in’, which is usually associated with the for loop. My proposal would be to change this to simply:<br>&gt;&gt; <br>&gt;&gt;    A -&gt; B { … }<br>&gt;&gt; <br>&gt;&gt; That is, the closure declaration closely mirrors the function declaration, but without the &#39;func name’ part. This is far from being just a cosmetic change though. Rather, it has some far-reaching consequences to how the concept of closure is applied to the language, but I believe that this would make Swift much more streamlined and concise (and also solve some other issues in the process). <br>&gt;&gt; <br>&gt;&gt; The crucial point is that the type annotation is (and should be) optional. Which means that every code block { … } is a closure. I think this fundamentally makes a lot of sense. So, a function declaration is just a closure associated with a name identifier (aka. injected into the namespace). Similarly, code blocks used in statements such as for and do have local lexical scope, which makes them essentially compatible closures as far as I can see. <br>&gt;&gt; <br>&gt;&gt; Essentially, this approach radically simplifies the language both from the syntax standpoint — closures and funcs are using the same syntax, the notion of code blocks is removed from the language; but also from the semantics standpoint. For instance, one can give more formal definitions for statements, which opens the path of treating statements as expressions (see https://lists.swift.org/pipermail/swift-evolution/2015-December/000133.html &lt;https://lists.swift.org/pipermail/swift-evolution/2015-December/000133.html&gt;). For instance, current if is of type (Bool, ()-&gt;())-&gt;(), but it can easily be redeclared as (Bool, ()-&gt;T)-&gt;T, which opens way to nice things like <br>&gt;&gt; <br>&gt;&gt;   let x = if(…) { .. some complex setup code..; value1} else { … other code..; value2}<br>&gt;&gt; <br>&gt;&gt; Similarly, do can be used to incapsulate auxiliary computations in the local scope (see below).<br>&gt;&gt; <br>&gt;&gt; 2. Another closure limitation is that return type inference does not work with longer closures (but they should). Here a particular use case.  Due to my work, I program a lot with R (which is sometimes a neat language in its own right). A particular paradigm I find very useful is to use anonymous code blocks in local scope to prevent namespace pollution, e.g. (in R code)<br>&gt;&gt; <br>&gt;&gt;  dataset &lt;- local({<br>&gt;&gt;    a &lt;- some_computation<br>&gt;&gt;    b &lt;- some_computation<br>&gt;&gt; <br>&gt;&gt;    a combined with b<br>&gt;&gt; })<br>&gt;&gt; <br>&gt;&gt; // a and b are not visible in the outer scope anymore<br>&gt;&gt; <br>&gt;&gt; In JavaScript, people often use anonymous functions for the same effect. The nice thing about this paradigm is that it allows one to properly isolate data dependency from each other, give the compiler a better sense of variable lifespan and overall make your code much nicer to read. Of course, in Swift  this can be done with nested functions or closures, but its the question of aesthetics. At any rate, the R function is very easy to emulate in Swift:<br>&gt;&gt; <br>&gt;&gt;  func local&lt;T&gt;(closure: () -&gt; T) -&gt; T {<br>&gt;&gt;      return closure()<br>&gt;&gt;  }<br>&gt;&gt; <br>&gt;&gt; which works beautifully, e.g.<br>&gt;&gt; <br>&gt;&gt;  let (a1,a2) = local({return(1, 2)}<br>&gt;&gt; <br>&gt;&gt; However, if I want to use more complex code, I need to explicitly declare the closure type:<br>&gt;&gt; <br>&gt;&gt;    let (a1, a2) = local({ () -&gt; (Int, Int) in<br>&gt;&gt;      let x2 = x*2<br>&gt;&gt; <br>&gt;&gt;      return (x2, x2+1)<br>&gt;&gt;    })<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; This is bulky, and frankly, unnecessary, as the compiler can easily infer the return type of the closure. <br>&gt;&gt; <br>&gt;&gt; BTW, combined with proposal in 1., this style of programming just becomes the beautiful<br>&gt;&gt; <br>&gt;&gt; let (a1, a2) = do {<br>&gt;&gt;   .. do something ..<br>&gt;&gt;  return(…, …) // or simply (…, …)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Summary TL;DR version of the proposal: <br>&gt;&gt; <br>&gt;&gt; replace the {A-&gt;B in …} closure syntax by A-&gt;B {…} — where type declaration is optional, remove the concept of code block (replace it by closure) and statements that take blocks/closures typed expressions. Improve type inference for return values. Current syntactic sugar for closures such as anonymous arguments and last line as return values should be preserved. <br>&gt;&gt; <br>&gt;&gt; Advantages: streamlines the language, solves a number of issues at the same time (idiosyncrasy, operators as expressions). In the end, makes the language easier to use and also to understand conceptually. <br>&gt;&gt; <br>&gt;&gt; Disadvantages: I honestly can’t see a single one<br>&gt;&gt; <br>&gt;&gt; Implementation challenge: would requires a parser change that might be non-trivial. I can also imagine that a lot of refactoring in the compiler code is necessary in regards to how statements work — but this might pay off as in the end, the compiler only needs to deal with closures and calls, which simplifies optimisation. And Swift is already great at aggressive inlining of closures. <br>&gt;&gt; <br>&gt;&gt; Impact on existing code: the syntax of closure declarations can be automatically ported as the rewrite rule is trivial. As far as I can see, changing code blocks to closures won’t have any impact on the semantics of the control structures, because the blocks are already using lexical scope. <br>&gt;&gt; <br>&gt;&gt; Eager to hear your thoughts on this!<br>&gt;&gt; <br>&gt;&gt; Cheers, <br>&gt;&gt; <br>&gt;&gt; Taras _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>&gt; On 13 Dec 2015, at 15:26, Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br>&gt; <br>&gt; How would you write this with the new syntax?<br>&gt; <br>&gt; someAsyncFunction() { error in<br>&gt;     // …<br>&gt; }<br>&gt; <br>&gt; This doesn&#39;t make sense (like Thorsten explained earlier):<br>&gt; <br>&gt; someAsyncFunction() error {<br>&gt;     // …<br>&gt; }<br>&gt; <br>&gt; I agree though that &quot;in&quot; is confusing and I never understood what &quot;in&quot; means here.<br>&gt; Since &quot;do&quot; is no longer used for loops but code blocks it would make sense to replace &quot;in&quot; with &quot;do&quot;. <br>&gt; <br>&gt; someAsyncFunction() { error do<br>&gt;     // …<br>&gt; }<br>&gt; <br>&gt; <br>&gt; On Sun, Dec 13, 2015 at 9:42 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Hi Taras,<br>&gt; <br>&gt; I don&#39;t think the syntax { x in ... } is a hindrance for your proposal of turning all code blocks into closures, as all code blocks currently have no arguments and in that case both variants look the same. All code blocks with the exception of function bodies but I think having these looking different is ok.<br>&gt; <br>&gt; An advantage of the current syntax is that you can leave off the parentheses when calling a closure if it is the last argument which already enables the syntax you would like for &quot;local&quot;:<br>&gt; <br>&gt; let x = local {<br>&gt;         ...<br>&gt; }<br>&gt; <br>&gt; This requires having the arguments inside the braces to allow for things like these:<br>&gt; <br>&gt; someCollection.forEach { x in ... }<br>&gt; File.open(&quot;some/path&quot;) { file in ... } // having the file closed automatically<br>&gt; <br>&gt; Such usage patterns would look awkward with arguments outside of the braces and they are very common and very useful.<br>&gt; <br>&gt; Actually I was very surprised to see that your example with &quot;local&quot; returning a tuple did not work. The type inferencer should be able to infer the result type T to be a tuple without problems.<br>&gt; <br>&gt; -Thorsten <br>&gt; <br>&gt; Am 13.12.2015 um 05:14 schrieb Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; <br>&gt;&gt; Dear all, <br>&gt;&gt; <br>&gt;&gt; first of all, thank you for giving the community the opportunity to influence the future of Swift. This is a strong move, which shows how passionate the Swift team is about their language and how you guys want to make it the best. <br>&gt;&gt; <br>&gt;&gt; Personally, I am a huge fan of streamlined, logically concise concepts as well as syntax in programming languages. This is an area where Swift both excels at (love what you do with types in the compiler) but also sometimes lacking, as there seems to be a lot of idiosyncrasy, as evident from the huge number of language keywords and compiler attributes.  Here, I would like to discuss some of the idiosyncrasy with closures. As I am trying to throw some random ideas out there, my post might be a bit chaotic, so please bear with me.  Besides, I literally started playing around with Swift only few hours ago (I know, I know, I’m late), so my practical knowledge of the language is very limited. <br>&gt;&gt; <br>&gt;&gt; 1. I always wondered about the specific closure syntax { A -&gt; B in … }. The type annotation is within the block for some reason and the there is the keyword ‘in’, which is usually associated with the for loop. My proposal would be to change this to simply:<br>&gt;&gt; <br>&gt;&gt;    A -&gt; B { … }<br>&gt;&gt; <br>&gt;&gt; That is, the closure declaration closely mirrors the function declaration, but without the &#39;func name’ part. This is far from being just a cosmetic change though. Rather, it has some far-reaching consequences to how the concept of closure is applied to the language, but I believe that this would make Swift much more streamlined and concise (and also solve some other issues in the process). <br>&gt;&gt; <br>&gt;&gt; The crucial point is that the type annotation is (and should be) optional. Which means that every code block { … } is a closure. I think this fundamentally makes a lot of sense. So, a function declaration is just a closure associated with a name identifier (aka. injected into the namespace). Similarly, code blocks used in statements such as for and do have local lexical scope, which makes them essentially compatible closures as far as I can see. <br>&gt;&gt; <br>&gt;&gt; Essentially, this approach radically simplifies the language both from the syntax standpoint — closures and funcs are using the same syntax, the notion of code blocks is removed from the language; but also from the semantics standpoint. For instance, one can give more formal definitions for statements, which opens the path of treating statements as expressions (see https://lists.swift.org/pipermail/swift-evolution/2015-December/000133.html &lt;https://lists.swift.org/pipermail/swift-evolution/2015-December/000133.html&gt;). For instance, current if is of type (Bool, ()-&gt;())-&gt;(), but it can easily be redeclared as (Bool, ()-&gt;T)-&gt;T, which opens way to nice things like <br>&gt;&gt; <br>&gt;&gt;   let x = if(…) { .. some complex setup code..; value1} else { … other code..; value2}<br>&gt;&gt; <br>&gt;&gt; Similarly, do can be used to incapsulate auxiliary computations in the local scope (see below).<br>&gt;&gt; <br>&gt;&gt; 2. Another closure limitation is that return type inference does not work with longer closures (but they should). Here a particular use case.  Due to my work, I program a lot with R (which is sometimes a neat language in its own right). A particular paradigm I find very useful is to use anonymous code blocks in local scope to prevent namespace pollution, e.g. (in R code)<br>&gt;&gt; <br>&gt;&gt;  dataset &lt;- local({<br>&gt;&gt;    a &lt;- some_computation<br>&gt;&gt;    b &lt;- some_computation<br>&gt;&gt; <br>&gt;&gt;    a combined with b<br>&gt;&gt; })<br>&gt;&gt; <br>&gt;&gt; // a and b are not visible in the outer scope anymore<br>&gt;&gt; <br>&gt;&gt; In JavaScript, people often use anonymous functions for the same effect. The nice thing about this paradigm is that it allows one to properly isolate data dependency from each other, give the compiler a better sense of variable lifespan and overall make your code much nicer to read. Of course, in Swift  this can be done with nested functions or closures, but its the question of aesthetics. At any rate, the R function is very easy to emulate in Swift:<br>&gt;&gt; <br>&gt;&gt;  func local&lt;T&gt;(closure: () -&gt; T) -&gt; T {<br>&gt;&gt;      return closure()<br>&gt;&gt;  }<br>&gt;&gt; <br>&gt;&gt; which works beautifully, e.g.<br>&gt;&gt; <br>&gt;&gt;  let (a1,a2) = local({return(1, 2)}<br>&gt;&gt; <br>&gt;&gt; However, if I want to use more complex code, I need to explicitly declare the closure type:<br>&gt;&gt; <br>&gt;&gt;    let (a1, a2) = local({ () -&gt; (Int, Int) in<br>&gt;&gt;      let x2 = x*2<br>&gt;&gt; <br>&gt;&gt;      return (x2, x2+1)<br>&gt;&gt;    })<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; This is bulky, and frankly, unnecessary, as the compiler can easily infer the return type of the closure. <br>&gt;&gt; <br>&gt;&gt; BTW, combined with proposal in 1., this style of programming just becomes the beautiful<br>&gt;&gt; <br>&gt;&gt; let (a1, a2) = do {<br>&gt;&gt;   .. do something ..<br>&gt;&gt;  return(…, …) // or simply (…, …)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Summary TL;DR version of the proposal: <br>&gt;&gt; <br>&gt;&gt; replace the {A-&gt;B in …} closure syntax by A-&gt;B {…} — where type declaration is optional, remove the concept of code block (replace it by closure) and statements that take blocks/closures typed expressions. Improve type inference for return values. Current syntactic sugar for closures such as anonymous arguments and last line as return values should be preserved. <br>&gt;&gt; <br>&gt;&gt; Advantages: streamlines the language, solves a number of issues at the same time (idiosyncrasy, operators as expressions). In the end, makes the language easier to use and also to understand conceptually. <br>&gt;&gt; <br>&gt;&gt; Disadvantages: I honestly can’t see a single one<br>&gt;&gt; <br>&gt;&gt; Implementation challenge: would requires a parser change that might be non-trivial. I can also imagine that a lot of refactoring in the compiler code is necessary in regards to how statements work — but this might pay off as in the end, the compiler only needs to deal with closures and calls, which simplifies optimisation. And Swift is already great at aggressive inlining of closures. <br>&gt;&gt; <br>&gt;&gt; Impact on existing code: the syntax of closure declarations can be automatically ported as the rewrite rule is trivial. As far as I can see, changing code blocks to closures won’t have any impact on the semantics of the control structures, because the blocks are already using lexical scope. <br>&gt;&gt; <br>&gt;&gt; Eager to hear your thoughts on this!<br>&gt;&gt; <br>&gt;&gt; Cheers, <br>&gt;&gt; <br>&gt;&gt; Taras <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151213/72204490/attachment-0001.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: open.gif<br>Type: image/gif<br>Size: 43 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151213/72204490/attachment-0002.gif&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: open.gif<br>Type: image/gif<br>Size: 43 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151213/72204490/attachment-0003.gif&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0eaab3d5d1d4428f74a711f724f2eb47?s=50"></div><header><strong>Streamlining closures</strong> from <string>Etan Kissling</string> &lt;kissling at oberon.ch&gt;<p>December 14, 2015 at 12:00:00pm</p></header><div class="content"><p>Problem is that without the `in` you could conflict with custom defined operators.<br></p><p>Right now, you can go with<br></p><p>[1, 2, 3, 4, 5].map {<br>    $0 + 1<br>}<br></p><p><br>Now assume a world where a user defined a custom postfix . or | operator.<br></p><p>var error = &quot;&quot;<br>someAsyncFunction() { error .<br>    // body<br>}<br></p><p>Is the &quot;error&quot; a named variable inside the closure, or the one used in the outer scope?<br></p><p>Is the . our custom postfix operator, or is it the delimiter between the argument list and the body?<br></p><p><br>With `in`, this problem cannot occur, as `in` cannot be used as an identifier.<br></p><p><br></p><p><br></p><p>Also don&#39;t forget about the whole mess when it starts with capture lists and explicit return type.<br></p><p>someAsyncFunction() { [capture list] (arg1: Arg1Type, arg2: Arg2Type, arg3: Arg3Type) -&gt; ReturnType in<br>    // ...<br>}<br></p><p><br></p><p>Etan<br></p><p><br></p><p><br></p><p><br>&gt; On 13 Dec 2015, at 15:36, Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On 13 Dec 2015, at 15:26, Marc Knaup &lt;marc at knaup.koeln &lt;mailto:marc at knaup.koeln&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; How would you write this with the new syntax?<br>&gt; <br>&gt; <br>&gt;&gt; On 13 Dec 2015, at 09:42, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I don&#39;t think the syntax { x in ... } is a hindrance for your proposal of turning all code blocks into closures, as all code blocks currently have no arguments and in that case both variants look the same. All code blocks with the exception of function bodies but I think having these looking different is ok.<br>&gt; <br>&gt; <br>&gt; Point well taken :)<br>&gt; <br>&gt; Other suggestions (out of top of my head) would be<br>&gt; <br>&gt; // lambda-calculus inspired, but potentially confusing<br>&gt; someAsyncFunction()  { error .<br>&gt;     // …<br>&gt; }<br>&gt; <br>&gt; // like above, kind of constructor notation, my personal favourite so far<br>&gt; someAsyncFunction()  { error |<br>&gt;     // …<br>&gt; }<br>&gt; <br>&gt; // lest idiosyncratic but also verbose and ugly<br>&gt; someAsyncFunction()  func(error) {<br>&gt;     // …<br>&gt; }<br>&gt; <br>&gt; But you are right of course that the syntax I proposed in the original mail does not work with these examples. Again, its more of a cosmetic thing anyway. I think the other point (streamlining the concept of closures in the language) is more important.<br>&gt; <br>&gt;&gt; On 13 Dec 2015, at 09:42, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Actually I was very surprised to see that your example with &quot;local&quot; returning a tuple did not work. The type inferencer should be able to infer the result type T to be a tuple without problems.<br>&gt; <br>&gt; Yep, I was also quite surprised. But it does not work for me as of Xcode 7C68<br>&gt; <br>&gt; Cheers,<br>&gt; <br>&gt;  Taras<br>&gt; <br>&gt; P.S. Thorsten, sorry for wrong reply, I am not using mailing lists often and the behaviour of the mail client is a bit confusing.<br>&gt; <br>&gt; <br>&gt;&gt; On 13 Dec 2015, at 15:26, Marc Knaup &lt;marc at knaup.koeln &lt;mailto:marc at knaup.koeln&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; How would you write this with the new syntax?<br>&gt;&gt; <br>&gt;&gt; someAsyncFunction() { error in<br>&gt;&gt;     // …<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This doesn&#39;t make sense (like Thorsten explained earlier):<br>&gt;&gt; <br>&gt;&gt; someAsyncFunction() error {<br>&gt;&gt;     // …<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I agree though that &quot;in&quot; is confusing and I never understood what &quot;in&quot; means here.<br>&gt;&gt; Since &quot;do&quot; is no longer used for loops but code blocks it would make sense to replace &quot;in&quot; with &quot;do&quot;.<br>&gt;&gt; <br>&gt;&gt; someAsyncFunction() { error do<br>&gt;&gt;     // …<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Sun, Dec 13, 2015 at 9:42 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Hi Taras,<br>&gt;&gt; <br>&gt;&gt; I don&#39;t think the syntax { x in ... } is a hindrance for your proposal of turning all code blocks into closures, as all code blocks currently have no arguments and in that case both variants look the same. All code blocks with the exception of function bodies but I think having these looking different is ok.<br>&gt;&gt; <br>&gt;&gt; An advantage of the current syntax is that you can leave off the parentheses when calling a closure if it is the last argument which already enables the syntax you would like for &quot;local&quot;:<br>&gt;&gt; <br>&gt;&gt; let x = local {<br>&gt;&gt;         ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This requires having the arguments inside the braces to allow for things like these:<br>&gt;&gt; <br>&gt;&gt; someCollection.forEach { x in ... }<br>&gt;&gt; File.open(&quot;some/path&quot;) { file in ... } // having the file closed automatically<br>&gt;&gt; <br>&gt;&gt; Such usage patterns would look awkward with arguments outside of the braces and they are very common and very useful.<br>&gt;&gt; <br>&gt;&gt; Actually I was very surprised to see that your example with &quot;local&quot; returning a tuple did not work. The type inferencer should be able to infer the result type T to be a tuple without problems.<br>&gt;&gt; <br>&gt;&gt; -Thorsten<br>&gt;&gt; <br>&gt;&gt; Am 13.12.2015 um 05:14 schrieb Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; Dear all,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; first of all, thank you for giving the community the opportunity to influence the future of Swift. This is a strong move, which shows how passionate the Swift team is about their language and how you guys want to make it the best.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Personally, I am a huge fan of streamlined, logically concise concepts as well as syntax in programming languages. This is an area where Swift both excels at (love what you do with types in the compiler) but also sometimes lacking, as there seems to be a lot of idiosyncrasy, as evident from the huge number of language keywords and compiler attributes.  Here, I would like to discuss some of the idiosyncrasy with closures. As I am trying to throw some random ideas out there, my post might be a bit chaotic, so please bear with me.  Besides, I literally started playing around with Swift only few hours ago (I know, I know, I’m late), so my practical knowledge of the language is very limited.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. I always wondered about the specific closure syntax { A -&gt; B in … }. The type annotation is within the block for some reason and the there is the keyword ‘in’, which is usually associated with the for loop. My proposal would be to change this to simply:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    A -&gt; B { … }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That is, the closure declaration closely mirrors the function declaration, but without the &#39;func name’ part. This is far from being just a cosmetic change though. Rather, it has some far-reaching consequences to how the concept of closure is applied to the language, but I believe that this would make Swift much more streamlined and concise (and also solve some other issues in the process).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The crucial point is that the type annotation is (and should be) optional. Which means that every code block { … } is a closure. I think this fundamentally makes a lot of sense. So, a function declaration is just a closure associated with a name identifier (aka. injected into the namespace). Similarly, code blocks used in statements such as for and do have local lexical scope, which makes them essentially compatible closures as far as I can see.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Essentially, this approach radically simplifies the language both from the syntax standpoint — closures and funcs are using the same syntax, the notion of code blocks is removed from the language; but also from the semantics standpoint. For instance, one can give more formal definitions for statements, which opens the path of treating statements as expressions (see https://lists.swift.org/pipermail/swift-evolution/2015-December/000133.html &lt;https://lists.swift.org/pipermail/swift-evolution/2015-December/000133.html&gt;). For instance, current if is of type (Bool, ()-&gt;())-&gt;(), but it can easily be redeclared as (Bool, ()-&gt;T)-&gt;T, which opens way to nice things like<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   let x = if(…) { .. some complex setup code..; value1} else { … other code..; value2}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Similarly, do can be used to incapsulate auxiliary computations in the local scope (see below).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2. Another closure limitation is that return type inference does not work with longer closures (but they should). Here a particular use case.  Due to my work, I program a lot with R (which is sometimes a neat language in its own right). A particular paradigm I find very useful is to use anonymous code blocks in local scope to prevent namespace pollution, e.g. (in R code)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  dataset &lt;- local({<br>&gt;&gt;&gt;    a &lt;- some_computation<br>&gt;&gt;&gt;    b &lt;- some_computation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    a combined with b<br>&gt;&gt;&gt; })<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // a and b are not visible in the outer scope anymore<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In JavaScript, people often use anonymous functions for the same effect. The nice thing about this paradigm is that it allows one to properly isolate data dependency from each other, give the compiler a better sense of variable lifespan and overall make your code much nicer to read. Of course, in Swift  this can be done with nested functions or closures, but its the question of aesthetics. At any rate, the R function is very easy to emulate in Swift:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  func local&lt;T&gt;(closure: () -&gt; T) -&gt; T {<br>&gt;&gt;&gt;      return closure()<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; which works beautifully, e.g.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  let (a1,a2) = local({return(1, 2)}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; However, if I want to use more complex code, I need to explicitly declare the closure type:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    let (a1, a2) = local({ () -&gt; (Int, Int) in<br>&gt;&gt;&gt;      let x2 = x*2<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;      return (x2, x2+1)<br>&gt;&gt;&gt;    })<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is bulky, and frankly, unnecessary, as the compiler can easily infer the return type of the closure.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; BTW, combined with proposal in 1., this style of programming just becomes the beautiful<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let (a1, a2) = do {<br>&gt;&gt;&gt;   .. do something ..<br>&gt;&gt;&gt;  return(…, …) // or simply (…, …)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Summary TL;DR version of the proposal:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; replace the {A-&gt;B in …} closure syntax by A-&gt;B {…} — where type declaration is optional, remove the concept of code block (replace it by closure) and statements that take blocks/closures typed expressions. Improve type inference for return values. Current syntactic sugar for closures such as anonymous arguments and last line as return values should be preserved.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Advantages: streamlines the language, solves a number of issues at the same time (idiosyncrasy, operators as expressions). In the end, makes the language easier to use and also to understand conceptually.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Disadvantages: I honestly can’t see a single one<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Implementation challenge: would requires a parser change that might be non-trivial. I can also imagine that a lot of refactoring in the compiler code is necessary in regards to how statements work — but this might pay off as in the end, the compiler only needs to deal with closures and calls, which simplifies optimisation. And Swift is already great at aggressive inlining of closures.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Impact on existing code: the syntax of closure declarations can be automatically ported as the rewrite rule is trivial. As far as I can see, changing code blocks to closures won’t have any impact on the semantics of the control structures, because the blocks are already using lexical scope.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Eager to hear your thoughts on this!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Taras &lt;open.gif&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &lt;open.gif&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt;&gt; On 13 Dec 2015, at 15:26, Marc Knaup &lt;marc at knaup.koeln &lt;mailto:marc at knaup.koeln&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; How would you write this with the new syntax?<br>&gt;&gt; <br>&gt;&gt; someAsyncFunction() { error in<br>&gt;&gt;     // …<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This doesn&#39;t make sense (like Thorsten explained earlier):<br>&gt;&gt; <br>&gt;&gt; someAsyncFunction() error {<br>&gt;&gt;     // …<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I agree though that &quot;in&quot; is confusing and I never understood what &quot;in&quot; means here.<br>&gt;&gt; Since &quot;do&quot; is no longer used for loops but code blocks it would make sense to replace &quot;in&quot; with &quot;do&quot;.<br>&gt;&gt; <br>&gt;&gt; someAsyncFunction() { error do<br>&gt;&gt;     // …<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Sun, Dec 13, 2015 at 9:42 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Hi Taras,<br>&gt;&gt; <br>&gt;&gt; I don&#39;t think the syntax { x in ... } is a hindrance for your proposal of turning all code blocks into closures, as all code blocks currently have no arguments and in that case both variants look the same. All code blocks with the exception of function bodies but I think having these looking different is ok.<br>&gt;&gt; <br>&gt;&gt; An advantage of the current syntax is that you can leave off the parentheses when calling a closure if it is the last argument which already enables the syntax you would like for &quot;local&quot;:<br>&gt;&gt; <br>&gt;&gt; let x = local {<br>&gt;&gt;         ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This requires having the arguments inside the braces to allow for things like these:<br>&gt;&gt; <br>&gt;&gt; someCollection.forEach { x in ... }<br>&gt;&gt; File.open(&quot;some/path&quot;) { file in ... } // having the file closed automatically<br>&gt;&gt; <br>&gt;&gt; Such usage patterns would look awkward with arguments outside of the braces and they are very common and very useful.<br>&gt;&gt; <br>&gt;&gt; Actually I was very surprised to see that your example with &quot;local&quot; returning a tuple did not work. The type inferencer should be able to infer the result type T to be a tuple without problems.<br>&gt;&gt; <br>&gt;&gt; -Thorsten<br>&gt;&gt; <br>&gt;&gt; Am 13.12.2015 um 05:14 schrieb Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; Dear all,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; first of all, thank you for giving the community the opportunity to influence the future of Swift. This is a strong move, which shows how passionate the Swift team is about their language and how you guys want to make it the best.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Personally, I am a huge fan of streamlined, logically concise concepts as well as syntax in programming languages. This is an area where Swift both excels at (love what you do with types in the compiler) but also sometimes lacking, as there seems to be a lot of idiosyncrasy, as evident from the huge number of language keywords and compiler attributes.  Here, I would like to discuss some of the idiosyncrasy with closures. As I am trying to throw some random ideas out there, my post might be a bit chaotic, so please bear with me.  Besides, I literally started playing around with Swift only few hours ago (I know, I know, I’m late), so my practical knowledge of the language is very limited.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. I always wondered about the specific closure syntax { A -&gt; B in … }. The type annotation is within the block for some reason and the there is the keyword ‘in’, which is usually associated with the for loop. My proposal would be to change this to simply:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    A -&gt; B { … }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That is, the closure declaration closely mirrors the function declaration, but without the &#39;func name’ part. This is far from being just a cosmetic change though. Rather, it has some far-reaching consequences to how the concept of closure is applied to the language, but I believe that this would make Swift much more streamlined and concise (and also solve some other issues in the process).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The crucial point is that the type annotation is (and should be) optional. Which means that every code block { … } is a closure. I think this fundamentally makes a lot of sense. So, a function declaration is just a closure associated with a name identifier (aka. injected into the namespace). Similarly, code blocks used in statements such as for and do have local lexical scope, which makes them essentially compatible closures as far as I can see.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Essentially, this approach radically simplifies the language both from the syntax standpoint — closures and funcs are using the same syntax, the notion of code blocks is removed from the language; but also from the semantics standpoint. For instance, one can give more formal definitions for statements, which opens the path of treating statements as expressions (see https://lists.swift.org/pipermail/swift-evolution/2015-December/000133.html &lt;https://lists.swift.org/pipermail/swift-evolution/2015-December/000133.html&gt;). For instance, current if is of type (Bool, ()-&gt;())-&gt;(), but it can easily be redeclared as (Bool, ()-&gt;T)-&gt;T, which opens way to nice things like<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   let x = if(…) { .. some complex setup code..; value1} else { … other code..; value2}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Similarly, do can be used to incapsulate auxiliary computations in the local scope (see below).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2. Another closure limitation is that return type inference does not work with longer closures (but they should). Here a particular use case.  Due to my work, I program a lot with R (which is sometimes a neat language in its own right). A particular paradigm I find very useful is to use anonymous code blocks in local scope to prevent namespace pollution, e.g. (in R code)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  dataset &lt;- local({<br>&gt;&gt;&gt;    a &lt;- some_computation<br>&gt;&gt;&gt;    b &lt;- some_computation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    a combined with b<br>&gt;&gt;&gt; })<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // a and b are not visible in the outer scope anymore<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In JavaScript, people often use anonymous functions for the same effect. The nice thing about this paradigm is that it allows one to properly isolate data dependency from each other, give the compiler a better sense of variable lifespan and overall make your code much nicer to read. Of course, in Swift  this can be done with nested functions or closures, but its the question of aesthetics. At any rate, the R function is very easy to emulate in Swift:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  func local&lt;T&gt;(closure: () -&gt; T) -&gt; T {<br>&gt;&gt;&gt;      return closure()<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; which works beautifully, e.g.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  let (a1,a2) = local({return(1, 2)}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; However, if I want to use more complex code, I need to explicitly declare the closure type:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    let (a1, a2) = local({ () -&gt; (Int, Int) in<br>&gt;&gt;&gt;      let x2 = x*2<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;      return (x2, x2+1)<br>&gt;&gt;&gt;    })<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is bulky, and frankly, unnecessary, as the compiler can easily infer the return type of the closure.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; BTW, combined with proposal in 1., this style of programming just becomes the beautiful<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let (a1, a2) = do {<br>&gt;&gt;&gt;   .. do something ..<br>&gt;&gt;&gt;  return(…, …) // or simply (…, …)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Summary TL;DR version of the proposal:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; replace the {A-&gt;B in …} closure syntax by A-&gt;B {…} — where type declaration is optional, remove the concept of code block (replace it by closure) and statements that take blocks/closures typed expressions. Improve type inference for return values. Current syntactic sugar for closures such as anonymous arguments and last line as return values should be preserved.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Advantages: streamlines the language, solves a number of issues at the same time (idiosyncrasy, operators as expressions). In the end, makes the language easier to use and also to understand conceptually.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Disadvantages: I honestly can’t see a single one<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Implementation challenge: would requires a parser change that might be non-trivial. I can also imagine that a lot of refactoring in the compiler code is necessary in regards to how statements work — but this might pay off as in the end, the compiler only needs to deal with closures and calls, which simplifies optimisation. And Swift is already great at aggressive inlining of closures.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Impact on existing code: the syntax of closure declarations can be automatically ported as the rewrite rule is trivial. As far as I can see, changing code blocks to closures won’t have any impact on the semantics of the control structures, because the blocks are already using lexical scope.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Eager to hear your thoughts on this!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Taras<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/12a3a860/attachment-0001.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 801 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/12a3a860/attachment-0001.sig&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Streamlining closures</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 14, 2015 at 06:00:00pm</p></header><div class="content"><p>&gt; Now assume a world where a user defined a custom postfix . or | operator.<br></p><p>“.” cannot be a custom operator; it’s reserved by the language. (But I think it’s way too easily missed to play such an important role.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Streamlining closures</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>December 13, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; Am 13.12.2015 um 15:26 schrieb Marc Knaup &lt;marc at knaup.koeln&gt;:<br>&gt; <br>&gt; I agree though that &quot;in&quot; is confusing and I never understood what &quot;in&quot; means here.<br>&gt; Since &quot;do&quot; is no longer used for loops but code blocks it would make sense to replace &quot;in&quot; with &quot;do“. <br></p><p>Well, I read<br></p><p>{ error in … }<br></p><p>as meaning, „error“ is bound within („in“) the following statements. I’m fine with that.<br></p><p>-Thorsten<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151213/571665f8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>Streamlining closures</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>December 13, 2015 at 04:00:00pm</p></header><div class="content"><p>Compare the following cases:<br></p><p>#1<br>for variable in sequence {}<br></p><p>#2<br>someFunction({ variable in sequence })<br></p><p>Case #1 assigns elements from sequence to variable, so sequence is the<br>SOURCE and variable is the DESTINATION.<br>Case #2 has variable as SOURCE and sequence as DESTINATION (return value).<br>It&#39;s flipped!<br>It feels like it&#39;s meaning the same (&quot;destination IN source&quot;) but it is<br>not. That&#39;s inconsistent and confusing.<br></p><p>Changing #2 to the following breaks the inconsistency and avoids the<br>confusion:<br></p><p>someFunction({ variable do sequence })<br></p><p>I know the example doesn&#39;t make much sense as it just returns the sequence<br>and ignores the variable. But it&#39;s good enough to highlight the<br>inconsistency.<br></p><p><br>On Sun, Dec 13, 2015 at 3:47 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br></p><p>&gt;<br>&gt; Am 13.12.2015 um 15:26 schrieb Marc Knaup &lt;marc at knaup.koeln&gt;:<br>&gt;<br>&gt; I agree though that &quot;in&quot; is confusing and I never understood what &quot;in&quot;<br>&gt; means here.<br>&gt; Since &quot;do&quot; is no longer used for loops but code blocks it would make sense<br>&gt; to replace &quot;in&quot; with &quot;do“.<br>&gt;<br>&gt;<br>&gt; Well, I read<br>&gt;<br>&gt; { error *in* … }<br>&gt;<br>&gt; as meaning, „error“ is bound within („in“) the following statements. I’m<br>&gt; fine with that.<br>&gt;<br>&gt; -Thorsten<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151213/29172338/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f98dc2a5a610100f8528eeeb2ff3c282?s=50"></div><header><strong>Streamlining closures</strong> from <string>Andrew Brown</string> &lt;a.br at me.com&gt;<p>December 13, 2015 at 07:00:00pm</p></header><div class="content"><p>I&#39;ve never really been able to read this naturally.<br>What opinions do people have on <br>{ with variable do sequence }<br>Or <br>with variable { sequences }<br></p><p>ABR.<br></p><p>&gt; On 13 Dec 2015, at 15:03, Marc Knaup via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Compare the following cases:<br>&gt; <br>&gt; #1<br>&gt; for variable in sequence {}<br>&gt; <br>&gt; #2<br>&gt; someFunction({ variable in sequence })<br>&gt; <br>&gt; Case #1 assigns elements from sequence to variable, so sequence is the SOURCE and variable is the DESTINATION.<br>&gt; Case #2 has variable as SOURCE and sequence as DESTINATION (return value).<br>&gt; It&#39;s flipped!<br>&gt; It feels like it&#39;s meaning the same (&quot;destination IN source&quot;) but it is not. That&#39;s inconsistent and confusing.<br>&gt; <br>&gt; Changing #2 to the following breaks the inconsistency and avoids the confusion:<br>&gt; <br>&gt; someFunction({ variable do sequence })<br>&gt; <br>&gt; I know the example doesn&#39;t make much sense as it just returns the sequence and ignores the variable. But it&#39;s good enough to highlight the inconsistency.<br>&gt; <br>&gt; <br>&gt;&gt; On Sun, Dec 13, 2015 at 3:47 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Am 13.12.2015 um 15:26 schrieb Marc Knaup &lt;marc at knaup.koeln&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree though that &quot;in&quot; is confusing and I never understood what &quot;in&quot; means here.<br>&gt;&gt;&gt; Since &quot;do&quot; is no longer used for loops but code blocks it would make sense to replace &quot;in&quot; with &quot;do“. <br>&gt;&gt; <br>&gt;&gt; Well, I read<br>&gt;&gt; <br>&gt;&gt; { error in … }<br>&gt;&gt; <br>&gt;&gt; as meaning, „error“ is bound within („in“) the following statements. I’m fine with that.<br>&gt;&gt; <br>&gt;&gt; -Thorsten<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151213/602e8141/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Streamlining closures</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>December 15, 2015 at 12:00:00pm</p></header><div class="content"><p>Hi, Taras. Thanks for writing this up. Unfortunately, it&#39;s infeasible to do most of these things, for several reasons.<br></p><p>&gt; On Dec 12, 2015, at 20:14 , Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Dear all, <br>&gt; <br>&gt; first of all, thank you for giving the community the opportunity to influence the future of Swift. This is a strong move, which shows how passionate the Swift team is about their language and how you guys want to make it the best. <br>&gt; <br>&gt; Personally, I am a huge fan of streamlined, logically concise concepts as well as syntax in programming languages. This is an area where Swift both excels at (love what you do with types in the compiler) but also sometimes lacking, as there seems to be a lot of idiosyncrasy, as evident from the huge number of language keywords and compiler attributes.  Here, I would like to discuss some of the idiosyncrasy with closures. As I am trying to throw some random ideas out there, my post might be a bit chaotic, so please bear with me.  Besides, I literally started playing around with Swift only few hours ago (I know, I know, I’m late), so my practical knowledge of the language is very limited. <br>&gt; <br>&gt; 1. I always wondered about the specific closure syntax { A -&gt; B in … }. The type annotation is within the block for some reason and the there is the keyword ‘in’, which is usually associated with the for loop. My proposal would be to change this to simply:<br>&gt; <br>&gt;    A -&gt; B { … }<br>&gt; <br>&gt; That is, the closure declaration closely mirrors the function declaration, but without the &#39;func name’ part. This is far from being just a cosmetic change though. Rather, it has some far-reaching consequences to how the concept of closure is applied to the language, but I believe that this would make Swift much more streamlined and concise (and also solve some other issues in the process). <br></p><p>We thought a lot about this, and settled on the current syntax (inside the braces) for several reasons, the main one being that it&#39;s much easier to parse. Without this, the compiler would have to stop whatever it&#39;s currently doing when it sees &#39;-&gt;&#39;. We do already do some of this work for things like &quot;[Int]()&quot; (which starts out as an array literal and then gets reinterpreted as a type later), but it leads to weird errors when the code is invalid or incomplete.<br></p><p>The keyword &quot;in&quot; was chosen because (a) it&#39;s already a keyword, (b) it&#39;s still short, and (c) it felt more Swifty than Smalltalk/Ruby pipes.<br></p><p>&gt; <br>&gt; The crucial point is that the type annotation is (and should be) optional. Which means that every code block { … } is a closure. I think this fundamentally makes a lot of sense. So, a function declaration is just a closure associated with a name identifier (aka. injected into the namespace). Similarly, code blocks used in statements such as for and do have local lexical scope, which makes them essentially compatible closures as far as I can see. <br></p><p>Today, &#39;return&#39; from a closure cannot return from the containing function. That alone would be a big language change.<br></p><p><br>&gt; <br>&gt; Essentially, this approach radically simplifies the language both from the syntax standpoint — closures and funcs are using the same syntax, the notion of code blocks is removed from the language; but also from the semantics standpoint. For instance, one can give more formal definitions for statements, which opens the path of treating statements as expressions (see https://lists.swift.org/pipermail/swift-evolution/2015-December/000133.html &lt;https://lists.swift.org/pipermail/swift-evolution/2015-December/000133.html&gt;). For instance, current if is of type (Bool, ()-&gt;())-&gt;(), but it can easily be redeclared as (Bool, ()-&gt;T)-&gt;T, which opens way to nice things like <br>&gt; <br>&gt;   let x = if(…) { .. some complex setup code..; value1} else { … other code..; value2}<br>&gt; <br>&gt; Similarly, do can be used to incapsulate auxiliary computations in the local scope (see below).<br></p><p>As discussed on the other thread, it&#39;s not at all clear that this is desireable. The implicit return in particular would be controversial &lt;http://awardwinningfjords.com/2012/05/08/beware-coffeescript-comprehensions.html&gt;.<br></p><p>&gt; <br>&gt; 2. Another closure limitation is that return type inference does not work with longer closures (but they should). Here a particular use case.  Due to my work, I program a lot with R (which is sometimes a neat language in its own right). A particular paradigm I find very useful is to use anonymous code blocks in local scope to prevent namespace pollution, e.g. (in R code)<br>&gt; <br>&gt;  dataset &lt;- local({<br>&gt;    a &lt;- some_computation<br>&gt;    b &lt;- some_computation<br>&gt; <br>&gt;    a combined with b<br>&gt; })<br>&gt; <br>&gt; // a and b are not visible in the outer scope anymore<br>&gt; <br>&gt; In JavaScript, people often use anonymous functions for the same effect. The nice thing about this paradigm is that it allows one to properly isolate data dependency from each other, give the compiler a better sense of variable lifespan and overall make your code much nicer to read. Of course, in Swift  this can be done with nested functions or closures, but its the question of aesthetics. At any rate, the R function is very easy to emulate in Swift:<br>&gt; <br>&gt;  func local&lt;T&gt;(closure: () -&gt; T) -&gt; T {<br>&gt;      return closure()<br>&gt;  }<br>&gt; <br>&gt; which works beautifully, e.g.<br>&gt; <br>&gt;  let (a1,a2) = local({return(1, 2)}<br>&gt; <br>&gt; However, if I want to use more complex code, I need to explicitly declare the closure type:<br>&gt; <br>&gt;    let (a1, a2) = local({ () -&gt; (Int, Int) in<br>&gt;      let x2 = x*2<br>&gt; <br>&gt;      return (x2, x2+1)<br>&gt;    })<br>&gt; <br>&gt; <br>&gt; This is bulky, and frankly, unnecessary, as the compiler can easily infer the return type of the closure. <br>&gt; <br>&gt; BTW, combined with proposal in 1., this style of programming just becomes the beautiful<br>&gt; <br>&gt; let (a1, a2) = do {<br>&gt;   .. do something ..<br>&gt;  return(…, …) // or simply (…, …)<br>&gt; }<br></p><p>Swift&#39;s type inference is currently statement-oriented, so there&#39;s no easy way to do this inference. This is at least partly a compilation-time concern: Swift&#39;s type system allows many more possible conversions than, say, Haskell or OCaml, so solving the types for an entire multi-statement function is not a trivial problem, possibly not a tractable problem.<br></p><p>The canonical way to write your closure would be this:<br></p><p>  let (a1, a2): (Int, Int) = {<br>    let x2 = x*2<br>    return (x2, x2+1)<br>  }()<br></p><p>To summarize, I think Swift has made the right trade-offs for a statically-typed language that prefers clarity over brevity &lt;https://swift.org/documentation/api-design-guidelines.html#fundamentals&gt;. Simply re-syntaxing closures isn&#39;t out of the question, but we ultimately went for something that handles many inline uses with varying amounts of type info rather than trying to stick as closely as possible to function syntax.<br></p><p>Best,<br>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/d9892385/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
