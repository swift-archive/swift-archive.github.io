<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/46439321e8b5b5ba0944eef50e18c3a3?s=50"></div><header><strong>UnsafeMutablePointer on the stack?</strong> from <string>Jean-Denis Muys</string> &lt;jdmuys at gmail.com&gt;<p>October  3, 2016 at 01:00:00am</p></header><div class="content"><p>Hi,<br></p><p>I have some issues using the new raw memory API. For instance, let&#39;s<br>suppose I want to call the `SecRandomCopyBytes` API to generate a<br>cryptographically secure random 32-bit number. The difficulty is its 3rd<br>argument, which is declared as UnsafeMutablePointer&lt;UInt8&gt;. Here is a<br>function that does that:<br></p><p>func entropicRandom() -&gt; UInt32 {<br></p><p>    let randomWordPT = UnsafeMutablePointer&lt;UInt32&gt;.allocate(capacity: 1)<br></p><p><br>    let _ = randomWordPT.withMemoryRebound(to: UInt8.self, capacity: 4) {<br>(p: UnsafeMutablePointer&lt;UInt8&gt;) -&gt; Int32 in<br></p><p>        let result = SecRandomCopyBytes(kSecRandomDefault, MemoryLayout&lt;<br>UInt32&gt;.size, p)<br></p><p>        return result<br></p><p>    }<br></p><p>    let randomInt32 = randomWordPT[0]<br></p><p>    randomWordPT.deallocate(capacity: 1)<br></p><p>    return randomInt32<br></p><p>}<br></p><p>apparently, the calls to allocate and then deallocate suggest that there is<br>some heap allocation happening behind the scene here, possibly malloc/free.<br>Is that correct?<br></p><p>If so, this is quite wasteful. Is there a way to use a local variable on<br>the stack to achieve the same result?<br></p><p>Thanks,<br></p><p>Jean-Denis<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20161003/c5a3cbda/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c23a24dd9f358575e9764f1a535e2ce0?s=50"></div><header><strong>UnsafeMutablePointer on the stack?</strong> from <string>Mike Ferenduros</string> &lt;mike.ferenduros at gmail.com&gt;<p>October  3, 2016 at 12:00:00am</p></header><div class="content"><p>You can use a local like this:<br>    var x: UInt32 = 0<br>    withUnsafePointer(to: x) { randomWordPT in<br>        //your existing code here<br>    }<br></p><p>Or I&#39;m not sure if small arrays go on the heap, but<br></p><p>    var bytes: [UInt8] = [0,0,0,0]<br>    _ = SecRandomCopyBytes(kSecRandomDefault, bytes.count, &amp;bytes)<br>    return bytes.reduce(0) { ($0 &lt;&lt; 8) | UInt32($1) }<br></p><p>reads a little nicer.<br></p><p>Personally I would be surprised if the malloc caused an actual measurable<br>performance hit tbh.<br></p><p>On Mon, 3 Oct 2016 at 02:15 Jean-Denis Muys via swift-users &lt;<br>swift-users at swift.org&gt; wrote:<br></p><p>&gt; Hi,<br>&gt;<br>&gt; I have some issues using the new raw memory API. For instance, let&#39;s<br>&gt; suppose I want to call the `SecRandomCopyBytes` API to generate a<br>&gt; cryptographically secure random 32-bit number. The difficulty is its 3rd<br>&gt; argument, which is declared as UnsafeMutablePointer&lt;UInt8&gt;. Here is a<br>&gt; function that does that:<br>&gt;<br>&gt; func entropicRandom() -&gt; UInt32 {<br>&gt;<br>&gt;     let randomWordPT = UnsafeMutablePointer&lt;UInt32&gt;.allocate(capacity: 1)<br>&gt;<br>&gt;<br>&gt;     let _ = randomWordPT.withMemoryRebound(to: UInt8.self, capacity: 4) {<br>&gt; (p: UnsafeMutablePointer&lt;UInt8&gt;) -&gt; Int32 in<br>&gt;<br>&gt;         let result = SecRandomCopyBytes(kSecRandomDefault, MemoryLayout&lt;<br>&gt; UInt32&gt;.size, p)<br>&gt;<br>&gt;         return result<br>&gt;<br>&gt;     }<br>&gt;<br>&gt;     let randomInt32 = randomWordPT[0]<br>&gt;<br>&gt;     randomWordPT.deallocate(capacity: 1)<br>&gt;<br>&gt;     return randomInt32<br>&gt;<br>&gt; }<br>&gt;<br>&gt; apparently, the calls to allocate and then deallocate suggest that there<br>&gt; is some heap allocation happening behind the scene here, possibly<br>&gt; malloc/free. Is that correct?<br>&gt;<br>&gt; If so, this is quite wasteful. Is there a way to use a local variable on<br>&gt; the stack to achieve the same result?<br>&gt;<br>&gt; Thanks,<br>&gt;<br>&gt; Jean-Denis<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20161003/5f326063/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2bc666e29724cd3bdf46b6cbbe4a07bb?s=50"></div><header><strong>UnsafeMutablePointer on the stack?</strong> from <string>Quinn &quot;The Eskimo!&quot;</string> &lt;eskimo1 at apple.com&gt;<p>October  3, 2016 at 08:00:00am</p></header><div class="content"><p>On 3 Oct 2016, at 01:14, Mike Ferenduros via swift-users &lt;swift-users at swift.org&gt; wrote:<br></p><p>&gt; Personally I would be surprised if the malloc caused an actual measurable performance hit tbh.<br></p><p>Quite.  SecRandom generates cryptographically sound random numbers and thus is not optimised for speed.<br></p><p>Share and Enjoy<br>--<br>Quinn &quot;The Eskimo!&quot;                    &lt;http://www.apple.com/developer/&gt;<br>Apple Developer Relations, Developer Technical Support, Core OS/Hardware<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/46439321e8b5b5ba0944eef50e18c3a3?s=50"></div><header><strong>UnsafeMutablePointer on the stack?</strong> from <string>Jean-Denis Muys</string> &lt;jdmuys at gmail.com&gt;<p>October  3, 2016 at 11:00:00am</p></header><div class="content"><p>Indeed,<br></p><p>But that function was just an example. I wanted to learn about how to use the stack to call C functions that will fill some memory area passed as a pointer.<br></p><p>Jean-Denis<br></p><p><br></p><p>&gt; On 3 Oct 2016, at 09:46, Quinn The Eskimo! via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; On 3 Oct 2016, at 01:14, Mike Ferenduros via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Personally I would be surprised if the malloc caused an actual measurable performance hit tbh.<br>&gt; <br>&gt; Quite.  SecRandom generates cryptographically sound random numbers and thus is not optimised for speed.<br>&gt; <br>&gt; Share and Enjoy<br>&gt; --<br>&gt; Quinn &quot;The Eskimo!&quot;                    &lt;http://www.apple.com/developer/&gt;<br>&gt; Apple Developer Relations, Developer Technical Support, Core OS/Hardware<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>UnsafeMutablePointer on the stack?</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>October  3, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Oct 2, 2016, at 5:14 PM, Mike Ferenduros via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Personally I would be surprised if the malloc caused an actual measurable performance hit tbh.<br></p><p>It won’t be noticeable against a call to SecRandom, as noted, but there are other circumstances where it’s a big performance hit to put a temporary buffer on the heap. (Right now I’m working on some rather performance-sensitive database code in C++ where avoiding a few heap allocations per iteration has proven to be a big win.)<br></p><p>Does Swift have any solution for allocating stack-based array buffers?<br></p><p>—Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20161003/948526b1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>UnsafeMutablePointer on the stack?</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>October  3, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Oct 3, 2016, at 10:20 AM, Jens Alfke via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 2, 2016, at 5:14 PM, Mike Ferenduros via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Personally I would be surprised if the malloc caused an actual measurable performance hit tbh.<br>&gt; <br>&gt; It won’t be noticeable against a call to SecRandom, as noted, but there are other circumstances where it’s a big performance hit to put a temporary buffer on the heap. (Right now I’m working on some rather performance-sensitive database code in C++ where avoiding a few heap allocations per iteration has proven to be a big win.)<br>&gt; <br>&gt; Does Swift have any solution for allocating stack-based array buffers?<br></p><p>There has been some work in the optimizer toward optimizing arrays onto the stack when they don&#39;t escape. In general, I would recommend sticking with the pointer allocate/deallocate methods if you need to directly control the destiny of the memory. If the allocate and deallocate occur unconditionally in the same function, it is possible to optimize the pair into a stack allocation. Using a local variable isn&#39;t a guarantee that you&#39;ll get stack memory, since closures may force the variable onto the heap, and furthermore subjects you to more aggressive semantic constraints on the underlying memory than you may want.<br></p><p>-Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20161003/11fd493f/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
