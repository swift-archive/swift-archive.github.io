<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c56b98ce889653412aa0f3d6ab6a0263?s=50"></div><header><strong>Proposal: Implement a rotate algorithm, equivalent to std::rotate() in C++</strong> from <string>Sergey Bolshedvorsky</string> &lt;sergey at bolshedvorsky.com&gt;<p>December 13, 2015 at 10:00:00am</p></header><div class="content"><p>Hi everyone,<br></p><p>I’ve selected a ticket SR-125 as my first task (https://bugs.swift.org/browse/SR-125).<br></p><p>I would like to propose an implementation of this method in Swift stdlib.<br></p><p>std::rotate() method performs a left rotation on a range of elements.<br>C++ declaration is void rotate (ForwardIterator first, ForwardIterator middle, ForwardIterator last)<br>Specifically, it swaps the elements in the range [first, last) in such a way that the element middle becomes the first element of the new range and middle - 1 becomes the last element.<br>A precondition of this function is that [first, n_first) and [middle, last) are valid ranges.<br></p><p>What are your thoughts?<br></p><p>Sergey<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Proposal: Implement a rotate algorithm, equivalent to std::rotate() in C++</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 14, 2015 at 12:00:00am</p></header><div class="content"><p>&gt; On Dec 13, 2015, at 2:20 AM, Sergey Bolshedvorsky via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi everyone,<br>&gt; <br>&gt; I’ve selected a ticket SR-125 as my first task (https://bugs.swift.org/browse/SR-125).<br>&gt; <br>&gt; I would like to propose an implementation of this method in Swift stdlib.<br>&gt; <br>&gt; std::rotate() method performs a left rotation on a range of elements.<br>&gt; C++ declaration is void rotate (ForwardIterator first, ForwardIterator middle, ForwardIterator last)<br>&gt; Specifically, it swaps the elements in the range [first, last) in such a way that the element middle becomes the first element of the new range and middle - 1 becomes the last element.<br>&gt; A precondition of this function is that [first, n_first) and [middle, last) are valid ranges.<br>&gt; <br>&gt; What are your thoughts?<br></p><p>This is a really important algorithm, with applications even in GUI programming (see slide &lt;http://www.bfilipek.com/2014/12/top-5-beautiful-c-std-algorithms.html#slide&gt; and gather &lt;http://www.bfilipek.com/2014/12/top-5-beautiful-c-std-algorithms.html#gather&gt;), so I&#39;m really happy someone is taking it on. You&#39;ll need different implementations depending on the index&#39;s protocol conformance &lt;http://stackoverflow.com/questions/21160875/why-is-stdrotate-so-fast&gt;.  C++ implementations can get pretty sophisticated &lt;http://llvm.org/viewvc/llvm-project/libcxx/trunk/include/algorithm?view=markup&amp;pathrev=251836&gt;.  Would you like additional thoughts (and if so, of what nature), or will those do? ;-)<br></p><p><br>-Dave<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/334d67f7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c56b98ce889653412aa0f3d6ab6a0263?s=50"></div><header><strong>Proposal: Implement a rotate algorithm, equivalent to std::rotate() in C++</strong> from <string>Sergey Bolshedvorsky</string> &lt;sergey at bolshedvorsky.com&gt;<p>December 14, 2015 at 11:00:00am</p></header><div class="content"><p>There are 3 main algorithms: forward iteration, random access iteration and bidirectional iteration. All excerpts from the book Alexander A. Stepanov. “From Mathematics to Generic Programming”, Chapters 11.3 - 11.6<br></p><p><br>1. The forward iteration can be implemented by using Gries-Mills algorithm. This algorithm returns a new middle: a position where the first element moved. <br></p><p>template &lt;ForwardIterator I&gt;<br>I rotate(I f, I m, I l, std::forward_iterator_tag) {<br>    if (f == m) return l;<br>    if (m == l) return f;<br>    pair&lt;I, I&gt; p = swap_ranges(f, m, m, l);<br>    while (p.first != m || p.second != l) {<br>        if (p.second == l) {<br>            rotate_unguarded(p.first, m, l);<br>            return p.first;<br>        }<br>        f = m;<br>        m = p.second;<br>        p = swap_ranges(f, m, m, l);<br>    }<br>    return m;<br>}<br></p><p><br>2. The random access iteration can be implement in this way:<br></p><p>template &lt;RandomAccessIterator I&gt;<br>I rotate(I f, I m, I l, std::random_access_iterator_tag) {<br>    if (f == m) return l;<br>    if (m == l) return f;<br>    DifferenceType&lt;I&gt; cycles = gcd(m - f, l - m);<br>    rotate_transform&lt;I&gt; rotator(f, m, l);<br>    while (cycles-- &gt; 0) rotate_cycle_from(f + cycles, rotator);<br>    return rotator.m1;<br>}<br></p><p><br>3. The bidirectional iteration can be implement by using reverse algorithm in this way:<br></p><p>template &lt;BidirectionalIterator I&gt;<br>I rotate(I f, I m, I l, bidirectional_iterator_tag) {<br>     reverse(f, m);<br>     reverse(m, l);<br>     pair&lt;I, I&gt; p = reverse_until(f, m, l);<br>     reverse(p.first, p.second);<br>     if (m == p.first) return p.second;<br>     return p.first;<br>}<br></p><p><br>We need to hide the complexity of these algorithms, therefore we need to write a simple version that works for any type of iterations.<br></p><p>Shall I create a formal PR to swift-evolution with a proposed solution and detailed design?<br></p><p>Sergey<br></p><p><br>&gt; On 14 Dec 2015, at 08:51, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 13, 2015, at 2:20 AM, Sergey Bolshedvorsky via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi everyone,<br>&gt;&gt; <br>&gt;&gt; I’ve selected a ticket SR-125 as my first task (https://bugs.swift.org/browse/SR-125 &lt;https://bugs.swift.org/browse/SR-125&gt;).<br>&gt;&gt; <br>&gt;&gt; I would like to propose an implementation of this method in Swift stdlib.<br>&gt;&gt; <br>&gt;&gt; std::rotate() method performs a left rotation on a range of elements.<br>&gt;&gt; C++ declaration is void rotate (ForwardIterator first, ForwardIterator middle, ForwardIterator last)<br>&gt;&gt; Specifically, it swaps the elements in the range [first, last) in such a way that the element middle becomes the first element of the new range and middle - 1 becomes the last element.<br>&gt;&gt; A precondition of this function is that [first, n_first) and [middle, last) are valid ranges.<br>&gt;&gt; <br>&gt;&gt; What are your thoughts?<br>&gt; <br>&gt; This is a really important algorithm, with applications even in GUI programming (see slide &lt;http://www.bfilipek.com/2014/12/top-5-beautiful-c-std-algorithms.html#slide&gt; and gather &lt;http://www.bfilipek.com/2014/12/top-5-beautiful-c-std-algorithms.html#gather&gt;), so I&#39;m really happy someone is taking it on. You&#39;ll need different implementations depending on the index&#39;s protocol conformance &lt;http://stackoverflow.com/questions/21160875/why-is-stdrotate-so-fast&gt;.  C++ implementations can get pretty sophisticated &lt;http://llvm.org/viewvc/llvm-project/libcxx/trunk/include/algorithm?view=markup&amp;pathrev=251836&gt;.  Would you like additional thoughts (and if so, of what nature), or will those do? ;-)<br>&gt; <br>&gt; <br>&gt; -Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/5099c209/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a03106b2fbee9e0ada822057dfd0b6d3?s=50"></div><header><strong>Proposal: Implement a rotate algorithm, equivalent to std::rotate() in C++</strong> from <string>Tal Atlas</string> &lt;me at tal.by&gt;<p>December 14, 2015 at 01:00:00pm</p></header><div class="content"><p>This seems like the sort of think that a third-party library could supply.<br>Have you considered making a new package for it yourself?<br>On Mon, Dec 14, 2015 at 7:00 AM Sergey Bolshedvorsky via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt;<br>&gt; There are 3 main algorithms: forward iteration, random access iteration<br>&gt; and bidirectional iteration. All excerpts from the book Alexander A.<br>&gt; Stepanov. “From Mathematics to Generic Programming”, Chapters 11.3 - 11.6<br>&gt;<br>&gt;<br>&gt; 1. The forward iteration can be implemented by using Gries-Mills<br>&gt; algorithm. This algorithm returns a new middle: a position where the first<br>&gt; element moved.<br>&gt;<br>&gt; template &lt;ForwardIterator I&gt;<br>&gt; I rotate(I f, I m, I l, std::forward_iterator_tag) {<br>&gt;     if (f == m) return l;<br>&gt;     if (m == l) return f;<br>&gt;     pair&lt;I, I&gt; p = swap_ranges(f, m, m, l);<br>&gt;     while (p.first != m || p.second != l) {<br>&gt;         if (p.second == l) {<br>&gt;             rotate_unguarded(p.first, m, l);<br>&gt;             return p.first;<br>&gt;         }<br>&gt;         f = m;<br>&gt;         m = p.second;<br>&gt;         p = swap_ranges(f, m, m, l);<br>&gt;     }<br>&gt;     return m;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; 2. The random access iteration can be implement in this way:<br>&gt;<br>&gt; template &lt;RandomAccessIterator I&gt;<br>&gt; I rotate(I f, I m, I l, std::random_access_iterator_tag) {<br>&gt;     if (f == m) return l;<br>&gt;     if (m == l) return f;<br>&gt;     DifferenceType&lt;I&gt; cycles = gcd(m - f, l - m);<br>&gt;     rotate_transform&lt;I&gt; rotator(f, m, l);<br>&gt;     while (cycles-- &gt; 0) rotate_cycle_from(f + cycles, rotator);<br>&gt;     return rotator.m1;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; 3. The bidirectional iteration can be implement by using reverse algorithm<br>&gt; in this way:<br>&gt;<br>&gt; template &lt;BidirectionalIterator I&gt;<br>&gt; I rotate(I f, I m, I l, bidirectional_iterator_tag) {<br>&gt;      reverse(f, m);<br>&gt;      reverse(m, l);<br>&gt;      pair&lt;I, I&gt; p = reverse_until(f, m, l);<br>&gt;      reverse(p.first, p.second);<br>&gt;      if (m == p.first) return p.second;<br>&gt;      return p.first;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; We need to hide the complexity of these algorithms, therefore we need to<br>&gt; write a simple version that works for any type of iterations.<br>&gt;<br>&gt; Shall I create a formal PR to swift-evolution with a proposed solution and<br>&gt; detailed design?<br>&gt;<br>&gt; Sergey<br>&gt;<br>&gt;<br>&gt; On 14 Dec 2015, at 08:51, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Dec 13, 2015, at 2:20 AM, Sergey Bolshedvorsky via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Hi everyone,<br>&gt;<br>&gt; I’ve selected a ticket SR-125 as my first task (<br>&gt; https://bugs.swift.org/browse/SR-125).<br>&gt;<br>&gt; I would like to propose an implementation of this method in Swift stdlib.<br>&gt;<br>&gt; std::rotate() method performs a left rotation on a range of elements.<br>&gt; C++ declaration is void rotate (ForwardIterator first, ForwardIterator<br>&gt; middle, ForwardIterator last)<br>&gt; Specifically, it swaps the elements in the range [first, last) in such a<br>&gt; way that the element middle becomes the first element of the new range and<br>&gt; middle - 1 becomes the last element.<br>&gt; A precondition of this function is that [first, n_first) and [middle,<br>&gt; last) are valid ranges.<br>&gt;<br>&gt; What are your thoughts?<br>&gt;<br>&gt;<br>&gt; This is a really important algorithm, with applications even in GUI<br>&gt; programming (see slide<br>&gt; &lt;http://www.bfilipek.com/2014/12/top-5-beautiful-c-std-algorithms.html#slide&gt;<br>&gt;  and gather<br>&gt; &lt;http://www.bfilipek.com/2014/12/top-5-beautiful-c-std-algorithms.html#gather&gt;),<br>&gt; so I&#39;m really happy someone is taking it on. You&#39;ll need different<br>&gt; implementations depending on the index&#39;s protocol conformance<br>&gt; &lt;http://stackoverflow.com/questions/21160875/why-is-stdrotate-so-fast&gt;.<br>&gt; C++ implementations can get pretty sophisticated<br>&gt; &lt;http://llvm.org/viewvc/llvm-project/libcxx/trunk/include/algorithm?view=markup&amp;pathrev=251836&gt;.<br>&gt; Would you like additional thoughts (and if so, of what nature), or will<br>&gt; those do? ;-)<br>&gt;<br>&gt;<br>&gt; -Dave<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/ae1d94ea/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>Proposal: Implement a rotate algorithm, equivalent to std::rotate() in C++</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>December 14, 2015 at 03:00:00pm</p></header><div class="content"><p>This is a language restriction/limitation which libraries can&#39;t fix.<br></p><p>On Mon, Dec 14, 2015 at 2:50 PM, Tal Atlas via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; This seems like the sort of think that a third-party library could supply.<br>&gt; Have you considered making a new package for it yourself?<br>&gt; On Mon, Dec 14, 2015 at 7:00 AM Sergey Bolshedvorsky via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; There are 3 main algorithms: forward iteration, random access iteration<br>&gt;&gt; and bidirectional iteration. All excerpts from the book Alexander A.<br>&gt;&gt; Stepanov. “From Mathematics to Generic Programming”, Chapters 11.3 - 11.6<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; 1. The forward iteration can be implemented by using Gries-Mills<br>&gt;&gt; algorithm. This algorithm returns a new middle: a position where the first<br>&gt;&gt; element moved.<br>&gt;&gt;<br>&gt;&gt; template &lt;ForwardIterator I&gt;<br>&gt;&gt; I rotate(I f, I m, I l, std::forward_iterator_tag) {<br>&gt;&gt;     if (f == m) return l;<br>&gt;&gt;     if (m == l) return f;<br>&gt;&gt;     pair&lt;I, I&gt; p = swap_ranges(f, m, m, l);<br>&gt;&gt;     while (p.first != m || p.second != l) {<br>&gt;&gt;         if (p.second == l) {<br>&gt;&gt;             rotate_unguarded(p.first, m, l);<br>&gt;&gt;             return p.first;<br>&gt;&gt;         }<br>&gt;&gt;         f = m;<br>&gt;&gt;         m = p.second;<br>&gt;&gt;         p = swap_ranges(f, m, m, l);<br>&gt;&gt;     }<br>&gt;&gt;     return m;<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; 2. The random access iteration can be implement in this way:<br>&gt;&gt;<br>&gt;&gt; template &lt;RandomAccessIterator I&gt;<br>&gt;&gt; I rotate(I f, I m, I l, std::random_access_iterator_tag) {<br>&gt;&gt;     if (f == m) return l;<br>&gt;&gt;     if (m == l) return f;<br>&gt;&gt;     DifferenceType&lt;I&gt; cycles = gcd(m - f, l - m);<br>&gt;&gt;     rotate_transform&lt;I&gt; rotator(f, m, l);<br>&gt;&gt;     while (cycles-- &gt; 0) rotate_cycle_from(f + cycles, rotator);<br>&gt;&gt;     return rotator.m1;<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; 3. The bidirectional iteration can be implement by using reverse<br>&gt;&gt; algorithm in this way:<br>&gt;&gt;<br>&gt;&gt; template &lt;BidirectionalIterator I&gt;<br>&gt;&gt; I rotate(I f, I m, I l, bidirectional_iterator_tag) {<br>&gt;&gt;      reverse(f, m);<br>&gt;&gt;      reverse(m, l);<br>&gt;&gt;      pair&lt;I, I&gt; p = reverse_until(f, m, l);<br>&gt;&gt;      reverse(p.first, p.second);<br>&gt;&gt;      if (m == p.first) return p.second;<br>&gt;&gt;      return p.first;<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; We need to hide the complexity of these algorithms, therefore we need to<br>&gt;&gt; write a simple version that works for any type of iterations.<br>&gt;&gt;<br>&gt;&gt; Shall I create a formal PR to swift-evolution with a proposed solution<br>&gt;&gt; and detailed design?<br>&gt;&gt;<br>&gt;&gt; Sergey<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On 14 Dec 2015, at 08:51, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Dec 13, 2015, at 2:20 AM, Sergey Bolshedvorsky via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Hi everyone,<br>&gt;&gt;<br>&gt;&gt; I’ve selected a ticket SR-125 as my first task (<br>&gt;&gt; https://bugs.swift.org/browse/SR-125).<br>&gt;&gt;<br>&gt;&gt; I would like to propose an implementation of this method in Swift stdlib.<br>&gt;&gt;<br>&gt;&gt; std::rotate() method performs a left rotation on a range of elements.<br>&gt;&gt; C++ declaration is void rotate (ForwardIterator first, ForwardIterator<br>&gt;&gt; middle, ForwardIterator last)<br>&gt;&gt; Specifically, it swaps the elements in the range [first, last) in such a<br>&gt;&gt; way that the element middle becomes the first element of the new range and<br>&gt;&gt; middle - 1 becomes the last element.<br>&gt;&gt; A precondition of this function is that [first, n_first) and [middle,<br>&gt;&gt; last) are valid ranges.<br>&gt;&gt;<br>&gt;&gt; What are your thoughts?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; This is a really important algorithm, with applications even in GUI<br>&gt;&gt; programming (see slide<br>&gt;&gt; &lt;http://www.bfilipek.com/2014/12/top-5-beautiful-c-std-algorithms.html#slide&gt;<br>&gt;&gt;  and gather<br>&gt;&gt; &lt;http://www.bfilipek.com/2014/12/top-5-beautiful-c-std-algorithms.html#gather&gt;),<br>&gt;&gt; so I&#39;m really happy someone is taking it on. You&#39;ll need different<br>&gt;&gt; implementations depending on the index&#39;s protocol conformance<br>&gt;&gt; &lt;http://stackoverflow.com/questions/21160875/why-is-stdrotate-so-fast&gt;.<br>&gt;&gt; C++ implementations can get pretty sophisticated<br>&gt;&gt; &lt;http://llvm.org/viewvc/llvm-project/libcxx/trunk/include/algorithm?view=markup&amp;pathrev=251836&gt;.<br>&gt;&gt; Would you like additional thoughts (and if so, of what nature), or will<br>&gt;&gt; those do? ;-)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; -Dave<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/8543fb47/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Proposal: Implement a rotate algorithm, equivalent to std::rotate() in C++</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 14, 2015 at 07:00:00am</p></header><div class="content"><p>&gt; On Dec 14, 2015, at 3:59 AM, Sergey Bolshedvorsky &lt;sergey at bolshedvorsky.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; There are 3 main algorithms: forward iteration, random access iteration and bidirectional iteration. All excerpts from the book Alexander A. Stepanov. “From Mathematics to Generic Programming”, Chapters 11.3 - 11.6<br>&gt; <br>&gt; <br>&gt; 1. The forward iteration can be implemented by using Gries-Mills algorithm. This algorithm returns a new middle: a position where the first element moved. <br>&gt; <br>&gt; template &lt;ForwardIterator I&gt;<br>&gt; I rotate(I f, I m, I l, std::forward_iterator_tag) {<br>&gt;     if (f == m) return l;<br>&gt;     if (m == l) return f;<br>&gt;     pair&lt;I, I&gt; p = swap_ranges(f, m, m, l);<br>&gt;     while (p.first != m || p.second != l) {<br>&gt;         if (p.second == l) {<br>&gt;             rotate_unguarded(p.first, m, l);<br>&gt;             return p.first;<br>&gt;         }<br>&gt;         f = m;<br>&gt;         m = p.second;<br>&gt;         p = swap_ranges(f, m, m, l);<br>&gt;     }<br>&gt;     return m;<br>&gt; }<br>&gt; <br>&gt; <br>&gt; 2. The random access iteration can be implement in this way:<br>&gt; <br>&gt; template &lt;RandomAccessIterator I&gt;<br>&gt; I rotate(I f, I m, I l, std::random_access_iterator_tag) {<br>&gt;     if (f == m) return l;<br>&gt;     if (m == l) return f;<br>&gt;     DifferenceType&lt;I&gt; cycles = gcd(m - f, l - m);<br>&gt;     rotate_transform&lt;I&gt; rotator(f, m, l);<br>&gt;     while (cycles-- &gt; 0) rotate_cycle_from(f + cycles, rotator);<br>&gt;     return rotator.m1;<br>&gt; }<br>&gt; <br>&gt; <br>&gt; 3. The bidirectional iteration can be implement by using reverse algorithm in this way:<br>&gt; <br>&gt; template &lt;BidirectionalIterator I&gt;<br>&gt; I rotate(I f, I m, I l, bidirectional_iterator_tag) {<br>&gt;      reverse(f, m);<br>&gt;      reverse(m, l);<br>&gt;      pair&lt;I, I&gt; p = reverse_until(f, m, l);<br>&gt;      reverse(p.first, p.second);<br>&gt;      if (m == p.first) return p.second;<br>&gt;      return p.first;<br>&gt; }<br>&gt; <br>&gt; <br>&gt; We need to hide the complexity of these algorithms, therefore we need to write a simple version that works for any type of iterations.<br>&gt; <br>&gt; Shall I create a formal PR to swift-evolution with a proposed solution and detailed design?<br></p><p>Yes, please!<br></p><p>&gt; <br>&gt; Sergey<br>&gt; <br>&gt; <br>&gt;&gt; On 14 Dec 2015, at 08:51, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 13, 2015, at 2:20 AM, Sergey Bolshedvorsky via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi everyone,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’ve selected a ticket SR-125 as my first task (https://bugs.swift.org/browse/SR-125 &lt;https://bugs.swift.org/browse/SR-125&gt;).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would like to propose an implementation of this method in Swift stdlib.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; std::rotate() method performs a left rotation on a range of elements.<br>&gt;&gt;&gt; C++ declaration is void rotate (ForwardIterator first, ForwardIterator middle, ForwardIterator last)<br>&gt;&gt;&gt; Specifically, it swaps the elements in the range [first, last) in such a way that the element middle becomes the first element of the new range and middle - 1 becomes the last element.<br>&gt;&gt;&gt; A precondition of this function is that [first, n_first) and [middle, last) are valid ranges.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What are your thoughts?<br>&gt;&gt; <br>&gt;&gt; This is a really important algorithm, with applications even in GUI programming (see slide &lt;http://www.bfilipek.com/2014/12/top-5-beautiful-c-std-algorithms.html#slide&gt; and gather &lt;http://www.bfilipek.com/2014/12/top-5-beautiful-c-std-algorithms.html#gather&gt;), so I&#39;m really happy someone is taking it on. You&#39;ll need different implementations depending on the index&#39;s protocol conformance &lt;http://stackoverflow.com/questions/21160875/why-is-stdrotate-so-fast&gt;.  C++ implementations can get pretty sophisticated &lt;http://llvm.org/viewvc/llvm-project/libcxx/trunk/include/algorithm?view=markup&amp;pathrev=251836&gt;.  Would you like additional thoughts (and if so, of what nature), or will those do? ;-)<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -Dave<br>&gt; <br></p><p>-Dave<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/cb33f9b3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c56b98ce889653412aa0f3d6ab6a0263?s=50"></div><header><strong>Proposal: Implement a rotate algorithm, equivalent to std::rotate() in C++</strong> from <string>Sergey Bolshedvorsky</string> &lt;sergey at bolshedvorsky.com&gt;<p>December 28, 2015 at 08:00:00pm</p></header><div class="content"><p>Hi all,<br></p><p>I have created a PR with with a formal proposal for this feature: https://github.com/apple/swift-evolution/pull/77<br></p><p>What are your thoughts?<br></p><p>Sergey<br></p><p>&gt; On 14 Dec 2015, at 15:48, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 14, 2015, at 3:59 AM, Sergey Bolshedvorsky &lt;sergey at bolshedvorsky.com &lt;mailto:sergey at bolshedvorsky.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; There are 3 main algorithms: forward iteration, random access iteration and bidirectional iteration. All excerpts from the book Alexander A. Stepanov. “From Mathematics to Generic Programming”, Chapters 11.3 - 11.6<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; 1. The forward iteration can be implemented by using Gries-Mills algorithm. This algorithm returns a new middle: a position where the first element moved. <br>&gt;&gt; <br>&gt;&gt; template &lt;ForwardIterator I&gt;<br>&gt;&gt; I rotate(I f, I m, I l, std::forward_iterator_tag) {<br>&gt;&gt;     if (f == m) return l;<br>&gt;&gt;     if (m == l) return f;<br>&gt;&gt;     pair&lt;I, I&gt; p = swap_ranges(f, m, m, l);<br>&gt;&gt;     while (p.first != m || p.second != l) {<br>&gt;&gt;         if (p.second == l) {<br>&gt;&gt;             rotate_unguarded(p.first, m, l);<br>&gt;&gt;             return p.first;<br>&gt;&gt;         }<br>&gt;&gt;         f = m;<br>&gt;&gt;         m = p.second;<br>&gt;&gt;         p = swap_ranges(f, m, m, l);<br>&gt;&gt;     }<br>&gt;&gt;     return m;<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; 2. The random access iteration can be implement in this way:<br>&gt;&gt; <br>&gt;&gt; template &lt;RandomAccessIterator I&gt;<br>&gt;&gt; I rotate(I f, I m, I l, std::random_access_iterator_tag) {<br>&gt;&gt;     if (f == m) return l;<br>&gt;&gt;     if (m == l) return f;<br>&gt;&gt;     DifferenceType&lt;I&gt; cycles = gcd(m - f, l - m);<br>&gt;&gt;     rotate_transform&lt;I&gt; rotator(f, m, l);<br>&gt;&gt;     while (cycles-- &gt; 0) rotate_cycle_from(f + cycles, rotator);<br>&gt;&gt;     return rotator.m1;<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; 3. The bidirectional iteration can be implement by using reverse algorithm in this way:<br>&gt;&gt; <br>&gt;&gt; template &lt;BidirectionalIterator I&gt;<br>&gt;&gt; I rotate(I f, I m, I l, bidirectional_iterator_tag) {<br>&gt;&gt;      reverse(f, m);<br>&gt;&gt;      reverse(m, l);<br>&gt;&gt;      pair&lt;I, I&gt; p = reverse_until(f, m, l);<br>&gt;&gt;      reverse(p.first, p.second);<br>&gt;&gt;      if (m == p.first) return p.second;<br>&gt;&gt;      return p.first;<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; We need to hide the complexity of these algorithms, therefore we need to write a simple version that works for any type of iterations.<br>&gt;&gt; <br>&gt;&gt; Shall I create a formal PR to swift-evolution with a proposed solution and detailed design?<br>&gt; <br>&gt; Yes, please!<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Sergey<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 14 Dec 2015, at 08:51, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 13, 2015, at 2:20 AM, Sergey Bolshedvorsky via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi everyone,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’ve selected a ticket SR-125 as my first task (https://bugs.swift.org/browse/SR-125 &lt;https://bugs.swift.org/browse/SR-125&gt;).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I would like to propose an implementation of this method in Swift stdlib.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; std::rotate() method performs a left rotation on a range of elements.<br>&gt;&gt;&gt;&gt; C++ declaration is void rotate (ForwardIterator first, ForwardIterator middle, ForwardIterator last)<br>&gt;&gt;&gt;&gt; Specifically, it swaps the elements in the range [first, last) in such a way that the element middle becomes the first element of the new range and middle - 1 becomes the last element.<br>&gt;&gt;&gt;&gt; A precondition of this function is that [first, n_first) and [middle, last) are valid ranges.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What are your thoughts?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a really important algorithm, with applications even in GUI programming (see slide &lt;http://www.bfilipek.com/2014/12/top-5-beautiful-c-std-algorithms.html#slide&gt; and gather &lt;http://www.bfilipek.com/2014/12/top-5-beautiful-c-std-algorithms.html#gather&gt;), so I&#39;m really happy someone is taking it on. You&#39;ll need different implementations depending on the index&#39;s protocol conformance &lt;http://stackoverflow.com/questions/21160875/why-is-stdrotate-so-fast&gt;.  C++ implementations can get pretty sophisticated &lt;http://llvm.org/viewvc/llvm-project/libcxx/trunk/include/algorithm?view=markup&amp;pathrev=251836&gt;.  Would you like additional thoughts (and if so, of what nature), or will those do? ;-)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Dave<br>&gt;&gt; <br>&gt; <br>&gt; -Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151228/8b1a194c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Proposal: Implement a rotate algorithm, equivalent to std::rotate() in C++</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December 29, 2015 at 08:00:00am</p></header><div class="content"><p>On Mon, Dec 28, 2015 at 10:29 PM, Sergey Bolshedvorsky via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hi all,<br>&gt;<br>&gt; I have created a PR with with a formal proposal for this feature:<br>&gt; https://github.com/apple/swift-evolution/pull/77<br>&gt;<br>&gt; What are your thoughts?<br>&gt;<br></p><p>Thank you for the proposal!<br></p><p>What jumps at me immediately is that the APIs are using integers to specify<br>positions in the collection.  I think they should be using collection&#39;s<br>indices instead.<br></p><p>I&#39;m unsure why we need `first` and `last` -- shouldn&#39;t the API operate on<br>the whole collection?  We have slices to operate on subsequences.<br></p><p>It is interesting that you are proposing that the new algorithms should<br>produce lazy views.  I agree this is consistent with the rest of the<br>library, but I&#39;m worried about the performance implications.  Have you<br>thought about this?  One point to keep in mind is that you can implement<br>the `_copyToNativeArrayBuffer()` and `_initializeTo()` entry points in all<br>new lazy collections, using the optimal eager algorithm.  This way,<br>converting them to arrays will be fast.<br></p><p>Another point to consider is how the call site of these functions looks<br>like:<br></p><p>collection.rotate(10, middle: 20, last: 30)<br></p><p>The first number hangs in the air, it is unclear what its meaning is.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151229/5c7ad8fb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c56b98ce889653412aa0f3d6ab6a0263?s=50"></div><header><strong>Proposal: Implement a rotate algorithm, equivalent to std::rotate() in C++</strong> from <string>Sergey Bolshedvorsky</string> &lt;sergey at bolshedvorsky.com&gt;<p>December 29, 2015 at 03:00:00pm</p></header><div class="content"><p>Hi Dmitri,<br></p><p>Thank you for your feedback! I’ve updated a proposal based on your comments: https://github.com/apple/swift-evolution/pull/77 &lt;https://github.com/apple/swift-evolution/pull/77&gt;<br></p><p>&gt; What jumps at me immediately is that the APIs are using integers to specify positions in the collection.  I think they should be using collection&#39;s indices instead.<br>Yes you are right, the APIs should use collection indexes. <br></p><p>&gt; I&#39;m unsure why we need `first` and `last` -- shouldn&#39;t the API operate on the whole collection?  We have slices to operate on subsequences.<br></p><p>The C++ implementation allows to rotate all elements of collection or only some of them. A precondition of this function is that<br>0 &lt;= first &lt;= middle &lt;= last &lt; count<br></p><p>&gt; Another point to consider is how the call site of these functions looks like:<br></p><p> I’ve added 2 API usage examples to PR:<br></p><p>Example of rotating all elements of the collection:<br></p><p>let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]<br>let rotated = numbers.rotateFrom(0, middle: 3, last: 8)<br>// rotated contains [4, 5, 6, 7, 8, 9, 1, 2, 3]<br></p><p>Example of rotating some elements of the collection:<br></p><p>let numbers = [10, 12, 13, 11, 15, 14]<br>let rotated = numbers.rotateFrom(1, middle: 3, last: 4)<br>// rotated contains [10, 11, 12, 13, 15, 14]<br></p><p><br>&gt; It is interesting that you are proposing that the new algorithms should produce lazy views.  I agree this is consistent with the rest of the library, but I&#39;m worried about the performance implications.  Have you thought about this?  One point to keep in mind is that you can implement the `_copyToNativeArrayBuffer()` and `_initializeTo()` entry points in all new lazy collections, using the optimal eager algorithm.  This way, converting them to arrays will be fast.<br>Thanks for pointing out the performance issue with lazy views. I will draft the implementation of algorithms for regular collections at first and then I will think how it can be reused with lazy views.<br></p><p>Sergey<br></p><p><br></p><p>&gt; On 29 Dec 2015, at 06:38, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Mon, Dec 28, 2015 at 10:29 PM, Sergey Bolshedvorsky via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Hi all,<br>&gt; <br>&gt; I have created a PR with with a formal proposal for this feature: https://github.com/apple/swift-evolution/pull/77 &lt;https://github.com/apple/swift-evolution/pull/77&gt;<br>&gt; <br>&gt; What are your thoughts?<br>&gt; <br>&gt; Thank you for the proposal!<br>&gt; <br>&gt; What jumps at me immediately is that the APIs are using integers to specify positions in the collection.  I think they should be using collection&#39;s indices instead.<br>&gt; <br>&gt; I&#39;m unsure why we need `first` and `last` -- shouldn&#39;t the API operate on the whole collection?  We have slices to operate on subsequences.<br>&gt; <br>&gt; It is interesting that you are proposing that the new algorithms should produce lazy views.  I agree this is consistent with the rest of the library, but I&#39;m worried about the performance implications.  Have you thought about this?  One point to keep in mind is that you can implement the `_copyToNativeArrayBuffer()` and `_initializeTo()` entry points in all new lazy collections, using the optimal eager algorithm.  This way, converting them to arrays will be fast.<br>&gt; <br>&gt; Another point to consider is how the call site of these functions looks like:<br>&gt; <br>&gt; collection.rotate(10, middle: 20, last: 30)<br>&gt; <br>&gt; The first number hangs in the air, it is unclear what its meaning is.<br>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt;*/<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151229/1b47c46f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Proposal: Implement a rotate algorithm, equivalent to std::rotate() in C++</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December 29, 2015 at 11:00:00pm</p></header><div class="content"><p>On Tue, Dec 29, 2015 at 5:30 PM, Sergey Bolshedvorsky<br>&lt;sergey at bolshedvorsky.com&gt; wrote:<br>&gt; Hi Dmitri,<br>&gt;<br>&gt; Thank you for your feedback! I’ve updated a proposal based on your comments:<br>&gt; https://github.com/apple/swift-evolution/pull/77<br>&gt;<br>&gt; What jumps at me immediately is that the APIs are using integers to specify<br>&gt; positions in the collection.  I think they should be using collection&#39;s<br>&gt; indices instead.<br>&gt;<br>&gt; Yes you are right, the APIs should use collection indexes.<br>&gt;<br>&gt; I&#39;m unsure why we need `first` and `last` -- shouldn&#39;t the API operate on<br>&gt; the whole collection?  We have slices to operate on subsequences.<br>&gt;<br>&gt; The C++ implementation allows to rotate all elements of collection or only<br>&gt; some of them. A precondition of this function is that<br>&gt; 0 &lt;= first &lt;= middle &lt;= last &lt; count<br></p><p>Right, but this question is relevant for every algorithm (sort,<br>partition, etc.).  That&#39;s why we have writeback through slices:<br></p><p>myArray[first..&lt;last].sortInPlace()<br></p><p>instead of adding `first` and `last` to every algorithm.<br></p><p>Dmitri<br></p><p>&gt; Another point to consider is how the call site of these functions looks<br>&gt; like:<br>&gt;<br>&gt;<br>&gt;  I’ve added 2 API usage examples to PR:<br>&gt;<br>&gt; Example of rotating all elements of the collection:<br>&gt;<br>&gt; let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]<br>&gt; let rotated = numbers.rotateFrom(0, middle: 3, last: 8)<br>&gt; // rotated contains [4, 5, 6, 7, 8, 9, 1, 2, 3]<br>&gt;<br>&gt; Example of rotating some elements of the collection:<br>&gt;<br>&gt; let numbers = [10, 12, 13, 11, 15, 14]<br>&gt; let rotated = numbers.rotateFrom(1, middle: 3, last: 4)<br>&gt; // rotated contains [10, 11, 12, 13, 15, 14]<br>&gt;<br>&gt;<br>&gt; It is interesting that you are proposing that the new algorithms should<br>&gt; produce lazy views.  I agree this is consistent with the rest of the<br>&gt; library, but I&#39;m worried about the performance implications.  Have you<br>&gt; thought about this?  One point to keep in mind is that you can implement the<br>&gt; `_copyToNativeArrayBuffer()` and `_initializeTo()` entry points in all new<br>&gt; lazy collections, using the optimal eager algorithm.  This way, converting<br>&gt; them to arrays will be fast.<br>&gt;<br>&gt; Thanks for pointing out the performance issue with lazy views. I will draft<br>&gt; the implementation of algorithms for regular collections at first and then I<br>&gt; will think how it can be reused with lazy views.<br>&gt;<br>&gt; Sergey<br>&gt;<br>&gt;<br>&gt;<br>&gt; On 29 Dec 2015, at 06:38, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Mon, Dec 28, 2015 at 10:29 PM, Sergey Bolshedvorsky via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Hi all,<br>&gt;&gt;<br>&gt;&gt; I have created a PR with with a formal proposal for this feature:<br>&gt;&gt; https://github.com/apple/swift-evolution/pull/77<br>&gt;&gt;<br>&gt;&gt; What are your thoughts?<br>&gt;<br>&gt;<br>&gt; Thank you for the proposal!<br>&gt;<br>&gt; What jumps at me immediately is that the APIs are using integers to specify<br>&gt; positions in the collection.  I think they should be using collection&#39;s<br>&gt; indices instead.<br>&gt;<br>&gt; I&#39;m unsure why we need `first` and `last` -- shouldn&#39;t the API operate on<br>&gt; the whole collection?  We have slices to operate on subsequences.<br>&gt;<br>&gt; It is interesting that you are proposing that the new algorithms should<br>&gt; produce lazy views.  I agree this is consistent with the rest of the<br>&gt; library, but I&#39;m worried about the performance implications.  Have you<br>&gt; thought about this?  One point to keep in mind is that you can implement the<br>&gt; `_copyToNativeArrayBuffer()` and `_initializeTo()` entry points in all new<br>&gt; lazy collections, using the optimal eager algorithm.  This way, converting<br>&gt; them to arrays will be fast.<br>&gt;<br>&gt; Another point to consider is how the call site of these functions looks<br>&gt; like:<br>&gt;<br>&gt; collection.rotate(10, middle: 20, last: 30)<br>&gt;<br>&gt; The first number hangs in the air, it is unclear what its meaning is.<br>&gt;<br>&gt; Dmitri<br>&gt;<br>&gt; --<br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;<br>&gt;<br></p><p><br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Proposal: Implement a rotate algorithm, equivalent to std::rotate() in C++</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 29, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; On Dec 29, 2015, at 7:30 AM, Sergey Bolshedvorsky &lt;sergey at bolshedvorsky.com&gt; wrote:<br>&gt; <br>&gt; Hi Dmitri,<br>&gt; <br>&gt; Thank you for your feedback! I’ve updated a proposal based on your comments: https://github.com/apple/swift-evolution/pull/77 &lt;https://github.com/apple/swift-evolution/pull/77&gt;<br>&gt; <br>&gt;&gt; What jumps at me immediately is that the APIs are using integers to specify positions in the collection.  I think they should be using collection&#39;s indices instead.<br>&gt; Yes you are right, the APIs should use collection indexes. <br>&gt; <br>&gt;&gt; I&#39;m unsure why we need `first` and `last` -- shouldn&#39;t the API operate on the whole collection?  We have slices to operate on subsequences.<br>&gt; <br>&gt; The C++ implementation allows to rotate all elements of collection or only some of them. A precondition of this function is that<br>&gt; 0 &lt;= first &lt;= middle &lt;= last &lt; count<br></p><p>This should be handled by slicing and rotating a slice. In-place slice mutation is not yet efficient, but we have an open radar asking for the necessary core language feature to make it so (non-pointer proxy addressors).<br></p><p>&gt;&gt; Another point to consider is how the call site of these functions looks like:<br>&gt; <br>&gt;  I’ve added 2 API usage examples to PR:<br>&gt; <br>&gt; Example of rotating all elements of the collection:<br>&gt; <br>&gt; let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]<br>&gt; let rotated = numbers.rotateFrom(0, middle: 3, last: 8)<br>&gt; // rotated contains [4, 5, 6, 7, 8, 9, 1, 2, 3]<br></p><p>There should be an in-place rotation algorithm as well, and for both varieties we should have a way of getting back the index of the old start element in the rotated collection.  I would start with the in-place algorithms are likely more of a challenge.<br></p><p>&gt; Example of rotating some elements of the collection:<br>&gt; <br>&gt; let numbers = [10, 12, 13, 11, 15, 14]<br>&gt; let rotated = numbers.rotateFrom(1, middle: 3, last: 4)<br>&gt; // rotated contains [10, 11, 12, 13, 15, 14]<br>&gt; <br>&gt; <br>&gt;&gt; It is interesting that you are proposing that the new algorithms should produce lazy views.  I agree this is consistent with the rest of the library, but I&#39;m worried about the performance implications.  Have you thought about this?  One point to keep in mind is that you can implement the `_copyToNativeArrayBuffer()` and `_initializeTo()` entry points in all new lazy collections, using the optimal eager algorithm.  This way, converting them to arrays will be fast.<br>&gt; Thanks for pointing out the performance issue with lazy views. I will draft the implementation of algorithms for regular collections at first and then I will think how it can be reused with lazy views.<br></p><p>Err, I don’t think Dmitri pointed anything out; he merely asked you to consider performance.  But I must admit that I don’t understand the concern.  Many of our eager algorithms for are implemented by copying lazy views to an array.<br></p><p>Personally, I would implement a rotate as something like:<br></p><p>extension CollectionType {<br>  func rotatedAt(midPoint: Index) -&gt; /* Return type */{<br>    let result = c.lazy.flatten([ c[midPoint..&lt;c.endIndex], c[startIndex..&lt;midPoint] ])<br>    // or, for optimization, c.flatten(CollectionOfTwo(c[midPoint..&lt;c.endIndex], c[startIndex..&lt;midPoint] )) <br>    return (result, calculateIndexOfMidPoint())<br>  }<br>}  <br></p><p>calculateIndexOfMidPoint can start out being O(N) if necessary; you should be able to add enough API to the LazyFlattenCollection that you can synthesize the position more efficiently though.<br></p><p>&gt; <br>&gt; Sergey<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On 29 Dec 2015, at 06:38, Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Mon, Dec 28, 2015 at 10:29 PM, Sergey Bolshedvorsky via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; I have created a PR with with a formal proposal for this feature: https://github.com/apple/swift-evolution/pull/77 &lt;https://github.com/apple/swift-evolution/pull/77&gt;<br>&gt;&gt; <br>&gt;&gt; What are your thoughts?<br>&gt;&gt; <br>&gt;&gt; Thank you for the proposal!<br>&gt;&gt; <br>&gt;&gt; What jumps at me immediately is that the APIs are using integers to specify positions in the collection.  I think they should be using collection&#39;s indices instead.<br>&gt;&gt; <br>&gt;&gt; I&#39;m unsure why we need `first` and `last` -- shouldn&#39;t the API operate on the whole collection?  We have slices to operate on subsequences.<br>&gt;&gt; <br>&gt;&gt; It is interesting that you are proposing that the new algorithms should produce lazy views.  I agree this is consistent with the rest of the library, but I&#39;m worried about the performance implications.  Have you thought about this?  One point to keep in mind is that you can implement the `_copyToNativeArrayBuffer()` and `_initializeTo()` entry points in all new lazy collections, using the optimal eager algorithm.  This way, converting them to arrays will be fast.<br>&gt;&gt; <br>&gt;&gt; Another point to consider is how the call site of these functions looks like:<br>&gt;&gt; <br>&gt;&gt; collection.rotate(10, middle: 20, last: 30)<br>&gt;&gt; <br>&gt;&gt; The first number hangs in the air, it is unclear what its meaning is.<br>&gt;&gt; <br>&gt;&gt; Dmitri<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt;&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt;*/<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151229/036b4bca/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c56b98ce889653412aa0f3d6ab6a0263?s=50"></div><header><strong>Proposal: Implement a rotate algorithm, equivalent to std::rotate() in C++</strong> from <string>Sergey Bolshedvorsky</string> &lt;sergey at bolshedvorsky.com&gt;<p>January  1, 2016 at 10:00:00pm</p></header><div class="content"><p>Hi All,<br></p><p>I would like to clarify the API endpoints based on your feedback. Am I missing something?<br></p><p>extension CollectionType {<br>    @warn_unused_result<br>    public func rotatedAt(middle: Index) /* -&gt; Return Type */ {<br>        // This should be handled by slicing and rotating a slice.<br>        // let result = c.flatten(CollectionOfTwo(c[midPoint..&lt;c.endIndex], c[startIndex..&lt;midPoint] ))<br>        // return (result, calculateIndexOfMidPoint())<br>    }<br>}<br></p><p>extension CollectionType where Index : ForwardIndexType {<br>    @warn_unused_result<br>    public mutating func rotatedInPlace(middle: Index) -&gt; Index {<br>        // Implement ForwardIndexType algorithm<br>	// Return the index of the old start element<br>    }<br>}<br></p><p>extension CollectionType where Index : BidirectionalIndexType {<br>    @warn_unused_result<br>    public mutating func rotatedInPlace(middle: Index) -&gt; Index {<br>        // Implement BidirectionalIndexType algorithm<br>	// Return the index of the old start element<br>    }<br>}<br></p><p>extension CollectionType where Index : RandomAccessIndexType {<br>    @warn_unused_result<br>    public mutating func rotatedInPlace(middle: Index) -&gt; Index {<br>        // Implement RandomAccessIndexType algorithm<br>	// Return the index of the old start element<br>    }<br>}<br></p><p>extension LazyCollectionType {<br>    @warn_unused_result<br>    public func rotatedAt(middle: Index) /* -&gt; Return Type */ {<br>        // Many of our eager algorithms for are implemented by copying lazy views to an array.<br>        // calculateIndexOfMidPoint can start out being O(N) if necessary; you should be able to add enough<br>        // API to the LazyFlattenCollection that you can synthesize the position more efficiently though.<br>    }<br>}<br></p><p>Sergey<br></p><p><br>&gt; On 29 Dec 2015, at 23:27, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 29, 2015, at 7:30 AM, Sergey Bolshedvorsky &lt;sergey at bolshedvorsky.com &lt;mailto:sergey at bolshedvorsky.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi Dmitri,<br>&gt;&gt; <br>&gt;&gt; Thank you for your feedback! I’ve updated a proposal based on your comments: https://github.com/apple/swift-evolution/pull/77 &lt;https://github.com/apple/swift-evolution/pull/77&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; What jumps at me immediately is that the APIs are using integers to specify positions in the collection.  I think they should be using collection&#39;s indices instead.<br>&gt;&gt; Yes you are right, the APIs should use collection indexes. <br>&gt;&gt; <br>&gt;&gt;&gt; I&#39;m unsure why we need `first` and `last` -- shouldn&#39;t the API operate on the whole collection?  We have slices to operate on subsequences.<br>&gt;&gt; <br>&gt;&gt; The C++ implementation allows to rotate all elements of collection or only some of them. A precondition of this function is that<br>&gt;&gt; 0 &lt;= first &lt;= middle &lt;= last &lt; count<br>&gt; <br>&gt; This should be handled by slicing and rotating a slice. In-place slice mutation is not yet efficient, but we have an open radar asking for the necessary core language feature to make it so (non-pointer proxy addressors).<br>&gt; <br>&gt;&gt;&gt; Another point to consider is how the call site of these functions looks like:<br>&gt;&gt; <br>&gt;&gt;  I’ve added 2 API usage examples to PR:<br>&gt;&gt; <br>&gt;&gt; Example of rotating all elements of the collection:<br>&gt;&gt; <br>&gt;&gt; let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]<br>&gt;&gt; let rotated = numbers.rotateFrom(0, middle: 3, last: 8)<br>&gt;&gt; // rotated contains [4, 5, 6, 7, 8, 9, 1, 2, 3]<br>&gt; <br>&gt; There should be an in-place rotation algorithm as well, and for both varieties we should have a way of getting back the index of the old start element in the rotated collection.  I would start with the in-place algorithms are likely more of a challenge.<br>&gt; <br>&gt;&gt; Example of rotating some elements of the collection:<br>&gt;&gt; <br>&gt;&gt; let numbers = [10, 12, 13, 11, 15, 14]<br>&gt;&gt; let rotated = numbers.rotateFrom(1, middle: 3, last: 4)<br>&gt;&gt; // rotated contains [10, 11, 12, 13, 15, 14]<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; It is interesting that you are proposing that the new algorithms should produce lazy views.  I agree this is consistent with the rest of the library, but I&#39;m worried about the performance implications.  Have you thought about this?  One point to keep in mind is that you can implement the `_copyToNativeArrayBuffer()` and `_initializeTo()` entry points in all new lazy collections, using the optimal eager algorithm.  This way, converting them to arrays will be fast.<br>&gt;&gt; Thanks for pointing out the performance issue with lazy views. I will draft the implementation of algorithms for regular collections at first and then I will think how it can be reused with lazy views.<br>&gt; <br>&gt; Err, I don’t think Dmitri pointed anything out; he merely asked you to consider performance.  But I must admit that I don’t understand the concern.  Many of our eager algorithms for are implemented by copying lazy views to an array.<br>&gt; <br>&gt; Personally, I would implement a rotate as something like:<br>&gt; <br>&gt; extension CollectionType {<br>&gt;   func rotatedAt(midPoint: Index) -&gt; /* Return type */{<br>&gt;     let result = c.lazy.flatten([ c[midPoint..&lt;c.endIndex], c[startIndex..&lt;midPoint] ])<br>&gt;     // or, for optimization, c.flatten(CollectionOfTwo(c[midPoint..&lt;c.endIndex], c[startIndex..&lt;midPoint] )) <br>&gt;     return (result, calculateIndexOfMidPoint())<br>&gt;   }<br>&gt; }  <br>&gt; <br>&gt; calculateIndexOfMidPoint can start out being O(N) if necessary; you should be able to add enough API to the LazyFlattenCollection that you can synthesize the position more efficiently though.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Sergey<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 29 Dec 2015, at 06:38, Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Mon, Dec 28, 2015 at 10:29 PM, Sergey Bolshedvorsky via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I have created a PR with with a formal proposal for this feature: https://github.com/apple/swift-evolution/pull/77 &lt;https://github.com/apple/swift-evolution/pull/77&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What are your thoughts?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thank you for the proposal!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What jumps at me immediately is that the APIs are using integers to specify positions in the collection.  I think they should be using collection&#39;s indices instead.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m unsure why we need `first` and `last` -- shouldn&#39;t the API operate on the whole collection?  We have slices to operate on subsequences.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It is interesting that you are proposing that the new algorithms should produce lazy views.  I agree this is consistent with the rest of the library, but I&#39;m worried about the performance implications.  Have you thought about this?  One point to keep in mind is that you can implement the `_copyToNativeArrayBuffer()` and `_initializeTo()` entry points in all new lazy collections, using the optimal eager algorithm.  This way, converting them to arrays will be fast.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another point to consider is how the call site of these functions looks like:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; collection.rotate(10, middle: 20, last: 30)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The first number hangs in the air, it is unclear what its meaning is.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Dmitri<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt;&gt;&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt;*/<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160101/064d7b3f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Proposal: Implement a rotate algorithm, equivalent to std::rotate() in C++</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>January  1, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jan 1, 2016, at 2:28 PM, Sergey Bolshedvorsky &lt;sergey at bolshedvorsky.com&gt; wrote:<br>&gt; <br>&gt; Hi All,<br>&gt; <br>&gt; I would like to clarify the API endpoints based on your feedback. Am I missing something?<br>&gt; <br>&gt; extension CollectionType {<br>&gt;     @warn_unused_result<br>&gt;     public func rotatedAt(middle: Index) /* -&gt; Return Type */ {<br></p><p>Now that I look, “rotatingFirstFrom” might be better, since it makes it very clear what middle does. <br></p><p>&gt;         // This should be handled by slicing and rotating a slice.<br>&gt;         // let result = c.flatten(CollectionOfTwo(c[midPoint..&lt;c.endIndex], c[startIndex..&lt;midPoint] ))<br>&gt;         // return (result, calculateIndexOfMidPoint())<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; extension CollectionType where Index : ForwardIndexType {<br>&gt;     @warn_unused_result<br>&gt;     public mutating func rotatedInPlace(middle: Index) -&gt; Index {<br></p><p>These should be called “rotateFirstFrom.”  The API guidelines are moving toward dropping the InPlace convention where possible.<br></p><p>&gt;         // Implement ForwardIndexType algorithm<br>&gt; 	// Return the index of the old start element<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; extension CollectionType where Index : BidirectionalIndexType {<br>&gt;     @warn_unused_result<br>&gt;     public mutating func rotatedInPlace(middle: Index) -&gt; Index {<br>&gt;         // Implement BidirectionalIndexType algorithm<br>&gt; 	// Return the index of the old start element<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; extension CollectionType where Index : RandomAccessIndexType {<br>&gt;     @warn_unused_result<br>&gt;     public mutating func rotatedInPlace(middle: Index) -&gt; Index {<br>&gt;         // Implement RandomAccessIndexType algorithm<br>&gt; 	// Return the index of the old start element<br>&gt;     }<br>&gt; }<br></p><p>I have heard one C++ stdlib developer argue that only two of these algorithms are needed.  I don’t know whether to believe him, but it might be worth doing some benchmarks.<br> <br>&gt; extension LazyCollectionType {<br>&gt;     @warn_unused_result<br>&gt;     public func rotatedAt(middle: Index) /* -&gt; Return Type */ {<br>&gt;         // Many of our eager algorithms for are implemented by copying lazy views to an array.<br>&gt;         // calculateIndexOfMidPoint can start out being O(N) if necessary; you should be able to add enough<br>&gt;         // API to the LazyFlattenCollection that you can synthesize the position more efficiently though.<br>&gt;     }<br>&gt; }<br></p><p>I think maybe you want another version for bidirectional collections?<br></p><p>&gt; Sergey<br>&gt; <br>&gt; <br>&gt;&gt; On 29 Dec 2015, at 23:27, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 29, 2015, at 7:30 AM, Sergey Bolshedvorsky &lt;sergey at bolshedvorsky.com &lt;mailto:sergey at bolshedvorsky.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi Dmitri,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thank you for your feedback! I’ve updated a proposal based on your comments: https://github.com/apple/swift-evolution/pull/77 &lt;https://github.com/apple/swift-evolution/pull/77&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What jumps at me immediately is that the APIs are using integers to specify positions in the collection.  I think they should be using collection&#39;s indices instead.<br>&gt;&gt;&gt; Yes you are right, the APIs should use collection indexes. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m unsure why we need `first` and `last` -- shouldn&#39;t the API operate on the whole collection?  We have slices to operate on subsequences.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The C++ implementation allows to rotate all elements of collection or only some of them. A precondition of this function is that<br>&gt;&gt;&gt; 0 &lt;= first &lt;= middle &lt;= last &lt; count<br>&gt;&gt; <br>&gt;&gt; This should be handled by slicing and rotating a slice. In-place slice mutation is not yet efficient, but we have an open radar asking for the necessary core language feature to make it so (non-pointer proxy addressors).<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; Another point to consider is how the call site of these functions looks like:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  I’ve added 2 API usage examples to PR:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Example of rotating all elements of the collection:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]<br>&gt;&gt;&gt; let rotated = numbers.rotateFrom(0, middle: 3, last: 8)<br>&gt;&gt;&gt; // rotated contains [4, 5, 6, 7, 8, 9, 1, 2, 3]<br>&gt;&gt; <br>&gt;&gt; There should be an in-place rotation algorithm as well, and for both varieties we should have a way of getting back the index of the old start element in the rotated collection.  I would start with the in-place algorithms are likely more of a challenge.<br>&gt;&gt; <br>&gt;&gt;&gt; Example of rotating some elements of the collection:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let numbers = [10, 12, 13, 11, 15, 14]<br>&gt;&gt;&gt; let rotated = numbers.rotateFrom(1, middle: 3, last: 4)<br>&gt;&gt;&gt; // rotated contains [10, 11, 12, 13, 15, 14]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It is interesting that you are proposing that the new algorithms should produce lazy views.  I agree this is consistent with the rest of the library, but I&#39;m worried about the performance implications.  Have you thought about this?  One point to keep in mind is that you can implement the `_copyToNativeArrayBuffer()` and `_initializeTo()` entry points in all new lazy collections, using the optimal eager algorithm.  This way, converting them to arrays will be fast.<br>&gt;&gt;&gt; Thanks for pointing out the performance issue with lazy views. I will draft the implementation of algorithms for regular collections at first and then I will think how it can be reused with lazy views.<br>&gt;&gt; <br>&gt;&gt; Err, I don’t think Dmitri pointed anything out; he merely asked you to consider performance.  But I must admit that I don’t understand the concern.  Many of our eager algorithms for are implemented by copying lazy views to an array.<br>&gt;&gt; <br>&gt;&gt; Personally, I would implement a rotate as something like:<br>&gt;&gt; <br>&gt;&gt; extension CollectionType {<br>&gt;&gt;   func rotatedAt(midPoint: Index) -&gt; /* Return type */{<br>&gt;&gt;     let result = c.lazy.flatten([ c[midPoint..&lt;c.endIndex], c[startIndex..&lt;midPoint] ])<br>&gt;&gt;     // or, for optimization, c.flatten(CollectionOfTwo(c[midPoint..&lt;c.endIndex], c[startIndex..&lt;midPoint] )) <br>&gt;&gt;     return (result, calculateIndexOfMidPoint())<br>&gt;&gt;   }<br>&gt;&gt; }  <br>&gt;&gt; <br>&gt;&gt; calculateIndexOfMidPoint can start out being O(N) if necessary; you should be able to add enough API to the LazyFlattenCollection that you can synthesize the position more efficiently though.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sergey<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 29 Dec 2015, at 06:38, Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mon, Dec 28, 2015 at 10:29 PM, Sergey Bolshedvorsky via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I have created a PR with with a formal proposal for this feature: https://github.com/apple/swift-evolution/pull/77 &lt;https://github.com/apple/swift-evolution/pull/77&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What are your thoughts?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thank you for the proposal!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What jumps at me immediately is that the APIs are using integers to specify positions in the collection.  I think they should be using collection&#39;s indices instead.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m unsure why we need `first` and `last` -- shouldn&#39;t the API operate on the whole collection?  We have slices to operate on subsequences.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It is interesting that you are proposing that the new algorithms should produce lazy views.  I agree this is consistent with the rest of the library, but I&#39;m worried about the performance implications.  Have you thought about this?  One point to keep in mind is that you can implement the `_copyToNativeArrayBuffer()` and `_initializeTo()` entry points in all new lazy collections, using the optimal eager algorithm.  This way, converting them to arrays will be fast.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Another point to consider is how the call site of these functions looks like:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; collection.rotate(10, middle: 20, last: 30)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The first number hangs in the air, it is unclear what its meaning is.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Dmitri<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt;&gt;&gt;&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt;*/<br>&gt; <br></p><p>-Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160101/1d33b6d3/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
