<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Review] Add a Lazy flatMap for Sequences of Optionals</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>December 15, 2015 at 01:00:00pm</p></header><div class="content"><p>Hello Swift community,<br></p><p>The review of “Add a Lazy flatMap for Sequences of Optionals” begins now and runs through Thursday, December 17th. The proposal is available here:<br></p><p>	https://github.com/apple/swift-evolution/blob/master/proposals/0008-lazy-flatmap-for-optionals.md<br></p><p>Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br></p><p>	https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>or, if you would like to keep your feedback private, directly to the review manager.<br></p><p>What goes into a review?<br></p><p>The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br></p><p>	* What is your evaluation of the proposal?<br>	* Is the problem being addressed significant enough to warrant a change to Swift?<br>	* Does this proposal fit well with the feel and direction of Swift?<br>	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>More information about the Swift evolution process is available at<br></p><p>	https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br></p><p>	Cheers,<br>	Doug Gregor<br>	Review Manager<br></p><p><br>	<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution-announce/attachments/20151215/9e18edd3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Review] Add a Lazy flatMap for Sequences of Optionals</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 15, 2015 at 06:00:00pm</p></header><div class="content"><p>First, I’d like to thank Oisin &lt;https://github.com/oisdk&gt; for his proposal.  It’s great to see people filling in gaps.<br></p><p>&gt; 	* What is your evaluation of the proposal?<br></p><p>The basic idea is solid and obviously appropriate.  I have some quibbles with the proposed solution.<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes; it’s a non-uniformity, nonuniformities create complexity for users.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes.<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>A quick reading, but I’m deeply familiar with the domain, having written the lazy facilities we have in the stdlib.<br></p><p>I don’t see why the proposal states, “Optional probably wouldn&#39;t have a BidirectionalIndexType“.  It seems to me that as a collection, an optional’s index should be random access, just like CollectionOfOne’s.<br></p><p>I’d like to suggest a different implementation approach that not only handles the bidirectional issue but also probably reduces the amount of code involved: create a generic CollectionOfZeroOrOne&lt;T&gt; that wraps a T?, and implement the x.flatmap(f) where f returns an optional as x.flatmap { CollectionOfZeroOrOne(f($0)) }<br></p><p>What do you think?<br></p><p>-Dave<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/9a10e128/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Review] Add a Lazy flatMap for Sequences of Optionals</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December 15, 2015 at 06:00:00pm</p></header><div class="content"><p>On Tue, Dec 15, 2015 at 6:29 PM, Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I’d like to suggest a different implementation approach that not only<br>&gt; handles the bidirectional issue but also probably reduces the amount of<br>&gt; code involved: create a generic CollectionOfZeroOrOne&lt;T&gt; that wraps a T?,<br>&gt; and implement the x.flatmap(f) where f returns an optional as x.flatmap {<br>&gt; CollectionOfZeroOrOne(f($0)) }<br>&gt;<br></p><p>What&#39;s the advantage?  Why would we want to have a type that is isomorphic<br>to Optional, except that conforms to CollectionType?<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/810b71a4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5a72880ffed1a30cb9b8e3f372507145?s=50"></div><header><strong>[Review] Add a Lazy flatMap for Sequences of Optionals</strong> from <string>Rob Mayoff</string> &lt;mayoff at dqd.com&gt;<p>December 15, 2015 at 09:00:00pm</p></header><div class="content"><p>&gt;<br>&gt; What&#39;s the advantage?  Why would we want to have a type that is isomorphic<br>&gt; to Optional, except that conforms to CollectionType?<br>&gt;<br></p><p>My question (apologies if it has been answered already) is: Why isn&#39;t<br>Optional a CollectionType, like it is in Scala?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/166d076f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Review] Add a Lazy flatMap for Sequences of Optionals</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 16, 2015 at 12:00:00am</p></header><div class="content"><p>&gt; On Dec 15, 2015, at 7:21 PM, Rob Mayoff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Dmitri wrote:<br>&gt; What&#39;s the advantage?  Why would we want to have a type that is isomorphic to Optional, except that conforms to CollectionType?<br>&gt; <br>&gt; My question (apologies if it has been answered already) is: Why isn&#39;t Optional a CollectionType, like it is in Scala?<br></p><p>I don&#39;t remember the rationale, but it used to be that way &lt;https://github.com/apple/swift/commit/fad874708e05cff56aec5587a4b0f49cdadc6d11&gt; and during the run-up to the Swift 1 release IIRC several members of the Swift team objected to it.  That&#39;s the answer to Dmitri&#39;s question: I have considered that to be off the table, but we could revisit it.  <br></p><p>One cute effect, which might be too cute for some, is that<br></p><p>  if let x = y {  ... } <br></p><p>becomes equivalent to<br></p><p>  for x in y { ... }<br></p><p>when y is an optional.<br></p><p>-Dave<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/dcbca3a9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Review] Add a Lazy flatMap for Sequences of Optionals</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>December 16, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 16, 2015, at 0:03 , Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 15, 2015, at 7:21 PM, Rob Mayoff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Dmitri wrote:<br>&gt;&gt; What&#39;s the advantage?  Why would we want to have a type that is isomorphic to Optional, except that conforms to CollectionType?<br>&gt;&gt; <br>&gt;&gt; My question (apologies if it has been answered already) is: Why isn&#39;t Optional a CollectionType, like it is in Scala?<br>&gt; <br>&gt; I don&#39;t remember the rationale, but it used to be that way &lt;https://github.com/apple/swift/commit/fad874708e05cff56aec5587a4b0f49cdadc6d11&gt; and during the run-up to the Swift 1 release IIRC several members of the Swift team objected to it.  That&#39;s the answer to Dmitri&#39;s question: I have considered that to be off the table, but we could revisit it.  <br>&gt; <br>&gt; One cute effect, which might be too cute for some, is that<br>&gt; <br>&gt;   if let x = y {  ... } <br>&gt; <br>&gt; becomes equivalent to<br>&gt; <br>&gt;   for x in y { ... }<br>&gt; <br>&gt; when y is an optional.<br></p><p>IIRC we made it a CollectionType purely so we could use &quot;for x in y&quot; while &quot;if let x = y&quot; was being implemented. We didn&#39;t actually consider it properly.<br></p><p>Dmitri has mentioned at times that he&#39;s concerned about the implicit conversion to Optional kicking in when the contextual type is &quot;T: CollectionType&quot;, but I don&#39;t think that would actually happen. We don&#39;t try random implicit conversions, only the ones that there&#39;s context for. But someone would need to verify that.<br></p><p>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/c1e8e22c/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Review] Add a Lazy flatMap for Sequences of Optionals</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 17, 2015 at 12:00:00am</p></header><div class="content"><p>I&#39;ve stated in the past that I&#39;d like to see Optional conform to<br>SequenceType. It may as well conform to CollectionType too. The only<br>real drawback I&#39;m aware of is the addition of extra methods/properties<br>on Optional, which shouldn&#39;t actually be a problem, it just seems a<br>little noisy.<br></p><p>Incidentally, pre-1.0 Rust used to actually have a fair amount of code<br>that used a for-loop to iterate an Option. The Option type still is<br>iterable, but the introduction of `if let` into Rust served to replace<br>the existing uses of the for loop.<br></p><p>In any case, I&#39;m broadly in favor of supporting lazy.flatMap. I&#39;m<br>concerned about the specific implementation in the proposal because<br>LazyMapSequence&lt;LazyFilterSequence&lt;LazyMapSequence&lt;Elements, T?&gt;&gt;, T&gt; is<br>kind of a ridiculous type to be getting back from a single call to<br>flatMap(). I&#39;m most in favor of making Optional conform to<br>CollectionType and using that to simply flatMap; barring that, the<br>CollectionOfZeroOrOne idea looks promising.<br></p><p>-Kevin Ballard<br></p><p>On Wed, Dec 16, 2015, at 12:03 AM, Dave Abrahams via swift-evolution wrote:<br>&gt;<br>&gt;&gt; On Dec 15, 2015, at 7:21 PM, Rob Mayoff via swift-evolution &lt;swift-<br>&gt;&gt; evolution at swift.org&gt; wrote: Dmitri wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; What&#39;s the advantage?  Why would we want to have a type that is<br>&gt;&gt;&gt; isomorphic to Optional, except that conforms to CollectionType?<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; My question (apologies if it has been answered already) is: Why isn&#39;t<br>&gt;&gt; Optional a CollectionType, like it is in Scala?<br>&gt; I don&#39;t remember the rationale, but it used to be that way[1] and<br>&gt; during the run-up to the Swift 1 release IIRC several members of the<br>&gt; Swift team objected to it.  That&#39;s the answer to Dmitri&#39;s question: I<br>&gt; have considered that to be off the table, but we could revisit it.<br>&gt;<br>&gt; One cute effect, which might be too cute for some, is that<br>&gt;<br>&gt; if let x = y {  ... }<br>&gt;<br>&gt; becomes equivalent to<br>&gt;<br>&gt; for x in y { ... }<br>&gt;<br>&gt; when y is an optional.<br>&gt;<br>&gt; -Dave<br>&gt;<br>&gt;<br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br></p><p>Links:<br></p><p>  1. https://github.com/apple/swift/commit/fad874708e05cff56aec5587a4b0f49cdadc6d11<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/fab8382a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Review] Add a Lazy flatMap for Sequences of Optionals</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>December 19, 2015 at 10:00:00pm</p></header><div class="content"><p>After thinking about it for a bit, I&#39;m against Optional conforming to CollectionType specifically because of those extra members on Optional. Quite a few of the operations on general SequenceTypes and CollectionTypes just don&#39;t make sense:<br></p><p>- elementsEqual/lexicographicalCompare<br>- dropFirst/Last<br>- joinWithSeparator<br>- min/maxElement<br>- reduce<br>- partition/sort<br>- split<br>- startsWith<br></p><p>It&#39;s not that CollectionOfZeroOrOne isn&#39;t sometimes useful; it&#39;s that users of Optional shouldn&#39;t be confronted with these useless APIs. Things like Array.init and Set.init that take sequences also feel weird to use with Optional.<br></p><p>This clicked with me after the discussion about Optional&lt;Void&gt; and Bool: just because two types are isomorphic (in the sense of having a bijection, i.e. value-preserving transformations in both directions) doesn&#39;t mean they&#39;re the same, or should be the same. This is similar to how implementing all the members of a protocol doesn&#39;t automatically mean you conform to the protocol; the protocol has semantic requirements too.<br></p><p>Jordan<br></p><p>&gt; On Dec 17, 2015, at 0:16 , Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;ve stated in the past that I&#39;d like to see Optional conform to SequenceType. It may as well conform to CollectionType too. The only real drawback I&#39;m aware of is the addition of extra methods/properties on Optional, which shouldn&#39;t actually be a problem, it just seems a little noisy.<br>&gt;  <br>&gt; Incidentally, pre-1.0 Rust used to actually have a fair amount of code that used a for-loop to iterate an Option. The Option type still is iterable, but the introduction of `if let` into Rust served to replace the existing uses of the for loop.<br>&gt;  <br>&gt; In any case, I&#39;m broadly in favor of supporting lazy.flatMap. I&#39;m concerned about the specific implementation in the proposal because LazyMapSequence&lt;LazyFilterSequence&lt;LazyMapSequence&lt;Elements, T?&gt;&gt;, T&gt; is kind of a ridiculous type to be getting back from a single call to flatMap(). I&#39;m most in favor of making Optional conform to CollectionType and using that to simply flatMap; barring that, the CollectionOfZeroOrOne idea looks promising.<br>&gt;  <br>&gt; -Kevin Ballard<br>&gt;  <br>&gt; On Wed, Dec 16, 2015, at 12:03 AM, Dave Abrahams via swift-evolution wrote:<br>&gt;&gt;  <br>&gt;&gt;&gt; On Dec 15, 2015, at 7:21 PM, Rob Mayoff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; Dmitri wrote:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; What&#39;s the advantage?  Why would we want to have a type that is isomorphic to Optional, except that conforms to CollectionType?<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; My question (apologies if it has been answered already) is: Why isn&#39;t Optional a CollectionType, like it is in Scala?<br>&gt;&gt; <br>&gt;&gt; I don&#39;t remember the rationale, but it used to be that way &lt;https://github.com/apple/swift/commit/fad874708e05cff56aec5587a4b0f49cdadc6d11&gt; and during the run-up to the Swift 1 release IIRC several members of the Swift team objected to it.  That&#39;s the answer to Dmitri&#39;s question: I have considered that to be off the table, but we could revisit it.  <br>&gt;&gt;  <br>&gt;&gt; One cute effect, which might be too cute for some, is that<br>&gt;&gt;  <br>&gt;&gt;   if let x = y {  ... } <br>&gt;&gt;  <br>&gt;&gt; becomes equivalent to<br>&gt;&gt;  <br>&gt;&gt;   for x in y { ... }<br>&gt;&gt;  <br>&gt;&gt; when y is an optional.<br>&gt;&gt;  <br>&gt;&gt; -Dave<br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151219/606f4658/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c53218a6524f4d644b6a75a4441ea631?s=50"></div><header><strong>[Review] Add a Lazy flatMap for Sequences of Optionals</strong> from <string>Max Moiseev</string> &lt;moiseev at apple.com&gt;<p>December 16, 2015 at 12:00:00pm</p></header><div class="content"><p>FWIW: Strictly speaking Option in Scala is not a collection. It happens to have all the methods that make it look like one and also an implicit conversion that creates a List of zero or one element. Which is kind of what Dave suggests.<br></p><p>&gt; On Dec 15, 2015, at 7:21 PM, Rob Mayoff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; What&#39;s the advantage?  Why would we want to have a type that is isomorphic to Optional, except that conforms to CollectionType?<br>&gt; <br>&gt; My question (apologies if it has been answered already) is: Why isn&#39;t Optional a CollectionType, like it is in Scala?<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/e934635c/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f5228ad4a1fad94f1a7d3d05b0c0ff6a?s=50"></div><header><strong>[Review] Add a Lazy flatMap for Sequences of Optionals</strong> from <string>Donnacha Oisín Kidney</string> &lt;oisin.kidney at gmail.com&gt;<p>December 16, 2015 at 03:00:00pm</p></header><div class="content"><p>Now that I think about it, of course CollectionOfZeroOrOne would (or Optional) have a random access index. I’ll update the proposal to include that.<br></p><p>I really like the CollectionOfZeroOrOne solution. The semantics and types certainly make more sense. I’m not sure that it reduces the amount of code, though: the three extensions are still needed, plus an extra struct. (I suppose that’s not counting the extra version of LazyFilterCollection. Am I right in saying that that is intended to be added?)<br></p><p>Here’s what I have for the collection (I tried to mimic the standard library’s CollectionOfOne):<br></p><p>public struct CollectionOfZeroOrOne&lt;Element&gt; : CollectionType {<br></p><p>  public typealias Index = Bit<br>  <br>  public init(_ element: Element?) {<br>    self.element = element<br>  }<br>  <br>  public var startIndex: Index {<br>    return .Zero<br>  }<br>  <br>  public var endIndex: Index {<br>    switch element {<br>    case .Some: return .One<br>    case .None: return .Zero<br>    }<br>  }<br>  <br>  public func generate() -&gt; GeneratorOfOne&lt;Element&gt; {<br>    return GeneratorOfOne(element)<br>  }<br>  <br>  public subscript(position: Index) -&gt; Element {<br>    if case .Zero = position, let result = element {<br>      return result<br>    } else {<br>      fatalError(&quot;Index out of range&quot;)<br>    }<br>  }<br>  <br>  let element: Element?<br>}<br></p><p>Does that seem reasonable?<br></p><p>&gt; On 16 Dec 2015, at 02:29, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; First, I’d like to thank Oisin &lt;https://github.com/oisdk&gt; for his proposal.  It’s great to see people filling in gaps.<br>&gt; <br>&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt; <br>&gt; The basic idea is solid and obviously appropriate.  I have some quibbles with the proposed solution.<br>&gt; <br>&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; <br>&gt; Yes; it’s a non-uniformity, nonuniformities create complexity for users.<br>&gt; <br>&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; <br>&gt; Yes.<br>&gt; <br>&gt;&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; A quick reading, but I’m deeply familiar with the domain, having written the lazy facilities we have in the stdlib.<br>&gt; <br>&gt; I don’t see why the proposal states, “Optional probably wouldn&#39;t have a BidirectionalIndexType“.  It seems to me that as a collection, an optional’s index should be random access, just like CollectionOfOne’s.<br>&gt; <br>&gt; I’d like to suggest a different implementation approach that not only handles the bidirectional issue but also probably reduces the amount of code involved: create a generic CollectionOfZeroOrOne&lt;T&gt; that wraps a T?, and implement the x.flatmap(f) where f returns an optional as x.flatmap { CollectionOfZeroOrOne(f($0)) }<br>&gt; <br>&gt; What do you think?<br>&gt; <br>&gt; -Dave<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/8f99adff/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Review] Add a Lazy flatMap for Sequences of Optionals</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December 16, 2015 at 10:00:00am</p></header><div class="content"><p>On Wed, Dec 16, 2015 at 7:10 AM, Donnacha Oisín Kidney &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Now that I think about it, of course CollectionOfZeroOrOne would (or<br>&gt; Optional) have a random access index. I’ll update the proposal to include<br>&gt; that.<br>&gt;<br>&gt; I really like the CollectionOfZeroOrOne solution. The semantics and types<br>&gt; certainly make more sense. I’m not sure that it reduces the amount of code,<br>&gt; though: the three extensions are still needed, plus an extra struct. (I<br>&gt; suppose that’s not counting the extra version of LazyFilterCollection. Am<br>&gt; I right in saying that that is intended to be added?)<br>&gt;<br>&gt; Here’s what I have for the collection (I tried to mimic the standard<br>&gt; library’s CollectionOfOne):<br>&gt;<br>&gt; public struct CollectionOfZeroOrOne&lt;Element&gt; : CollectionType {<br>&gt;<br>&gt; [...]<br>&gt; }<br>&gt;<br>&gt; Does that seem reasonable?<br>&gt;<br></p><p>It looks reasonable, but I don&#39;t understand why adding<br>CollectionOfZeroOrOne improves the API.  Dave?<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/512e9168/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Review] Add a Lazy flatMap for Sequences of Optionals</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 16, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; On Dec 16, 2015, at 10:15 AM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Wed, Dec 16, 2015 at 7:10 AM, Donnacha Oisín Kidney &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Now that I think about it, of course CollectionOfZeroOrOne would (or Optional) have a random access index. I’ll update the proposal to include that.<br>&gt; <br>&gt; I really like the CollectionOfZeroOrOne solution. The semantics and types certainly make more sense. I’m not sure that it reduces the amount of code, though: the three extensions are still needed, plus an extra struct. (I suppose that’s not counting the extra version of LazyFilterCollection. Am I right in saying that that is intended to be added?)<br></p><p>I&#39;m not sure I understand why we need another version of LazyFilterCollection.  Can you explain?<br></p><p>&gt; Here’s what I have for the collection (I tried to mimic the standard library’s CollectionOfOne):<br>&gt; <br>&gt; public struct CollectionOfZeroOrOne&lt;Element&gt; : CollectionType {<br>&gt; <br>&gt; [...]<br>&gt; }<br>&gt; <br>&gt; Does that seem reasonable?<br>&gt; <br>&gt; It looks reasonable, but I don&#39;t understand why adding CollectionOfZeroOrOne improves the API.  Dave?<br></p><p>It doesn&#39;t.  I think it improves code reuse, and gives people an adapter to use when they want to pass an Optional where a Collection or Sequence is required.<br></p><p>&gt; <br>&gt; Dmitri<br>&gt;  <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt;*/<br></p><p>-Dave<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/2fa78ca2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f5228ad4a1fad94f1a7d3d05b0c0ff6a?s=50"></div><header><strong>[Review] Add a Lazy flatMap for Sequences of Optionals</strong> from <string>Donnacha Oisín Kidney</string> &lt;oisin.kidney at gmail.com&gt;<p>December 16, 2015 at 07:00:00pm</p></header><div class="content"><p>Oops, sorry, I wasn’t very clear. I was just trying to compare the amount of code reuse and new types between the two versions. CollectionOfZeroOrOne would need three extensions (SequenceType, CollectionType  BidirectionalIndexType  as well as the extra struct itself. The filter version doesn’t really need a new struct, but to have a bidirectional version, you would need a LazyFilterBidirectionalCollection  which doesn’t currently exist. I had thought that that was something which may be added anyway, though.<br></p><p>Oisin.<br></p><p>&gt; On 16 Dec 2015, at 19:08, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 16, 2015, at 10:15 AM, Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Wed, Dec 16, 2015 at 7:10 AM, Donnacha Oisín Kidney &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Now that I think about it, of course CollectionOfZeroOrOne would (or Optional) have a random access index. I’ll update the proposal to include that.<br>&gt;&gt; <br>&gt;&gt; I really like the CollectionOfZeroOrOne solution. The semantics and types certainly make more sense. I’m not sure that it reduces the amount of code, though: the three extensions are still needed, plus an extra struct. (I suppose that’s not counting the extra version of LazyFilterCollection. Am I right in saying that that is intended to be added?)<br>&gt; <br>&gt; I&#39;m not sure I understand why we need another version of LazyFilterCollection.  Can you explain?<br>&gt; <br>&gt;&gt; Here’s what I have for the collection (I tried to mimic the standard library’s CollectionOfOne):<br>&gt;&gt; <br>&gt;&gt; public struct CollectionOfZeroOrOne&lt;Element&gt; : CollectionType {<br>&gt;&gt; <br>&gt;&gt; [...]<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Does that seem reasonable?<br>&gt;&gt; <br>&gt;&gt; It looks reasonable, but I don&#39;t understand why adding CollectionOfZeroOrOne improves the API.  Dave?<br>&gt; <br>&gt; It doesn&#39;t.  I think it improves code reuse, and gives people an adapter to use when they want to pass an Optional where a Collection or Sequence is required.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Dmitri<br>&gt;&gt;  <br>&gt;&gt; -- <br>&gt;&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt;&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt;*/<br>&gt; <br>&gt; -Dave<br>&gt; <br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/c521f2c2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Review] Add a Lazy flatMap for Sequences of Optionals</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 16, 2015 at 12:00:00pm</p></header><div class="content"><p>OK, maybe I need to think about this more carefully.  Sorry if I drew incorrect/hasty conclusions.<br></p><p>&gt; On Dec 16, 2015, at 11:35 AM, Donnacha Oisín Kidney &lt;oisin.kidney at gmail.com&gt; wrote:<br>&gt; <br>&gt; Oops, sorry, I wasn’t very clear. I was just trying to compare the amount of code reuse and new types between the two versions. CollectionOfZeroOrOne would need three extensions (SequenceType, CollectionType  BidirectionalIndexType  as well as the extra struct itself. The filter version doesn’t really need a new struct, but to have a bidirectional version, you would need a LazyFilterBidirectionalCollection  which doesn’t currently exist. I had thought that that was something which may be added anyway, though.<br>&gt; <br>&gt; Oisin.<br>&gt; <br>&gt;&gt; On 16 Dec 2015, at 19:08, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 16, 2015, at 10:15 AM, Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Wed, Dec 16, 2015 at 7:10 AM, Donnacha Oisín Kidney &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; Now that I think about it, of course CollectionOfZeroOrOne would (or Optional) have a random access index. I’ll update the proposal to include that.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I really like the CollectionOfZeroOrOne solution. The semantics and types certainly make more sense. I’m not sure that it reduces the amount of code, though: the three extensions are still needed, plus an extra struct. (I suppose that’s not counting the extra version of LazyFilterCollection. Am I right in saying that that is intended to be added?)<br>&gt;&gt; <br>&gt;&gt; I&#39;m not sure I understand why we need another version of LazyFilterCollection.  Can you explain?<br>&gt;&gt; <br>&gt;&gt;&gt; Here’s what I have for the collection (I tried to mimic the standard library’s CollectionOfOne):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public struct CollectionOfZeroOrOne&lt;Element&gt; : CollectionType {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; [...]<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Does that seem reasonable?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It looks reasonable, but I don&#39;t understand why adding CollectionOfZeroOrOne improves the API.  Dave?<br>&gt;&gt; <br>&gt;&gt; It doesn&#39;t.  I think it improves code reuse, and gives people an adapter to use when they want to pass an Optional where a Collection or Sequence is required.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Dmitri<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt;&gt;&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt;*/<br>&gt;&gt; <br>&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br></p><p>-Dave<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/db0bb38d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Review] Add a Lazy flatMap for Sequences of Optionals</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 17, 2015 at 02:00:00pm</p></header><div class="content"><p>Having discussed it with the team, I withdraw my objection to the implementation strategy.  CollectionOfZeroOrOne is an orthogonal capability that should be handled separately, if at all.<br></p><p>So, +1 for acceptance, provided there are tests.<br></p><p>&gt; On Dec 16, 2015, at 12:14 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; OK, maybe I need to think about this more carefully.  Sorry if I drew incorrect/hasty conclusions.<br>&gt; <br>&gt;&gt; On Dec 16, 2015, at 11:35 AM, Donnacha Oisín Kidney &lt;oisin.kidney at gmail.com &lt;mailto:oisin.kidney at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Oops, sorry, I wasn’t very clear. I was just trying to compare the amount of code reuse and new types between the two versions. CollectionOfZeroOrOne would need three extensions (SequenceType, CollectionType  BidirectionalIndexType  as well as the extra struct itself. The filter version doesn’t really need a new struct, but to have a bidirectional version, you would need a LazyFilterBidirectionalCollection  which doesn’t currently exist. I had thought that that was something which may be added anyway, though.<br>&gt;&gt; <br>&gt;&gt; Oisin.<br>&gt;&gt; <br>&gt;&gt;&gt; On 16 Dec 2015, at 19:08, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 16, 2015, at 10:15 AM, Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 7:10 AM, Donnacha Oisín Kidney &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; Now that I think about it, of course CollectionOfZeroOrOne would (or Optional) have a random access index. I’ll update the proposal to include that.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I really like the CollectionOfZeroOrOne solution. The semantics and types certainly make more sense. I’m not sure that it reduces the amount of code, though: the three extensions are still needed, plus an extra struct. (I suppose that’s not counting the extra version of LazyFilterCollection. Am I right in saying that that is intended to be added?)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m not sure I understand why we need another version of LazyFilterCollection.  Can you explain?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Here’s what I have for the collection (I tried to mimic the standard library’s CollectionOfOne):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; public struct CollectionOfZeroOrOne&lt;Element&gt; : CollectionType {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; [...]<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Does that seem reasonable?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It looks reasonable, but I don&#39;t understand why adding CollectionOfZeroOrOne improves the API.  Dave?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It doesn&#39;t.  I think it improves code reuse, and gives people an adapter to use when they want to pass an Optional where a Collection or Sequence is required.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Dmitri<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt;&gt;&gt;&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt;*/<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; -Dave<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-Dave<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/eda2c94d/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
