<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d30e546d655d1c7ece0464791a9a90d5?s=50"></div><header><strong>Proposal: Typed throws</strong> from <string>Adrian Kashivskyy</string> &lt;adrian.kashivskyy at me.com&gt;<p>December  4, 2015 at 01:00:00am</p></header><div class="content"><p>I&#39;m sure you heard this request like a billion times already, but I&#39;d like to be official and make a proper proposal for that. So having said that, I hereby propose adding support for typed `throws` annotations.<br></p><p>If a function can throw, it is often known what type of error it may throw. Consider this piece of code:<br></p><p>&gt; enum NetworkError: ErrorType {<br>&gt; 	case RequestTimeout<br>&gt; 	case UnreachableHost<br>&gt; }<br>&gt; <br>&gt; enum SearchError: ErrorType {<br>&gt; 	case InvalidQuery<br>&gt; }<br>&gt; <br>&gt; func search(query: String) throws {}<br>&gt; <br>&gt; func m() {<br>&gt; 	do {<br>&gt; 		try search(&quot;foo&quot;)<br>&gt; 	} catch SearchError.InvalidQuery {<br>&gt; 		print(&quot;your query is invalid&quot;)<br>&gt; 	} catch is NetworkError {<br>&gt; 		print(&quot;please check your internet connection&quot;)<br>&gt; 	} catch {<br>&gt; 		print(&quot;an unknown error occurred&quot;) // ???<br>&gt; 	}<br>&gt; }<br></p><p><br>In order for `do-catch` to be exhaustive, the vague `catch` block is required by the compiler, and inside of it, one has literally no idea what kind of error they deal with. This is useless or even dangerous for error handling, because the last `catch` often looks like this:<br></p><p>&gt; catch {<br>&gt; 	// don&#39;t know what that is, let&#39;s ignore that<br>&gt; }<br></p><p>The situation above can be resolved by introducing typed error handling, so that the `search` function may be refactored to:<br></p><p>&gt; func search(query: String) throws SearchError, NetworkError {}<br></p><p>Then, the requirement for last, opaque `catch` block can be completely removed as the compiler will make sure that only errors of the allowed types be thrown from `search`.<br></p><p>I will be happy to hear your comments on this.<br></p><p>?????<br></p><p>As a bonus, I prepared a short FAQ for my proposal:<br></p><p>Q: What if my function throws multiple error types?<br></p><p>Use comma-separated list of error types.<br></p><p>&gt; func f() throws SomeError, OtherError {}<br></p><p>Q: What if I `try` a function which throws something completely different?<br></p><p>Then you have three possibilities:<br></p><p>1. You resolve the error in scope of the function, inside a `catch` block.<br>2. You convert it into a compatible type and `throw` it.<br>3. You annotate your `func` to be throwing that particular error as well.<br></p><p>Q: What about `rethrows`?<br></p><p>`rethrows` should become generic and throw anything that the closure arguments can throw.<br></p><p>&gt; func f(g: () throws SomeError -&gt; Void, h: () throws OtherError -&gt; Void) rethrows {}<br>&gt; <br>&gt; // behaves like<br>&gt; <br>&gt; func f(g: () throws SomeError -&gt; Void, h: () throws OtherError -&gt; Void) throws SomeError, OtherError {}<br></p><p>Q: What if I want to use the old behavior?<br></p><p>Just annotate as `throws ErrorType` and you can throw anything from there.<br></p><p>&gt; func f() throws ErrorType {}<br></p><p><br>Q: Is the failure path really as important as the success path?<br></p><p>Yes, it is.<br></p><p>Pozdrawiam ? Regards,<br>Adrian Kashivskyy<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/7448ed12/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d30e546d655d1c7ece0464791a9a90d5?s=50"></div><header><strong>Proposal: Typed throws</strong> from <string>Adrian Kashivskyy</string> &lt;adrian.kashivskyy at me.com&gt;<p>December  4, 2015 at 07:00:00pm</p></header><div class="content"><p>Anyone has any thoughts on this? I didn&#39;t expect this topic to die without any response... <br></p><p>Pozdrawiam ? Regards,<br>Adrian Kashivskyy<br></p><p>&gt; Wiadomo?? napisana przez Adrian Kashivskyy &lt;adrian.kashivskyy at me.com&gt; w dniu 04.12.2015, o godz. 01:43:<br>&gt; <br>&gt; I&#39;m sure you heard this request like a billion times already, but I&#39;d like to be official and make a proper proposal for that. So having said that, I hereby propose adding support for typed `throws` annotations.<br>&gt; <br>&gt; If a function can throw, it is often known what type of error it may throw. Consider this piece of code:<br>&gt; <br>&gt;&gt; enum NetworkError: ErrorType {<br>&gt;&gt; 	case RequestTimeout<br>&gt;&gt; 	case UnreachableHost<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; enum SearchError: ErrorType {<br>&gt;&gt; 	case InvalidQuery<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func search(query: String) throws {}<br>&gt;&gt; <br>&gt;&gt; func m() {<br>&gt;&gt; 	do {<br>&gt;&gt; 		try search(&quot;foo&quot;)<br>&gt;&gt; 	} catch SearchError.InvalidQuery {<br>&gt;&gt; 		print(&quot;your query is invalid&quot;)<br>&gt;&gt; 	} catch is NetworkError {<br>&gt;&gt; 		print(&quot;please check your internet connection&quot;)<br>&gt;&gt; 	} catch {<br>&gt;&gt; 		print(&quot;an unknown error occurred&quot;) // ???<br>&gt;&gt; 	}<br>&gt;&gt; }<br>&gt; <br>&gt; <br>&gt; In order for `do-catch` to be exhaustive, the vague `catch` block is required by the compiler, and inside of it, one has literally no idea what kind of error they deal with. This is useless or even dangerous for error handling, because the last `catch` often looks like this:<br>&gt; <br>&gt;&gt; catch {<br>&gt;&gt; 	// don&#39;t know what that is, let&#39;s ignore that<br>&gt;&gt; }<br>&gt; <br>&gt; The situation above can be resolved by introducing typed error handling, so that the `search` function may be refactored to:<br>&gt; <br>&gt;&gt; func search(query: String) throws SearchError, NetworkError {}<br>&gt; <br>&gt; Then, the requirement for last, opaque `catch` block can be completely removed as the compiler will make sure that only errors of the allowed types be thrown from `search`.<br>&gt; <br>&gt; I will be happy to hear your comments on this.<br>&gt; <br>&gt; ?????<br>&gt; <br>&gt; As a bonus, I prepared a short FAQ for my proposal:<br>&gt; <br>&gt; Q: What if my function throws multiple error types?<br>&gt; <br>&gt; Use comma-separated list of error types.<br>&gt; <br>&gt;&gt; func f() throws SomeError, OtherError {}<br>&gt; <br>&gt; Q: What if I `try` a function which throws something completely different?<br>&gt; <br>&gt; Then you have three possibilities:<br>&gt; <br>&gt; 1. You resolve the error in scope of the function, inside a `catch` block.<br>&gt; 2. You convert it into a compatible type and `throw` it.<br>&gt; 3. You annotate your `func` to be throwing that particular error as well.<br>&gt; <br>&gt; Q: What about `rethrows`?<br>&gt; <br>&gt; `rethrows` should become generic and throw anything that the closure arguments can throw.<br>&gt; <br>&gt;&gt; func f(g: () throws SomeError -&gt; Void, h: () throws OtherError -&gt; Void) rethrows {}<br>&gt;&gt; <br>&gt;&gt; // behaves like<br>&gt;&gt; <br>&gt;&gt; func f(g: () throws SomeError -&gt; Void, h: () throws OtherError -&gt; Void) throws SomeError, OtherError {}<br>&gt; <br>&gt; Q: What if I want to use the old behavior?<br>&gt; <br>&gt; Just annotate as `throws ErrorType` and you can throw anything from there.<br>&gt; <br>&gt;&gt; func f() throws ErrorType {}<br>&gt; <br>&gt; <br>&gt; Q: Is the failure path really as important as the success path?<br>&gt; <br>&gt; Yes, it is.<br>&gt; <br>&gt; Pozdrawiam ? Regards,<br>&gt; Adrian Kashivskyy<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/2fd38e95/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Proposal: Typed throws</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>December  4, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; On Dec 4, 2015, at 10:18 AM, Adrian Kashivskyy &lt;adrian.kashivskyy at me.com&gt; wrote:<br>&gt; Anyone has any thoughts on this? I didn&#39;t expect this topic to die without any response? <br></p><p>Patience. :)  We?ve been getting a lot of proposals, and it hasn?t even been a full day yet.<br></p><p>I do think that there?s a place for typed throws.  There are some very narrow use cases, usually where error handling is being employed as a sort of alternate control scheme rather than a mechanism for reporting ?errors? per se, where it?s nice to both:<br></p><p>  - inform callers that the function only ?fails? in the prescribed ways<br></p><p>  - statically enforce that general errors aren?t accidentally getting mixed in<br></p><p>You might imagine using it in a recursive-descent parser, for example, although even there I?m not convinced.<br></p><p>However, I?m still reluctant to fully embrace the feature, because I think it?s far too tempting to try to use it for actual error handling, and that?s a job that it?s really, really poorly-suited for.<br></p><p>Let?s get one thing out of the way first.  There are some operations that make sense to be able to do on a generic error ? crucially, formatting it for display in various ways ? and right now the ErrorType protocol doesn?t expose API for that.  That?s something we perhaps need to work on.<br></p><p>Beyond that, however, it has always been unclear to me what exactly programmers expect to do with this additional typing information on errors, besides pedantically copying it all over the place and feeling pleased.  Libraries can fail in a lot of different ways.  It?s inevitable that that set will grow in ways that neither the library?s authors nor its users are necessarily anticipating.  Even putting evolution aside, the list of failures is almost certainly impractical to exhaustively pattern-match over, and doing so couples you very tightly to the implementation of the library and everything it uses.  Furthermore, in practice nearly every ?exhaustively enumerable? error type I?ve ever seen has at least one (and often two or three) generic, catch-all cases used to encode arbitrary extra kinds of error, either dynamically-typed (e.g. carrying an ErrorType) or completely untyped (e.g. carrying a String); and not only does this make it impossible to exhaustively enumerate the actual kinds of failure, but it actually makes it more difficult to detect specific failures, by making it more likely that the error you?re actually trying to detect and special-case will be stored at the end of a rather complicated path of wrapping errors.<br></p><p>And this isn?t even just about third-party libraries, because if there?s any lesson from the last fifty years of experience that&#39;s broadly applicable across programming languages, it?s that you really do need to think about how your program breaks down into components, and understand how those components work with each other essentially as if they were separable libraries, or else you will always, always run into a wall as you find that the complexity of your comprehension has failed to scale with the complexity of your code.<br></p><p>So I continue to feel that the pattern of ?recognize a few special cases and then be prepared to deal with other failures generically? is basically the right approach for ordinary error-handling in Swift, and I think it?s pretty well-served by the current design.<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: Typed throws</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December  4, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; Beyond that, however, it has always been unclear to me what exactly programmers expect to do with this additional typing information on errors, besides pedantically copying it all over the place and feeling pleased.  Libraries can fail in a lot of different ways.  It?s inevitable that that set will grow in ways that neither the library?s authors nor its users are necessarily anticipating.  <br>&gt; <br>&gt; So I continue to feel that the pattern of ?recognize a few special cases and then be prepared to deal with other failures generically? is basically the right approach for ordinary error-handling in Swift, and I think it?s pretty well-served by the current design.<br></p><p>I am a big proponent of typed throws.  IMO error results are every bit as important a part of an API contract as success results.  Sometimes erasing type information is the right API contract and sometimes it is not.  I don?t think requiring type information to be erased is the right way to go.  It should be a choice the language allows library authors to make for themselves.<br></p><p>I have worked in many languages over the last 20 years and one complaint I have nearly always had is that documentation of error cases is quite poor.  This problem has been significant enough that I think it warrants a language solution.  Typed errors provide compiler-enforced documentation about what errors can arise from a call.  The value of this compiler-enforced documentation should not be underestimated.<br></p><p>If the language evolves to support typed errors I believe we would learn how and when it is best to provide specific error types and when to employ type erasure / generic errors.  The range of options would encourage thoughtful library authors to consider their approach carefully and likely lead to solutions that facilitate better error handling in code that uses the library.  <br></p><p>One idea that I think merits consideration is the approach Rust uses to translate lower level errors representing implementation details into higher level errors represented in the API contract at module boundaries.  A well-designed language feature along these lines would go a long way towards addressing the complexity of ?previously unanticipated errors?, would provide compiler enforced documentation, and would allow library authors to present a well-defined contract for error conditions as well as success conditions.<br></p><p>I hope this at least begins to answer the question of what programmers might hope to achieve with additional typing information on errors.<br></p><p>Matthew<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>Proposal: Typed throws</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>December  4, 2015 at 11:00:00am</p></header><div class="content"><p>For the most part, I feel that typed errors are more of a response to how we need to handle errors within Swift today.<br></p><p>    var vendingMachine = VendingMachine()<br>    vendingMachine.coinsDeposited = 8<br>    <br>    do {<br>        try buyFavoriteSnack(&quot;Alice&quot;, vendingMachine: vendingMachine)<br>    } catch VendingMachineError.InvalidSelection {<br>        print(&quot;Invalid Selection.&quot;)<br>    } catch VendingMachineError.OutOfStock {<br>        print(&quot;Out of Stock.&quot;)<br>    } catch VendingMachineError.InsufficientFunds(let coinsNeeded) {<br>        print(&quot;Insufficient funds. Please insert an additional \(coinsNeeded) coins.&quot;)<br>    } catch { fatalError(&quot;this is always needed??) }<br></p><p>&gt; So I continue to feel that the pattern of ?recognize a few special cases and then be prepared to deal with other failures generically? is basically the right approach for ordinary error-handling in Swift, and I think it?s pretty well-served by the current design.<br></p><p>Possibly? but I think the counter argument is that introducing a new error type that can happen **should** be a breaking change. So the `catch` with no pattern becomes a pattern that is ?yeah, some error may happen at a later date, but since we have no idea what it is, it may be benign or it may be catastrophic. So, should it be handled with a `fatalError()` or should it be equivalent to a no-op?<br></p><p>To me, the question really becomes: does a non-typed error-like system really make sense in Swift? Or in other words, if interop with ObjC was not required, would `throw` exist as it does today? <br></p><p>It would seem that something has to give: either something like a `Result`/`Error` type should be used instead with some nicer syntax to handle it, or `throws` should really become typed. Leaving it as-is, seems to be the worst of both worlds.<br></p><p>-David<br></p><p><br>&gt; On Dec 4, 2015, at 11:08 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Dec 4, 2015, at 10:18 AM, Adrian Kashivskyy &lt;adrian.kashivskyy at me.com&gt; wrote:<br>&gt;&gt; Anyone has any thoughts on this? I didn&#39;t expect this topic to die without any response? <br>&gt; <br>&gt; Patience. :)  We?ve been getting a lot of proposals, and it hasn?t even been a full day yet.<br>&gt; <br>&gt; I do think that there?s a place for typed throws.  There are some very narrow use cases, usually where error handling is being employed as a sort of alternate control scheme rather than a mechanism for reporting ?errors? per se, where it?s nice to both:<br>&gt; <br>&gt;  - inform callers that the function only ?fails? in the prescribed ways<br>&gt; <br>&gt;  - statically enforce that general errors aren?t accidentally getting mixed in<br>&gt; <br>&gt; You might imagine using it in a recursive-descent parser, for example, although even there I?m not convinced.<br>&gt; <br>&gt; However, I?m still reluctant to fully embrace the feature, because I think it?s far too tempting to try to use it for actual error handling, and that?s a job that it?s really, really poorly-suited for.<br>&gt; <br>&gt; Let?s get one thing out of the way first.  There are some operations that make sense to be able to do on a generic error ? crucially, formatting it for display in various ways ? and right now the ErrorType protocol doesn?t expose API for that.  That?s something we perhaps need to work on.<br>&gt; <br>&gt; Beyond that, however, it has always been unclear to me what exactly programmers expect to do with this additional typing information on errors, besides pedantically copying it all over the place and feeling pleased.  Libraries can fail in a lot of different ways.  It?s inevitable that that set will grow in ways that neither the library?s authors nor its users are necessarily anticipating.  Even putting evolution aside, the list of failures is almost certainly impractical to exhaustively pattern-match over, and doing so couples you very tightly to the implementation of the library and everything it uses.  Furthermore, in practice nearly every ?exhaustively enumerable? error type I?ve ever seen has at least one (and often two or three) generic, catch-all cases used to encode arbitrary extra kinds of error, either dynamically-typed (e.g. carrying an ErrorType) or completely untyped (e.g. carrying a String); and not only does this make it impossible to exhaustively enumerate the actual kinds of failure, but it actually makes it more difficult to detect specific failures, by making it more likely that the error you?re actually trying to detect and special-case will be stored at the end of a rather complicated path of wrapping errors.<br>&gt; <br>&gt; And this isn?t even just about third-party libraries, because if there?s any lesson from the last fifty years of experience that&#39;s broadly applicable across programming languages, it?s that you really do need to think about how your program breaks down into components, and understand how those components work with each other essentially as if they were separable libraries, or else you will always, always run into a wall as you find that the complexity of your comprehension has failed to scale with the complexity of your code.<br>&gt; <br>&gt; So I continue to feel that the pattern of ?recognize a few special cases and then be prepared to deal with other failures generically? is basically the right approach for ordinary error-handling in Swift, and I think it?s pretty well-served by the current design.<br>&gt; <br>&gt; John.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Proposal: Typed throws</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>December  4, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; On Dec 4, 2015, at 11:36 AM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt; For the most part, I feel that typed errors are more of a response to how we need to handle errors within Swift today.<br>&gt; <br>&gt;    var vendingMachine = VendingMachine()<br>&gt;    vendingMachine.coinsDeposited = 8<br>&gt; <br>&gt;    do {<br>&gt;        try buyFavoriteSnack(&quot;Alice&quot;, vendingMachine: vendingMachine)<br>&gt;    } catch VendingMachineError.InvalidSelection {<br>&gt;        print(&quot;Invalid Selection.&quot;)<br>&gt;    } catch VendingMachineError.OutOfStock {<br>&gt;        print(&quot;Out of Stock.&quot;)<br>&gt;    } catch VendingMachineError.InsufficientFunds(let coinsNeeded) {<br>&gt;        print(&quot;Insufficient funds. Please insert an additional \(coinsNeeded) coins.&quot;)<br>&gt;    } catch { fatalError(&quot;this is always needed??) }<br></p><p>But this is printing.  Of course you should be able to generically display an error, but you don?t need static typing for that.  Also, I certainly hope you are not actually repeating all this stuff at every catch site.<br></p><p>&gt;&gt; So I continue to feel that the pattern of ?recognize a few special cases and then be prepared to deal with other failures generically? is basically the right approach for ordinary error-handling in Swift, and I think it?s pretty well-served by the current design.<br>&gt; <br>&gt; Possibly? but I think the counter argument is that introducing a new error type that can happen **should** be a breaking change.<br></p><p>This is abstract reasoning without any real consideration for what it?s going to do to actual code.  My argument here is that it?s very easy to fall into a trap where you think this information is useful, but in practice it just leads to a lot of redundancy and boilerplate which, overall, actually means you?re handling errors *worse* than you were before.<br></p><p>&gt; So the `catch` with no pattern becomes a pattern that is ?yeah, some error may happen at a later date, but since we have no idea what it is, it may be benign or it may be catastrophic. So, should it be handled with a `fatalError()` or should it be equivalent to a no-op?<br>&gt; <br>&gt; To me, the question really becomes: does a non-typed error-like system really make sense in Swift? Or in other words, if interop with ObjC was not required, would `throw` exist as it does today? <br></p><p>Yes.  It is absolutely the case that libraries are not going to commit to a generating a small, fixed set of failures.  Please feel free to try to find an exhaustive error enum that isn?t littered with vague catch-alls.  Library authors often don?t want to commit to their current set of failures precisely *because* they feel that their current errors are too loosely typed, and they?re holding out hope that some day they?ll come along and make them more specific.<br></p><p>It?s nice to say things like library authors should be encouraged to think more carefully about what errors they generate, and I don?t disagree, but it is not reasonable language design to demand and expect that programmers suddenly start putting vastly more effort into this sort of thing.  Honestly, I am curious what environment people are thinking of when they say that it?s been successful elsewhere, because whenever I see something like Result&lt;T, SomeErrorType&gt;, I take a look at SomeErrorType and almost always find that it is extremely loosely specified.<br></p><p>John.<br></p><p>&gt; It would seem that something has to give: either something like a `Result`/`Error` type should be used instead with some nicer syntax to handle it, or `throws` should really become typed. Leaving it as-is, seems to be the worst of both worlds.<br>&gt; <br>&gt; -David<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 4, 2015, at 11:08 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 4, 2015, at 10:18 AM, Adrian Kashivskyy &lt;adrian.kashivskyy at me.com&gt; wrote:<br>&gt;&gt;&gt; Anyone has any thoughts on this? I didn&#39;t expect this topic to die without any response? <br>&gt;&gt; <br>&gt;&gt; Patience. :)  We?ve been getting a lot of proposals, and it hasn?t even been a full day yet.<br>&gt;&gt; <br>&gt;&gt; I do think that there?s a place for typed throws.  There are some very narrow use cases, usually where error handling is being employed as a sort of alternate control scheme rather than a mechanism for reporting ?errors? per se, where it?s nice to both:<br>&gt;&gt; <br>&gt;&gt; - inform callers that the function only ?fails? in the prescribed ways<br>&gt;&gt; <br>&gt;&gt; - statically enforce that general errors aren?t accidentally getting mixed in<br>&gt;&gt; <br>&gt;&gt; You might imagine using it in a recursive-descent parser, for example, although even there I?m not convinced.<br>&gt;&gt; <br>&gt;&gt; However, I?m still reluctant to fully embrace the feature, because I think it?s far too tempting to try to use it for actual error handling, and that?s a job that it?s really, really poorly-suited for.<br>&gt;&gt; <br>&gt;&gt; Let?s get one thing out of the way first.  There are some operations that make sense to be able to do on a generic error ? crucially, formatting it for display in various ways ? and right now the ErrorType protocol doesn?t expose API for that.  That?s something we perhaps need to work on.<br>&gt;&gt; <br>&gt;&gt; Beyond that, however, it has always been unclear to me what exactly programmers expect to do with this additional typing information on errors, besides pedantically copying it all over the place and feeling pleased.  Libraries can fail in a lot of different ways.  It?s inevitable that that set will grow in ways that neither the library?s authors nor its users are necessarily anticipating.  Even putting evolution aside, the list of failures is almost certainly impractical to exhaustively pattern-match over, and doing so couples you very tightly to the implementation of the library and everything it uses.  Furthermore, in practice nearly every ?exhaustively enumerable? error type I?ve ever seen has at least one (and often two or three) generic, catch-all cases used to encode arbitrary extra kinds of error, either dynamically-typed (e.g. carrying an ErrorType) or completely untyped (e.g. carrying a String); and not only does this make it impossible to exhaustively enumerate the actual kinds of failure, but it actually makes it more difficult to detect specific failures, by making it more likely that the error you?re actually trying to detect and special-case will be stored at the end of a rather complicated path of wrapping errors.<br>&gt;&gt; <br>&gt;&gt; And this isn?t even just about third-party libraries, because if there?s any lesson from the last fifty years of experience that&#39;s broadly applicable across programming languages, it?s that you really do need to think about how your program breaks down into components, and understand how those components work with each other essentially as if they were separable libraries, or else you will always, always run into a wall as you find that the complexity of your comprehension has failed to scale with the complexity of your code.<br>&gt;&gt; <br>&gt;&gt; So I continue to feel that the pattern of ?recognize a few special cases and then be prepared to deal with other failures generically? is basically the right approach for ordinary error-handling in Swift, and I think it?s pretty well-served by the current design.<br>&gt;&gt; <br>&gt;&gt; John.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>Proposal: Typed throws</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>December  4, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; On Dec 4, 2015, at 11:54 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Dec 4, 2015, at 11:36 AM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt;&gt; For the most part, I feel that typed errors are more of a response to how we need to handle errors within Swift today.<br>&gt;&gt; <br>&gt;&gt;   var vendingMachine = VendingMachine()<br>&gt;&gt;   vendingMachine.coinsDeposited = 8<br>&gt;&gt; <br>&gt;&gt;   do {<br>&gt;&gt;       try buyFavoriteSnack(&quot;Alice&quot;, vendingMachine: vendingMachine)<br>&gt;&gt;   } catch VendingMachineError.InvalidSelection {<br>&gt;&gt;       print(&quot;Invalid Selection.&quot;)<br>&gt;&gt;   } catch VendingMachineError.OutOfStock {<br>&gt;&gt;       print(&quot;Out of Stock.&quot;)<br>&gt;&gt;   } catch VendingMachineError.InsufficientFunds(let coinsNeeded) {<br>&gt;&gt;       print(&quot;Insufficient funds. Please insert an additional \(coinsNeeded) coins.&quot;)<br>&gt;&gt;   } catch { fatalError(&quot;this is always needed…”) }<br>&gt; <br>&gt; But this is printing.  Of course you should be able to generically display an error, but you don’t need static typing for that.  Also, I certainly hope you are not actually repeating all this stuff at every catch site.<br></p><p>This was a sample from the Swift docs: https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ErrorHandling.html#//apple_ref/doc/uid/TP40014097-CH42-ID508. I added the missing final `catch` that is required with Swift today.<br></p><p>The point being, the error enum is fully defined but we still need the final `catch` at the end because there is no type information on the `throws` annotation for `buyFavoriteSnack`. So unlike the case when dealing with enums and switch-statements, we lose all compile-time information about coverage of error states when we could know them. The current implementation of `throws` is the only (as far as I can tell) place in Swift that turns a compile-time validation problem into a run-time validation problem.<br></p><p>That’s my concern.<br></p><p>Instead, if we could annotate throws, we could move this into a compile-time validation.<br></p><p>    enum VendingMachineError: ErrorType {<br>        case InvalidSelection<br>        case InsufficientFunds(coinsNeeded: Int)<br>        case OutOfStock<br>    }<br></p><p>    func buyFavoriteSnack(person: String, vendingMachine: VendingMachine) throws VendingMachineError {<br>        let snackName = favoriteSnacks[person] ?? &quot;Candy Bar&quot;<br>        try vendingMachine.vend(itemNamed: snackName)<br>    }<br></p><p>This allows the compiler to validate the only error information leaving this call site is a `VendingMachineError` and it allows all callers to ensure that they are indeed handling the all of the errors for `VendingMachineError`. <br></p><p>To me, that is a very practical and pragmatic problem and is fundamentally no different than the treatment of exhaustive switch cases needed when dealing with other enum values.<br></p><p>Instead, if I turned the `buyFavoriteSnack` into this:<br></p><p>    enum Error&lt;ErrorType&gt; {<br>        case Ok,<br>        case Error(ErrorType)<br>    }<br></p><p>    func buyFavoriteSnack(person: String, vendingMachine: VendingMachine) -&gt; Error&lt;VendingMachineError&gt;<br></p><p>I then get to leverage the compiler to check that I’m indeed handling all of the VendingMachineErrors.<br></p><p>Yes, I do realize that multiple error types would complicate that, but honestly, I’d rather than the limitation that only a single error type can be propagated up the callstack than to have the ability to have no typed error information at all.<br></p><p>Of course, I can do this myself, but the language is going to win so I still have to deal with how `throws` is treated within the language as a whole.<br></p><p>-David<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>Proposal: Typed throws</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>December  4, 2015 at 04:00:00pm</p></header><div class="content"><p>I created a pull request for this issue: https://github.com/apple/swift-evolution/pull/26<br></p><p>There was a question on GitHub:<br></p><p>&gt; The proposal seems to be ignoring the negative implementation experience in Java. Why is Swift different?<br></p><p>*Moving the discussion back to the alias*<br></p><p>--<br></p><p>I guess first and foremost, the proposal basically boils down to a syntactical sugar request for what could be considered `Error&lt;T&gt;` and `Result&lt;T, U&gt;` types as the realized return values.<br></p><p>The second fundamental ask is this: give us the ability to handle errors in a way that we can verify all of the potential codepaths with the compiler. <br></p><p>My experience in Java was many years ago, so I can only speak to what I remember, but what I do remember was the proliferation of exceptions for every little minute thing. In the end, they became a mechanism for control flow instead of for actual error cases.<br></p><p>An example would be a `FileNotFoundException`. Is it really exceptional that a file doesn&#39;t exist? No, obviously not. Bad API decisions cannot help you abuse language constructs. <br></p><p>The other problem seemed to be the shear number of exceptions that would be marked as throwable from any particular method. In the proposal, I specifically call out only allowing a single type. The purpose is to avoid such a proliferation problem.<br></p><p>This is what all of my do-catch code boils down to:<br></p><p>```swift<br>do {<br>    try f()<br>}<br>catch KnownError.Case1 { }<br>catch KnownError.ThatsAllOfThem {}<br>catch { fatalError(&quot;Well... if someone else adds another case, I better crash here and hopefully I&#39;ll see it before my customers do&quot;) }<br>```<br></p><p>Now, if I chose to use a catch-all `catch` clause, then that&#39;s fine. However, Swift forces me to do it today. So my option is to either:<br></p><p>1. Crash the user&#39;s app so that a potentially subtle bug doesn&#39;t propagate through the app causing a more serious error, or<br>2. Roll the dice and see what happens. Hopefully I have telemetry data here so I know when these handlers are happening, because the compiler cannot tell me.<br></p><p>If you have another option, I&#39;m willing to hear it.<br></p><p><br>&gt; On Dec 4, 2015, at 12:54 PM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 4, 2015, at 11:54 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 4, 2015, at 11:36 AM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt;&gt;&gt; For the most part, I feel that typed errors are more of a response to how we need to handle errors within Swift today.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  var vendingMachine = VendingMachine()<br>&gt;&gt;&gt;  vendingMachine.coinsDeposited = 8<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  do {<br>&gt;&gt;&gt;      try buyFavoriteSnack(&quot;Alice&quot;, vendingMachine: vendingMachine)<br>&gt;&gt;&gt;  } catch VendingMachineError.InvalidSelection {<br>&gt;&gt;&gt;      print(&quot;Invalid Selection.&quot;)<br>&gt;&gt;&gt;  } catch VendingMachineError.OutOfStock {<br>&gt;&gt;&gt;      print(&quot;Out of Stock.&quot;)<br>&gt;&gt;&gt;  } catch VendingMachineError.InsufficientFunds(let coinsNeeded) {<br>&gt;&gt;&gt;      print(&quot;Insufficient funds. Please insert an additional \(coinsNeeded) coins.&quot;)<br>&gt;&gt;&gt;  } catch { fatalError(&quot;this is always needed…”) }<br>&gt;&gt; <br>&gt;&gt; But this is printing.  Of course you should be able to generically display an error, but you don’t need static typing for that.  Also, I certainly hope you are not actually repeating all this stuff at every catch site.<br>&gt; <br>&gt; This was a sample from the Swift docs: https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ErrorHandling.html#//apple_ref/doc/uid/TP40014097-CH42-ID508. I added the missing final `catch` that is required with Swift today.<br>&gt; <br>&gt; The point being, the error enum is fully defined but we still need the final `catch` at the end because there is no type information on the `throws` annotation for `buyFavoriteSnack`. So unlike the case when dealing with enums and switch-statements, we lose all compile-time information about coverage of error states when we could know them. The current implementation of `throws` is the only (as far as I can tell) place in Swift that turns a compile-time validation problem into a run-time validation problem.<br>&gt; <br>&gt; That’s my concern.<br>&gt; <br>&gt; Instead, if we could annotate throws, we could move this into a compile-time validation.<br>&gt; <br>&gt;    enum VendingMachineError: ErrorType {<br>&gt;        case InvalidSelection<br>&gt;        case InsufficientFunds(coinsNeeded: Int)<br>&gt;        case OutOfStock<br>&gt;    }<br>&gt; <br>&gt;    func buyFavoriteSnack(person: String, vendingMachine: VendingMachine) throws VendingMachineError {<br>&gt;        let snackName = favoriteSnacks[person] ?? &quot;Candy Bar&quot;<br>&gt;        try vendingMachine.vend(itemNamed: snackName)<br>&gt;    }<br>&gt; <br>&gt; This allows the compiler to validate the only error information leaving this call site is a `VendingMachineError` and it allows all callers to ensure that they are indeed handling the all of the errors for `VendingMachineError`. <br>&gt; <br>&gt; To me, that is a very practical and pragmatic problem and is fundamentally no different than the treatment of exhaustive switch cases needed when dealing with other enum values.<br>&gt; <br>&gt; Instead, if I turned the `buyFavoriteSnack` into this:<br>&gt; <br>&gt;    enum Error&lt;ErrorType&gt; {<br>&gt;        case Ok,<br>&gt;        case Error(ErrorType)<br>&gt;    }<br>&gt; <br>&gt;    func buyFavoriteSnack(person: String, vendingMachine: VendingMachine) -&gt; Error&lt;VendingMachineError&gt;<br>&gt; <br>&gt; I then get to leverage the compiler to check that I’m indeed handling all of the VendingMachineErrors.<br>&gt; <br>&gt; Yes, I do realize that multiple error types would complicate that, but honestly, I’d rather than the limitation that only a single error type can be propagated up the callstack than to have the ability to have no typed error information at all.<br>&gt; <br>&gt; Of course, I can do this myself, but the language is going to win so I still have to deal with how `throws` is treated within the language as a whole.<br>&gt; <br>&gt; -David<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Proposal: Typed throws</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>December  4, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; On Dec 4, 2015, at 12:54 PM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt;&gt; On Dec 4, 2015, at 11:54 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 4, 2015, at 11:36 AM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt;&gt;&gt; For the most part, I feel that typed errors are more of a response to how we need to handle errors within Swift today.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  var vendingMachine = VendingMachine()<br>&gt;&gt;&gt;  vendingMachine.coinsDeposited = 8<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  do {<br>&gt;&gt;&gt;      try buyFavoriteSnack(&quot;Alice&quot;, vendingMachine: vendingMachine)<br>&gt;&gt;&gt;  } catch VendingMachineError.InvalidSelection {<br>&gt;&gt;&gt;      print(&quot;Invalid Selection.&quot;)<br>&gt;&gt;&gt;  } catch VendingMachineError.OutOfStock {<br>&gt;&gt;&gt;      print(&quot;Out of Stock.&quot;)<br>&gt;&gt;&gt;  } catch VendingMachineError.InsufficientFunds(let coinsNeeded) {<br>&gt;&gt;&gt;      print(&quot;Insufficient funds. Please insert an additional \(coinsNeeded) coins.&quot;)<br>&gt;&gt;&gt;  } catch { fatalError(&quot;this is always needed…”) }<br>&gt;&gt; <br>&gt;&gt; But this is printing.  Of course you should be able to generically display an error, but you don’t need static typing for that.  Also, I certainly hope you are not actually repeating all this stuff at every catch site.<br>&gt; <br>&gt; This was a sample from the Swift docs: https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ErrorHandling.html#//apple_ref/doc/uid/TP40014097-CH42-ID508. I added the missing final `catch` that is required with Swift today.<br></p><p>Ah, right, I knew I recognized that example.<br></p><p>This code is intended to demonstrate the ability to chain catches more than it is intended to demonstrate best practice for working with errors.  In real code, this would be better done by giving VendingMachineError a conformance to CustomStringConvertible and just having this at the catch site:<br></p><p>  catch {<br>    print(error)<br>  }<br></p><p>&gt; The point being, the error enum is fully defined but we still need the final `catch` at the end because there is no type information on the `throws` annotation for `buyFavoriteSnack`. So unlike the case when dealing with enums and switch-statements, we lose all compile-time information about coverage of error states when we could know them. The current implementation of `throws` is the only (as far as I can tell) place in Swift that turns a compile-time validation problem into a run-time validation problem.<br></p><p>AnyObject and ImplicitlyUnwrappedOptional come immediately to mind.  I expect that we will gradually more dynamic features, hopefully more like the former than the latter.<br></p><p>&gt; That’s my concern.<br>&gt; <br>&gt; Instead, if we could annotate throws, we could move this into a compile-time validation.<br></p><p>I understand what you want to do.  I am saying that, as a language designer, I am reluctant to add features that seem to be, frankly, aspirational bluffs.<br></p><p>I would like you to think about what your concrete error types will look like in their entirety and reconsider whether that static type would actually tell you anything useful.  I certainly don’t believe that they’re worth the costs, which are quite high.<br></p><p>&gt; Yes, I do realize that multiple error types would complicate that, but honestly, I’d rather than the limitation that only a single error type can be propagated up the callstack than to have the ability to have no typed error information at all.<br></p><p>This is what I mean.  Your code will use other code, which will produce its own errors.  Your &quot;single error type” will therefore end up providing at least one case, and probably several, that simply wraps other, opaque error types without providing any extra information.  Thus, it will simply rebroadcast all of your library dependencies, and it will need to be modified whenever your implementation changes.  You will have meaningless translation/wrapping code scattered at every library boundary just to appease the compiler, and anybody trying to recognize specific problems will have to pattern match through an arbitrarily-nested tree of such wrappers.  This is all essentially an inevitable consequence of statically typed errors, and it is a bad outcome.<br></p><p>John.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: Typed throws</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December  5, 2015 at 08:00:00am</p></header><div class="content"><p>On Dec 4, 2015, at 12:54 PM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  do {<br>&gt;&gt;&gt;      try buyFavoriteSnack(&quot;Alice&quot;, vendingMachine: vendingMachine)<br>&gt;&gt;&gt;  } catch VendingMachineError.InvalidSelection {<br>&gt;&gt;&gt;      print(&quot;Invalid Selection.&quot;)<br>&gt;&gt;&gt;  } catch VendingMachineError.OutOfStock {<br>&gt;&gt;&gt;      print(&quot;Out of Stock.&quot;)<br>&gt;&gt;&gt;  } catch VendingMachineError.InsufficientFunds(let coinsNeeded) {<br>&gt;&gt;&gt;      print(&quot;Insufficient funds. Please insert an additional \(coinsNeeded) coins.&quot;)<br>&gt;&gt;&gt;  } catch { fatalError(&quot;this is always needed…”) }<br>&gt;&gt; <br>&gt;&gt; But this is printing.  Of course you should be able to generically display an error, but you don’t need static typing for that.  Also, I certainly hope you are not actually repeating all this stuff at every catch site.<br>&gt; <br>&gt; This was a sample from the Swift docs: https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ErrorHandling.html#//apple_ref/doc/uid/TP40014097-CH42-ID508. I added the missing final `catch` that is required with Swift today.<br>&gt; <br>&gt; The point being, the error enum is fully defined but we still need the final `catch` at the end because there is no type information on the `throws` annotation for `buyFavoriteSnack`. So unlike the case when dealing with enums and switch-statements, we lose all compile-time information about coverage of error states when we could know them. The current implementation of `throws` is the only (as far as I can tell) place in Swift that turns a compile-time validation problem into a run-time validation problem.<br>&gt; <br>&gt; That’s my concern.<br>&gt; <br>&gt; Instead, if we could annotate throws, we could move this into a compile-time validation.<br></p><p>FWIW, if you’re interested in the Swift error handling model, then this document is required reading:<br>https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst<br></p><p>John drove the design efforts for error handling in Swift 2 and wrote it to capture the thinking of the team.  There is also this document that describes the intent of the feature as well, but it has been subsumed by The Swift Programming Langauge:<br>https://github.com/apple/swift/blob/master/docs/ErrorHandling.rst<br></p><p><br>My take on it is that typed throws would be a great feature to add for all of the reasons you specify.  However, rolling it out in Swift 2 would have been very problematic, because we didn’t (and still don’t) have the Swift 3 resilience model in place.<br></p><p>The resilience model addresses how the public API from a module can evolve without breaking clients (either at the source level or ABI level).  Notably, we want the ability to be able to add enum cases to something by default, but also to allow API authors to opt into more performance/strictness by saying that a public enum is “fragile” or “closed for evolution”.<br></p><p>In the case of typed throws, you should only get the “exhaustiveness checking” of catch blocks if you’re catching an enum defined in your own module, or if it is a public enum from some other module that is defined as being fragile.<br></p><p>-Chris<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
