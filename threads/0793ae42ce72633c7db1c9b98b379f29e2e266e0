<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/957b675456a66c394945a7361aedd51d?s=50"></div><header><strong>Compiler should generate code base on the functions that have default values</strong> from <string>Zhao Xin</string> &lt;owenzx at gmail.com&gt;<p>January 17, 2016 at 10:00:00pm</p></header><div class="content"><p>This proposal is the summary of the previous protocol function default<br>value proposal and some of my new thinkings all together.<br></p><p>Currently the compiler doesn&#39;t stop you defining two functions like:<br></p><p>func printSomething(something:String = &quot;some thing&quot;) {<br></p><p>    print(something)<br></p><p>}<br></p><p><br>func printSomething() {<br></p><p>    print(&quot;some thing!&quot;)<br></p><p>}<br></p><p><br>However, when you call it, an error arises.<br></p><p><br>printSomething() // Ambiguous use of &#39;printSomething&#39;<br></p><p><br>You may say just remove the function that has no argument. But protocol<br>needs it.<br></p><p><br>protocol A {<br></p><p>    func printSomething(something:String)<br></p><p>    func printSomething()<br></p><p>}<br></p><p><br>struct Foo:A {<br></p><p>    func printSomething(something:String) {<br></p><p>        print(something)<br></p><p>    }<br></p><p><br></p><p>    func printSomething() {<br></p><p>        self.printSomething(&quot;some thing&quot;)<br></p><p>    }<br></p><p>}<br></p><p><br>If you do&#39;t define the no-argument function in protocol A. You can not use<br>the function by (Foo() as A).printSomething().<br></p><p><br></p><p>As we all know, a function with default values, can rewrite to two or more<br>equivalent functions. For example,<br></p><p><br>struct Bar {<br></p><p>    func add(int1:Int = 1, int2:Int = 2, int3:Int = 3) {<br></p><p>        print(int1 + int2 + int3)<br></p><p>    }<br></p><p>}<br></p><p><br>is equivalent to<br></p><p><br>struct Bar {<br></p><p>    func add(int1:Int, int2:Int, int3:Int) {<br></p><p>        print(int1 + int2 + int3)<br></p><p>    }<br></p><p><br></p><p>    func add() {<br></p><p>        self.add(1, int2: 2, int3: 3)<br></p><p>    }<br></p><p><br></p><p>    func add(int1:Int) {<br></p><p>        self.add(int1, int2: 2, int3: 3)<br></p><p>    }<br></p><p><br></p><p>    func add(int1:Int, int2:Int) {<br></p><p>        self.add(int1, int2: int2, int3: 3)<br></p><p>    }<br></p><p>}<br></p><p><br>So my proposal is let compiler or pre-compiler to generate the code<br>internally, without changing the original code,  base on the functions that<br>have default values.<br></p><p><br>Then we need not to define multiple functions in a protocol when we need<br>function with default values.<br></p><p><br>new code:<br></p><p><br>protocol A {<br></p><p>    func printSomething(something:String)<br></p><p>}<br></p><p><br>struct Foo:A {<br></p><p>    func printSomething(something:String = &quot;some thing&quot;) {<br></p><p>        print(something)<br></p><p>    }<br></p><p>}<br></p><p><br></p><p>If we don&#39;t want to change our previous code, we may also need to introduce<br>another keyword defaultValue. This keyword is used only in a protocol to<br>restrict if a function&#39;s argument can have a default value. If a function<br>use it, but the implementation doesn&#39;t give a default value, or vice versa,<br>an error arises.<br></p><p><br>new code:<br></p><p><br>protocol A {<br></p><p>    func printSomething(something:String = defaultValue)<br></p><p>}<br></p><p><br>struct Foo:A {<br></p><p>    func printSomething(something:String = &quot;some thing&quot;) {<br></p><p>        print(something)<br></p><p>    }<br></p><p>}<br></p><p><br>This keyword is useful. With it, you can still use Swift in old way. Which<br>means you need not to change code like below if you don&#39;t want to.<br></p><p><br>old code:<br></p><p><br>protocol A {<br></p><p>    func printSomething(something:String)<br></p><p>    func printSomething()<br></p><p>}<br></p><p><br>struct Foo:A {<br></p><p>    func printSomething(something:String) {<br></p><p>        print(something)<br></p><p>    }<br></p><p><br></p><p>    func printSomething() {<br></p><p>        self.printSomething(&quot;some thing&quot;)<br></p><p>    }<br></p><p>}<br></p><p><br>But if you want to write new code. You can just write it in the new<br>way, enjoining the simpler and clearer.<br></p><p><br>zhaoxin<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160117/079366e0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d9dbc0dfeb74eab8dd9bbd9cbd84680?s=50"></div><header><strong>Compiler should generate code base on the functions that have default values</strong> from <string>Jose Cheyo Jimenez</string> &lt;cheyo at masters3d.com&gt;<p>January 17, 2016 at 08:00:00am</p></header><div class="content"><p>This is very interesting. The first case seems like a bug because the<br>compiler should not let you define that function().<br></p><p>Do you have any actual examples when you would need to conform to the same<br>function name but with different signatures?<br></p><p>On Sunday, January 17, 2016, 肇鑫 via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; This proposal is the summary of the previous protocol function default<br>&gt; value proposal and some of my new thinkings all together.<br>&gt;<br>&gt; Currently the compiler doesn&#39;t stop you defining two functions like:<br>&gt;<br>&gt; func printSomething(something:String = &quot;some thing&quot;) {<br>&gt;<br>&gt;     print(something)<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; func printSomething() {<br>&gt;<br>&gt;     print(&quot;some thing!&quot;)<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; However, when you call it, an error arises.<br>&gt;<br>&gt;<br>&gt; printSomething() // Ambiguous use of &#39;printSomething&#39;<br>&gt;<br>&gt;<br>&gt; You may say just remove the function that has no argument. But protocol<br>&gt; needs it.<br>&gt;<br>&gt;<br>&gt; protocol A {<br>&gt;<br>&gt;     func printSomething(something:String)<br>&gt;<br>&gt;     func printSomething()<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; struct Foo:A {<br>&gt;<br>&gt;     func printSomething(something:String) {<br>&gt;<br>&gt;         print(something)<br>&gt;<br>&gt;     }<br>&gt;<br>&gt;<br>&gt;<br>&gt;     func printSomething() {<br>&gt;<br>&gt;         self.printSomething(&quot;some thing&quot;)<br>&gt;<br>&gt;     }<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; If you do&#39;t define the no-argument function in protocol A. You can not use<br>&gt; the function by (Foo() as A).printSomething().<br>&gt;<br>&gt;<br>&gt;<br>&gt; As we all know, a function with default values, can rewrite to two or more<br>&gt; equivalent functions. For example,<br>&gt;<br>&gt;<br>&gt; struct Bar {<br>&gt;<br>&gt;     func add(int1:Int = 1, int2:Int = 2, int3:Int = 3) {<br>&gt;<br>&gt;         print(int1 + int2 + int3)<br>&gt;<br>&gt;     }<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; is equivalent to<br>&gt;<br>&gt;<br>&gt; struct Bar {<br>&gt;<br>&gt;     func add(int1:Int, int2:Int, int3:Int) {<br>&gt;<br>&gt;         print(int1 + int2 + int3)<br>&gt;<br>&gt;     }<br>&gt;<br>&gt;<br>&gt;<br>&gt;     func add() {<br>&gt;<br>&gt;         self.add(1, int2: 2, int3: 3)<br>&gt;<br>&gt;     }<br>&gt;<br>&gt;<br>&gt;<br>&gt;     func add(int1:Int) {<br>&gt;<br>&gt;         self.add(int1, int2: 2, int3: 3)<br>&gt;<br>&gt;     }<br>&gt;<br>&gt;<br>&gt;<br>&gt;     func add(int1:Int, int2:Int) {<br>&gt;<br>&gt;         self.add(int1, int2: int2, int3: 3)<br>&gt;<br>&gt;     }<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; So my proposal is let compiler or pre-compiler to generate the code<br>&gt; internally, without changing the original code,  base on the functions that<br>&gt; have default values.<br>&gt;<br>&gt;<br>&gt; Then we need not to define multiple functions in a protocol when we need<br>&gt; function with default values.<br>&gt;<br>&gt;<br>&gt; new code:<br>&gt;<br>&gt;<br>&gt; protocol A {<br>&gt;<br>&gt;     func printSomething(something:String)<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; struct Foo:A {<br>&gt;<br>&gt;     func printSomething(something:String = &quot;some thing&quot;) {<br>&gt;<br>&gt;         print(something)<br>&gt;<br>&gt;     }<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt;<br>&gt; If we don&#39;t want to change our previous code, we may also need to<br>&gt; introduce another keyword defaultValue. This keyword is used only in a<br>&gt; protocol to restrict if a function&#39;s argument can have a default value. If<br>&gt; a function use it, but the implementation doesn&#39;t give a default value, or<br>&gt; vice versa, an error arises.<br>&gt;<br>&gt;<br>&gt; new code:<br>&gt;<br>&gt;<br>&gt; protocol A {<br>&gt;<br>&gt;     func printSomething(something:String = defaultValue)<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; struct Foo:A {<br>&gt;<br>&gt;     func printSomething(something:String = &quot;some thing&quot;) {<br>&gt;<br>&gt;         print(something)<br>&gt;<br>&gt;     }<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; This keyword is useful. With it, you can still use Swift in old way. Which<br>&gt; means you need not to change code like below if you don&#39;t want to.<br>&gt;<br>&gt;<br>&gt; old code:<br>&gt;<br>&gt;<br>&gt; protocol A {<br>&gt;<br>&gt;     func printSomething(something:String)<br>&gt;<br>&gt;     func printSomething()<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; struct Foo:A {<br>&gt;<br>&gt;     func printSomething(something:String) {<br>&gt;<br>&gt;         print(something)<br>&gt;<br>&gt;     }<br>&gt;<br>&gt;<br>&gt;<br>&gt;     func printSomething() {<br>&gt;<br>&gt;         self.printSomething(&quot;some thing&quot;)<br>&gt;<br>&gt;     }<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; But if you want to write new code. You can just write it in the new<br>&gt; way, enjoining the simpler and clearer.<br>&gt;<br>&gt;<br>&gt; zhaoxin<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160117/871195bf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Compiler should generate code base on the functions that have default values</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>January 17, 2016 at 12:00:00pm</p></header><div class="content"><p>I agree that the compiler should be able to use a function with default values for protocol conformance.<br></p><p>Félix<br></p><p>&gt; Le 17 janv. 2016 à 11:52:06, J. Cheyo Jimenez via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; This is very interesting. The first case seems like a bug because the compiler should not let you define that function(). <br>&gt; <br>&gt; Do you have any actual examples when you would need to conform to the same function name but with different signatures? <br>&gt; <br>&gt; On Sunday, January 17, 2016, 肇鑫 via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; This proposal is the summary of the previous protocol function default value proposal and some of my new thinkings all together.<br>&gt; <br>&gt; Currently the compiler doesn&#39;t stop you defining two functions like:<br>&gt; <br>&gt; func printSomething(something:String = &quot;some thing&quot;) {<br>&gt;     print(something)<br>&gt; }<br>&gt; <br>&gt; func printSomething() {<br>&gt;     print(&quot;some thing!&quot;)<br>&gt; }<br>&gt; <br>&gt; However, when you call it, an error arises.<br>&gt; <br>&gt; printSomething() // Ambiguous use of &#39;printSomething&#39;<br>&gt; <br>&gt; You may say just remove the function that has no argument. But protocol needs it.<br>&gt; <br>&gt; protocol A {<br>&gt;     func printSomething(something:String)<br>&gt;     func printSomething()<br>&gt; }<br>&gt; <br>&gt; struct Foo:A {<br>&gt;     func printSomething(something:String) {<br>&gt;         print(something)<br>&gt;     }<br>&gt;     <br>&gt;     func printSomething() {<br>&gt;         self.printSomething(&quot;some thing&quot;)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; If you do&#39;t define the no-argument function in protocol A. You can not use the function by (Foo() as A).printSomething().<br>&gt; <br>&gt; <br>&gt; As we all know, a function with default values, can rewrite to two or more equivalent functions. For example,<br>&gt; <br>&gt; struct Bar {<br>&gt;     func add(int1:Int = 1, int2:Int = 2, int3:Int = 3) {<br>&gt;         print(int1 + int2 + int3)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; is equivalent to <br>&gt; <br>&gt; struct Bar {<br>&gt;     func add(int1:Int, int2:Int, int3:Int) {<br>&gt;         print(int1 + int2 + int3)<br>&gt;     }<br>&gt;     <br>&gt;     func add() {<br>&gt;         self.add(1, int2: 2, int3: 3)<br>&gt;     }<br>&gt;     <br>&gt;     func add(int1:Int) {<br>&gt;         self.add(int1, int2: 2, int3: 3)<br>&gt;     }<br>&gt;     <br>&gt;     func add(int1:Int, int2:Int) {<br>&gt;         self.add(int1, int2: int2, int3: 3)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; So my proposal is let compiler or pre-compiler to generate the code internally, without changing the original code,  base on the functions that have default values.<br>&gt; <br>&gt; Then we need not to define multiple functions in a protocol when we need function with default values.<br>&gt; <br>&gt; new code:<br>&gt; <br>&gt; protocol A {<br>&gt;     func printSomething(something:String)<br>&gt; }<br>&gt; <br>&gt; struct Foo:A {<br>&gt;     func printSomething(something:String = &quot;some thing&quot;) {<br>&gt;         print(something)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; If we don&#39;t want to change our previous code, we may also need to introduce another keyword defaultValue. This keyword is used only in a protocol to restrict if a function&#39;s argument can have a default value. If a function use it, but the implementation doesn&#39;t give a default value, or vice versa, an error arises.<br>&gt; <br>&gt; new code:<br>&gt; <br>&gt; protocol A {<br>&gt;     func printSomething(something:String = defaultValue)<br>&gt; }<br>&gt; <br>&gt; struct Foo:A {<br>&gt;     func printSomething(something:String = &quot;some thing&quot;) {<br>&gt;         print(something)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; This keyword is useful. With it, you can still use Swift in old way. Which means you need not to change code like below if you don&#39;t want to.<br>&gt; <br>&gt; old code:<br>&gt; <br>&gt; protocol A {<br>&gt;     func printSomething(something:String)<br>&gt;     func printSomething()<br>&gt; }<br>&gt; <br>&gt; struct Foo:A {<br>&gt;     func printSomething(something:String) {<br>&gt;         print(something)<br>&gt;     }<br>&gt;     <br>&gt;     func printSomething() {<br>&gt;         self.printSomething(&quot;some thing&quot;)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; But if you want to write new code. You can just write it in the new way, enjoining the simpler and clearer.<br>&gt; <br>&gt; zhaoxin<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160117/b73d7cfd/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/957b675456a66c394945a7361aedd51d?s=50"></div><header><strong>Compiler should generate code base on the functions that have default values</strong> from <string>Zhao Xin</string> &lt;owenzx at gmail.com&gt;<p>January 18, 2016 at 01:00:00am</p></header><div class="content"><p>It is not to *conform to the same function name but with  different<br>signatures*. It is the protocol limits in current Swift. You can implement<br>a protocol function with default values. But the protocol can&#39;t call the<br>function with the default value. So you have to add another function that<br>has no argument in the protocol and change the implementation.<br></p><p>current code:<br></p><p>protocol A {<br></p><p>    func printSomething(something:String)<br></p><p>}<br></p><p><br>struct Foo:A {<br></p><p>    func printSomething(something:String = &quot;some thing&quot;) {<br></p><p>        print(something)<br></p><p>    }<br></p><p>}<br></p><p><br>Foo().printSomething() // some thing<br></p><p>(Foo() as A).printSomething() // Missing argument for parameter #1 in call<br></p><p><br>default value part is widely discussed in this thread<br>&lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160111/006798.html&gt;,<br>including other approaches like protocol extension.<br></p><p><br>zhaoxin<br></p><p>On Mon, Jan 18, 2016 at 12:52 AM, J. Cheyo Jimenez &lt;cheyo at masters3d.com&gt;<br>wrote:<br></p><p>&gt; This is very interesting. The first case seems like a bug because the<br>&gt; compiler should not let you define that function().<br>&gt;<br>&gt; Do you have any actual examples when you would need to conform to the same<br>&gt; function name but with different signatures?<br>&gt;<br>&gt;<br>&gt; On Sunday, January 17, 2016, 肇鑫 via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; This proposal is the summary of the previous protocol function default<br>&gt;&gt; value proposal and some of my new thinkings all together.<br>&gt;&gt;<br>&gt;&gt; Currently the compiler doesn&#39;t stop you defining two functions like:<br>&gt;&gt;<br>&gt;&gt; func printSomething(something:String = &quot;some thing&quot;) {<br>&gt;&gt;<br>&gt;&gt;     print(something)<br>&gt;&gt;<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; func printSomething() {<br>&gt;&gt;<br>&gt;&gt;     print(&quot;some thing!&quot;)<br>&gt;&gt;<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; However, when you call it, an error arises.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; printSomething() // Ambiguous use of &#39;printSomething&#39;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; You may say just remove the function that has no argument. But protocol<br>&gt;&gt; needs it.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; protocol A {<br>&gt;&gt;<br>&gt;&gt;     func printSomething(something:String)<br>&gt;&gt;<br>&gt;&gt;     func printSomething()<br>&gt;&gt;<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; struct Foo:A {<br>&gt;&gt;<br>&gt;&gt;     func printSomething(something:String) {<br>&gt;&gt;<br>&gt;&gt;         print(something)<br>&gt;&gt;<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     func printSomething() {<br>&gt;&gt;<br>&gt;&gt;         self.printSomething(&quot;some thing&quot;)<br>&gt;&gt;<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; If you do&#39;t define the no-argument function in protocol A. You can not<br>&gt;&gt; use the function by (Foo() as A).printSomething().<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; As we all know, a function with default values, can rewrite to two or<br>&gt;&gt; more equivalent functions. For example,<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; struct Bar {<br>&gt;&gt;<br>&gt;&gt;     func add(int1:Int = 1, int2:Int = 2, int3:Int = 3) {<br>&gt;&gt;<br>&gt;&gt;         print(int1 + int2 + int3)<br>&gt;&gt;<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; is equivalent to<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; struct Bar {<br>&gt;&gt;<br>&gt;&gt;     func add(int1:Int, int2:Int, int3:Int) {<br>&gt;&gt;<br>&gt;&gt;         print(int1 + int2 + int3)<br>&gt;&gt;<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     func add() {<br>&gt;&gt;<br>&gt;&gt;         self.add(1, int2: 2, int3: 3)<br>&gt;&gt;<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     func add(int1:Int) {<br>&gt;&gt;<br>&gt;&gt;         self.add(int1, int2: 2, int3: 3)<br>&gt;&gt;<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     func add(int1:Int, int2:Int) {<br>&gt;&gt;<br>&gt;&gt;         self.add(int1, int2: int2, int3: 3)<br>&gt;&gt;<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; So my proposal is let compiler or pre-compiler to generate the code<br>&gt;&gt; internally, without changing the original code,  base on the functions that<br>&gt;&gt; have default values.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Then we need not to define multiple functions in a protocol when we need<br>&gt;&gt; function with default values.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; new code:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; protocol A {<br>&gt;&gt;<br>&gt;&gt;     func printSomething(something:String)<br>&gt;&gt;<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; struct Foo:A {<br>&gt;&gt;<br>&gt;&gt;     func printSomething(something:String = &quot;some thing&quot;) {<br>&gt;&gt;<br>&gt;&gt;         print(something)<br>&gt;&gt;<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; If we don&#39;t want to change our previous code, we may also need to<br>&gt;&gt; introduce another keyword defaultValue. This keyword is used only in a<br>&gt;&gt; protocol to restrict if a function&#39;s argument can have a default value. If<br>&gt;&gt; a function use it, but the implementation doesn&#39;t give a default value, or<br>&gt;&gt; vice versa, an error arises.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; new code:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; protocol A {<br>&gt;&gt;<br>&gt;&gt;     func printSomething(something:String = defaultValue)<br>&gt;&gt;<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; struct Foo:A {<br>&gt;&gt;<br>&gt;&gt;     func printSomething(something:String = &quot;some thing&quot;) {<br>&gt;&gt;<br>&gt;&gt;         print(something)<br>&gt;&gt;<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; This keyword is useful. With it, you can still use Swift in old way.<br>&gt;&gt; Which means you need not to change code like below if you don&#39;t want to.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; old code:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; protocol A {<br>&gt;&gt;<br>&gt;&gt;     func printSomething(something:String)<br>&gt;&gt;<br>&gt;&gt;     func printSomething()<br>&gt;&gt;<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; struct Foo:A {<br>&gt;&gt;<br>&gt;&gt;     func printSomething(something:String) {<br>&gt;&gt;<br>&gt;&gt;         print(something)<br>&gt;&gt;<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     func printSomething() {<br>&gt;&gt;<br>&gt;&gt;         self.printSomething(&quot;some thing&quot;)<br>&gt;&gt;<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; But if you want to write new code. You can just write it in the new<br>&gt;&gt; way, enjoining the simpler and clearer.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; zhaoxin<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160118/84e1dbd8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>Compiler should generate code base on the functions that have default values</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>January 17, 2016 at 07:00:00pm</p></header><div class="content"><p>Hi Dave,<br></p><p>I agree with 肇鑫. Your issue and his seem like two separate issues, and I’d also like to see his issue implemented. For example, imagine I wanted to define this protocol:<br></p><p>protocol Logger {<br>    func print()<br>    func print(message: String)<br>    func print(path: String)<br>    func print(line: Int)<br>    func print(message: String, path: String)<br>    func print(message: String, line: Int)<br>    func print(path: String, line: Int)<br>    func print(message: String, path: String, line: Int)<br>}<br></p><p>It would be much simpler if I could more simply write:<br></p><p>protocol Logger {<br>    func print(message: String = default, path: String = default, line: Int = default)<br>}<br></p><p>Which is a separate issue then what you propose which would allow the same as the following for init as well:<br></p><p>protocol Logger {<br>    func print(message: String)<br>}<br></p><p>class NSLogger {<br>    func print(message: String, path: String, line: Int) {<br>        // ...<br>    }<br>}<br></p><p>extension NSLogger: Logger {<br>    conformance {<br>        print(message)<br>    }<br>}<br></p><p>&gt; On 17 Jan 2016, at 18:09, 肇鑫 via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; It is not to conform to the same function name but with  different signatures. It is the protocol limits in current Swift. You can implement a protocol function with default values. But the protocol can&#39;t call the function with the default value. So you have to add another function that has no argument in the protocol and change the implementation.<br>&gt; <br>&gt; current code:<br>&gt; <br>&gt; protocol A {<br>&gt;     func printSomething(something:String)<br>&gt; }<br>&gt; <br>&gt; struct Foo:A {<br>&gt;     func printSomething(something:String = &quot;some thing&quot;) {<br>&gt;         print(something)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; Foo().printSomething() // some thing<br>&gt; (Foo() as A).printSomething() // Missing argument for parameter #1 in call<br>&gt; <br>&gt; default value part is widely discussed in this thread &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160111/006798.html&gt;, including other approaches like protocol extension.<br>&gt; <br>&gt; zhaoxin<br>&gt; <br>&gt; On Mon, Jan 18, 2016 at 12:52 AM, J. Cheyo Jimenez &lt;cheyo at masters3d.com &lt;mailto:cheyo at masters3d.com&gt;&gt; wrote:<br>&gt; This is very interesting. The first case seems like a bug because the compiler should not let you define that function(). <br>&gt; <br>&gt; Do you have any actual examples when you would need to conform to the same function name but with different signatures? <br>&gt; <br>&gt; <br>&gt; On Sunday, January 17, 2016, 肇鑫 via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; This proposal is the summary of the previous protocol function default value proposal and some of my new thinkings all together.<br>&gt; <br>&gt; Currently the compiler doesn&#39;t stop you defining two functions like:<br>&gt; <br>&gt; func printSomething(something:String = &quot;some thing&quot;) {<br>&gt;     print(something)<br>&gt; }<br>&gt; <br>&gt; func printSomething() {<br>&gt;     print(&quot;some thing!&quot;)<br>&gt; }<br>&gt; <br>&gt; However, when you call it, an error arises.<br>&gt; <br>&gt; printSomething() // Ambiguous use of &#39;printSomething&#39;<br>&gt; <br>&gt; You may say just remove the function that has no argument. But protocol needs it.<br>&gt; <br>&gt; protocol A {<br>&gt;     func printSomething(something:String)<br>&gt;     func printSomething()<br>&gt; }<br>&gt; <br>&gt; struct Foo:A {<br>&gt;     func printSomething(something:String) {<br>&gt;         print(something)<br>&gt;     }<br>&gt;     <br>&gt;     func printSomething() {<br>&gt;         self.printSomething(&quot;some thing&quot;)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; If you do&#39;t define the no-argument function in protocol A. You can not use the function by (Foo() as A).printSomething().<br>&gt; <br>&gt; <br>&gt; As we all know, a function with default values, can rewrite to two or more equivalent functions. For example,<br>&gt; <br>&gt; struct Bar {<br>&gt;     func add(int1:Int = 1, int2:Int = 2, int3:Int = 3) {<br>&gt;         print(int1 + int2 + int3)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; is equivalent to <br>&gt; <br>&gt; struct Bar {<br>&gt;     func add(int1:Int, int2:Int, int3:Int) {<br>&gt;         print(int1 + int2 + int3)<br>&gt;     }<br>&gt;     <br>&gt;     func add() {<br>&gt;         self.add(1, int2: 2, int3: 3)<br>&gt;     }<br>&gt;     <br>&gt;     func add(int1:Int) {<br>&gt;         self.add(int1, int2: 2, int3: 3)<br>&gt;     }<br>&gt;     <br>&gt;     func add(int1:Int, int2:Int) {<br>&gt;         self.add(int1, int2: int2, int3: 3)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; So my proposal is let compiler or pre-compiler to generate the code internally, without changing the original code,  base on the functions that have default values.<br>&gt; <br>&gt; Then we need not to define multiple functions in a protocol when we need function with default values.<br>&gt; <br>&gt; new code:<br>&gt; <br>&gt; protocol A {<br>&gt;     func printSomething(something:String)<br>&gt; }<br>&gt; <br>&gt; struct Foo:A {<br>&gt;     func printSomething(something:String = &quot;some thing&quot;) {<br>&gt;         print(something)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; If we don&#39;t want to change our previous code, we may also need to introduce another keyword defaultValue. This keyword is used only in a protocol to restrict if a function&#39;s argument can have a default value. If a function use it, but the implementation doesn&#39;t give a default value, or vice versa, an error arises.<br>&gt; <br>&gt; new code:<br>&gt; <br>&gt; protocol A {<br>&gt;     func printSomething(something:String = defaultValue)<br>&gt; }<br>&gt; <br>&gt; struct Foo:A {<br>&gt;     func printSomething(something:String = &quot;some thing&quot;) {<br>&gt;         print(something)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; This keyword is useful. With it, you can still use Swift in old way. Which means you need not to change code like below if you don&#39;t want to.<br>&gt; <br>&gt; old code:<br>&gt; <br>&gt; protocol A {<br>&gt;     func printSomething(something:String)<br>&gt;     func printSomething()<br>&gt; }<br>&gt; <br>&gt; struct Foo:A {<br>&gt;     func printSomething(something:String) {<br>&gt;         print(something)<br>&gt;     }<br>&gt;     <br>&gt;     func printSomething() {<br>&gt;         self.printSomething(&quot;some thing&quot;)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; But if you want to write new code. You can just write it in the new way, enjoining the simpler and clearer.<br>&gt; <br>&gt; zhaoxin<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160117/e7d32590/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>Compiler should generate code base on the functions that have default values</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>January 18, 2016 at 10:00:00am</p></header><div class="content"><p>Similar has been discussed in the topic: &quot;two protocols with the same<br>method name&quot;, it starts here:<br></p><p>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/005673.html<br></p><p>Here&#39;s another solution you may not have considered:<br></p><p>struct Foo:A {<br></p><p>    func printSomething(something:String = &quot;some thing&quot;) {<br></p><p>        print(something)<br></p><p>    }<br></p><p><br>    @implements(A.printSomething)<br></p><p>    private func _printSomething() { self.printSomething() }<br></p><p>}<br></p><p><br>This was derived from the message by Joe Groff, in the linked thread:<br></p><p>&gt; Swift&#39;s protocol conformance model doesn&#39;t rely on the name of the member<br>matching the name of the requirement it satisfies. One possibility here is<br>to introduce an attribute to explicitly declare what protocol<br>requirement(s) a member is intended to satisfy:<br>&gt;<br>&gt; class X: A, B {<br>&gt;   @implements(A.ring)<br>&gt;   var weddingRing: String<br>&gt;<br>&gt;   @implements(B.ring)<br>&gt;   var ringtone: String<br>&gt; }<br>&gt;<br></p><p><br></p><p>On Mon, Jan 18, 2016 at 5:19 AM, David Hart via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hi Dave,<br>&gt;<br>&gt; I agree with 肇鑫. Your issue and his seem like two separate issues, and I’d<br>&gt; also like to see his issue implemented. For example, imagine I wanted to<br>&gt; define this protocol:<br>&gt;<br>&gt; protocol Logger {<br>&gt;     func print()<br>&gt;     func print(message: String)<br>&gt;     func print(path: String)<br>&gt;     func print(line: Int)<br>&gt;     func print(message: String, path: String)<br>&gt;     func print(message: String, line: Int)<br>&gt;     func print(path: String, line: Int)<br>&gt;     func print(message: String, path: String, line: Int)<br>&gt; }<br>&gt;<br>&gt; It would be much simpler if I could more simply write:<br>&gt;<br>&gt; protocol Logger {<br>&gt;     func print(message: String = default, path: String = default, line:<br>&gt; Int = default)<br>&gt; }<br>&gt;<br>&gt; Which is a separate issue then what you propose which would allow the same<br>&gt; as the following for *init* as well:<br>&gt;<br>&gt; protocol Logger {<br>&gt;     func print(message: String)<br>&gt; }<br>&gt;<br>&gt; class NSLogger {<br>&gt;     func print(message: String, path: String, line: Int) {<br>&gt;         // ...<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; extension NSLogger: Logger {<br>&gt;     conformance {<br>&gt;         print(message)<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; On 17 Jan 2016, at 18:09, 肇鑫 via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; It is not to *conform to the same function name but with  different<br>&gt; signatures*. It is the protocol limits in current Swift. You can<br>&gt; implement a protocol function with default values. But the protocol can&#39;t<br>&gt; call the function with the default value. So you have to add another<br>&gt; function that has no argument in the protocol and change the implementation.<br>&gt;<br>&gt; current code:<br>&gt;<br>&gt; protocol A {<br>&gt;     func printSomething(something:String)<br>&gt; }<br>&gt;<br>&gt; struct Foo:A {<br>&gt;     func printSomething(something:String = &quot;some thing&quot;) {<br>&gt;         print(something)<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; Foo().printSomething() // some thing<br>&gt; (Foo() as A).printSomething() // Missing argument for parameter #1 in call<br>&gt;<br>&gt; default value part is widely discussed in this thread<br>&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160111/006798.html&gt;,<br>&gt; including other approaches like protocol extension.<br>&gt;<br>&gt; zhaoxin<br>&gt;<br>&gt; On Mon, Jan 18, 2016 at 12:52 AM, J. Cheyo Jimenez &lt;cheyo at masters3d.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; This is very interesting. The first case seems like a bug because the<br>&gt;&gt; compiler should not let you define that function().<br>&gt;&gt;<br>&gt;&gt; Do you have any actual examples when you would need to conform to the<br>&gt;&gt; same function name but with different signatures?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Sunday, January 17, 2016, 肇鑫 via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; This proposal is the summary of the previous protocol function default<br>&gt;&gt;&gt; value proposal and some of my new thinkings all together.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Currently the compiler doesn&#39;t stop you defining two functions like:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func printSomething(something:String = &quot;some thing&quot;) {<br>&gt;&gt;&gt;     print(something)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func printSomething() {<br>&gt;&gt;&gt;     print(&quot;some thing!&quot;)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; However, when you call it, an error arises.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; printSomething() // Ambiguous use of &#39;printSomething&#39;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; You may say just remove the function that has no argument. But protocol<br>&gt;&gt;&gt; needs it.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; protocol A {<br>&gt;&gt;&gt;     func printSomething(something:String)<br>&gt;&gt;&gt;     func printSomething()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; struct Foo:A {<br>&gt;&gt;&gt;     func printSomething(something:String) {<br>&gt;&gt;&gt;         print(something)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     func printSomething() {<br>&gt;&gt;&gt;         self.printSomething(&quot;some thing&quot;)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If you do&#39;t define the no-argument function in protocol A. You can not<br>&gt;&gt;&gt; use the function by (Foo() as A).printSomething().<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; As we all know, a function with default values, can rewrite to two or<br>&gt;&gt;&gt; more equivalent functions. For example,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; struct Bar {<br>&gt;&gt;&gt;     func add(int1:Int = 1, int2:Int = 2, int3:Int = 3) {<br>&gt;&gt;&gt;         print(int1 + int2 + int3)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; is equivalent to<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; struct Bar {<br>&gt;&gt;&gt;     func add(int1:Int, int2:Int, int3:Int) {<br>&gt;&gt;&gt;         print(int1 + int2 + int3)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     func add() {<br>&gt;&gt;&gt;         self.add(1, int2: 2, int3: 3)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     func add(int1:Int) {<br>&gt;&gt;&gt;         self.add(int1, int2: 2, int3: 3)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     func add(int1:Int, int2:Int) {<br>&gt;&gt;&gt;         self.add(int1, int2: int2, int3: 3)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; So my proposal is let compiler or pre-compiler to generate the code<br>&gt;&gt;&gt; internally, without changing the original code,  base on the functions that<br>&gt;&gt;&gt; have default values.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Then we need not to define multiple functions in a protocol when we need<br>&gt;&gt;&gt; function with default values.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; new code:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; protocol A {<br>&gt;&gt;&gt;     func printSomething(something:String)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; struct Foo:A {<br>&gt;&gt;&gt;     func printSomething(something:String = &quot;some thing&quot;) {<br>&gt;&gt;&gt;         print(something)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If we don&#39;t want to change our previous code, we may also need to<br>&gt;&gt;&gt; introduce another keyword defaultValue. This keyword is used only in a<br>&gt;&gt;&gt; protocol to restrict if a function&#39;s argument can have a default value. If<br>&gt;&gt;&gt; a function use it, but the implementation doesn&#39;t give a default value, or<br>&gt;&gt;&gt; vice versa, an error arises.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; new code:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; protocol A {<br>&gt;&gt;&gt;     func printSomething(something:String = defaultValue)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; struct Foo:A {<br>&gt;&gt;&gt;     func printSomething(something:String = &quot;some thing&quot;) {<br>&gt;&gt;&gt;         print(something)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This keyword is useful. With it, you can still use Swift in old way.<br>&gt;&gt;&gt; Which means you need not to change code like below if you don&#39;t want to.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; old code:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; protocol A {<br>&gt;&gt;&gt;     func printSomething(something:String)<br>&gt;&gt;&gt;     func printSomething()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; struct Foo:A {<br>&gt;&gt;&gt;     func printSomething(something:String) {<br>&gt;&gt;&gt;         print(something)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     func printSomething() {<br>&gt;&gt;&gt;         self.printSomething(&quot;some thing&quot;)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; But if you want to write new code. You can just write it in the new<br>&gt;&gt;&gt; way, enjoining the simpler and clearer.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; zhaoxin<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160118/b89d0158/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/957b675456a66c394945a7361aedd51d?s=50"></div><header><strong>Compiler should generate code base on the functions that have default values</strong> from <string>Zhao Xin</string> &lt;owenzx at gmail.com&gt;<p>January 18, 2016 at 09:00:00am</p></header><div class="content"><p>Sorry Andrew, you link is not related with this proposal.<br></p><p>As you can see, this proposal starts with no protocol at all. It starts<br>with the conflicts between a function with a default value comparing to its<br>version that has no argument. Then this issue combines with the protocol<br>limits becomes a larger issue. But there is no two different protocols with<br>the same properties name here. There is only one protocol from the<br>beginning to the end.<br></p><p>I also discussed in the link your provided. And in my option, this proposal<br>has nothing related with that at all.<br></p><p>zhaoxin<br></p><p>On Mon, Jan 18, 2016 at 7:50 AM, Andrew Bennett &lt;cacoyi at gmail.com&gt; wrote:<br></p><p>&gt; Similar has been discussed in the topic: &quot;two protocols with the same<br>&gt; method name&quot;, it starts here:<br>&gt;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/005673.html<br>&gt;<br>&gt; Here&#39;s another solution you may not have considered:<br>&gt;<br>&gt; struct Foo:A {<br>&gt;<br>&gt;     func printSomething(something:String = &quot;some thing&quot;) {<br>&gt;<br>&gt;         print(something)<br>&gt;<br>&gt;     }<br>&gt;<br>&gt;<br>&gt;     @implements(A.printSomething)<br>&gt;<br>&gt;     private func _printSomething() { self.printSomething() }<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; This was derived from the message by Joe Groff, in the linked thread:<br>&gt;<br>&gt; &gt; Swift&#39;s protocol conformance model doesn&#39;t rely on the name of the<br>&gt; member matching the name of the requirement it satisfies. One possibility<br>&gt; here is to introduce an attribute to explicitly declare what protocol<br>&gt; requirement(s) a member is intended to satisfy:<br>&gt; &gt;<br>&gt; &gt; class X: A, B {<br>&gt; &gt;   @implements(A.ring)<br>&gt; &gt;   var weddingRing: String<br>&gt; &gt;<br>&gt; &gt;   @implements(B.ring)<br>&gt; &gt;   var ringtone: String<br>&gt; &gt; }<br>&gt; &gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Mon, Jan 18, 2016 at 5:19 AM, David Hart via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Hi Dave,<br>&gt;&gt;<br>&gt;&gt; I agree with 肇鑫. Your issue and his seem like two separate issues, and<br>&gt;&gt; I’d also like to see his issue implemented. For example, imagine I wanted<br>&gt;&gt; to define this protocol:<br>&gt;&gt;<br>&gt;&gt; protocol Logger {<br>&gt;&gt;     func print()<br>&gt;&gt;     func print(message: String)<br>&gt;&gt;     func print(path: String)<br>&gt;&gt;     func print(line: Int)<br>&gt;&gt;     func print(message: String, path: String)<br>&gt;&gt;     func print(message: String, line: Int)<br>&gt;&gt;     func print(path: String, line: Int)<br>&gt;&gt;     func print(message: String, path: String, line: Int)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; It would be much simpler if I could more simply write:<br>&gt;&gt;<br>&gt;&gt; protocol Logger {<br>&gt;&gt;     func print(message: String = default, path: String = default, line:<br>&gt;&gt; Int = default)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Which is a separate issue then what you propose which would allow the<br>&gt;&gt; same as the following for *init* as well:<br>&gt;&gt;<br>&gt;&gt; protocol Logger {<br>&gt;&gt;     func print(message: String)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; class NSLogger {<br>&gt;&gt;     func print(message: String, path: String, line: Int) {<br>&gt;&gt;         // ...<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; extension NSLogger: Logger {<br>&gt;&gt;     conformance {<br>&gt;&gt;         print(message)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; On 17 Jan 2016, at 18:09, 肇鑫 via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; It is not to *conform to the same function name but with  different<br>&gt;&gt; signatures*. It is the protocol limits in current Swift. You can<br>&gt;&gt; implement a protocol function with default values. But the protocol can&#39;t<br>&gt;&gt; call the function with the default value. So you have to add another<br>&gt;&gt; function that has no argument in the protocol and change the implementation.<br>&gt;&gt;<br>&gt;&gt; current code:<br>&gt;&gt;<br>&gt;&gt; protocol A {<br>&gt;&gt;     func printSomething(something:String)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; struct Foo:A {<br>&gt;&gt;     func printSomething(something:String = &quot;some thing&quot;) {<br>&gt;&gt;         print(something)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Foo().printSomething() // some thing<br>&gt;&gt; (Foo() as A).printSomething() // Missing argument for parameter #1 in<br>&gt;&gt; call<br>&gt;&gt;<br>&gt;&gt; default value part is widely discussed in this thread<br>&gt;&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160111/006798.html&gt;,<br>&gt;&gt; including other approaches like protocol extension.<br>&gt;&gt;<br>&gt;&gt; zhaoxin<br>&gt;&gt;<br>&gt;&gt; On Mon, Jan 18, 2016 at 12:52 AM, J. Cheyo Jimenez &lt;cheyo at masters3d.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; This is very interesting. The first case seems like a bug because the<br>&gt;&gt;&gt; compiler should not let you define that function().<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Do you have any actual examples when you would need to conform to the<br>&gt;&gt;&gt; same function name but with different signatures?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Sunday, January 17, 2016, 肇鑫 via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This proposal is the summary of the previous protocol function default<br>&gt;&gt;&gt;&gt; value proposal and some of my new thinkings all together.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Currently the compiler doesn&#39;t stop you defining two functions like:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; func printSomething(something:String = &quot;some thing&quot;) {<br>&gt;&gt;&gt;&gt;     print(something)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; func printSomething() {<br>&gt;&gt;&gt;&gt;     print(&quot;some thing!&quot;)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; However, when you call it, an error arises.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; printSomething() // Ambiguous use of &#39;printSomething&#39;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; You may say just remove the function that has no argument. But protocol<br>&gt;&gt;&gt;&gt; needs it.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; protocol A {<br>&gt;&gt;&gt;&gt;     func printSomething(something:String)<br>&gt;&gt;&gt;&gt;     func printSomething()<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; struct Foo:A {<br>&gt;&gt;&gt;&gt;     func printSomething(something:String) {<br>&gt;&gt;&gt;&gt;         print(something)<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     func printSomething() {<br>&gt;&gt;&gt;&gt;         self.printSomething(&quot;some thing&quot;)<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; If you do&#39;t define the no-argument function in protocol A. You can not<br>&gt;&gt;&gt;&gt; use the function by (Foo() as A).printSomething().<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; As we all know, a function with default values, can rewrite to two or<br>&gt;&gt;&gt;&gt; more equivalent functions. For example,<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; struct Bar {<br>&gt;&gt;&gt;&gt;     func add(int1:Int = 1, int2:Int = 2, int3:Int = 3) {<br>&gt;&gt;&gt;&gt;         print(int1 + int2 + int3)<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; is equivalent to<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; struct Bar {<br>&gt;&gt;&gt;&gt;     func add(int1:Int, int2:Int, int3:Int) {<br>&gt;&gt;&gt;&gt;         print(int1 + int2 + int3)<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     func add() {<br>&gt;&gt;&gt;&gt;         self.add(1, int2: 2, int3: 3)<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     func add(int1:Int) {<br>&gt;&gt;&gt;&gt;         self.add(int1, int2: 2, int3: 3)<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     func add(int1:Int, int2:Int) {<br>&gt;&gt;&gt;&gt;         self.add(int1, int2: int2, int3: 3)<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; So my proposal is let compiler or pre-compiler to generate the code<br>&gt;&gt;&gt;&gt; internally, without changing the original code,  base on the functions that<br>&gt;&gt;&gt;&gt; have default values.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Then we need not to define multiple functions in a protocol when we<br>&gt;&gt;&gt;&gt; need function with default values.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; new code:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; protocol A {<br>&gt;&gt;&gt;&gt;     func printSomething(something:String)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; struct Foo:A {<br>&gt;&gt;&gt;&gt;     func printSomething(something:String = &quot;some thing&quot;) {<br>&gt;&gt;&gt;&gt;         print(something)<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; If we don&#39;t want to change our previous code, we may also need to<br>&gt;&gt;&gt;&gt; introduce another keyword defaultValue. This keyword is used only in a<br>&gt;&gt;&gt;&gt; protocol to restrict if a function&#39;s argument can have a default value. If<br>&gt;&gt;&gt;&gt; a function use it, but the implementation doesn&#39;t give a default value, or<br>&gt;&gt;&gt;&gt; vice versa, an error arises.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; new code:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; protocol A {<br>&gt;&gt;&gt;&gt;     func printSomething(something:String = defaultValue)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; struct Foo:A {<br>&gt;&gt;&gt;&gt;     func printSomething(something:String = &quot;some thing&quot;) {<br>&gt;&gt;&gt;&gt;         print(something)<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This keyword is useful. With it, you can still use Swift in old way.<br>&gt;&gt;&gt;&gt; Which means you need not to change code like below if you don&#39;t want to.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; old code:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; protocol A {<br>&gt;&gt;&gt;&gt;     func printSomething(something:String)<br>&gt;&gt;&gt;&gt;     func printSomething()<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; struct Foo:A {<br>&gt;&gt;&gt;&gt;     func printSomething(something:String) {<br>&gt;&gt;&gt;&gt;         print(something)<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     func printSomething() {<br>&gt;&gt;&gt;&gt;         self.printSomething(&quot;some thing&quot;)<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; But if you want to write new code. You can just write it in the new<br>&gt;&gt;&gt;&gt; way, enjoining the simpler and clearer.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; zhaoxin<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160118/d49d2810/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/957b675456a66c394945a7361aedd51d?s=50"></div><header><strong>Compiler should generate code base on the functions that have default values</strong> from <string>Zhao Xin</string> &lt;owenzx at gmail.com&gt;<p>January 18, 2016 at 11:00:00am</p></header><div class="content"><p>Hi David,<br></p><p>You understanding is correct.<br></p><p>There is only one thing I have to mention. Unless the other c style<br>languages which you can call default values in the middle, Swift only<br>allows you to call default values in the last. That makes you example:<br></p><p>func print(message: String = default, path: String = default, line: Int =<br>default)<br></p><p>can only wrapped to 4 functions instead of 8.<br></p><p>func print(message: String, path: String, line: Int)<br>func print()<br>func print(message: String)<br>func print(message: String, path: String)<br></p><p>You can&#39;t call func print(path: String) by calling func print(message:<br>String = default, path: String = default, line: Int = default). print(_,<br>path: &quot;path&quot;t, line: _) is not a valid calling in Swift.<br></p><p>zhaoxin<br></p><p>On Mon, Jan 18, 2016 at 2:19 AM, David Hart &lt;david at hartbit.com&gt; wrote:<br></p><p>&gt; Hi Dave,<br>&gt;<br>&gt; I agree with 肇鑫. Your issue and his seem like two separate issues, and I’d<br>&gt; also like to see his issue implemented. For example, imagine I wanted to<br>&gt; define this protocol:<br>&gt;<br>&gt; protocol Logger {<br>&gt;     func print()<br>&gt;     func print(message: String)<br>&gt;     func print(path: String)<br>&gt;     func print(line: Int)<br>&gt;     func print(message: String, path: String)<br>&gt;     func print(message: String, line: Int)<br>&gt;     func print(path: String, line: Int)<br>&gt;     func print(message: String, path: String, line: Int)<br>&gt; }<br>&gt;<br>&gt; It would be much simpler if I could more simply write:<br>&gt;<br>&gt; protocol Logger {<br>&gt;     func print(message: String = default, path: String = default, line:<br>&gt; Int = default)<br>&gt; }<br>&gt;<br>&gt; Which is a separate issue then what you propose which would allow the same<br>&gt; as the following for *init* as well:<br>&gt;<br>&gt; protocol Logger {<br>&gt;     func print(message: String)<br>&gt; }<br>&gt;<br>&gt; class NSLogger {<br>&gt;     func print(message: String, path: String, line: Int) {<br>&gt;         // ...<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; extension NSLogger: Logger {<br>&gt;     conformance {<br>&gt;         print(message)<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; On 17 Jan 2016, at 18:09, 肇鑫 via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; It is not to *conform to the same function name but with  different<br>&gt; signatures*. It is the protocol limits in current Swift. You can<br>&gt; implement a protocol function with default values. But the protocol can&#39;t<br>&gt; call the function with the default value. So you have to add another<br>&gt; function that has no argument in the protocol and change the implementation.<br>&gt;<br>&gt; current code:<br>&gt;<br>&gt; protocol A {<br>&gt;     func printSomething(something:String)<br>&gt; }<br>&gt;<br>&gt; struct Foo:A {<br>&gt;     func printSomething(something:String = &quot;some thing&quot;) {<br>&gt;         print(something)<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; Foo().printSomething() // some thing<br>&gt; (Foo() as A).printSomething() // Missing argument for parameter #1 in call<br>&gt;<br>&gt; default value part is widely discussed in this thread<br>&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160111/006798.html&gt;,<br>&gt; including other approaches like protocol extension.<br>&gt;<br>&gt; zhaoxin<br>&gt;<br>&gt; On Mon, Jan 18, 2016 at 12:52 AM, J. Cheyo Jimenez &lt;cheyo at masters3d.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; This is very interesting. The first case seems like a bug because the<br>&gt;&gt; compiler should not let you define that function().<br>&gt;&gt;<br>&gt;&gt; Do you have any actual examples when you would need to conform to the<br>&gt;&gt; same function name but with different signatures?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Sunday, January 17, 2016, 肇鑫 via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; This proposal is the summary of the previous protocol function default<br>&gt;&gt;&gt; value proposal and some of my new thinkings all together.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Currently the compiler doesn&#39;t stop you defining two functions like:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func printSomething(something:String = &quot;some thing&quot;) {<br>&gt;&gt;&gt;     print(something)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func printSomething() {<br>&gt;&gt;&gt;     print(&quot;some thing!&quot;)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; However, when you call it, an error arises.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; printSomething() // Ambiguous use of &#39;printSomething&#39;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; You may say just remove the function that has no argument. But protocol<br>&gt;&gt;&gt; needs it.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; protocol A {<br>&gt;&gt;&gt;     func printSomething(something:String)<br>&gt;&gt;&gt;     func printSomething()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; struct Foo:A {<br>&gt;&gt;&gt;     func printSomething(something:String) {<br>&gt;&gt;&gt;         print(something)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     func printSomething() {<br>&gt;&gt;&gt;         self.printSomething(&quot;some thing&quot;)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If you do&#39;t define the no-argument function in protocol A. You can not<br>&gt;&gt;&gt; use the function by (Foo() as A).printSomething().<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; As we all know, a function with default values, can rewrite to two or<br>&gt;&gt;&gt; more equivalent functions. For example,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; struct Bar {<br>&gt;&gt;&gt;     func add(int1:Int = 1, int2:Int = 2, int3:Int = 3) {<br>&gt;&gt;&gt;         print(int1 + int2 + int3)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; is equivalent to<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; struct Bar {<br>&gt;&gt;&gt;     func add(int1:Int, int2:Int, int3:Int) {<br>&gt;&gt;&gt;         print(int1 + int2 + int3)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     func add() {<br>&gt;&gt;&gt;         self.add(1, int2: 2, int3: 3)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     func add(int1:Int) {<br>&gt;&gt;&gt;         self.add(int1, int2: 2, int3: 3)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     func add(int1:Int, int2:Int) {<br>&gt;&gt;&gt;         self.add(int1, int2: int2, int3: 3)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; So my proposal is let compiler or pre-compiler to generate the code<br>&gt;&gt;&gt; internally, without changing the original code,  base on the functions that<br>&gt;&gt;&gt; have default values.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Then we need not to define multiple functions in a protocol when we need<br>&gt;&gt;&gt; function with default values.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; new code:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; protocol A {<br>&gt;&gt;&gt;     func printSomething(something:String)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; struct Foo:A {<br>&gt;&gt;&gt;     func printSomething(something:String = &quot;some thing&quot;) {<br>&gt;&gt;&gt;         print(something)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If we don&#39;t want to change our previous code, we may also need to<br>&gt;&gt;&gt; introduce another keyword defaultValue. This keyword is used only in a<br>&gt;&gt;&gt; protocol to restrict if a function&#39;s argument can have a default value. If<br>&gt;&gt;&gt; a function use it, but the implementation doesn&#39;t give a default value, or<br>&gt;&gt;&gt; vice versa, an error arises.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; new code:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; protocol A {<br>&gt;&gt;&gt;     func printSomething(something:String = defaultValue)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; struct Foo:A {<br>&gt;&gt;&gt;     func printSomething(something:String = &quot;some thing&quot;) {<br>&gt;&gt;&gt;         print(something)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This keyword is useful. With it, you can still use Swift in old way.<br>&gt;&gt;&gt; Which means you need not to change code like below if you don&#39;t want to.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; old code:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; protocol A {<br>&gt;&gt;&gt;     func printSomething(something:String)<br>&gt;&gt;&gt;     func printSomething()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; struct Foo:A {<br>&gt;&gt;&gt;     func printSomething(something:String) {<br>&gt;&gt;&gt;         print(something)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     func printSomething() {<br>&gt;&gt;&gt;         self.printSomething(&quot;some thing&quot;)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; But if you want to write new code. You can just write it in the new<br>&gt;&gt;&gt; way, enjoining the simpler and clearer.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; zhaoxin<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160118/cf93bf26/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Compiler should generate code base on the functions that have default values</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>January 20, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jan 17, 2016, at 19:18 , 肇鑫 via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi David,<br>&gt; <br>&gt; You understanding is correct. <br>&gt; <br>&gt; There is only one thing I have to mention. Unless the other c style languages which you can call default values in the middle, Swift only allows you to call default values in the last. That makes you example:<br>&gt; <br>&gt; func print(message: String = default, path: String = default, line: Int = default)<br>&gt; <br>&gt; can only wrapped to 4 functions instead of 8.<br>&gt; <br>&gt; func print(message: String, path: String, line: Int)<br>&gt; func print()<br>&gt; func print(message: String)<br>&gt; func print(message: String, path: String)<br>&gt; <br>&gt; You can&#39;t call func print(path: String) by calling func print(message: String = default, path: String = default, line: Int = default). print(_, path: &quot;path&quot;t, line: _) is not a valid calling in Swift.<br></p><p>This is not true.<br></p><p>func test(a a: Int = 0, b: Int = 1, c: Int = 2, d: Int = 3) {<br>  print(&quot;\(a) \(b) \(c) \(d)&quot;)<br>}<br>test()<br>test(a: 10)<br>test(b: 10)<br>test(c: 10)<br>test(d: 10)<br>test(b: 20, a: 10)<br>test(a: 10, b: 20, c: 30)<br>test(a: 10, d: 20)<br></p><p>All of these calls are legal.<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160120/63411162/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/957b675456a66c394945a7361aedd51d?s=50"></div><header><strong>Compiler should generate code base on the functions that have default values</strong> from <string>Zhao Xin</string> &lt;owenzx at gmail.com&gt;<p>January 21, 2016 at 09:00:00am</p></header><div class="content"><p>You are right. I didn&#39;t know it can do that way.<br></p><p>There is a note in Swift document<br>&lt;https://developer.apple.com/library/prerelease/mac/documentation/Swift/Conceptual/Swift_Programming_Language/Functions.html&gt;<br>.<br></p><p>NOTE<br>&gt; Place parameters with default values at the end of a function’s parameter<br>&gt; list. This ensures that all calls to the function use the same order for<br>&gt; their nondefault arguments, and makes it clear that the same function is<br>&gt; being called in each case.<br></p><p><br>It makes me think what I did.<br></p><p>zhaoxin<br></p><p>On Thu, Jan 21, 2016 at 5:51 AM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Jan 17, 2016, at 19:18 , 肇鑫 via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Hi David,<br>&gt;<br>&gt; You understanding is correct.<br>&gt;<br>&gt; There is only one thing I have to mention. Unless the other c style<br>&gt; languages which you can call default values in the middle, Swift only<br>&gt; allows you to call default values in the last. That makes you example:<br>&gt;<br>&gt; func print(message: String = default, path: String = default, line: Int =<br>&gt; default)<br>&gt;<br>&gt; can only wrapped to 4 functions instead of 8.<br>&gt;<br>&gt; func print(message: String, path: String, line: Int)<br>&gt; func print()<br>&gt; func print(message: String)<br>&gt; func print(message: String, path: String)<br>&gt;<br>&gt; You can&#39;t call func print(path: String) by calling func print(message:<br>&gt; String = default, path: String = default, line: Int = default). print(_,<br>&gt; path: &quot;path&quot;t, line: _) is not a valid calling in Swift.<br>&gt;<br>&gt;<br>&gt; This is not true.<br>&gt;<br>&gt; func test(a a: Int = 0, b: Int = 1, c: Int = 2, d: Int = 3) {<br>&gt;   print(&quot;\(a) \(b) \(c) \(d)&quot;)<br>&gt; }<br>&gt; test()<br>&gt; test(a: 10)<br>&gt; test(b: 10)<br>&gt; test(c: 10)<br>&gt; test(d: 10)<br>&gt; test(b: 20, a: 10)<br>&gt; test(a: 10, b: 20, c: 30)<br>&gt; test(a: 10, d: 20)<br>&gt;<br>&gt;<br>&gt; All of these calls are legal.<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160121/6ffaf2e6/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
