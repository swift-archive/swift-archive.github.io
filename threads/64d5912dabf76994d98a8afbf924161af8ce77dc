<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a9d2257812ec9c0a45414c06d8f544ee?s=50"></div><header><strong>Random() in the standard library</strong> from <string>James Andrews</string> &lt;james at enigmanorth.com&gt;<p>June 24, 2016 at 06:00:00am</p></header><div class="content"><p>Hi,<br></p><p>Is there a reason why random() is missing from the standard library? Is<br>it just a matter of someone implementing it?<br></p><p>Thanks,<br>James<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Random() in the standard library</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>July  2, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Jun 24, 2016, at 6:38 AM, James Andrews via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Is there a reason why random() is missing from the standard library? Is<br>&gt; it just a matter of someone implementing it?<br></p><p>(Note: I&#39;m just a guy, not someone in a leadership position.)<br></p><p>Random number generation is surprisingly complicated:<br></p><p>* Is it a truly random number generator or a pseudorandom one?<br>* If it&#39;s truly random:<br>	* Where are we getting the random data?<br>	* Does it require platform-specific code?<br>	* Is there I/O involved?<br>* If it&#39;s pseudorandom:<br>	* What&#39;s our goal here—cryptography, statistics, both, neither? Cryptographic PRNGs are slow for statistics, but statistical PRNGs break the security of crypto algorithms.<br>	* What algorithm?<br>	* Does it use shared state, or do you initialize your own RNG instance?<br>	* If it&#39;s shared:<br>		* How does it behave under concurrency?<br>		* Can you change the seed?<br>	* If it&#39;s not shared:<br>		* Can you seed it?<br>		* How big is the seed?<br>		* Where does the default seed come from?<br>		* Can you save and restore the state?<br></p><p>The Swift standard library is deep in very narrow, fundamental areas: features requiring compiler support, control flow, basic types, fundamental string handling, and sequences and collections. There&#39;s just barely enough console I/O and argument support to write a very basic command-line program. There&#39;s no file I/O, no concurrency, no networking, not even environment variables. Those things come from Foundation or from other libraries.<br></p><p>Random-number generation is another one of those things that Swift leaves to libraries. It is complicated, platform-specific (but not generally architecture-specific), subject to app-specific requirements, implementable in userspace, and does not require compiler support. Ultimately, it simply *does not need to be part of the language* in the way the things in the standard library are. If we wanted to make a protocol for random number generators, we would pretty much just end up with Sequence or Collection, and we already have those sitting in the standard library. The rest is finicky details we can leave to platform creators, library implementors, and users while we work on the things only we can do, like improving our numeric protocols so we can support BigInts and BigFloats.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Random() in the standard library</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>July  2, 2016 at 11:00:00pm</p></header><div class="content"><p>I am also just a random guy, and I agree with much of what Brent says, but my personal opinion is that the standard library should be allowed to grow in the future to encompass areas whose generality and usefulness are comparable to those of current standard library constructs. I would consider a sufficiently well-designed suite of PRNGs to fall into this category.<br></p><p>I guess what I&#39;m saying is that, after Swift 3.0 is released, someone (maybe you!) should develop an argument as to why PRNGs belong in the standard library, and pitch it to the swift-evolution list. The worst that can happen is that people (or the core team) disagrees on principle, and at least you have an answer. But if there&#39;s interest a proposal can be drafted and taken to the review stage, at which point it&#39;ll be considered and possibly accepted.<br></p><p>Best,<br>Austin<br></p><p>&gt; On Jul 2, 2016, at 11:30 PM, Brent Royal-Gordon via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Jun 24, 2016, at 6:38 AM, James Andrews via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Is there a reason why random() is missing from the standard library? Is<br>&gt;&gt; it just a matter of someone implementing it?<br>&gt; <br>&gt; (Note: I&#39;m just a guy, not someone in a leadership position.)<br>&gt; <br>&gt; Random number generation is surprisingly complicated:<br>&gt; <br>&gt; * Is it a truly random number generator or a pseudorandom one?<br>&gt; * If it&#39;s truly random:<br>&gt; 	* Where are we getting the random data?<br>&gt; 	* Does it require platform-specific code?<br>&gt; 	* Is there I/O involved?<br>&gt; * If it&#39;s pseudorandom:<br>&gt; 	* What&#39;s our goal here—cryptography, statistics, both, neither? Cryptographic PRNGs are slow for statistics, but statistical PRNGs break the security of crypto algorithms.<br>&gt; 	* What algorithm?<br>&gt; 	* Does it use shared state, or do you initialize your own RNG instance?<br>&gt; 	* If it&#39;s shared:<br>&gt; 		* How does it behave under concurrency?<br>&gt; 		* Can you change the seed?<br>&gt; 	* If it&#39;s not shared:<br>&gt; 		* Can you seed it?<br>&gt; 		* How big is the seed?<br>&gt; 		* Where does the default seed come from?<br>&gt; 		* Can you save and restore the state?<br>&gt; <br>&gt; The Swift standard library is deep in very narrow, fundamental areas: features requiring compiler support, control flow, basic types, fundamental string handling, and sequences and collections. There&#39;s just barely enough console I/O and argument support to write a very basic command-line program. There&#39;s no file I/O, no concurrency, no networking, not even environment variables. Those things come from Foundation or from other libraries.<br>&gt; <br>&gt; Random-number generation is another one of those things that Swift leaves to libraries. It is complicated, platform-specific (but not generally architecture-specific), subject to app-specific requirements, implementable in userspace, and does not require compiler support. Ultimately, it simply *does not need to be part of the language* in the way the things in the standard library are. If we wanted to make a protocol for random number generators, we would pretty much just end up with Sequence or Collection, and we already have those sitting in the standard library. The rest is finicky details we can leave to platform creators, library implementors, and users while we work on the things only we can do, like improving our numeric protocols so we can support BigInts and BigFloats.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a9d2257812ec9c0a45414c06d8f544ee?s=50"></div><header><strong>Random() in the standard library</strong> from <string>James Andrews</string> &lt;james at enigmanorth.com&gt;<p>July  3, 2016 at 01:00:00pm</p></header><div class="content"><p>Thanks for the feedback. I agree in that I believe the standard library should be able to grow. I think a PRNG implementation is a sufficiently “atomic” building block to be included in the standard library for a modern language these days. <br></p><p>As to the implementation, would it not be foolish to stray to far from the already well proven,  existing well understood PRNG implementations?<br></p><p>Thanks,<br>James<br></p><p><br>On 3 July 2016 at 07:46:16, Austin Zheng (austinzheng at gmail.com) wrote:<br></p><p>I am also just a random guy, and I agree with much of what Brent says, but my personal opinion is that the standard library should be allowed to grow in the future to encompass areas whose generality and usefulness are comparable to those of current standard library constructs. I would consider a sufficiently well-designed suite of PRNGs to fall into this category.  <br></p><p>I guess what I&#39;m saying is that, after Swift 3.0 is released, someone (maybe you!) should develop an argument as to why PRNGs belong in the standard library, and pitch it to the swift-evolution list. The worst that can happen is that people (or the core team) disagrees on principle, and at least you have an answer. But if there&#39;s interest a proposal can be drafted and taken to the review stage, at which point it&#39;ll be considered and possibly accepted.  <br></p><p>Best,  <br>Austin  <br></p><p>&gt; On Jul 2, 2016, at 11:30 PM, Brent Royal-Gordon via swift-dev &lt;swift-dev at swift.org&gt; wrote:  <br>&gt;  <br>&gt;&gt; On Jun 24, 2016, at 6:38 AM, James Andrews via swift-dev &lt;swift-dev at swift.org&gt; wrote:  <br>&gt;&gt;  <br>&gt;&gt; Is there a reason why random() is missing from the standard library? Is  <br>&gt;&gt; it just a matter of someone implementing it?  <br>&gt;  <br>&gt; (Note: I&#39;m just a guy, not someone in a leadership position.)  <br>&gt;  <br>&gt; Random number generation is surprisingly complicated:  <br>&gt;  <br>&gt; * Is it a truly random number generator or a pseudorandom one?  <br>&gt; * If it&#39;s truly random:  <br>&gt; * Where are we getting the random data?  <br>&gt; * Does it require platform-specific code?  <br>&gt; * Is there I/O involved?  <br>&gt; * If it&#39;s pseudorandom:  <br>&gt; * What&#39;s our goal here—cryptography, statistics, both, neither? Cryptographic PRNGs are slow for statistics, but statistical PRNGs break the security of crypto algorithms.  <br>&gt; * What algorithm?  <br>&gt; * Does it use shared state, or do you initialize your own RNG instance?  <br>&gt; * If it&#39;s shared:  <br>&gt; * How does it behave under concurrency?  <br>&gt; * Can you change the seed?  <br>&gt; * If it&#39;s not shared:  <br>&gt; * Can you seed it?  <br>&gt; * How big is the seed?  <br>&gt; * Where does the default seed come from?  <br>&gt; * Can you save and restore the state?  <br>&gt;  <br>&gt; The Swift standard library is deep in very narrow, fundamental areas: features requiring compiler support, control flow, basic types, fundamental string handling, and sequences and collections. There&#39;s just barely enough console I/O and argument support to write a very basic command-line program. There&#39;s no file I/O, no concurrency, no networking, not even environment variables. Those things come from Foundation or from other libraries.  <br>&gt;  <br>&gt; Random-number generation is another one of those things that Swift leaves to libraries. It is complicated, platform-specific (but not generally architecture-specific), subject to app-specific requirements, implementable in userspace, and does not require compiler support. Ultimately, it simply *does not need to be part of the language* in the way the things in the standard library are. If we wanted to make a protocol for random number generators, we would pretty much just end up with Sequence or Collection, and we already have those sitting in the standard library. The rest is finicky details we can leave to platform creators, library implementors, and users while we work on the things only we can do, like improving our numeric protocols so we can support BigInts and BigFloats.  <br>&gt;  <br>&gt; --  <br>&gt; Brent Royal-Gordon  <br>&gt; Architechies  <br>&gt;  <br>&gt; _______________________________________________  <br>&gt; swift-dev mailing list  <br>&gt; swift-dev at swift.org  <br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev  <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160703/935a8b44/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>Random() in the standard library</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>July  3, 2016 at 11:00:00am</p></header><div class="content"><p>Trouble is, most modern languages disagree with that and have chosen to split them out of their standard libraries.<br></p><p>- Rust https://github.com/rust-lang-nursery/rand<br>- Go https://golang.org/pkg/math/rand/<br>- Dart https://api.dartlang.org/stable/1.17.1/dart-math/Random-class.html<br>- Elm https://github.com/jcollard/elm-random<br>- Haskell http://hackage.haskell.org/package/random-1.1/docs/System-Random.html#<br></p><p>As far as I can see, recent languages that do have [P]RNGs in their standard libraries are the ones that rely on massive STLs: Clojure, Scala, (java.*), C#, F# (.NET), Python, Ruby, (built-ins.  Perhaps by virtue of their implementations in C).<br></p><p>Speaking as someone that has had to write such a control for a library, I don&#39;t think it should be included, at least not yet.  Not because it&#39;s not useful, but because there doesn&#39;t seem to be a concrete plan for how it will work here to suit more than one use-case (&quot;gimme a random number&quot;).  [P]RNGs are not one-size-fits-all and if the community upholds one particular implementation, it will uphold not just the good but the bad of the invariants it carries with it.  Better to let the community offer a wide selection of algorithms and interfaces and let the user pick than let them reach for a tailor-made tool for a broad class of functionality.<br></p><p>~Robert Widmann<br></p><p>2016/07/03 5:37、James Andrews via swift-dev &lt;swift-dev at swift.org&gt; のメッセージ:<br></p><p>&gt; Thanks for the feedback. I agree in that I believe the standard library should be able to grow. I think a PRNG implementation is a sufficiently “atomic” building block to be included in the standard library for a modern language these days. <br>&gt; <br>&gt; As to the implementation, would it not be foolish to stray to far from the already well proven,  existing well understood PRNG implementations?<br>&gt; <br>&gt; Thanks,<br>&gt; James<br>&gt; <br>&gt; <br>&gt;&gt; On 3 July 2016 at 07:46:16, Austin Zheng (austinzheng at gmail.com) wrote:<br>&gt;&gt; <br>&gt;&gt; I am also just a random guy, and I agree with much of what Brent says, but my personal opinion is that the standard library should be allowed to grow in the future to encompass areas whose generality and usefulness are comparable to those of current standard library constructs. I would consider a sufficiently well-designed suite of PRNGs to fall into this category. <br>&gt;&gt; <br>&gt;&gt; I guess what I&#39;m saying is that, after Swift 3.0 is released, someone (maybe you!) should develop an argument as to why PRNGs belong in the standard library, and pitch it to the swift-evolution list. The worst that can happen is that people (or the core team) disagrees on principle, and at least you have an answer. But if there&#39;s interest a proposal can be drafted and taken to the review stage, at which point it&#39;ll be considered and possibly accepted. <br>&gt;&gt; <br>&gt;&gt; Best, <br>&gt;&gt; Austin <br>&gt;&gt; <br>&gt;&gt; &gt; On Jul 2, 2016, at 11:30 PM, Brent Royal-Gordon via swift-dev &lt;swift-dev at swift.org&gt; wrote: <br>&gt;&gt; &gt; <br>&gt;&gt; &gt;&gt; On Jun 24, 2016, at 6:38 AM, James Andrews via swift-dev &lt;swift-dev at swift.org&gt; wrote: <br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; Is there a reason why random() is missing from the standard library? Is <br>&gt;&gt; &gt;&gt; it just a matter of someone implementing it? <br>&gt;&gt; &gt; <br>&gt;&gt; &gt; (Note: I&#39;m just a guy, not someone in a leadership position.) <br>&gt;&gt; &gt; <br>&gt;&gt; &gt; Random number generation is surprisingly complicated: <br>&gt;&gt; &gt; <br>&gt;&gt; &gt; * Is it a truly random number generator or a pseudorandom one? <br>&gt;&gt; &gt; * If it&#39;s truly random: <br>&gt;&gt; &gt; * Where are we getting the random data? <br>&gt;&gt; &gt; * Does it require platform-specific code? <br>&gt;&gt; &gt; * Is there I/O involved? <br>&gt;&gt; &gt; * If it&#39;s pseudorandom: <br>&gt;&gt; &gt; * What&#39;s our goal here―cryptography, statistics, both, neither? Cryptographic PRNGs are slow for statistics, but statistical PRNGs break the security of crypto algorithms. <br>&gt;&gt; &gt; * What algorithm? <br>&gt;&gt; &gt; * Does it use shared state, or do you initialize your own RNG instance? <br>&gt;&gt; &gt; * If it&#39;s shared: <br>&gt;&gt; &gt; * How does it behave under concurrency? <br>&gt;&gt; &gt; * Can you change the seed? <br>&gt;&gt; &gt; * If it&#39;s not shared: <br>&gt;&gt; &gt; * Can you seed it? <br>&gt;&gt; &gt; * How big is the seed? <br>&gt;&gt; &gt; * Where does the default seed come from? <br>&gt;&gt; &gt; * Can you save and restore the state? <br>&gt;&gt; &gt; <br>&gt;&gt; &gt; The Swift standard library is deep in very narrow, fundamental areas: features requiring compiler support, control flow, basic types, fundamental string handling, and sequences and collections. There&#39;s just barely enough console I/O and argument support to write a very basic command-line program. There&#39;s no file I/O, no concurrency, no networking, not even environment variables. Those things come from Foundation or from other libraries. <br>&gt;&gt; &gt; <br>&gt;&gt; &gt; Random-number generation is another one of those things that Swift leaves to libraries. It is complicated, platform-specific (but not generally architecture-specific), subject to app-specific requirements, implementable in userspace, and does not require compiler support. Ultimately, it simply *does not need to be part of the language* in the way the things in the standard library are. If we wanted to make a protocol for random number generators, we would pretty much just end up with Sequence or Collection, and we already have those sitting in the standard library. The rest is finicky details we can leave to platform creators, library implementors, and users while we work on the things only we can do, like improving our numeric protocols so we can support BigInts and BigFloats. <br>&gt;&gt; &gt; <br>&gt;&gt; &gt; -- <br>&gt;&gt; &gt; Brent Royal-Gordon <br>&gt;&gt; &gt; Architechies <br>&gt;&gt; &gt; <br>&gt;&gt; &gt; _______________________________________________ <br>&gt;&gt; &gt; swift-dev mailing list <br>&gt;&gt; &gt; swift-dev at swift.org <br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160703/25f98362/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/00464d59365595ecaebd19b44de312fa?s=50"></div><header><strong>Random() in the standard library</strong> from <string>Gwynne Raskind</string> &lt;gwynne at darkrainfall.org&gt;<p>July  4, 2016 at 08:00:00am</p></header><div class="content"><p>C++11 defines PRNGs in the STL, but even then the API is fairly complex thanks to the need for so many different options for source, distribution, seeds, security... - and it *still* doesn’t cover all of what I consider the obvious cases (YMMV).<br></p><p>I agree with Robert here, Swift isn’t ready to have that heavy a functionality be part of its core library. For that matter, I question if it’s even a question of readiness so much as one of the API being suitable to a stdlib at all! Having the basic tools available via Darwin/Glibc and/or Foundation is plenty. If you have a need for stronger guarantees in your entropy than you can get from the common functions like rand, random, *rand48, arc4random, etc., it’s unlikely that any stdlib-provided option is going to meet your needs anyway.<br></p><p>I mean, not that I don’t wish there was something like ***SSL’s RAND functionality around, but that just underscores the heck out of how much this is something that belongs in its own library and is too heavy for the stdlib. A coherent, vaguely safe API for randomness is nontrivial, to say the least.<br></p><p>In fact, the strongest argument against it is that it’s just too easy for novices to shoot themselves in the foot with a builtin PRNG. Swift is supposed to make it *harder* to write broken unsafe code, not easier. And that’s not even considering that of the available OS-level functions only random_r() explicitly provides a thread-safety guarantee (so it’s even *easier* for users to mess themselves up without even realizing it, especially with libdispatch being so awesome in Swift 3).<br></p><p>Swift shouldn&#39;t promote the use of RNGs by users who don&#39;t understand their pitfalls, and adding it to the stdlib does just that. At least forcing users to explicitly call into C APIs, or find existing libraries which have hopefully already focused their time on these considerations, adds an extra step that will ideally lead them to be a bit more conservative - C is &quot;hard mode&quot; from Swift’s POV. (One could argue that it’ll instead encourage them to roll their own insecure implementations, but that’ll happen with or without a builtin API so why make it easier?)<br></p><p>-- Gwynne Raskind<br>More magic than a mere signature can contain<br></p><p><br>&gt; On Jul 3, 2016, at 13:27, Robert Widmann via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Trouble is, most modern languages disagree with that and have chosen to split them out of their standard libraries.<br>&gt; <br>&gt; - Rust https://github.com/rust-lang-nursery/rand &lt;https://github.com/rust-lang-nursery/rand&gt;<br>&gt; - Go https://golang.org/pkg/math/rand/ &lt;https://golang.org/pkg/math/rand/&gt;<br>&gt; - Dart https://api.dartlang.org/stable/1.17.1/dart-math/Random-class.html &lt;https://api.dartlang.org/stable/1.17.1/dart-math/Random-class.html&gt;<br>&gt; - Elm https://github.com/jcollard/elm-random &lt;https://github.com/jcollard/elm-random&gt;<br>&gt; - Haskell http://hackage.haskell.org/package/random-1.1/docs/System-Random.html# &lt;http://hackage.haskell.org/package/random-1.1/docs/System-Random.html#&gt;<br>&gt; <br>&gt; As far as I can see, recent languages that do have [P]RNGs in their standard libraries are the ones that rely on massive STLs: Clojure, Scala, (java.*), C#, F# (.NET), Python, Ruby, (built-ins.  Perhaps by virtue of their implementations in C).<br>&gt; <br>&gt; Speaking as someone that has had to write such a control for a library, I don&#39;t think it should be included, at least not yet.  Not because it&#39;s not useful, but because there doesn&#39;t seem to be a concrete plan for how it will work here to suit more than one use-case (&quot;gimme a random number&quot;).  [P]RNGs are not one-size-fits-all and if the community upholds one particular implementation, it will uphold not just the good but the bad of the invariants it carries with it.  Better to let the community offer a wide selection of algorithms and interfaces and let the user pick than let them reach for a tailor-made tool for a broad class of functionality.<br>&gt; <br>&gt; ~Robert Widmann<br>&gt; <br>&gt; 2016/07/03 5:37、James Andrews via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; のメッセージ:<br>&gt; <br>&gt;&gt; Thanks for the feedback. I agree in that I believe the standard library should be able to grow. I think a PRNG implementation is a sufficiently “atomic” building block to be included in the standard library for a modern language these days. <br>&gt;&gt; <br>&gt;&gt; As to the implementation, would it not be foolish to stray to far from the already well proven,  existing well understood PRNG implementations?<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; James<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On 3 July 2016 at 07:46:16, Austin Zheng (austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;) wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; I am also just a random guy, and I agree with much of what Brent says, but my personal opinion is that the standard library should be allowed to grow in the future to encompass areas whose generality and usefulness are comparable to those of current standard library constructs. I would consider a sufficiently well-designed suite of PRNGs to fall into this category. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I guess what I&#39;m saying is that, after Swift 3.0 is released, someone (maybe you!) should develop an argument as to why PRNGs belong in the standard library, and pitch it to the swift-evolution list. The worst that can happen is that people (or the core team) disagrees on principle, and at least you have an answer. But if there&#39;s interest a proposal can be drafted and taken to the review stage, at which point it&#39;ll be considered and possibly accepted. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Best, <br>&gt;&gt;&gt; Austin <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; On Jul 2, 2016, at 11:30 PM, Brent Royal-Gordon via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote: <br>&gt;&gt;&gt; &gt;  <br>&gt;&gt;&gt; &gt;&gt; On Jun 24, 2016, at 6:38 AM, James Andrews via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote: <br>&gt;&gt;&gt; &gt;&gt;  <br>&gt;&gt;&gt; &gt;&gt; Is there a reason why random() is missing from the standard library? Is <br>&gt;&gt;&gt; &gt;&gt; it just a matter of someone implementing it? <br>&gt;&gt;&gt; &gt;  <br>&gt;&gt;&gt; &gt; (Note: I&#39;m just a guy, not someone in a leadership position.) <br>&gt;&gt;&gt; &gt;  <br>&gt;&gt;&gt; &gt; Random number generation is surprisingly complicated: <br>&gt;&gt;&gt; &gt;  <br>&gt;&gt;&gt; &gt; * Is it a truly random number generator or a pseudorandom one? <br>&gt;&gt;&gt; &gt; * If it&#39;s truly random: <br>&gt;&gt;&gt; &gt; * Where are we getting the random data? <br>&gt;&gt;&gt; &gt; * Does it require platform-specific code? <br>&gt;&gt;&gt; &gt; * Is there I/O involved? <br>&gt;&gt;&gt; &gt; * If it&#39;s pseudorandom: <br>&gt;&gt;&gt; &gt; * What&#39;s our goal here―cryptography, statistics, both, neither? Cryptographic PRNGs are slow for statistics, but statistical PRNGs break the security of crypto algorithms. <br>&gt;&gt;&gt; &gt; * What algorithm? <br>&gt;&gt;&gt; &gt; * Does it use shared state, or do you initialize your own RNG instance? <br>&gt;&gt;&gt; &gt; * If it&#39;s shared: <br>&gt;&gt;&gt; &gt; * How does it behave under concurrency? <br>&gt;&gt;&gt; &gt; * Can you change the seed? <br>&gt;&gt;&gt; &gt; * If it&#39;s not shared: <br>&gt;&gt;&gt; &gt; * Can you seed it? <br>&gt;&gt;&gt; &gt; * How big is the seed? <br>&gt;&gt;&gt; &gt; * Where does the default seed come from? <br>&gt;&gt;&gt; &gt; * Can you save and restore the state? <br>&gt;&gt;&gt; &gt;  <br>&gt;&gt;&gt; &gt; The Swift standard library is deep in very narrow, fundamental areas: features requiring compiler support, control flow, basic types, fundamental string handling, and sequences and collections. There&#39;s just barely enough console I/O and argument support to write a very basic command-line program. There&#39;s no file I/O, no concurrency, no networking, not even environment variables. Those things come from Foundation or from other libraries. <br>&gt;&gt;&gt; &gt;  <br>&gt;&gt;&gt; &gt; Random-number generation is another one of those things that Swift leaves to libraries. It is complicated, platform-specific (but not generally architecture-specific), subject to app-specific requirements, implementable in userspace, and does not require compiler support. Ultimately, it simply *does not need to be part of the language* in the way the things in the standard library are. If we wanted to make a protocol for random number generators, we would pretty much just end up with Sequence or Collection, and we already have those sitting in the standard library. The rest is finicky details we can leave to platform creators, library implementors, and users while we work on the things only we can do, like improving our numeric protocols so we can support BigInts and BigFloats. <br>&gt;&gt;&gt; &gt;  <br>&gt;&gt;&gt; &gt; --  <br>&gt;&gt;&gt; &gt; Brent Royal-Gordon <br>&gt;&gt;&gt; &gt; Architechies <br>&gt;&gt;&gt; &gt;  <br>&gt;&gt;&gt; &gt; _______________________________________________ <br>&gt;&gt;&gt; &gt; swift-dev mailing list <br>&gt;&gt;&gt; &gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt; <br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160704/f90ef769/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a9d2257812ec9c0a45414c06d8f544ee?s=50"></div><header><strong>Random() in the standard library</strong> from <string>James Andrews</string> &lt;james at enigmanorth.com&gt;<p>July  4, 2016 at 07:00:00am</p></header><div class="content"><p>Hi All,<br>  <br>Thanks a lot for the quality feedback. I think that not only answers my<br>question, but has also swayed me in the direction of not having Random()<br>in the standard library.  At least for now.<br>  <br>My original thinking was along the lines of what you suggest in that<br>leaving it out might encourage people to build bad implementations.  But<br>you&#39;re point is valid, people will probably do that anyway if they feel<br>so inclined.<br>  <br>Whilst I still think it might be a good building block and having a<br>solid PRNG in the stnd library may make sense down the road, it seems<br>there are so many good reasons to leave this up to another library.  Its<br>clearly not as straight forward as my original thinking suggested.<br> Thanks very much for the detailed responses!<br>  <br>--<br>  James Andrews<br>  james at enigmanorth.com<br>  <br>  <br>  <br>On Mon, Jul 4, 2016, at 06:37 AM, Gwynne Raskind wrote: <br>&gt; C++11 defines PRNGs in the STL, but even then the API is fairly<br>&gt; complex thanks to the need for so many different options for source,<br>&gt; distribution, seeds, security... - and it *still* doesn’t cover all of<br>&gt; what I consider the obvious cases (YMMV).<br>&gt;<br>&gt; I agree with Robert here, Swift isn’t ready to have that heavy a<br>&gt; functionality be part of its core library. For that matter, I question<br>&gt; if it’s even a question of readiness so much as one of the API being<br>&gt; suitable to a stdlib at all! Having the basic tools available via<br>&gt; Darwin/Glibc and/or Foundation is plenty. If you have a need for<br>&gt; stronger guarantees in your entropy than you can get from the common<br>&gt; functions like rand, random, *rand48, arc4random, etc., it’s unlikely<br>&gt; that any stdlib-provided option is going to meet your needs anyway.<br>&gt;<br>&gt; I mean, not that I don’t wish there was something like ***SSL’s RAND<br>&gt; functionality around, but that just underscores the heck out of how<br>&gt; much this is something that belongs in its own library and is too<br>&gt; heavy for the stdlib. A coherent, vaguely safe API for randomness is<br>&gt; nontrivial, to say the least.<br>&gt;<br>&gt; In fact, the strongest argument against it is that it’s just too easy<br>&gt; for novices to shoot themselves in the foot with a builtin PRNG. Swift<br>&gt; is supposed to make it *harder* to write broken unsafe code, not<br>&gt; easier. And that’s not even considering that of the available OS-level<br>&gt; functions only random_r() explicitly provides a thread-safety<br>&gt; guarantee (so it’s even *easier* for users to mess themselves up<br>&gt; without even realizing it, especially with libdispatch being so<br>&gt; awesome in Swift 3).<br>&gt;<br>&gt; Swift shouldn&#39;t promote the use of RNGs by users who don&#39;t understand<br>&gt; their pitfalls, and adding it to the stdlib does just that. At least<br>&gt; forcing users to explicitly call into C APIs, or find existing<br>&gt; libraries which have hopefully already focused their time on these<br>&gt; considerations, adds an extra step that will ideally lead them to be a<br>&gt; bit more conservative - C is &quot;hard mode&quot; from Swift’s POV. (One could<br>&gt; argue that it’ll instead encourage them to roll their own insecure<br>&gt; implementations, but that’ll happen with or without a builtin API so<br>&gt; why make it easier?)<br>&gt;<br>&gt; -- Gwynne Raskind<br>&gt; More magic than a mere signature can contain<br>&gt;<br>&gt;<br>&gt;&gt; On Jul 3, 2016, at 13:27, Robert Widmann via swift-dev &lt;swift-<br>&gt;&gt; dev at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Trouble is, most modern languages disagree with that and have chosen<br>&gt;&gt; to split them out of their standard libraries.<br>&gt;&gt;<br>&gt;&gt; - Rust https://github.com/rust-lang-nursery/rand<br>&gt;&gt; - Go https://golang.org/pkg/math/rand/<br>&gt;&gt; - Dart<br>&gt;&gt;   https://api.dartlang.org/stable/1.17.1/dart-math/Random-class.html<br>&gt;&gt; - Elm https://github.com/jcollard/elm-random<br>&gt;&gt; - Haskell<br>&gt;&gt;   http://hackage.haskell.org/package/random-1.1/docs/System-Random.html#<br>&gt;&gt;<br>&gt;&gt; As far as I can see, recent languages that do have [P]RNGs in their<br>&gt;&gt; standard libraries are the ones that rely on massive STLs: Clojure,<br>&gt;&gt; Scala, (java.*), C#, F# (.NET), Python, Ruby, (built-ins.  Perhaps by<br>&gt;&gt; virtue of their implementations in C).<br>&gt;&gt;<br>&gt;&gt; Speaking as someone that has had to write such a control for a<br>&gt;&gt; library, I don&#39;t think it should be included, at least not yet.  Not<br>&gt;&gt; because it&#39;s not useful, but because there doesn&#39;t seem to be a<br>&gt;&gt; concrete plan for how it will work here to suit more than one use-<br>&gt;&gt; case (&quot;gimme a random number&quot;).  [P]RNGs are not one-size-fits-all<br>&gt;&gt; and if the community upholds one particular implementation, it will<br>&gt;&gt; uphold not just the good but the bad of the invariants it carries<br>&gt;&gt; with it.  Better to let the community offer a wide selection of<br>&gt;&gt; algorithms and interfaces and let the user pick than let them reach<br>&gt;&gt; for a tailor-made tool for a broad class of functionality.<br>&gt;&gt;<br>&gt;&gt; ~Robert Widmann<br>&gt;&gt;<br>&gt;&gt; 2016/07/03 5:37、James Andrews via swift-dev &lt;swift-dev at swift.org&gt;<br>&gt;&gt; のメッセージ:<br>&gt;&gt;&gt; Thanks for the feedback. I agree in that I believe the standard<br>&gt;&gt;&gt; library should be able to grow. I think a PRNG implementation is a<br>&gt;&gt;&gt; sufficiently “atomic” building block to be included in the standard<br>&gt;&gt;&gt; library for a modern language these days.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; As to the implementation, would it not be foolish to stray to far<br>&gt;&gt;&gt; from the already well proven,  existing well understood PRNG<br>&gt;&gt;&gt; implementations?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt; James<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On 3 July 2016 at 07:46:16, Austin Zheng (austinzheng at gmail.com)<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I am also just a random guy, and I agree with much of what Brent<br>&gt;&gt;&gt;&gt; says, but my personal opinion is that the standard library should<br>&gt;&gt;&gt;&gt; be allowed to grow in the future to encompass areas whose<br>&gt;&gt;&gt;&gt; generality and usefulness are comparable to those of current<br>&gt;&gt;&gt;&gt; standard library constructs. I would consider a sufficiently well-<br>&gt;&gt;&gt;&gt; designed suite of PRNGs to fall into this category.  &gt;&gt;&gt;&gt;  &gt;&gt;&gt;&gt; I<br>&gt;&gt;&gt;&gt; guess what I&#39;m saying is that, after Swift 3.0 is released, someone<br>&gt;&gt;&gt;&gt; (maybe you!) should develop an argument as to why PRNGs belong in<br>&gt;&gt;&gt;&gt; the standard library, and pitch it to the swift-evolution list. The<br>&gt;&gt;&gt;&gt; worst that can happen is that people (or the core team) disagrees<br>&gt;&gt;&gt;&gt; on principle, and at least you have an answer. But if there&#39;s<br>&gt;&gt;&gt;&gt; interest a proposal can be drafted and taken to the review stage,<br>&gt;&gt;&gt;&gt; at which point it&#39;ll be considered and possibly accepted.  &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt; Best,  &gt;&gt;&gt;&gt; Austin  &gt;&gt;&gt;&gt;  &gt;&gt;&gt;&gt; &gt; On Jul 2, 2016, at 11:30 PM,<br>&gt;&gt;&gt;&gt; Brent Royal-Gordon via swift-dev &lt;swift-dev at swift.org&gt; wrote:  &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;   &gt;&gt;&gt;&gt; &gt;&gt; On Jun 24, 2016, at 6:38 AM, James Andrews via swift-<br>&gt;&gt;&gt;&gt; dev &lt;swift-dev at swift.org&gt; wrote:  &gt;&gt;&gt;&gt; &gt;&gt;   &gt;&gt;&gt;&gt; &gt;&gt; Is there a<br>&gt;&gt;&gt;&gt; reason why random() is missing from the standard library? Is  &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; it just a matter of someone implementing it?  &gt;&gt;&gt;&gt; &gt;   &gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; (Note: I&#39;m just a guy, not someone in a leadership position.)  &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;   &gt;&gt;&gt;&gt; &gt; Random number generation is surprisingly complicated:<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt; &gt;   &gt;&gt;&gt;&gt; &gt; * Is it a truly random number generator or a<br>&gt;&gt;&gt;&gt; pseudorandom one?  &gt;&gt;&gt;&gt; &gt; * If it&#39;s truly random:  &gt;&gt;&gt;&gt; &gt; * Where<br>&gt;&gt;&gt;&gt; are we getting the random data?  &gt;&gt;&gt;&gt; &gt; * Does it require platform-<br>&gt;&gt;&gt;&gt; specific code?  &gt;&gt;&gt;&gt; &gt; * Is there I/O involved?  &gt;&gt;&gt;&gt; &gt; * If it&#39;s<br>&gt;&gt;&gt;&gt; pseudorandom:  &gt;&gt;&gt;&gt; &gt; * What&#39;s our goal here―cryptography,<br>&gt;&gt;&gt;&gt; statistics, both, neither? Cryptographic PRNGs are slow for<br>&gt;&gt;&gt;&gt; statistics, but statistical PRNGs break the security of crypto<br>&gt;&gt;&gt;&gt; algorithms.  &gt;&gt;&gt;&gt; &gt; * What algorithm?  &gt;&gt;&gt;&gt; &gt; * Does it use shared<br>&gt;&gt;&gt;&gt; state, or do you initialize your own RNG instance?  &gt;&gt;&gt;&gt; &gt; * If<br>&gt;&gt;&gt;&gt; it&#39;s shared:  &gt;&gt;&gt;&gt; &gt; * How does it behave under concurrency?  &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt; * Can you change the seed?  &gt;&gt;&gt;&gt; &gt; * If it&#39;s not shared:  &gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; * Can you seed it?  &gt;&gt;&gt;&gt; &gt; * How big is the seed?  &gt;&gt;&gt;&gt; &gt; * Where<br>&gt;&gt;&gt;&gt; does the default seed come from?  &gt;&gt;&gt;&gt; &gt; * Can you save and restore<br>&gt;&gt;&gt;&gt; the state?  &gt;&gt;&gt;&gt; &gt;   &gt;&gt;&gt;&gt; &gt; The Swift standard library is deep in<br>&gt;&gt;&gt;&gt; very narrow, fundamental areas: features requiring compiler<br>&gt;&gt;&gt;&gt; support, control flow, basic types, fundamental string handling,<br>&gt;&gt;&gt;&gt; and sequences and collections. There&#39;s just barely enough console<br>&gt;&gt;&gt;&gt; I/O and argument support to write a very basic command-line<br>&gt;&gt;&gt;&gt; program. There&#39;s no file I/O, no concurrency, no networking, not<br>&gt;&gt;&gt;&gt; even environment variables. Those things come from Foundation or<br>&gt;&gt;&gt;&gt; from other libraries.  &gt;&gt;&gt;&gt; &gt;   &gt;&gt;&gt;&gt; &gt; Random-number generation is<br>&gt;&gt;&gt;&gt; another one of those things that Swift leaves to libraries. It is<br>&gt;&gt;&gt;&gt; complicated, platform-specific (but not generally architecture-<br>&gt;&gt;&gt;&gt; specific), subject to app-specific requirements, implementable in<br>&gt;&gt;&gt;&gt; userspace, and does not require compiler support. Ultimately, it<br>&gt;&gt;&gt;&gt; simply *does not need to be part of the language* in the way the<br>&gt;&gt;&gt;&gt; things in the standard library are. If we wanted to make a protocol<br>&gt;&gt;&gt;&gt; for random number generators, we would pretty much just end up with<br>&gt;&gt;&gt;&gt; Sequence or Collection, and we already have those sitting in the<br>&gt;&gt;&gt;&gt; standard library. The rest is finicky details we can leave to<br>&gt;&gt;&gt;&gt; platform creators, library implementors, and users while we work on<br>&gt;&gt;&gt;&gt; the things only we can do, like improving our numeric protocols so<br>&gt;&gt;&gt;&gt; we can support BigInts and BigFloats.  &gt;&gt;&gt;&gt; &gt;   &gt;&gt;&gt;&gt; &gt; --   &gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; Brent Royal-Gordon  &gt;&gt;&gt;&gt; &gt; Architechies  &gt;&gt;&gt;&gt; &gt;   &gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; _______________________________________________  &gt;&gt;&gt;&gt; &gt; swift-dev<br>&gt;&gt;&gt;&gt; mailing list  &gt;&gt;&gt;&gt; &gt; swift-dev at swift.org  &gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt; swift-dev at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br> <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160704/adb3ef3a/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
