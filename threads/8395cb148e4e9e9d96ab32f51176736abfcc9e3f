<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>Typealiases in protocols and protocol extensions</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>May  9, 2016 at 01:00:00am</p></header><div class="content"><p>Hello,<br></p><p>I’ve come again with another proposal directly from the Generics Manifesto. Please let me know if it needs any modifications before sending the pull request.<br></p><p>Typealiases in protocols and protocol extensions<br></p><p>Proposal: SE-XXXX &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md&gt;<br>Authors: David Hart &lt;https://github.com/hartbit&gt;, Doug Gregor &lt;https://github.com/DougGregor&gt;<br>Status: TBD<br>Review manager: TBD<br> &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#introduction&gt;Introduction<br></p><p>This proposal is from the Generics Manifesto &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md&gt; and brings the typealias keyword back into protocols for type aliasing.<br></p><p> &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#motivation&gt;Motivation<br></p><p>In Swift versions prior to 2.2, the typelias keyword was used outside of protocols to declare type aliases and in protocols to declare associated types. Since SE-0011 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0011-replace-typealias-associated.md&gt; and Swift 2.2, associated type now use the associatedtype keyword and typelias is available for implementing true associated type aliases. <br></p><p> &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#proposed-solution&gt;Proposed solution<br></p><p>The solution allows the creation of associated type aliases. Here is an example from the standard library:<br></p><p>protocol Sequence {<br>  associatedtype Iterator : IteratorProtocol<br>  typealias Element = Iterator.Element<br>}<br>The example above shows how this simplifies referencing indirect associated types:<br></p><p>func sum&lt;T: Sequence where T.Element == Int&gt;(sequence: T) -&gt; Int {<br>    return sequence.reduce(0, combine: +)<br>}<br> &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#detailed-design&gt;Detailed design<br></p><p>The following grammar rules needs to be added:<br></p><p>protocol-member-declaration → protocol-typealias-declaration<br></p><p>protocol-typealias-declaration → typealias-declaration<br></p><p> &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#impact-on-existing-code&gt;Impact on existing code<br></p><p>This will have no impact on existing code, but will probably require improving the Fix-It that was created for migrating typealias to associatedtype in Swift 2.2.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160509/83959e3f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Typealiases in protocols and protocol extensions</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May  9, 2016 at 05:00:00am</p></header><div class="content"><p>If the protocol Sequence has typealias Element, does that mean I also have<br>MyConformingSequence.Element?<br></p><p>If so, I think there is a potential impact on existing code not mentioned.<br>Suppose MyConformingSequence already (unwisely) declares typealias Element.<br>Now, what happens when I try to migrate my code to your proposed version of<br>Swift?<br></p><p>This is a toy example, of course. More generally, though, I wonder about<br>this question:<br></p><p>Suppose two protocols A and B each declare typealias Element. These<br>typealiases are, as you proposed, intended to simplify referencing indirect<br>associated types. But are they themselves considered protocol requirements?<br></p><p>I ask because, suppose I want to conform type T to A and B. I implement all<br>the required methods and properties for such conformance. I declare the<br>appropriate typealiases for the associatedtypes declared in both protocols.<br>But, if A.Element and B.Element are incompatible with each other, it is<br>nonetheless impossible to conform T to both A and B? If it&#39;s forbidden,<br>isn&#39;t that kind of a bummer, since what&#39;s getting in the way is a naming<br>clash arising from a facility intended to simplify the naming of things<br>rather than provide for new functionality? If it&#39;s permitted, what is<br>T.Element? Some clarity here would be nice.<br>On Sun, May 8, 2016 at 6:17 PM David Hart via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hello,<br>&gt;<br>&gt; I’ve come again with another proposal directly from the Generics<br>&gt; Manifesto. Please let me know if it needs any modifications before sending<br>&gt; the pull request.<br>&gt;<br>&gt; Typealiases in protocols and protocol extensions<br>&gt;<br>&gt;    - Proposal: SE-XXXX<br>&gt;    &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md&gt;<br>&gt;    - Authors: David Hart &lt;https://github.com/hartbit&gt;, Doug Gregor<br>&gt;    &lt;https://github.com/DougGregor&gt;<br>&gt;    - Status: TBD<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; This proposal is from the Generics Manifesto<br>&gt; &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md&gt; and<br>&gt; brings the typealias keyword back into protocols for type aliasing.<br>&gt;<br>&gt; &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#motivation&gt;<br>&gt; Motivation<br>&gt;<br>&gt; In Swift versions prior to 2.2, the typelias keyword was used outside of<br>&gt; protocols to declare type aliases and in protocols to declare associated<br>&gt; types. Since SE-0011<br>&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0011-replace-typealias-associated.md&gt; and<br>&gt; Swift 2.2, associated type now use the associatedtype keyword and typelias is<br>&gt; available for implementing true associated type aliases.<br>&gt;<br>&gt; &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#proposed-solution&gt;Proposed<br>&gt; solution<br>&gt;<br>&gt; The solution allows the creation of associated type aliases. Here is an<br>&gt; example from the standard library:<br>&gt;<br>&gt; protocol Sequence {<br>&gt;   associatedtype Iterator : IteratorProtocol<br>&gt;   typealias Element = Iterator.Element<br>&gt; }<br>&gt;<br>&gt; The example above shows how this simplifies referencing indirect<br>&gt; associated types:<br>&gt;<br>&gt; func sum&lt;T: Sequence where T.Element == Int&gt;(sequence: T) -&gt; Int {<br>&gt;     return sequence.reduce(0, combine: +)<br>&gt; }<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#detailed-design&gt;Detailed<br>&gt; design<br>&gt;<br>&gt; The following grammar rules needs to be added:<br>&gt;<br>&gt; *protocol-member-declaration* → *protocol-typealias-declaration*<br>&gt;<br>&gt; *protocol-typealias-declaration* → *typealias-declaration*<br>&gt;<br>&gt; &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#impact-on-existing-code&gt;Impact<br>&gt; on existing code<br>&gt; This will have no impact on existing code, but will probably require<br>&gt; improving the Fix-It that was created for migrating typealias to<br>&gt; associatedtype in Swift 2.2.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160509/e6ba77f1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>Typealiases in protocols and protocol extensions</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>May  9, 2016 at 07:00:00am</p></header><div class="content"><p>Hello Xiaodi,<br></p><p>What I mean by there is no impact on existing code is that the language change has no impact. Of course, if the Standard Library then declares a typealias Element in Sequence, it will clash with code which has declared an Element typealias in sub-protocols, but that is separate from the proposal.<br></p><p>&gt; On 09 May 2016, at 07:28, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; If the protocol Sequence has typealias Element, does that mean I also have MyConformingSequence.Element?<br>&gt; <br>&gt; If so, I think there is a potential impact on existing code not mentioned. Suppose MyConformingSequence already (unwisely) declares typealias Element. Now, what happens when I try to migrate my code to your proposed version of Swift?<br>&gt; <br>&gt; This is a toy example, of course. More generally, though, I wonder about this question:<br>&gt; <br>&gt; Suppose two protocols A and B each declare typealias Element. These typealiases are, as you proposed, intended to simplify referencing indirect associated types. But are they themselves considered protocol requirements?<br>&gt; <br>&gt; I ask because, suppose I want to conform type T to A and B. I implement all the required methods and properties for such conformance. I declare the appropriate typealiases for the associatedtypes declared in both protocols. But, if A.Element and B.Element are incompatible with each other, it is nonetheless impossible to conform T to both A and B? If it&#39;s forbidden, isn&#39;t that kind of a bummer, since what&#39;s getting in the way is a naming clash arising from a facility intended to simplify the naming of things rather than provide for new functionality? If it&#39;s permitted, what is T.Element? Some clarity here would be nice.<br>&gt; On Sun, May 8, 2016 at 6:17 PM David Hart via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Hello,<br>&gt; <br>&gt; I’ve come again with another proposal directly from the Generics Manifesto. Please let me know if it needs any modifications before sending the pull request.<br>&gt; <br>&gt; Typealiases in protocols and protocol extensions<br>&gt; <br>&gt; Proposal: SE-XXXX &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md&gt;<br>&gt; Authors: David Hart &lt;https://github.com/hartbit&gt;, Doug Gregor &lt;https://github.com/DougGregor&gt;<br>&gt; Status: TBD<br>&gt; Review manager: TBD<br>&gt;  &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#introduction&gt;Introduction<br>&gt; <br>&gt; This proposal is from the Generics Manifesto &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md&gt; and brings the typealias keyword back into protocols for type aliasing.<br>&gt; <br>&gt;  &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#motivation&gt;Motivation<br>&gt; <br>&gt; In Swift versions prior to 2.2, the typelias keyword was used outside of protocols to declare type aliases and in protocols to declare associated types. Since SE-0011 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0011-replace-typealias-associated.md&gt; and Swift 2.2, associated type now use the associatedtype keyword and typelias is available for implementing true associated type aliases. <br>&gt; <br>&gt;  &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt; The solution allows the creation of associated type aliases. Here is an example from the standard library:<br>&gt; <br>&gt; protocol Sequence {<br>&gt;   associatedtype Iterator : IteratorProtocol<br>&gt;   typealias Element = Iterator.Element<br>&gt; }<br>&gt; The example above shows how this simplifies referencing indirect associated types:<br>&gt; <br>&gt; func sum&lt;T: Sequence where T.Element == Int&gt;(sequence: T) -&gt; Int {<br>&gt;     return sequence.reduce(0, combine: +)<br>&gt; }<br>&gt;  &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#detailed-design&gt;Detailed design<br>&gt; <br>&gt; The following grammar rules needs to be added:<br>&gt; <br>&gt; protocol-member-declaration → protocol-typealias-declaration<br>&gt; <br>&gt; protocol-typealias-declaration → typealias-declaration<br>&gt; <br>&gt;  &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; This will have no impact on existing code, but will probably require improving the Fix-It that was created for migrating typealias to associatedtype in Swift 2.2.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160509/97fb308c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Typealiases in protocols and protocol extensions</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May  9, 2016 at 06:00:00am</p></header><div class="content"><p>I see your point that nothing breaks in the stdlib with your proposal<br>alone. It&#39;s undeniably true--by construction!--that a purely additive<br>feature, if never used, will not cause problems.<br></p><p>That said, since the time that this feature was outlined in Doug&#39;s<br>manifesto, I have been wondering how clashes such as the examples in my<br>previous email are to be handled--i.e. what the rules of the language are<br>to be--which I think is certainly germane to your proposal. Can a<br>conforming type override a protocol typealias? Can a type conform to two<br>protocols with conflicting typealiases if all requirements are otherwise<br>satisfied? Surely, these merit discussion in your proposal.<br></p><p>On Mon, May 9, 2016 at 12:48 AM David Hart &lt;david at hartbit.com&gt; wrote:<br></p><p>&gt; Hello Xiaodi,<br>&gt;<br>&gt; What I mean by there is no impact on existing code is that the language<br>&gt; change has no impact. Of course, if the Standard Library then declares a<br>&gt; typealias Element in Sequence, it will clash with code which has declared<br>&gt; an Element typealias in sub-protocols, but that is separate from the<br>&gt; proposal.<br>&gt;<br>&gt; On 09 May 2016, at 07:28, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; If the protocol Sequence has typealias Element, does that mean I also have<br>&gt; MyConformingSequence.Element?<br>&gt;<br>&gt; If so, I think there is a potential impact on existing code not mentioned.<br>&gt; Suppose MyConformingSequence already (unwisely) declares typealias Element.<br>&gt; Now, what happens when I try to migrate my code to your proposed version of<br>&gt; Swift?<br>&gt;<br>&gt; This is a toy example, of course. More generally, though, I wonder about<br>&gt; this question:<br>&gt;<br>&gt; Suppose two protocols A and B each declare typealias Element. These<br>&gt; typealiases are, as you proposed, intended to simplify referencing indirect<br>&gt; associated types. But are they themselves considered protocol requirements?<br>&gt;<br>&gt; I ask because, suppose I want to conform type T to A and B. I implement<br>&gt; all the required methods and properties for such conformance. I declare the<br>&gt; appropriate typealiases for the associatedtypes declared in both protocols.<br>&gt; But, if A.Element and B.Element are incompatible with each other, it is<br>&gt; nonetheless impossible to conform T to both A and B? If it&#39;s forbidden,<br>&gt; isn&#39;t that kind of a bummer, since what&#39;s getting in the way is a naming<br>&gt; clash arising from a facility intended to simplify the naming of things<br>&gt; rather than provide for new functionality? If it&#39;s permitted, what is<br>&gt; T.Element? Some clarity here would be nice.<br>&gt; On Sun, May 8, 2016 at 6:17 PM David Hart via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Hello,<br>&gt;&gt;<br>&gt;&gt; I’ve come again with another proposal directly from the Generics<br>&gt;&gt; Manifesto. Please let me know if it needs any modifications before sending<br>&gt;&gt; the pull request.<br>&gt;&gt;<br>&gt;&gt; Typealiases in protocols and protocol extensions<br>&gt;&gt;<br>&gt;&gt;    - Proposal: SE-XXXX<br>&gt;&gt;    &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md&gt;<br>&gt;&gt;    - Authors: David Hart &lt;https://github.com/hartbit&gt;, Doug Gregor<br>&gt;&gt;    &lt;https://github.com/DougGregor&gt;<br>&gt;&gt;    - Status: TBD<br>&gt;&gt;    - Review manager: TBD<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#introduction&gt;<br>&gt;&gt; Introduction<br>&gt;&gt;<br>&gt;&gt; This proposal is from the Generics Manifesto<br>&gt;&gt; &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md&gt; and<br>&gt;&gt; brings the typealias keyword back into protocols for type aliasing.<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#motivation&gt;<br>&gt;&gt; Motivation<br>&gt;&gt;<br>&gt;&gt; In Swift versions prior to 2.2, the typelias keyword was used outside of<br>&gt;&gt; protocols to declare type aliases and in protocols to declare associated<br>&gt;&gt; types. Since SE-0011<br>&gt;&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0011-replace-typealias-associated.md&gt; and<br>&gt;&gt; Swift 2.2, associated type now use the associatedtype keyword and<br>&gt;&gt; typelias is available for implementing true associated type aliases.<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#proposed-solution&gt;Proposed<br>&gt;&gt; solution<br>&gt;&gt;<br>&gt;&gt; The solution allows the creation of associated type aliases. Here is an<br>&gt;&gt; example from the standard library:<br>&gt;&gt;<br>&gt;&gt; protocol Sequence {<br>&gt;&gt;   associatedtype Iterator : IteratorProtocol<br>&gt;&gt;   typealias Element = Iterator.Element<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; The example above shows how this simplifies referencing indirect<br>&gt;&gt; associated types:<br>&gt;&gt;<br>&gt;&gt; func sum&lt;T: Sequence where T.Element == Int&gt;(sequence: T) -&gt; Int {<br>&gt;&gt;     return sequence.reduce(0, combine: +)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#detailed-design&gt;Detailed<br>&gt;&gt; design<br>&gt;&gt;<br>&gt;&gt; The following grammar rules needs to be added:<br>&gt;&gt;<br>&gt;&gt; *protocol-member-declaration* → *protocol-typealias-declaration*<br>&gt;&gt;<br>&gt;&gt; *protocol-typealias-declaration* → *typealias-declaration*<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#impact-on-existing-code&gt;Impact<br>&gt;&gt; on existing code<br>&gt;&gt; This will have no impact on existing code, but will probably require<br>&gt;&gt; improving the Fix-It that was created for migrating typealias to<br>&gt;&gt; associatedtype in Swift 2.2.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160509/07c98bb8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>Typealiases in protocols and protocol extensions</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>May  9, 2016 at 08:00:00am</p></header><div class="content"><p>I understand that name clashing in those instances is important to discuss, but I still think it is slightly orthogonal to the proposal. Let me try to explain why.<br></p><p>If typealises in protocols are to have the same semantics as alises outside protocols (as I think they should), then they don’t change anything about the rules of collision. For example, the problem already exists today with associated types:<br></p><p>protocol Foo {<br>    associatedtype Inner: IntegerType<br>    func foo(inner: Inner)<br>}<br></p><p>protocol Bar {<br>    associatedtype Inner: FloatingPointType<br>    var inner: Inner { get }<br>}<br></p><p>struct FooBarImpl: Foo, Bar { // error: Type ‘FooBarImpl’ does not conform to protocol ‘Bar&#39;<br>    func foo(inner: Int) {}<br>    var inner: Float<br>}<br></p><p>Type aliasing would not change anything about the fact that those collisions already exists in the language and are not very well handled: either they are meant to be forbidden but in that case we need better diagnostics, or we want to have a way to work around them. Perhaps you’d like to start a discussion around fixing that ?<br></p><p>&gt; On 09 May 2016, at 08:06, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; I see your point that nothing breaks in the stdlib with your proposal alone. It&#39;s undeniably true--by construction!--that a purely additive feature, if never used, will not cause problems.<br>&gt; <br>&gt; That said, since the time that this feature was outlined in Doug&#39;s manifesto, I have been wondering how clashes such as the examples in my previous email are to be handled--i.e. what the rules of the language are to be--which I think is certainly germane to your proposal. Can a conforming type override a protocol typealias? Can a type conform to two protocols with conflicting typealiases if all requirements are otherwise satisfied? Surely, these merit discussion in your proposal.<br>&gt; <br>&gt; On Mon, May 9, 2016 at 12:48 AM David Hart &lt;david at hartbit.com &lt;mailto:david at hartbit.com&gt;&gt; wrote:<br>&gt; Hello Xiaodi,<br>&gt; <br>&gt; What I mean by there is no impact on existing code is that the language change has no impact. Of course, if the Standard Library then declares a typealias Element in Sequence, it will clash with code which has declared an Element typealias in sub-protocols, but that is separate from the proposal.<br>&gt; <br>&gt;&gt; On 09 May 2016, at 07:28, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; If the protocol Sequence has typealias Element, does that mean I also have MyConformingSequence.Element?<br>&gt;&gt; <br>&gt;&gt; If so, I think there is a potential impact on existing code not mentioned. Suppose MyConformingSequence already (unwisely) declares typealias Element. Now, what happens when I try to migrate my code to your proposed version of Swift?<br>&gt;&gt; <br>&gt;&gt; This is a toy example, of course. More generally, though, I wonder about this question:<br>&gt;&gt; <br>&gt;&gt; Suppose two protocols A and B each declare typealias Element. These typealiases are, as you proposed, intended to simplify referencing indirect associated types. But are they themselves considered protocol requirements?<br>&gt;&gt; <br>&gt;&gt; I ask because, suppose I want to conform type T to A and B. I implement all the required methods and properties for such conformance. I declare the appropriate typealiases for the associatedtypes declared in both protocols. But, if A.Element and B.Element are incompatible with each other, it is nonetheless impossible to conform T to both A and B? If it&#39;s forbidden, isn&#39;t that kind of a bummer, since what&#39;s getting in the way is a naming clash arising from a facility intended to simplify the naming of things rather than provide for new functionality? If it&#39;s permitted, what is T.Element? Some clarity here would be nice.<br>&gt;&gt; On Sun, May 8, 2016 at 6:17 PM David Hart via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Hello,<br>&gt;&gt; <br>&gt;&gt; I’ve come again with another proposal directly from the Generics Manifesto. Please let me know if it needs any modifications before sending the pull request.<br>&gt;&gt; <br>&gt;&gt; Typealiases in protocols and protocol extensions<br>&gt;&gt; <br>&gt;&gt; Proposal: SE-XXXX &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md&gt;<br>&gt;&gt; Authors: David Hart &lt;https://github.com/hartbit&gt;, Doug Gregor &lt;https://github.com/DougGregor&gt;<br>&gt;&gt; Status: TBD<br>&gt;&gt; Review manager: TBD<br>&gt;&gt;  &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#introduction&gt;Introduction<br>&gt;&gt; <br>&gt;&gt; This proposal is from the Generics Manifesto &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md&gt; and brings the typealias keyword back into protocols for type aliasing.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#motivation&gt;Motivation<br>&gt;&gt; <br>&gt;&gt; In Swift versions prior to 2.2, the typelias keyword was used outside of protocols to declare type aliases and in protocols to declare associated types. Since SE-0011 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0011-replace-typealias-associated.md&gt; and Swift 2.2, associated type now use the associatedtype keyword and typelias is available for implementing true associated type aliases. <br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#proposed-solution&gt;Proposed solution<br>&gt;&gt; <br>&gt;&gt; The solution allows the creation of associated type aliases. Here is an example from the standard library:<br>&gt;&gt; <br>&gt;&gt; protocol Sequence {<br>&gt;&gt;   associatedtype Iterator : IteratorProtocol<br>&gt;&gt;   typealias Element = Iterator.Element<br>&gt;&gt; }<br>&gt;&gt; The example above shows how this simplifies referencing indirect associated types:<br>&gt;&gt; <br>&gt;&gt; func sum&lt;T: Sequence where T.Element == Int&gt;(sequence: T) -&gt; Int {<br>&gt;&gt;     return sequence.reduce(0, combine: +)<br>&gt;&gt; }<br>&gt;&gt;  &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#detailed-design&gt;Detailed design<br>&gt;&gt; <br>&gt;&gt; The following grammar rules needs to be added:<br>&gt;&gt; <br>&gt;&gt; protocol-member-declaration → protocol-typealias-declaration<br>&gt;&gt; <br>&gt;&gt; protocol-typealias-declaration → typealias-declaration<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt; <br>&gt;&gt; This will have no impact on existing code, but will probably require improving the Fix-It that was created for migrating typealias to associatedtype in Swift 2.2.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160509/d4e3d61b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Typealiases in protocols and protocol extensions</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May  9, 2016 at 07:00:00am</p></header><div class="content"><p>I agree with you that similar issues exist with the status quo. I&#39;m not<br>asking that you fix them with your proposal, just that you document how<br>your proposed feature will work--i.e. please include some of this stuff you<br>just wrote here somewhere in the proposal text.<br></p><p>Your question to the list solicited suggestions for modifications to your<br>proposal. Mine is to flesh out &quot;proposed solution&quot; and/or &quot;detailed<br>design.&quot; In &quot;proposed solution,&quot; you describe how what you&#39;re proposing<br>would be useful based on a lone example. Elsewhere, under &quot;motivation&quot; you<br>write that you&#39;re proposing &quot;true associated type aliases&quot;--what, exactly,<br>is that? how does it interact with type aliases in conforming types and in<br>sub-protocols? can they be overridden? can they be masked like non-default<br>methods in protocol extensions are currently? I don&#39;t really have a beef<br>with the proposal whether the answers are yes or no, but I&#39;d like to know<br>what the answers are by reading the proposal.<br></p><p>On Mon, May 9, 2016 at 01:52 David Hart &lt;david at hartbit.com&gt; wrote:<br></p><p>&gt; I understand that name clashing in those instances is important to<br>&gt; discuss, but I still think it is slightly orthogonal to the proposal. Let<br>&gt; me try to explain why.<br>&gt;<br>&gt; If typealises in protocols are to have the same semantics as alises<br>&gt; outside protocols (as I think they should), then they don’t change anything<br>&gt; about the rules of collision. For example, the problem already exists today<br>&gt; with associated types:<br>&gt;<br>&gt; protocol Foo {<br>&gt;     associatedtype Inner: IntegerType<br>&gt;     func foo(inner: Inner)<br>&gt; }<br>&gt;<br>&gt; protocol Bar {<br>&gt;     associatedtype Inner: FloatingPointType<br>&gt;     var inner: Inner { get }<br>&gt; }<br>&gt;<br>&gt; struct FooBarImpl: Foo, Bar { // error: Type ‘FooBarImpl’ does not conform<br>&gt; to protocol ‘Bar&#39;<br>&gt;     func foo(inner: Int) {}<br>&gt;     var inner: Float<br>&gt; }<br>&gt;<br>&gt; Type aliasing would not change anything about the fact that those<br>&gt; collisions already exists in the language and are not very well handled:<br>&gt; either they are meant to be forbidden but in that case we need better<br>&gt; diagnostics, or we want to have a way to work around them. Perhaps you’d<br>&gt; like to start a discussion around fixing that ?<br>&gt;<br>&gt; On 09 May 2016, at 08:06, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; I see your point that nothing breaks in the stdlib with your proposal<br>&gt; alone. It&#39;s undeniably true--by construction!--that a purely additive<br>&gt; feature, if never used, will not cause problems.<br>&gt;<br>&gt; That said, since the time that this feature was outlined in Doug&#39;s<br>&gt; manifesto, I have been wondering how clashes such as the examples in my<br>&gt; previous email are to be handled--i.e. what the rules of the language are<br>&gt; to be--which I think is certainly germane to your proposal. Can a<br>&gt; conforming type override a protocol typealias? Can a type conform to two<br>&gt; protocols with conflicting typealiases if all requirements are otherwise<br>&gt; satisfied? Surely, these merit discussion in your proposal.<br>&gt;<br>&gt; On Mon, May 9, 2016 at 12:48 AM David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;<br>&gt;&gt; Hello Xiaodi,<br>&gt;&gt;<br>&gt;&gt; What I mean by there is no impact on existing code is that the language<br>&gt;&gt; change has no impact. Of course, if the Standard Library then declares a<br>&gt;&gt; typealias Element in Sequence, it will clash with code which has declared<br>&gt;&gt; an Element typealias in sub-protocols, but that is separate from the<br>&gt;&gt; proposal.<br>&gt;&gt;<br>&gt;&gt; On 09 May 2016, at 07:28, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; If the protocol Sequence has typealias Element, does that mean I also<br>&gt;&gt; have MyConformingSequence.Element?<br>&gt;&gt;<br>&gt;&gt; If so, I think there is a potential impact on existing code not<br>&gt;&gt; mentioned. Suppose MyConformingSequence already (unwisely) declares<br>&gt;&gt; typealias Element. Now, what happens when I try to migrate my code to your<br>&gt;&gt; proposed version of Swift?<br>&gt;&gt;<br>&gt;&gt; This is a toy example, of course. More generally, though, I wonder about<br>&gt;&gt; this question:<br>&gt;&gt;<br>&gt;&gt; Suppose two protocols A and B each declare typealias Element. These<br>&gt;&gt; typealiases are, as you proposed, intended to simplify referencing indirect<br>&gt;&gt; associated types. But are they themselves considered protocol requirements?<br>&gt;&gt;<br>&gt;&gt; I ask because, suppose I want to conform type T to A and B. I implement<br>&gt;&gt; all the required methods and properties for such conformance. I declare the<br>&gt;&gt; appropriate typealiases for the associatedtypes declared in both protocols.<br>&gt;&gt; But, if A.Element and B.Element are incompatible with each other, it is<br>&gt;&gt; nonetheless impossible to conform T to both A and B? If it&#39;s forbidden,<br>&gt;&gt; isn&#39;t that kind of a bummer, since what&#39;s getting in the way is a naming<br>&gt;&gt; clash arising from a facility intended to simplify the naming of things<br>&gt;&gt; rather than provide for new functionality? If it&#39;s permitted, what is<br>&gt;&gt; T.Element? Some clarity here would be nice.<br>&gt;&gt; On Sun, May 8, 2016 at 6:17 PM David Hart via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Hello,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I’ve come again with another proposal directly from the Generics<br>&gt;&gt;&gt; Manifesto. Please let me know if it needs any modifications before sending<br>&gt;&gt;&gt; the pull request.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Typealiases in protocols and protocol extensions<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    - Proposal: SE-XXXX<br>&gt;&gt;&gt;    &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md&gt;<br>&gt;&gt;&gt;    - Authors: David Hart &lt;https://github.com/hartbit&gt;, Doug Gregor<br>&gt;&gt;&gt;    &lt;https://github.com/DougGregor&gt;<br>&gt;&gt;&gt;    - Status: TBD<br>&gt;&gt;&gt;    - Review manager: TBD<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#introduction&gt;<br>&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This proposal is from the Generics Manifesto<br>&gt;&gt;&gt; &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md&gt; and<br>&gt;&gt;&gt; brings the typealias keyword back into protocols for type aliasing.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#motivation&gt;<br>&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In Swift versions prior to 2.2, the typelias keyword was used outside<br>&gt;&gt;&gt; of protocols to declare type aliases and in protocols to declare associated<br>&gt;&gt;&gt; types. Since SE-0011<br>&gt;&gt;&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0011-replace-typealias-associated.md&gt; and<br>&gt;&gt;&gt; Swift 2.2, associated type now use the associatedtype keyword and<br>&gt;&gt;&gt; typelias is available for implementing true associated type aliases.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#proposed-solution&gt;Proposed<br>&gt;&gt;&gt; solution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The solution allows the creation of associated type aliases. Here is an<br>&gt;&gt;&gt; example from the standard library:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; protocol Sequence {<br>&gt;&gt;&gt;   associatedtype Iterator : IteratorProtocol<br>&gt;&gt;&gt;   typealias Element = Iterator.Element<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The example above shows how this simplifies referencing indirect<br>&gt;&gt;&gt; associated types:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func sum&lt;T: Sequence where T.Element == Int&gt;(sequence: T) -&gt; Int {<br>&gt;&gt;&gt;     return sequence.reduce(0, combine: +)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#detailed-design&gt;Detailed<br>&gt;&gt;&gt; design<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The following grammar rules needs to be added:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *protocol-member-declaration* → *protocol-typealias-declaration*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *protocol-typealias-declaration* → *typealias-declaration*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#impact-on-existing-code&gt;Impact<br>&gt;&gt;&gt; on existing code<br>&gt;&gt;&gt; This will have no impact on existing code, but will probably require<br>&gt;&gt;&gt; improving the Fix-It that was created for migrating typealias to<br>&gt;&gt;&gt; associatedtype in Swift 2.2.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160509/90493448/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Typealiases in protocols and protocol extensions</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May  9, 2016 at 07:00:00am</p></header><div class="content"><p>One more thought here:<br></p><p>It goes a long way to say &quot;typealiases in protocols are to have the same<br>semantics as aliases outside protocols.&quot; I&#39;m inclined to agree on that, but<br>I haven&#39;t thought it totally through.<br></p><p>Now, I can have private typealiases outside protocols. Could I have private<br>typealiases inside protocols? They&#39;d be handy for referencing types while<br>implementing default methods in protocol extensions and whatnot without<br>worrying about collisions with typealiases in conforming types...<br></p><p>On Mon, May 9, 2016 at 01:52 David Hart &lt;david at hartbit.com&gt; wrote:<br></p><p>&gt; I understand that name clashing in those instances is important to<br>&gt; discuss, but I still think it is slightly orthogonal to the proposal. Let<br>&gt; me try to explain why.<br>&gt;<br>&gt; If typealises in protocols are to have the same semantics as alises<br>&gt; outside protocols (as I think they should), then they don’t change anything<br>&gt; about the rules of collision. For example, the problem already exists today<br>&gt; with associated types:<br>&gt;<br>&gt; protocol Foo {<br>&gt;     associatedtype Inner: IntegerType<br>&gt;     func foo(inner: Inner)<br>&gt; }<br>&gt;<br>&gt; protocol Bar {<br>&gt;     associatedtype Inner: FloatingPointType<br>&gt;     var inner: Inner { get }<br>&gt; }<br>&gt;<br>&gt; struct FooBarImpl: Foo, Bar { // error: Type ‘FooBarImpl’ does not conform<br>&gt; to protocol ‘Bar&#39;<br>&gt;     func foo(inner: Int) {}<br>&gt;     var inner: Float<br>&gt; }<br>&gt;<br>&gt; Type aliasing would not change anything about the fact that those<br>&gt; collisions already exists in the language and are not very well handled:<br>&gt; either they are meant to be forbidden but in that case we need better<br>&gt; diagnostics, or we want to have a way to work around them. Perhaps you’d<br>&gt; like to start a discussion around fixing that ?<br>&gt;<br>&gt; On 09 May 2016, at 08:06, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; I see your point that nothing breaks in the stdlib with your proposal<br>&gt; alone. It&#39;s undeniably true--by construction!--that a purely additive<br>&gt; feature, if never used, will not cause problems.<br>&gt;<br>&gt; That said, since the time that this feature was outlined in Doug&#39;s<br>&gt; manifesto, I have been wondering how clashes such as the examples in my<br>&gt; previous email are to be handled--i.e. what the rules of the language are<br>&gt; to be--which I think is certainly germane to your proposal. Can a<br>&gt; conforming type override a protocol typealias? Can a type conform to two<br>&gt; protocols with conflicting typealiases if all requirements are otherwise<br>&gt; satisfied? Surely, these merit discussion in your proposal.<br>&gt;<br>&gt; On Mon, May 9, 2016 at 12:48 AM David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;<br>&gt;&gt; Hello Xiaodi,<br>&gt;&gt;<br>&gt;&gt; What I mean by there is no impact on existing code is that the language<br>&gt;&gt; change has no impact. Of course, if the Standard Library then declares a<br>&gt;&gt; typealias Element in Sequence, it will clash with code which has declared<br>&gt;&gt; an Element typealias in sub-protocols, but that is separate from the<br>&gt;&gt; proposal.<br>&gt;&gt;<br>&gt;&gt; On 09 May 2016, at 07:28, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; If the protocol Sequence has typealias Element, does that mean I also<br>&gt;&gt; have MyConformingSequence.Element?<br>&gt;&gt;<br>&gt;&gt; If so, I think there is a potential impact on existing code not<br>&gt;&gt; mentioned. Suppose MyConformingSequence already (unwisely) declares<br>&gt;&gt; typealias Element. Now, what happens when I try to migrate my code to your<br>&gt;&gt; proposed version of Swift?<br>&gt;&gt;<br>&gt;&gt; This is a toy example, of course. More generally, though, I wonder about<br>&gt;&gt; this question:<br>&gt;&gt;<br>&gt;&gt; Suppose two protocols A and B each declare typealias Element. These<br>&gt;&gt; typealiases are, as you proposed, intended to simplify referencing indirect<br>&gt;&gt; associated types. But are they themselves considered protocol requirements?<br>&gt;&gt;<br>&gt;&gt; I ask because, suppose I want to conform type T to A and B. I implement<br>&gt;&gt; all the required methods and properties for such conformance. I declare the<br>&gt;&gt; appropriate typealiases for the associatedtypes declared in both protocols.<br>&gt;&gt; But, if A.Element and B.Element are incompatible with each other, it is<br>&gt;&gt; nonetheless impossible to conform T to both A and B? If it&#39;s forbidden,<br>&gt;&gt; isn&#39;t that kind of a bummer, since what&#39;s getting in the way is a naming<br>&gt;&gt; clash arising from a facility intended to simplify the naming of things<br>&gt;&gt; rather than provide for new functionality? If it&#39;s permitted, what is<br>&gt;&gt; T.Element? Some clarity here would be nice.<br>&gt;&gt; On Sun, May 8, 2016 at 6:17 PM David Hart via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Hello,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I’ve come again with another proposal directly from the Generics<br>&gt;&gt;&gt; Manifesto. Please let me know if it needs any modifications before sending<br>&gt;&gt;&gt; the pull request.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Typealiases in protocols and protocol extensions<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    - Proposal: SE-XXXX<br>&gt;&gt;&gt;    &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md&gt;<br>&gt;&gt;&gt;    - Authors: David Hart &lt;https://github.com/hartbit&gt;, Doug Gregor<br>&gt;&gt;&gt;    &lt;https://github.com/DougGregor&gt;<br>&gt;&gt;&gt;    - Status: TBD<br>&gt;&gt;&gt;    - Review manager: TBD<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#introduction&gt;<br>&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This proposal is from the Generics Manifesto<br>&gt;&gt;&gt; &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md&gt; and<br>&gt;&gt;&gt; brings the typealias keyword back into protocols for type aliasing.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#motivation&gt;<br>&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In Swift versions prior to 2.2, the typelias keyword was used outside<br>&gt;&gt;&gt; of protocols to declare type aliases and in protocols to declare associated<br>&gt;&gt;&gt; types. Since SE-0011<br>&gt;&gt;&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0011-replace-typealias-associated.md&gt; and<br>&gt;&gt;&gt; Swift 2.2, associated type now use the associatedtype keyword and<br>&gt;&gt;&gt; typelias is available for implementing true associated type aliases.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#proposed-solution&gt;Proposed<br>&gt;&gt;&gt; solution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The solution allows the creation of associated type aliases. Here is an<br>&gt;&gt;&gt; example from the standard library:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; protocol Sequence {<br>&gt;&gt;&gt;   associatedtype Iterator : IteratorProtocol<br>&gt;&gt;&gt;   typealias Element = Iterator.Element<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The example above shows how this simplifies referencing indirect<br>&gt;&gt;&gt; associated types:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func sum&lt;T: Sequence where T.Element == Int&gt;(sequence: T) -&gt; Int {<br>&gt;&gt;&gt;     return sequence.reduce(0, combine: +)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#detailed-design&gt;Detailed<br>&gt;&gt;&gt; design<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The following grammar rules needs to be added:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *protocol-member-declaration* → *protocol-typealias-declaration*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *protocol-typealias-declaration* → *typealias-declaration*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#impact-on-existing-code&gt;Impact<br>&gt;&gt;&gt; on existing code<br>&gt;&gt;&gt; This will have no impact on existing code, but will probably require<br>&gt;&gt;&gt; improving the Fix-It that was created for migrating typealias to<br>&gt;&gt;&gt; associatedtype in Swift 2.2.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160509/86550102/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>Typealiases in protocols and protocol extensions</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>May  9, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On 09 May 2016, at 09:16, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; One more thought here:<br>&gt; <br>&gt; It goes a long way to say &quot;typealiases in protocols are to have the same semantics as aliases outside protocols.&quot; I&#39;m inclined to agree on that, but I haven&#39;t thought it totally through.<br>&gt; <br>&gt; Now, I can have private typealiases outside protocols. Could I have private typealiases inside protocols? They&#39;d be handy for referencing types while implementing default methods in protocol extensions and whatnot without worrying about collisions with typealiases in conforming types…<br></p><p>Sounds like it should be allowed. I’ll add something about it in the proposal. Could you give an example of what you mean by &quot;without worrying about collisions with typealiases in conforming types…”?<br></p><p>&gt; On Mon, May 9, 2016 at 01:52 David Hart &lt;david at hartbit.com &lt;mailto:david at hartbit.com&gt;&gt; wrote:<br>&gt; I understand that name clashing in those instances is important to discuss, but I still think it is slightly orthogonal to the proposal. Let me try to explain why.<br>&gt; <br>&gt; If typealises in protocols are to have the same semantics as alises outside protocols (as I think they should), then they don’t change anything about the rules of collision. For example, the problem already exists today with associated types:<br>&gt; <br>&gt; protocol Foo {<br>&gt;     associatedtype Inner: IntegerType<br>&gt;     func foo(inner: Inner)<br>&gt; }<br>&gt; <br>&gt; protocol Bar {<br>&gt;     associatedtype Inner: FloatingPointType<br>&gt;     var inner: Inner { get }<br>&gt; }<br>&gt; <br>&gt; struct FooBarImpl: Foo, Bar { // error: Type ‘FooBarImpl’ does not conform to protocol ‘Bar&#39;<br>&gt;     func foo(inner: Int) {}<br>&gt;     var inner: Float<br>&gt; }<br>&gt; <br>&gt; Type aliasing would not change anything about the fact that those collisions already exists in the language and are not very well handled: either they are meant to be forbidden but in that case we need better diagnostics, or we want to have a way to work around them. Perhaps you’d like to start a discussion around fixing that ?<br>&gt; <br>&gt;&gt; On 09 May 2016, at 08:06, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I see your point that nothing breaks in the stdlib with your proposal alone. It&#39;s undeniably true--by construction!--that a purely additive feature, if never used, will not cause problems.<br>&gt;&gt; <br>&gt;&gt; That said, since the time that this feature was outlined in Doug&#39;s manifesto, I have been wondering how clashes such as the examples in my previous email are to be handled--i.e. what the rules of the language are to be--which I think is certainly germane to your proposal. Can a conforming type override a protocol typealias? Can a type conform to two protocols with conflicting typealiases if all requirements are otherwise satisfied? Surely, these merit discussion in your proposal.<br>&gt;&gt; <br>&gt;&gt; On Mon, May 9, 2016 at 12:48 AM David Hart &lt;david at hartbit.com &lt;mailto:david at hartbit.com&gt;&gt; wrote:<br>&gt;&gt; Hello Xiaodi,<br>&gt;&gt; <br>&gt;&gt; What I mean by there is no impact on existing code is that the language change has no impact. Of course, if the Standard Library then declares a typealias Element in Sequence, it will clash with code which has declared an Element typealias in sub-protocols, but that is separate from the proposal.<br>&gt;&gt; <br>&gt;&gt;&gt; On 09 May 2016, at 07:28, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If the protocol Sequence has typealias Element, does that mean I also have MyConformingSequence.Element?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If so, I think there is a potential impact on existing code not mentioned. Suppose MyConformingSequence already (unwisely) declares typealias Element. Now, what happens when I try to migrate my code to your proposed version of Swift?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a toy example, of course. More generally, though, I wonder about this question:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Suppose two protocols A and B each declare typealias Element. These typealiases are, as you proposed, intended to simplify referencing indirect associated types. But are they themselves considered protocol requirements?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I ask because, suppose I want to conform type T to A and B. I implement all the required methods and properties for such conformance. I declare the appropriate typealiases for the associatedtypes declared in both protocols. But, if A.Element and B.Element are incompatible with each other, it is nonetheless impossible to conform T to both A and B? If it&#39;s forbidden, isn&#39;t that kind of a bummer, since what&#39;s getting in the way is a naming clash arising from a facility intended to simplify the naming of things rather than provide for new functionality? If it&#39;s permitted, what is T.Element? Some clarity here would be nice.<br>&gt;&gt;&gt; On Sun, May 8, 2016 at 6:17 PM David Hart via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; Hello,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’ve come again with another proposal directly from the Generics Manifesto. Please let me know if it needs any modifications before sending the pull request.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Typealiases in protocols and protocol extensions<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposal: SE-XXXX &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md&gt;<br>&gt;&gt;&gt; Authors: David Hart &lt;https://github.com/hartbit&gt;, Doug Gregor &lt;https://github.com/DougGregor&gt;<br>&gt;&gt;&gt; Status: TBD<br>&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt;  &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#introduction&gt;Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This proposal is from the Generics Manifesto &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md&gt; and brings the typealias keyword back into protocols for type aliasing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#motivation&gt;Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In Swift versions prior to 2.2, the typelias keyword was used outside of protocols to declare type aliases and in protocols to declare associated types. Since SE-0011 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0011-replace-typealias-associated.md&gt; and Swift 2.2, associated type now use the associatedtype keyword and typelias is available for implementing true associated type aliases. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#proposed-solution&gt;Proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The solution allows the creation of associated type aliases. Here is an example from the standard library:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol Sequence {<br>&gt;&gt;&gt;   associatedtype Iterator : IteratorProtocol<br>&gt;&gt;&gt;   typealias Element = Iterator.Element<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; The example above shows how this simplifies referencing indirect associated types:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func sum&lt;T: Sequence where T.Element == Int&gt;(sequence: T) -&gt; Int {<br>&gt;&gt;&gt;     return sequence.reduce(0, combine: +)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;  &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#detailed-design&gt;Detailed design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The following grammar rules needs to be added:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol-member-declaration → protocol-typealias-declaration<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol-typealias-declaration → typealias-declaration<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This will have no impact on existing code, but will probably require improving the Fix-It that was created for migrating typealias to associatedtype in Swift 2.2.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160509/8cfa9e4a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Typealiases in protocols and protocol extensions</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May  9, 2016 at 03:00:00am</p></header><div class="content"><p>On Mon, May 9, 2016 at 2:31 AM, David Hart &lt;david at hartbit.com&gt; wrote:<br></p><p>&gt;<br>&gt; On 09 May 2016, at 09:16, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; One more thought here:<br>&gt;<br>&gt; It goes a long way to say &quot;typealiases in protocols are to have the same<br>&gt; semantics as aliases outside protocols.&quot; I&#39;m inclined to agree on that, but<br>&gt; I haven&#39;t thought it totally through.<br>&gt;<br>&gt; Now, I can have private typealiases outside protocols. Could I have<br>&gt; private typealiases inside protocols? They&#39;d be handy for referencing types<br>&gt; while implementing default methods in protocol extensions and whatnot<br>&gt; without worrying about collisions with typealiases in conforming types…<br>&gt;<br>&gt;<br>&gt; Sounds like it should be allowed. I’ll add something about it in the<br>&gt; proposal. Could you give an example of what you mean by &quot;without worrying<br>&gt; about collisions with typealiases in conforming types…”?<br>&gt;<br>&gt;<br>I wonder if this takes things in an, um, interesting direction. Suppose I<br>could have this (a contrived example--it may fall apart on further study):<br></p><p>```<br>protocol MyUsefulProtocol {<br>  associatedtype Storage : Collection<br>  fileprivate typealias UniqueIdentifier = Storage.Index<br>  func doUsefulThing() -&gt; Storage<br>}<br></p><p>extension MyUsefulProtocol {<br>  func doUsefulThing() -&gt; Storage {<br>    // do something useful in this default implementation<br>    // use UniqueIdentifier internally here and only here<br>  }<br>}<br>```<br></p><p>In a different file:<br></p><p>```<br>struct MyUsefulType&lt;A : Hashable, B&gt; : MyUsefulProtocol {<br>  /* I could do this if I wanted:<br>  typealias UniqueIdentifier = A<br></p><p>  More importantly, I could retroactively conform MyUsefulType<br>  to MyUsefulProtocol even if they happen to have clashing<br>  typealiases, which is great because the typealias in<br>  MyUsefulProtocol is used for clarity and convenience inside<br>  the default implementation and is irrelevant here<br>  */<br>  func doUsefulThing() -&gt; Dictionary&lt;A, B&gt; {<br>    // do something useful but different<br>    // from the default implementation<br>  }<br>}<br>```<br></p><p>I wonder, though, if this is to be allowed, whether much the same could be<br>achieved by instead allowing associatedtype declarations to have default<br>values (for example: `associatedtype UniqueIdentifier : Equatable =<br>Storage.Index`), at which point we might be one step away from going full<br>circle and eliminating the distinction between associatedtypes and<br>typealiases once again.<br></p><p><br>On Mon, May 9, 2016 at 01:52 David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;<br>&gt;&gt; I understand that name clashing in those instances is important to<br>&gt;&gt; discuss, but I still think it is slightly orthogonal to the proposal. Let<br>&gt;&gt; me try to explain why.<br>&gt;&gt;<br>&gt;&gt; If typealises in protocols are to have the same semantics as alises<br>&gt;&gt; outside protocols (as I think they should), then they don’t change anything<br>&gt;&gt; about the rules of collision. For example, the problem already exists today<br>&gt;&gt; with associated types:<br>&gt;&gt;<br>&gt;&gt; protocol Foo {<br>&gt;&gt;     associatedtype Inner: IntegerType<br>&gt;&gt;     func foo(inner: Inner)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; protocol Bar {<br>&gt;&gt;     associatedtype Inner: FloatingPointType<br>&gt;&gt;     var inner: Inner { get }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; struct FooBarImpl: Foo, Bar { // error: Type ‘FooBarImpl’ does not<br>&gt;&gt; conform to protocol ‘Bar&#39;<br>&gt;&gt;     func foo(inner: Int) {}<br>&gt;&gt;     var inner: Float<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Type aliasing would not change anything about the fact that those<br>&gt;&gt; collisions already exists in the language and are not very well handled:<br>&gt;&gt; either they are meant to be forbidden but in that case we need better<br>&gt;&gt; diagnostics, or we want to have a way to work around them. Perhaps you’d<br>&gt;&gt; like to start a discussion around fixing that ?<br>&gt;&gt;<br>&gt;&gt; On 09 May 2016, at 08:06, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I see your point that nothing breaks in the stdlib with your proposal<br>&gt;&gt; alone. It&#39;s undeniably true--by construction!--that a purely additive<br>&gt;&gt; feature, if never used, will not cause problems.<br>&gt;&gt;<br>&gt;&gt; That said, since the time that this feature was outlined in Doug&#39;s<br>&gt;&gt; manifesto, I have been wondering how clashes such as the examples in my<br>&gt;&gt; previous email are to be handled--i.e. what the rules of the language are<br>&gt;&gt; to be--which I think is certainly germane to your proposal. Can a<br>&gt;&gt; conforming type override a protocol typealias? Can a type conform to two<br>&gt;&gt; protocols with conflicting typealiases if all requirements are otherwise<br>&gt;&gt; satisfied? Surely, these merit discussion in your proposal.<br>&gt;&gt;<br>&gt;&gt; On Mon, May 9, 2016 at 12:48 AM David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Hello Xiaodi,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; What I mean by there is no impact on existing code is that the language<br>&gt;&gt;&gt; change has no impact. Of course, if the Standard Library then declares a<br>&gt;&gt;&gt; typealias Element in Sequence, it will clash with code which has declared<br>&gt;&gt;&gt; an Element typealias in sub-protocols, but that is separate from the<br>&gt;&gt;&gt; proposal.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On 09 May 2016, at 07:28, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If the protocol Sequence has typealias Element, does that mean I also<br>&gt;&gt;&gt; have MyConformingSequence.Element?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If so, I think there is a potential impact on existing code not<br>&gt;&gt;&gt; mentioned. Suppose MyConformingSequence already (unwisely) declares<br>&gt;&gt;&gt; typealias Element. Now, what happens when I try to migrate my code to your<br>&gt;&gt;&gt; proposed version of Swift?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This is a toy example, of course. More generally, though, I wonder about<br>&gt;&gt;&gt; this question:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Suppose two protocols A and B each declare typealias Element. These<br>&gt;&gt;&gt; typealiases are, as you proposed, intended to simplify referencing indirect<br>&gt;&gt;&gt; associated types. But are they themselves considered protocol requirements?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I ask because, suppose I want to conform type T to A and B. I implement<br>&gt;&gt;&gt; all the required methods and properties for such conformance. I declare the<br>&gt;&gt;&gt; appropriate typealiases for the associatedtypes declared in both protocols.<br>&gt;&gt;&gt; But, if A.Element and B.Element are incompatible with each other, it is<br>&gt;&gt;&gt; nonetheless impossible to conform T to both A and B? If it&#39;s forbidden,<br>&gt;&gt;&gt; isn&#39;t that kind of a bummer, since what&#39;s getting in the way is a naming<br>&gt;&gt;&gt; clash arising from a facility intended to simplify the naming of things<br>&gt;&gt;&gt; rather than provide for new functionality? If it&#39;s permitted, what is<br>&gt;&gt;&gt; T.Element? Some clarity here would be nice.<br>&gt;&gt;&gt; On Sun, May 8, 2016 at 6:17 PM David Hart via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Hello,<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I’ve come again with another proposal directly from the Generics<br>&gt;&gt;&gt;&gt; Manifesto. Please let me know if it needs any modifications before sending<br>&gt;&gt;&gt;&gt; the pull request.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Typealiases in protocols and protocol extensions<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;    - Proposal: SE-XXXX<br>&gt;&gt;&gt;&gt;    &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md&gt;<br>&gt;&gt;&gt;&gt;    - Authors: David Hart &lt;https://github.com/hartbit&gt;, Doug Gregor<br>&gt;&gt;&gt;&gt;    &lt;https://github.com/DougGregor&gt;<br>&gt;&gt;&gt;&gt;    - Status: TBD<br>&gt;&gt;&gt;&gt;    - Review manager: TBD<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#introduction&gt;<br>&gt;&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This proposal is from the Generics Manifesto<br>&gt;&gt;&gt;&gt; &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md&gt; and<br>&gt;&gt;&gt;&gt; brings the typealias keyword back into protocols for type aliasing.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#motivation&gt;<br>&gt;&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; In Swift versions prior to 2.2, the typelias keyword was used outside<br>&gt;&gt;&gt;&gt; of protocols to declare type aliases and in protocols to declare associated<br>&gt;&gt;&gt;&gt; types. Since SE-0011<br>&gt;&gt;&gt;&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0011-replace-typealias-associated.md&gt; and<br>&gt;&gt;&gt;&gt; Swift 2.2, associated type now use the associatedtype keyword and<br>&gt;&gt;&gt;&gt; typelias is available for implementing true associated type aliases.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#proposed-solution&gt;Proposed<br>&gt;&gt;&gt;&gt; solution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The solution allows the creation of associated type aliases. Here is an<br>&gt;&gt;&gt;&gt; example from the standard library:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; protocol Sequence {<br>&gt;&gt;&gt;&gt;   associatedtype Iterator : IteratorProtocol<br>&gt;&gt;&gt;&gt;   typealias Element = Iterator.Element<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The example above shows how this simplifies referencing indirect<br>&gt;&gt;&gt;&gt; associated types:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; func sum&lt;T: Sequence where T.Element == Int&gt;(sequence: T) -&gt; Int {<br>&gt;&gt;&gt;&gt;     return sequence.reduce(0, combine: +)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#detailed-design&gt;Detailed<br>&gt;&gt;&gt;&gt; design<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The following grammar rules needs to be added:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; *protocol-member-declaration* → *protocol-typealias-declaration*<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; *protocol-typealias-declaration* → *typealias-declaration*<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#impact-on-existing-code&gt;Impact<br>&gt;&gt;&gt;&gt; on existing code<br>&gt;&gt;&gt;&gt; This will have no impact on existing code, but will probably require<br>&gt;&gt;&gt;&gt; improving the Fix-It that was created for migrating typealias to<br>&gt;&gt;&gt;&gt; associatedtype in Swift 2.2.<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160509/0bacbaad/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>Typealiases in protocols and protocol extensions</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>May  9, 2016 at 10:00:00pm</p></header><div class="content"><p>I don’t see a problem with your example. Because the typealias is fileprivate, it doesn’t exist as far as MyUsefulType is concerned. The same way the following works:<br></p><p>```<br>class Base {<br>    private typealias Foo = Int<br>    func foo() -&gt; Int {<br>        return Foo()<br>    }<br>}<br>```<br></p><p>Other file:<br></p><p>```<br>class Derived: Base {<br>    typealias Foo = String<br>    func bar() -&gt; String {<br>        return &quot;Hello \(foo())&quot;<br>    }<br>}<br>```<br></p><p>&gt; On 09 May 2016, at 10:37, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Mon, May 9, 2016 at 2:31 AM, David Hart &lt;david at hartbit.com &lt;mailto:david at hartbit.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On 09 May 2016, at 09:16, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; One more thought here:<br>&gt;&gt; <br>&gt;&gt; It goes a long way to say &quot;typealiases in protocols are to have the same semantics as aliases outside protocols.&quot; I&#39;m inclined to agree on that, but I haven&#39;t thought it totally through.<br>&gt;&gt; <br>&gt;&gt; Now, I can have private typealiases outside protocols. Could I have private typealiases inside protocols? They&#39;d be handy for referencing types while implementing default methods in protocol extensions and whatnot without worrying about collisions with typealiases in conforming types…<br>&gt; <br>&gt; Sounds like it should be allowed. I’ll add something about it in the proposal. Could you give an example of what you mean by &quot;without worrying about collisions with typealiases in conforming types…”?<br>&gt; <br>&gt; <br>&gt; I wonder if this takes things in an, um, interesting direction. Suppose I could have this (a contrived example--it may fall apart on further study):<br>&gt; <br>&gt; ```<br>&gt; protocol MyUsefulProtocol {<br>&gt;   associatedtype Storage : Collection<br>&gt;   fileprivate typealias UniqueIdentifier = Storage.Index<br>&gt;   func doUsefulThing() -&gt; Storage<br>&gt; }<br>&gt; <br>&gt; extension MyUsefulProtocol {<br>&gt;   func doUsefulThing() -&gt; Storage {<br>&gt;     // do something useful in this default implementation<br>&gt;     // use UniqueIdentifier internally here and only here<br>&gt;   }<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; In a different file:<br>&gt; <br>&gt; ```<br>&gt; struct MyUsefulType&lt;A : Hashable, B&gt; : MyUsefulProtocol {<br>&gt;   /* I could do this if I wanted:<br>&gt;   typealias UniqueIdentifier = A<br>&gt;   <br>&gt;   More importantly, I could retroactively conform MyUsefulType<br>&gt;   to MyUsefulProtocol even if they happen to have clashing<br>&gt;   typealiases, which is great because the typealias in<br>&gt;   MyUsefulProtocol is used for clarity and convenience inside<br>&gt;   the default implementation and is irrelevant here<br>&gt;   */<br>&gt;   func doUsefulThing() -&gt; Dictionary&lt;A, B&gt; {<br>&gt;     // do something useful but different<br>&gt;     // from the default implementation<br>&gt;   }<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; I wonder, though, if this is to be allowed, whether much the same could be achieved by instead allowing associatedtype declarations to have default values (for example: `associatedtype UniqueIdentifier : Equatable = Storage.Index`), at which point we might be one step away from going full circle and eliminating the distinction between associatedtypes and typealiases once again.<br>&gt; <br>&gt; <br>&gt;&gt; On Mon, May 9, 2016 at 01:52 David Hart &lt;david at hartbit.com &lt;mailto:david at hartbit.com&gt;&gt; wrote:<br>&gt;&gt; I understand that name clashing in those instances is important to discuss, but I still think it is slightly orthogonal to the proposal. Let me try to explain why.<br>&gt;&gt; <br>&gt;&gt; If typealises in protocols are to have the same semantics as alises outside protocols (as I think they should), then they don’t change anything about the rules of collision. For example, the problem already exists today with associated types:<br>&gt;&gt; <br>&gt;&gt; protocol Foo {<br>&gt;&gt;     associatedtype Inner: IntegerType<br>&gt;&gt;     func foo(inner: Inner)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; protocol Bar {<br>&gt;&gt;     associatedtype Inner: FloatingPointType<br>&gt;&gt;     var inner: Inner { get }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct FooBarImpl: Foo, Bar { // error: Type ‘FooBarImpl’ does not conform to protocol ‘Bar&#39;<br>&gt;&gt;     func foo(inner: Int) {}<br>&gt;&gt;     var inner: Float<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Type aliasing would not change anything about the fact that those collisions already exists in the language and are not very well handled: either they are meant to be forbidden but in that case we need better diagnostics, or we want to have a way to work around them. Perhaps you’d like to start a discussion around fixing that ?<br>&gt;&gt; <br>&gt;&gt;&gt; On 09 May 2016, at 08:06, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I see your point that nothing breaks in the stdlib with your proposal alone. It&#39;s undeniably true--by construction!--that a purely additive feature, if never used, will not cause problems.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That said, since the time that this feature was outlined in Doug&#39;s manifesto, I have been wondering how clashes such as the examples in my previous email are to be handled--i.e. what the rules of the language are to be--which I think is certainly germane to your proposal. Can a conforming type override a protocol typealias? Can a type conform to two protocols with conflicting typealiases if all requirements are otherwise satisfied? Surely, these merit discussion in your proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Mon, May 9, 2016 at 12:48 AM David Hart &lt;david at hartbit.com &lt;mailto:david at hartbit.com&gt;&gt; wrote:<br>&gt;&gt;&gt; Hello Xiaodi,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What I mean by there is no impact on existing code is that the language change has no impact. Of course, if the Standard Library then declares a typealias Element in Sequence, it will clash with code which has declared an Element typealias in sub-protocols, but that is separate from the proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 09 May 2016, at 07:28, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If the protocol Sequence has typealias Element, does that mean I also have MyConformingSequence.Element?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If so, I think there is a potential impact on existing code not mentioned. Suppose MyConformingSequence already (unwisely) declares typealias Element. Now, what happens when I try to migrate my code to your proposed version of Swift?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is a toy example, of course. More generally, though, I wonder about this question:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Suppose two protocols A and B each declare typealias Element. These typealiases are, as you proposed, intended to simplify referencing indirect associated types. But are they themselves considered protocol requirements?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I ask because, suppose I want to conform type T to A and B. I implement all the required methods and properties for such conformance. I declare the appropriate typealiases for the associatedtypes declared in both protocols. But, if A.Element and B.Element are incompatible with each other, it is nonetheless impossible to conform T to both A and B? If it&#39;s forbidden, isn&#39;t that kind of a bummer, since what&#39;s getting in the way is a naming clash arising from a facility intended to simplify the naming of things rather than provide for new functionality? If it&#39;s permitted, what is T.Element? Some clarity here would be nice.<br>&gt;&gt;&gt;&gt; On Sun, May 8, 2016 at 6:17 PM David Hart via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; Hello,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’ve come again with another proposal directly from the Generics Manifesto. Please let me know if it needs any modifications before sending the pull request.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Typealiases in protocols and protocol extensions<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Proposal: SE-XXXX &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md&gt;<br>&gt;&gt;&gt;&gt; Authors: David Hart &lt;https://github.com/hartbit&gt;, Doug Gregor &lt;https://github.com/DougGregor&gt;<br>&gt;&gt;&gt;&gt; Status: TBD<br>&gt;&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt;&gt;  &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#introduction&gt;Introduction<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This proposal is from the Generics Manifesto &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md&gt; and brings the typealias keyword back into protocols for type aliasing.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#motivation&gt;Motivation<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In Swift versions prior to 2.2, the typelias keyword was used outside of protocols to declare type aliases and in protocols to declare associated types. Since SE-0011 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0011-replace-typealias-associated.md&gt; and Swift 2.2, associated type now use the associatedtype keyword and typelias is available for implementing true associated type aliases. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#proposed-solution&gt;Proposed solution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The solution allows the creation of associated type aliases. Here is an example from the standard library:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol Sequence {<br>&gt;&gt;&gt;&gt;   associatedtype Iterator : IteratorProtocol<br>&gt;&gt;&gt;&gt;   typealias Element = Iterator.Element<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; The example above shows how this simplifies referencing indirect associated types:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func sum&lt;T: Sequence where T.Element == Int&gt;(sequence: T) -&gt; Int {<br>&gt;&gt;&gt;&gt;     return sequence.reduce(0, combine: +)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;  &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#detailed-design&gt;Detailed design<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The following grammar rules needs to be added:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol-member-declaration → protocol-typealias-declaration<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol-typealias-declaration → typealias-declaration<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This will have no impact on existing code, but will probably require improving the Fix-It that was created for migrating typealias to associatedtype in Swift 2.2.<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160509/c9aeeca6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Typealiases in protocols and protocol extensions</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May  9, 2016 at 03:00:00pm</p></header><div class="content"><p>Sorry--I&#39;m not at all saying that I think there&#39;s a problem. As you asked,<br>I attempted to supply a contrived use case for a typealias declared in a<br>protocol having a more restricted scope than the protocol itself. I was<br>asking if it would be supported as part of your proposal.<br></p><p><br>On Mon, May 9, 2016 at 3:11 PM, David Hart &lt;david at hartbit.com&gt; wrote:<br></p><p>&gt; I don’t see a problem with your example. Because the typealias is<br>&gt; fileprivate, it doesn’t exist as far as MyUsefulType is concerned. The same<br>&gt; way the following works:<br>&gt;<br>&gt; ```<br>&gt; class Base {<br>&gt;     private typealias Foo = Int<br>&gt;     func foo() -&gt; Int {<br>&gt;         return Foo()<br>&gt;     }<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; Other file:<br>&gt;<br>&gt; ```<br>&gt; class Derived: Base {<br>&gt;     typealias Foo = String<br>&gt;     func bar() -&gt; String {<br>&gt;         return &quot;Hello \(foo())&quot;<br>&gt;     }<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; On 09 May 2016, at 10:37, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Mon, May 9, 2016 at 2:31 AM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On 09 May 2016, at 09:16, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; One more thought here:<br>&gt;&gt;<br>&gt;&gt; It goes a long way to say &quot;typealiases in protocols are to have the same<br>&gt;&gt; semantics as aliases outside protocols.&quot; I&#39;m inclined to agree on that, but<br>&gt;&gt; I haven&#39;t thought it totally through.<br>&gt;&gt;<br>&gt;&gt; Now, I can have private typealiases outside protocols. Could I have<br>&gt;&gt; private typealiases inside protocols? They&#39;d be handy for referencing types<br>&gt;&gt; while implementing default methods in protocol extensions and whatnot<br>&gt;&gt; without worrying about collisions with typealiases in conforming types…<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Sounds like it should be allowed. I’ll add something about it in the<br>&gt;&gt; proposal. Could you give an example of what you mean by &quot;without worrying<br>&gt;&gt; about collisions with typealiases in conforming types…”?<br>&gt;&gt;<br>&gt;&gt;<br>&gt; I wonder if this takes things in an, um, interesting direction. Suppose I<br>&gt; could have this (a contrived example--it may fall apart on further study):<br>&gt;<br>&gt; ```<br>&gt; protocol MyUsefulProtocol {<br>&gt;   associatedtype Storage : Collection<br>&gt;   fileprivate typealias UniqueIdentifier = Storage.Index<br>&gt;   func doUsefulThing() -&gt; Storage<br>&gt; }<br>&gt;<br>&gt; extension MyUsefulProtocol {<br>&gt;   func doUsefulThing() -&gt; Storage {<br>&gt;     // do something useful in this default implementation<br>&gt;     // use UniqueIdentifier internally here and only here<br>&gt;   }<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; In a different file:<br>&gt;<br>&gt; ```<br>&gt; struct MyUsefulType&lt;A : Hashable, B&gt; : MyUsefulProtocol {<br>&gt;   /* I could do this if I wanted:<br>&gt;   typealias UniqueIdentifier = A<br>&gt;<br>&gt;   More importantly, I could retroactively conform MyUsefulType<br>&gt;   to MyUsefulProtocol even if they happen to have clashing<br>&gt;   typealiases, which is great because the typealias in<br>&gt;   MyUsefulProtocol is used for clarity and convenience inside<br>&gt;   the default implementation and is irrelevant here<br>&gt;   */<br>&gt;   func doUsefulThing() -&gt; Dictionary&lt;A, B&gt; {<br>&gt;     // do something useful but different<br>&gt;     // from the default implementation<br>&gt;   }<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; I wonder, though, if this is to be allowed, whether much the same could be<br>&gt; achieved by instead allowing associatedtype declarations to have default<br>&gt; values (for example: `associatedtype UniqueIdentifier : Equatable =<br>&gt; Storage.Index`), at which point we might be one step away from going full<br>&gt; circle and eliminating the distinction between associatedtypes and<br>&gt; typealiases once again.<br>&gt;<br>&gt;<br>&gt; On Mon, May 9, 2016 at 01:52 David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; I understand that name clashing in those instances is important to<br>&gt;&gt;&gt; discuss, but I still think it is slightly orthogonal to the proposal. Let<br>&gt;&gt;&gt; me try to explain why.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If typealises in protocols are to have the same semantics as alises<br>&gt;&gt;&gt; outside protocols (as I think they should), then they don’t change anything<br>&gt;&gt;&gt; about the rules of collision. For example, the problem already exists today<br>&gt;&gt;&gt; with associated types:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; protocol Foo {<br>&gt;&gt;&gt;     associatedtype Inner: IntegerType<br>&gt;&gt;&gt;     func foo(inner: Inner)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; protocol Bar {<br>&gt;&gt;&gt;     associatedtype Inner: FloatingPointType<br>&gt;&gt;&gt;     var inner: Inner { get }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; struct FooBarImpl: Foo, Bar { // error: Type ‘FooBarImpl’ does not<br>&gt;&gt;&gt; conform to protocol ‘Bar&#39;<br>&gt;&gt;&gt;     func foo(inner: Int) {}<br>&gt;&gt;&gt;     var inner: Float<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Type aliasing would not change anything about the fact that those<br>&gt;&gt;&gt; collisions already exists in the language and are not very well handled:<br>&gt;&gt;&gt; either they are meant to be forbidden but in that case we need better<br>&gt;&gt;&gt; diagnostics, or we want to have a way to work around them. Perhaps you’d<br>&gt;&gt;&gt; like to start a discussion around fixing that ?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On 09 May 2016, at 08:06, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I see your point that nothing breaks in the stdlib with your proposal<br>&gt;&gt;&gt; alone. It&#39;s undeniably true--by construction!--that a purely additive<br>&gt;&gt;&gt; feature, if never used, will not cause problems.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; That said, since the time that this feature was outlined in Doug&#39;s<br>&gt;&gt;&gt; manifesto, I have been wondering how clashes such as the examples in my<br>&gt;&gt;&gt; previous email are to be handled--i.e. what the rules of the language are<br>&gt;&gt;&gt; to be--which I think is certainly germane to your proposal. Can a<br>&gt;&gt;&gt; conforming type override a protocol typealias? Can a type conform to two<br>&gt;&gt;&gt; protocols with conflicting typealiases if all requirements are otherwise<br>&gt;&gt;&gt; satisfied? Surely, these merit discussion in your proposal.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Mon, May 9, 2016 at 12:48 AM David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Hello Xiaodi,<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; What I mean by there is no impact on existing code is that the language<br>&gt;&gt;&gt;&gt; change has no impact. Of course, if the Standard Library then declares a<br>&gt;&gt;&gt;&gt; typealias Element in Sequence, it will clash with code which has declared<br>&gt;&gt;&gt;&gt; an Element typealias in sub-protocols, but that is separate from the<br>&gt;&gt;&gt;&gt; proposal.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On 09 May 2016, at 07:28, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; If the protocol Sequence has typealias Element, does that mean I also<br>&gt;&gt;&gt;&gt; have MyConformingSequence.Element?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; If so, I think there is a potential impact on existing code not<br>&gt;&gt;&gt;&gt; mentioned. Suppose MyConformingSequence already (unwisely) declares<br>&gt;&gt;&gt;&gt; typealias Element. Now, what happens when I try to migrate my code to your<br>&gt;&gt;&gt;&gt; proposed version of Swift?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This is a toy example, of course. More generally, though, I wonder<br>&gt;&gt;&gt;&gt; about this question:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Suppose two protocols A and B each declare typealias Element. These<br>&gt;&gt;&gt;&gt; typealiases are, as you proposed, intended to simplify referencing indirect<br>&gt;&gt;&gt;&gt; associated types. But are they themselves considered protocol requirements?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I ask because, suppose I want to conform type T to A and B. I implement<br>&gt;&gt;&gt;&gt; all the required methods and properties for such conformance. I declare the<br>&gt;&gt;&gt;&gt; appropriate typealiases for the associatedtypes declared in both protocols.<br>&gt;&gt;&gt;&gt; But, if A.Element and B.Element are incompatible with each other, it is<br>&gt;&gt;&gt;&gt; nonetheless impossible to conform T to both A and B? If it&#39;s forbidden,<br>&gt;&gt;&gt;&gt; isn&#39;t that kind of a bummer, since what&#39;s getting in the way is a naming<br>&gt;&gt;&gt;&gt; clash arising from a facility intended to simplify the naming of things<br>&gt;&gt;&gt;&gt; rather than provide for new functionality? If it&#39;s permitted, what is<br>&gt;&gt;&gt;&gt; T.Element? Some clarity here would be nice.<br>&gt;&gt;&gt;&gt; On Sun, May 8, 2016 at 6:17 PM David Hart via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Hello,<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I’ve come again with another proposal directly from the Generics<br>&gt;&gt;&gt;&gt;&gt; Manifesto. Please let me know if it needs any modifications before sending<br>&gt;&gt;&gt;&gt;&gt; the pull request.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Typealiases in protocols and protocol extensions<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;    - Proposal: SE-XXXX<br>&gt;&gt;&gt;&gt;&gt;    &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md&gt;<br>&gt;&gt;&gt;&gt;&gt;    - Authors: David Hart &lt;https://github.com/hartbit&gt;, Doug Gregor<br>&gt;&gt;&gt;&gt;&gt;    &lt;https://github.com/DougGregor&gt;<br>&gt;&gt;&gt;&gt;&gt;    - Status: TBD<br>&gt;&gt;&gt;&gt;&gt;    - Review manager: TBD<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#introduction&gt;<br>&gt;&gt;&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; This proposal is from the Generics Manifesto<br>&gt;&gt;&gt;&gt;&gt; &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md&gt; and<br>&gt;&gt;&gt;&gt;&gt; brings the typealias keyword back into protocols for type aliasing.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#motivation&gt;<br>&gt;&gt;&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; In Swift versions prior to 2.2, the typelias keyword was used outside<br>&gt;&gt;&gt;&gt;&gt; of protocols to declare type aliases and in protocols to declare associated<br>&gt;&gt;&gt;&gt;&gt; types. Since SE-0011<br>&gt;&gt;&gt;&gt;&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0011-replace-typealias-associated.md&gt; and<br>&gt;&gt;&gt;&gt;&gt; Swift 2.2, associated type now use the associatedtype keyword and<br>&gt;&gt;&gt;&gt;&gt; typelias is available for implementing true associated type aliases.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#proposed-solution&gt;Proposed<br>&gt;&gt;&gt;&gt;&gt; solution<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; The solution allows the creation of associated type aliases. Here is<br>&gt;&gt;&gt;&gt;&gt; an example from the standard library:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; protocol Sequence {<br>&gt;&gt;&gt;&gt;&gt;   associatedtype Iterator : IteratorProtocol<br>&gt;&gt;&gt;&gt;&gt;   typealias Element = Iterator.Element<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; The example above shows how this simplifies referencing indirect<br>&gt;&gt;&gt;&gt;&gt; associated types:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; func sum&lt;T: Sequence where T.Element == Int&gt;(sequence: T) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt;     return sequence.reduce(0, combine: +)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#detailed-design&gt;Detailed<br>&gt;&gt;&gt;&gt;&gt; design<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; The following grammar rules needs to be added:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; *protocol-member-declaration* → *protocol-typealias-declaration*<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; *protocol-typealias-declaration* → *typealias-declaration*<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#impact-on-existing-code&gt;Impact<br>&gt;&gt;&gt;&gt;&gt; on existing code<br>&gt;&gt;&gt;&gt;&gt; This will have no impact on existing code, but will probably require<br>&gt;&gt;&gt;&gt;&gt; improving the Fix-It that was created for migrating typealias to<br>&gt;&gt;&gt;&gt;&gt; associatedtype in Swift 2.2.<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160509/453279fe/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>Typealiases in protocols and protocol extensions</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>May 14, 2016 at 10:00:00pm</p></header><div class="content"><p>Hi everybody,<br></p><p>I added details suggested by Xiaodi and opened a pull request. Any last minute modifications before it gets merged in?<br></p><p>https://github.com/hartbit/swift-evolution/blob/a1b883132588bd0ceff5e5c9787bcef140f6674a/proposals/XXXX-typealiases-in-protocols.md<br></p><p>Typealiases in protocols and protocol extensions<br></p><p>Proposal: SE-XXXX &lt;https://github.com/hartbit/swift-evolution/blob/a1b883132588bd0ceff5e5c9787bcef140f6674a/proposals/XXXX-typealiases-in-protocols.md&gt;<br>Authors: David Hart &lt;https://github.com/hartbit&gt;, Doug Gregor &lt;https://github.com/DougGregor&gt;<br>Status: TBD<br>Review manager: TBD<br> &lt;https://github.com/hartbit/swift-evolution/blob/a1b883132588bd0ceff5e5c9787bcef140f6674a/proposals/XXXX-typealiases-in-protocols.md#introduction&gt;Introduction<br></p><p>This proposal is from the Generics Manifesto &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md&gt; and brings the typealias keyword back into protocols for type aliasing.<br></p><p> &lt;https://github.com/hartbit/swift-evolution/blob/a1b883132588bd0ceff5e5c9787bcef140f6674a/proposals/XXXX-typealiases-in-protocols.md#motivation&gt;Motivation<br></p><p>In Swift versions prior to 2.2, the typealias keyword was used outside of protocols to declare type aliases and in protocols to declare associated types. Since SE-0011 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0011-replace-typealias-associated.md&gt; and Swift 2.2, associated type now use the associatedtypekeyword and typealias is available for implementing true associated type aliases. <br></p><p> &lt;https://github.com/hartbit/swift-evolution/blob/a1b883132588bd0ceff5e5c9787bcef140f6674a/proposals/XXXX-typealiases-in-protocols.md#proposed-solution&gt;Proposed solution<br></p><p>The solution allows the creation of associated type aliases. Here is an example from the standard library:<br></p><p>protocol Sequence {<br>  associatedtype Iterator : IteratorProtocol<br>  typealias Element = Iterator.Element<br>}<br>The example above shows how this simplifies referencing indirect associated types:<br></p><p>func sum&lt;T: Sequence where T.Element == Int&gt;(sequence: T) -&gt; Int {<br>    return sequence.reduce(0, combine: +)<br>}<br>Allowing typealias in protocol extensions also allows extensions to use aliases to simplify code that the protocol did not originally propose:<br></p><p>extension Sequence {<br>    typealias Element = Iterator.Element<br></p><p>    func concat(other: Self) -&gt; [Element] {<br>        return Array&lt;Element&gt;(self) + Array&lt;Element&gt;(other)<br>    }<br>}<br> &lt;https://github.com/hartbit/swift-evolution/blob/a1b883132588bd0ceff5e5c9787bcef140f6674a/proposals/XXXX-typealiases-in-protocols.md#detailed-design&gt;Detailed design<br></p><p>The following grammar rules needs to be added:<br></p><p>protocol-member-declaration → protocol-typealias-declaration<br></p><p>protocol-typealias-declaration → typealias-declaration<br></p><p> &lt;https://github.com/hartbit/swift-evolution/blob/a1b883132588bd0ceff5e5c9787bcef140f6674a/proposals/XXXX-typealiases-in-protocols.md#impact-on-existing-code&gt;Impact on existing code<br></p><p>This will initially have no impact on existing code, but will probably require improving the Fix-It that was created for migrating typealias to associatedtype in Swift 2.2.<br></p><p>But once typealias starts being used inside protocols, especially in the Standard Library, name clashes might start cropping up between the type aliases and associated types. For example:<br></p><p>protocol Sequence {<br>    typealias Element = Iterator.Element // once this is added<br>}<br></p><p>protocol MySequence: Sequence {<br>    associatedtype Element // MySequence.Element is ambiguous<br>}<br>But there is no reason that those name clashes behave differently than current clashes between associated types:<br></p><p>protocol Foo {<br>    associatedtype Inner: IntegerType<br>    func foo(inner: Inner)<br>}<br></p><p>protocol Bar {<br>    associatedtype Inner: FloatingPointType<br>    var inner: Inner { get }<br>}<br></p><p>struct FooBarImpl: Foo, Bar { // error: Type ‘FooBarImpl’ does not conform to protocol ‘Bar&#39;<br>    func foo(inner: Int) {}<br>    var inner: Float<br>}<br></p><p><br>&gt; On 09 May 2016, at 22:18, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; Sorry--I&#39;m not at all saying that I think there&#39;s a problem. As you asked, I attempted to supply a contrived use case for a typealias declared in a protocol having a more restricted scope than the protocol itself. I was asking if it would be supported as part of your proposal.<br>&gt; <br>&gt; <br>&gt; On Mon, May 9, 2016 at 3:11 PM, David Hart &lt;david at hartbit.com &lt;mailto:david at hartbit.com&gt;&gt; wrote:<br>&gt; I don’t see a problem with your example. Because the typealias is fileprivate, it doesn’t exist as far as MyUsefulType is concerned. The same way the following works:<br>&gt; <br>&gt; ```<br>&gt; class Base {<br>&gt;     private typealias Foo = Int<br>&gt;     func foo() -&gt; Int {<br>&gt;         return Foo()<br>&gt;     }<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; Other file:<br>&gt; <br>&gt; ```<br>&gt; class Derived: Base {<br>&gt;     typealias Foo = String<br>&gt;     func bar() -&gt; String {<br>&gt;         return &quot;Hello \(foo())&quot;<br>&gt;     }<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt;&gt; On 09 May 2016, at 10:37, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Mon, May 9, 2016 at 2:31 AM, David Hart &lt;david at hartbit.com &lt;mailto:david at hartbit.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On 09 May 2016, at 09:16, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One more thought here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It goes a long way to say &quot;typealiases in protocols are to have the same semantics as aliases outside protocols.&quot; I&#39;m inclined to agree on that, but I haven&#39;t thought it totally through.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Now, I can have private typealiases outside protocols. Could I have private typealiases inside protocols? They&#39;d be handy for referencing types while implementing default methods in protocol extensions and whatnot without worrying about collisions with typealiases in conforming types…<br>&gt;&gt; <br>&gt;&gt; Sounds like it should be allowed. I’ll add something about it in the proposal. Could you give an example of what you mean by &quot;without worrying about collisions with typealiases in conforming types…”?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I wonder if this takes things in an, um, interesting direction. Suppose I could have this (a contrived example--it may fall apart on further study):<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; protocol MyUsefulProtocol {<br>&gt;&gt;   associatedtype Storage : Collection<br>&gt;&gt;   fileprivate typealias UniqueIdentifier = Storage.Index<br>&gt;&gt;   func doUsefulThing() -&gt; Storage<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension MyUsefulProtocol {<br>&gt;&gt;   func doUsefulThing() -&gt; Storage {<br>&gt;&gt;     // do something useful in this default implementation<br>&gt;&gt;     // use UniqueIdentifier internally here and only here<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; In a different file:<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; struct MyUsefulType&lt;A : Hashable, B&gt; : MyUsefulProtocol {<br>&gt;&gt;   /* I could do this if I wanted:<br>&gt;&gt;   typealias UniqueIdentifier = A<br>&gt;&gt;   <br>&gt;&gt;   More importantly, I could retroactively conform MyUsefulType<br>&gt;&gt;   to MyUsefulProtocol even if they happen to have clashing<br>&gt;&gt;   typealiases, which is great because the typealias in<br>&gt;&gt;   MyUsefulProtocol is used for clarity and convenience inside<br>&gt;&gt;   the default implementation and is irrelevant here<br>&gt;&gt;   */<br>&gt;&gt;   func doUsefulThing() -&gt; Dictionary&lt;A, B&gt; {<br>&gt;&gt;     // do something useful but different<br>&gt;&gt;     // from the default implementation<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; I wonder, though, if this is to be allowed, whether much the same could be achieved by instead allowing associatedtype declarations to have default values (for example: `associatedtype UniqueIdentifier : Equatable = Storage.Index`), at which point we might be one step away from going full circle and eliminating the distinction between associatedtypes and typealiases once again.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Mon, May 9, 2016 at 01:52 David Hart &lt;david at hartbit.com &lt;mailto:david at hartbit.com&gt;&gt; wrote:<br>&gt;&gt;&gt; I understand that name clashing in those instances is important to discuss, but I still think it is slightly orthogonal to the proposal. Let me try to explain why.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If typealises in protocols are to have the same semantics as alises outside protocols (as I think they should), then they don’t change anything about the rules of collision. For example, the problem already exists today with associated types:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol Foo {<br>&gt;&gt;&gt;     associatedtype Inner: IntegerType<br>&gt;&gt;&gt;     func foo(inner: Inner)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol Bar {<br>&gt;&gt;&gt;     associatedtype Inner: FloatingPointType<br>&gt;&gt;&gt;     var inner: Inner { get }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct FooBarImpl: Foo, Bar { // error: Type ‘FooBarImpl’ does not conform to protocol ‘Bar&#39;<br>&gt;&gt;&gt;     func foo(inner: Int) {}<br>&gt;&gt;&gt;     var inner: Float<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Type aliasing would not change anything about the fact that those collisions already exists in the language and are not very well handled: either they are meant to be forbidden but in that case we need better diagnostics, or we want to have a way to work around them. Perhaps you’d like to start a discussion around fixing that ?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 09 May 2016, at 08:06, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I see your point that nothing breaks in the stdlib with your proposal alone. It&#39;s undeniably true--by construction!--that a purely additive feature, if never used, will not cause problems.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That said, since the time that this feature was outlined in Doug&#39;s manifesto, I have been wondering how clashes such as the examples in my previous email are to be handled--i.e. what the rules of the language are to be--which I think is certainly germane to your proposal. Can a conforming type override a protocol typealias? Can a type conform to two protocols with conflicting typealiases if all requirements are otherwise satisfied? Surely, these merit discussion in your proposal.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mon, May 9, 2016 at 12:48 AM David Hart &lt;david at hartbit.com &lt;mailto:david at hartbit.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; Hello Xiaodi,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What I mean by there is no impact on existing code is that the language change has no impact. Of course, if the Standard Library then declares a typealias Element in Sequence, it will clash with code which has declared an Element typealias in sub-protocols, but that is separate from the proposal.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 09 May 2016, at 07:28, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If the protocol Sequence has typealias Element, does that mean I also have MyConformingSequence.Element?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If so, I think there is a potential impact on existing code not mentioned. Suppose MyConformingSequence already (unwisely) declares typealias Element. Now, what happens when I try to migrate my code to your proposed version of Swift?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This is a toy example, of course. More generally, though, I wonder about this question:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Suppose two protocols A and B each declare typealias Element. These typealiases are, as you proposed, intended to simplify referencing indirect associated types. But are they themselves considered protocol requirements?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I ask because, suppose I want to conform type T to A and B. I implement all the required methods and properties for such conformance. I declare the appropriate typealiases for the associatedtypes declared in both protocols. But, if A.Element and B.Element are incompatible with each other, it is nonetheless impossible to conform T to both A and B? If it&#39;s forbidden, isn&#39;t that kind of a bummer, since what&#39;s getting in the way is a naming clash arising from a facility intended to simplify the naming of things rather than provide for new functionality? If it&#39;s permitted, what is T.Element? Some clarity here would be nice.<br>&gt;&gt;&gt;&gt;&gt; On Sun, May 8, 2016 at 6:17 PM David Hart via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; Hello,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I’ve come again with another proposal directly from the Generics Manifesto. Please let me know if it needs any modifications before sending the pull request.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Typealiases in protocols and protocol extensions<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Proposal: SE-XXXX &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md&gt;<br>&gt;&gt;&gt;&gt;&gt; Authors: David Hart &lt;https://github.com/hartbit&gt;, Doug Gregor &lt;https://github.com/DougGregor&gt;<br>&gt;&gt;&gt;&gt;&gt; Status: TBD<br>&gt;&gt;&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt;&gt;&gt;  &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#introduction&gt;Introduction<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This proposal is from the Generics Manifesto &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md&gt; and brings the typealias keyword back into protocols for type aliasing.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#motivation&gt;Motivation<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In Swift versions prior to 2.2, the typelias keyword was used outside of protocols to declare type aliases and in protocols to declare associated types. Since SE-0011 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0011-replace-typealias-associated.md&gt; and Swift 2.2, associated type now use the associatedtype keyword and typelias is available for implementing true associated type aliases. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#proposed-solution&gt;Proposed solution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The solution allows the creation of associated type aliases. Here is an example from the standard library:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; protocol Sequence {<br>&gt;&gt;&gt;&gt;&gt;   associatedtype Iterator : IteratorProtocol<br>&gt;&gt;&gt;&gt;&gt;   typealias Element = Iterator.Element<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; The example above shows how this simplifies referencing indirect associated types:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func sum&lt;T: Sequence where T.Element == Int&gt;(sequence: T) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt;     return sequence.reduce(0, combine: +)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;  &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#detailed-design&gt;Detailed design<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The following grammar rules needs to be added:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; protocol-member-declaration → protocol-typealias-declaration<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; protocol-typealias-declaration → typealias-declaration<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This will have no impact on existing code, but will probably require improving the Fix-It that was created for migrating typealias to associatedtype in Swift 2.2.<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160514/1460e899/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Typealiases in protocols and protocol extensions</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May  9, 2016 at 06:00:00am</p></header><div class="content"><p>And to clarify, FWIW, I think it&#39;d be wonderful to implement this feature,<br>and I share your sense that sometimes conversations on this list get a<br>little sidetracked. My comments are not meant to suggest that this is not a<br>good feature; rather, they go to your question to the list--does your<br>proposal need any modifications before a PR?<br></p><p>IMO, some sections need to be fleshed out. Some discussion on how your<br>proposed rules interact with other aspects of the language when they are<br>used in the daily task of conforming types to protocols is called for. I<br>accept your point that perhaps it doesn&#39;t belong in the &#39;Impact on Existing<br>Code&#39; section.<br></p><p>I hope you&#39;ll forgive me for saying that the proposal seems, overall,<br>hastily written. That there are two misspelled instances of &quot;typealias&quot; in<br>a proposal about typealias does not give one confidence that what is<br>proposed has been sufficiently considered.<br></p><p>On Mon, May 9, 2016 at 01:06 Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br></p><p>&gt; I see your point that nothing breaks in the stdlib with your proposal<br>&gt; alone. It&#39;s undeniably true--by construction!--that a purely additive<br>&gt; feature, if never used, will not cause problems.<br>&gt;<br>&gt; That said, since the time that this feature was outlined in Doug&#39;s<br>&gt; manifesto, I have been wondering how clashes such as the examples in my<br>&gt; previous email are to be handled--i.e. what the rules of the language are<br>&gt; to be--which I think is certainly germane to your proposal. Can a<br>&gt; conforming type override a protocol typealias? Can a type conform to two<br>&gt; protocols with conflicting typealiases if all requirements are otherwise<br>&gt; satisfied? Surely, these merit discussion in your proposal.<br>&gt;<br>&gt; On Mon, May 9, 2016 at 12:48 AM David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;<br>&gt;&gt; Hello Xiaodi,<br>&gt;&gt;<br>&gt;&gt; What I mean by there is no impact on existing code is that the language<br>&gt;&gt; change has no impact. Of course, if the Standard Library then declares a<br>&gt;&gt; typealias Element in Sequence, it will clash with code which has declared<br>&gt;&gt; an Element typealias in sub-protocols, but that is separate from the<br>&gt;&gt; proposal.<br>&gt;&gt;<br>&gt;&gt; On 09 May 2016, at 07:28, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; If the protocol Sequence has typealias Element, does that mean I also<br>&gt;&gt; have MyConformingSequence.Element?<br>&gt;&gt;<br>&gt;&gt; If so, I think there is a potential impact on existing code not<br>&gt;&gt; mentioned. Suppose MyConformingSequence already (unwisely) declares<br>&gt;&gt; typealias Element. Now, what happens when I try to migrate my code to your<br>&gt;&gt; proposed version of Swift?<br>&gt;&gt;<br>&gt;&gt; This is a toy example, of course. More generally, though, I wonder about<br>&gt;&gt; this question:<br>&gt;&gt;<br>&gt;&gt; Suppose two protocols A and B each declare typealias Element. These<br>&gt;&gt; typealiases are, as you proposed, intended to simplify referencing indirect<br>&gt;&gt; associated types. But are they themselves considered protocol requirements?<br>&gt;&gt;<br>&gt;&gt; I ask because, suppose I want to conform type T to A and B. I implement<br>&gt;&gt; all the required methods and properties for such conformance. I declare the<br>&gt;&gt; appropriate typealiases for the associatedtypes declared in both protocols.<br>&gt;&gt; But, if A.Element and B.Element are incompatible with each other, it is<br>&gt;&gt; nonetheless impossible to conform T to both A and B? If it&#39;s forbidden,<br>&gt;&gt; isn&#39;t that kind of a bummer, since what&#39;s getting in the way is a naming<br>&gt;&gt; clash arising from a facility intended to simplify the naming of things<br>&gt;&gt; rather than provide for new functionality? If it&#39;s permitted, what is<br>&gt;&gt; T.Element? Some clarity here would be nice.<br>&gt;&gt; On Sun, May 8, 2016 at 6:17 PM David Hart via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Hello,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I’ve come again with another proposal directly from the Generics<br>&gt;&gt;&gt; Manifesto. Please let me know if it needs any modifications before sending<br>&gt;&gt;&gt; the pull request.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Typealiases in protocols and protocol extensions<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    - Proposal: SE-XXXX<br>&gt;&gt;&gt;    &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md&gt;<br>&gt;&gt;&gt;    - Authors: David Hart &lt;https://github.com/hartbit&gt;, Doug Gregor<br>&gt;&gt;&gt;    &lt;https://github.com/DougGregor&gt;<br>&gt;&gt;&gt;    - Status: TBD<br>&gt;&gt;&gt;    - Review manager: TBD<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#introduction&gt;<br>&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This proposal is from the Generics Manifesto<br>&gt;&gt;&gt; &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md&gt; and<br>&gt;&gt;&gt; brings the typealias keyword back into protocols for type aliasing.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#motivation&gt;<br>&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In Swift versions prior to 2.2, the typelias keyword was used outside<br>&gt;&gt;&gt; of protocols to declare type aliases and in protocols to declare associated<br>&gt;&gt;&gt; types. Since SE-0011<br>&gt;&gt;&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0011-replace-typealias-associated.md&gt; and<br>&gt;&gt;&gt; Swift 2.2, associated type now use the associatedtype keyword and<br>&gt;&gt;&gt; typelias is available for implementing true associated type aliases.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#proposed-solution&gt;Proposed<br>&gt;&gt;&gt; solution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The solution allows the creation of associated type aliases. Here is an<br>&gt;&gt;&gt; example from the standard library:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; protocol Sequence {<br>&gt;&gt;&gt;   associatedtype Iterator : IteratorProtocol<br>&gt;&gt;&gt;   typealias Element = Iterator.Element<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The example above shows how this simplifies referencing indirect<br>&gt;&gt;&gt; associated types:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func sum&lt;T: Sequence where T.Element == Int&gt;(sequence: T) -&gt; Int {<br>&gt;&gt;&gt;     return sequence.reduce(0, combine: +)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#detailed-design&gt;Detailed<br>&gt;&gt;&gt; design<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The following grammar rules needs to be added:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *protocol-member-declaration* → *protocol-typealias-declaration*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *protocol-typealias-declaration* → *typealias-declaration*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#impact-on-existing-code&gt;Impact<br>&gt;&gt;&gt; on existing code<br>&gt;&gt;&gt; This will have no impact on existing code, but will probably require<br>&gt;&gt;&gt; improving the Fix-It that was created for migrating typealias to<br>&gt;&gt;&gt; associatedtype in Swift 2.2.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160509/63fec869/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>Typealiases in protocols and protocol extensions</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>May  9, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On 09 May 2016, at 08:53, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; And to clarify, FWIW, I think it&#39;d be wonderful to implement this feature, and I share your sense that sometimes conversations on this list get a little sidetracked. My comments are not meant to suggest that this is not a good feature; rather, they go to your question to the list--does your proposal need any modifications before a PR?<br>&gt; <br>&gt; IMO, some sections need to be fleshed out. Some discussion on how your proposed rules interact with other aspects of the language when they are used in the daily task of conforming types to protocols is called for. I accept your point that perhaps it doesn&#39;t belong in the &#39;Impact on Existing Code&#39; section.<br></p><p>I’ll add something.<br></p><p>&gt; I hope you&#39;ll forgive me for saying that the proposal seems, overall, hastily written. That there are two misspelled instances of &quot;typealias&quot; in a proposal about typealias does not give one confidence that what is proposed has been sufficiently considered.<br></p><p>I don’t mind you saying it, it is a very early draft. That’s why I’m putting it in front of the community before sending it for a Pull Request.<br></p><p>&gt; On Mon, May 9, 2016 at 01:06 Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt; I see your point that nothing breaks in the stdlib with your proposal alone. It&#39;s undeniably true--by construction!--that a purely additive feature, if never used, will not cause problems.<br>&gt; <br>&gt; That said, since the time that this feature was outlined in Doug&#39;s manifesto, I have been wondering how clashes such as the examples in my previous email are to be handled--i.e. what the rules of the language are to be--which I think is certainly germane to your proposal. Can a conforming type override a protocol typealias? Can a type conform to two protocols with conflicting typealiases if all requirements are otherwise satisfied? Surely, these merit discussion in your proposal.<br>&gt; <br>&gt; On Mon, May 9, 2016 at 12:48 AM David Hart &lt;david at hartbit.com &lt;mailto:david at hartbit.com&gt;&gt; wrote:<br>&gt; Hello Xiaodi,<br>&gt; <br>&gt; What I mean by there is no impact on existing code is that the language change has no impact. Of course, if the Standard Library then declares a typealias Element in Sequence, it will clash with code which has declared an Element typealias in sub-protocols, but that is separate from the proposal.<br>&gt; <br>&gt;&gt; On 09 May 2016, at 07:28, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; If the protocol Sequence has typealias Element, does that mean I also have MyConformingSequence.Element?<br>&gt;&gt; <br>&gt;&gt; If so, I think there is a potential impact on existing code not mentioned. Suppose MyConformingSequence already (unwisely) declares typealias Element. Now, what happens when I try to migrate my code to your proposed version of Swift?<br>&gt;&gt; <br>&gt;&gt; This is a toy example, of course. More generally, though, I wonder about this question:<br>&gt;&gt; <br>&gt;&gt; Suppose two protocols A and B each declare typealias Element. These typealiases are, as you proposed, intended to simplify referencing indirect associated types. But are they themselves considered protocol requirements?<br>&gt;&gt; <br>&gt;&gt; I ask because, suppose I want to conform type T to A and B. I implement all the required methods and properties for such conformance. I declare the appropriate typealiases for the associatedtypes declared in both protocols. But, if A.Element and B.Element are incompatible with each other, it is nonetheless impossible to conform T to both A and B? If it&#39;s forbidden, isn&#39;t that kind of a bummer, since what&#39;s getting in the way is a naming clash arising from a facility intended to simplify the naming of things rather than provide for new functionality? If it&#39;s permitted, what is T.Element? Some clarity here would be nice.<br>&gt;&gt; On Sun, May 8, 2016 at 6:17 PM David Hart via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Hello,<br>&gt;&gt; <br>&gt;&gt; I’ve come again with another proposal directly from the Generics Manifesto. Please let me know if it needs any modifications before sending the pull request.<br>&gt;&gt; <br>&gt;&gt; Typealiases in protocols and protocol extensions<br>&gt;&gt; <br>&gt;&gt; Proposal: SE-XXXX &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md&gt;<br>&gt;&gt; Authors: David Hart &lt;https://github.com/hartbit&gt;, Doug Gregor &lt;https://github.com/DougGregor&gt;<br>&gt;&gt; Status: TBD<br>&gt;&gt; Review manager: TBD<br>&gt;&gt;  &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#introduction&gt;Introduction<br>&gt;&gt; <br>&gt;&gt; This proposal is from the Generics Manifesto &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md&gt; and brings the typealias keyword back into protocols for type aliasing.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#motivation&gt;Motivation<br>&gt;&gt; <br>&gt;&gt; In Swift versions prior to 2.2, the typelias keyword was used outside of protocols to declare type aliases and in protocols to declare associated types. Since SE-0011 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0011-replace-typealias-associated.md&gt; and Swift 2.2, associated type now use the associatedtype keyword and typelias is available for implementing true associated type aliases. <br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#proposed-solution&gt;Proposed solution<br>&gt;&gt; <br>&gt;&gt; The solution allows the creation of associated type aliases. Here is an example from the standard library:<br>&gt;&gt; <br>&gt;&gt; protocol Sequence {<br>&gt;&gt;   associatedtype Iterator : IteratorProtocol<br>&gt;&gt;   typealias Element = Iterator.Element<br>&gt;&gt; }<br>&gt;&gt; The example above shows how this simplifies referencing indirect associated types:<br>&gt;&gt; <br>&gt;&gt; func sum&lt;T: Sequence where T.Element == Int&gt;(sequence: T) -&gt; Int {<br>&gt;&gt;     return sequence.reduce(0, combine: +)<br>&gt;&gt; }<br>&gt;&gt;  &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#detailed-design&gt;Detailed design<br>&gt;&gt; <br>&gt;&gt; The following grammar rules needs to be added:<br>&gt;&gt; <br>&gt;&gt; protocol-member-declaration → protocol-typealias-declaration<br>&gt;&gt; <br>&gt;&gt; protocol-typealias-declaration → typealias-declaration<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt; <br>&gt;&gt; This will have no impact on existing code, but will probably require improving the Fix-It that was created for migrating typealias to associatedtype in Swift 2.2.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160509/10b13bf0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Typealiases in protocols and protocol extensions</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May  9, 2016 at 07:00:00am</p></header><div class="content"><p>Great, I hope this proposal finds much success with the community.<br></p><p>One more thing: your title makes mention of protocol extensions, but<br>protocol extensions are mentioned nowhere else. Please include details on<br>typealiases in protocol extensions within the text or remove it altogether<br>from the proposal.<br></p><p>On Mon, May 9, 2016 at 02:24 David Hart &lt;david at hartbit.com&gt; wrote:<br></p><p>&gt; On 09 May 2016, at 08:53, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; And to clarify, FWIW, I think it&#39;d be wonderful to implement this feature,<br>&gt; and I share your sense that sometimes conversations on this list get a<br>&gt; little sidetracked. My comments are not meant to suggest that this is not a<br>&gt; good feature; rather, they go to your question to the list--does your<br>&gt; proposal need any modifications before a PR?<br>&gt;<br>&gt; IMO, some sections need to be fleshed out. Some discussion on how your<br>&gt; proposed rules interact with other aspects of the language when they are<br>&gt; used in the daily task of conforming types to protocols is called for. I<br>&gt; accept your point that perhaps it doesn&#39;t belong in the &#39;Impact on Existing<br>&gt; Code&#39; section.<br>&gt;<br>&gt;<br>&gt; I’ll add something.<br>&gt;<br>&gt; I hope you&#39;ll forgive me for saying that the proposal seems, overall,<br>&gt; hastily written. That there are two misspelled instances of &quot;typealias&quot; in<br>&gt; a proposal about typealias does not give one confidence that what is<br>&gt; proposed has been sufficiently considered.<br>&gt;<br>&gt;<br>&gt; I don’t mind you saying it, it is a very early draft. That’s why I’m<br>&gt; putting it in front of the community before sending it for a Pull Request.<br>&gt;<br>&gt; On Mon, May 9, 2016 at 01:06 Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; I see your point that nothing breaks in the stdlib with your proposal<br>&gt;&gt; alone. It&#39;s undeniably true--by construction!--that a purely additive<br>&gt;&gt; feature, if never used, will not cause problems.<br>&gt;&gt;<br>&gt;&gt; That said, since the time that this feature was outlined in Doug&#39;s<br>&gt;&gt; manifesto, I have been wondering how clashes such as the examples in my<br>&gt;&gt; previous email are to be handled--i.e. what the rules of the language are<br>&gt;&gt; to be--which I think is certainly germane to your proposal. Can a<br>&gt;&gt; conforming type override a protocol typealias? Can a type conform to two<br>&gt;&gt; protocols with conflicting typealiases if all requirements are otherwise<br>&gt;&gt; satisfied? Surely, these merit discussion in your proposal.<br>&gt;&gt;<br>&gt;&gt; On Mon, May 9, 2016 at 12:48 AM David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Hello Xiaodi,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; What I mean by there is no impact on existing code is that the language<br>&gt;&gt;&gt; change has no impact. Of course, if the Standard Library then declares a<br>&gt;&gt;&gt; typealias Element in Sequence, it will clash with code which has declared<br>&gt;&gt;&gt; an Element typealias in sub-protocols, but that is separate from the<br>&gt;&gt;&gt; proposal.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On 09 May 2016, at 07:28, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If the protocol Sequence has typealias Element, does that mean I also<br>&gt;&gt;&gt; have MyConformingSequence.Element?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If so, I think there is a potential impact on existing code not<br>&gt;&gt;&gt; mentioned. Suppose MyConformingSequence already (unwisely) declares<br>&gt;&gt;&gt; typealias Element. Now, what happens when I try to migrate my code to your<br>&gt;&gt;&gt; proposed version of Swift?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This is a toy example, of course. More generally, though, I wonder about<br>&gt;&gt;&gt; this question:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Suppose two protocols A and B each declare typealias Element. These<br>&gt;&gt;&gt; typealiases are, as you proposed, intended to simplify referencing indirect<br>&gt;&gt;&gt; associated types. But are they themselves considered protocol requirements?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I ask because, suppose I want to conform type T to A and B. I implement<br>&gt;&gt;&gt; all the required methods and properties for such conformance. I declare the<br>&gt;&gt;&gt; appropriate typealiases for the associatedtypes declared in both protocols.<br>&gt;&gt;&gt; But, if A.Element and B.Element are incompatible with each other, it is<br>&gt;&gt;&gt; nonetheless impossible to conform T to both A and B? If it&#39;s forbidden,<br>&gt;&gt;&gt; isn&#39;t that kind of a bummer, since what&#39;s getting in the way is a naming<br>&gt;&gt;&gt; clash arising from a facility intended to simplify the naming of things<br>&gt;&gt;&gt; rather than provide for new functionality? If it&#39;s permitted, what is<br>&gt;&gt;&gt; T.Element? Some clarity here would be nice.<br>&gt;&gt;&gt; On Sun, May 8, 2016 at 6:17 PM David Hart via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Hello,<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I’ve come again with another proposal directly from the Generics<br>&gt;&gt;&gt;&gt; Manifesto. Please let me know if it needs any modifications before sending<br>&gt;&gt;&gt;&gt; the pull request.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Typealiases in protocols and protocol extensions<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;    - Proposal: SE-XXXX<br>&gt;&gt;&gt;&gt;    &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md&gt;<br>&gt;&gt;&gt;&gt;    - Authors: David Hart &lt;https://github.com/hartbit&gt;, Doug Gregor<br>&gt;&gt;&gt;&gt;    &lt;https://github.com/DougGregor&gt;<br>&gt;&gt;&gt;&gt;    - Status: TBD<br>&gt;&gt;&gt;&gt;    - Review manager: TBD<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#introduction&gt;<br>&gt;&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This proposal is from the Generics Manifesto<br>&gt;&gt;&gt;&gt; &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md&gt; and<br>&gt;&gt;&gt;&gt; brings the typealias keyword back into protocols for type aliasing.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#motivation&gt;<br>&gt;&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; In Swift versions prior to 2.2, the typelias keyword was used outside<br>&gt;&gt;&gt;&gt; of protocols to declare type aliases and in protocols to declare associated<br>&gt;&gt;&gt;&gt; types. Since SE-0011<br>&gt;&gt;&gt;&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0011-replace-typealias-associated.md&gt; and<br>&gt;&gt;&gt;&gt; Swift 2.2, associated type now use the associatedtype keyword and<br>&gt;&gt;&gt;&gt; typelias is available for implementing true associated type aliases.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#proposed-solution&gt;Proposed<br>&gt;&gt;&gt;&gt; solution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The solution allows the creation of associated type aliases. Here is an<br>&gt;&gt;&gt;&gt; example from the standard library:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; protocol Sequence {<br>&gt;&gt;&gt;&gt;   associatedtype Iterator : IteratorProtocol<br>&gt;&gt;&gt;&gt;   typealias Element = Iterator.Element<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The example above shows how this simplifies referencing indirect<br>&gt;&gt;&gt;&gt; associated types:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; func sum&lt;T: Sequence where T.Element == Int&gt;(sequence: T) -&gt; Int {<br>&gt;&gt;&gt;&gt;     return sequence.reduce(0, combine: +)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#detailed-design&gt;Detailed<br>&gt;&gt;&gt;&gt; design<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The following grammar rules needs to be added:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; *protocol-member-declaration* → *protocol-typealias-declaration*<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; *protocol-typealias-declaration* → *typealias-declaration*<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#impact-on-existing-code&gt;Impact<br>&gt;&gt;&gt;&gt; on existing code<br>&gt;&gt;&gt;&gt; This will have no impact on existing code, but will probably require<br>&gt;&gt;&gt;&gt; improving the Fix-It that was created for migrating typealias to<br>&gt;&gt;&gt;&gt; associatedtype in Swift 2.2.<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160509/401f6757/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>Typealiases in protocols and protocol extensions</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>May  9, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On 09 May 2016, at 09:30, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; Great, I hope this proposal finds much success with the community.<br>&gt; <br>&gt; One more thing: your title makes mention of protocol extensions, but protocol extensions are mentioned nowhere else. Please include details on typealiases in protocol extensions within the text or remove it altogether from the proposal.<br></p><p>I left it in for now because it was explicitly mentioned in the Generics Manifesto (the title is a simple copy and paste), but I have yet to find good examples to illustrate their usefulness. Perhaps you could help me out on this one?<br></p><p>&gt; On Mon, May 9, 2016 at 02:24 David Hart &lt;david at hartbit.com &lt;mailto:david at hartbit.com&gt;&gt; wrote:<br>&gt;&gt; On 09 May 2016, at 08:53, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; And to clarify, FWIW, I think it&#39;d be wonderful to implement this feature, and I share your sense that sometimes conversations on this list get a little sidetracked. My comments are not meant to suggest that this is not a good feature; rather, they go to your question to the list--does your proposal need any modifications before a PR?<br>&gt;&gt; <br>&gt;&gt; IMO, some sections need to be fleshed out. Some discussion on how your proposed rules interact with other aspects of the language when they are used in the daily task of conforming types to protocols is called for. I accept your point that perhaps it doesn&#39;t belong in the &#39;Impact on Existing Code&#39; section.<br>&gt; <br>&gt; I’ll add something.<br>&gt; <br>&gt;&gt; I hope you&#39;ll forgive me for saying that the proposal seems, overall, hastily written. That there are two misspelled instances of &quot;typealias&quot; in a proposal about typealias does not give one confidence that what is proposed has been sufficiently considered.<br>&gt; <br>&gt; I don’t mind you saying it, it is a very early draft. That’s why I’m putting it in front of the community before sending it for a Pull Request.<br>&gt; <br>&gt;&gt; On Mon, May 9, 2016 at 01:06 Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; I see your point that nothing breaks in the stdlib with your proposal alone. It&#39;s undeniably true--by construction!--that a purely additive feature, if never used, will not cause problems.<br>&gt;&gt; <br>&gt;&gt; That said, since the time that this feature was outlined in Doug&#39;s manifesto, I have been wondering how clashes such as the examples in my previous email are to be handled--i.e. what the rules of the language are to be--which I think is certainly germane to your proposal. Can a conforming type override a protocol typealias? Can a type conform to two protocols with conflicting typealiases if all requirements are otherwise satisfied? Surely, these merit discussion in your proposal.<br>&gt;&gt; <br>&gt;&gt; On Mon, May 9, 2016 at 12:48 AM David Hart &lt;david at hartbit.com &lt;mailto:david at hartbit.com&gt;&gt; wrote:<br>&gt;&gt; Hello Xiaodi,<br>&gt;&gt; <br>&gt;&gt; What I mean by there is no impact on existing code is that the language change has no impact. Of course, if the Standard Library then declares a typealias Element in Sequence, it will clash with code which has declared an Element typealias in sub-protocols, but that is separate from the proposal.<br>&gt;&gt; <br>&gt;&gt;&gt; On 09 May 2016, at 07:28, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If the protocol Sequence has typealias Element, does that mean I also have MyConformingSequence.Element?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If so, I think there is a potential impact on existing code not mentioned. Suppose MyConformingSequence already (unwisely) declares typealias Element. Now, what happens when I try to migrate my code to your proposed version of Swift?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a toy example, of course. More generally, though, I wonder about this question:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Suppose two protocols A and B each declare typealias Element. These typealiases are, as you proposed, intended to simplify referencing indirect associated types. But are they themselves considered protocol requirements?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I ask because, suppose I want to conform type T to A and B. I implement all the required methods and properties for such conformance. I declare the appropriate typealiases for the associatedtypes declared in both protocols. But, if A.Element and B.Element are incompatible with each other, it is nonetheless impossible to conform T to both A and B? If it&#39;s forbidden, isn&#39;t that kind of a bummer, since what&#39;s getting in the way is a naming clash arising from a facility intended to simplify the naming of things rather than provide for new functionality? If it&#39;s permitted, what is T.Element? Some clarity here would be nice.<br>&gt;&gt;&gt; On Sun, May 8, 2016 at 6:17 PM David Hart via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; Hello,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’ve come again with another proposal directly from the Generics Manifesto. Please let me know if it needs any modifications before sending the pull request.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Typealiases in protocols and protocol extensions<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposal: SE-XXXX &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md&gt;<br>&gt;&gt;&gt; Authors: David Hart &lt;https://github.com/hartbit&gt;, Doug Gregor &lt;https://github.com/DougGregor&gt;<br>&gt;&gt;&gt; Status: TBD<br>&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt;  &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#introduction&gt;Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This proposal is from the Generics Manifesto &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md&gt; and brings the typealias keyword back into protocols for type aliasing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#motivation&gt;Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In Swift versions prior to 2.2, the typelias keyword was used outside of protocols to declare type aliases and in protocols to declare associated types. Since SE-0011 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0011-replace-typealias-associated.md&gt; and Swift 2.2, associated type now use the associatedtype keyword and typelias is available for implementing true associated type aliases. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#proposed-solution&gt;Proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The solution allows the creation of associated type aliases. Here is an example from the standard library:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol Sequence {<br>&gt;&gt;&gt;   associatedtype Iterator : IteratorProtocol<br>&gt;&gt;&gt;   typealias Element = Iterator.Element<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; The example above shows how this simplifies referencing indirect associated types:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func sum&lt;T: Sequence where T.Element == Int&gt;(sequence: T) -&gt; Int {<br>&gt;&gt;&gt;     return sequence.reduce(0, combine: +)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;  &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#detailed-design&gt;Detailed design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The following grammar rules needs to be added:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol-member-declaration → protocol-typealias-declaration<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol-typealias-declaration → typealias-declaration<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This will have no impact on existing code, but will probably require improving the Fix-It that was created for migrating typealias to associatedtype in Swift 2.2.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160509/30d892a1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Typealiases in protocols and protocol extensions</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May  9, 2016 at 03:00:00am</p></header><div class="content"><p>On Mon, May 9, 2016 at 2:33 AM, David Hart &lt;david at hartbit.com&gt; wrote:<br></p><p>&gt;<br>&gt; On 09 May 2016, at 09:30, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; Great, I hope this proposal finds much success with the community.<br>&gt;<br>&gt; One more thing: your title makes mention of protocol extensions, but<br>&gt; protocol extensions are mentioned nowhere else. Please include details on<br>&gt; typealiases in protocol extensions within the text or remove it altogether<br>&gt; from the proposal.<br>&gt;<br>&gt;<br>&gt; I left it in for now because it was explicitly mentioned in the Generics<br>&gt; Manifesto (the title is a simple copy and paste), but I have yet to find<br>&gt; good examples to illustrate their usefulness. Perhaps you could help me out<br>&gt; on this one?<br>&gt;<br></p><p>Nothing&#39;s coming to mind right off the bat. Perhaps the writer of the<br>Manifesto could chime in...<br></p><p>On Mon, May 9, 2016 at 02:24 David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;<br>&gt;&gt; On 09 May 2016, at 08:53, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; And to clarify, FWIW, I think it&#39;d be wonderful to implement this<br>&gt;&gt; feature, and I share your sense that sometimes conversations on this list<br>&gt;&gt; get a little sidetracked. My comments are not meant to suggest that this is<br>&gt;&gt; not a good feature; rather, they go to your question to the list--does your<br>&gt;&gt; proposal need any modifications before a PR?<br>&gt;&gt;<br>&gt;&gt; IMO, some sections need to be fleshed out. Some discussion on how your<br>&gt;&gt; proposed rules interact with other aspects of the language when they are<br>&gt;&gt; used in the daily task of conforming types to protocols is called for. I<br>&gt;&gt; accept your point that perhaps it doesn&#39;t belong in the &#39;Impact on Existing<br>&gt;&gt; Code&#39; section.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I’ll add something.<br>&gt;&gt;<br>&gt;&gt; I hope you&#39;ll forgive me for saying that the proposal seems, overall,<br>&gt;&gt; hastily written. That there are two misspelled instances of &quot;typealias&quot; in<br>&gt;&gt; a proposal about typealias does not give one confidence that what is<br>&gt;&gt; proposed has been sufficiently considered.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I don’t mind you saying it, it is a very early draft. That’s why I’m<br>&gt;&gt; putting it in front of the community before sending it for a Pull Request.<br>&gt;&gt;<br>&gt;&gt; On Mon, May 9, 2016 at 01:06 Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; I see your point that nothing breaks in the stdlib with your proposal<br>&gt;&gt;&gt; alone. It&#39;s undeniably true--by construction!--that a purely additive<br>&gt;&gt;&gt; feature, if never used, will not cause problems.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; That said, since the time that this feature was outlined in Doug&#39;s<br>&gt;&gt;&gt; manifesto, I have been wondering how clashes such as the examples in my<br>&gt;&gt;&gt; previous email are to be handled--i.e. what the rules of the language are<br>&gt;&gt;&gt; to be--which I think is certainly germane to your proposal. Can a<br>&gt;&gt;&gt; conforming type override a protocol typealias? Can a type conform to two<br>&gt;&gt;&gt; protocols with conflicting typealiases if all requirements are otherwise<br>&gt;&gt;&gt; satisfied? Surely, these merit discussion in your proposal.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Mon, May 9, 2016 at 12:48 AM David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Hello Xiaodi,<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; What I mean by there is no impact on existing code is that the language<br>&gt;&gt;&gt;&gt; change has no impact. Of course, if the Standard Library then declares a<br>&gt;&gt;&gt;&gt; typealias Element in Sequence, it will clash with code which has declared<br>&gt;&gt;&gt;&gt; an Element typealias in sub-protocols, but that is separate from the<br>&gt;&gt;&gt;&gt; proposal.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On 09 May 2016, at 07:28, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; If the protocol Sequence has typealias Element, does that mean I also<br>&gt;&gt;&gt;&gt; have MyConformingSequence.Element?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; If so, I think there is a potential impact on existing code not<br>&gt;&gt;&gt;&gt; mentioned. Suppose MyConformingSequence already (unwisely) declares<br>&gt;&gt;&gt;&gt; typealias Element. Now, what happens when I try to migrate my code to your<br>&gt;&gt;&gt;&gt; proposed version of Swift?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This is a toy example, of course. More generally, though, I wonder<br>&gt;&gt;&gt;&gt; about this question:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Suppose two protocols A and B each declare typealias Element. These<br>&gt;&gt;&gt;&gt; typealiases are, as you proposed, intended to simplify referencing indirect<br>&gt;&gt;&gt;&gt; associated types. But are they themselves considered protocol requirements?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I ask because, suppose I want to conform type T to A and B. I implement<br>&gt;&gt;&gt;&gt; all the required methods and properties for such conformance. I declare the<br>&gt;&gt;&gt;&gt; appropriate typealiases for the associatedtypes declared in both protocols.<br>&gt;&gt;&gt;&gt; But, if A.Element and B.Element are incompatible with each other, it is<br>&gt;&gt;&gt;&gt; nonetheless impossible to conform T to both A and B? If it&#39;s forbidden,<br>&gt;&gt;&gt;&gt; isn&#39;t that kind of a bummer, since what&#39;s getting in the way is a naming<br>&gt;&gt;&gt;&gt; clash arising from a facility intended to simplify the naming of things<br>&gt;&gt;&gt;&gt; rather than provide for new functionality? If it&#39;s permitted, what is<br>&gt;&gt;&gt;&gt; T.Element? Some clarity here would be nice.<br>&gt;&gt;&gt;&gt; On Sun, May 8, 2016 at 6:17 PM David Hart via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Hello,<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I’ve come again with another proposal directly from the Generics<br>&gt;&gt;&gt;&gt;&gt; Manifesto. Please let me know if it needs any modifications before sending<br>&gt;&gt;&gt;&gt;&gt; the pull request.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Typealiases in protocols and protocol extensions<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;    - Proposal: SE-XXXX<br>&gt;&gt;&gt;&gt;&gt;    &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md&gt;<br>&gt;&gt;&gt;&gt;&gt;    - Authors: David Hart &lt;https://github.com/hartbit&gt;, Doug Gregor<br>&gt;&gt;&gt;&gt;&gt;    &lt;https://github.com/DougGregor&gt;<br>&gt;&gt;&gt;&gt;&gt;    - Status: TBD<br>&gt;&gt;&gt;&gt;&gt;    - Review manager: TBD<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#introduction&gt;<br>&gt;&gt;&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; This proposal is from the Generics Manifesto<br>&gt;&gt;&gt;&gt;&gt; &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md&gt; and<br>&gt;&gt;&gt;&gt;&gt; brings the typealias keyword back into protocols for type aliasing.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#motivation&gt;<br>&gt;&gt;&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; In Swift versions prior to 2.2, the typelias keyword was used outside<br>&gt;&gt;&gt;&gt;&gt; of protocols to declare type aliases and in protocols to declare associated<br>&gt;&gt;&gt;&gt;&gt; types. Since SE-0011<br>&gt;&gt;&gt;&gt;&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0011-replace-typealias-associated.md&gt; and<br>&gt;&gt;&gt;&gt;&gt; Swift 2.2, associated type now use the associatedtype keyword and<br>&gt;&gt;&gt;&gt;&gt; typelias is available for implementing true associated type aliases.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#proposed-solution&gt;Proposed<br>&gt;&gt;&gt;&gt;&gt; solution<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; The solution allows the creation of associated type aliases. Here is<br>&gt;&gt;&gt;&gt;&gt; an example from the standard library:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; protocol Sequence {<br>&gt;&gt;&gt;&gt;&gt;   associatedtype Iterator : IteratorProtocol<br>&gt;&gt;&gt;&gt;&gt;   typealias Element = Iterator.Element<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; The example above shows how this simplifies referencing indirect<br>&gt;&gt;&gt;&gt;&gt; associated types:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; func sum&lt;T: Sequence where T.Element == Int&gt;(sequence: T) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt;     return sequence.reduce(0, combine: +)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#detailed-design&gt;Detailed<br>&gt;&gt;&gt;&gt;&gt; design<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; The following grammar rules needs to be added:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; *protocol-member-declaration* → *protocol-typealias-declaration*<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; *protocol-typealias-declaration* → *typealias-declaration*<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &lt;https://github.com/hartbit/swift-evolution/blob/typealiases-in-protocols/proposals/XXXX-typealiases-in-protocols.md#impact-on-existing-code&gt;Impact<br>&gt;&gt;&gt;&gt;&gt; on existing code<br>&gt;&gt;&gt;&gt;&gt; This will have no impact on existing code, but will probably require<br>&gt;&gt;&gt;&gt;&gt; improving the Fix-It that was created for migrating typealias to<br>&gt;&gt;&gt;&gt;&gt; associatedtype in Swift 2.2.<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160509/01b0a268/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
