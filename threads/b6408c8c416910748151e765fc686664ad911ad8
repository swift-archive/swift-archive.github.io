<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ae935c57f716bf88cbebe36849f6cfba?s=50"></div><header><strong>Parameter Validation</strong> from <string>David Hart</string> &lt;david at wittywings.fr&gt;<p>December  6, 2015 at 09:00:00pm</p></header><div class="content"><p>When writing library code, what method of parameter validation would be suggested?<br></p><p>Assert<br></p><p>func greetUser(user: String, times: Int) {<br>	assert(user.count &gt; 0)<br>	assert(times &gt; 0)<br></p><p>	for _ in 0..&lt;times {<br>		print(“Hello \(user)”)<br>	}<br>}<br></p><p>Pros<br>* Easy to use<br></p><p>Cons<br>* Disabled in release<br>* Not unit-testable<br></p><p>Error-Handling<br></p><p>Pros<br>* Unit-testable<br></p><p>Cons<br>* Quickly litters all calling code with try&#39;s<br></p><p>In the case Error-Handling is used, what kind of ErrorType would you suggest?<br></p><p>enum GreetUserError : ErrorType {<br>	case UserEmpty<br>	case TimesInvalid<br>}<br></p><p>func greetUser(user: String, times: Int) throws {<br>	guard user.count &gt; 0 else {<br>		throw GreetUserError.UserEmpty<br>	}<br></p><p>	guard times &gt; 0 else {<br>		throw GreetUserError.TimesInvalid<br>	}<br></p><p>	for _ in 0..&lt;times {<br>		print(“Hello \(user)”)<br>	}<br>}<br></p><p>Or should more generic re-usable errors be used? But less descriptive errors except if messages are provided every times:<br></p><p>enum ParameterError : ErrorType {<br>	case Empty(String)<br>	case NotInRange(String)<br>}<br></p><p>func greetUser(user: String, times: Int) throws {<br>	guard user.count &gt; 0 else {<br>		throw ParameterError.Empty(“user&quot;)<br>	}<br></p><p>	guard times &gt; 0 else {<br>		throw ParameterError.NotInRange(“times&quot;)<br>	}<br></p><p>	for _ in 0..&lt;times {<br>		print(“Hello \(user)”)<br>	}<br>}<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20151206/b6401ad8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>Parameter Validation</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>December  6, 2015 at 09:00:00pm</p></header><div class="content"><p>&gt; On Dec 6, 2015, at 12:49 PM, David Hart via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; When writing library code, what method of parameter validation would be suggested?<br></p><p>Definitely assert. Assert is for illegal calls, i.e. programmer errors, while errors (throw) are for valid runtime error conditions.<br></p><p>&gt; Cons<br>&gt; * Disabled in release<br></p><p>I believe there is a compiler flag to control this, if you want them enabled in the release.<br></p><p>&gt; * Not unit-testable<br></p><p><br>Well, you can’t create tests for rejection of illegal parameters. Which doesn’t seem like a huge loss to me. It would be nice to be able to do this, though. Maybe through some mechanism for catching / recovering from the otherwise-fatal exception triggered by an assert failure?<br></p><p>—Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20151206/230a6bd3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ae935c57f716bf88cbebe36849f6cfba?s=50"></div><header><strong>Parameter Validation</strong> from <string>David Hart</string> &lt;david at wittywings.fr&gt;<p>December  7, 2015 at 08:00:00am</p></header><div class="content"><p>In that case, we really need a way to unit-test assertions, because unit-testing illegal parameters in a library seems critical.<br>David.<br></p><p>&gt; On 07 Dec 2015, at 06:33, Jens Alfke &lt;jens at mooseyard.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 6, 2015, at 12:49 PM, David Hart via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; When writing library code, what method of parameter validation would be suggested?<br>&gt; <br>&gt; Definitely assert. Assert is for illegal calls, i.e. programmer errors, while errors (throw) are for valid runtime error conditions.<br>&gt; <br>&gt;&gt; Cons<br>&gt;&gt; * Disabled in release<br>&gt; <br>&gt; I believe there is a compiler flag to control this, if you want them enabled in the release.<br>&gt; <br>&gt;&gt; * Not unit-testable<br>&gt; <br>&gt; <br>&gt; Well, you can’t create tests for rejection of illegal parameters. Which doesn’t seem like a huge loss to me. It would be nice to be able to do this, though. Maybe through some mechanism for catching / recovering from the otherwise-fatal exception triggered by an assert failure?<br>&gt; <br>&gt; —Jens<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20151207/375648f9/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Parameter Validation</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December  6, 2015 at 11:00:00pm</p></header><div class="content"><p>&gt; When writing library code, what method of parameter validation would be suggested?<br></p><p>It depends.<br></p><p>If the data may come from somewhere out of your control, like a user or the network, throws (or an optional or Bool return value) is an appropriate choice.<br></p><p>If the data will come from a source which should “never” be wrong, like data that has already been parsed or a calculation you perform, then precondition() (rather than assert(), which is removed in production builds) is a good way to run a sanity check.<br></p><p>Basically, if you anticipate that the value could ever be invalid, use throws or an optional/boolean return. If you don’t think the value should ever be invalid, use precondition().<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ae935c57f716bf88cbebe36849f6cfba?s=50"></div><header><strong>Parameter Validation</strong> from <string>David Hart</string> &lt;david at wittywings.fr&gt;<p>December  7, 2015 at 08:00:00am</p></header><div class="content"><p>I’m looking at the special case of library code. If I surface an API in a library, it’s the library user who will call this function. Would you regard this as an assert or throws scenario?<br></p><p>&gt; On 07 Dec 2015, at 08:25, Brent Royal-Gordon via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; When writing library code, what method of parameter validation would be suggested?<br>&gt; <br>&gt; It depends.<br>&gt; <br>&gt; If the data may come from somewhere out of your control, like a user or the network, throws (or an optional or Bool return value) is an appropriate choice.<br>&gt; <br>&gt; If the data will come from a source which should “never” be wrong, like data that has already been parsed or a calculation you perform, then precondition() (rather than assert(), which is removed in production builds) is a good way to run a sanity check.<br>&gt; <br>&gt; Basically, if you anticipate that the value could ever be invalid, use throws or an optional/boolean return. If you don’t think the value should ever be invalid, use precondition().<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Parameter Validation</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December  7, 2015 at 12:00:00am</p></header><div class="content"><p>&gt; I’m looking at the special case of library code. If I surface an API in a library, it’s the library user who will call this function. Would you regard this as an assert or throws scenario?<br></p><p>“Library” is not a special case here—the same basic considerations apply. If you expect API users to pass you raw data from an untrustworthy source, throw. If you expect them to always give you valid data, use precondition().<br></p><p>For example, let’s say you’ve been hired by a company called PayMe to write PayMeKit.<br></p><p>* PayMeServer.setDeveloperToken(_:) takes a token issued by PayMe to each developer, which should be hardcoded into the app. This API should use precondition() to check if the token is valid.<br>* PayMeCard.init(name:cardNumber:expirationMonth:year:) creates an object from data which is probably provided by the user. This API should throw if the data is invalid.<br>* PayMeServer.buyProductWithID(_:usingCard:) is an interesting case. The product ID is probably developer-controlled, and presumably should always be valid, so we’ll precondition() that. But suppose the product ID is valid but the product is out of stock. We don’t want to crash the app, right? So we’ll throw for that one.<br></p><p>(Of course, buyProductWithID would in practice probably be an async call with a completion handler, and instead of throwing, you’d pass an ErrorType to the completion handler. But you get the idea.)<br></p><p>In short: Even when you’re writing a library, you can’t escape the requirement that you think about how your product will be used. Sorry that there’s no single answer I can give.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>Parameter Validation</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>December  7, 2015 at 08:00:00am</p></header><div class="content"><p>&gt; On Dec 6, 2015, at 11:49 PM, David Hart via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; I’m looking at the special case of library code. If I surface an API in a library, it’s the library user who will call this function. Would you regard this as an assert or throws scenario?<br></p><p>Assert. It’s not library vs. non-library, it’s a question of bug vs. legitimate runtime error. Passing an invalid parameter value is a bug.<br></p><p>For example, Foundation is a library, and passing an invalid parameter to a Foundation method triggers an assertion failure.<br></p><p>—Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20151207/9ac8b287/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ae935c57f716bf88cbebe36849f6cfba?s=50"></div><header><strong>Parameter Validation</strong> from <string>David Hart</string> &lt;david at wittywings.fr&gt;<p>December  7, 2015 at 06:00:00pm</p></header><div class="content"><p>But then you can&#39;t unit-test that the function fails on those parameters. To look at a counter-argument, both C# and Java would throw exceptions for parameter validation.<br></p><p>&gt; On 07 Dec 2015, at 17:30, Jens Alfke &lt;jens at mooseyard.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 6, 2015, at 11:49 PM, David Hart via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I’m looking at the special case of library code. If I surface an API in a library, it’s the library user who will call this function. Would you regard this as an assert or throws scenario?<br>&gt; <br>&gt; Assert. It’s not library vs. non-library, it’s a question of bug vs. legitimate runtime error. Passing an invalid parameter value is a bug.<br>&gt; <br>&gt; For example, Foundation is a library, and passing an invalid parameter to a Foundation method triggers an assertion failure.<br>&gt; <br>&gt; —Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20151207/6aff2836/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>Parameter Validation</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>December  7, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 7, 2015, at 9:03 AM, David Hart &lt;david at wittywings.fr&gt; wrote:<br>&gt; <br>&gt; But then you can&#39;t unit-test that the function fails on those parameters. To look at a counter-argument, both C# and Java would throw exceptions for parameter validation.<br></p><p>I agree, that’s a drawback. But the alternative of ‘throwing’ an exception adds so much overhead that it’s IMHO a non-starter. Except in the case where the method can already return/throw errors, but that’s not always going to be the case. Operator overloads are a particular problem for errors — consider range-checking the index to a subscript operator: you have no choice but an assertion, since that method is incapable of returning/throwing errors.<br></p><p>As I said yesterday, I think the best solution is to make the unit testing framework somehow capable of magically recovering from assertion failure. (Which it might be already, at least on Apple platforms — I haven’t explicitly tested what XCTest does, but I don’t remember my test suites ever completely bombing out due to an assertion failure. IIRC they just continue to the next test. But it’s possible I’m forgetting!)<br></p><p>—Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20151207/330a801e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/26b79a145193358c02392e186dccaaf2?s=50"></div><header><strong>Parameter Validation</strong> from <string>Jan Neumüller</string> &lt;nasan at slayers.de&gt;<p>December  7, 2015 at 07:00:00pm</p></header><div class="content"><p>But what overhead? As you know Swift has *NO* exceptions. It’s just syntax sugar for normale error values.<br></p><p>Jan<br></p><p><br>&gt; On 07.12.2015, at 18:18, Jens Alfke via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 7, 2015, at 9:03 AM, David Hart &lt;david at wittywings.fr &lt;mailto:david at wittywings.fr&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; But then you can&#39;t unit-test that the function fails on those parameters. To look at a counter-argument, both C# and Java would throw exceptions for parameter validation.<br>&gt; <br>&gt; I agree, that’s a drawback. But the alternative of ‘throwing’ an exception adds so much overhead that it’s IMHO a non-starter. Except in the case where the method can already return/throw errors, but that’s not always going to be the case. Operator overloads are a particular problem for errors — consider range-checking the index to a subscript operator: you have no choice but an assertion, since that method is incapable of returning/throwing errors.<br>&gt; <br>&gt; As I said yesterday, I think the best solution is to make the unit testing framework somehow capable of magically recovering from assertion failure. (Which it might be already, at least on Apple platforms — I haven’t explicitly tested what XCTest does, but I don’t remember my test suites ever completely bombing out due to an assertion failure. IIRC they just continue to the next test. But it’s possible I’m forgetting!)<br>&gt; <br>&gt; —Jens<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20151207/8ee64923/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>Parameter Validation</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>December  7, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; On Dec 7, 2015, at 10:56 AM, Jan Neumüller via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; But what overhead? As you know Swift has *NO* exceptions. It’s just syntax sugar for normale error values.<br></p><p>Mostly the overhead in the caller of having to pass a (hidden) error parameter into the call, and check the return value and branch afterwards.<br></p><p>(C++/Obj-C exceptions actually have no runtime cost in the normal success case; it’s only throwing an exception that’s expensive.)<br></p><p>—Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20151207/27e4e656/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/26b79a145193358c02392e186dccaaf2?s=50"></div><header><strong>Parameter Validation</strong> from <string>Jan Neumüller</string> &lt;nasan at slayers.de&gt;<p>December  7, 2015 at 08:00:00pm</p></header><div class="content"><p>&gt; On 07.12.2015, at 20:03, Jens Alfke &lt;jens at mooseyard.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 7, 2015, at 10:56 AM, Jan Neumüller via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; But what overhead? As you know Swift has *NO* exceptions. It’s just syntax sugar for normale error values.<br>&gt; <br>&gt; Mostly the overhead in the caller of having to pass a (hidden) error parameter into the call, and check the return value and branch afterwards.<br></p><p>I fail to see any overhead here. Its the absolute minimum to get checked values. Anything less is not checking.<br></p><p>Jan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20151207/18872d47/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>Parameter Validation</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>December  7, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; On Dec 7, 2015, at 11:39 AM, Jan Neumüller via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; I fail to see any overhead here. Its the absolute minimum to get checked values. Anything less is not checking.<br></p><p>There’s no overhead if the function already ‘throws’ / returns errors. But not all functions do that (and some functions _cannot_ do that, like operators.) If a function has to be upgraded to return an error, that _is_ extra overhead, mostly on the caller’s side. (And, as previously noted, this may complicate the programmer’s life too, because now they may have to either propagate ‘throws’ to the caller or add a ‘catch’ handler.)<br></p><p>Anyway, the programming conventions have been clear for a very long time: assertions should be used for programmer errors (like invalid parameters) while returned errors should be used for legitimate runtime error situations (like file-not-found). This predates Swift and even predates Mac OS X*; I think it goes back to OpenStep in the mid-‘90s.<br></p><p>—Jens<br></p><p>* NSError itself isn’t that old, but before that the APIs still returned nil or false for runtime errors.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20151207/bf09d749/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>Parameter Validation</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>December  8, 2015 at 02:00:00am</p></header><div class="content"><p>You enable assertions for release builds then? Remember, I&#39;m talking specifically about library code: the same way that calling NSArray&#39;s objectAtIndex throws an exception (if my memory serves well) for out of bounds indices. At least, NSAssert in Objective-C throws exceptions and is catchable.<br></p><p>&gt; On 08 Dec 2015, at 01:43, Jens Alfke via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 7, 2015, at 11:39 AM, Jan Neumüller via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I fail to see any overhead here. Its the absolute minimum to get checked values. Anything less is not checking.<br>&gt; <br>&gt; There’s no overhead if the function already ‘throws’ / returns errors. But not all functions do that (and some functions _cannot_ do that, like operators.) If a function has to be upgraded to return an error, that _is_ extra overhead, mostly on the caller’s side. (And, as previously noted, this may complicate the programmer’s life too, because now they may have to either propagate ‘throws’ to the caller or add a ‘catch’ handler.)<br>&gt; <br>&gt; Anyway, the programming conventions have been clear for a very long time: assertions should be used for programmer errors (like invalid parameters) while returned errors should be used for legitimate runtime error situations (like file-not-found). This predates Swift and even predates Mac OS X*; I think it goes back to OpenStep in the mid-‘90s.<br>&gt; <br>&gt; —Jens<br>&gt; <br>&gt; * NSError itself isn’t that old, but before that the APIs still returned nil or false for runtime errors.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20151208/de2ed184/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Parameter Validation</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December  7, 2015 at 05:00:00pm</p></header><div class="content"><p>precondition() is enabled for release builds.<br></p><p>On Mon, Dec 7, 2015 at 5:24 PM, David Hart via swift-users &lt;<br>swift-users at swift.org&gt; wrote:<br></p><p>&gt; You enable assertions for release builds then? Remember, I&#39;m talking<br>&gt; specifically about library code: the same way that calling NSArray&#39;s<br>&gt; objectAtIndex throws an exception (if my memory serves well) for out of<br>&gt; bounds indices. At least, NSAssert in Objective-C throws exceptions and is<br>&gt; catchable.<br>&gt;<br>&gt; On 08 Dec 2015, at 01:43, Jens Alfke via swift-users &lt;<br>&gt; swift-users at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Dec 7, 2015, at 11:39 AM, Jan Neumüller via swift-users &lt;<br>&gt; swift-users at swift.org&gt; wrote:<br>&gt;<br>&gt; I fail to see any overhead here. Its the absolute minimum to get checked<br>&gt; values. Anything less is not checking.<br>&gt;<br>&gt;<br>&gt; There’s no overhead if the function already ‘throws’ / returns errors. But<br>&gt; not all functions do that (and some functions _cannot_ do that, like<br>&gt; operators.) If a function has to be upgraded to return an error, that _is_<br>&gt; extra overhead, mostly on the caller’s side. (And, as previously noted,<br>&gt; this may complicate the programmer’s life too, because now they may have to<br>&gt; either propagate ‘throws’ to the caller or add a ‘catch’ handler.)<br>&gt;<br>&gt; Anyway, the programming conventions have been clear for a very long time:<br>&gt; assertions should be used for programmer errors (like invalid parameters)<br>&gt; while returned errors should be used for legitimate runtime error<br>&gt; situations (like file-not-found). This predates Swift and even predates Mac<br>&gt; OS X*; I think it goes back to OpenStep in the mid-‘90s.<br>&gt;<br>&gt; —Jens<br>&gt;<br>&gt; * NSError itself isn’t that old, but before that the APIs still returned<br>&gt; nil or false for runtime errors.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br>&gt;<br></p><p><br>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20151207/d5981148/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>Parameter Validation</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>December  7, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt; On Dec 7, 2015, at 5:24 PM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt; <br>&gt; You enable assertions for release builds then?<br></p><p>It depends on the target. In a lot of app-level code it doesn’t make much difference to leave them in, while in lower-level performance-sensitive code it’s a big slowdown. (Back when I worked at Apple, a lot of system apps shipped with assertions enabled.)<br></p><p>But that’s irrelevant. If you had to add a ‘throws’ declaration to a function to add error handling to it in debug builds, it’s still going to have the overhead of ‘throws’ in a release build even if the error check is suppressed somehow.<br></p><p>&gt; Remember, I&#39;m talking specifically about library code: the same way that calling NSArray&#39;s objectAtIndex throws an exception (if my memory serves well) for out of bounds indices. At least, NSAssert in Objective-C throws exceptions and is catchable.<br></p><p><br>(a) Obj-C exceptions (which are bridged to C++ exceptions) don’t incur any overhead, unlike Swift ‘throws’ functions. They have no direct equivalent in Swift.<br>(b) You’re not _supposed_ to catch NSAssertion failures, or at least not let your app continue afterwards. Cocoa has always had a weird ambivalence about exceptions: they’re part of the Obj-C language, but their use is discouraged, and the docs have become increasingly direct about telling you not to catch-and-continue.<br></p><p>—Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20151207/e5dbbe83/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Parameter Validation</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December  7, 2015 at 09:00:00am</p></header><div class="content"><p>On Mon, Dec 7, 2015 at 9:03 AM, David Hart via swift-users &lt;<br>swift-users at swift.org&gt; wrote:<br></p><p>&gt; But then you can&#39;t unit-test that the function fails on those parameters.<br>&gt;<br></p><p>Yes you can.  Maybe not with the current XCTest, but there&#39;s nothing that<br>prevents unit-testing traps in principle.  The standard library is already<br>doing that.  See test/1_stdlib/ArrayTraps.swift.gyb for some examples:<br></p><p>ArrayTraps.test(&quot;downcast1&quot;)<br>  .skip(.Custom(<br>    { _isFastAssertConfiguration() },<br>    reason: &quot;this trap is not guaranteed to happen in -Ounchecked&quot;))<br>  .code {<br>  let ba: [Base] = [ Derived(), Base() ]<br>  let da = ba as! [Derived]<br>  let d0 = da[0]<br>  expectCrashLater()<br>  da[1]<br>}<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20151207/f120ca8b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>Parameter Validation</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>December  7, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 7, 2015, at 9:21 AM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; <br>&gt; Yes you can.  Maybe not with the current XCTest, but there&#39;s nothing that prevents unit-testing traps in principle.  The standard library is already doing that.  See test/1_stdlib/ArrayTraps.swift.gyb for some examples:<br></p><p>Nice! But completely undocumented, AFAIK. This is the first I’ve heard of the term “trap” or a way to handle them. The docs I’ve seen just say that an assertion failure terminates the process.<br></p><p>Is there any more info about traps, other than “Read the source, Luke?” ;-)<br></p><p>(This is one reason I’ve been excited for the open source release — finally getting to look behind the scenes of some of the “magic” stuff.)<br></p><p>—Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20151207/4814aca9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Parameter Validation</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December  7, 2015 at 09:00:00am</p></header><div class="content"><p>On Mon, Dec 7, 2015 at 9:25 AM, Jens Alfke &lt;jens at mooseyard.com&gt; wrote:<br>&gt;<br>&gt; On Dec 7, 2015, at 9:21 AM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt;<br>&gt; Yes you can.  Maybe not with the current XCTest, but there&#39;s nothing that<br>&gt; prevents unit-testing traps in principle.  The standard library is already<br>&gt; doing that.  See test/1_stdlib/ArrayTraps.swift.gyb for some examples:<br>&gt;<br>&gt;<br>&gt; Nice! But completely undocumented, AFAIK. This is the first I’ve heard of<br>&gt; the term “trap”<br></p><p>We don&#39;t call them &quot;crashes&quot;, because the word &quot;crash&quot; is typically<br>used to describe non-reliable program termination because of an<br>invalid memory unsafe operation that lead to memory corruption.  Traps<br>are guaranteed to happen, and they *prevent* memory unsafe operations<br>to happen, terminating the process before they happen.<br></p><p>&gt; or a way to handle them. The docs I’ve seen just say that an<br>&gt; assertion failure terminates the process.<br></p><p>Traps do terminate the process, without any way to recover, and that<br>is exactly what is happening in the standard library tests.  There are<br>just two processes -- one is performing a trap, and another one is the<br>test harness that verifies that the other process terminated.<br></p><p>&gt; Is there any more info about traps, other than “Read the source, Luke?” ;-)<br></p><p>What would you like to know?<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>Parameter Validation</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>December  7, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 7, 2015, at 9:40 AM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; <br>&gt; There are<br>&gt; just two processes -- one is performing a trap, and another one is the<br>&gt; test harness that verifies that the other process terminated.<br></p><p>Ah — I thought it was some type of in-process exception/signal handler.<br></p><p>&gt; What would you like to know?<br></p><p>Given the above, not much :) I suppose an assertion failure just raises a SIGABORT or something similar?<br></p><p>—Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20151207/827fceee/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Parameter Validation</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December  7, 2015 at 10:00:00am</p></header><div class="content"><p>On Mon, Dec 7, 2015 at 10:02 AM, Jens Alfke &lt;jens at mooseyard.com&gt; wrote:<br>&gt;<br>&gt; On Dec 7, 2015, at 9:40 AM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt;<br>&gt; There are<br>&gt; just two processes -- one is performing a trap, and another one is the<br>&gt; test harness that verifies that the other process terminated.<br>&gt;<br>&gt;<br>&gt; Ah — I thought it was some type of in-process exception/signal handler.<br></p><p>Well, if we used that, then we wouldn&#39;t be testing in the same<br>environment as production code would run in.<br></p><p>Even more, when a compiler sees that the process is going to trap<br>anyway, it can omit some cleanups, like ARC releases, which will lead<br>to memory leaks and other surprising behavior.<br></p><p>While it is technically possible to intercept the control flow after a<br>Swift trap, I would not recommend doing that even for test purposes,<br>and even less for production code, for the reasons I described.<br></p><p>&gt; What would you like to know?<br>&gt;<br>&gt;<br>&gt; Given the above, not much :) I suppose an assertion failure just raises a<br>&gt; SIGABORT or something similar?<br></p><p>It performs a UD2 instruction on x86, or equivalent on other<br>platforms.  stdlib/public/core/AssertCommon.swift if you are<br>interested.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/94064636d740f54a1ea944b46f4dd8bd?s=50"></div><header><strong>Parameter Validation</strong> from <string>Jason Dusek</string> &lt;jason.dusek at gmail.com&gt;<p>December  6, 2015 at 11:00:00pm</p></header><div class="content"><p>Say for a moment we wanted to capture every such constraint at type<br>level -- with types NonEmptyString and PositiveNonZeroInteger. Would<br>these be declared as structs in Swift?<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
