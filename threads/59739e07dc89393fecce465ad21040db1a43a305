<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d745cdc85e6df10fd8691b06ff840e5f?s=50"></div><header><strong>SE-0047</strong> from <string>Michael M. Mayer</string> &lt;m.mayer6 at gmail.com&gt;<p>March 17, 2016 at 01:00:00am</p></header><div class="content"><p>https://github.com/apple/swift-evolution/blob/master/proposals/0047-nonvoid-warn.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0047-nonvoid-warn.md&gt;<br></p><p>I really like the way Swift currently works in this regard.  Return values can be and are routinely ignored and that is ok and what most people are used to.  Except when it isn’t okay, and that’s when we add a warning/annotation. Perfect!<br></p><p>It is far more common to be able to ignore a return value than to have it be required to be handled.  To flip when we add the annotation, will require far more effort and will clutter our code.  Why do I want annotations to tell me that I can ignore something.  I want it there when I need to be warned.  You wave a red flag when there is something to be concerned about, not when the results are inconsequential.<br></p><p>I strongly urge for the disapproval of this proposal.<br></p><p>Regards, Michael<br></p><p>==================<br>Michael M. Mayer<br>Hanover, MD<br>m.mayer6 at gmail.com<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160317/5973a305/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>SE-0047</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March 17, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; It is far more common to be able to ignore a return value than to have it be required to be handled.<br></p><p>Do you really think that&#39;s true?<br></p><p>I took a look at the Swift standard library and extracted just the function, method, and operator names and return values, with Void functions excluded (since they&#39;re automatically discardable), even if they throw. Here&#39;s the data I got: <br></p><p>	https://gist.github.com/brentdax/11d78a3d8e1df70f21f3<br></p><p>It looks a little funky, but you can pretty much tell what each method does.<br></p><p>Then I asked TextMate to shuffle the lines in that file and took a look at the first twenty:<br></p><p>	    multiplyWithOverflow -&gt; (Self, overflow: Bool)<br>	- -&gt; Float80<br>	== -&gt; Bool<br>	    withUnsafeMutableBufferPointer  -&gt; R<br>	    withUnsafeMutableBufferPointer  -&gt; R<br>	    samePositionIn -&gt; String.UTF8View.Index<br>	    withUnsafeMutableBufferPointer  -&gt; R<br>	    member -&gt; AnyObject?<br>	    indexForKey -&gt; DictionaryIndex?<br>	&gt;&gt; -&gt; UInt64<br>	prefix ~ -&gt; UInt<br>	!= -&gt; Bool<br>	&gt;= -&gt; Bool<br>	    popLast -&gt; Self.Generator.Element?<br>	    addWithOverflow -&gt; (Self, overflow: Bool)<br>	    successor -&gt; AnyBidirectionalIndex<br>	- -&gt; Int<br>	    subtractWithOverflow -&gt; (Self, overflow: Bool)<br>	postfix -- -&gt; Double<br>	prefix ++ -&gt; UInt32<br></p><p>Of these lines, the three `withUnsafeMutableBufferPointer` methods would sometimes be used with discardable results—except those are examples of a pattern where the return type comes from an inner closure, so if that return value is Void, it&#39;s automatically discardable. `popLast`, `--`, and `++` *are* genuinely things that should be discardable; you might use them just for their side effects. For the others, really the only thing the function does is calculate a return value; if you don&#39;t use that value, you&#39;ve wasted CPU cycles for no reason.<br></p><p>	Generic:		3<br>	Discardable:	3<br>	Important:	14<br></p><p>Okay, but a lot of those are operators. Maybe that&#39;s just an operator thing and functions are a different story? Let&#39;s filter out the operators and again select the top twenty:<br></p><p>	    multiplyWithOverflow -&gt; (Self, overflow: Bool)<br>	    withUnsafeMutableBufferPointer  -&gt; R<br>	    withUnsafeMutableBufferPointer  -&gt; R<br>	    samePositionIn -&gt; String.UTF8View.Index<br>	    withUnsafeMutableBufferPointer  -&gt; R<br>	    member -&gt; AnyObject?<br>	    indexForKey -&gt; DictionaryIndex?<br>	    popLast -&gt; Self.Generator.Element?<br>	    addWithOverflow -&gt; (Self, overflow: Bool)<br>	    successor -&gt; AnyBidirectionalIndex<br>	    subtractWithOverflow -&gt; (Self, overflow: Bool)<br>	    removeAtIndex -&gt; Self.Generator.Element<br>	max -&gt; T<br>	    samePositionIn -&gt; UnicodeScalarIndex?<br>	    withUnsafeMutablePointerToValue -&gt; R<br>	    predecessor -&gt; UInt<br>	    generate -&gt; Self.Generator<br>	    advancedBy -&gt; Self<br>	withVaList -&gt; R<br>	    next -&gt; Element?<br></p><p>We&#39;ve got two more of those &quot;generic return type&quot; cases—`withUnsafeMutablePointerToValue` and `withVaList`. But in this sample we only have `popLast` and `removeAtIndex in the &quot;should be discardable&quot; category.<br></p><p>	Generic:		5<br>	Discardable:	2<br>	Important:	13<br></p><p>Maybe it&#39;s just this sample, though, so I ran a few more (on the &quot;no operator&quot; set):<br></p><p>	Generic	Discardable	Important<br>	2		0			18<br>	0		1			19<br>	1		2			17<br>	2		0			18<br>	1		1			18<br>	-----		-----			-----<br>	6		4			90<br></p><p>Yeah, it was that sample. That sample had far fewer important return values than average.<br></p><p>I think it&#39;s fair to say that the vast majority of standard library functions ought to return values.  But maybe the standard library is a little weird, and other frameworks would have different behavior?<br></p><p>Fine. I&#39;ll do it again with Core Data. (For reference, Core Data&#39;s generated interface is about half the size of Stdlib&#39;s in terms of number of lines.)<br></p><p>	https://gist.github.com/brentdax/87e3f86adaf1ed7b11c8<br></p><p>Core Data had 68 non-Void functions to evaluate, which was short enough that I decided I could just look at all of the methods. I wanted to be pretty broad here, but not overbroad, so I&#39;m counting anything with a side effect *other* than merely throwing an error or precalculating some data. That includes some really stupid things, like calling `insertNewObjectForEntityForName` and then not doing anything with it, but it doesn&#39;t count calling `executeFetchRequest` and ignoring the result.<br></p><p>So, how did Core Data do?<br></p><p>	Discardable:	9<br>	Important:	59<br></p><p>That includes, by the way, some *stupendously* bad ideas, such as calling `tryLock` without seeing if the lock succeeded. I would guess that more than half of the &quot;discardable&quot; category are the sort of thing that would leave you gaping at the screen if you saw them in a piece of code.<br></p><p>Now, I&#39;ve only looked at frameworks here, so maybe application code is different. Maybe *your* code is different for some reason. But I suspect that, if you really take a look at your code, you&#39;ll realize that most functions and methods are either Void (and possibly throwing), or they exist entirely to calculate and return some piece of data, and if you&#39;re not doing something with that data you shouldn&#39;t be calling them. But I think the evidence suggests that warn-by-default is the right choice for most Swift code.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>SE-0047</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>March 17, 2016 at 10:00:00am</p></header><div class="content"><p>I don&#39;t think that counting discardable results in existing Cocoas libraries is a good metric for the usefulness of warn-unused-result: Other libraries may follow a different style, and Objective-C is a very bad fit for fluent interfaces.<br>So far, I haven&#39;t seen any real world examples of problems caused by accidentally discarded results, and changing the default would be be a real pain that discourages established patterns.<br>The imho easiest solution would be a module-specific setting for the default.<br></p><p>&gt; That includes, by the way, some *stupendously* bad ideas, such as calling `tryLock` without seeing if the lock succeeded. I would guess that more than half of the &quot;discardable&quot; category are the sort of thing that would leave you gaping at the screen if you saw them in a piece of code.<br>I see this as a strong argument to only slightly modify the current behavior:<br>- Add a @pure-annotation which implies warn-unused-result<br>- Change the name/syntax of warn-unused-result to something shorter and less ugly (already discussed, but no proposals yet)<br></p><p>When nearly all functions trigger warnings, it becomes harder to spot the cases where it is really likely that someone made an error by ignoring a result.<br></p><p>Tino<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
