<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>Proposal: An Either Type in the STL</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>December  9, 2015 at 06:00:00pm</p></header><div class="content"><p>It’s high time the STL admitted some kind of disjoint union type, at the very least because it’s such a minor addition it seems a shame to leave it out.  Whatever feelings one may have about `throws`, the lack of standardizing on a datatype representing choice has caused the community to get creative and create many disjoint implementation of the same concept over and over and over again.  To that end, I propose the STL ship with an Either type; We at TypeLift have already got our own we’d like to model it on (https://github.com/typelift/Swiftx/blob/master/Swiftx/Either.swift#L16).<br></p><p><br>~Robert Widmann (CodaFi)<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/011dec7e31b0e0bf9de0c40a8cb2f162?s=50"></div><header><strong>Proposal: An Either Type in the STL</strong> from <string>Ilias Karim</string> &lt;ilias.karim at gmail.com&gt;<p>December  9, 2015 at 03:00:00pm</p></header><div class="content"><p>Hi Robert,<br></p><p>I agree with your recommendation of a generic Either type.<br></p><p>However, I find your use of “Right” as the “Correct” value (whatever that means) of an instance of an Either type a little perplexing. While clever, it is exactly the kind of convention that easily leads to misunderstandings about the nature of the type itself ie. is it right and left or wrong and correct? At least that is my first impression after scanning your code.<br></p><p>Ilias<br></p><p>&gt; On Dec 9, 2015, at 3:06 PM, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; It’s high time the STL admitted some kind of disjoint union type, at the very least because it’s such a minor addition it seems a shame to leave it out.  Whatever feelings one may have about `throws`, the lack of standardizing on a datatype representing choice has caused the community to get creative and create many disjoint implementation of the same concept over and over and over again.  To that end, I propose the STL ship with an Either type; We at TypeLift have already got our own we’d like to model it on (https://github.com/typelift/Swiftx/blob/master/Swiftx/Either.swift#L16).<br>&gt; <br>&gt; <br>&gt; ~Robert Widmann (CodaFi)<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Proposal: An Either Type in the STL</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>December  9, 2015 at 03:00:00pm</p></header><div class="content"><p>The idea of using Left/Right is to remain agnostic to what sorts of things<br>users might want to put in. It&#39;s feasible a user might want Either&lt;Int,<br>String&gt;, not just Either&lt;ErrorType, T&gt;.<br></p><p>While I&#39;m not sure Left &amp; Right are the best choices, I don&#39;t think it&#39;s<br>particularly worrisome when it comes to errors, as the general type-safety<br>of the language will prevent users from mixing up success &amp; error cases.<br></p><p>Jacob<br></p><p>On Wed, Dec 9, 2015 at 3:32 PM, Ilias Karim via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hi Robert,<br>&gt;<br>&gt; I agree with your recommendation of a generic Either type.<br>&gt;<br>&gt; However, I find your use of “Right” as the “Correct” value (whatever that<br>&gt; means) of an instance of an Either type a little perplexing. While clever,<br>&gt; it is exactly the kind of convention that easily leads to misunderstandings<br>&gt; about the nature of the type itself ie. is it right and left or wrong and<br>&gt; correct? At least that is my first impression after scanning your code.<br>&gt;<br>&gt; Ilias<br>&gt;<br>&gt; &gt; On Dec 9, 2015, at 3:06 PM, Developer via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; It’s high time the STL admitted some kind of disjoint union type, at the<br>&gt; very least because it’s such a minor addition it seems a shame to leave it<br>&gt; out.  Whatever feelings one may have about `throws`, the lack of<br>&gt; standardizing on a datatype representing choice has caused the community to<br>&gt; get creative and create many disjoint implementation of the same concept<br>&gt; over and over and over again.  To that end, I propose the STL ship with an<br>&gt; Either type; We at TypeLift have already got our own we’d like to model it<br>&gt; on (https://github.com/typelift/Swiftx/blob/master/Swiftx/Either.swift#L16<br>&gt; ).<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; ~Robert Widmann (CodaFi)<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/e7700c3a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/011dec7e31b0e0bf9de0c40a8cb2f162?s=50"></div><header><strong>Proposal: An Either Type in the STL</strong> from <string>Ilias Karim</string> &lt;ilias.karim at gmail.com&gt;<p>December  9, 2015 at 03:00:00pm</p></header><div class="content"><p>What are the advantage over using a tuple? One great feature about tuples is being able to name parameters so you can dispel ambiguity.<br></p><p><br>&gt; On Dec 9, 2015, at 3:35 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt; <br>&gt; The idea of using Left/Right is to remain agnostic to what sorts of things users might want to put in. It&#39;s feasible a user might want Either&lt;Int, String&gt;, not just Either&lt;ErrorType, T&gt;.<br>&gt; <br>&gt; While I&#39;m not sure Left &amp; Right are the best choices, I don&#39;t think it&#39;s particularly worrisome when it comes to errors, as the general type-safety of the language will prevent users from mixing up success &amp; error cases.<br>&gt; <br>&gt; Jacob<br>&gt; <br>&gt; On Wed, Dec 9, 2015 at 3:32 PM, Ilias Karim via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Hi Robert,<br>&gt; <br>&gt; I agree with your recommendation of a generic Either type.<br>&gt; <br>&gt; However, I find your use of “Right” as the “Correct” value (whatever that means) of an instance of an Either type a little perplexing. While clever, it is exactly the kind of convention that easily leads to misunderstandings about the nature of the type itself ie. is it right and left or wrong and correct? At least that is my first impression after scanning your code.<br>&gt; <br>&gt; Ilias<br>&gt; <br>&gt; &gt; On Dec 9, 2015, at 3:06 PM, Developer via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; It’s high time the STL admitted some kind of disjoint union type, at the very least because it’s such a minor addition it seems a shame to leave it out.  Whatever feelings one may have about `throws`, the lack of standardizing on a datatype representing choice has caused the community to get creative and create many disjoint implementation of the same concept over and over and over again.  To that end, I propose the STL ship with an Either type; We at TypeLift have already got our own we’d like to model it on (https://github.com/typelift/Swiftx/blob/master/Swiftx/Either.swift#L16 &lt;https://github.com/typelift/Swiftx/blob/master/Swiftx/Either.swift#L16&gt;).<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; ~Robert Widmann (CodaFi)<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/c7c4051c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>Proposal: An Either Type in the STL</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>December  9, 2015 at 06:00:00pm</p></header><div class="content"><p>A tuple is a product, we want a sum here.  A tuple says “I know I have 2 things”, a sum says “I know one or the other of these things is here but not both” without the need to unwrap both halves just to check.  Past a certain point, you’re writing Either code over and over again without realizing it.<br></p><p><br>&gt; On Dec 9, 2015, at 6:41 PM, Ilias Karim &lt;ilias.karim at gmail.com&gt; wrote:<br>&gt; <br>&gt; What are the advantage over using a tuple? One great feature about tuples is being able to name parameters so you can dispel ambiguity.<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 9, 2015, at 3:35 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The idea of using Left/Right is to remain agnostic to what sorts of things users might want to put in. It&#39;s feasible a user might want Either&lt;Int, String&gt;, not just Either&lt;ErrorType, T&gt;.<br>&gt;&gt; <br>&gt;&gt; While I&#39;m not sure Left &amp; Right are the best choices, I don&#39;t think it&#39;s particularly worrisome when it comes to errors, as the general type-safety of the language will prevent users from mixing up success &amp; error cases.<br>&gt;&gt; <br>&gt;&gt; Jacob<br>&gt;&gt; <br>&gt;&gt; On Wed, Dec 9, 2015 at 3:32 PM, Ilias Karim via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Hi Robert,<br>&gt;&gt; <br>&gt;&gt; I agree with your recommendation of a generic Either type.<br>&gt;&gt; <br>&gt;&gt; However, I find your use of “Right” as the “Correct” value (whatever that means) of an instance of an Either type a little perplexing. While clever, it is exactly the kind of convention that easily leads to misunderstandings about the nature of the type itself ie. is it right and left or wrong and correct? At least that is my first impression after scanning your code.<br>&gt;&gt; <br>&gt;&gt; Ilias<br>&gt;&gt; <br>&gt;&gt; &gt; On Dec 9, 2015, at 3:06 PM, Developer via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; It’s high time the STL admitted some kind of disjoint union type, at the very least because it’s such a minor addition it seems a shame to leave it out.  Whatever feelings one may have about `throws`, the lack of standardizing on a datatype representing choice has caused the community to get creative and create many disjoint implementation of the same concept over and over and over again.  To that end, I propose the STL ship with an Either type; We at TypeLift have already got our own we’d like to model it on (https://github.com/typelift/Swiftx/blob/master/Swiftx/Either.swift#L16 &lt;https://github.com/typelift/Swiftx/blob/master/Swiftx/Either.swift#L16&gt;).<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; ~Robert Widmann (CodaFi)<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/443e6f05/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Proposal: An Either Type in the STL</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>December  9, 2015 at 03:00:00pm</p></header><div class="content"><p>Sorry, I&#39;m bad at this proofreading thing. The fourth case is (A, B).<br></p><p>Jacob Bandes-Storch<br></p><p>On Wed, Dec 9, 2015 at 3:42 PM, Developer &lt;devteam.codafi at gmail.com&gt; wrote:<br></p><p>&gt; A tuple is a product, we want a sum here.  A tuple says “I know I have 2<br>&gt; things”, a sum says “I know one or the other of these things is here but<br>&gt; not both” without the need to unwrap both halves just to check.  Past a<br>&gt; certain point, you’re writing Either code over and over again without<br>&gt; realizing it.<br>&gt;<br>&gt;<br>&gt; On Dec 9, 2015, at 6:41 PM, Ilias Karim &lt;ilias.karim at gmail.com&gt; wrote:<br>&gt;<br>&gt; What are the advantage over using a tuple? One great feature about tuples<br>&gt; is being able to name parameters so you can dispel ambiguity.<br>&gt;<br>&gt;<br>&gt; On Dec 9, 2015, at 3:35 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; The idea of using Left/Right is to remain agnostic to what sorts of things<br>&gt; users might want to put in. It&#39;s feasible a user might want Either&lt;Int,<br>&gt; String&gt;, not just Either&lt;ErrorType, T&gt;.<br>&gt;<br>&gt; While I&#39;m not sure Left &amp; Right are the best choices, I don&#39;t think it&#39;s<br>&gt; particularly worrisome when it comes to errors, as the general type-safety<br>&gt; of the language will prevent users from mixing up success &amp; error cases.<br>&gt;<br>&gt; Jacob<br>&gt;<br>&gt; On Wed, Dec 9, 2015 at 3:32 PM, Ilias Karim via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Hi Robert,<br>&gt;&gt;<br>&gt;&gt; I agree with your recommendation of a generic Either type.<br>&gt;&gt;<br>&gt;&gt; However, I find your use of “Right” as the “Correct” value (whatever that<br>&gt;&gt; means) of an instance of an Either type a little perplexing. While clever,<br>&gt;&gt; it is exactly the kind of convention that easily leads to misunderstandings<br>&gt;&gt; about the nature of the type itself ie. is it right and left or wrong and<br>&gt;&gt; correct? At least that is my first impression after scanning your code.<br>&gt;&gt;<br>&gt;&gt; Ilias<br>&gt;&gt;<br>&gt;&gt; &gt; On Dec 9, 2015, at 3:06 PM, Developer via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; It’s high time the STL admitted some kind of disjoint union type, at<br>&gt;&gt; the very least because it’s such a minor addition it seems a shame to leave<br>&gt;&gt; it out.  Whatever feelings one may have about `throws`, the lack of<br>&gt;&gt; standardizing on a datatype representing choice has caused the community to<br>&gt;&gt; get creative and create many disjoint implementation of the same concept<br>&gt;&gt; over and over and over again.  To that end, I propose the STL ship with an<br>&gt;&gt; Either type; We at TypeLift have already got our own we’d like to model it<br>&gt;&gt; on (<br>&gt;&gt; https://github.com/typelift/Swiftx/blob/master/Swiftx/Either.swift#L16).<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; ~Robert Widmann (CodaFi)<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/45b80d07/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Proposal: An Either Type in the STL</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>December  9, 2015 at 03:00:00pm</p></header><div class="content"><p>A tuple of (A?, B?) has four states: (nil, nil) / (A, nil) / (nil, B) / (B,<br>nil)<br></p><p>Whereas Either&lt;A,B&gt; has only two states: .Left(A) or .Right(B).<br></p><p>Jacob<br></p><p>On Wed, Dec 9, 2015 at 3:41 PM, Ilias Karim &lt;ilias.karim at gmail.com&gt; wrote:<br></p><p>&gt; What are the advantage over using a tuple? One great feature about tuples<br>&gt; is being able to name parameters so you can dispel ambiguity.<br>&gt;<br>&gt;<br>&gt; On Dec 9, 2015, at 3:35 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; The idea of using Left/Right is to remain agnostic to what sorts of things<br>&gt; users might want to put in. It&#39;s feasible a user might want Either&lt;Int,<br>&gt; String&gt;, not just Either&lt;ErrorType, T&gt;.<br>&gt;<br>&gt; While I&#39;m not sure Left &amp; Right are the best choices, I don&#39;t think it&#39;s<br>&gt; particularly worrisome when it comes to errors, as the general type-safety<br>&gt; of the language will prevent users from mixing up success &amp; error cases.<br>&gt;<br>&gt; Jacob<br>&gt;<br>&gt; On Wed, Dec 9, 2015 at 3:32 PM, Ilias Karim via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Hi Robert,<br>&gt;&gt;<br>&gt;&gt; I agree with your recommendation of a generic Either type.<br>&gt;&gt;<br>&gt;&gt; However, I find your use of “Right” as the “Correct” value (whatever that<br>&gt;&gt; means) of an instance of an Either type a little perplexing. While clever,<br>&gt;&gt; it is exactly the kind of convention that easily leads to misunderstandings<br>&gt;&gt; about the nature of the type itself ie. is it right and left or wrong and<br>&gt;&gt; correct? At least that is my first impression after scanning your code.<br>&gt;&gt;<br>&gt;&gt; Ilias<br>&gt;&gt;<br>&gt;&gt; &gt; On Dec 9, 2015, at 3:06 PM, Developer via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; It’s high time the STL admitted some kind of disjoint union type, at<br>&gt;&gt; the very least because it’s such a minor addition it seems a shame to leave<br>&gt;&gt; it out.  Whatever feelings one may have about `throws`, the lack of<br>&gt;&gt; standardizing on a datatype representing choice has caused the community to<br>&gt;&gt; get creative and create many disjoint implementation of the same concept<br>&gt;&gt; over and over and over again.  To that end, I propose the STL ship with an<br>&gt;&gt; Either type; We at TypeLift have already got our own we’d like to model it<br>&gt;&gt; on (<br>&gt;&gt; https://github.com/typelift/Swiftx/blob/master/Swiftx/Either.swift#L16).<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; ~Robert Widmann (CodaFi)<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/c71ce583/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0abd997dee7c62b8c38871fee54643cb?s=50"></div><header><strong>Proposal: An Either Type in the STL</strong> from <string>Dave DeLong</string> &lt;delong at apple.com&gt;<p>December  9, 2015 at 04:00:00pm</p></header><div class="content"><p>With a tuple, you have to do “(left: T?, right: U?)”, whereas with an Either you are guaranteed to always have one or other other; never both and never neither. That is not guaranteed with the tuple.<br></p><p>Dave<br></p><p>&gt; On Dec 9, 2015, at 4:41 PM, Ilias Karim via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; What are the advantage over using a tuple? One great feature about tuples is being able to name parameters so you can dispel ambiguity.<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 9, 2015, at 3:35 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The idea of using Left/Right is to remain agnostic to what sorts of things users might want to put in. It&#39;s feasible a user might want Either&lt;Int, String&gt;, not just Either&lt;ErrorType, T&gt;.<br>&gt;&gt; <br>&gt;&gt; While I&#39;m not sure Left &amp; Right are the best choices, I don&#39;t think it&#39;s particularly worrisome when it comes to errors, as the general type-safety of the language will prevent users from mixing up success &amp; error cases.<br>&gt;&gt; <br>&gt;&gt; Jacob<br>&gt;&gt; <br>&gt;&gt; On Wed, Dec 9, 2015 at 3:32 PM, Ilias Karim via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Hi Robert,<br>&gt;&gt; <br>&gt;&gt; I agree with your recommendation of a generic Either type.<br>&gt;&gt; <br>&gt;&gt; However, I find your use of “Right” as the “Correct” value (whatever that means) of an instance of an Either type a little perplexing. While clever, it is exactly the kind of convention that easily leads to misunderstandings about the nature of the type itself ie. is it right and left or wrong and correct? At least that is my first impression after scanning your code.<br>&gt;&gt; <br>&gt;&gt; Ilias<br>&gt;&gt; <br>&gt;&gt; &gt; On Dec 9, 2015, at 3:06 PM, Developer via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; It’s high time the STL admitted some kind of disjoint union type, at the very least because it’s such a minor addition it seems a shame to leave it out.  Whatever feelings one may have about `throws`, the lack of standardizing on a datatype representing choice has caused the community to get creative and create many disjoint implementation of the same concept over and over and over again.  To that end, I propose the STL ship with an Either type; We at TypeLift have already got our own we’d like to model it on (https://github.com/typelift/Swiftx/blob/master/Swiftx/Either.swift#L16 &lt;https://github.com/typelift/Swiftx/blob/master/Swiftx/Either.swift#L16&gt;).<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; ~Robert Widmann (CodaFi)<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/156c0ba0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/011dec7e31b0e0bf9de0c40a8cb2f162?s=50"></div><header><strong>Proposal: An Either Type in the STL</strong> from <string>Ilias Karim</string> &lt;ilias.karim at gmail.com&gt;<p>December  9, 2015 at 03:00:00pm</p></header><div class="content"><p>I’m sorry, I misunderstood. I guess an enum would be the appropriate choice, instead.<br></p><p>As far as left/right goes, the decision to have left or right be the “correct” value is entirely arbitrary and should be left up to the developer. It should be a convention at best.<br></p><p>Ilias<br></p><p>&gt; On Dec 9, 2015, at 3:43 PM, Dave DeLong &lt;delong at apple.com&gt; wrote:<br>&gt; <br>&gt; With a tuple, you have to do “(left: T?, right: U?)”, whereas with an Either you are guaranteed to always have one or other other; never both and never neither. That is not guaranteed with the tuple.<br>&gt; <br>&gt; Dave<br>&gt; <br>&gt;&gt; On Dec 9, 2015, at 4:41 PM, Ilias Karim via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; What are the advantage over using a tuple? One great feature about tuples is being able to name parameters so you can dispel ambiguity.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 9, 2015, at 3:35 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The idea of using Left/Right is to remain agnostic to what sorts of things users might want to put in. It&#39;s feasible a user might want Either&lt;Int, String&gt;, not just Either&lt;ErrorType, T&gt;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; While I&#39;m not sure Left &amp; Right are the best choices, I don&#39;t think it&#39;s particularly worrisome when it comes to errors, as the general type-safety of the language will prevent users from mixing up success &amp; error cases.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Jacob<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Wed, Dec 9, 2015 at 3:32 PM, Ilias Karim via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; Hi Robert,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree with your recommendation of a generic Either type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; However, I find your use of “Right” as the “Correct” value (whatever that means) of an instance of an Either type a little perplexing. While clever, it is exactly the kind of convention that easily leads to misunderstandings about the nature of the type itself ie. is it right and left or wrong and correct? At least that is my first impression after scanning your code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Ilias<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; On Dec 9, 2015, at 3:06 PM, Developer via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; It’s high time the STL admitted some kind of disjoint union type, at the very least because it’s such a minor addition it seems a shame to leave it out.  Whatever feelings one may have about `throws`, the lack of standardizing on a datatype representing choice has caused the community to get creative and create many disjoint implementation of the same concept over and over and over again.  To that end, I propose the STL ship with an Either type; We at TypeLift have already got our own we’d like to model it on (https://github.com/typelift/Swiftx/blob/master/Swiftx/Either.swift#L16 &lt;https://github.com/typelift/Swiftx/blob/master/Swiftx/Either.swift#L16&gt;).<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; ~Robert Widmann (CodaFi)<br>&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/bc7f5ad2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>Proposal: An Either Type in the STL</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>December  9, 2015 at 06:00:00pm</p></header><div class="content"><p>How would you write `map` for an unbiased Either.  You have to pick a side!<br></p><p>Our implementation happens to be the one standardized on by Scala, Haskell, ML, (and to a limited extent) F#.  For a less arbitrary reason, the use of &quot;Right as Correct&quot; is because Either, in all it’s Bifunctor-ial ways, has to admit two ways to map “across” itself.  To paraphrase the words of a friend &quot;There are lots of things in computer science we can leftMap”.  In Haskell, such a thing is represented by the Functor typeclass, and due to the way type application works in that language, the convention has been to map over the rightmost side.  But this isn’t Haskell, so our reasons can get even more theoretical than that (if you really want to get into what it looks like when you implement Covariant mapping down the left side of a common Bifunctor like Either, Cats has already had a thorough discussion on the subject: https://github.com/non/cats/issues/189 &lt;https://github.com/non/cats/issues/189&gt;).<br></p><p>&gt; On Dec 9, 2015, at 6:44 PM, Ilias Karim &lt;ilias.karim at gmail.com&gt; wrote:<br>&gt; <br>&gt; I’m sorry, I misunderstood. I guess an enum would be the appropriate choice, instead.<br>&gt; <br>&gt; As far as left/right goes, the decision to have left or right be the “correct” value is entirely arbitrary and should be left up to the developer. It should be a convention at best.<br>&gt; <br>&gt; Ilias<br>&gt; <br>&gt;&gt; On Dec 9, 2015, at 3:43 PM, Dave DeLong &lt;delong at apple.com &lt;mailto:delong at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; With a tuple, you have to do “(left: T?, right: U?)”, whereas with an Either you are guaranteed to always have one or other other; never both and never neither. That is not guaranteed with the tuple.<br>&gt;&gt; <br>&gt;&gt; Dave<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 9, 2015, at 4:41 PM, Ilias Karim via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What are the advantage over using a tuple? One great feature about tuples is being able to name parameters so you can dispel ambiguity.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 9, 2015, at 3:35 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The idea of using Left/Right is to remain agnostic to what sorts of things users might want to put in. It&#39;s feasible a user might want Either&lt;Int, String&gt;, not just Either&lt;ErrorType, T&gt;.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; While I&#39;m not sure Left &amp; Right are the best choices, I don&#39;t think it&#39;s particularly worrisome when it comes to errors, as the general type-safety of the language will prevent users from mixing up success &amp; error cases.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Jacob<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Wed, Dec 9, 2015 at 3:32 PM, Ilias Karim via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; Hi Robert,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I agree with your recommendation of a generic Either type.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; However, I find your use of “Right” as the “Correct” value (whatever that means) of an instance of an Either type a little perplexing. While clever, it is exactly the kind of convention that easily leads to misunderstandings about the nature of the type itself ie. is it right and left or wrong and correct? At least that is my first impression after scanning your code.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Ilias<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt; On Dec 9, 2015, at 3:06 PM, Developer via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; It’s high time the STL admitted some kind of disjoint union type, at the very least because it’s such a minor addition it seems a shame to leave it out.  Whatever feelings one may have about `throws`, the lack of standardizing on a datatype representing choice has caused the community to get creative and create many disjoint implementation of the same concept over and over and over again.  To that end, I propose the STL ship with an Either type; We at TypeLift have already got our own we’d like to model it on (https://github.com/typelift/Swiftx/blob/master/Swiftx/Either.swift#L16 &lt;https://github.com/typelift/Swiftx/blob/master/Swiftx/Either.swift#L16&gt;).<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; ~Robert Widmann (CodaFi)<br>&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/a0fec42d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Proposal: An Either Type in the STL</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>December  9, 2015 at 03:00:00pm</p></header><div class="content"><p>Is there not precedent for having both &quot;mapLeft&lt;T&gt;(f: L -&gt; T) -&gt; Either&lt;T,<br>R&gt;&quot; and &quot;mapRight&lt;T&gt;(f: R -&gt; T) -&gt; Either&lt;L, T&gt;&quot; ?<br></p><p>Jacob Bandes-Storch<br></p><p>On Wed, Dec 9, 2015 at 3:49 PM, Developer &lt;devteam.codafi at gmail.com&gt; wrote:<br></p><p>&gt; How would you write `map` for an unbiased Either.  You have to pick a side!<br>&gt;<br>&gt; Our implementation happens to be the one standardized on by Scala,<br>&gt; Haskell, ML, (and to a limited extent) F#.  For a less arbitrary reason,<br>&gt; the use of &quot;Right as Correct&quot; is because Either, in all it’s Bifunctor-ial<br>&gt; ways, has to admit two ways to map “across” itself.  To paraphrase the<br>&gt; words of a friend &quot;There are lots of things in computer science we can<br>&gt; leftMap”.  In Haskell, such a thing is represented by the Functor<br>&gt; typeclass, and due to the way type application works in that language, the<br>&gt; convention has been to map over the rightmost side.  But this isn’t<br>&gt; Haskell, so our reasons can get even more theoretical than that (if you<br>&gt; really want to get into what it looks like when you implement Covariant<br>&gt; mapping down the left side of a common Bifunctor like Either, Cats has<br>&gt; already had a thorough discussion on the subject:<br>&gt; https://github.com/non/cats/issues/189).<br>&gt;<br>&gt; On Dec 9, 2015, at 6:44 PM, Ilias Karim &lt;ilias.karim at gmail.com&gt; wrote:<br>&gt;<br>&gt; I’m sorry, I misunderstood. I guess an enum would be the appropriate<br>&gt; choice, instead.<br>&gt;<br>&gt; As far as left/right goes, the decision to have left or right be the<br>&gt; “correct” value is entirely arbitrary and should be left up to the<br>&gt; developer. It should be a convention at best.<br>&gt;<br>&gt; Ilias<br>&gt;<br>&gt; On Dec 9, 2015, at 3:43 PM, Dave DeLong &lt;delong at apple.com&gt; wrote:<br>&gt;<br>&gt; With a tuple, you have to do “(left: T?, right: U?)”, whereas with an<br>&gt; Either you are guaranteed to always have one or other other; never both and<br>&gt; never neither. That is not guaranteed with the tuple.<br>&gt;<br>&gt; Dave<br>&gt;<br>&gt; On Dec 9, 2015, at 4:41 PM, Ilias Karim via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; What are the advantage over using a tuple? One great feature about tuples<br>&gt; is being able to name parameters so you can dispel ambiguity.<br>&gt;<br>&gt;<br>&gt; On Dec 9, 2015, at 3:35 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; The idea of using Left/Right is to remain agnostic to what sorts of things<br>&gt; users might want to put in. It&#39;s feasible a user might want Either&lt;Int,<br>&gt; String&gt;, not just Either&lt;ErrorType, T&gt;.<br>&gt;<br>&gt; While I&#39;m not sure Left &amp; Right are the best choices, I don&#39;t think it&#39;s<br>&gt; particularly worrisome when it comes to errors, as the general type-safety<br>&gt; of the language will prevent users from mixing up success &amp; error cases.<br>&gt;<br>&gt; Jacob<br>&gt;<br>&gt; On Wed, Dec 9, 2015 at 3:32 PM, Ilias Karim via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Hi Robert,<br>&gt;&gt;<br>&gt;&gt; I agree with your recommendation of a generic Either type.<br>&gt;&gt;<br>&gt;&gt; However, I find your use of “Right” as the “Correct” value (whatever that<br>&gt;&gt; means) of an instance of an Either type a little perplexing. While clever,<br>&gt;&gt; it is exactly the kind of convention that easily leads to misunderstandings<br>&gt;&gt; about the nature of the type itself ie. is it right and left or wrong and<br>&gt;&gt; correct? At least that is my first impression after scanning your code.<br>&gt;&gt;<br>&gt;&gt; Ilias<br>&gt;&gt;<br>&gt;&gt; &gt; On Dec 9, 2015, at 3:06 PM, Developer via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; It’s high time the STL admitted some kind of disjoint union type, at<br>&gt;&gt; the very least because it’s such a minor addition it seems a shame to leave<br>&gt;&gt; it out.  Whatever feelings one may have about `throws`, the lack of<br>&gt;&gt; standardizing on a datatype representing choice has caused the community to<br>&gt;&gt; get creative and create many disjoint implementation of the same concept<br>&gt;&gt; over and over and over again.  To that end, I propose the STL ship with an<br>&gt;&gt; Either type; We at TypeLift have already got our own we’d like to model it<br>&gt;&gt; on (<br>&gt;&gt; https://github.com/typelift/Swiftx/blob/master/Swiftx/Either.swift#L16).<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; ~Robert Widmann (CodaFi)<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/d8223c88/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>Proposal: An Either Type in the STL</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>December  9, 2015 at 06:00:00pm</p></header><div class="content"><p>There is!  That’s what the Bifunctor typeclass is for.  But if you had to pick just one of them to implement some Functor constraint - some canonical `map` function, would you pick the side that you filled with Errors, or the side that you filled with Values?<br></p><p><br>&gt; On Dec 9, 2015, at 6:52 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt; <br>&gt; Is there not precedent for having both &quot;mapLeft&lt;T&gt;(f: L -&gt; T) -&gt; Either&lt;T, R&gt;&quot; and &quot;mapRight&lt;T&gt;(f: R -&gt; T) -&gt; Either&lt;L, T&gt;&quot; ?<br>&gt; <br>&gt; Jacob Bandes-Storch<br>&gt; <br>&gt; On Wed, Dec 9, 2015 at 3:49 PM, Developer &lt;devteam.codafi at gmail.com &lt;mailto:devteam.codafi at gmail.com&gt;&gt; wrote:<br>&gt; How would you write `map` for an unbiased Either.  You have to pick a side!<br>&gt; <br>&gt; Our implementation happens to be the one standardized on by Scala, Haskell, ML, (and to a limited extent) F#.  For a less arbitrary reason, the use of &quot;Right as Correct&quot; is because Either, in all it’s Bifunctor-ial ways, has to admit two ways to map “across” itself.  To paraphrase the words of a friend &quot;There are lots of things in computer science we can leftMap”.  In Haskell, such a thing is represented by the Functor typeclass, and due to the way type application works in that language, the convention has been to map over the rightmost side.  But this isn’t Haskell, so our reasons can get even more theoretical than that (if you really want to get into what it looks like when you implement Covariant mapping down the left side of a common Bifunctor like Either, Cats has already had a thorough discussion on the subject: https://github.com/non/cats/issues/189 &lt;https://github.com/non/cats/issues/189&gt;).<br>&gt; <br>&gt;&gt; On Dec 9, 2015, at 6:44 PM, Ilias Karim &lt;ilias.karim at gmail.com &lt;mailto:ilias.karim at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I’m sorry, I misunderstood. I guess an enum would be the appropriate choice, instead.<br>&gt;&gt; <br>&gt;&gt; As far as left/right goes, the decision to have left or right be the “correct” value is entirely arbitrary and should be left up to the developer. It should be a convention at best.<br>&gt;&gt; <br>&gt;&gt; Ilias<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 9, 2015, at 3:43 PM, Dave DeLong &lt;delong at apple.com &lt;mailto:delong at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; With a tuple, you have to do “(left: T?, right: U?)”, whereas with an Either you are guaranteed to always have one or other other; never both and never neither. That is not guaranteed with the tuple.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 9, 2015, at 4:41 PM, Ilias Karim via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What are the advantage over using a tuple? One great feature about tuples is being able to name parameters so you can dispel ambiguity.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 9, 2015, at 3:35 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The idea of using Left/Right is to remain agnostic to what sorts of things users might want to put in. It&#39;s feasible a user might want Either&lt;Int, String&gt;, not just Either&lt;ErrorType, T&gt;.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; While I&#39;m not sure Left &amp; Right are the best choices, I don&#39;t think it&#39;s particularly worrisome when it comes to errors, as the general type-safety of the language will prevent users from mixing up success &amp; error cases.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Jacob<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Wed, Dec 9, 2015 at 3:32 PM, Ilias Karim via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; Hi Robert,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I agree with your recommendation of a generic Either type.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; However, I find your use of “Right” as the “Correct” value (whatever that means) of an instance of an Either type a little perplexing. While clever, it is exactly the kind of convention that easily leads to misunderstandings about the nature of the type itself ie. is it right and left or wrong and correct? At least that is my first impression after scanning your code.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Ilias<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt; On Dec 9, 2015, at 3:06 PM, Developer via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; It’s high time the STL admitted some kind of disjoint union type, at the very least because it’s such a minor addition it seems a shame to leave it out.  Whatever feelings one may have about `throws`, the lack of standardizing on a datatype representing choice has caused the community to get creative and create many disjoint implementation of the same concept over and over and over again.  To that end, I propose the STL ship with an Either type; We at TypeLift have already got our own we’d like to model it on (https://github.com/typelift/Swiftx/blob/master/Swiftx/Either.swift#L16 &lt;https://github.com/typelift/Swiftx/blob/master/Swiftx/Either.swift#L16&gt;).<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; ~Robert Widmann (CodaFi)<br>&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/5cf5c500/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>Proposal: An Either Type in the STL</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>December 10, 2015 at 05:00:00am</p></header><div class="content"><p>I hope that we can get both Either and Result into the standard lib. A<br>great situation might be if Result were some sort of newtype declaration of<br>Either.<br></p><p>On Thu, Dec 10, 2015 at 5:25 AM, Developer via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; There is!  That’s what the Bifunctor typeclass is for.  But if you had to<br>&gt; pick just one of them to implement some Functor constraint - some canonical<br>&gt; `map` function, would you pick the side that you filled with Errors, or the<br>&gt; side that you filled with Values?<br>&gt;<br>&gt;<br>&gt; On Dec 9, 2015, at 6:52 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; Is there not precedent for having both &quot;mapLeft&lt;T&gt;(f: L -&gt; T) -&gt; Either&lt;T,<br>&gt; R&gt;&quot; and &quot;mapRight&lt;T&gt;(f: R -&gt; T) -&gt; Either&lt;L, T&gt;&quot; ?<br>&gt;<br>&gt; Jacob Bandes-Storch<br>&gt;<br>&gt; On Wed, Dec 9, 2015 at 3:49 PM, Developer &lt;devteam.codafi at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; How would you write `map` for an unbiased Either.  You have to pick a<br>&gt;&gt; side!<br>&gt;&gt;<br>&gt;&gt; Our implementation happens to be the one standardized on by Scala,<br>&gt;&gt; Haskell, ML, (and to a limited extent) F#.  For a less arbitrary reason,<br>&gt;&gt; the use of &quot;Right as Correct&quot; is because Either, in all it’s Bifunctor-ial<br>&gt;&gt; ways, has to admit two ways to map “across” itself.  To paraphrase the<br>&gt;&gt; words of a friend &quot;There are lots of things in computer science we can<br>&gt;&gt; leftMap”.  In Haskell, such a thing is represented by the Functor<br>&gt;&gt; typeclass, and due to the way type application works in that language, the<br>&gt;&gt; convention has been to map over the rightmost side.  But this isn’t<br>&gt;&gt; Haskell, so our reasons can get even more theoretical than that (if you<br>&gt;&gt; really want to get into what it looks like when you implement Covariant<br>&gt;&gt; mapping down the left side of a common Bifunctor like Either, Cats has<br>&gt;&gt; already had a thorough discussion on the subject:<br>&gt;&gt; https://github.com/non/cats/issues/189).<br>&gt;&gt;<br>&gt;&gt; On Dec 9, 2015, at 6:44 PM, Ilias Karim &lt;ilias.karim at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I’m sorry, I misunderstood. I guess an enum would be the appropriate<br>&gt;&gt; choice, instead.<br>&gt;&gt;<br>&gt;&gt; As far as left/right goes, the decision to have left or right be the<br>&gt;&gt; “correct” value is entirely arbitrary and should be left up to the<br>&gt;&gt; developer. It should be a convention at best.<br>&gt;&gt;<br>&gt;&gt; Ilias<br>&gt;&gt;<br>&gt;&gt; On Dec 9, 2015, at 3:43 PM, Dave DeLong &lt;delong at apple.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; With a tuple, you have to do “(left: T?, right: U?)”, whereas with an<br>&gt;&gt; Either you are guaranteed to always have one or other other; never both and<br>&gt;&gt; never neither. That is not guaranteed with the tuple.<br>&gt;&gt;<br>&gt;&gt; Dave<br>&gt;&gt;<br>&gt;&gt; On Dec 9, 2015, at 4:41 PM, Ilias Karim via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; What are the advantage over using a tuple? One great feature about tuples<br>&gt;&gt; is being able to name parameters so you can dispel ambiguity.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Dec 9, 2015, at 3:35 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; The idea of using Left/Right is to remain agnostic to what sorts of<br>&gt;&gt; things users might want to put in. It&#39;s feasible a user might want<br>&gt;&gt; Either&lt;Int, String&gt;, not just Either&lt;ErrorType, T&gt;.<br>&gt;&gt;<br>&gt;&gt; While I&#39;m not sure Left &amp; Right are the best choices, I don&#39;t think it&#39;s<br>&gt;&gt; particularly worrisome when it comes to errors, as the general type-safety<br>&gt;&gt; of the language will prevent users from mixing up success &amp; error cases.<br>&gt;&gt;<br>&gt;&gt; Jacob<br>&gt;&gt;<br>&gt;&gt; On Wed, Dec 9, 2015 at 3:32 PM, Ilias Karim via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Hi Robert,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I agree with your recommendation of a generic Either type.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; However, I find your use of “Right” as the “Correct” value (whatever<br>&gt;&gt;&gt; that means) of an instance of an Either type a little perplexing. While<br>&gt;&gt;&gt; clever, it is exactly the kind of convention that easily leads to<br>&gt;&gt;&gt; misunderstandings about the nature of the type itself ie. is it right and<br>&gt;&gt;&gt; left or wrong and correct? At least that is my first impression after<br>&gt;&gt;&gt; scanning your code.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Ilias<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; On Dec 9, 2015, at 3:06 PM, Developer via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; It’s high time the STL admitted some kind of disjoint union type, at<br>&gt;&gt;&gt; the very least because it’s such a minor addition it seems a shame to leave<br>&gt;&gt;&gt; it out.  Whatever feelings one may have about `throws`, the lack of<br>&gt;&gt;&gt; standardizing on a datatype representing choice has caused the community to<br>&gt;&gt;&gt; get creative and create many disjoint implementation of the same concept<br>&gt;&gt;&gt; over and over and over again.  To that end, I propose the STL ship with an<br>&gt;&gt;&gt; Either type; We at TypeLift have already got our own we’d like to model it<br>&gt;&gt;&gt; on (<br>&gt;&gt;&gt; https://github.com/typelift/Swiftx/blob/master/Swiftx/Either.swift#L16).<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; ~Robert Widmann (CodaFi)<br>&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/b7a2bae1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: An Either Type in the STL</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 10, 2015 at 12:00:00am</p></header><div class="content"><p>I support the addition of a Result, and I encourage people to look at https://doc.rust-lang.org/stable/std/result/index.html for a good example of how this can be done well. I&#39;d like a Result&lt;T,E&gt; in Swift that looks similar.<br></p><p>I do not support the addition of Either. As far as I am aware, the only<br>compelling argument in favor of an Either type is &quot;because Haskell has<br>one&quot;, but I believe it&#39;s commonly recognized that Haskell&#39;s Either is<br>not particularly good. It&#39;s a weird name for results (which Result<br>covers), and for other cases it&#39;s usually better just to define your own<br>two-variant enum anyway. Rust provides some evidence in favor of this,<br>as this was the rationale for why Rust has a Result&lt;T,E&gt; but no Either,<br>and it turns out there has been no need to add an Either.<br></p><p>-Kevin Ballard<br></p><p>On Wed, Dec 9, 2015, at 04:01 PM, T.J. Usiyan via swift-evolution wrote:<br>&gt; I hope that we can get both Either and Result into the standard lib. A<br>&gt; great situation might be if Result were some sort of newtype<br>&gt; declaration of Either.<br>&gt;<br>&gt; On Thu, Dec 10, 2015 at 5:25 AM, Developer via swift-evolution &lt;swift-<br>&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt; There is!  That’s what the Bifunctor typeclass is for.  But if you<br>&gt;&gt; had to pick just one of them to implement some Functor constraint -<br>&gt;&gt; some canonical `map` function, would you pick the side that you<br>&gt;&gt; filled with Errors, or the side that you filled with Values?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; On Dec 9, 2015, at 6:52 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Is there not precedent for having both &quot;mapLeft&lt;T&gt;(f: L -&gt; T) -&gt;<br>&gt;&gt;&gt; Either&lt;T, R&gt;&quot; and &quot;mapRight&lt;T&gt;(f: R -&gt; T) -&gt; Either&lt;L, T&gt;&quot; ?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Jacob Bandes-Storch<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Wed, Dec 9, 2015 at 3:49 PM, Developer &lt;devteam.codafi at gmail.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; How would you write `map` for an unbiased Either.  You have to pick<br>&gt;&gt;&gt;&gt; a side!<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Our implementation happens to be the one standardized on by Scala,<br>&gt;&gt;&gt;&gt; Haskell, ML, (and to a limited extent) F#.  For a less arbitrary<br>&gt;&gt;&gt;&gt; reason, the use of &quot;Right as Correct&quot; is because Either, in all<br>&gt;&gt;&gt;&gt; it’s Bifunctor-ial ways, has to admit two ways to map “across”<br>&gt;&gt;&gt;&gt; itself.  To paraphrase the words of a friend &quot;There are lots of<br>&gt;&gt;&gt;&gt; things in computer science we can leftMap”.  In Haskell, such a<br>&gt;&gt;&gt;&gt; thing is represented by the Functor typeclass, and due to the way<br>&gt;&gt;&gt;&gt; type application works in that language, the convention has been to<br>&gt;&gt;&gt;&gt; map over the rightmost side.  But this isn’t Haskell, so our<br>&gt;&gt;&gt;&gt; reasons can get even more theoretical than that (if you really want<br>&gt;&gt;&gt;&gt; to get into what it looks like when you implement Covariant mapping<br>&gt;&gt;&gt;&gt; down the left side of a common Bifunctor like Either, Cats has<br>&gt;&gt;&gt;&gt; already had a thorough discussion on the subject:<br>&gt;&gt;&gt;&gt; https://github.com/non/cats/issues/189).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Dec 9, 2015, at 6:44 PM, Ilias Karim &lt;ilias.karim at gmail.com&gt;<br>&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I’m sorry, I misunderstood. I guess an enum would be the<br>&gt;&gt;&gt;&gt;&gt; appropriate choice, instead.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; As far as left/right goes, the decision to have left or right be<br>&gt;&gt;&gt;&gt;&gt; the “correct” value is entirely arbitrary and should be left up to<br>&gt;&gt;&gt;&gt;&gt; the developer. It should be a convention at best.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Ilias<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 9, 2015, at 3:43 PM, Dave DeLong &lt;delong at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; With a tuple, you have to do “(left: T?, right: U?)”, whereas<br>&gt;&gt;&gt;&gt;&gt;&gt; with an Either you are guaranteed to always have one or other<br>&gt;&gt;&gt;&gt;&gt;&gt; other; never both and never neither. That is not guaranteed with<br>&gt;&gt;&gt;&gt;&gt;&gt; the tuple.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Dave<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 9, 2015, at 4:41 PM, Ilias Karim via swift-evolution &lt;swift-<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; What are the advantage over using a tuple? One great feature<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; about tuples is being able to name parameters so you can dispel<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ambiguity.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 9, 2015, at 3:35 PM, Jacob Bandes-Storch<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;jtbandes at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The idea of using Left/Right is to remain agnostic to what<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; sorts of things users might want to put in. It&#39;s feasible a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; user might want Either&lt;Int, String&gt;, not just Either&lt;ErrorType,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; T&gt;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; While I&#39;m not sure Left &amp; Right are the best choices, I don&#39;t<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; think it&#39;s particularly worrisome when it comes to errors, as<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the general type-safety of the language will prevent users from<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; mixing up success &amp; error cases.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jacob<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Dec 9, 2015 at 3:32 PM, Ilias Karim via swift-evolution&lt;swift-<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; evolution at swift.org&gt;wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hi Robert,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I agree with your recommendation of a generic Either type.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; However, I find your use of “Right” as the “Correct” value<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; (whatever that means) of an instance of an Either type a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; little perplexing. While clever, it is exactly the kind of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; convention that easily leads to misunderstandings about the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; nature of the type itself ie. is it right and left or wrong<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; and correct? At least that is my first impression after<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; scanning your code.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Ilias<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; On Dec 9, 2015, at 3:06 PM, Developer via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; It’s high time the STL admitted some kind of disjoint union<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; type, at the very least because it’s such a minor addition<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; it seems a shame to leave it out.  Whatever feelings one may<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; have about `throws`, the lack of standardizing on a datatype<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; representing choice has caused the community to get creative<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; and create many disjoint implementation of the same concept<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; over and over and over again.  To that end, I propose the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; STL ship with an Either type; We at TypeLift have already<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; got our own we’d like to model it on<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; (https://github.com/typelift/Swiftx/blob/master/Swiftx/Either.swift#L16)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; .<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; ~Robert Widmann (CodaFi)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt;<br>swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/356e5c1c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d5ada5f318f38f99b9d0a5d88284743a?s=50"></div><header><strong>Proposal: An Either Type in the STL</strong> from <string>Nick Shelley</string> &lt;nickmshelley at gmail.com&gt;<p>December 10, 2015 at 11:00:00am</p></header><div class="content"><p>Can you explain why you think it&#39;s better to just define your own<br>two-variant enum rather than having a built-in Either type, or point me to<br>the evidence that Rust found in favor of this approach?<br></p><p>I had to create my own Either type for some code I wrote semi-recently and<br>wished it was built in, so I&#39;m wondering why I apparently shouldn&#39;t have<br>wished that, but been glad that I&#39;m creating my own.<br></p><p>On Thu, Dec 10, 2015 at 1:34 AM, Kevin Ballard via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I support the addition of a Result, and I encourage people to look at<br>&gt; https://doc.rust-lang.org/stable/std/result/index.html for a good example<br>&gt; of how this can be done well. I&#39;d like a Result&lt;T,E&gt; in Swift that looks<br>&gt; similar.<br>&gt;<br>&gt; I do not support the addition of Either. As far as I am aware, the only<br>&gt; compelling argument in favor of an Either type is &quot;because Haskell has<br>&gt; one&quot;, but I believe it&#39;s commonly recognized that Haskell&#39;s Either is not<br>&gt; particularly good. It&#39;s a weird name for results (which Result covers), and<br>&gt; for other cases it&#39;s usually better just to define your own two-variant<br>&gt; enum anyway. Rust provides some evidence in favor of this, as this was the<br>&gt; rationale for why Rust has a Result&lt;T,E&gt; but no Either, and it turns out<br>&gt; there has been no need to add an Either.<br>&gt;<br>&gt; -Kevin Ballard<br>&gt;<br>&gt; On Wed, Dec 9, 2015, at 04:01 PM, T.J. Usiyan via swift-evolution wrote:<br>&gt;<br>&gt; I hope that we can get both Either and Result into the standard lib. A<br>&gt; great situation might be if Result were some sort of newtype declaration of<br>&gt; Either.<br>&gt;<br>&gt; On Thu, Dec 10, 2015 at 5:25 AM, Developer via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; There is!  That’s what the Bifunctor typeclass is for.  But if you had to<br>&gt; pick just one of them to implement some Functor constraint - some canonical<br>&gt; `map` function, would you pick the side that you filled with Errors, or the<br>&gt; side that you filled with Values?<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Dec 9, 2015, at 6:52 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; Is there not precedent for having both &quot;mapLeft&lt;T&gt;(f: L -&gt; T) -&gt; Either&lt;T,<br>&gt; R&gt;&quot; and &quot;mapRight&lt;T&gt;(f: R -&gt; T) -&gt; Either&lt;L, T&gt;&quot; ?<br>&gt;<br>&gt; Jacob Bandes-Storch<br>&gt;<br>&gt; On Wed, Dec 9, 2015 at 3:49 PM, Developer &lt;devteam.codafi at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; How would you write `map` for an unbiased Either.  You have to pick a side!<br>&gt;<br>&gt; Our implementation happens to be the one standardized on by Scala,<br>&gt; Haskell, ML, (and to a limited extent) F#.  For a less arbitrary reason,<br>&gt; the use of &quot;Right as Correct&quot; is because Either, in all it’s Bifunctor-ial<br>&gt; ways, has to admit two ways to map “across” itself.  To paraphrase the<br>&gt; words of a friend &quot;There are lots of things in computer science we can<br>&gt; leftMap”.  In Haskell, such a thing is represented by the Functor<br>&gt; typeclass, and due to the way type application works in that language, the<br>&gt; convention has been to map over the rightmost side.  But this isn’t<br>&gt; Haskell, so our reasons can get even more theoretical than that (if you<br>&gt; really want to get into what it looks like when you implement Covariant<br>&gt; mapping down the left side of a common Bifunctor like Either, Cats has<br>&gt; already had a thorough discussion on the subject:<br>&gt; https://github.com/non/cats/issues/189).<br>&gt;<br>&gt;<br>&gt; On Dec 9, 2015, at 6:44 PM, Ilias Karim &lt;ilias.karim at gmail.com&gt; wrote:<br>&gt;<br>&gt; I’m sorry, I misunderstood. I guess an enum would be the appropriate<br>&gt; choice, instead.<br>&gt;<br>&gt; As far as left/right goes, the decision to have left or right be the<br>&gt; “correct” value is entirely arbitrary and should be left up to the<br>&gt; developer. It should be a convention at best.<br>&gt;<br>&gt; Ilias<br>&gt;<br>&gt;<br>&gt; On Dec 9, 2015, at 3:43 PM, Dave DeLong &lt;delong at apple.com&gt; wrote:<br>&gt;<br>&gt; With a tuple, you have to do “(left: T?, right: U?)”, whereas with an<br>&gt; Either you are guaranteed to always have one or other other; never both and<br>&gt; never neither. That is not guaranteed with the tuple.<br>&gt;<br>&gt; Dave<br>&gt;<br>&gt;<br>&gt; On Dec 9, 2015, at 4:41 PM, Ilias Karim via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; What are the advantage over using a tuple? One great feature about tuples<br>&gt; is being able to name parameters so you can dispel ambiguity.<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Dec 9, 2015, at 3:35 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; The idea of using Left/Right is to remain agnostic to what sorts of things<br>&gt; users might want to put in. It&#39;s feasible a user might want Either&lt;Int,<br>&gt; String&gt;, not just Either&lt;ErrorType, T&gt;.<br>&gt;<br>&gt; While I&#39;m not sure Left &amp; Right are the best choices, I don&#39;t think it&#39;s<br>&gt; particularly worrisome when it comes to errors, as the general type-safety<br>&gt; of the language will prevent users from mixing up success &amp; error cases.<br>&gt;<br>&gt; Jacob<br>&gt;<br>&gt; On Wed, Dec 9, 2015 at 3:32 PM, Ilias Karim via swift-evolution&lt;<br>&gt; swift-evolution at swift.org&gt;wrote:<br>&gt;<br>&gt; Hi Robert,<br>&gt;<br>&gt; I agree with your recommendation of a generic Either type.<br>&gt;<br>&gt; However, I find your use of “Right” as the “Correct” value (whatever that<br>&gt; means) of an instance of an Either type a little perplexing. While clever,<br>&gt; it is exactly the kind of convention that easily leads to misunderstandings<br>&gt; about the nature of the type itself ie. is it right and left or wrong and<br>&gt; correct? At least that is my first impression after scanning your code.<br>&gt;<br>&gt; Ilias<br>&gt;<br>&gt; &gt; On Dec 9, 2015, at 3:06 PM, Developer via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; It’s high time the STL admitted some kind of disjoint union type, at the<br>&gt; very least because it’s such a minor addition it seems a shame to leave it<br>&gt; out.  Whatever feelings one may have about `throws`, the lack of<br>&gt; standardizing on a datatype representing choice has caused the community to<br>&gt; get creative and create many disjoint implementation of the same concept<br>&gt; over and over and over again.  To that end, I propose the STL ship with an<br>&gt; Either type; We at TypeLift have already got our own we’d like to model it<br>&gt; on (https://github.com/typelift/Swiftx/blob/master/Swiftx/Either.swift#L16<br>&gt; ).<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; ~Robert Widmann (CodaFi)<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt;swift-evolution at swift.org<br>&gt; &gt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; *_______________________________________________*<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/b177d417/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal: An Either Type in the STL</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 10, 2015 at 10:00:00am</p></header><div class="content"><p>As an alternative to a semantically-neutral Either type, it might be worth considering the possibility of anonymous structural sum types (similar to how tuples are the structural analog of structs).<br></p><p>-Joe<br></p><p>&gt; On Dec 10, 2015, at 10:06 AM, Nick Shelley via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Can you explain why you think it&#39;s better to just define your own two-variant enum rather than having a built-in Either type, or point me to the evidence that Rust found in favor of this approach?<br>&gt; <br>&gt; I had to create my own Either type for some code I wrote semi-recently and wished it was built in, so I&#39;m wondering why I apparently shouldn&#39;t have wished that, but been glad that I&#39;m creating my own.<br>&gt; <br>&gt; On Thu, Dec 10, 2015 at 1:34 AM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; I support the addition of a Result, and I encourage people to look at https://doc.rust-lang.org/stable/std/result/index.html &lt;https://doc.rust-lang.org/stable/std/result/index.html&gt; for a good example of how this can be done well. I&#39;d like a Result&lt;T,E&gt; in Swift that looks similar.<br>&gt;  <br>&gt; I do not support the addition of Either. As far as I am aware, the only compelling argument in favor of an Either type is &quot;because Haskell has one&quot;, but I believe it&#39;s commonly recognized that Haskell&#39;s Either is not particularly good. It&#39;s a weird name for results (which Result covers), and for other cases it&#39;s usually better just to define your own two-variant enum anyway. Rust provides some evidence in favor of this, as this was the rationale for why Rust has a Result&lt;T,E&gt; but no Either, and it turns out there has been no need to add an Either.<br>&gt;  <br>&gt; -Kevin Ballard<br>&gt;  <br>&gt; On Wed, Dec 9, 2015, at 04:01 PM, T.J. Usiyan via swift-evolution wrote:<br>&gt;&gt; I hope that we can get both Either and Result into the standard lib. A great situation might be if Result were some sort of newtype declaration of Either.<br>&gt;&gt;  <br>&gt;&gt; On Thu, Dec 10, 2015 at 5:25 AM, Developer via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; There is!  That’s what the Bifunctor typeclass is for.  But if you had to pick just one of them to implement some Functor constraint - some canonical `map` function, would you pick the side that you filled with Errors, or the side that you filled with Values?<br>&gt;&gt;  <br>&gt;&gt;  <br>&gt;&gt;&gt; On Dec 9, 2015, at 6:52 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Is there not precedent for having both &quot;mapLeft&lt;T&gt;(f: L -&gt; T) -&gt; Either&lt;T, R&gt;&quot; and &quot;mapRight&lt;T&gt;(f: R -&gt; T) -&gt; Either&lt;L, T&gt;&quot; ?<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Jacob Bandes-Storch<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; On Wed, Dec 9, 2015 at 3:49 PM, Developer &lt;devteam.codafi at gmail.com &lt;mailto:devteam.codafi at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; How would you write `map` for an unbiased Either.  You have to pick a side!<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Our implementation happens to be the one standardized on by Scala, Haskell, ML, (and to a limited extent) F#.  For a less arbitrary reason, the use of &quot;Right as Correct&quot; is because Either, in all it’s Bifunctor-ial ways, has to admit two ways to map “across” itself.  To paraphrase the words of a friend &quot;There are lots of things in computer science we can leftMap”.  In Haskell, such a thing is represented by the Functor typeclass, and due to the way type application works in that language, the convention has been to map over the rightmost side.  But this isn’t Haskell, so our reasons can get even more theoretical than that (if you really want to get into what it looks like when you implement Covariant mapping down the left side of a common Bifunctor like Either, Cats has already had a thorough discussion on the subject: https://github.com/non/cats/issues/189 &lt;https://github.com/non/cats/issues/189&gt;).<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; On Dec 9, 2015, at 6:44 PM, Ilias Karim &lt;ilias.karim at gmail.com &lt;mailto:ilias.karim at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; I’m sorry, I misunderstood. I guess an enum would be the appropriate choice, instead.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; As far as left/right goes, the decision to have left or right be the “correct” value is entirely arbitrary and should be left up to the developer. It should be a convention at best.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Ilias<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; On Dec 9, 2015, at 3:43 PM, Dave DeLong &lt;delong at apple.com &lt;mailto:delong at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; With a tuple, you have to do “(left: T?, right: U?)”, whereas with an Either you are guaranteed to always have one or other other; never both and never neither. That is not guaranteed with the tuple.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; Dave<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 9, 2015, at 4:41 PM, Ilias Karim via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; What are the advantage over using a tuple? One great feature about tuples is being able to name parameters so you can dispel ambiguity.<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 9, 2015, at 3:35 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The idea of using Left/Right is to remain agnostic to what sorts of things users might want to put in. It&#39;s feasible a user might want Either&lt;Int, String&gt;, not just Either&lt;ErrorType, T&gt;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; While I&#39;m not sure Left &amp; Right are the best choices, I don&#39;t think it&#39;s particularly worrisome when it comes to errors, as the general type-safety of the language will prevent users from mixing up success &amp; error cases.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jacob<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Dec 9, 2015 at 3:32 PM, Ilias Karim via swift-evolution&lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hi Robert,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I agree with your recommendation of a generic Either type.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; However, I find your use of “Right” as the “Correct” value (whatever that means) of an instance of an Either type a little perplexing. While clever, it is exactly the kind of convention that easily leads to misunderstandings about the nature of the type itself ie. is it right and left or wrong and correct? At least that is my first impression after scanning your code.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Ilias<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; On Dec 9, 2015, at 3:06 PM, Developer via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; It’s high time the STL admitted some kind of disjoint union type, at the very least because it’s such a minor addition it seems a shame to leave it out.  Whatever feelings one may have about `throws`, the lack of standardizing on a datatype representing choice has caused the community to get creative and create many disjoint implementation of the same concept over and over and over again.  To that end, I propose the STL ship with an Either type; We at TypeLift have already got our own we’d like to model it on (https://github.com/typelift/Swiftx/blob/master/Swiftx/Either.swift#L16 &lt;https://github.com/typelift/Swiftx/blob/master/Swiftx/Either.swift#L16&gt;).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; ~Robert Widmann (CodaFi)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt;  <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/7ee7043a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: An Either Type in the STL</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 10, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; As an alternative to a semantically-neutral Either type, it might be worth considering the possibility of anonymous structural sum types (similar to how tuples are the structural analog of structs).<br></p><p>John mentioned that these are a massive complication for type systems when I proposed them as a possible way to implement throwing multiple error types.  Do you agree with that?<br></p><p><br>&gt; <br>&gt; <br>&gt;&gt; On Dec 10, 2015, at 10:06 AM, Nick Shelley via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Can you explain why you think it&#39;s better to just define your own two-variant enum rather than having a built-in Either type, or point me to the evidence that Rust found in favor of this approach?<br>&gt;&gt; <br>&gt;&gt; I had to create my own Either type for some code I wrote semi-recently and wished it was built in, so I&#39;m wondering why I apparently shouldn&#39;t have wished that, but been glad that I&#39;m creating my own.<br>&gt;&gt; <br>&gt;&gt; On Thu, Dec 10, 2015 at 1:34 AM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; I support the addition of a Result, and I encourage people to look at https://doc.rust-lang.org/stable/std/result/index.html &lt;https://doc.rust-lang.org/stable/std/result/index.html&gt; for a good example of how this can be done well. I&#39;d like a Result&lt;T,E&gt; in Swift that looks similar.<br>&gt;&gt;  <br>&gt;&gt; I do not support the addition of Either. As far as I am aware, the only compelling argument in favor of an Either type is &quot;because Haskell has one&quot;, but I believe it&#39;s commonly recognized that Haskell&#39;s Either is not particularly good. It&#39;s a weird name for results (which Result covers), and for other cases it&#39;s usually better just to define your own two-variant enum anyway. Rust provides some evidence in favor of this, as this was the rationale for why Rust has a Result&lt;T,E&gt; but no Either, and it turns out there has been no need to add an Either.<br>&gt;&gt;  <br>&gt;&gt; -Kevin Ballard<br>&gt;&gt;  <br>&gt;&gt; On Wed, Dec 9, 2015, at 04:01 PM, T.J. Usiyan via swift-evolution wrote:<br>&gt;&gt;&gt; I hope that we can get both Either and Result into the standard lib. A great situation might be if Result were some sort of newtype declaration of Either.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; On Thu, Dec 10, 2015 at 5:25 AM, Developer via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; There is!  That’s what the Bifunctor typeclass is for.  But if you had to pick just one of them to implement some Functor constraint - some canonical `map` function, would you pick the side that you filled with Errors, or the side that you filled with Values?<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; On Dec 9, 2015, at 6:52 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Is there not precedent for having both &quot;mapLeft&lt;T&gt;(f: L -&gt; T) -&gt; Either&lt;T, R&gt;&quot; and &quot;mapRight&lt;T&gt;(f: R -&gt; T) -&gt; Either&lt;L, T&gt;&quot; ?<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Jacob Bandes-Storch<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; On Wed, Dec 9, 2015 at 3:49 PM, Developer &lt;devteam.codafi at gmail.com &lt;mailto:devteam.codafi at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; How would you write `map` for an unbiased Either.  You have to pick a side!<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Our implementation happens to be the one standardized on by Scala, Haskell, ML, (and to a limited extent) F#.  For a less arbitrary reason, the use of &quot;Right as Correct&quot; is because Either, in all it’s Bifunctor-ial ways, has to admit two ways to map “across” itself.  To paraphrase the words of a friend &quot;There are lots of things in computer science we can leftMap”.  In Haskell, such a thing is represented by the Functor typeclass, and due to the way type application works in that language, the convention has been to map over the rightmost side.  But this isn’t Haskell, so our reasons can get even more theoretical than that (if you really want to get into what it looks like when you implement Covariant mapping down the left side of a common Bifunctor like Either, Cats has already had a thorough discussion on the subject: https://github.com/non/cats/issues/189 &lt;https://github.com/non/cats/issues/189&gt;).<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; On Dec 9, 2015, at 6:44 PM, Ilias Karim &lt;ilias.karim at gmail.com &lt;mailto:ilias.karim at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; I’m sorry, I misunderstood. I guess an enum would be the appropriate choice, instead.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; As far as left/right goes, the decision to have left or right be the “correct” value is entirely arbitrary and should be left up to the developer. It should be a convention at best.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; Ilias<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 9, 2015, at 3:43 PM, Dave DeLong &lt;delong at apple.com &lt;mailto:delong at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; With a tuple, you have to do “(left: T?, right: U?)”, whereas with an Either you are guaranteed to always have one or other other; never both and never neither. That is not guaranteed with the tuple.<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; Dave<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 9, 2015, at 4:41 PM, Ilias Karim via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; What are the advantage over using a tuple? One great feature about tuples is being able to name parameters so you can dispel ambiguity.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 9, 2015, at 3:35 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The idea of using Left/Right is to remain agnostic to what sorts of things users might want to put in. It&#39;s feasible a user might want Either&lt;Int, String&gt;, not just Either&lt;ErrorType, T&gt;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; While I&#39;m not sure Left &amp; Right are the best choices, I don&#39;t think it&#39;s particularly worrisome when it comes to errors, as the general type-safety of the language will prevent users from mixing up success &amp; error cases.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jacob<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Dec 9, 2015 at 3:32 PM, Ilias Karim via swift-evolution&lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hi Robert,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I agree with your recommendation of a generic Either type.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; However, I find your use of “Right” as the “Correct” value (whatever that means) of an instance of an Either type a little perplexing. While clever, it is exactly the kind of convention that easily leads to misunderstandings about the nature of the type itself ie. is it right and left or wrong and correct? At least that is my first impression after scanning your code.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Ilias<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; On Dec 9, 2015, at 3:06 PM, Developer via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; It’s high time the STL admitted some kind of disjoint union type, at the very least because it’s such a minor addition it seems a shame to leave it out.  Whatever feelings one may have about `throws`, the lack of standardizing on a datatype representing choice has caused the community to get creative and create many disjoint implementation of the same concept over and over and over again.  To that end, I propose the STL ship with an Either type; We at TypeLift have already got our own we’d like to model it on (https://github.com/typelift/Swiftx/blob/master/Swiftx/Either.swift#L16 &lt;https://github.com/typelift/Swiftx/blob/master/Swiftx/Either.swift#L16&gt;).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; ~Robert Widmann (CodaFi)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/0505ab6c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal: An Either Type in the STL</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 10, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 10, 2015, at 10:34 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt;&gt; As an alternative to a semantically-neutral Either type, it might be worth considering the possibility of anonymous structural sum types (similar to how tuples are the structural analog of structs).<br>&gt; <br>&gt; John mentioned that these are a massive complication for type systems when I proposed them as a possible way to implement throwing multiple error types.  Do you agree with that?<br></p><p>There are definitely problems if you expect them to behave like unions (so that the type `T + T` == `T`) or be unordered (so that `T + U` == `U + T`), which would be intuitively expected.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f5228ad4a1fad94f1a7d3d05b0c0ff6a?s=50"></div><header><strong>Proposal: An Either Type in the STL</strong> from <string>Donnacha Oisín Kidney</string> &lt;oisin.kidney at gmail.com&gt;<p>December 10, 2015 at 06:00:00pm</p></header><div class="content"><p>If the analogy is to tuples, though, I would intuitively expect the other behaviour. Maybe something like:<br></p><p>let listOfProducts: [(Int, Bool)] = [(1, true), (2, false)]<br>let listOfSums: [(Int|Bool)] = [(|true), (2|)]<br></p><p>&gt; On 10 Dec 2015, at 18:38, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 10, 2015, at 10:34 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; As an alternative to a semantically-neutral Either type, it might be worth considering the possibility of anonymous structural sum types (similar to how tuples are the structural analog of structs).<br>&gt;&gt; <br>&gt;&gt; John mentioned that these are a massive complication for type systems when I proposed them as a possible way to implement throwing multiple error types.  Do you agree with that?<br>&gt; <br>&gt; There are definitely problems if you expect them to behave like unions (so that the type `T + T` == `T`) or be unordered (so that `T + U` == `U + T`), which would be intuitively expected.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/678f283a/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: An Either Type in the STL</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 10, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; There are definitely problems if you expect them to behave like unions (so that the type `T + T` == `T`) or be unordered (so that `T + U` == `U + T`), which would be intuitively expected.<br></p><p>Thanks for explaining the source of complication.  These definitely seem like intuitively expected behaviors.  <br></p><p>In the context of typed throws we would expect ()-&gt;() throws MyError, YourError to be the same as ()-&gt;() throws YourError, MyError.<br></p><p>I have an idea that seems obvious enough that there are probably problems with it.  Couldn&#39;t the type system support a canonical subset of the theoretically possible structural sum types and canonicalize structural sum types immediately when it encounters them?  An obvious way to canonicalize would be to sort the types (comparator could be arbitrary as long as it was consistent) and then unique adjacent members.  This seems like it would provide the intuitively expected behavior.  Is this a viable approach or are there problems with it?<br></p><p>Matthew<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Proposal: An Either Type in the STL</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>December 10, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; On Dec 10, 2015, at 11:30 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; There are definitely problems if you expect them to behave like unions (so that the type `T + T` == `T`) or be unordered (so that `T + U` == `U + T`), which would be intuitively expected.<br>&gt; <br>&gt; Thanks for explaining the source of complication.  These definitely seem like intuitively expected behaviors.  <br>&gt; <br>&gt; In the context of typed throws we would expect ()-&gt;() throws MyError, YourError to be the same as ()-&gt;() throws YourError, MyError.<br>&gt; <br>&gt; I have an idea that seems obvious enough that there are probably problems with it.  Couldn&#39;t the type system support a canonical subset of the theoretically possible structural sum types and canonicalize structural sum types immediately when it encounters them?  An obvious way to canonicalize would be to sort the types (comparator could be arbitrary as long as it was consistent) and then unique adjacent members.  This seems like it would provide the intuitively expected behavior.  Is this a viable approach or are there problems with it?<br></p><p>Generics.<br></p><p>Also, what are the proposed injection / projection / conversion rules for structural sums?  Implicit injection and dynamic cast, as if it were an existential type?<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Proposal: An Either Type in the STL</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>December 10, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; On Dec 10, 2015, at 11:49 AM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; On Dec 10, 2015, at 11:30 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; There are definitely problems if you expect them to behave like unions (so that the type `T + T` == `T`) or be unordered (so that `T + U` == `U + T`), which would be intuitively expected.<br>&gt;&gt; <br>&gt;&gt; Thanks for explaining the source of complication.  These definitely seem like intuitively expected behaviors.  <br>&gt;&gt; <br>&gt;&gt; In the context of typed throws we would expect ()-&gt;() throws MyError, YourError to be the same as ()-&gt;() throws YourError, MyError.<br>&gt;&gt; <br>&gt;&gt; I have an idea that seems obvious enough that there are probably problems with it.  Couldn&#39;t the type system support a canonical subset of the theoretically possible structural sum types and canonicalize structural sum types immediately when it encounters them?  An obvious way to canonicalize would be to sort the types (comparator could be arbitrary as long as it was consistent) and then unique adjacent members.  This seems like it would provide the intuitively expected behavior.  Is this a viable approach or are there problems with it?<br>&gt; <br>&gt; Generics.<br>&gt; <br>&gt; Also, what are the proposed injection / projection / conversion rules for structural sums?  Implicit injection and dynamic cast, as if it were an existential type?<br></p><p>Also, are we allowed to *infer* structural sums?  For example, can we decide that the type of (x ? A() : B()) is A+B if that’s the greatest common type?  And do you know how to solve such typing problems efficiently in System F-sub?<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Proposal: An Either Type in the STL</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>December 12, 2015 at 07:00:00pm</p></header><div class="content"><p>&gt; Am 10.12.2015 um 20:59 schrieb John McCall via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Also, are we allowed to *infer* structural sums?  For example, can we decide that the type of (x ? A() : B()) is A+B if that’s the greatest common type?  <br></p><p>That’s what Ceylon does.<br></p><p>-Thorsten<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151212/b96721bf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: An Either Type in the STL</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 12, 2015 at 01:00:00pm</p></header><div class="content"><p>I don’t have any experience working in a language with structural sum types but I think inference of structural sums in different branches of a conditional would lead to a lot of bugs and potential confusion.  Before considering support of such inference I would want to see pretty compelling evidence that it adds value and doesn’t lead to problems.<br></p><p>In absence of allowing this inference, the structural sum could be specified manually if that is what is intended.<br></p><p>&gt; On Dec 12, 2015, at 12:48 PM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Am 10.12.2015 um 20:59 schrieb John McCall via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt; Also, are we allowed to *infer* structural sums?  For example, can we decide that the type of (x ? A() : B()) is A+B if that’s the greatest common type?  <br>&gt; <br>&gt; That’s what Ceylon does.<br>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151212/1895d4ed/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Proposal: An Either Type in the STL</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>December 13, 2015 at 09:00:00am</p></header><div class="content"><p>I don&#39;t expect interference to lead to bugs because everything is strongly typed and you would wonder when the compile or IDE tells you that your variable or function should have type Int | String.<br></p><p>But requiring the result type of a conditional to be explicitly typed I could live with if I just get union types :-)<br></p><p>-Thorsten<br></p><p>&gt; Am 12.12.2015 um 20:11 schrieb Matthew Johnson &lt;matthew at anandabits.com&gt;:<br>&gt; <br>&gt; I don’t have any experience working in a language with structural sum types but I think inference of structural sums in different branches of a conditional would lead to a lot of bugs and potential confusion.  Before considering support of such inference I would want to see pretty compelling evidence that it adds value and doesn’t lead to problems.<br>&gt; <br>&gt; In absence of allowing this inference, the structural sum could be specified manually if that is what is intended.<br>&gt; <br>&gt;&gt;&gt; On Dec 12, 2015, at 12:48 PM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am 10.12.2015 um 20:59 schrieb John McCall via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Also, are we allowed to *infer* structural sums?  For example, can we decide that the type of (x ? A() : B()) is A+B if that’s the greatest common type?  <br>&gt;&gt; <br>&gt;&gt; That’s what Ceylon does.<br>&gt;&gt; <br>&gt;&gt; -Thorsten<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151213/eeba9ef6/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: An Either Type in the STL</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 10, 2015 at 06:00:00pm</p></header><div class="content"><p>&gt; <br>&gt; Generics.<br>&gt; <br>&gt; Also, what are the proposed injection / projection / conversion rules for structural sums?  Implicit injection and dynamic cast, as if it were an existential type?<br></p><p>Thanks for pointing out the issues that need clarification.  It will give me some things to think about in the coming days.  <br></p><p>Can you elaborate on generics a bit?  Do you mean generic structural sum types, structural sum types with cases containing generic types, or both?<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Proposal: An Either Type in the STL</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>December 10, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; On Dec 10, 2015, at 4:19 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; Generics.<br>&gt;&gt; <br>&gt;&gt; Also, what are the proposed injection / projection / conversion rules for structural sums?  Implicit injection and dynamic cast, as if it were an existential type?<br>&gt; <br>&gt; Thanks for pointing out the issues that need clarification.  It will give me some things to think about in the coming days.  <br>&gt; <br>&gt; Can you elaborate on generics a bit?  Do you mean generic structural sum types, structural sum types with cases containing generic types, or both?  <br></p><p>Structural sum types containing dependent types.<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: An Either Type in the STL</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 10, 2015 at 07:00:00pm</p></header><div class="content"><p>&gt; Structural sum types containing dependent types.<br></p><p>Dependent in what sense?  Swift doesn&#39;t support anything like dependent types in the usual sense of being dependent on a value (modulo the pretty limited ability to abuse the type system).<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal: An Either Type in the STL</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 10, 2015 at 06:00:00pm</p></header><div class="content"><p>&gt; On Dec 10, 2015, at 5:59 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Structural sum types containing dependent types.<br>&gt; <br>&gt; Dependent in what sense?  Swift doesn&#39;t support anything like dependent types in the usual sense of being dependent on a value (modulo the pretty limited ability to abuse the type system).<br></p><p>I think John means &#39;dependent&#39; in the more prosaic C++ sense of &#39;dependent on generic type parameters&#39;, e.g. &#39;Array&lt;T&gt;&#39; inside a function generic on &lt;T&gt;, not dependent types in the Coq/Agda/Idris sense.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Proposal: An Either Type in the STL</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>December 10, 2015 at 06:00:00pm</p></header><div class="content"><p>&gt; On Dec 10, 2015, at 6:05 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; On Dec 10, 2015, at 5:59 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Structural sum types containing dependent types.<br>&gt;&gt; <br>&gt;&gt; Dependent in what sense?  Swift doesn&#39;t support anything like dependent types in the usual sense of being dependent on a value (modulo the pretty limited ability to abuse the type system).<br>&gt; <br>&gt; I think John means &#39;dependent&#39; in the more prosaic C++ sense of &#39;dependent on generic type parameters&#39;, e.g. &#39;Array&lt;T&gt;&#39; inside a function generic on &lt;T&gt;, not dependent types in the Coq/Agda/Idris sense.<br></p><p>Right, sorry; I’ve gotten too used to the C++ sense.  I mean types which contain free uses of the generic parameters of the context, which therefore appear to be opaque there.  It’s a problem for union typing because the intersection of any opaque types with the other concrete types in a union is not necessarily empty.  It’s not an unsolvable problem, of course.<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal: An Either Type in the STL</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 12, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 10, 2015, at 6:14 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Dec 10, 2015, at 6:05 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt; On Dec 10, 2015, at 5:59 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Structural sum types containing dependent types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Dependent in what sense?  Swift doesn&#39;t support anything like dependent types in the usual sense of being dependent on a value (modulo the pretty limited ability to abuse the type system).<br>&gt;&gt; <br>&gt;&gt; I think John means &#39;dependent&#39; in the more prosaic C++ sense of &#39;dependent on generic type parameters&#39;, e.g. &#39;Array&lt;T&gt;&#39; inside a function generic on &lt;T&gt;, not dependent types in the Coq/Agda/Idris sense.<br>&gt; <br>&gt; Right, sorry; I’ve gotten too used to the C++ sense.  I mean types which contain free uses of the generic parameters of the context, which therefore appear to be opaque there.  It’s a problem for union typing because the intersection of any opaque types with the other concrete types in a union is not necessarily empty.  It’s not an unsolvable problem, of course.<br></p><p>A structural sum type that was a disjoint sum and strictly ordered seems reasonably easy to support, if not perfectly ergonomic, and would handy if we ever get variadic generics, and better than the Either towers Haskellers construct for abstract anonymous sums. You could say that (T | U | V) behaves like an enum with cases .0(T), .1(U), .2(V); maybe you get implicit conversion in cases where the type-to-tag association is unambiguous. (T | T | U | V) and (U | T | V) would be distinct types, just like (T, U, V) and (U, T, V) are distinct product types.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: An Either Type in the STL</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 12, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; A structural sum type that was a disjoint sum and strictly ordered seems reasonably easy to support, if not perfectly ergonomic, and would handy if we ever get variadic generics, and better than the Either towers Haskellers construct for abstract anonymous sums. You could say that (T | U | V) behaves like an enum with cases .0(T), .1(U), .2(V); maybe you get implicit conversion in cases where the type-to-tag association is unambiguous. (T | T | U | V) and (U | T | V) would be distinct types, just like (T, U, V) and (U, T, V) are distinct product types.<br>&gt; <br></p><p>Did you mean &quot;(T | U | V) and (U | T | V) would be distinct types, just like (T, U, V) and (U, T, V) are distinct product types.&quot;?<br></p><p>In the typed throws with multiple error types use case I think most developers would intuitively expect all permutations of error types to mean the same thing:<br>()-&gt;() throws T, U, V<br>()-&gt;() throws U, T, V<br>etc<br></p><p>I haven&#39;t given a lot of thought to other use cases but I my instinct is that the same intuition would apply.  I&#39;m not sure that order provides a meaningful distinction for structural sum types.  I would like to learn about any use cases where the distinction would be meaningful if anyone knows of any.<br></p><p>If order doesn&#39;t provide a useful and meaningful distinction or if it contradicts intuition in the most prevalent and compelling use cases maybe syntactic permutations should be irrelevant.  A projection of syntax to a canonical order could be performed such that (U | T | V) is projected to (T | U | V) and the type system never encounters any of the other permutations.  <br></p><p>If we do this we probably don&#39;t want to expose cases of .0(T), etc as the canonical order be an implementation detail.  The constituent types of the union type would naturally be subtypes of the union type so dynamic cast could be used for projection instead. <br></p><p>Matthew<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal: An Either Type in the STL</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 12, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; On Dec 12, 2015, at 10:58 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; A structural sum type that was a disjoint sum and strictly ordered seems reasonably easy to support, if not perfectly ergonomic, and would handy if we ever get variadic generics, and better than the Either towers Haskellers construct for abstract anonymous sums. You could say that (T | U | V) behaves like an enum with cases .0(T), .1(U), .2(V); maybe you get implicit conversion in cases where the type-to-tag association is unambiguous. (T | T | U | V) and (U | T | V) would be distinct types, just like (T, U, V) and (U, T, V) are distinct product types.<br>&gt;&gt; <br>&gt; <br>&gt; Did you mean &quot;(T | U | V) and (U | T | V) would be distinct types, just like (T, U, V) and (U, T, V) are distinct product types.&quot;?<br></p><p>I meant that T | U | V, T | T | U | V, and U | T | V are all different.<br></p><p>&gt; In the typed throws with multiple error types use case I think most developers would intuitively expect all permutations of error types to mean the same thing:<br>&gt; ()-&gt;() throws T, U, V<br>&gt; ()-&gt;() throws U, T, V<br>&gt; etc<br>&gt; <br>&gt; I haven&#39;t given a lot of thought to other use cases but I my instinct is that the same intuition would apply.  I&#39;m not sure that order provides a meaningful distinction for structural sum types.  I would like to learn about any use cases where the distinction would be meaningful if anyone knows of any.<br>&gt; <br>&gt; If order doesn&#39;t provide a useful and meaningful distinction or if it contradicts intuition in the most prevalent and compelling use cases maybe syntactic permutations should be irrelevant.  A projection of syntax to a canonical order could be performed such that (U | T | V) is projected to (T | U | V) and the type system never encounters any of the other permutations.  <br>&gt; <br>&gt; If we do this we probably don&#39;t want to expose cases of .0(T), etc as the canonical order be an implementation detail.  The constituent types of the union type would naturally be subtypes of the union type so dynamic cast could be used for projection instead. <br></p><p>Order invariance is manageable. There are reasons *not* to coalesce equivalent effects, depending on the type system model. For reference, Koka doesn&#39;t attempt to coalesce equivalent effects, both because it would complicate the type system, and because it makes operations like &#39;catch&#39; easier to type:<br></p><p>http://research.microsoft.com/pubs/210640/paper.pdf<br></p><p>Our effect rows differ in an important way from the usual approaches in that effect labels can be dupli- cated, i.e. ⟨exn, exn⟩ ̸≡ ⟨exn⟩ (1). This was first described by Leijen [17] where this was used to enable scoped labels in record types. Enabling duplicate labels fits our approach well: first of all, it enables principal unification without needing extra constraints, and secondly, it enables us to give precise types to effect elimination forms (like catching exceptions).<br></p><p>In particular, during unification we may end up with constraints of the form ⟨exn|μ⟩ ∼ ⟨exn⟩. With regular row-polymorphism which are sets of labels, such constraint can have multiple solutions, namely μ = ⟨⟩ or μ = ⟨exn⟩. This was first observed by Wand [43] in the context of records. Usually, this problem is fixed by either introducing lacks constraints [7] or polymorphic presence and absence flags on each label [32] (as used by Lindley and Cheney [23] for an effect system in the context of database queries). The problem with both approaches is that they complicate the type system quite a bit. With lacks contstraints we need a system of qualified types as in Haskell, while with presece and absence flags, we need a kind system that tracks for each type variable which labels cannot be present.<br></p><p>With rows allowing duplicate labels, we avoid any additional machinery and can use straight forward type inference techniques. In our case μ = ⟨⟩ is the only solution to the above constraint (due to (1)).<br></p><p>Moreover, duplicate labels make it easy to give types to effect elimination forms. For example, catching effects removes the exn effect:<br></p><p>catch : ∀αμ.(()→⟨exn|μ⟩α, exception→μ α)→μ α<br></p><p>Here we assume that catch takes two functions, the action and the exception handler that takes as an argument the thrown exception. The exn effect of the action is discarded in the final effect μ since all exceptions are caught by the handler. But of course, the handler can itself throw an exception and have an exn effect itself. In that case μ will unify with a type of the form ⟨exn|μ′⟩ giving action the effect ⟨exn|exn|μ′⟩ where exn occurs duplicated, which gives us exactly the right behavior. Note that withlacks constraints we would not be able to type this example because there would be a exn ̸∈ μ constraint. We can type this example using flags but the type would arguably be more complex with a polymorphic presence/absence flag φ on the exn label in the result effect, something like:<br></p><p>catch : ∀μαφ. (() → ⟨exn•| μ⟩ α, exception → ⟨exnφ | μ⟩ α) → ⟨exnφ | μ⟩ α<br></p><p>There is one situation where an approach with flags is more expressive though: with flags one can state specifically that a certain effect must be absent. This is used for example in the effect system by Lindley and Cheney [23] to enforce that database queries never have the wild effect (io). In our setting we can only enforce absence of an effect by explicitly listing a closed row of the allowed effects which is less modular. In our current experience this has not yet proven to be a problem in practice though but we may experiment with this in the future. <br></p><p><br>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151212/89b8d7a7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: An Either Type in the STL</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 12, 2015 at 02:00:00pm</p></header><div class="content"><p>Very interesting reading, thanks Joe.  I have stumbled across Koka in the past when reading about effect systems and thought it looked like a really strong approach with many advantages.<br></p><p>I&#39;m wondering how a couple of examples would behave under this approach.<br></p><p>If we have the following:<br>func foo( bar: ()-&gt;() throws T, U)<br>func baz() throws U, T<br>foo(baz)<br></p><p>Is the last statement valid?  It seems like the permutation would cause an unintuitive and problematic compiler error but maybe it is resolved somehow?<br></p><p>Also consider the following:<br></p><p>enum T: ErrorType { case A, case B }<br>enum U: ErrorType { case C }<br>func foo() throws T, U, T<br></p><p>do {<br>   Try foo()<br>} catch U.C {<br>} catch T.A {<br>} catch T.B {<br>}<br></p><p>Have we exhaustively handled all errors even though T appears twice in the type of foo and the catch clauses are not in the same order as T, U, T in the type of foo?  I don&#39;t think anyone would declare a foo like this, but maybe a function could end up with a type like this by rethrowing, etc.<br></p><p>Matthew<br></p><p>Sent from my iPad<br></p><p>&gt; On Dec 12, 2015, at 1:36 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Dec 12, 2015, at 10:58 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A structural sum type that was a disjoint sum and strictly ordered seems reasonably easy to support, if not perfectly ergonomic, and would handy if we ever get variadic generics, and better than the Either towers Haskellers construct for abstract anonymous sums. You could say that (T | U | V) behaves like an enum with cases .0(T), .1(U), .2(V); maybe you get implicit conversion in cases where the type-to-tag association is unambiguous. (T | T | U | V) and (U | T | V) would be distinct types, just like (T, U, V) and (U, T, V) are distinct product types.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Did you mean &quot;(T | U | V) and (U | T | V) would be distinct types, just like (T, U, V) and (U, T, V) are distinct product types.&quot;?<br>&gt; <br>&gt; I meant that T | U | V, T | T | U | V, and U | T | V are all different.<br>&gt; <br>&gt;&gt; In the typed throws with multiple error types use case I think most developers would intuitively expect all permutations of error types to mean the same thing:<br>&gt;&gt; ()-&gt;() throws T, U, V<br>&gt;&gt; ()-&gt;() throws U, T, V<br>&gt;&gt; etc<br>&gt;&gt; <br>&gt;&gt; I haven&#39;t given a lot of thought to other use cases but I my instinct is that the same intuition would apply.  I&#39;m not sure that order provides a meaningful distinction for structural sum types.  I would like to learn about any use cases where the distinction would be meaningful if anyone knows of any.<br>&gt;&gt; <br>&gt;&gt; If order doesn&#39;t provide a useful and meaningful distinction or if it contradicts intuition in the most prevalent and compelling use cases maybe syntactic permutations should be irrelevant.  A projection of syntax to a canonical order could be performed such that (U | T | V) is projected to (T | U | V) and the type system never encounters any of the other permutations.  <br>&gt;&gt; <br>&gt;&gt; If we do this we probably don&#39;t want to expose cases of .0(T), etc as the canonical order be an implementation detail.  The constituent types of the union type would naturally be subtypes of the union type so dynamic cast could be used for projection instead. <br>&gt; <br>&gt; Order invariance is manageable. There are reasons *not* to coalesce equivalent effects, depending on the type system model. For reference, Koka doesn&#39;t attempt to coalesce equivalent effects, both because it would complicate the type system, and because it makes operations like &#39;catch&#39; easier to type:<br>&gt; <br>&gt; http://research.microsoft.com/pubs/210640/paper.pdf<br>&gt; <br>&gt; Our effect rows differ in an important way from the usual approaches in that effect labels can be dupli- cated, i.e. ⟨exn, exn⟩ ̸≡ ⟨exn⟩ (1). This was first described by Leijen [17] where this was used to enable scoped labels in record types. Enabling duplicate labels fits our approach well: first of all, it enables principal unification without needing extra constraints, and secondly, it enables us to give precise types to effect elimination forms (like catching exceptions).<br>&gt; <br>&gt; In particular, during unification we may end up with constraints of the form ⟨exn|μ⟩ ∼ ⟨exn⟩. With regular row-polymorphism which are sets of labels, such constraint can have multiple solutions, namely μ = ⟨⟩ or μ = ⟨exn⟩. This was first observed by Wand [43] in the context of records. Usually, this problem is fixed by either introducing lacks constraints [7] or polymorphic presence and absence flags on each label [32] (as used by Lindley and Cheney [23] for an effect system in the context of database queries). The problem with both approaches is that they complicate the type system quite a bit. With lacks contstraints we need a system of qualified types as in Haskell, while with presece and absence flags, we need a kind system that tracks for each type variable which labels cannot be present.<br>&gt; <br>&gt; With rows allowing duplicate labels, we avoid any additional machinery and can use straight forward type inference techniques. In our case μ = ⟨⟩ is the only solution to the above constraint (due to (1)).<br>&gt; <br>&gt; Moreover, duplicate labels make it easy to give types to effect elimination forms. For example, catching effects removes the exn effect:<br>&gt; <br>&gt; catch : ∀αμ.(()→⟨exn|μ⟩α, exception→μ α)→μ α<br>&gt; <br>&gt; Here we assume that catch takes two functions, the action and the exception handler that takes as an argument the thrown exception. The exn effect of the action is discarded in the final effect μ since all exceptions are caught by the handler. But of course, the handler can itself throw an exception and have an exn effect itself. In that case μ will unify with a type of the form ⟨exn|μ′⟩ giving action the effect ⟨exn|exn|μ′⟩ where exn occurs duplicated, which gives us exactly the right behavior. Note that withlacks constraints we would not be able to type this example because there would be a exn ̸∈ μ constraint. We can type this example using flags but the type would arguably be more complex with a polymorphic presence/absence flag φ on the exn label in the result effect, something like:<br>&gt; <br>&gt; catch : ∀μαφ. (() → ⟨exn•| μ⟩ α, exception → ⟨exnφ | μ⟩ α) → ⟨exnφ | μ⟩ α<br>&gt; <br>&gt; There is one situation where an approach with flags is more expressive though: with flags one can state specifically that a certain effect must be absent. This is used for example in the effect system by Lindley and Cheney [23] to enforce that database queries never have the wild effect (io). In our setting we can only enforce absence of an effect by explicitly listing a closed row of the allowed effects which is less modular. In our current experience this has not yet proven to be a problem in practice though but we may experiment with this in the future. <br>&gt; <br>&gt; <br>&gt; -Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151212/67a833f9/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Proposal: An Either Type in the STL</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>December 12, 2015 at 07:00:00pm</p></header><div class="content"><p>&gt; Am 12.12.2015 um 19:01 schrieb Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; (T | T | U | V) and (U | T | V) would be distinct types<br></p><p>That would be unexpected. I’d expect them to be the same type.<br></p><p>In Ceylon I can do the following without problems:<br>String|String|Integer foo = 1;<br>Integer|String bar = foo;<br>or<br>interface Parent {}<br>interface ChildA satisfies Parent {}<br>interface ChildB satisfies Parent {}<br>ChildA a = childA();<br>ChildB b = childB();<br>Parent p1 = a;<br>ChildA|Parent p2 = b;<br>Parent p3 = if (x) then a else b;<br>Everything fits nicely as expected.<br></p><p>-Thorsten<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151212/07a7dada/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal: An Either Type in the STL</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 12, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; On Dec 12, 2015, at 10:58 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Am 12.12.2015 um 19:01 schrieb Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt; (T | T | U | V) and (U | T | V) would be distinct types<br>&gt; <br>&gt; That would be unexpected. I’d expect them to be the same type.<br>&gt; <br>&gt; In Ceylon I can do the following without problems:<br>&gt; String|String|Integer foo = 1;<br>&gt; Integer|String bar = foo;<br>&gt; or<br>&gt; interface Parent {}<br>&gt; interface ChildA satisfies Parent {}<br>&gt; interface ChildB satisfies Parent {}<br>&gt; ChildA a = childA();<br>&gt; ChildB b = childB();<br>&gt; Parent p1 = a;<br>&gt; ChildA|Parent p2 = b;<br>&gt; Parent p3 = if (x) then a else b;<br>&gt; Everything fits nicely as expected.<br></p><p>I agree, but making this work massively complicates the type system, as John noted.<br></p><p>-Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151212/a34d93ce/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Proposal: An Either Type in the STL</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>December 13, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; Am 12.12.2015 um 20:08 schrieb Joe Groff &lt;jgroff at apple.com&gt;:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Dec 12, 2015, at 10:58 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am 12.12.2015 um 19:01 schrieb Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (T | T | U | V) and (U | T | V) would be distinct types<br>&gt;&gt; <br>&gt;&gt; That would be unexpected. I’d expect them to be the same type.<br>&gt;&gt; <br>&gt;&gt; In Ceylon I can do the following without problems:<br>&gt;&gt; String|String|Integer foo = 1;<br>&gt;&gt; Integer|String bar = foo;<br>&gt;&gt; or<br>&gt;&gt; interface Parent {}<br>&gt;&gt; interface ChildA satisfies Parent {}<br>&gt;&gt; interface ChildB satisfies Parent {}<br>&gt;&gt; ChildA a = childA();<br>&gt;&gt; ChildB b = childB();<br>&gt;&gt; Parent p1 = a;<br>&gt;&gt; ChildA|Parent p2 = b;<br>&gt;&gt; Parent p3 = if (x) then a else b;<br>&gt;&gt; Everything fits nicely as expected.<br>&gt; <br>&gt; I agree, but making this work massively complicates the type system, as John noted.<br></p><p>Certainly, but at the same time much more powerful!<br></p><p>And the Ceylon type system has recently been made available as a module with Apache 2 license, so it should be possible to check how they have solved problems (although I fear that Swift&#39;s non attribution license extension might be a problem here).<br></p><p>-Thorsten<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151213/78bab9bc/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Proposal: An Either Type in the STL</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>December 14, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 12, 2015, at 10:01 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; On Dec 10, 2015, at 6:14 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 10, 2015, at 6:05 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; On Dec 10, 2015, at 5:59 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Structural sum types containing dependent types.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Dependent in what sense?  Swift doesn&#39;t support anything like dependent types in the usual sense of being dependent on a value (modulo the pretty limited ability to abuse the type system).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think John means &#39;dependent&#39; in the more prosaic C++ sense of &#39;dependent on generic type parameters&#39;, e.g. &#39;Array&lt;T&gt;&#39; inside a function generic on &lt;T&gt;, not dependent types in the Coq/Agda/Idris sense.<br>&gt;&gt; <br>&gt;&gt; Right, sorry; I’ve gotten too used to the C++ sense.  I mean types which contain free uses of the generic parameters of the context, which therefore appear to be opaque there.  It’s a problem for union typing because the intersection of any opaque types with the other concrete types in a union is not necessarily empty.  It’s not an unsolvable problem, of course.<br>&gt; <br>&gt; A structural sum type that was a disjoint sum and strictly ordered seems reasonably easy to support, if not perfectly ergonomic, and would handy if we ever get variadic generics, and better than the Either towers Haskellers construct for abstract anonymous sums. You could say that (T | U | V) behaves like an enum with cases .0(T), .1(U), .2(V); maybe you get implicit conversion in cases where the type-to-tag association is unambiguous. (T | T | U | V) and (U | T | V) would be distinct types, just like (T, U, V) and (U, T, V) are distinct product types.<br></p><p>That is easy to support, but it is completely different from what Ceylon supports, which is true structural union-typing, including implicit injection and union-lookup.  Although they seem to structurally demand disjointness for some reason that escapes me; avoidance of programmer confusion, perhaps?<br></p><p>Ceylon is, of course, a JVM language, which means it is just providing additional type accuracy over java.lang.Object.  To support their model reasonably, we would have to use a representation closer to Any.<br></p><p>Anyway, proposals to add new kinds of structural types will require a lot more motivation than I’m seeing here.<br></p><p>John.<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Proposal: An Either Type in the STL</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>December 12, 2015 at 07:00:00pm</p></header><div class="content"><p>&gt; Am 11.12.2015 um 03:14 schrieb John McCall via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Right, sorry; I’ve gotten too used to the C++ sense.  I mean types which contain free uses of the generic parameters of the context, which therefore appear to be opaque there.  It’s a problem for union typing because the intersection of any opaque types with the other concrete types in a union is not necessarily empty.  It’s not an unsolvable problem, of course.<br></p><p>Do you mean something along these lines (taken from Ceylon)?<br></p><p> interface Set&lt;These&gt; {<br>	shared formal Set&lt;These | Those&gt; union&lt;Those&gt;(Set&lt;Those&gt; set);<br>	shared formal Set&lt;These &amp; Those&gt; intersection&lt;Those&gt;(Set&lt;Those&gt; set);<br>}<br></p><p>Set&lt;Foo&gt; setOfFoo = ... ;<br>Set&lt;Bar&gt; setOfBar = ... ;<br></p><p>Set&lt;Foo | Bar&gt; setUnion = setOfFoo.union(setOfBar); // each element conforms to Foo or Bar<br>Set&lt;Foo &amp; Bar&gt; setIntersection = setOfFoo.intersection(setOfBar); // each element conforms to Foo and Bar<br></p><p>Types like (Int | Int) reduce to Int, of course, etc.<br></p><p>-Thorsten<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151212/01f0b9f8/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: An Either Type in the STL</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 10, 2015 at 09:00:00pm</p></header><div class="content"><p>&gt; <br>&gt; I think John means &#39;dependent&#39; in the more prosaic C++ sense of &#39;dependent on generic type parameters&#39;, e.g. &#39;Array&lt;T&gt;&#39; inside a function generic on &lt;T&gt;, not dependent types in the Coq/Agda/Idris sense.<br></p><p>Thanks for the clarification. Makes sense now.<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>Proposal: An Either Type in the STL</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>December 10, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; On Dec 10, 2015, at 12:38 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 10, 2015, at 10:34 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; As an alternative to a semantically-neutral Either type, it might be worth considering the possibility of anonymous structural sum types (similar to how tuples are the structural analog of structs).<br>&gt;&gt; <br>&gt;&gt; John mentioned that these are a massive complication for type systems when I proposed them as a possible way to implement throwing multiple error types.  Do you agree with that?<br>&gt; <br>&gt; There are definitely problems if you expect them to behave like unions (so that the type `T + T` == `T`) or be unordered (so that `T + U` == `U + T`), which would be intuitively expected.<br></p><p>FWIW I like the idea of e.g. &quot;structural sum types” in the language, but if e.g. Swift 3 allows this kind of thing:<br></p><p>extension Foo: Baz where Foo.Bar: Baz {<br>}<br></p><p>…it is then possible to write sufficiently-useful, adequately-general Sum2, Sum3, etc., types without further language-level support (yes it’s tedious but it’s also a one-off cost).<br></p><p>Given that, language-level support would then seem justified only if there&#39;s a very strong sentiment that such types are, say, the right way to design APIs in Swift (which I don’t agree with, and doesn’t seem to to be the community feeling right now, either).<br></p><p>Also FWIW explicit or implicit “proper” unions feel like something I’d be willing to deal with but wouldn’t want to use when at all avoidable.<br></p><p>&gt; -Joe<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d933552ea7fda10a4488a74223c00988?s=50"></div><header><strong>Proposal: An Either Type in the STL</strong> from <string>Thorsten Seitz</string> &lt;thorsten.seitz at web.de&gt;<p>December 10, 2015 at 08:00:00pm</p></header><div class="content"><p>Ceylon has lots of experience with a type system built around union and intersection types. Their type checker has been factored into a module, so you could check that out for ideas how they solved these problems (Apache 2.0 license).<br></p><p>http://ceylon-lang.org/blog/2015/07/04/model/<br></p><p>-Thorsten<br></p><p><br>&gt; Am 10.12.2015 um 19:34 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt;&gt; As an alternative to a semantically-neutral Either type, it might be worth considering the possibility of anonymous structural sum types (similar to how tuples are the structural analog of structs).<br>&gt; <br>&gt; John mentioned that these are a massive complication for type systems when I proposed them as a possible way to implement throwing multiple error types.  Do you agree with that?<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 10, 2015, at 10:06 AM, Nick Shelley via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Can you explain why you think it&#39;s better to just define your own two-variant enum rather than having a built-in Either type, or point me to the evidence that Rust found in favor of this approach?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I had to create my own Either type for some code I wrote semi-recently and wished it was built in, so I&#39;m wondering why I apparently shouldn&#39;t have wished that, but been glad that I&#39;m creating my own.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Thu, Dec 10, 2015 at 1:34 AM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; I support the addition of a Result, and I encourage people to look at https://doc.rust-lang.org/stable/std/result/index.html &lt;https://doc.rust-lang.org/stable/std/result/index.html&gt; for a good example of how this can be done well. I&#39;d like a Result&lt;T,E&gt; in Swift that looks similar.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; I do not support the addition of Either. As far as I am aware, the only compelling argument in favor of an Either type is &quot;because Haskell has one&quot;, but I believe it&#39;s commonly recognized that Haskell&#39;s Either is not particularly good. It&#39;s a weird name for results (which Result covers), and for other cases it&#39;s usually better just to define your own two-variant enum anyway. Rust provides some evidence in favor of this, as this was the rationale for why Rust has a Result&lt;T,E&gt; but no Either, and it turns out there has been no need to add an Either.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; On Wed, Dec 9, 2015, at 04:01 PM, T.J. Usiyan via swift-evolution wrote:<br>&gt;&gt;&gt;&gt; I hope that we can get both Either and Result into the standard lib. A great situation might be if Result were some sort of newtype declaration of Either.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; On Thu, Dec 10, 2015 at 5:25 AM, Developer via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; There is!  That’s what the Bifunctor typeclass is for.  But if you had to pick just one of them to implement some Functor constraint - some canonical `map` function, would you pick the side that you filled with Errors, or the side that you filled with Values?<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; On Dec 9, 2015, at 6:52 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; Is there not precedent for having both &quot;mapLeft&lt;T&gt;(f: L -&gt; T) -&gt; Either&lt;T, R&gt;&quot; and &quot;mapRight&lt;T&gt;(f: R -&gt; T) -&gt; Either&lt;L, T&gt;&quot; ?<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; Jacob Bandes-Storch<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; On Wed, Dec 9, 2015 at 3:49 PM, Developer &lt;devteam.codafi at gmail.com &lt;mailto:devteam.codafi at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; How would you write `map` for an unbiased Either.  You have to pick a side!<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; Our implementation happens to be the one standardized on by Scala, Haskell, ML, (and to a limited extent) F#.  For a less arbitrary reason, the use of &quot;Right as Correct&quot; is because Either, in all it’s Bifunctor-ial ways, has to admit two ways to map “across” itself.  To paraphrase the words of a friend &quot;There are lots of things in computer science we can leftMap”.  In Haskell, such a thing is represented by the Functor typeclass, and due to the way type application works in that language, the convention has been to map over the rightmost side.  But this isn’t Haskell, so our reasons can get even more theoretical than that (if you really want to get into what it looks like when you implement Covariant mapping down the left side of a common Bifunctor like Either, Cats has already had a thorough discussion on the subject: https://github.com/non/cats/issues/189 &lt;https://github.com/non/cats/issues/189&gt;).<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 9, 2015, at 6:44 PM, Ilias Karim &lt;ilias.karim at gmail.com &lt;mailto:ilias.karim at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; I’m sorry, I misunderstood. I guess an enum would be the appropriate choice, instead.<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; As far as left/right goes, the decision to have left or right be the “correct” value is entirely arbitrary and should be left up to the developer. It should be a convention at best.<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; Ilias<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 9, 2015, at 3:43 PM, Dave DeLong &lt;delong at apple.com &lt;mailto:delong at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; With a tuple, you have to do “(left: T?, right: U?)”, whereas with an Either you are guaranteed to always have one or other other; never both and never neither. That is not guaranteed with the tuple.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Dave<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 9, 2015, at 4:41 PM, Ilias Karim via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; What are the advantage over using a tuple? One great feature about tuples is being able to name parameters so you can dispel ambiguity.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 9, 2015, at 3:35 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The idea of using Left/Right is to remain agnostic to what sorts of things users might want to put in. It&#39;s feasible a user might want Either&lt;Int, String&gt;, not just Either&lt;ErrorType, T&gt;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; While I&#39;m not sure Left &amp; Right are the best choices, I don&#39;t think it&#39;s particularly worrisome when it comes to errors, as the general type-safety of the language will prevent users from mixing up success &amp; error cases.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jacob<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Dec 9, 2015 at 3:32 PM, Ilias Karim via swift-evolution&lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hi Robert,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I agree with your recommendation of a generic Either type.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; However, I find your use of “Right” as the “Correct” value (whatever that means) of an instance of an Either type a little perplexing. While clever, it is exactly the kind of convention that easily leads to misunderstandings about the nature of the type itself ie. is it right and left or wrong and correct? At least that is my first impression after scanning your code.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Ilias<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; On Dec 9, 2015, at 3:06 PM, Developer via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; It’s high time the STL admitted some kind of disjoint union type, at the very least because it’s such a minor addition it seems a shame to leave it out.  Whatever feelings one may have about `throws`, the lack of standardizing on a datatype representing choice has caused the community to get creative and create many disjoint implementation of the same concept over and over and over again.  To that end, I propose the STL ship with an Either type; We at TypeLift have already got our own we’d like to model it on (https://github.com/typelift/Swiftx/blob/master/Swiftx/Either.swift#L16 &lt;https://github.com/typelift/Swiftx/blob/master/Swiftx/Either.swift#L16&gt;).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; ~Robert Widmann (CodaFi)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/784eb47e/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: An Either Type in the STL</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 10, 2015 at 11:00:00am</p></header><div class="content"><p>On Thu, Dec 10, 2015, at 10:06 AM, Nick Shelley wrote:<br>&gt; Can you explain why you think it&#39;s better to just define your own two-<br>&gt; variant enum rather than having a built-in Either type, or point me to<br>&gt; the evidence that Rust found in favor of this approach?<br>&gt;<br>&gt; I had to create my own Either type for some code I wrote semi-recently<br>&gt; and wished it was built in, so I&#39;m wondering why I apparently<br>&gt; shouldn&#39;t have wished that, but been glad that I&#39;m creating my own.<br></p><p>The simplest argument is that the name Either (and variants Left and<br>Right) are so generic as to be meaningless, and there&#39;s no good<br>alternatives that are any better. By defining your own enum, you get to<br>name the enum and its variants (and document them) in a way that&#39;s<br>actually meaningful.<br></p><p>If you want to use the Either type in a context that actually is pretty<br>generic (such that you can&#39;t come up with other names that are<br>particularly meaningful), which I&#39;d suggest is pretty rare (nothing<br>immediately comes to mind that is really this generic), by using the stdlib-<br>provided Either type you&#39;re also restricting yourself to only ever<br>having 2 variants. If you find a need for a 3rd variant later (for<br>example, if you have a function that takes two values and it returns one<br>of them, and you later realize you want an overload that takes 3<br>values), then you can&#39;t add it to Either and have to create your own<br>enum anyway. By starting off with your own enum you make it a lot easier<br>to update code for the 3rd variant (only exhaustive switches are forced<br>to change, everything else is source-compatible).<br></p><p>Ultimately, given how trivial it is to define a new enum, there&#39;s just<br>no real compelling reason to have a stdlib-defined Either. The best<br>argument I can come up with in favor of using Either instead of your own<br>enum is that the stdlib may have already defined methods like mapLeft()<br>and mapRight() on Either, but I don&#39;t find that to be a very good<br>reason. In most cases those methods are not particularly helpful.<br></p><p>Also, in my personal experience, in what (admittedly small) amount of<br>Haskell code I&#39;ve seen, every single instance of Either was being used<br>for error handling, and Result already handles that job. Every other<br>case of a two-variant data I&#39;ve seen in Haskell that wasn&#39;t error<br>handling, it was a custom data instead of Either. And as I already<br>stated, Rust made the decision here to have Result and nothing else, and<br>there&#39;s been no push to add an Either type to the stdlib (I don&#39;t think<br>I&#39;ve even seen it so much as suggested ever since Result was added,<br>although I haven&#39;t been paying as much attention to Rust since 1.0 came<br>out so I can&#39;t say that definitively).<br></p><p>-Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/fe23b3fc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d5ada5f318f38f99b9d0a5d88284743a?s=50"></div><header><strong>Proposal: An Either Type in the STL</strong> from <string>Nick Shelley</string> &lt;nickmshelley at gmail.com&gt;<p>December 10, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt;<br>&gt; The simplest argument is that the name Either (and variants Left and<br>&gt; Right) are so generic as to be meaningless, and there&#39;s no good<br>&gt; alternatives that are any better. By defining your own enum, you get to<br>&gt; name the enum and its variants (and document them) in a way that&#39;s actually<br>&gt; meaningful.<br>&gt;<br>&gt; If you want to use the Either type in a context that actually is pretty<br>&gt; generic (such that you can&#39;t come up with other names that are particularly<br>&gt; meaningful), which I&#39;d suggest is pretty rare (nothing immediately comes to<br>&gt; mind that is really this generic), by using the stdlib-provided Either type<br>&gt; you&#39;re also restricting yourself to only ever having 2 variants. If you<br>&gt; find a need for a 3rd variant later (for example, if you have a function<br>&gt; that takes two values and it returns one of them, and you later realize you<br>&gt; want an overload that takes 3 values), then you can&#39;t add it to Either and<br>&gt; have to create your own enum anyway. By starting off with your own enum you<br>&gt; make it a lot easier to update code for the 3rd variant (only exhaustive<br>&gt; switches are forced to change, everything else is source-compatible).<br>&gt;<br>&gt; Ultimately, given how trivial it is to define a new enum, there&#39;s just no<br>&gt; real compelling reason to have a stdlib-defined Either. The best argument I<br>&gt; can come up with in favor of using Either instead of your own enum is that<br>&gt; the stdlib may have already defined methods like mapLeft() and mapRight()<br>&gt; on Either, but I don&#39;t find that to be a very good reason. In most cases<br>&gt; those methods are not particularly helpful.<br>&gt;<br>&gt; Also, in my personal experience, in what (admittedly small) amount of<br>&gt; Haskell code I&#39;ve seen, every single instance of Either was being used for<br>&gt; error handling, and Result already handles that job. Every other case of a<br>&gt; two-variant data I&#39;ve seen in Haskell that wasn&#39;t error handling, it was a<br>&gt; custom data instead of Either. And as I already stated, Rust made the<br>&gt; decision here to have Result and nothing else, and there&#39;s been no push to<br>&gt; add an Either type to the stdlib (I don&#39;t think I&#39;ve even seen it so much<br>&gt; as suggested ever since Result was added, although I haven&#39;t been paying as<br>&gt; much attention to Rust since 1.0 came out so I can&#39;t say that definitively).<br></p><p><br>Thanks for explaining your reasoning, Kevin.<br></p><p>On Thu, Dec 10, 2015 at 12:25 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br></p><p>&gt; On Thu, Dec 10, 2015, at 10:06 AM, Nick Shelley wrote:<br>&gt;<br>&gt; Can you explain why you think it&#39;s better to just define your own<br>&gt; two-variant enum rather than having a built-in Either type, or point me to<br>&gt; the evidence that Rust found in favor of this approach?<br>&gt;<br>&gt; I had to create my own Either type for some code I wrote semi-recently and<br>&gt; wished it was built in, so I&#39;m wondering why I apparently shouldn&#39;t have<br>&gt; wished that, but been glad that I&#39;m creating my own.<br>&gt;<br>&gt;<br>&gt; The simplest argument is that the name Either (and variants Left and<br>&gt; Right) are so generic as to be meaningless, and there&#39;s no good<br>&gt; alternatives that are any better. By defining your own enum, you get to<br>&gt; name the enum and its variants (and document them) in a way that&#39;s actually<br>&gt; meaningful.<br>&gt;<br>&gt; If you want to use the Either type in a context that actually is pretty<br>&gt; generic (such that you can&#39;t come up with other names that are particularly<br>&gt; meaningful), which I&#39;d suggest is pretty rare (nothing immediately comes to<br>&gt; mind that is really this generic), by using the stdlib-provided Either type<br>&gt; you&#39;re also restricting yourself to only ever having 2 variants. If you<br>&gt; find a need for a 3rd variant later (for example, if you have a function<br>&gt; that takes two values and it returns one of them, and you later realize you<br>&gt; want an overload that takes 3 values), then you can&#39;t add it to Either and<br>&gt; have to create your own enum anyway. By starting off with your own enum you<br>&gt; make it a lot easier to update code for the 3rd variant (only exhaustive<br>&gt; switches are forced to change, everything else is source-compatible).<br>&gt;<br>&gt; Ultimately, given how trivial it is to define a new enum, there&#39;s just no<br>&gt; real compelling reason to have a stdlib-defined Either. The best argument I<br>&gt; can come up with in favor of using Either instead of your own enum is that<br>&gt; the stdlib may have already defined methods like mapLeft() and mapRight()<br>&gt; on Either, but I don&#39;t find that to be a very good reason. In most cases<br>&gt; those methods are not particularly helpful.<br>&gt;<br>&gt; Also, in my personal experience, in what (admittedly small) amount of<br>&gt; Haskell code I&#39;ve seen, every single instance of Either was being used for<br>&gt; error handling, and Result already handles that job. Every other case of a<br>&gt; two-variant data I&#39;ve seen in Haskell that wasn&#39;t error handling, it was a<br>&gt; custom data instead of Either. And as I already stated, Rust made the<br>&gt; decision here to have Result and nothing else, and there&#39;s been no push to<br>&gt; add an Either type to the stdlib (I don&#39;t think I&#39;ve even seen it so much<br>&gt; as suggested ever since Result was added, although I haven&#39;t been paying as<br>&gt; much attention to Rust since 1.0 came out so I can&#39;t say that definitively).<br>&gt;<br>&gt; -Kevin Ballard<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/86a91b66/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7abf2ce34651dd5e97cd97b16ce21bae?s=50"></div><header><strong>Proposal: An Either Type in the STL</strong> from <string>Guillaume Lessard</string> &lt;glessard at tffenterprises.com&gt;<p>December  9, 2015 at 04:00:00pm</p></header><div class="content"><p>There is probably a greater need for a non-agnostic Result monad type (with descriptive cases .Value and .Error) for manual error propagation. If it’s not agnostic then the happy and unhappy paths can be better optimized.<br></p><p>Such a type was proposed but not designed in &lt;https://github.com/apple/swift/blob/master/docs/ErrorHandling.rst#manual-propagation-and-manipulation-of-errors&gt;. Was it abandoned or simply left for later?<br>(There are several implementations available on github, heh)<br></p><p>Guillaume Lessard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Proposal: An Either Type in the STL</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>December  9, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; On Dec 9, 2015, at 3:45 PM, Guillaume Lessard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; There is probably a greater need for a non-agnostic Result monad type (with descriptive cases .Value and .Error) for manual error propagation. If it’s not agnostic then the happy and unhappy paths can be better optimized.<br>&gt; <br>&gt; Such a type was proposed but not designed in &lt;https://github.com/apple/swift/blob/master/docs/ErrorHandling.rst#manual-propagation-and-manipulation-of-errors&gt;. Was it abandoned or simply left for later?<br>&gt; (There are several implementations available on github, heh)<br></p><p>We considered it, had some specifics worked out, and then decided to put it on hold.  Part of our reasoning was that it seemed more like an implementation detail of the async / CPS-conversion features we’d like to provide than an independently valuable feature, given that we don’t want to encourage people to write library interfaces using functional-style error handling instead of throws.<br></p><p>It’s also a feature that’s directly affected by the design of typed throws, which in turn poses some usability challenges for it.  For example, without typed throws you really just want the type to be Result&lt;T&gt;.  With typed throws, can you still write that, or do you have to write Result&lt;T, ErrorType&gt;?  Also, if we want every function result signature to have a corresponding Result&lt;&gt; type, does that permanently prevent us to supporting multiple error types with “typed throws”?  Also, would it be too frustrating to work with typed Result values if we don’t allow implicit covariant conversions along one or both dimensions?<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: An Either Type in the STL</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December  9, 2015 at 08:00:00pm</p></header><div class="content"><p>&gt; We considered it, had some specifics worked out, and then decided to put it on hold.  Part of our reasoning was that it seemed more like an implementation detail of the async / CPS-conversion features we’d like to provide than an independently valuable feature, given that we don’t want to encourage people to write library interfaces using functional-style error handling instead of throws.<br>&gt; <br>&gt; It’s also a feature that’s directly affected by the design of typed throws, which in turn poses some usability challenges for it.  For example, without typed throws you really just want the type to be Result&lt;T&gt;.  With typed throws, can you still write that, or do you have to write Result&lt;T, ErrorType&gt;?  Also, if we want every function result signature to have a corresponding Result&lt;&gt; type, does that permanently prevent us to supporting multiple error types with “typed throws”?  Also, would it be too frustrating to work with typed Result values if we don’t allow implicit covariant conversions along one or both dimensions?<br></p><p>I’m glad to see you holding off until these related design issues are sorted out.  <br></p><p>Can you elaborate on what you mean by a corresponding Result&lt;&gt; type?  I don’t follow the generic argument brackets without any arguments.<br></p><p>When it comes back up and assuming we have typed throws I would like to see support for multiple error types.  I think it could be accomplished via an anonymous compiler generated sum type or something similar to that.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Proposal: An Either Type in the STL</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>December  9, 2015 at 07:00:00pm</p></header><div class="content"><p>&gt; On Dec 9, 2015, at 6:43 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; We considered it, had some specifics worked out, and then decided to put it on hold.  Part of our reasoning was that it seemed more like an implementation detail of the async / CPS-conversion features we’d like to provide than an independently valuable feature, given that we don’t want to encourage people to write library interfaces using functional-style error handling instead of throws.<br>&gt;&gt; <br>&gt;&gt; It’s also a feature that’s directly affected by the design of typed throws, which in turn poses some usability challenges for it.  For example, without typed throws you really just want the type to be Result&lt;T&gt;.  With typed throws, can you still write that, or do you have to write Result&lt;T, ErrorType&gt;?  Also, if we want every function result signature to have a corresponding Result&lt;&gt; type, does that permanently prevent us to supporting multiple error types with “typed throws”?  Also, would it be too frustrating to work with typed Result values if we don’t allow implicit covariant conversions along one or both dimensions?<br>&gt; <br>&gt; I’m glad to see you holding off until these related design issues are sorted out.  <br>&gt; <br>&gt; Can you elaborate on what you mean by a corresponding Result&lt;&gt; type?  I don’t follow the generic argument brackets without any arguments.<br></p><p>I was being intentionally vague about what the generic arguments to Result might be.<br></p><p>Evaluating a Swift expression always either yields a T or throws an E (or fails to terminate at all, but from a static perspective, we can ignore this).  One purpose of Result is to allow the abstract result of that evaluation to be captured in a single value.  It makes sense for Result to be parameterized by T, and possibly also by E.<br></p><p>Swift currently does not allow E to be constrained more precisely than just ErrorType.  In this world, it makes sense to just be able to write Result&lt;T&gt;.<br></p><p>The point of typed “throws” is to allow E to be more constrained.  In the simplest case, E might be one specific type; it might then make sense to be able to write Result&lt;T, E&gt;.  However, there are more complex cases.  For example, it might be possible to say (Java-like) that a function can throw any one of a set of different error types; would this have to be expressed as Result&lt;T, E1, E2, E2, …&gt;?  That’s a tough fit for the generics system, especially since the error types are logically a set, not a sequence.  Now, you could try to disallow this by saying that functions have to pick a single type that they can throw (e.g. ErrorType); but this doesn’t actually solve the problem, because expressions can contain multiple throw sites with different error types, so now you’ve got a set again.  Again, you can force that back to the greatest common type (which will generally be ErrorType), but now Result loses information that normal type-checking would have preserved.  So it’s a challenge.<br></p><p>&gt; When it comes back up and assuming we have typed throws I would like to see support for multiple error types.  I think it could be accomplished via an anonymous compiler generated sum type or something similar to that.  <br></p><p>Structural sum types (as opposed to nominal sum types like Either which are explicitly formed and broken down) are a massive complication for type systems.<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d933552ea7fda10a4488a74223c00988?s=50"></div><header><strong>Proposal: An Either Type in the STL</strong> from <string>Thorsten Seitz</string> &lt;thorsten.seitz at web.de&gt;<p>December 10, 2015 at 08:00:00pm</p></header><div class="content"><p>&gt; The point of typed “throws” is to allow E to be more constrained.  In the simplest case, E might be one specific type; it might then make sense to be able to write Result&lt;T, E&gt;.  However, there are more complex cases.  For example, it might be possible to say (Java-like) that a function can throw any one of a set of different error types; would this have to be expressed as Result&lt;T, E1, E2, E2, …&gt;?  That’s a tough fit for the generics system, especially since the error types are logically a set, not a sequence.  <br></p><p>You could just write Result&lt;T, E1 | E2 | E3&gt; where &quot;|&quot; is the type union operator if we had union types as in Ceylon (see http://ceylon-lang.org/documentation/tour/types/).<br>I’ve mentioned them once or twice on this list already and I do think they are really really powerful and useful while staying totally intuitive!<br></p><p>&gt; Now, you could try to disallow this by saying that functions have to pick a single type that they can throw (e.g. ErrorType); but this doesn’t actually solve the problem, because expressions can contain multiple throw sites with different error types, so now you’ve got a set again.  Again, you can force that back to the greatest common type (which will generally be ErrorType), but now Result loses information that normal type-checking would have preserved.  So it’s a challenge.<br></p><p>With union types no information is lost. I was really surprised how well they worked out in Ceylon (and I think the Ceylon guys were themselves pleasantly surprised, too).<br></p><p>-Thorsten<br></p><p>&gt; <br>&gt;&gt; When it comes back up and assuming we have typed throws I would like to see support for multiple error types.  I think it could be accomplished via an anonymous compiler generated sum type or something similar to that.  <br>&gt; <br>&gt; Structural sum types (as opposed to nominal sum types like Either which are explicitly formed and broken down) are a massive complication for type systems.<br>&gt; <br>&gt; John.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/960c2977/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>STL (not!) (was: Proposal: An Either Type in the STL)</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 14, 2015 at 01:00:00am</p></header><div class="content"><p>&gt; On Dec 9, 2015, at 3:06 PM, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; It’s high time the STL admitted some kind of disjoint union type…<br></p><p>Friends,<br></p><p>The STL &lt;https://en.wikipedia.org/wiki/Standard_Template_Library&gt; is a hugely influential and important effort, but it is not the Swift standard library.  We don&#39;t want to be seen as either co-opting the name or taking credit for its design, nor do we want to sell short the unique strengths of Swift&#39;s own standard library by letting it be confused with that other body of work.  My humble request is that, if we want to use a short name to refer to the Swift standard library, we choose a different one.  &quot;Stdlib&quot; seems workable and precedented in our source directory layout, for example.<br></p><p>Thanks,<br>-Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/4dc0a0b5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>STL (not!) (was: Proposal: An Either Type in the STL)</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>December 14, 2015 at 01:00:00am</p></header><div class="content"><p>How about the Swift Standard Library (SSL)?  ;-)<br></p><p>On Mon, Dec 14, 2015 at 1:06 AM, Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Dec 9, 2015, at 3:06 PM, Developer via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; It’s high time the STL admitted some kind of disjoint union type…<br>&gt;<br>&gt;<br>&gt; Friends,<br>&gt;<br>&gt; The STL &lt;https://en.wikipedia.org/wiki/Standard_Template_Library&gt; is a<br>&gt; hugely influential and important effort, but it is not the Swift standard<br>&gt; library.  We don&#39;t want to be seen as either co-opting the name or taking<br>&gt; credit for its design, nor do we want to sell short the unique strengths of<br>&gt; Swift&#39;s own standard library by letting it be confused with that other body<br>&gt; of work.  My humble request is that, if we want to use a short name to<br>&gt; refer to the Swift standard library, we choose a different one.  &quot;Stdlib&quot;<br>&gt; seems workable and precedented in our source directory layout, for example.<br>&gt;<br>&gt; Thanks,<br>&gt; -Dave<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/06183482/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>STL (not!) (was: Proposal: An Either Type in the STL)</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>December 14, 2015 at 08:00:00pm</p></header><div class="content"><p>Or the Swift Common Module? SCM<br></p><p>On Mon, Dec 14, 2015 at 8:21 PM, Jacob Bandes-Storch via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; How about the Swift Standard Library (SSL)?  ;-)<br>&gt;<br>&gt; On Mon, Dec 14, 2015 at 1:06 AM, Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Dec 9, 2015, at 3:06 PM, Developer via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; It’s high time the STL admitted some kind of disjoint union type…<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Friends,<br>&gt;&gt;<br>&gt;&gt; The STL &lt;https://en.wikipedia.org/wiki/Standard_Template_Library&gt; is a<br>&gt;&gt; hugely influential and important effort, but it is not the Swift standard<br>&gt;&gt; library.  We don&#39;t want to be seen as either co-opting the name or taking<br>&gt;&gt; credit for its design, nor do we want to sell short the unique strengths of<br>&gt;&gt; Swift&#39;s own standard library by letting it be confused with that other body<br>&gt;&gt; of work.  My humble request is that, if we want to use a short name to<br>&gt;&gt; refer to the Swift standard library, we choose a different one.  &quot;Stdlib&quot;<br>&gt;&gt; seems workable and precedented in our source directory layout, for example.<br>&gt;&gt;<br>&gt;&gt; Thanks,<br>&gt;&gt; -Dave<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/1882ce8c/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
