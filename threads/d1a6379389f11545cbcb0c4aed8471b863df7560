<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>Swift 3 (Xcode 8 GM) issue with @escaping</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>September  7, 2016 at 10:00:00pm</p></header><div class="content"><p>I like and fully supported the change to @escaping away from @noescape<br>however in a body of code that I am porting to the latest Swift 3 variant<br>(as found in Xcode 8 GM) I am hitting an issue for methods that take an<br>optional completion closure. If optional is involved I can&#39;t find a way to<br>apply @escape to the escaping closure. See the following for an basic<br>example...<br></p><p>Is their a way to do what I need and/or is this an edge case in the<br>implementation of @escaping?<br></p><p>typealias MyCallback = (String)-&gt;()<br></p><p>// Happy<br>func foo1(bar: String, completion: ((String)-&gt;())) {<br>    completion(bar)<br>}<br></p><p>// Happy<br>func foo2(bar: String, completion: MyCallback) {<br>    completion(bar)<br>}<br></p><p>// Happy<br>func foo3(bar: String, completion: ((String)-&gt;())? = nil) {<br>    completion?(bar)<br>}<br></p><p>// Happy<br>func foo4(bar: String, completion: MyCallback? = nil) {<br>    completion?(bar)<br>}<br></p><p>// Happy<br>func foo5(bar: String, completion: Optional&lt;MyCallback&gt; = nil) {<br>    completion?(bar)<br>}<br></p><p>// Happy<br>func foo6(bar: String, completion: @escaping (String)-&gt;()) {<br>    completion(bar)<br>}<br></p><p>// Happy<br>func foo7(bar: String, completion: @escaping MyCallback) {<br>    completion(bar)<br>}<br></p><p>// Unhappy...<br>// &quot;@escaping attribute only applies to function types&quot;<br>func foo8(bar: String, completion: @escaping ((String)-&gt;())? = nil) {<br>    completion?(bar)<br>}<br></p><p>// Unhappy...<br>// &quot;@escaping attribute only applies to function types&quot;<br>func foo9(bar: String, completion: @escaping MyCallback? = nil) {<br>    completion?(bar)<br>}<br></p><p>// Unhappy...<br>// &quot;@escaping attribute only applies to function types&quot;<br>func foo10(bar: String, completion: (@escaping ((String)-&gt;()))? = nil) {<br>    completion?(bar)<br>}<br></p><p>// Unhappy...<br>// &quot;@escaping attribute only applies to function types&quot;<br>func foo11(bar: String, completion: (@escaping MyCallback)? = nil) {<br>    completion?(bar)<br>}<br></p><p>// Unhappy...<br>// &quot;@escaping attribute only applies to function types&quot;<br>func foo12(bar: String, completion: Optional&lt;@escaping MyCallback&gt; = nil) {<br>    completion?(bar)<br>}<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160907/d1a67560/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>Swift 3 (Xcode 8 GM) issue with @escaping</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>September  7, 2016 at 10:00:00pm</p></header><div class="content"><p>I should note that this issue also appeared in an earlier variant of Swift<br>after the addition of @escaping but I was on vacation so didn&#39;t get a<br>chance to report it then. It isn&#39;t new with the Xcode 8 GM.<br></p><p>On Wed, Sep 7, 2016 at 3:08 PM Shawn Erickson &lt;shawnce at gmail.com&gt; wrote:<br></p><p>&gt; I like and fully supported the change to @escaping away from @noescape<br>&gt; however in a body of code that I am porting to the latest Swift 3 variant<br>&gt; (as found in Xcode 8 GM) I am hitting an issue for methods that take an<br>&gt; optional completion closure. If optional is involved I can&#39;t find a way to<br>&gt; apply @escape to the escaping closure. See the following for an basic<br>&gt; example...<br>&gt;<br>&gt; Is their a way to do what I need and/or is this an edge case in the<br>&gt; implementation of @escaping?<br>&gt;<br>&gt; typealias MyCallback = (String)-&gt;()<br>&gt;<br>&gt; // Happy<br>&gt; func foo1(bar: String, completion: ((String)-&gt;())) {<br>&gt;     completion(bar)<br>&gt; }<br>&gt;<br>&gt; // Happy<br>&gt; func foo2(bar: String, completion: MyCallback) {<br>&gt;     completion(bar)<br>&gt; }<br>&gt;<br>&gt; // Happy<br>&gt; func foo3(bar: String, completion: ((String)-&gt;())? = nil) {<br>&gt;     completion?(bar)<br>&gt; }<br>&gt;<br>&gt; // Happy<br>&gt; func foo4(bar: String, completion: MyCallback? = nil) {<br>&gt;     completion?(bar)<br>&gt; }<br>&gt;<br>&gt; // Happy<br>&gt; func foo5(bar: String, completion: Optional&lt;MyCallback&gt; = nil) {<br>&gt;     completion?(bar)<br>&gt; }<br>&gt;<br>&gt; // Happy<br>&gt; func foo6(bar: String, completion: @escaping (String)-&gt;()) {<br>&gt;     completion(bar)<br>&gt; }<br>&gt;<br>&gt; // Happy<br>&gt; func foo7(bar: String, completion: @escaping MyCallback) {<br>&gt;     completion(bar)<br>&gt; }<br>&gt;<br>&gt; // Unhappy...<br>&gt; // &quot;@escaping attribute only applies to function types&quot;<br>&gt; func foo8(bar: String, completion: @escaping ((String)-&gt;())? = nil) {<br>&gt;     completion?(bar)<br>&gt; }<br>&gt;<br>&gt; // Unhappy...<br>&gt; // &quot;@escaping attribute only applies to function types&quot;<br>&gt; func foo9(bar: String, completion: @escaping MyCallback? = nil) {<br>&gt;     completion?(bar)<br>&gt; }<br>&gt;<br>&gt; // Unhappy...<br>&gt; // &quot;@escaping attribute only applies to function types&quot;<br>&gt; func foo10(bar: String, completion: (@escaping ((String)-&gt;()))? = nil) {<br>&gt;     completion?(bar)<br>&gt; }<br>&gt;<br>&gt; // Unhappy...<br>&gt; // &quot;@escaping attribute only applies to function types&quot;<br>&gt; func foo11(bar: String, completion: (@escaping MyCallback)? = nil) {<br>&gt;     completion?(bar)<br>&gt; }<br>&gt;<br>&gt; // Unhappy...<br>&gt; // &quot;@escaping attribute only applies to function types&quot;<br>&gt; func foo12(bar: String, completion: Optional&lt;@escaping MyCallback&gt; = nil) {<br>&gt;     completion?(bar)<br>&gt; }<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160907/9a386e67/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/44b9c3e92a40313850fdbc2cb0abdef7?s=50"></div><header><strong>Swift 3 (Xcode 8 GM) issue with @escaping</strong> from <string>Jon Shier</string> &lt;jon at jonshier.com&gt;<p>September  7, 2016 at 06:00:00pm</p></header><div class="content"><p>Perhaps relatedly, it no longer seems possible to mark typealiased closures as @escaping. That was quite handy when you know that closures will always be used asynchronously.<br></p><p><br>Jon<br></p><p><br>&gt; On Sep 7, 2016, at 6:15 PM, Shawn Erickson via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; I should note that this issue also appeared in an earlier variant of Swift after the addition of @escaping but I was on vacation so didn&#39;t get a chance to report it then. It isn&#39;t new with the Xcode 8 GM.<br>&gt; <br>&gt; On Wed, Sep 7, 2016 at 3:08 PM Shawn Erickson &lt;shawnce at gmail.com &lt;mailto:shawnce at gmail.com&gt;&gt; wrote:<br>&gt; I like and fully supported the change to @escaping away from @noescape however in a body of code that I am porting to the latest Swift 3 variant (as found in Xcode 8 GM) I am hitting an issue for methods that take an optional completion closure. If optional is involved I can&#39;t find a way to apply @escape to the escaping closure. See the following for an basic example...<br>&gt; <br>&gt; Is their a way to do what I need and/or is this an edge case in the implementation of @escaping?<br>&gt; <br>&gt; typealias MyCallback = (String)-&gt;()<br>&gt; <br>&gt; // Happy<br>&gt; func foo1(bar: String, completion: ((String)-&gt;())) {<br>&gt;     completion(bar)<br>&gt; }<br>&gt; <br>&gt; // Happy<br>&gt; func foo2(bar: String, completion: MyCallback) {<br>&gt;     completion(bar)<br>&gt; }<br>&gt; <br>&gt; // Happy<br>&gt; func foo3(bar: String, completion: ((String)-&gt;())? = nil) {<br>&gt;     completion?(bar)<br>&gt; }<br>&gt; <br>&gt; // Happy<br>&gt; func foo4(bar: String, completion: MyCallback? = nil) {<br>&gt;     completion?(bar)<br>&gt; }<br>&gt; <br>&gt; // Happy<br>&gt; func foo5(bar: String, completion: Optional&lt;MyCallback&gt; = nil) {<br>&gt;     completion?(bar)<br>&gt; }<br>&gt; <br>&gt; // Happy<br>&gt; func foo6(bar: String, completion: @escaping (String)-&gt;()) {<br>&gt;     completion(bar)<br>&gt; }<br>&gt; <br>&gt; // Happy<br>&gt; func foo7(bar: String, completion: @escaping MyCallback) {<br>&gt;     completion(bar)<br>&gt; }<br>&gt; <br>&gt; // Unhappy...<br>&gt; // &quot;@escaping attribute only applies to function types&quot;<br>&gt; func foo8(bar: String, completion: @escaping ((String)-&gt;())? = nil) {<br>&gt;     completion?(bar)<br>&gt; }<br>&gt; <br>&gt; // Unhappy...<br>&gt; // &quot;@escaping attribute only applies to function types&quot;<br>&gt; func foo9(bar: String, completion: @escaping MyCallback? = nil) {<br>&gt;     completion?(bar)<br>&gt; }<br>&gt; <br>&gt; // Unhappy...<br>&gt; // &quot;@escaping attribute only applies to function types&quot;<br>&gt; func foo10(bar: String, completion: (@escaping ((String)-&gt;()))? = nil) {<br>&gt;     completion?(bar)<br>&gt; }<br>&gt; <br>&gt; // Unhappy...<br>&gt; // &quot;@escaping attribute only applies to function types&quot;<br>&gt; func foo11(bar: String, completion: (@escaping MyCallback)? = nil) {<br>&gt;     completion?(bar)<br>&gt; }<br>&gt; <br>&gt; // Unhappy...<br>&gt; // &quot;@escaping attribute only applies to function types&quot;<br>&gt; func foo12(bar: String, completion: Optional&lt;@escaping MyCallback&gt; = nil) {<br>&gt;     completion?(bar)<br>&gt; }<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160907/fa024d2a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>Swift 3 (Xcode 8 GM) issue with @escaping</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>September  7, 2016 at 10:00:00pm</p></header><div class="content"><p>Yeah I actually have a few of those myself that I can no longer do.<br></p><p>On Wed, Sep 7, 2016 at 3:26 PM Jon Shier &lt;jon at jonshier.com&gt; wrote:<br></p><p>&gt; Perhaps relatedly, it no longer seems possible to mark typealiased<br>&gt; closures as @escaping. That was quite handy when you know that closures<br>&gt; will always be used asynchronously.<br>&gt;<br>&gt;<br>&gt; Jon<br>&gt;<br>&gt;<br>&gt; On Sep 7, 2016, at 6:15 PM, Shawn Erickson via swift-users &lt;<br>&gt; swift-users at swift.org&gt; wrote:<br>&gt;<br>&gt; I should note that this issue also appeared in an earlier variant of Swift<br>&gt; after the addition of @escaping but I was on vacation so didn&#39;t get a<br>&gt; chance to report it then. It isn&#39;t new with the Xcode 8 GM.<br>&gt;<br>&gt; On Wed, Sep 7, 2016 at 3:08 PM Shawn Erickson &lt;shawnce at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; I like and fully supported the change to @escaping away from @noescape<br>&gt;&gt; however in a body of code that I am porting to the latest Swift 3 variant<br>&gt;&gt; (as found in Xcode 8 GM) I am hitting an issue for methods that take an<br>&gt;&gt; optional completion closure. If optional is involved I can&#39;t find a way to<br>&gt;&gt; apply @escape to the escaping closure. See the following for an basic<br>&gt;&gt; example...<br>&gt;&gt;<br>&gt;&gt; Is their a way to do what I need and/or is this an edge case in the<br>&gt;&gt; implementation of @escaping?<br>&gt;&gt;<br>&gt;&gt; typealias MyCallback = (String)-&gt;()<br>&gt;&gt;<br>&gt;&gt; // Happy<br>&gt;&gt; func foo1(bar: String, completion: ((String)-&gt;())) {<br>&gt;&gt;     completion(bar)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; // Happy<br>&gt;&gt; func foo2(bar: String, completion: MyCallback) {<br>&gt;&gt;     completion(bar)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; // Happy<br>&gt;&gt; func foo3(bar: String, completion: ((String)-&gt;())? = nil) {<br>&gt;&gt;     completion?(bar)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; // Happy<br>&gt;&gt; func foo4(bar: String, completion: MyCallback? = nil) {<br>&gt;&gt;     completion?(bar)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; // Happy<br>&gt;&gt; func foo5(bar: String, completion: Optional&lt;MyCallback&gt; = nil) {<br>&gt;&gt;     completion?(bar)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; // Happy<br>&gt;&gt; func foo6(bar: String, completion: @escaping (String)-&gt;()) {<br>&gt;&gt;     completion(bar)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; // Happy<br>&gt;&gt; func foo7(bar: String, completion: @escaping MyCallback) {<br>&gt;&gt;     completion(bar)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; // Unhappy...<br>&gt;&gt; // &quot;@escaping attribute only applies to function types&quot;<br>&gt;&gt; func foo8(bar: String, completion: @escaping ((String)-&gt;())? = nil) {<br>&gt;&gt;     completion?(bar)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; // Unhappy...<br>&gt;&gt; // &quot;@escaping attribute only applies to function types&quot;<br>&gt;&gt; func foo9(bar: String, completion: @escaping MyCallback? = nil) {<br>&gt;&gt;     completion?(bar)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; // Unhappy...<br>&gt;&gt; // &quot;@escaping attribute only applies to function types&quot;<br>&gt;&gt; func foo10(bar: String, completion: (@escaping ((String)-&gt;()))? = nil) {<br>&gt;&gt;     completion?(bar)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; // Unhappy...<br>&gt;&gt; // &quot;@escaping attribute only applies to function types&quot;<br>&gt;&gt; func foo11(bar: String, completion: (@escaping MyCallback)? = nil) {<br>&gt;&gt;     completion?(bar)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; // Unhappy...<br>&gt;&gt; // &quot;@escaping attribute only applies to function types&quot;<br>&gt;&gt; func foo12(bar: String, completion: Optional&lt;@escaping MyCallback&gt; = nil)<br>&gt;&gt; {<br>&gt;&gt;     completion?(bar)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160907/f851c29c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>Swift 3 (Xcode 8 GM) issue with @escaping</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>September  7, 2016 at 10:00:00pm</p></header><div class="content"><p>I see https://bugs.swift.org/browse/SR-2324 and<br>https://bugs.swift.org/browse/SR-2444 which looks related to this issue and<br>may explain the error I saw on &quot;the other side&quot; of this.<br></p><p><br></p><p>On Wed, Sep 7, 2016 at 3:28 PM Shawn Erickson &lt;shawnce at gmail.com&gt; wrote:<br></p><p>&gt; Yeah I actually have a few of those myself that I can no longer do.<br>&gt;<br>&gt; On Wed, Sep 7, 2016 at 3:26 PM Jon Shier &lt;jon at jonshier.com&gt; wrote:<br>&gt;<br>&gt;&gt; Perhaps relatedly, it no longer seems possible to mark typealiased<br>&gt;&gt; closures as @escaping. That was quite handy when you know that closures<br>&gt;&gt; will always be used asynchronously.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Jon<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Sep 7, 2016, at 6:15 PM, Shawn Erickson via swift-users &lt;<br>&gt;&gt; swift-users at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I should note that this issue also appeared in an earlier variant of<br>&gt;&gt; Swift after the addition of @escaping but I was on vacation so didn&#39;t get a<br>&gt;&gt; chance to report it then. It isn&#39;t new with the Xcode 8 GM.<br>&gt;&gt;<br>&gt;&gt; On Wed, Sep 7, 2016 at 3:08 PM Shawn Erickson &lt;shawnce at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; I like and fully supported the change to @escaping away from @noescape<br>&gt;&gt;&gt; however in a body of code that I am porting to the latest Swift 3 variant<br>&gt;&gt;&gt; (as found in Xcode 8 GM) I am hitting an issue for methods that take an<br>&gt;&gt;&gt; optional completion closure. If optional is involved I can&#39;t find a way to<br>&gt;&gt;&gt; apply @escape to the escaping closure. See the following for an basic<br>&gt;&gt;&gt; example...<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Is their a way to do what I need and/or is this an edge case in the<br>&gt;&gt;&gt; implementation of @escaping?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; typealias MyCallback = (String)-&gt;()<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; // Happy<br>&gt;&gt;&gt; func foo1(bar: String, completion: ((String)-&gt;())) {<br>&gt;&gt;&gt;     completion(bar)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; // Happy<br>&gt;&gt;&gt; func foo2(bar: String, completion: MyCallback) {<br>&gt;&gt;&gt;     completion(bar)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; // Happy<br>&gt;&gt;&gt; func foo3(bar: String, completion: ((String)-&gt;())? = nil) {<br>&gt;&gt;&gt;     completion?(bar)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; // Happy<br>&gt;&gt;&gt; func foo4(bar: String, completion: MyCallback? = nil) {<br>&gt;&gt;&gt;     completion?(bar)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; // Happy<br>&gt;&gt;&gt; func foo5(bar: String, completion: Optional&lt;MyCallback&gt; = nil) {<br>&gt;&gt;&gt;     completion?(bar)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; // Happy<br>&gt;&gt;&gt; func foo6(bar: String, completion: @escaping (String)-&gt;()) {<br>&gt;&gt;&gt;     completion(bar)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; // Happy<br>&gt;&gt;&gt; func foo7(bar: String, completion: @escaping MyCallback) {<br>&gt;&gt;&gt;     completion(bar)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; // Unhappy...<br>&gt;&gt;&gt; // &quot;@escaping attribute only applies to function types&quot;<br>&gt;&gt;&gt; func foo8(bar: String, completion: @escaping ((String)-&gt;())? = nil) {<br>&gt;&gt;&gt;     completion?(bar)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; // Unhappy...<br>&gt;&gt;&gt; // &quot;@escaping attribute only applies to function types&quot;<br>&gt;&gt;&gt; func foo9(bar: String, completion: @escaping MyCallback? = nil) {<br>&gt;&gt;&gt;     completion?(bar)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; // Unhappy...<br>&gt;&gt;&gt; // &quot;@escaping attribute only applies to function types&quot;<br>&gt;&gt;&gt; func foo10(bar: String, completion: (@escaping ((String)-&gt;()))? = nil) {<br>&gt;&gt;&gt;     completion?(bar)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; // Unhappy...<br>&gt;&gt;&gt; // &quot;@escaping attribute only applies to function types&quot;<br>&gt;&gt;&gt; func foo11(bar: String, completion: (@escaping MyCallback)? = nil) {<br>&gt;&gt;&gt;     completion?(bar)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; // Unhappy...<br>&gt;&gt;&gt; // &quot;@escaping attribute only applies to function types&quot;<br>&gt;&gt;&gt; func foo12(bar: String, completion: Optional&lt;@escaping MyCallback&gt; =<br>&gt;&gt;&gt; nil) {<br>&gt;&gt;&gt;     completion?(bar)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160907/3af78e08/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8dfc6932943f38e7a7de48be3194f13c?s=50"></div><header><strong>Swift 3 (Xcode 8 GM) issue with @escaping</strong> from <string>Michael Ilseman</string> &lt;milseman at apple.com&gt;<p>September  7, 2016 at 05:00:00pm</p></header><div class="content"><p>I implemented a better (i.e. correct) diagnostic message for this at https://github.com/apple/swift/pull/4670. I want to also do a better diagnostic specifically for aggregate parameters to functions (e.g. optional closures), but that requires more work in the type checker.<br></p><p>Basically, @escaping is valid only on closures in function parameter position. The noescape-by-default rule only applies to these closures at function parameter position, otherwise they are escaping. Aggregates, such as enums with associated values (e.g. Optional), tuples, structs, etc., if they have closures, follow the default rules for closures that are not at function parameter position, i.e. they are escaping.<br></p><p>It would be a post-Swift-3 addition to the language to be able to support more robust liveness tracking here. There may be interesting directions to take this, with optional closures being the most common beneficiary. <br></p><p>&gt; On Sep 7, 2016, at 3:33 PM, Shawn Erickson via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; I see https://bugs.swift.org/browse/SR-2324 &lt;https://bugs.swift.org/browse/SR-2324&gt; and https://bugs.swift.org/browse/SR-2444 &lt;https://bugs.swift.org/browse/SR-2444&gt; which looks related to this issue and may explain the error I saw on &quot;the other side&quot; of this.<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Wed, Sep 7, 2016 at 3:28 PM Shawn Erickson &lt;shawnce at gmail.com &lt;mailto:shawnce at gmail.com&gt;&gt; wrote:<br>&gt; Yeah I actually have a few of those myself that I can no longer do.<br>&gt; <br>&gt; On Wed, Sep 7, 2016 at 3:26 PM Jon Shier &lt;jon at jonshier.com &lt;mailto:jon at jonshier.com&gt;&gt; wrote:<br>&gt; Perhaps relatedly, it no longer seems possible to mark typealiased closures as @escaping. That was quite handy when you know that closures will always be used asynchronously.<br>&gt; <br>&gt; <br>&gt; Jon<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Sep 7, 2016, at 6:15 PM, Shawn Erickson via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt; <br>&gt;&gt; I should note that this issue also appeared in an earlier variant of Swift after the addition of @escaping but I was on vacation so didn&#39;t get a chance to report it then. It isn&#39;t new with the Xcode 8 GM.<br>&gt;&gt; <br>&gt;&gt; On Wed, Sep 7, 2016 at 3:08 PM Shawn Erickson &lt;shawnce at gmail.com &lt;mailto:shawnce at gmail.com&gt;&gt; wrote:<br>&gt;&gt; I like and fully supported the change to @escaping away from @noescape however in a body of code that I am porting to the latest Swift 3 variant (as found in Xcode 8 GM) I am hitting an issue for methods that take an optional completion closure. If optional is involved I can&#39;t find a way to apply @escape to the escaping closure. See the following for an basic example...<br>&gt;&gt; <br>&gt;&gt; Is their a way to do what I need and/or is this an edge case in the implementation of @escaping?<br>&gt;&gt; <br>&gt;&gt; typealias MyCallback = (String)-&gt;()<br>&gt;&gt; <br>&gt;&gt; // Happy<br>&gt;&gt; func foo1(bar: String, completion: ((String)-&gt;())) {<br>&gt;&gt;     completion(bar)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // Happy<br>&gt;&gt; func foo2(bar: String, completion: MyCallback) {<br>&gt;&gt;     completion(bar)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // Happy<br>&gt;&gt; func foo3(bar: String, completion: ((String)-&gt;())? = nil) {<br>&gt;&gt;     completion?(bar)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // Happy<br>&gt;&gt; func foo4(bar: String, completion: MyCallback? = nil) {<br>&gt;&gt;     completion?(bar)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // Happy<br>&gt;&gt; func foo5(bar: String, completion: Optional&lt;MyCallback&gt; = nil) {<br>&gt;&gt;     completion?(bar)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // Happy<br>&gt;&gt; func foo6(bar: String, completion: @escaping (String)-&gt;()) {<br>&gt;&gt;     completion(bar)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // Happy<br>&gt;&gt; func foo7(bar: String, completion: @escaping MyCallback) {<br>&gt;&gt;     completion(bar)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // Unhappy...<br>&gt;&gt; // &quot;@escaping attribute only applies to function types&quot;<br>&gt;&gt; func foo8(bar: String, completion: @escaping ((String)-&gt;())? = nil) {<br>&gt;&gt;     completion?(bar)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // Unhappy...<br>&gt;&gt; // &quot;@escaping attribute only applies to function types&quot;<br>&gt;&gt; func foo9(bar: String, completion: @escaping MyCallback? = nil) {<br>&gt;&gt;     completion?(bar)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // Unhappy...<br>&gt;&gt; // &quot;@escaping attribute only applies to function types&quot;<br>&gt;&gt; func foo10(bar: String, completion: (@escaping ((String)-&gt;()))? = nil) {<br>&gt;&gt;     completion?(bar)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // Unhappy...<br>&gt;&gt; // &quot;@escaping attribute only applies to function types&quot;<br>&gt;&gt; func foo11(bar: String, completion: (@escaping MyCallback)? = nil) {<br>&gt;&gt;     completion?(bar)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // Unhappy...<br>&gt;&gt; // &quot;@escaping attribute only applies to function types&quot;<br>&gt;&gt; func foo12(bar: String, completion: Optional&lt;@escaping MyCallback&gt; = nil) {<br>&gt;&gt;     completion?(bar)<br>&gt;&gt; }<br>&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160907/e80c3a0e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Swift 3 (Xcode 8 GM) issue with @escaping</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>September  7, 2016 at 06:00:00pm</p></header><div class="content"><p>On Wed, Sep 7, 2016 at 5:54 PM, Michael Ilseman via swift-users &lt;<br>swift-users at swift.org&gt; wrote:<br></p><p>&gt; I implemented a better (i.e. correct) diagnostic message for this at<br>&gt; https://github.com/apple/swift/pull/4670. I want to also do a better<br>&gt; diagnostic specifically for aggregate parameters to functions (e.g.<br>&gt; optional closures), but that requires more work in the type checker.<br>&gt;<br>&gt; Basically, @escaping is valid only on closures in function parameter<br>&gt; position. The noescape-by-default rule only applies to these closures at<br>&gt; function parameter position, otherwise they are escaping. Aggregates, such<br>&gt; as enums with associated values (e.g. Optional), tuples, structs, etc., if<br>&gt; they have closures, follow the default rules for closures that are not at<br>&gt; function parameter position, i.e. they are escaping.<br>&gt;<br></p><p>Shouldn&#39;t it be possible to allow distinguishing @escaping/@noescape for<br>aggregates like these, at least for the simple case of Optional?  (I<br>handled optionals in https://github.com/apple/swift/pull/4438 for imported<br>function types; see comment<br>&lt;https://github.com/apple/swift/pull/4438#issuecomment-243645367&gt;.)<br></p><p><br>&gt;<br>&gt; It would be a post-Swift-3 addition to the language to be able to support<br>&gt; more robust liveness tracking here. There may be interesting directions to<br>&gt; take this, with optional closures being the most common beneficiary.<br>&gt;<br>&gt; On Sep 7, 2016, at 3:33 PM, Shawn Erickson via swift-users &lt;<br>&gt; swift-users at swift.org&gt; wrote:<br>&gt;<br>&gt; I see https://bugs.swift.org/browse/SR-2324 and<br>&gt; https://bugs.swift.org/browse/SR-2444 which looks related to this issue<br>&gt; and may explain the error I saw on &quot;the other side&quot; of this.<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Wed, Sep 7, 2016 at 3:28 PM Shawn Erickson &lt;shawnce at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; Yeah I actually have a few of those myself that I can no longer do.<br>&gt;&gt;<br>&gt;&gt; On Wed, Sep 7, 2016 at 3:26 PM Jon Shier &lt;jon at jonshier.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Perhaps relatedly, it no longer seems possible to mark typealiased<br>&gt;&gt;&gt; closures as @escaping. That was quite handy when you know that closures<br>&gt;&gt;&gt; will always be used asynchronously.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Sep 7, 2016, at 6:15 PM, Shawn Erickson via swift-users &lt;<br>&gt;&gt;&gt; swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I should note that this issue also appeared in an earlier variant of<br>&gt;&gt;&gt; Swift after the addition of @escaping but I was on vacation so didn&#39;t get a<br>&gt;&gt;&gt; chance to report it then. It isn&#39;t new with the Xcode 8 GM.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Wed, Sep 7, 2016 at 3:08 PM Shawn Erickson &lt;shawnce at gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I like and fully supported the change to @escaping away from @noescape<br>&gt;&gt;&gt;&gt; however in a body of code that I am porting to the latest Swift 3 variant<br>&gt;&gt;&gt;&gt; (as found in Xcode 8 GM) I am hitting an issue for methods that take an<br>&gt;&gt;&gt;&gt; optional completion closure. If optional is involved I can&#39;t find a way to<br>&gt;&gt;&gt;&gt; apply @escape to the escaping closure. See the following for an basic<br>&gt;&gt;&gt;&gt; example...<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Is their a way to do what I need and/or is this an edge case in the<br>&gt;&gt;&gt;&gt; implementation of @escaping?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; typealias MyCallback = (String)-&gt;()<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; // Happy<br>&gt;&gt;&gt;&gt; func foo1(bar: String, completion: ((String)-&gt;())) {<br>&gt;&gt;&gt;&gt;     completion(bar)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; // Happy<br>&gt;&gt;&gt;&gt; func foo2(bar: String, completion: MyCallback) {<br>&gt;&gt;&gt;&gt;     completion(bar)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; // Happy<br>&gt;&gt;&gt;&gt; func foo3(bar: String, completion: ((String)-&gt;())? = nil) {<br>&gt;&gt;&gt;&gt;     completion?(bar)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; // Happy<br>&gt;&gt;&gt;&gt; func foo4(bar: String, completion: MyCallback? = nil) {<br>&gt;&gt;&gt;&gt;     completion?(bar)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; // Happy<br>&gt;&gt;&gt;&gt; func foo5(bar: String, completion: Optional&lt;MyCallback&gt; = nil) {<br>&gt;&gt;&gt;&gt;     completion?(bar)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; // Happy<br>&gt;&gt;&gt;&gt; func foo6(bar: String, completion: @escaping (String)-&gt;()) {<br>&gt;&gt;&gt;&gt;     completion(bar)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; // Happy<br>&gt;&gt;&gt;&gt; func foo7(bar: String, completion: @escaping MyCallback) {<br>&gt;&gt;&gt;&gt;     completion(bar)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; // Unhappy...<br>&gt;&gt;&gt;&gt; // &quot;@escaping attribute only applies to function types&quot;<br>&gt;&gt;&gt;&gt; func foo8(bar: String, completion: @escaping ((String)-&gt;())? = nil) {<br>&gt;&gt;&gt;&gt;     completion?(bar)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; // Unhappy...<br>&gt;&gt;&gt;&gt; // &quot;@escaping attribute only applies to function types&quot;<br>&gt;&gt;&gt;&gt; func foo9(bar: String, completion: @escaping MyCallback? = nil) {<br>&gt;&gt;&gt;&gt;     completion?(bar)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; // Unhappy...<br>&gt;&gt;&gt;&gt; // &quot;@escaping attribute only applies to function types&quot;<br>&gt;&gt;&gt;&gt; func foo10(bar: String, completion: (@escaping ((String)-&gt;()))? = nil) {<br>&gt;&gt;&gt;&gt;     completion?(bar)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; // Unhappy...<br>&gt;&gt;&gt;&gt; // &quot;@escaping attribute only applies to function types&quot;<br>&gt;&gt;&gt;&gt; func foo11(bar: String, completion: (@escaping MyCallback)? = nil) {<br>&gt;&gt;&gt;&gt;     completion?(bar)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; // Unhappy...<br>&gt;&gt;&gt;&gt; // &quot;@escaping attribute only applies to function types&quot;<br>&gt;&gt;&gt;&gt; func foo12(bar: String, completion: Optional&lt;@escaping MyCallback&gt; =<br>&gt;&gt;&gt;&gt; nil) {<br>&gt;&gt;&gt;&gt;     completion?(bar)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt; swift-users at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160907/d7524e2f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>Swift 3 (Xcode 8 GM) issue with @escaping</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>September  8, 2016 at 02:00:00am</p></header><div class="content"><p>It just seems a little strange that @escaping only shows up once in the<br>following example (real) function of mine yet both of them are escaping.<br>This fixit message should maybe imply that @escaping isn&#39;t needed since the<br>optional one is already implicitly considered escaping? ...it is kinda<br>confusing when first jumping over to Swift if at one point you are told you<br>need to added @escaping (the non-optional one) yet you are told @escaping<br>isn&#39;t valid for the optional one despite it needing to be escaping (e.g.<br>the fixit doesn&#39;t really explain that is already escaping).<br></p><p>    func httpGet&lt;T&gt;(path: String, parameters: [String:String] = [:],<br>                    needsAuth: Bool = true, queue: DispatchQueue =<br>DispatchQueue.main,<br>                    completion: ObjectFetchCallback&lt;T&gt;?, importer:<br>@escaping HttpImporterCallback&lt;T&gt;)<br></p><p>-Shawn<br></p><p>On Wed, Sep 7, 2016 at 6:51 PM Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>wrote:<br></p><p>&gt; On Wed, Sep 7, 2016 at 5:54 PM, Michael Ilseman via swift-users &lt;<br>&gt; swift-users at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; I implemented a better (i.e. correct) diagnostic message for this at<br>&gt;&gt; https://github.com/apple/swift/pull/4670. I want to also do a better<br>&gt;&gt; diagnostic specifically for aggregate parameters to functions (e.g.<br>&gt;&gt; optional closures), but that requires more work in the type checker.<br>&gt;&gt;<br>&gt;&gt; Basically, @escaping is valid only on closures in function parameter<br>&gt;&gt; position. The noescape-by-default rule only applies to these closures at<br>&gt;&gt; function parameter position, otherwise they are escaping. Aggregates, such<br>&gt;&gt; as enums with associated values (e.g. Optional), tuples, structs, etc., if<br>&gt;&gt; they have closures, follow the default rules for closures that are not at<br>&gt;&gt; function parameter position, i.e. they are escaping.<br>&gt;&gt;<br>&gt;<br>&gt; Shouldn&#39;t it be possible to allow distinguishing @escaping/@noescape for<br>&gt; aggregates like these, at least for the simple case of Optional?  (I<br>&gt; handled optionals in https://github.com/apple/swift/pull/4438 for<br>&gt; imported function types; see comment<br>&gt; &lt;https://github.com/apple/swift/pull/4438#issuecomment-243645367&gt;.)<br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt; It would be a post-Swift-3 addition to the language to be able to support<br>&gt;&gt; more robust liveness tracking here. There may be interesting directions to<br>&gt;&gt; take this, with optional closures being the most common beneficiary.<br>&gt;&gt;<br>&gt;&gt; On Sep 7, 2016, at 3:33 PM, Shawn Erickson via swift-users &lt;<br>&gt;&gt; swift-users at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I see https://bugs.swift.org/browse/SR-2324 and<br>&gt;&gt; https://bugs.swift.org/browse/SR-2444 which looks related to this issue<br>&gt;&gt; and may explain the error I saw on &quot;the other side&quot; of this.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Wed, Sep 7, 2016 at 3:28 PM Shawn Erickson &lt;shawnce at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Yeah I actually have a few of those myself that I can no longer do.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Wed, Sep 7, 2016 at 3:26 PM Jon Shier &lt;jon at jonshier.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Perhaps relatedly, it no longer seems possible to mark typealiased<br>&gt;&gt;&gt;&gt; closures as @escaping. That was quite handy when you know that closures<br>&gt;&gt;&gt;&gt; will always be used asynchronously.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Sep 7, 2016, at 6:15 PM, Shawn Erickson via swift-users &lt;<br>&gt;&gt;&gt;&gt; swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I should note that this issue also appeared in an earlier variant of<br>&gt;&gt;&gt;&gt; Swift after the addition of @escaping but I was on vacation so didn&#39;t get a<br>&gt;&gt;&gt;&gt; chance to report it then. It isn&#39;t new with the Xcode 8 GM.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Wed, Sep 7, 2016 at 3:08 PM Shawn Erickson &lt;shawnce at gmail.com&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I like and fully supported the change to @escaping away from @noescape<br>&gt;&gt;&gt;&gt;&gt; however in a body of code that I am porting to the latest Swift 3 variant<br>&gt;&gt;&gt;&gt;&gt; (as found in Xcode 8 GM) I am hitting an issue for methods that take an<br>&gt;&gt;&gt;&gt;&gt; optional completion closure. If optional is involved I can&#39;t find a way to<br>&gt;&gt;&gt;&gt;&gt; apply @escape to the escaping closure. See the following for an basic<br>&gt;&gt;&gt;&gt;&gt; example...<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Is their a way to do what I need and/or is this an edge case in the<br>&gt;&gt;&gt;&gt;&gt; implementation of @escaping?<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; typealias MyCallback = (String)-&gt;()<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; // Happy<br>&gt;&gt;&gt;&gt;&gt; func foo1(bar: String, completion: ((String)-&gt;())) {<br>&gt;&gt;&gt;&gt;&gt;     completion(bar)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; // Happy<br>&gt;&gt;&gt;&gt;&gt; func foo2(bar: String, completion: MyCallback) {<br>&gt;&gt;&gt;&gt;&gt;     completion(bar)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; // Happy<br>&gt;&gt;&gt;&gt;&gt; func foo3(bar: String, completion: ((String)-&gt;())? = nil) {<br>&gt;&gt;&gt;&gt;&gt;     completion?(bar)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; // Happy<br>&gt;&gt;&gt;&gt;&gt; func foo4(bar: String, completion: MyCallback? = nil) {<br>&gt;&gt;&gt;&gt;&gt;     completion?(bar)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; // Happy<br>&gt;&gt;&gt;&gt;&gt; func foo5(bar: String, completion: Optional&lt;MyCallback&gt; = nil) {<br>&gt;&gt;&gt;&gt;&gt;     completion?(bar)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; // Happy<br>&gt;&gt;&gt;&gt;&gt; func foo6(bar: String, completion: @escaping (String)-&gt;()) {<br>&gt;&gt;&gt;&gt;&gt;     completion(bar)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; // Happy<br>&gt;&gt;&gt;&gt;&gt; func foo7(bar: String, completion: @escaping MyCallback) {<br>&gt;&gt;&gt;&gt;&gt;     completion(bar)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; // Unhappy...<br>&gt;&gt;&gt;&gt;&gt; // &quot;@escaping attribute only applies to function types&quot;<br>&gt;&gt;&gt;&gt;&gt; func foo8(bar: String, completion: @escaping ((String)-&gt;())? = nil) {<br>&gt;&gt;&gt;&gt;&gt;     completion?(bar)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; // Unhappy...<br>&gt;&gt;&gt;&gt;&gt; // &quot;@escaping attribute only applies to function types&quot;<br>&gt;&gt;&gt;&gt;&gt; func foo9(bar: String, completion: @escaping MyCallback? = nil) {<br>&gt;&gt;&gt;&gt;&gt;     completion?(bar)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; // Unhappy...<br>&gt;&gt;&gt;&gt;&gt; // &quot;@escaping attribute only applies to function types&quot;<br>&gt;&gt;&gt;&gt;&gt; func foo10(bar: String, completion: (@escaping ((String)-&gt;()))? = nil)<br>&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;     completion?(bar)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; // Unhappy...<br>&gt;&gt;&gt;&gt;&gt; // &quot;@escaping attribute only applies to function types&quot;<br>&gt;&gt;&gt;&gt;&gt; func foo11(bar: String, completion: (@escaping MyCallback)? = nil) {<br>&gt;&gt;&gt;&gt;&gt;     completion?(bar)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; // Unhappy...<br>&gt;&gt;&gt;&gt;&gt; // &quot;@escaping attribute only applies to function types&quot;<br>&gt;&gt;&gt;&gt;&gt; func foo12(bar: String, completion: Optional&lt;@escaping MyCallback&gt; =<br>&gt;&gt;&gt;&gt;&gt; nil) {<br>&gt;&gt;&gt;&gt;&gt;     completion?(bar)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt;&gt; swift-users at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt;<br>&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160908/360b06d3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>Swift 3 (Xcode 8 GM) issue with @escaping</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>September  8, 2016 at 03:00:00am</p></header><div class="content"><p>To more completely state what I find it a little strange.<br></p><p>The default was moved to be non-escaping since that is the better default<br>(for various reason) with @escaping being used to both inform the compiler<br>that something is intentionally escaping (yeah I meant to do that) and to<br>me it seem also helpful as a way to inform the user of the API that the<br>closure they are providing is escaping so they better understand the<br>requirements placed on that closure (e.g. it may not be called before the<br>called function returns, possible retain cycle issues, etc.).<br></p><p>So when using APIs I would look for @escaping as a way to know I need to<br>think a little more about the behavior of the closure and the func taking<br>the closure that I am calling. If I don&#39;t see it I may incorrectly assume<br>it isn&#39;t escaping when intact it may have be implicitly escaping.<br></p><p>Anyway my thoughts on this...<br></p><p>-Shawn<br></p><p><br></p><p>On Wed, Sep 7, 2016 at 7:08 PM Shawn Erickson &lt;shawnce at gmail.com&gt; wrote:<br></p><p>&gt; It just seems a little strange that @escaping only shows up once in the<br>&gt; following example (real) function of mine yet both of them are escaping.<br>&gt; This fixit message should maybe imply that @escaping isn&#39;t needed since the<br>&gt; optional one is already implicitly considered escaping? ...it is kinda<br>&gt; confusing when first jumping over to Swift if at one point you are told you<br>&gt; need to added @escaping (the non-optional one) yet you are told @escaping<br>&gt; isn&#39;t valid for the optional one despite it needing to be escaping (e.g.<br>&gt; the fixit doesn&#39;t really explain that is already escaping).<br>&gt;<br>&gt;     func httpGet&lt;T&gt;(path: String, parameters: [String:String] = [:],<br>&gt;                     needsAuth: Bool = true, queue: DispatchQueue =<br>&gt; DispatchQueue.main,<br>&gt;                     completion: ObjectFetchCallback&lt;T&gt;?, importer:<br>&gt; @escaping HttpImporterCallback&lt;T&gt;)<br>&gt;<br>&gt; -Shawn<br>&gt;<br>&gt; On Wed, Sep 7, 2016 at 6:51 PM Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; On Wed, Sep 7, 2016 at 5:54 PM, Michael Ilseman via swift-users &lt;<br>&gt;&gt; swift-users at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; I implemented a better (i.e. correct) diagnostic message for this at<br>&gt;&gt;&gt; https://github.com/apple/swift/pull/4670. I want to also do a better<br>&gt;&gt;&gt; diagnostic specifically for aggregate parameters to functions (e.g.<br>&gt;&gt;&gt; optional closures), but that requires more work in the type checker.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Basically, @escaping is valid only on closures in function parameter<br>&gt;&gt;&gt; position. The noescape-by-default rule only applies to these closures at<br>&gt;&gt;&gt; function parameter position, otherwise they are escaping. Aggregates, such<br>&gt;&gt;&gt; as enums with associated values (e.g. Optional), tuples, structs, etc., if<br>&gt;&gt;&gt; they have closures, follow the default rules for closures that are not at<br>&gt;&gt;&gt; function parameter position, i.e. they are escaping.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Shouldn&#39;t it be possible to allow distinguishing @escaping/@noescape for<br>&gt;&gt; aggregates like these, at least for the simple case of Optional?  (I<br>&gt;&gt; handled optionals in https://github.com/apple/swift/pull/4438 for<br>&gt;&gt; imported function types; see comment<br>&gt;&gt; &lt;https://github.com/apple/swift/pull/4438#issuecomment-243645367&gt;.)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It would be a post-Swift-3 addition to the language to be able to<br>&gt;&gt;&gt; support more robust liveness tracking here. There may be interesting<br>&gt;&gt;&gt; directions to take this, with optional closures being the most common<br>&gt;&gt;&gt; beneficiary.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Sep 7, 2016, at 3:33 PM, Shawn Erickson via swift-users &lt;<br>&gt;&gt;&gt; swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I see https://bugs.swift.org/browse/SR-2324 and<br>&gt;&gt;&gt; https://bugs.swift.org/browse/SR-2444 which looks related to this issue<br>&gt;&gt;&gt; and may explain the error I saw on &quot;the other side&quot; of this.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Wed, Sep 7, 2016 at 3:28 PM Shawn Erickson &lt;shawnce at gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Yeah I actually have a few of those myself that I can no longer do.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Wed, Sep 7, 2016 at 3:26 PM Jon Shier &lt;jon at jonshier.com&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Perhaps relatedly, it no longer seems possible to mark typealiased<br>&gt;&gt;&gt;&gt;&gt; closures as @escaping. That was quite handy when you know that closures<br>&gt;&gt;&gt;&gt;&gt; will always be used asynchronously.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Sep 7, 2016, at 6:15 PM, Shawn Erickson via swift-users &lt;<br>&gt;&gt;&gt;&gt;&gt; swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I should note that this issue also appeared in an earlier variant of<br>&gt;&gt;&gt;&gt;&gt; Swift after the addition of @escaping but I was on vacation so didn&#39;t get a<br>&gt;&gt;&gt;&gt;&gt; chance to report it then. It isn&#39;t new with the Xcode 8 GM.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Wed, Sep 7, 2016 at 3:08 PM Shawn Erickson &lt;shawnce at gmail.com&gt;<br>&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; I like and fully supported the change to @escaping away from<br>&gt;&gt;&gt;&gt;&gt;&gt; @noescape however in a body of code that I am porting to the latest Swift 3<br>&gt;&gt;&gt;&gt;&gt;&gt; variant (as found in Xcode 8 GM) I am hitting an issue for methods that<br>&gt;&gt;&gt;&gt;&gt;&gt; take an optional completion closure. If optional is involved I can&#39;t find a<br>&gt;&gt;&gt;&gt;&gt;&gt; way to apply @escape to the escaping closure. See the following for an<br>&gt;&gt;&gt;&gt;&gt;&gt; basic example...<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Is their a way to do what I need and/or is this an edge case in the<br>&gt;&gt;&gt;&gt;&gt;&gt; implementation of @escaping?<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; typealias MyCallback = (String)-&gt;()<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; // Happy<br>&gt;&gt;&gt;&gt;&gt;&gt; func foo1(bar: String, completion: ((String)-&gt;())) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     completion(bar)<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; // Happy<br>&gt;&gt;&gt;&gt;&gt;&gt; func foo2(bar: String, completion: MyCallback) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     completion(bar)<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; // Happy<br>&gt;&gt;&gt;&gt;&gt;&gt; func foo3(bar: String, completion: ((String)-&gt;())? = nil) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     completion?(bar)<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; // Happy<br>&gt;&gt;&gt;&gt;&gt;&gt; func foo4(bar: String, completion: MyCallback? = nil) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     completion?(bar)<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; // Happy<br>&gt;&gt;&gt;&gt;&gt;&gt; func foo5(bar: String, completion: Optional&lt;MyCallback&gt; = nil) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     completion?(bar)<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; // Happy<br>&gt;&gt;&gt;&gt;&gt;&gt; func foo6(bar: String, completion: @escaping (String)-&gt;()) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     completion(bar)<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; // Happy<br>&gt;&gt;&gt;&gt;&gt;&gt; func foo7(bar: String, completion: @escaping MyCallback) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     completion(bar)<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; // Unhappy...<br>&gt;&gt;&gt;&gt;&gt;&gt; // &quot;@escaping attribute only applies to function types&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt; func foo8(bar: String, completion: @escaping ((String)-&gt;())? = nil) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     completion?(bar)<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; // Unhappy...<br>&gt;&gt;&gt;&gt;&gt;&gt; // &quot;@escaping attribute only applies to function types&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt; func foo9(bar: String, completion: @escaping MyCallback? = nil) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     completion?(bar)<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; // Unhappy...<br>&gt;&gt;&gt;&gt;&gt;&gt; // &quot;@escaping attribute only applies to function types&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt; func foo10(bar: String, completion: (@escaping ((String)-&gt;()))? =<br>&gt;&gt;&gt;&gt;&gt;&gt; nil) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     completion?(bar)<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; // Unhappy...<br>&gt;&gt;&gt;&gt;&gt;&gt; // &quot;@escaping attribute only applies to function types&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt; func foo11(bar: String, completion: (@escaping MyCallback)? = nil) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     completion?(bar)<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; // Unhappy...<br>&gt;&gt;&gt;&gt;&gt;&gt; // &quot;@escaping attribute only applies to function types&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt; func foo12(bar: String, completion: Optional&lt;@escaping MyCallback&gt; =<br>&gt;&gt;&gt;&gt;&gt;&gt; nil) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     completion?(bar)<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-users at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt; swift-users at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt; swift-users at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160908/8b635a3f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>Swift 3 (Xcode 8 GM) issue with @escaping</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>September  8, 2016 at 04:00:00am</p></header><div class="content"><p>I seem to have hit a possibly related @escaping issue...<br></p><p>The following code worked without issue under Swift 2.x and earlier<br>variants of Swift 3 but after the @escaping change (fairly sure that is<br>what is at fault) it no longer compiles.<br></p><p>protocol Foo {<br>    // Happy<br>    func visitValues&lt;T&gt;(visitors: [(key: String, body: (T) throws -&gt;<br>Void)]) throws<br></p><p>    // Happy<br>    func visitValues&lt;T&gt;(throwOnWrongType: Bool, visitors: [(key: String,<br>body: (T) throws -&gt; Void)]) throws<br>}<br></p><p>protocol FooBar { // IGNORE ME - NOT PART OF ORIGINAL CODE<br>    // Unhappy - this is appearntly expected given prior emails in this<br>thread<br>    // @escaping may only be applied to parameters of function type<br>    func visitValues&lt;T&gt;(visitors: [(key: String, body: @escaping (T) throws<br>-&gt; Void)]) throws<br></p><p>    // Unhappy - this is appearntly expected given prior emails in this<br>thread<br>    // @escaping may only be applied to parameters of function type<br>    func visitValues&lt;T&gt;(throwOnWrongType: Bool, visitors: [(key: String,<br>body: @escaping (T) throws -&gt; Void)]) throws<br>}<br></p><p>// Provide a default implementation for the simple visitor version<br>extension Foo {<br>    // Happy<br>    func visitValues&lt;T&gt;(visitors: [(String, body: (T) throws -&gt; Void)])<br>throws {<br>        try self.visitValues(throwOnWrongType: false, visitors: visitors)<br>    }<br>}<br></p><p>// Unhappy<br>// error: type &#39;RealFoo&#39; does not conform to protocol &#39;Foo&#39;<br>struct RealFoo : Foo {<br>    // Happy<br>    func visitValues&lt;T&gt;(throwOnWrongType: Bool, visitors: [(key: String,<br>body: (T) throws -&gt; Void)]) throws {<br>        // do stuff...<br>    }<br></p><p>    // error: MyPlayground.playground:23:8: error: type &#39;RealFoo&#39; does not<br>conform to protocol &#39;Foo&#39;<br>    //struct RealFoo : Foo {<br>    //    ^<br>    //<br>    //    MyPlayground.playground:16:10: note: candidate has non-matching<br>type &#39;&lt;Self, T&gt; (visitors: [(String, body: (T) throws -&gt; Void)]) throws -&gt;<br>()&#39; (aka &#39;&lt;τ_0_0, τ_1_0&gt; (visitors: Array&lt;(String, body: (τ_1_0) throws -&gt;<br>())&gt;) throws -&gt; ()&#39;)<br>    //    func visitValues&lt;T&gt;(visitors: [(String, body: (T) throws -&gt;<br>Void)]) throws {<br></p><p>    // The fix-it suggestion for &quot;error: type &#39;RealFoo&#39; does not conform to<br>protocol &#39;Foo&#39;&quot; inserts the following which makes<br>    // the &quot;not conform&quot; error go away however it doesn&#39;t compile because<br>of @escaping<br>    // Unhappy<br>    // @escaping may only be applied to parameters of function type<br>    internal func visitValues&lt;T&gt;(visitors: [(key: String, body: @escaping<br>(T) throws -&gt; Void)]) throws { // NOT PART OF ORIGINAL CODE<br>    }<br>    // The above shouldn&#39;t be needed since an implementation is provided<br>via an extension on protocol Foo right?<br>}<br></p><p>On Wed, Sep 7, 2016 at 8:06 PM Shawn Erickson &lt;shawnce at gmail.com&gt; wrote:<br></p><p>&gt; To more completely state what I find it a little strange.<br>&gt;<br>&gt; The default was moved to be non-escaping since that is the better default<br>&gt; (for various reason) with @escaping being used to both inform the compiler<br>&gt; that something is intentionally escaping (yeah I meant to do that) and to<br>&gt; me it seem also helpful as a way to inform the user of the API that the<br>&gt; closure they are providing is escaping so they better understand the<br>&gt; requirements placed on that closure (e.g. it may not be called before the<br>&gt; called function returns, possible retain cycle issues, etc.).<br>&gt;<br>&gt; So when using APIs I would look for @escaping as a way to know I need to<br>&gt; think a little more about the behavior of the closure and the func taking<br>&gt; the closure that I am calling. If I don&#39;t see it I may incorrectly assume<br>&gt; it isn&#39;t escaping when intact it may have be implicitly escaping.<br>&gt;<br>&gt; Anyway my thoughts on this...<br>&gt;<br>&gt; -Shawn<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Wed, Sep 7, 2016 at 7:08 PM Shawn Erickson &lt;shawnce at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; It just seems a little strange that @escaping only shows up once in the<br>&gt;&gt; following example (real) function of mine yet both of them are escaping.<br>&gt;&gt; This fixit message should maybe imply that @escaping isn&#39;t needed since the<br>&gt;&gt; optional one is already implicitly considered escaping? ...it is kinda<br>&gt;&gt; confusing when first jumping over to Swift if at one point you are told you<br>&gt;&gt; need to added @escaping (the non-optional one) yet you are told @escaping<br>&gt;&gt; isn&#39;t valid for the optional one despite it needing to be escaping (e.g.<br>&gt;&gt; the fixit doesn&#39;t really explain that is already escaping).<br>&gt;&gt;<br>&gt;&gt;     func httpGet&lt;T&gt;(path: String, parameters: [String:String] = [:],<br>&gt;&gt;                     needsAuth: Bool = true, queue: DispatchQueue =<br>&gt;&gt; DispatchQueue.main,<br>&gt;&gt;                     completion: ObjectFetchCallback&lt;T&gt;?, importer:<br>&gt;&gt; @escaping HttpImporterCallback&lt;T&gt;)<br>&gt;&gt;<br>&gt;&gt; -Shawn<br>&gt;&gt;<br>&gt;&gt; On Wed, Sep 7, 2016 at 6:51 PM Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; On Wed, Sep 7, 2016 at 5:54 PM, Michael Ilseman via swift-users &lt;<br>&gt;&gt;&gt; swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I implemented a better (i.e. correct) diagnostic message for this at<br>&gt;&gt;&gt;&gt; https://github.com/apple/swift/pull/4670. I want to also do a better<br>&gt;&gt;&gt;&gt; diagnostic specifically for aggregate parameters to functions (e.g.<br>&gt;&gt;&gt;&gt; optional closures), but that requires more work in the type checker.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Basically, @escaping is valid only on closures in function parameter<br>&gt;&gt;&gt;&gt; position. The noescape-by-default rule only applies to these closures at<br>&gt;&gt;&gt;&gt; function parameter position, otherwise they are escaping. Aggregates, such<br>&gt;&gt;&gt;&gt; as enums with associated values (e.g. Optional), tuples, structs, etc., if<br>&gt;&gt;&gt;&gt; they have closures, follow the default rules for closures that are not at<br>&gt;&gt;&gt;&gt; function parameter position, i.e. they are escaping.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Shouldn&#39;t it be possible to allow distinguishing @escaping/@noescape for<br>&gt;&gt;&gt; aggregates like these, at least for the simple case of Optional?  (I<br>&gt;&gt;&gt; handled optionals in https://github.com/apple/swift/pull/4438 for<br>&gt;&gt;&gt; imported function types; see comment<br>&gt;&gt;&gt; &lt;https://github.com/apple/swift/pull/4438#issuecomment-243645367&gt;.)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; It would be a post-Swift-3 addition to the language to be able to<br>&gt;&gt;&gt;&gt; support more robust liveness tracking here. There may be interesting<br>&gt;&gt;&gt;&gt; directions to take this, with optional closures being the most common<br>&gt;&gt;&gt;&gt; beneficiary.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Sep 7, 2016, at 3:33 PM, Shawn Erickson via swift-users &lt;<br>&gt;&gt;&gt;&gt; swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I see https://bugs.swift.org/browse/SR-2324 and<br>&gt;&gt;&gt;&gt; https://bugs.swift.org/browse/SR-2444 which looks related to this<br>&gt;&gt;&gt;&gt; issue and may explain the error I saw on &quot;the other side&quot; of this.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Wed, Sep 7, 2016 at 3:28 PM Shawn Erickson &lt;shawnce at gmail.com&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Yeah I actually have a few of those myself that I can no longer do.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Wed, Sep 7, 2016 at 3:26 PM Jon Shier &lt;jon at jonshier.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Perhaps relatedly, it no longer seems possible to mark typealiased<br>&gt;&gt;&gt;&gt;&gt;&gt; closures as @escaping. That was quite handy when you know that closures<br>&gt;&gt;&gt;&gt;&gt;&gt; will always be used asynchronously.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On Sep 7, 2016, at 6:15 PM, Shawn Erickson via swift-users &lt;<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; I should note that this issue also appeared in an earlier variant of<br>&gt;&gt;&gt;&gt;&gt;&gt; Swift after the addition of @escaping but I was on vacation so didn&#39;t get a<br>&gt;&gt;&gt;&gt;&gt;&gt; chance to report it then. It isn&#39;t new with the Xcode 8 GM.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Sep 7, 2016 at 3:08 PM Shawn Erickson &lt;shawnce at gmail.com&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I like and fully supported the change to @escaping away from<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; @noescape however in a body of code that I am porting to the latest Swift 3<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; variant (as found in Xcode 8 GM) I am hitting an issue for methods that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; take an optional completion closure. If optional is involved I can&#39;t find a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; way to apply @escape to the escaping closure. See the following for an<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; basic example...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Is their a way to do what I need and/or is this an edge case in the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; implementation of @escaping?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; typealias MyCallback = (String)-&gt;()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Happy<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; func foo1(bar: String, completion: ((String)-&gt;())) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     completion(bar)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Happy<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; func foo2(bar: String, completion: MyCallback) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     completion(bar)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Happy<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; func foo3(bar: String, completion: ((String)-&gt;())? = nil) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     completion?(bar)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Happy<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; func foo4(bar: String, completion: MyCallback? = nil) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     completion?(bar)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Happy<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; func foo5(bar: String, completion: Optional&lt;MyCallback&gt; = nil) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     completion?(bar)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Happy<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; func foo6(bar: String, completion: @escaping (String)-&gt;()) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     completion(bar)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Happy<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; func foo7(bar: String, completion: @escaping MyCallback) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     completion(bar)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Unhappy...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // &quot;@escaping attribute only applies to function types&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; func foo8(bar: String, completion: @escaping ((String)-&gt;())? = nil) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     completion?(bar)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Unhappy...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // &quot;@escaping attribute only applies to function types&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; func foo9(bar: String, completion: @escaping MyCallback? = nil) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     completion?(bar)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Unhappy...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // &quot;@escaping attribute only applies to function types&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; func foo10(bar: String, completion: (@escaping ((String)-&gt;()))? =<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; nil) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     completion?(bar)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Unhappy...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // &quot;@escaping attribute only applies to function types&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; func foo11(bar: String, completion: (@escaping MyCallback)? = nil) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     completion?(bar)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Unhappy...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // &quot;@escaping attribute only applies to function types&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; func foo12(bar: String, completion: Optional&lt;@escaping MyCallback&gt; =<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; nil) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     completion?(bar)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-users at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt;&gt; swift-users at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt;&gt; swift-users at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160908/3d068387/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>Swift 3 (Xcode 8 GM) issue with @escaping</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>September  8, 2016 at 04:00:00am</p></header><div class="content"><p>Oh I also meant to state that original version of this visitor was marked<br>as @noescape since it doesn&#39;t in the implementation. It looks like I have<br>lost that ability with the @escaping change since appears to assume it is<br>escaping in this situation now?<br></p><p>-Shawn<br></p><p>On Wed, Sep 7, 2016 at 9:16 PM Shawn Erickson &lt;shawnce at gmail.com&gt; wrote:<br></p><p>&gt; I seem to have hit a possibly related @escaping issue...<br>&gt;<br>&gt; The following code worked without issue under Swift 2.x and earlier<br>&gt; variants of Swift 3 but after the @escaping change (fairly sure that is<br>&gt; what is at fault) it no longer compiles.<br>&gt;<br>&gt; protocol Foo {<br>&gt;     // Happy<br>&gt;     func visitValues&lt;T&gt;(visitors: [(key: String, body: (T) throws -&gt;<br>&gt; Void)]) throws<br>&gt;<br>&gt;     // Happy<br>&gt;     func visitValues&lt;T&gt;(throwOnWrongType: Bool, visitors: [(key: String,<br>&gt; body: (T) throws -&gt; Void)]) throws<br>&gt; }<br>&gt;<br>&gt; protocol FooBar { // IGNORE ME - NOT PART OF ORIGINAL CODE<br>&gt;     // Unhappy - this is appearntly expected given prior emails in this<br>&gt; thread<br>&gt;     // @escaping may only be applied to parameters of function type<br>&gt;     func visitValues&lt;T&gt;(visitors: [(key: String, body: @escaping (T)<br>&gt; throws -&gt; Void)]) throws<br>&gt;<br>&gt;     // Unhappy - this is appearntly expected given prior emails in this<br>&gt; thread<br>&gt;     // @escaping may only be applied to parameters of function type<br>&gt;     func visitValues&lt;T&gt;(throwOnWrongType: Bool, visitors: [(key: String,<br>&gt; body: @escaping (T) throws -&gt; Void)]) throws<br>&gt; }<br>&gt;<br>&gt; // Provide a default implementation for the simple visitor version<br>&gt; extension Foo {<br>&gt;     // Happy<br>&gt;     func visitValues&lt;T&gt;(visitors: [(String, body: (T) throws -&gt; Void)])<br>&gt; throws {<br>&gt;         try self.visitValues(throwOnWrongType: false, visitors: visitors)<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; // Unhappy<br>&gt; // error: type &#39;RealFoo&#39; does not conform to protocol &#39;Foo&#39;<br>&gt; struct RealFoo : Foo {<br>&gt;     // Happy<br>&gt;     func visitValues&lt;T&gt;(throwOnWrongType: Bool, visitors: [(key: String,<br>&gt; body: (T) throws -&gt; Void)]) throws {<br>&gt;         // do stuff...<br>&gt;     }<br>&gt;<br>&gt;     // error: MyPlayground.playground:23:8: error: type &#39;RealFoo&#39; does not<br>&gt; conform to protocol &#39;Foo&#39;<br>&gt;     //struct RealFoo : Foo {<br>&gt;     //    ^<br>&gt;     //<br>&gt;     //    MyPlayground.playground:16:10: note: candidate has non-matching<br>&gt; type &#39;&lt;Self, T&gt; (visitors: [(String, body: (T) throws -&gt; Void)]) throws -&gt;<br>&gt; ()&#39; (aka &#39;&lt;τ_0_0, τ_1_0&gt; (visitors: Array&lt;(String, body: (τ_1_0) throws -&gt;<br>&gt; ())&gt;) throws -&gt; ()&#39;)<br>&gt;     //    func visitValues&lt;T&gt;(visitors: [(String, body: (T) throws -&gt;<br>&gt; Void)]) throws {<br>&gt;<br>&gt;     // The fix-it suggestion for &quot;error: type &#39;RealFoo&#39; does not conform<br>&gt; to protocol &#39;Foo&#39;&quot; inserts the following which makes<br>&gt;     // the &quot;not conform&quot; error go away however it doesn&#39;t compile because<br>&gt; of @escaping<br>&gt;     // Unhappy<br>&gt;     // @escaping may only be applied to parameters of function type<br>&gt;     internal func visitValues&lt;T&gt;(visitors: [(key: String, body: @escaping<br>&gt; (T) throws -&gt; Void)]) throws { // NOT PART OF ORIGINAL CODE<br>&gt;     }<br>&gt;     // The above shouldn&#39;t be needed since an implementation is provided<br>&gt; via an extension on protocol Foo right?<br>&gt; }<br>&gt;<br>&gt; On Wed, Sep 7, 2016 at 8:06 PM Shawn Erickson &lt;shawnce at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; To more completely state what I find it a little strange.<br>&gt;&gt;<br>&gt;&gt; The default was moved to be non-escaping since that is the better default<br>&gt;&gt; (for various reason) with @escaping being used to both inform the compiler<br>&gt;&gt; that something is intentionally escaping (yeah I meant to do that) and to<br>&gt;&gt; me it seem also helpful as a way to inform the user of the API that the<br>&gt;&gt; closure they are providing is escaping so they better understand the<br>&gt;&gt; requirements placed on that closure (e.g. it may not be called before the<br>&gt;&gt; called function returns, possible retain cycle issues, etc.).<br>&gt;&gt;<br>&gt;&gt; So when using APIs I would look for @escaping as a way to know I need to<br>&gt;&gt; think a little more about the behavior of the closure and the func taking<br>&gt;&gt; the closure that I am calling. If I don&#39;t see it I may incorrectly assume<br>&gt;&gt; it isn&#39;t escaping when intact it may have be implicitly escaping.<br>&gt;&gt;<br>&gt;&gt; Anyway my thoughts on this...<br>&gt;&gt;<br>&gt;&gt; -Shawn<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Wed, Sep 7, 2016 at 7:08 PM Shawn Erickson &lt;shawnce at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; It just seems a little strange that @escaping only shows up once in the<br>&gt;&gt;&gt; following example (real) function of mine yet both of them are escaping.<br>&gt;&gt;&gt; This fixit message should maybe imply that @escaping isn&#39;t needed since the<br>&gt;&gt;&gt; optional one is already implicitly considered escaping? ...it is kinda<br>&gt;&gt;&gt; confusing when first jumping over to Swift if at one point you are told you<br>&gt;&gt;&gt; need to added @escaping (the non-optional one) yet you are told @escaping<br>&gt;&gt;&gt; isn&#39;t valid for the optional one despite it needing to be escaping (e.g.<br>&gt;&gt;&gt; the fixit doesn&#39;t really explain that is already escaping).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     func httpGet&lt;T&gt;(path: String, parameters: [String:String] = [:],<br>&gt;&gt;&gt;                     needsAuth: Bool = true, queue: DispatchQueue =<br>&gt;&gt;&gt; DispatchQueue.main,<br>&gt;&gt;&gt;                     completion: ObjectFetchCallback&lt;T&gt;?, importer:<br>&gt;&gt;&gt; @escaping HttpImporterCallback&lt;T&gt;)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -Shawn<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Wed, Sep 7, 2016 at 6:51 PM Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Wed, Sep 7, 2016 at 5:54 PM, Michael Ilseman via swift-users &lt;<br>&gt;&gt;&gt;&gt; swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I implemented a better (i.e. correct) diagnostic message for this at<br>&gt;&gt;&gt;&gt;&gt; https://github.com/apple/swift/pull/4670. I want to also do a better<br>&gt;&gt;&gt;&gt;&gt; diagnostic specifically for aggregate parameters to functions (e.g.<br>&gt;&gt;&gt;&gt;&gt; optional closures), but that requires more work in the type checker.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Basically, @escaping is valid only on closures in function parameter<br>&gt;&gt;&gt;&gt;&gt; position. The noescape-by-default rule only applies to these closures at<br>&gt;&gt;&gt;&gt;&gt; function parameter position, otherwise they are escaping. Aggregates, such<br>&gt;&gt;&gt;&gt;&gt; as enums with associated values (e.g. Optional), tuples, structs, etc., if<br>&gt;&gt;&gt;&gt;&gt; they have closures, follow the default rules for closures that are not at<br>&gt;&gt;&gt;&gt;&gt; function parameter position, i.e. they are escaping.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Shouldn&#39;t it be possible to allow distinguishing @escaping/@noescape<br>&gt;&gt;&gt;&gt; for aggregates like these, at least for the simple case of Optional?  (I<br>&gt;&gt;&gt;&gt; handled optionals in https://github.com/apple/swift/pull/4438 for<br>&gt;&gt;&gt;&gt; imported function types; see comment<br>&gt;&gt;&gt;&gt; &lt;https://github.com/apple/swift/pull/4438#issuecomment-243645367&gt;.)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; It would be a post-Swift-3 addition to the language to be able to<br>&gt;&gt;&gt;&gt;&gt; support more robust liveness tracking here. There may be interesting<br>&gt;&gt;&gt;&gt;&gt; directions to take this, with optional closures being the most common<br>&gt;&gt;&gt;&gt;&gt; beneficiary.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Sep 7, 2016, at 3:33 PM, Shawn Erickson via swift-users &lt;<br>&gt;&gt;&gt;&gt;&gt; swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I see https://bugs.swift.org/browse/SR-2324 and<br>&gt;&gt;&gt;&gt;&gt; https://bugs.swift.org/browse/SR-2444 which looks related to this<br>&gt;&gt;&gt;&gt;&gt; issue and may explain the error I saw on &quot;the other side&quot; of this.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Wed, Sep 7, 2016 at 3:28 PM Shawn Erickson &lt;shawnce at gmail.com&gt;<br>&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Yeah I actually have a few of those myself that I can no longer do.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Sep 7, 2016 at 3:26 PM Jon Shier &lt;jon at jonshier.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Perhaps relatedly, it no longer seems possible to mark typealiased<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; closures as @escaping. That was quite handy when you know that closures<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; will always be used asynchronously.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Sep 7, 2016, at 6:15 PM, Shawn Erickson via swift-users &lt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I should note that this issue also appeared in an earlier variant of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift after the addition of @escaping but I was on vacation so didn&#39;t get a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; chance to report it then. It isn&#39;t new with the Xcode 8 GM.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Sep 7, 2016 at 3:08 PM Shawn Erickson &lt;shawnce at gmail.com&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I like and fully supported the change to @escaping away from<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; @noescape however in a body of code that I am porting to the latest Swift 3<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; variant (as found in Xcode 8 GM) I am hitting an issue for methods that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; take an optional completion closure. If optional is involved I can&#39;t find a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; way to apply @escape to the escaping closure. See the following for an<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; basic example...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Is their a way to do what I need and/or is this an edge case in the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; implementation of @escaping?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; typealias MyCallback = (String)-&gt;()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Happy<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func foo1(bar: String, completion: ((String)-&gt;())) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     completion(bar)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Happy<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func foo2(bar: String, completion: MyCallback) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     completion(bar)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Happy<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func foo3(bar: String, completion: ((String)-&gt;())? = nil) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     completion?(bar)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Happy<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func foo4(bar: String, completion: MyCallback? = nil) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     completion?(bar)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Happy<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func foo5(bar: String, completion: Optional&lt;MyCallback&gt; = nil) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     completion?(bar)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Happy<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func foo6(bar: String, completion: @escaping (String)-&gt;()) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     completion(bar)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Happy<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func foo7(bar: String, completion: @escaping MyCallback) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     completion(bar)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Unhappy...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // &quot;@escaping attribute only applies to function types&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func foo8(bar: String, completion: @escaping ((String)-&gt;())? = nil)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     completion?(bar)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Unhappy...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // &quot;@escaping attribute only applies to function types&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func foo9(bar: String, completion: @escaping MyCallback? = nil) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     completion?(bar)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Unhappy...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // &quot;@escaping attribute only applies to function types&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func foo10(bar: String, completion: (@escaping ((String)-&gt;()))? =<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; nil) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     completion?(bar)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Unhappy...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // &quot;@escaping attribute only applies to function types&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func foo11(bar: String, completion: (@escaping MyCallback)? = nil) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     completion?(bar)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Unhappy...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // &quot;@escaping attribute only applies to function types&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func foo12(bar: String, completion: Optional&lt;@escaping MyCallback&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; = nil) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     completion?(bar)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-users at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-users at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-users at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160908/f58fe628/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>Swift 3 (Xcode 8 GM) issue with @escaping</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>September  9, 2016 at 12:00:00am</p></header><div class="content"><p>Michael any ideas about how to deal with the following? It seems like at<br>least a bug in the fix-it.<br></p><p>I assume I should open a bug on this?<br></p><p>-Shawn<br></p><p>On Wed, Sep 7, 2016 at 9:16 PM Shawn Erickson &lt;shawnce at gmail.com&gt; wrote:<br></p><p>&gt; I seem to have hit a possibly related @escaping issue...<br>&gt;<br>&gt; The following code worked without issue under Swift 2.x and earlier<br>&gt; variants of Swift 3 but after the @escaping change (fairly sure that is<br>&gt; what is at fault) it no longer compiles.<br>&gt;<br>&gt; protocol Foo {<br>&gt;     // Happy<br>&gt;     func visitValues&lt;T&gt;(visitors: [(key: String, body: (T) throws -&gt;<br>&gt; Void)]) throws<br>&gt;<br>&gt;     // Happy<br>&gt;     func visitValues&lt;T&gt;(throwOnWrongType: Bool, visitors: [(key: String,<br>&gt; body: (T) throws -&gt; Void)]) throws<br>&gt; }<br>&gt;<br>&gt; protocol FooBar { // IGNORE ME - NOT PART OF ORIGINAL CODE<br>&gt;     // Unhappy - this is appearntly expected given prior emails in this<br>&gt; thread<br>&gt;     // @escaping may only be applied to parameters of function type<br>&gt;     func visitValues&lt;T&gt;(visitors: [(key: String, body: @escaping (T)<br>&gt; throws -&gt; Void)]) throws<br>&gt;<br>&gt;     // Unhappy - this is appearntly expected given prior emails in this<br>&gt; thread<br>&gt;     // @escaping may only be applied to parameters of function type<br>&gt;     func visitValues&lt;T&gt;(throwOnWrongType: Bool, visitors: [(key: String,<br>&gt; body: @escaping (T) throws -&gt; Void)]) throws<br>&gt; }<br>&gt;<br>&gt; // Provide a default implementation for the simple visitor version<br>&gt; extension Foo {<br>&gt;     // Happy<br>&gt;     func visitValues&lt;T&gt;(visitors: [(String, body: (T) throws -&gt; Void)])<br>&gt; throws {<br>&gt;         try self.visitValues(throwOnWrongType: false, visitors: visitors)<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; // Unhappy<br>&gt; // error: type &#39;RealFoo&#39; does not conform to protocol &#39;Foo&#39;<br>&gt; struct RealFoo : Foo {<br>&gt;     // Happy<br>&gt;     func visitValues&lt;T&gt;(throwOnWrongType: Bool, visitors: [(key: String,<br>&gt; body: (T) throws -&gt; Void)]) throws {<br>&gt;         // do stuff...<br>&gt;     }<br>&gt;<br>&gt;     // error: MyPlayground.playground:23:8: error: type &#39;RealFoo&#39; does not<br>&gt; conform to protocol &#39;Foo&#39;<br>&gt;     //struct RealFoo : Foo {<br>&gt;     //    ^<br>&gt;     //<br>&gt;     //    MyPlayground.playground:16:10: note: candidate has non-matching<br>&gt; type &#39;&lt;Self, T&gt; (visitors: [(String, body: (T) throws -&gt; Void)]) throws -&gt;<br>&gt; ()&#39; (aka &#39;&lt;τ_0_0, τ_1_0&gt; (visitors: Array&lt;(String, body: (τ_1_0) throws -&gt;<br>&gt; ())&gt;) throws -&gt; ()&#39;)<br>&gt;     //    func visitValues&lt;T&gt;(visitors: [(String, body: (T) throws -&gt;<br>&gt; Void)]) throws {<br>&gt;<br>&gt;     // The fix-it suggestion for &quot;error: type &#39;RealFoo&#39; does not conform<br>&gt; to protocol &#39;Foo&#39;&quot; inserts the following which makes<br>&gt;     // the &quot;not conform&quot; error go away however it doesn&#39;t compile because<br>&gt; of @escaping<br>&gt;     // Unhappy<br>&gt;     // @escaping may only be applied to parameters of function type<br>&gt;     internal func visitValues&lt;T&gt;(visitors: [(key: String, body: @escaping<br>&gt; (T) throws -&gt; Void)]) throws { // NOT PART OF ORIGINAL CODE<br>&gt;     }<br>&gt;     // The above shouldn&#39;t be needed since an implementation is provided<br>&gt; via an extension on protocol Foo right?<br>&gt; }<br>&gt;<br>&gt; On Wed, Sep 7, 2016 at 8:06 PM Shawn Erickson &lt;shawnce at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; To more completely state what I find it a little strange.<br>&gt;&gt;<br>&gt;&gt; The default was moved to be non-escaping since that is the better default<br>&gt;&gt; (for various reason) with @escaping being used to both inform the compiler<br>&gt;&gt; that something is intentionally escaping (yeah I meant to do that) and to<br>&gt;&gt; me it seem also helpful as a way to inform the user of the API that the<br>&gt;&gt; closure they are providing is escaping so they better understand the<br>&gt;&gt; requirements placed on that closure (e.g. it may not be called before the<br>&gt;&gt; called function returns, possible retain cycle issues, etc.).<br>&gt;&gt;<br>&gt;&gt; So when using APIs I would look for @escaping as a way to know I need to<br>&gt;&gt; think a little more about the behavior of the closure and the func taking<br>&gt;&gt; the closure that I am calling. If I don&#39;t see it I may incorrectly assume<br>&gt;&gt; it isn&#39;t escaping when intact it may have be implicitly escaping.<br>&gt;&gt;<br>&gt;&gt; Anyway my thoughts on this...<br>&gt;&gt;<br>&gt;&gt; -Shawn<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Wed, Sep 7, 2016 at 7:08 PM Shawn Erickson &lt;shawnce at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; It just seems a little strange that @escaping only shows up once in the<br>&gt;&gt;&gt; following example (real) function of mine yet both of them are escaping.<br>&gt;&gt;&gt; This fixit message should maybe imply that @escaping isn&#39;t needed since the<br>&gt;&gt;&gt; optional one is already implicitly considered escaping? ...it is kinda<br>&gt;&gt;&gt; confusing when first jumping over to Swift if at one point you are told you<br>&gt;&gt;&gt; need to added @escaping (the non-optional one) yet you are told @escaping<br>&gt;&gt;&gt; isn&#39;t valid for the optional one despite it needing to be escaping (e.g.<br>&gt;&gt;&gt; the fixit doesn&#39;t really explain that is already escaping).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     func httpGet&lt;T&gt;(path: String, parameters: [String:String] = [:],<br>&gt;&gt;&gt;                     needsAuth: Bool = true, queue: DispatchQueue =<br>&gt;&gt;&gt; DispatchQueue.main,<br>&gt;&gt;&gt;                     completion: ObjectFetchCallback&lt;T&gt;?, importer:<br>&gt;&gt;&gt; @escaping HttpImporterCallback&lt;T&gt;)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -Shawn<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Wed, Sep 7, 2016 at 6:51 PM Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Wed, Sep 7, 2016 at 5:54 PM, Michael Ilseman via swift-users &lt;<br>&gt;&gt;&gt;&gt; swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I implemented a better (i.e. correct) diagnostic message for this at<br>&gt;&gt;&gt;&gt;&gt; https://github.com/apple/swift/pull/4670. I want to also do a better<br>&gt;&gt;&gt;&gt;&gt; diagnostic specifically for aggregate parameters to functions (e.g.<br>&gt;&gt;&gt;&gt;&gt; optional closures), but that requires more work in the type checker.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Basically, @escaping is valid only on closures in function parameter<br>&gt;&gt;&gt;&gt;&gt; position. The noescape-by-default rule only applies to these closures at<br>&gt;&gt;&gt;&gt;&gt; function parameter position, otherwise they are escaping. Aggregates, such<br>&gt;&gt;&gt;&gt;&gt; as enums with associated values (e.g. Optional), tuples, structs, etc., if<br>&gt;&gt;&gt;&gt;&gt; they have closures, follow the default rules for closures that are not at<br>&gt;&gt;&gt;&gt;&gt; function parameter position, i.e. they are escaping.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Shouldn&#39;t it be possible to allow distinguishing @escaping/@noescape<br>&gt;&gt;&gt;&gt; for aggregates like these, at least for the simple case of Optional?  (I<br>&gt;&gt;&gt;&gt; handled optionals in https://github.com/apple/swift/pull/4438 for<br>&gt;&gt;&gt;&gt; imported function types; see comment<br>&gt;&gt;&gt;&gt; &lt;https://github.com/apple/swift/pull/4438#issuecomment-243645367&gt;.)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; It would be a post-Swift-3 addition to the language to be able to<br>&gt;&gt;&gt;&gt;&gt; support more robust liveness tracking here. There may be interesting<br>&gt;&gt;&gt;&gt;&gt; directions to take this, with optional closures being the most common<br>&gt;&gt;&gt;&gt;&gt; beneficiary.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Sep 7, 2016, at 3:33 PM, Shawn Erickson via swift-users &lt;<br>&gt;&gt;&gt;&gt;&gt; swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I see https://bugs.swift.org/browse/SR-2324 and<br>&gt;&gt;&gt;&gt;&gt; https://bugs.swift.org/browse/SR-2444 which looks related to this<br>&gt;&gt;&gt;&gt;&gt; issue and may explain the error I saw on &quot;the other side&quot; of this.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Wed, Sep 7, 2016 at 3:28 PM Shawn Erickson &lt;shawnce at gmail.com&gt;<br>&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Yeah I actually have a few of those myself that I can no longer do.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Sep 7, 2016 at 3:26 PM Jon Shier &lt;jon at jonshier.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Perhaps relatedly, it no longer seems possible to mark typealiased<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; closures as @escaping. That was quite handy when you know that closures<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; will always be used asynchronously.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Sep 7, 2016, at 6:15 PM, Shawn Erickson via swift-users &lt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I should note that this issue also appeared in an earlier variant of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift after the addition of @escaping but I was on vacation so didn&#39;t get a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; chance to report it then. It isn&#39;t new with the Xcode 8 GM.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Sep 7, 2016 at 3:08 PM Shawn Erickson &lt;shawnce at gmail.com&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I like and fully supported the change to @escaping away from<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; @noescape however in a body of code that I am porting to the latest Swift 3<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; variant (as found in Xcode 8 GM) I am hitting an issue for methods that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; take an optional completion closure. If optional is involved I can&#39;t find a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; way to apply @escape to the escaping closure. See the following for an<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; basic example...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Is their a way to do what I need and/or is this an edge case in the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; implementation of @escaping?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; typealias MyCallback = (String)-&gt;()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Happy<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func foo1(bar: String, completion: ((String)-&gt;())) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     completion(bar)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Happy<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func foo2(bar: String, completion: MyCallback) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     completion(bar)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Happy<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func foo3(bar: String, completion: ((String)-&gt;())? = nil) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     completion?(bar)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Happy<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func foo4(bar: String, completion: MyCallback? = nil) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     completion?(bar)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Happy<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func foo5(bar: String, completion: Optional&lt;MyCallback&gt; = nil) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     completion?(bar)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Happy<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func foo6(bar: String, completion: @escaping (String)-&gt;()) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     completion(bar)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Happy<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func foo7(bar: String, completion: @escaping MyCallback) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     completion(bar)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Unhappy...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // &quot;@escaping attribute only applies to function types&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func foo8(bar: String, completion: @escaping ((String)-&gt;())? = nil)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     completion?(bar)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Unhappy...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // &quot;@escaping attribute only applies to function types&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func foo9(bar: String, completion: @escaping MyCallback? = nil) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     completion?(bar)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Unhappy...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // &quot;@escaping attribute only applies to function types&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func foo10(bar: String, completion: (@escaping ((String)-&gt;()))? =<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; nil) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     completion?(bar)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Unhappy...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // &quot;@escaping attribute only applies to function types&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func foo11(bar: String, completion: (@escaping MyCallback)? = nil) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     completion?(bar)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Unhappy...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // &quot;@escaping attribute only applies to function types&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func foo12(bar: String, completion: Optional&lt;@escaping MyCallback&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; = nil) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     completion?(bar)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-users at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-users at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-users at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160909/7b4c9c48/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8dfc6932943f38e7a7de48be3194f13c?s=50"></div><header><strong>Swift 3 (Xcode 8 GM) issue with @escaping</strong> from <string>Michael Ilseman</string> &lt;milseman at apple.com&gt;<p>September  8, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Sep 7, 2016, at 6:50 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Wed, Sep 7, 2016 at 5:54 PM, Michael Ilseman via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt; I implemented a better (i.e. correct) diagnostic message for this at https://github.com/apple/swift/pull/4670 &lt;https://github.com/apple/swift/pull/4670&gt;. I want to also do a better diagnostic specifically for aggregate parameters to functions (e.g. optional closures), but that requires more work in the type checker.<br>&gt; <br>&gt; Basically, @escaping is valid only on closures in function parameter position. The noescape-by-default rule only applies to these closures at function parameter position, otherwise they are escaping. Aggregates, such as enums with associated values (e.g. Optional), tuples, structs, etc., if they have closures, follow the default rules for closures that are not at function parameter position, i.e. they are escaping.<br>&gt; <br>&gt; Shouldn&#39;t it be possible to allow distinguishing @escaping/@noescape for aggregates like these, at least for the simple case of Optional?  (I handled optionals in https://github.com/apple/swift/pull/4438 &lt;https://github.com/apple/swift/pull/4438&gt; for imported function types; see comment &lt;https://github.com/apple/swift/pull/4438#issuecomment-243645367&gt;.)<br>&gt;  <br></p><p>Yes it is possible (but *not* in time for Swift 3) to address this. Optional at the very least would be the highest bang for our buck, along with other single-type aggregate structures. A general solution would require some kind of aggregate liveness solution, but we can get something very good with a bit less: we could express such things with the ‘@escaping’ still being at the immediate function parameter position, and applying it throughout aggregate types in a principled fashion. E.g.:<br></p><p>func foo(_ a: @escaping ((Int) -&gt; Int)?) {}<br>func foo(_ a: @escaping (Int, (Int) -&gt; Int)) {}<br>func foo(_ a: @escaping ((Int) -&gt; Int, (Int) -&gt; Int)) {} // both are escaping<br>func foo(_ a: @escaping [(Int) -&gt; Int]? {} // they are all escaping<br></p><p>Struct aggregate members and protocol associated types would not be impacted by this, as their member types are not listed in their signature, only tuples and generic type parameters (modulo sugar).<br></p><p>This would re-enforce that it’s about the parameter position specifically being a special case. Also, I don’t think there’s any practical benefit to finer grained escapability, e.g. some tuple elements are escaping and some are not. Though, at this point, maybe it makes more sense being a parameter attribute, rather than a type attribute…<br></p><p>Any solution should be discussed further on swift-evolution.<br></p><p><br></p><p>&gt; <br>&gt; It would be a post-Swift-3 addition to the language to be able to support more robust liveness tracking here. There may be interesting directions to take this, with optional closures being the most common beneficiary. <br>&gt; <br>&gt;&gt; On Sep 7, 2016, at 3:33 PM, Shawn Erickson via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I see https://bugs.swift.org/browse/SR-2324 &lt;https://bugs.swift.org/browse/SR-2324&gt; and https://bugs.swift.org/browse/SR-2444 &lt;https://bugs.swift.org/browse/SR-2444&gt; which looks related to this issue and may explain the error I saw on &quot;the other side&quot; of this.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Wed, Sep 7, 2016 at 3:28 PM Shawn Erickson &lt;shawnce at gmail.com &lt;mailto:shawnce at gmail.com&gt;&gt; wrote:<br>&gt;&gt; Yeah I actually have a few of those myself that I can no longer do.<br>&gt;&gt; <br>&gt;&gt; On Wed, Sep 7, 2016 at 3:26 PM Jon Shier &lt;jon at jonshier.com &lt;mailto:jon at jonshier.com&gt;&gt; wrote:<br>&gt;&gt; Perhaps relatedly, it no longer seems possible to mark typealiased closures as @escaping. That was quite handy when you know that closures will always be used asynchronously.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Jon<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Sep 7, 2016, at 6:15 PM, Shawn Erickson via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; I should note that this issue also appeared in an earlier variant of Swift after the addition of @escaping but I was on vacation so didn&#39;t get a chance to report it then. It isn&#39;t new with the Xcode 8 GM.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Wed, Sep 7, 2016 at 3:08 PM Shawn Erickson &lt;shawnce at gmail.com &lt;mailto:shawnce at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; I like and fully supported the change to @escaping away from @noescape however in a body of code that I am porting to the latest Swift 3 variant (as found in Xcode 8 GM) I am hitting an issue for methods that take an optional completion closure. If optional is involved I can&#39;t find a way to apply @escape to the escaping closure. See the following for an basic example...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Is their a way to do what I need and/or is this an edge case in the implementation of @escaping?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; typealias MyCallback = (String)-&gt;()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Happy<br>&gt;&gt;&gt; func foo1(bar: String, completion: ((String)-&gt;())) {<br>&gt;&gt;&gt;     completion(bar)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Happy<br>&gt;&gt;&gt; func foo2(bar: String, completion: MyCallback) {<br>&gt;&gt;&gt;     completion(bar)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Happy<br>&gt;&gt;&gt; func foo3(bar: String, completion: ((String)-&gt;())? = nil) {<br>&gt;&gt;&gt;     completion?(bar)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Happy<br>&gt;&gt;&gt; func foo4(bar: String, completion: MyCallback? = nil) {<br>&gt;&gt;&gt;     completion?(bar)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Happy<br>&gt;&gt;&gt; func foo5(bar: String, completion: Optional&lt;MyCallback&gt; = nil) {<br>&gt;&gt;&gt;     completion?(bar)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Happy<br>&gt;&gt;&gt; func foo6(bar: String, completion: @escaping (String)-&gt;()) {<br>&gt;&gt;&gt;     completion(bar)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Happy<br>&gt;&gt;&gt; func foo7(bar: String, completion: @escaping MyCallback) {<br>&gt;&gt;&gt;     completion(bar)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Unhappy...<br>&gt;&gt;&gt; // &quot;@escaping attribute only applies to function types&quot;<br>&gt;&gt;&gt; func foo8(bar: String, completion: @escaping ((String)-&gt;())? = nil) {<br>&gt;&gt;&gt;     completion?(bar)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Unhappy...<br>&gt;&gt;&gt; // &quot;@escaping attribute only applies to function types&quot;<br>&gt;&gt;&gt; func foo9(bar: String, completion: @escaping MyCallback? = nil) {<br>&gt;&gt;&gt;     completion?(bar)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Unhappy...<br>&gt;&gt;&gt; // &quot;@escaping attribute only applies to function types&quot;<br>&gt;&gt;&gt; func foo10(bar: String, completion: (@escaping ((String)-&gt;()))? = nil) {<br>&gt;&gt;&gt;     completion?(bar)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Unhappy...<br>&gt;&gt;&gt; // &quot;@escaping attribute only applies to function types&quot;<br>&gt;&gt;&gt; func foo11(bar: String, completion: (@escaping MyCallback)? = nil) {<br>&gt;&gt;&gt;     completion?(bar)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Unhappy...<br>&gt;&gt;&gt; // &quot;@escaping attribute only applies to function types&quot;<br>&gt;&gt;&gt; func foo12(bar: String, completion: Optional&lt;@escaping MyCallback&gt; = nil) {<br>&gt;&gt;&gt;     completion?(bar)<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160908/92a68b4f/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
