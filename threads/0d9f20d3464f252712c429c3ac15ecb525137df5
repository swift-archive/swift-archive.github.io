<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/63d942c0fa15cef62a14e75ef6d7ed81?s=50"></div><header><strong>Custom annotation processors?</strong> from <string>Talin</string> &lt;viridia at gmail.com&gt;<p>January 13, 2016 at 05:00:00pm</p></header><div class="content"><p>As a former Googler, I&#39;ve spent a lot of years writing Java code that uses<br>dependency injection, and this relies heavily on the ability to have custom<br>annotations/attributes in the language - particularly, user-defined<br>attributes on function parameters - and to generate additional code at<br>compile time via annotation processors. Although dependency injection does<br>have it&#39;s detractors, it&#39;s getting better (current best of breed is<br>http://google.github.io/dagger/), and it solves an amazing array of<br>problems, including the ability for asynchronous programming to disappear<br>into the underlying framework - you just write synchronous code and the<br>framework handles the rest (no more futures!).<br></p><p>Now, you can of course do dependency injection without custom attribute<br>support in the language, but it&#39;s much more cumbersome. The user-defined<br>attributes allow you to specify, in a simple declarative way, the runtime<br>dependencies between various classes. Without it you have to build up those<br>dependencies in code, using some sort of fluent interface or builder<br>pattern.<br></p><p>So my question is, is there any plan for Swift to support user-created<br>annotations, and annotation processing compilation stages?<br></p><p>-- <br>-- Talin<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/0d9f7df5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Custom annotation processors?</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 13, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jan 13, 2016, at 5:24 PM, Talin via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; As a former Googler, I&#39;ve spent a lot of years writing Java code that uses dependency injection, and this relies heavily on the ability to have custom annotations/attributes in the language - particularly, user-defined attributes on function parameters - and to generate additional code at compile time via annotation processors. Although dependency injection does have it&#39;s detractors, it&#39;s getting better (current best of breed is http://google.github.io/dagger/ &lt;http://google.github.io/dagger/&gt;), and it solves an amazing array of problems, including the ability for asynchronous programming to disappear into the underlying framework - you just write synchronous code and the framework handles the rest (no more futures!).<br>&gt; <br>&gt; Now, you can of course do dependency injection without custom attribute support in the language, but it&#39;s much more cumbersome. The user-defined attributes allow you to specify, in a simple declarative way, the runtime dependencies between various classes. Without it you have to build up those dependencies in code, using some sort of fluent interface or builder pattern.<br>&gt; <br>&gt; So my question is, is there any plan for Swift to support user-created annotations, and annotation processing compilation stages?<br></p><p>Hi Talin, <br></p><p>We have no concrete plans for user defined attributes, but it is a natural extension.  One of our goals for Swift 3 is to nail down the reflection metadata representation.  We should design this to be extensible to support user defined attributes so that we don’t close this off in the future.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/f5b62dd2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/63d942c0fa15cef62a14e75ef6d7ed81?s=50"></div><header><strong>Custom annotation processors?</strong> from <string>Talin</string> &lt;viridia at gmail.com&gt;<p>January 13, 2016 at 06:00:00pm</p></header><div class="content"><p>Understood. I might add that one of the advantages of Dagger2 over the<br>older Guice framework is that it does all of the reflection work at compile<br>time, rather than at runtime, so a lot of the expense of runtime reflection<br>is avoided. This also means that the generated code for the injection logic<br>is debuggable, which was historically one of the biggest complaints about<br>Guice.<br></p><p>So the bottom line for me is, I don&#39;t care as much about the ability to<br>access the attributes at runtime - I&#39;m more interested as to whether the<br>module artifacts output by the compiler can be introspected via some simple<br>API, or are stored in some relatively transparent encoding.<br></p><p><br>On Wed, Jan 13, 2016 at 5:58 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Jan 13, 2016, at 5:24 PM, Talin via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; As a former Googler, I&#39;ve spent a lot of years writing Java code that uses<br>&gt; dependency injection, and this relies heavily on the ability to have custom<br>&gt; annotations/attributes in the language - particularly, user-defined<br>&gt; attributes on function parameters - and to generate additional code at<br>&gt; compile time via annotation processors. Although dependency injection does<br>&gt; have it&#39;s detractors, it&#39;s getting better (current best of breed is<br>&gt; http://google.github.io/dagger/), and it solves an amazing array of<br>&gt; problems, including the ability for asynchronous programming to disappear<br>&gt; into the underlying framework - you just write synchronous code and the<br>&gt; framework handles the rest (no more futures!).<br>&gt;<br>&gt; Now, you can of course do dependency injection without custom attribute<br>&gt; support in the language, but it&#39;s much more cumbersome. The user-defined<br>&gt; attributes allow you to specify, in a simple declarative way, the runtime<br>&gt; dependencies between various classes. Without it you have to build up those<br>&gt; dependencies in code, using some sort of fluent interface or builder<br>&gt; pattern.<br>&gt;<br>&gt; So my question is, is there any plan for Swift to support user-created<br>&gt; annotations, and annotation processing compilation stages?<br>&gt;<br>&gt;<br>&gt; Hi Talin,<br>&gt;<br>&gt; We have no concrete plans for user defined attributes, but it is a natural<br>&gt; extension.  One of our goals for Swift 3 is to nail down the reflection<br>&gt; metadata representation.  We should design this to be extensible to support<br>&gt; user defined attributes so that we don’t close this off in the future.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br></p><p><br>-- <br>-- Talin<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/dfcfc160/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Custom annotation processors?</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 13, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jan 13, 2016, at 6:18 PM, Talin &lt;viridia at gmail.com&gt; wrote:<br>&gt; <br>&gt; Understood. I might add that one of the advantages of Dagger2 over the older Guice framework is that it does all of the reflection work at compile time, rather than at runtime, so a lot of the expense of runtime reflection is avoided. This also means that the generated code for the injection logic is debuggable, which was historically one of the biggest complaints about Guice.<br>&gt; <br>&gt; So the bottom line for me is, I don&#39;t care as much about the ability to access the attributes at runtime - I&#39;m more interested as to whether the module artifacts output by the compiler can be introspected via some simple API, or are stored in some relatively transparent encoding.<br></p><p>Ah I see, I don’t know anyone considering building those sorts of tools right now.<br></p><p>-Chris<br></p><p>&gt; <br>&gt; <br>&gt; On Wed, Jan 13, 2016 at 5:58 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 13, 2016, at 5:24 PM, Talin via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; As a former Googler, I&#39;ve spent a lot of years writing Java code that uses dependency injection, and this relies heavily on the ability to have custom annotations/attributes in the language - particularly, user-defined attributes on function parameters - and to generate additional code at compile time via annotation processors. Although dependency injection does have it&#39;s detractors, it&#39;s getting better (current best of breed is http://google.github.io/dagger/ &lt;http://google.github.io/dagger/&gt;), and it solves an amazing array of problems, including the ability for asynchronous programming to disappear into the underlying framework - you just write synchronous code and the framework handles the rest (no more futures!).<br>&gt;&gt; <br>&gt;&gt; Now, you can of course do dependency injection without custom attribute support in the language, but it&#39;s much more cumbersome. The user-defined attributes allow you to specify, in a simple declarative way, the runtime dependencies between various classes. Without it you have to build up those dependencies in code, using some sort of fluent interface or builder pattern.<br>&gt;&gt; <br>&gt;&gt; So my question is, is there any plan for Swift to support user-created annotations, and annotation processing compilation stages?<br>&gt; <br>&gt; Hi Talin, <br>&gt; <br>&gt; We have no concrete plans for user defined attributes, but it is a natural extension.  One of our goals for Swift 3 is to nail down the reflection metadata representation.  We should design this to be extensible to support user defined attributes so that we don’t close this off in the future.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; -- Talin<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/2d12b8f3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/63d942c0fa15cef62a14e75ef6d7ed81?s=50"></div><header><strong>Custom annotation processors?</strong> from <string>Talin</string> &lt;viridia at gmail.com&gt;<p>January 14, 2016 at 09:00:00am</p></header><div class="content"><p>BTW other use cases for this sort of thing are automated generation of<br>testing mocks and RPC stubs - things that require a lot of exacting,<br>repetitive drudgery and that no programmer should have to code manually.<br>It&#39;s possible to do these with reflection as well, however the problem with<br>reflection is that when you look at the code in the debugger you have to<br>peer inside a lot of obscure data structures to figure out what is going<br>on, whereas it&#39;s fairly intuitive to step through generated source code.<br></p><p>On Wed, Jan 13, 2016 at 9:55 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Jan 13, 2016, at 6:18 PM, Talin &lt;viridia at gmail.com&gt; wrote:<br>&gt;<br>&gt; Understood. I might add that one of the advantages of Dagger2 over the<br>&gt; older Guice framework is that it does all of the reflection work at compile<br>&gt; time, rather than at runtime, so a lot of the expense of runtime reflection<br>&gt; is avoided. This also means that the generated code for the injection logic<br>&gt; is debuggable, which was historically one of the biggest complaints about<br>&gt; Guice.<br>&gt;<br>&gt; So the bottom line for me is, I don&#39;t care as much about the ability to<br>&gt; access the attributes at runtime - I&#39;m more interested as to whether the<br>&gt; module artifacts output by the compiler can be introspected via some simple<br>&gt; API, or are stored in some relatively transparent encoding.<br>&gt;<br>&gt;<br>&gt; Ah I see, I don’t know anyone considering building those sorts of tools<br>&gt; right now.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Wed, Jan 13, 2016 at 5:58 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Jan 13, 2016, at 5:24 PM, Talin via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; As a former Googler, I&#39;ve spent a lot of years writing Java code that<br>&gt;&gt; uses dependency injection, and this relies heavily on the ability to have<br>&gt;&gt; custom annotations/attributes in the language - particularly, user-defined<br>&gt;&gt; attributes on function parameters - and to generate additional code at<br>&gt;&gt; compile time via annotation processors. Although dependency injection does<br>&gt;&gt; have it&#39;s detractors, it&#39;s getting better (current best of breed is<br>&gt;&gt; http://google.github.io/dagger/), and it solves an amazing array of<br>&gt;&gt; problems, including the ability for asynchronous programming to disappear<br>&gt;&gt; into the underlying framework - you just write synchronous code and the<br>&gt;&gt; framework handles the rest (no more futures!).<br>&gt;&gt;<br>&gt;&gt; Now, you can of course do dependency injection without custom attribute<br>&gt;&gt; support in the language, but it&#39;s much more cumbersome. The user-defined<br>&gt;&gt; attributes allow you to specify, in a simple declarative way, the runtime<br>&gt;&gt; dependencies between various classes. Without it you have to build up those<br>&gt;&gt; dependencies in code, using some sort of fluent interface or builder<br>&gt;&gt; pattern.<br>&gt;&gt;<br>&gt;&gt; So my question is, is there any plan for Swift to support user-created<br>&gt;&gt; annotations, and annotation processing compilation stages?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Hi Talin,<br>&gt;&gt;<br>&gt;&gt; We have no concrete plans for user defined attributes, but it is a<br>&gt;&gt; natural extension.  One of our goals for Swift 3 is to nail down the<br>&gt;&gt; reflection metadata representation.  We should design this to be extensible<br>&gt;&gt; to support user defined attributes so that we don’t close this off in the<br>&gt;&gt; future.<br>&gt;&gt;<br>&gt;&gt; -Chris<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; -- Talin<br>&gt;<br>&gt;<br>&gt;<br></p><p><br>-- <br>-- Talin<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160114/3a9bc393/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/428c01fbcb7520555ed00f2b06246d16?s=50"></div><header><strong>Custom annotation processors?</strong> from <string>Fons Rademakers</string> &lt;Fons.Rademakers at cern.ch&gt;<p>January 19, 2016 at 03:00:00pm</p></header><div class="content"><p>Hi Chris,<br></p><p>  is there a document or notes on discussions on reflection metadata representations and an API to access them? We are very interested in this as it essential to have that make a powerful I/O system, like we have in ROOT, it is mandatory to be able to find out at run-time all possible object details. User defined attributes are in our case used to annotate e.g. transient data members that should not be streamed, or the precision with which a certain data member should be streamed (a double that could be streamed with a much lower precision saves a lot of bytes in the output, etc.).<br></p><p>Cheers, Fons.<br></p><p><br>&gt; On 13 Jan 2016, at 22:58, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 13, 2016, at 5:24 PM, Talin via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; As a former Googler, I&#39;ve spent a lot of years writing Java code that uses dependency injection, and this relies heavily on the ability to have custom annotations/attributes in the language - particularly, user-defined attributes on function parameters - and to generate additional code at compile time via annotation processors. Although dependency injection does have it&#39;s detractors, it&#39;s getting better (current best of breed is http://google.github.io/dagger/), and it solves an amazing array of problems, including the ability for asynchronous programming to disappear into the underlying framework - you just write synchronous code and the framework handles the rest (no more futures!).<br>&gt;&gt; <br>&gt;&gt; Now, you can of course do dependency injection without custom attribute support in the language, but it&#39;s much more cumbersome. The user-defined attributes allow you to specify, in a simple declarative way, the runtime dependencies between various classes. Without it you have to build up those dependencies in code, using some sort of fluent interface or builder pattern.<br>&gt;&gt; <br>&gt;&gt; So my question is, is there any plan for Swift to support user-created annotations, and annotation processing compilation stages?<br>&gt; <br>&gt; Hi Talin, <br>&gt; <br>&gt; We have no concrete plans for user defined attributes, but it is a natural extension.  One of our goals for Swift 3 is to nail down the reflection metadata representation.  We should design this to be extensible to support user defined attributes so that we don’t close this off in the future.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>--------------------------------------------------------------------------<br>Dr. Fons Rademakers      CERN - European Organization for Nuclear Research<br>Chief Research Officer   1211 Geneve 23, Switzerland<br>CERN openlab             Tel: +41227679248            Mobile: +41754113742<br>--------------------------------------------------------------------------<br></p><p>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: smime.p7s<br>Type: application/pkcs7-signature<br>Size: 3029 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160119/777f1fe9/attachment.p7s&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Custom annotation processors?</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 19, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 19, 2016, at 7:10 AM, Fons Rademakers &lt;Fons.Rademakers at cern.ch&gt; wrote:<br>&gt; <br>&gt; Hi Chris,<br>&gt; <br>&gt;  is there a document or notes on discussions on reflection metadata representations and an API to access them? We are very interested in this as it essential to have that make a powerful I/O system, like we have in ROOT, it is mandatory to be able to find out at run-time all possible object details. User defined attributes are in our case used to annotate e.g. transient data members that should not be streamed, or the precision with which a certain data member should be streamed (a double that could be streamed with a much lower precision saves a lot of bytes in the output, etc.).<br></p><p>Hi Fons,<br></p><p>There is some early documentation here:<br>https://github.com/apple/swift/blob/master/docs/ABI.rst#type-metadata<br></p><p>Slava is the one working on this area IIRC.<br></p><p>-Chris<br></p><p><br>&gt;&gt; On 13 Jan 2016, at 22:58, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 13, 2016, at 5:24 PM, Talin via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As a former Googler, I&#39;ve spent a lot of years writing Java code that uses dependency injection, and this relies heavily on the ability to have custom annotations/attributes in the language - particularly, user-defined attributes on function parameters - and to generate additional code at compile time via annotation processors. Although dependency injection does have it&#39;s detractors, it&#39;s getting better (current best of breed is http://google.github.io/dagger/), and it solves an amazing array of problems, including the ability for asynchronous programming to disappear into the underlying framework - you just write synchronous code and the framework handles the rest (no more futures!).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Now, you can of course do dependency injection without custom attribute support in the language, but it&#39;s much more cumbersome. The user-defined attributes allow you to specify, in a simple declarative way, the runtime dependencies between various classes. Without it you have to build up those dependencies in code, using some sort of fluent interface or builder pattern.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So my question is, is there any plan for Swift to support user-created annotations, and annotation processing compilation stages?<br>&gt;&gt; <br>&gt;&gt; Hi Talin, <br>&gt;&gt; <br>&gt;&gt; We have no concrete plans for user defined attributes, but it is a natural extension.  One of our goals for Swift 3 is to nail down the reflection metadata representation.  We should design this to be extensible to support user defined attributes so that we don’t close this off in the future.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; --------------------------------------------------------------------------<br>&gt; Dr. Fons Rademakers      CERN - European Organization for Nuclear Research<br>&gt; Chief Research Officer   1211 Geneve 23, Switzerland<br>&gt; CERN openlab             Tel: +41227679248            Mobile: +41754113742<br>&gt; --------------------------------------------------------------------------<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/428c01fbcb7520555ed00f2b06246d16?s=50"></div><header><strong>Custom annotation processors?</strong> from <string>Fons Rademakers</string> &lt;Fons.Rademakers at cern.ch&gt;<p>January 21, 2016 at 05:00:00pm</p></header><div class="content"><p>Hi Chris,<br></p><p>  many thanks for the pointer. Will there also be a method or function calling interface, so interfaces can be discovered and called at run-time. Something we abundantly use via the Cling interpreter.<br></p><p>Cheers, Fons.<br></p><p><br>&gt; On 19 Jan 2016, at 15:20, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 19, 2016, at 7:10 AM, Fons Rademakers &lt;Fons.Rademakers at cern.ch&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi Chris,<br>&gt;&gt; <br>&gt;&gt; is there a document or notes on discussions on reflection metadata representations and an API to access them? We are very interested in this as it essential to have that make a powerful I/O system, like we have in ROOT, it is mandatory to be able to find out at run-time all possible object details. User defined attributes are in our case used to annotate e.g. transient data members that should not be streamed, or the precision with which a certain data member should be streamed (a double that could be streamed with a much lower precision saves a lot of bytes in the output, etc.).<br>&gt; <br>&gt; Hi Fons,<br>&gt; <br>&gt; There is some early documentation here:<br>&gt; https://github.com/apple/swift/blob/master/docs/ABI.rst#type-metadata<br>&gt; <br>&gt; Slava is the one working on this area IIRC.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On 13 Jan 2016, at 22:58, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 13, 2016, at 5:24 PM, Talin via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As a former Googler, I&#39;ve spent a lot of years writing Java code that uses dependency injection, and this relies heavily on the ability to have custom annotations/attributes in the language - particularly, user-defined attributes on function parameters - and to generate additional code at compile time via annotation processors. Although dependency injection does have it&#39;s detractors, it&#39;s getting better (current best of breed is http://google.github.io/dagger/), and it solves an amazing array of problems, including the ability for asynchronous programming to disappear into the underlying framework - you just write synchronous code and the framework handles the rest (no more futures!).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Now, you can of course do dependency injection without custom attribute support in the language, but it&#39;s much more cumbersome. The user-defined attributes allow you to specify, in a simple declarative way, the runtime dependencies between various classes. Without it you have to build up those dependencies in code, using some sort of fluent interface or builder pattern.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So my question is, is there any plan for Swift to support user-created annotations, and annotation processing compilation stages?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi Talin, <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We have no concrete plans for user defined attributes, but it is a natural extension.  One of our goals for Swift 3 is to nail down the reflection metadata representation.  We should design this to be extensible to support user defined attributes so that we don’t close this off in the future.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; --------------------------------------------------------------------------<br>&gt;&gt; Dr. Fons Rademakers      CERN - European Organization for Nuclear Research<br>&gt;&gt; Chief Research Officer   1211 Geneve 23, Switzerland<br>&gt;&gt; CERN openlab             Tel: +41227679248            Mobile: +41754113742<br>&gt;&gt; --------------------------------------------------------------------------<br>&gt;&gt; <br>&gt; <br></p><p>--------------------------------------------------------------------------<br>Dr. Fons Rademakers      CERN - European Organization for Nuclear Research<br>Chief Research Officer   1211 Geneve 23, Switzerland<br>CERN openlab             Tel: +41227679248            Mobile: +41754113742<br>--------------------------------------------------------------------------<br></p><p>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: smime.p7s<br>Type: application/pkcs7-signature<br>Size: 3029 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160121/453ef3f7/attachment.p7s&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Custom annotation processors?</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 21, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jan 21, 2016, at 9:45 AM, Fons Rademakers &lt;Fons.Rademakers at cern.ch&gt; wrote:<br>&gt; <br>&gt; Hi Chris,<br>&gt; <br>&gt;  many thanks for the pointer. Will there also be a method or function calling interface, so interfaces can be discovered and called at run-time. Something we abundantly use via the Cling interpreter.<br></p><p>There will certainly be a reflection API at some point, but it hasn’t been scheduled.  I’ve been working under the assumption that it won’t fit into Swift 3, but we’ll see how things go.  Once the metadata format is nailed down, it can be added at any time.<br></p><p>-Chris<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0b728da29cd3d569863451ebf5d1d361?s=50"></div><header><strong>Custom annotation processors?</strong> from <string>品雪</string> &lt;pinxue at gmail.com&gt;<p>January 14, 2016 at 02:00:00pm</p></header><div class="content"><p>-1 on user-created annotation.<br></p><p>I wrote Java since 90s and hate user-created annotation. Annotation is indeed a backdoor in syntax system, it makes source code totally un-understandable before you read reference of the annotation. <br></p><p>&gt; 在 2016年1月14日，上午9:24，Talin via swift-evolution &lt;swift-evolution at swift.org&gt; 写道：<br>&gt; <br>&gt; As a former Googler, I&#39;ve spent a lot of years writing Java code that uses dependency injection, and this relies heavily on the ability to have custom annotations/attributes in the language - particularly, user-defined attributes on function parameters - and to generate additional code at compile time via annotation processors. Although dependency injection does have it&#39;s detractors, it&#39;s getting better (current best of breed is http://google.github.io/dagger/ &lt;http://google.github.io/dagger/&gt;), and it solves an amazing array of problems, including the ability for asynchronous programming to disappear into the underlying framework - you just write synchronous code and the framework handles the rest (no more futures!).<br>&gt; <br>&gt; Now, you can of course do dependency injection without custom attribute support in the language, but it&#39;s much more cumbersome. The user-defined attributes allow you to specify, in a simple declarative way, the runtime dependencies between various classes. Without it you have to build up those dependencies in code, using some sort of fluent interface or builder pattern.<br>&gt; <br>&gt; So my question is, is there any plan for Swift to support user-created annotations, and annotation processing compilation stages?<br>&gt; <br>&gt; -- <br>&gt; -- Talin<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160114/fda46053/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/63d942c0fa15cef62a14e75ef6d7ed81?s=50"></div><header><strong>Custom annotation processors?</strong> from <string>Talin</string> &lt;viridia at gmail.com&gt;<p>January 13, 2016 at 10:00:00pm</p></header><div class="content"><p>You can say that about any metaprogramming feature, including operator<br>overloading, parametric polymorphism, automated code generation, or any<br>other form of programmable syntax - all of these features have to be used<br>with care because they essentially create new dialects of the language. As<br>for using annotations to drive dependency injection, this is used by<br>thousands of Google engineers on a daily basis and people generally find it<br>quite powerful and helpful. I actually think it is syntactically less<br>dangerous overall than the ability to invent new infix operators, because<br>at least you have an imported name that you can search for.<br></p><p>My own personal interest is in metaprogramming, that is &quot;code that operates<br>on code&quot;, whether it be by reflection, template instantiation, or automated<br>code generation. In Java, this is sometimes done through reflection, and<br>sometimes via annotation processors, which are plugins to the Java compiler<br>that can examine the annotations and generate additional helper classes. By<br>contrast, in my own experimental language, the output of the compiler is<br>stored in a generic introspectable binary file format, similar to protocol<br>buffers, which can easily be taken apart and re-assembled by any<br>programming language (C, Python, Swift, Go, etc), allowing any sort of<br>post-processing on a compiled module.<br></p><p><br>On Wed, Jan 13, 2016 at 10:01 PM, Yang Wu &lt;pinxue at gmail.com&gt; wrote:<br></p><p>&gt; -1 on user-created annotation.<br>&gt;<br>&gt; I wrote Java since 90s and hate user-created annotation. Annotation is<br>&gt; indeed a backdoor in syntax system, it makes source code totally<br>&gt; un-understandable before you read reference of the annotation.<br>&gt;<br>&gt; 在 2016年1月14日，上午9:24，Talin via swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt; 写道：<br>&gt;<br>&gt; As a former Googler, I&#39;ve spent a lot of years writing Java code that uses<br>&gt; dependency injection, and this relies heavily on the ability to have custom<br>&gt; annotations/attributes in the language - particularly, user-defined<br>&gt; attributes on function parameters - and to generate additional code at<br>&gt; compile time via annotation processors. Although dependency injection does<br>&gt; have it&#39;s detractors, it&#39;s getting better (current best of breed is<br>&gt; http://google.github.io/dagger/), and it solves an amazing array of<br>&gt; problems, including the ability for asynchronous programming to disappear<br>&gt; into the underlying framework - you just write synchronous code and the<br>&gt; framework handles the rest (no more futures!).<br>&gt;<br>&gt; Now, you can of course do dependency injection without custom attribute<br>&gt; support in the language, but it&#39;s much more cumbersome. The user-defined<br>&gt; attributes allow you to specify, in a simple declarative way, the runtime<br>&gt; dependencies between various classes. Without it you have to build up those<br>&gt; dependencies in code, using some sort of fluent interface or builder<br>&gt; pattern.<br>&gt;<br>&gt; So my question is, is there any plan for Swift to support user-created<br>&gt; annotations, and annotation processing compilation stages?<br>&gt;<br>&gt; --<br>&gt; -- Talin<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br></p><p><br>-- <br>-- Talin<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/0d842119/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0b728da29cd3d569863451ebf5d1d361?s=50"></div><header><strong>Custom annotation processors?</strong> from <string>品雪</string> &lt;pinxue at gmail.com&gt;<p>January 14, 2016 at 03:00:00pm</p></header><div class="content"><p>No, they are not same. Macro and preprocessor changes the language as well,<br>any RTTI supported feature doesn&#39;t, but only affects runtime behavior.<br>Operator overloading changes semantic of existed language element, but<br>doesn&#39;t enable introducing of any new syntax element.<br></p><p>Java&#39;s annotation allows you to add any @ beginning identifier as they are<br>part of the language. It is more like I cannot tell if a function call is<br>right or not before read the document of that library. But I wish we may<br>keep the language pre-defined.<br></p><p>PS, Java Annotation is obviously not equal to implement DI, AspectJ existed<br>before annotation was added and configuration file based methods existed<br>even longer.<br></p><p><br></p><p>On Thu, Jan 14, 2016 at 2:21 PM, Talin &lt;viridia at gmail.com&gt; wrote:<br></p><p>&gt; You can say that about any metaprogramming feature, including operator<br>&gt; overloading, parametric polymorphism, automated code generation, or any<br>&gt; other form of programmable syntax - all of these features have to be used<br>&gt; with care because they essentially create new dialects of the language. As<br>&gt; for using annotations to drive dependency injection, this is used by<br>&gt; thousands of Google engineers on a daily basis and people generally find it<br>&gt; quite powerful and helpful. I actually think it is syntactically less<br>&gt; dangerous overall than the ability to invent new infix operators, because<br>&gt; at least you have an imported name that you can search for.<br>&gt;<br>&gt; My own personal interest is in metaprogramming, that is &quot;code that<br>&gt; operates on code&quot;, whether it be by reflection, template instantiation, or<br>&gt; automated code generation. In Java, this is sometimes done through<br>&gt; reflection, and sometimes via annotation processors, which are plugins to<br>&gt; the Java compiler that can examine the annotations and generate additional<br>&gt; helper classes. By contrast, in my own experimental language, the output of<br>&gt; the compiler is stored in a generic introspectable binary file format,<br>&gt; similar to protocol buffers, which can easily be taken apart and<br>&gt; re-assembled by any programming language (C, Python, Swift, Go, etc),<br>&gt; allowing any sort of post-processing on a compiled module.<br>&gt;<br>&gt;<br>&gt; On Wed, Jan 13, 2016 at 10:01 PM, Yang Wu &lt;pinxue at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; -1 on user-created annotation.<br>&gt;&gt;<br>&gt;&gt; I wrote Java since 90s and hate user-created annotation. Annotation is<br>&gt;&gt; indeed a backdoor in syntax system, it makes source code totally<br>&gt;&gt; un-understandable before you read reference of the annotation.<br>&gt;&gt;<br>&gt;&gt; 在 2016年1月14日，上午9:24，Talin via swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt;&gt; 写道：<br>&gt;&gt;<br>&gt;&gt; As a former Googler, I&#39;ve spent a lot of years writing Java code that<br>&gt;&gt; uses dependency injection, and this relies heavily on the ability to have<br>&gt;&gt; custom annotations/attributes in the language - particularly, user-defined<br>&gt;&gt; attributes on function parameters - and to generate additional code at<br>&gt;&gt; compile time via annotation processors. Although dependency injection does<br>&gt;&gt; have it&#39;s detractors, it&#39;s getting better (current best of breed is<br>&gt;&gt; http://google.github.io/dagger/), and it solves an amazing array of<br>&gt;&gt; problems, including the ability for asynchronous programming to disappear<br>&gt;&gt; into the underlying framework - you just write synchronous code and the<br>&gt;&gt; framework handles the rest (no more futures!).<br>&gt;&gt;<br>&gt;&gt; Now, you can of course do dependency injection without custom attribute<br>&gt;&gt; support in the language, but it&#39;s much more cumbersome. The user-defined<br>&gt;&gt; attributes allow you to specify, in a simple declarative way, the runtime<br>&gt;&gt; dependencies between various classes. Without it you have to build up those<br>&gt;&gt; dependencies in code, using some sort of fluent interface or builder<br>&gt;&gt; pattern.<br>&gt;&gt;<br>&gt;&gt; So my question is, is there any plan for Swift to support user-created<br>&gt;&gt; annotations, and annotation processing compilation stages?<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; -- Talin<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; -- Talin<br>&gt;<br></p><p><br></p><p>-- <br>Best Regards!<br></p><p>Yang Wu<br>--------------------------------------------------------<br>Location: Pudong, Shanghai, China.<br>EMail    : pinxue at gmail.com<br>Website: http://www.time2change.mobi http://rockplayer.com<br>Twitter/Weibo : @pinxue<br>&lt;http://www.pinxue.net&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160114/8ccd8c74/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
