<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal draft #2] Naming Functions with Argument Labels</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January 11, 2016 at 11:00:00am</p></header><div class="content"><p>Hi all,<br></p><p>I’ve updated and simplified my “Generalized Naming for Any Function” proposal to only deal with naming functions with argument labels, and dropping the back-ticks. Comments welcome! Proposal is here<br></p><p>	https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md<br></p><p>and inline:<br></p><p>Naming Functions with Argument Labels<br></p><p>Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0000-generalized-naming.md&gt;<br>Author(s): Doug Gregor &lt;https://github.com/DougGregor&gt;<br>Status: Awaiting Review<br>Review manager: TBD<br> &lt;https://github.com/DougGregor/swift-evolution/tree/generalized-naming#introduction&gt;Introduction<br></p><p>Swift includes support for first-class functions, such that any function (or method) can be placed into a value of function type. However, when specifying the name of a function, one can only provide the base name, (e.g., insertSubview) without the argument labels. For overloaded functions, this means that one must disambiguate based on type information, which is awkward and verbose. This proposal allwos one <br></p><p>it is not possible to specifically name every function that is part of a Swift program---one cannot provide the argument labels when naming a function, nor are property and subscript getters and setters referenceable. This proposal introduces a general syntax that allows one to name anything that is a function within Swift in an extensible manner.<br></p><p>Swift-evolution thread: The first draft of this proposal was discussed here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151221/004555.html&gt;. It included support for naming getters/setters (separately brought up by Michael Henson here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html&gt;, continued here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002203.html&gt;). Joe Groff convinced &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151221/004579.html&gt; me that lenses are a better approach for working with getters/setters, so I&#39;ve dropped them from this version of the proposal.<br></p><p> &lt;https://github.com/DougGregor/swift-evolution/tree/generalized-naming#motivation&gt;Motivation<br></p><p>It&#39;s fairly common in Swift for multiple functions or methods to have the same &quot;base name&quot;, but be distinguished by parameter labels. For example, UIView has three methods with the same base name insertSubview:<br></p><p>extension UIView {<br>  func insertSubview(view: UIView, at index: Int)<br>  func insertSubview(view: UIView, aboveSubview siblingSubview: UIView)<br>  func insertSubview(view: UIView, belowSubview siblingSubview: UIView)<br>}<br>When calling these methods, the argument labels distinguish the different methods, e.g.,<br></p><p>someView.insertSubview(view, at: 3)<br>someView.insertSubview(view, aboveSubview: otherView)<br>someView.insertSubview(view, belowSubview: otherView)<br>However, when referencing the function to create a function value, one cannot provide the labels:<br></p><p>let fn = someView.insertSubview // ambiguous: could be any of the three methods<br>In some cases, it is possible to use type annotations to disambiguate:<br></p><p>let fn: (UIView, Int) = someView.insertSubview    // ok: uses insertSubview(_:at:)<br>let fn: (UIView, UIView) = someView.insertSubview // error: still ambiguous!<br>To resolve the latter case, one must fall back to creating a closure:<br></p><p>let fn: (UIView, UIView) = { view, otherView in<br>  button.insertSubview(view, aboveSubview: otherView)<br>}<br>which is painfully tedious. <br></p><p>One additional bit of motivation: Swift should probably get some way to ask for the Objective-C selector for a given method (rather than writing a string literal). The argument to such an operation would likely be a reference to a method, which would benefit from being able to name any method, including getters and setters.<br></p><p> &lt;https://github.com/DougGregor/swift-evolution/tree/generalized-naming#proposed-solution&gt;Proposed solution<br></p><p>I propose to extend function naming to allow compound Swift names (e.g., insertSubview(_:aboveSubview:)) anywhere a name can occur. Specifically,<br></p><p>let fn = someView.insertSubview(_:at:)<br>let fn1 = someView.insertSubview(_:aboveSubview:)<br>The same syntax can also refer to initializers, e.g.,<br></p><p>let buttonFactory = UIButton.init(type:)<br>The &quot;produce the Objective-C selector for the given method&quot; operation will be the subject of a separate proposal. However, here is one possibility that illustrations how it uses the proposed syntax here:<br></p><p>let getter = Selector(NSDictionary.insertSubview(_:aboveSubview:)) // produces insertSubview:aboveSubview:.<br> &lt;https://github.com/DougGregor/swift-evolution/tree/generalized-naming#detailed-design&gt;Detailed Design<br></p><p>Grammatically, the primary-expression grammar will change from:<br></p><p>primary-expression -&gt; identifier generic-argument-clause[opt]<br>to:<br></p><p>primary-expression -&gt; unqualified-name generic-argument-clause[opt]<br></p><p>unqualified-name -&gt; identifier<br>                  | identifier &#39;(&#39; ((identifier | &#39;_&#39;) &#39;:&#39;)+ &#39;)&#39;<br>Within the parentheses, the use of &quot;+&quot; is important, because it disambiguates:<br></p><p>f()<br>as a call to f rather than a reference to an f with no arguments. Zero-argument function references will still require disambiguation via contextual type information.<br></p><p> &lt;https://github.com/DougGregor/swift-evolution/tree/generalized-naming#impact-on-existing-code&gt;Impact on existing code<br></p><p>This is a purely additive feature that has no impact on existing code.<br></p><p> &lt;https://github.com/DougGregor/swift-evolution/tree/generalized-naming#alternatives-considered&gt;Alternatives considered<br></p><p>Joe Groff notes &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/003008.html&gt; that lenses are a better solution than manually retrieving getter/setter functions when the intent is to actually operate on the properties.<br></p><p>Bartlomiej Cichosz suggests &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151228/004739.html&gt; a general partial application syntax using _ as a placeholder, e.g.,<br></p><p>aGameView.insertSubview(_, aboveSubview: playingSurfaceView)<br>When all arguments are _, this provides the ability to name any method:<br></p><p>aGameView.insertSubview(_, aboveSubview: _)<br>I decided not to go with this because I don&#39;t believe we need such a general partial application syntax in Swift. Closures using the $ names are nearly as concise, and eliminate any questions about how the _ placeholder maps to an argument of the partially-applied function:<br></p><p>{ aGameView.insertSubview($0, aboveSubview: playingSurfaceView) }<br></p><p><br></p><p><br>	- Doug<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/b1e459ac/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Proposal draft #2] Naming Functions with Argument Labels</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>January 11, 2016 at 02:00:00pm</p></header><div class="content"><p>I thought that the backpacks were workable but this does look nicer.<br></p><p>Is there any way to specify which module/framework you are pulling the<br>selector from? Is that information even part of the selector? Am I<br>overestimated the usefulness of that possibility?<br></p><p>TJ<br></p><p><br>On Mon, Jan 11, 2016 at 2:03 PM, Douglas Gregor via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hi all,<br>&gt;<br>&gt; I’ve updated and simplified my “Generalized Naming for Any Function”<br>&gt; proposal to only deal with naming functions with argument labels, and<br>&gt; dropping the back-ticks. Comments welcome! Proposal is here<br>&gt;<br>&gt;<br>&gt; https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md<br>&gt;<br>&gt; and inline:<br>&gt;<br>&gt; Naming Functions with Argument Labels<br>&gt;<br>&gt;    - Proposal: SE-NNNN<br>&gt;    &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0000-generalized-naming.md&gt;<br>&gt;    - Author(s): Doug Gregor &lt;https://github.com/DougGregor&gt;<br>&gt;    - Status: *Awaiting Review*<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/DougGregor/swift-evolution/tree/generalized-naming#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; Swift includes support for first-class functions, such that any function<br>&gt; (or method) can be placed into a value of function type. However, when<br>&gt; specifying the name of a function, one can only provide the base name,<br>&gt; (e.g., insertSubview) without the argument labels. For overloaded<br>&gt; functions, this means that one must disambiguate based on type information,<br>&gt; which is awkward and verbose. This proposal allwos one<br>&gt;<br>&gt; it is not possible to specifically name every function that is part of a<br>&gt; Swift program---one cannot provide the argument labels when naming a<br>&gt; function, nor are property and subscript getters and setters referenceable.<br>&gt; This proposal introduces a general syntax that allows one to name anything<br>&gt; that is a function within Swift in an extensible manner.<br>&gt;<br>&gt; Swift-evolution thread: The first draft of this proposal was discussed<br>&gt; here<br>&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151221/004555.html&gt;.<br>&gt; It included support for naming getters/setters (separately brought up by<br>&gt; Michael Henson here<br>&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html&gt;,<br>&gt; continued here<br>&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002203.html&gt;).<br>&gt; Joe Groff convinced<br>&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151221/004579.html&gt; me<br>&gt; that lenses are a better approach for working with getters/setters, so I&#39;ve<br>&gt; dropped them from this version of the proposal.<br>&gt;<br>&gt; &lt;https://github.com/DougGregor/swift-evolution/tree/generalized-naming#motivation&gt;<br>&gt; Motivation<br>&gt;<br>&gt; It&#39;s fairly common in Swift for multiple functions or methods to have the<br>&gt; same &quot;base name&quot;, but be distinguished by parameter labels. For example,<br>&gt; UIView has three methods with the same base name insertSubview:<br>&gt;<br>&gt; extension UIView {<br>&gt;   func insertSubview(view: UIView, at index: Int)<br>&gt;   func insertSubview(view: UIView, aboveSubview siblingSubview: UIView)<br>&gt;   func insertSubview(view: UIView, belowSubview siblingSubview: UIView)<br>&gt; }<br>&gt;<br>&gt; When calling these methods, the argument labels distinguish the different<br>&gt; methods, e.g.,<br>&gt;<br>&gt; someView.insertSubview(view, at: 3)<br>&gt; someView.insertSubview(view, aboveSubview: otherView)<br>&gt; someView.insertSubview(view, belowSubview: otherView)<br>&gt;<br>&gt; However, when referencing the function to create a function value, one<br>&gt; cannot provide the labels:<br>&gt;<br>&gt; let fn = someView.insertSubview // ambiguous: could be any of the three methods<br>&gt;<br>&gt; In some cases, it is possible to use type annotations to disambiguate:<br>&gt;<br>&gt; let fn: (UIView, Int) = someView.insertSubview    // ok: uses insertSubview(_:at:)let fn: (UIView, UIView) = someView.insertSubview // error: still ambiguous!<br>&gt;<br>&gt; To resolve the latter case, one must fall back to creating a closure:<br>&gt;<br>&gt; let fn: (UIView, UIView) = { view, otherView in<br>&gt;   button.insertSubview(view, aboveSubview: otherView)<br>&gt; }<br>&gt;<br>&gt; which is painfully tedious.<br>&gt;<br>&gt; One additional bit of motivation: Swift should probably get some way to<br>&gt; ask for the Objective-C selector for a given method (rather than writing a<br>&gt; string literal). The argument to such an operation would likely be a<br>&gt; reference to a method, which would benefit from being able to name any<br>&gt; method, including getters and setters.<br>&gt;<br>&gt; &lt;https://github.com/DougGregor/swift-evolution/tree/generalized-naming#proposed-solution&gt;Proposed<br>&gt; solution<br>&gt;<br>&gt; I propose to extend function naming to allow compound Swift names (e.g.,<br>&gt; insertSubview(_:aboveSubview:)) anywhere a name can occur. Specifically,<br>&gt;<br>&gt; let fn = someView.insertSubview(_:at:)let fn1 = someView.insertSubview(_:aboveSubview:)<br>&gt;<br>&gt; The same syntax can also refer to initializers, e.g.,<br>&gt;<br>&gt; let buttonFactory = UIButton.init(type:)<br>&gt;<br>&gt; The &quot;produce the Objective-C selector for the given method&quot; operation will<br>&gt; be the subject of a separate proposal. However, here is one possibility<br>&gt; that illustrations how it uses the proposed syntax here:<br>&gt;<br>&gt; let getter = Selector(NSDictionary.insertSubview(_:aboveSubview:)) // produces insertSubview:aboveSubview:.<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/DougGregor/swift-evolution/tree/generalized-naming#detailed-design&gt;Detailed<br>&gt; Design<br>&gt;<br>&gt; Grammatically, the *primary-expression* grammar will change from:<br>&gt;<br>&gt; primary-expression -&gt; identifier generic-argument-clause[opt]<br>&gt;<br>&gt; to:<br>&gt;<br>&gt; primary-expression -&gt; unqualified-name generic-argument-clause[opt]<br>&gt;<br>&gt; unqualified-name -&gt; identifier<br>&gt;                   | identifier &#39;(&#39; ((identifier | &#39;_&#39;) &#39;:&#39;)+ &#39;)&#39;<br>&gt;<br>&gt; Within the parentheses, the use of &quot;+&quot; is important, because it<br>&gt; disambiguates:<br>&gt;<br>&gt; f()<br>&gt;<br>&gt; as a call to f rather than a reference to an f with no arguments.<br>&gt; Zero-argument function references will still require disambiguation via<br>&gt; contextual type information.<br>&gt;<br>&gt; &lt;https://github.com/DougGregor/swift-evolution/tree/generalized-naming#impact-on-existing-code&gt;Impact<br>&gt; on existing code<br>&gt;<br>&gt; This is a purely additive feature that has no impact on existing code.<br>&gt;<br>&gt; &lt;https://github.com/DougGregor/swift-evolution/tree/generalized-naming#alternatives-considered&gt;Alternatives<br>&gt; considered<br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    Joe Groff notes<br>&gt;    &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/003008.html&gt;<br>&gt;     that *lenses* are a better solution than manually retrieving<br>&gt;    getter/setter functions when the intent is to actually operate on the<br>&gt;    properties.<br>&gt;    -<br>&gt;<br>&gt;    Bartlomiej Cichosz suggests<br>&gt;    &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151228/004739.html&gt; a<br>&gt;    general partial application syntax using _ as a placeholder, e.g.,<br>&gt;<br>&gt;    aGameView.insertSubview(_, aboveSubview: playingSurfaceView)<br>&gt;<br>&gt;    When all arguments are _, this provides the ability to name any method:<br>&gt;<br>&gt;    aGameView.insertSubview(_, aboveSubview: _)<br>&gt;<br>&gt;    I decided not to go with this because I don&#39;t believe we need such a<br>&gt;    general partial application syntax in Swift. Closures using the $ names are<br>&gt;    nearly as concise, and eliminate any questions about how the _ placeholder<br>&gt;    maps to an argument of the partially-applied function:<br>&gt;<br>&gt;    { aGameView.insertSubview($0, aboveSubview: playingSurfaceView) }<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; - Doug<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/800e65e9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal draft #2] Naming Functions with Argument Labels</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January 11, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jan 11, 2016, at 11:12 AM, T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br>&gt; <br>&gt; I thought that the backpacks were workable but this does look nicer. <br></p><p>Backticks were workable and general but ugly.<br></p><p>&gt; <br>&gt; Is there any way to specify which module/framework you are pulling the selector from? Is that information even part of the selector? Am I overestimated the usefulness of that possibility?<br></p><p>This is about naming functions. You can use “modulename.fnname(arglabel1:arglabel2:)” to name a specific function from a module.<br></p><p>	- Doug<br></p><p>&gt; <br>&gt; TJ<br>&gt; <br>&gt; <br>&gt; On Mon, Jan 11, 2016 at 2:03 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Hi all,<br>&gt; <br>&gt; I’ve updated and simplified my “Generalized Naming for Any Function” proposal to only deal with naming functions with argument labels, and dropping the back-ticks. Comments welcome! Proposal is here<br>&gt; <br>&gt; 	https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md&gt;<br>&gt; <br>&gt; and inline:<br>&gt; <br>&gt; Naming Functions with Argument Labels<br>&gt; <br>&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0000-generalized-naming.md&gt;<br>&gt; Author(s): Doug Gregor &lt;https://github.com/DougGregor&gt;<br>&gt; Status: Awaiting Review<br>&gt; Review manager: TBD<br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/generalized-naming#introduction&gt;Introduction<br>&gt; <br>&gt; Swift includes support for first-class functions, such that any function (or method) can be placed into a value of function type. However, when specifying the name of a function, one can only provide the base name, (e.g., insertSubview) without the argument labels. For overloaded functions, this means that one must disambiguate based on type information, which is awkward and verbose. This proposal allwos one <br>&gt; <br>&gt; it is not possible to specifically name every function that is part of a Swift program---one cannot provide the argument labels when naming a function, nor are property and subscript getters and setters referenceable. This proposal introduces a general syntax that allows one to name anything that is a function within Swift in an extensible manner.<br>&gt; <br>&gt; Swift-evolution thread: The first draft of this proposal was discussed here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151221/004555.html&gt;. It included support for naming getters/setters (separately brought up by Michael Henson here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html&gt;, continued here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002203.html&gt;). Joe Groff convinced &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151221/004579.html&gt; me that lenses are a better approach for working with getters/setters, so I&#39;ve dropped them from this version of the proposal.<br>&gt; <br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/generalized-naming#motivation&gt;Motivation<br>&gt; <br>&gt; It&#39;s fairly common in Swift for multiple functions or methods to have the same &quot;base name&quot;, but be distinguished by parameter labels. For example, UIView has three methods with the same base name insertSubview:<br>&gt; <br>&gt; extension UIView {<br>&gt;   func insertSubview(view: UIView, at index: Int)<br>&gt;   func insertSubview(view: UIView, aboveSubview siblingSubview: UIView)<br>&gt;   func insertSubview(view: UIView, belowSubview siblingSubview: UIView)<br>&gt; }<br>&gt; When calling these methods, the argument labels distinguish the different methods, e.g.,<br>&gt; <br>&gt; someView.insertSubview(view, at: 3)<br>&gt; someView.insertSubview(view, aboveSubview: otherView)<br>&gt; someView.insertSubview(view, belowSubview: otherView)<br>&gt; However, when referencing the function to create a function value, one cannot provide the labels:<br>&gt; <br>&gt; let fn = someView.insertSubview // ambiguous: could be any of the three methods<br>&gt; In some cases, it is possible to use type annotations to disambiguate:<br>&gt; <br>&gt; let fn: (UIView, Int) = someView.insertSubview    // ok: uses insertSubview(_:at:)<br>&gt; let fn: (UIView, UIView) = someView.insertSubview // error: still ambiguous!<br>&gt; To resolve the latter case, one must fall back to creating a closure:<br>&gt; <br>&gt; let fn: (UIView, UIView) = { view, otherView in<br>&gt;   button.insertSubview(view, aboveSubview: otherView)<br>&gt; }<br>&gt; which is painfully tedious. <br>&gt; <br>&gt; One additional bit of motivation: Swift should probably get some way to ask for the Objective-C selector for a given method (rather than writing a string literal). The argument to such an operation would likely be a reference to a method, which would benefit from being able to name any method, including getters and setters.<br>&gt; <br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/generalized-naming#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt; I propose to extend function naming to allow compound Swift names (e.g., insertSubview(_:aboveSubview:)) anywhere a name can occur. Specifically,<br>&gt; <br>&gt; let fn = someView.insertSubview(_:at:)<br>&gt; let fn1 = someView.insertSubview(_:aboveSubview:)<br>&gt; The same syntax can also refer to initializers, e.g.,<br>&gt; <br>&gt; let buttonFactory = UIButton.init(type:)<br>&gt; The &quot;produce the Objective-C selector for the given method&quot; operation will be the subject of a separate proposal. However, here is one possibility that illustrations how it uses the proposed syntax here:<br>&gt; <br>&gt; let getter = Selector(NSDictionary.insertSubview(_:aboveSubview:)) // produces insertSubview:aboveSubview:.<br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/generalized-naming#detailed-design&gt;Detailed Design<br>&gt; <br>&gt; Grammatically, the primary-expression grammar will change from:<br>&gt; <br>&gt; primary-expression -&gt; identifier generic-argument-clause[opt]<br>&gt; to:<br>&gt; <br>&gt; primary-expression -&gt; unqualified-name generic-argument-clause[opt]<br>&gt; <br>&gt; unqualified-name -&gt; identifier<br>&gt;                   | identifier &#39;(&#39; ((identifier | &#39;_&#39;) &#39;:&#39;)+ &#39;)&#39;<br>&gt; Within the parentheses, the use of &quot;+&quot; is important, because it disambiguates:<br>&gt; <br>&gt; f()<br>&gt; as a call to f rather than a reference to an f with no arguments. Zero-argument function references will still require disambiguation via contextual type information.<br>&gt; <br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/generalized-naming#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; This is a purely additive feature that has no impact on existing code.<br>&gt; <br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/generalized-naming#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt; Joe Groff notes &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/003008.html&gt; that lenses are a better solution than manually retrieving getter/setter functions when the intent is to actually operate on the properties.<br>&gt; <br>&gt; Bartlomiej Cichosz suggests &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151228/004739.html&gt; a general partial application syntax using _ as a placeholder, e.g.,<br>&gt; <br>&gt; aGameView.insertSubview(_, aboveSubview: playingSurfaceView)<br>&gt; When all arguments are _, this provides the ability to name any method:<br>&gt; <br>&gt; aGameView.insertSubview(_, aboveSubview: _)<br>&gt; I decided not to go with this because I don&#39;t believe we need such a general partial application syntax in Swift. Closures using the $ names are nearly as concise, and eliminate any questions about how the _ placeholder maps to an argument of the partially-applied function:<br>&gt; <br>&gt; { aGameView.insertSubview($0, aboveSubview: playingSurfaceView) }<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/40b40ae1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Proposal draft #2] Naming Functions with Argument Labels</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>January 11, 2016 at 02:00:00pm</p></header><div class="content"><p>Thanks for the clarification.<br></p><p>On Mon, Jan 11, 2016 at 2:13 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Jan 11, 2016, at 11:12 AM, T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br>&gt;<br>&gt; I thought that the backpacks were workable but this does look nicer.<br>&gt;<br>&gt;<br>&gt; Backticks were workable and general but ugly.<br>&gt;<br>&gt;<br>&gt; Is there any way to specify which module/framework you are pulling the<br>&gt; selector from? Is that information even part of the selector? Am I<br>&gt; overestimated the usefulness of that possibility?<br>&gt;<br>&gt;<br>&gt; This is about naming functions. You can use<br>&gt; “modulename.fnname(arglabel1:arglabel2:)” to name a specific function from<br>&gt; a module.<br>&gt;<br>&gt; - Doug<br>&gt;<br>&gt;<br>&gt; TJ<br>&gt;<br>&gt;<br>&gt; On Mon, Jan 11, 2016 at 2:03 PM, Douglas Gregor via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Hi all,<br>&gt;&gt;<br>&gt;&gt; I’ve updated and simplified my “Generalized Naming for Any Function”<br>&gt;&gt; proposal to only deal with naming functions with argument labels, and<br>&gt;&gt; dropping the back-ticks. Comments welcome! Proposal is here<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md<br>&gt;&gt;<br>&gt;&gt; and inline:<br>&gt;&gt;<br>&gt;&gt; Naming Functions with Argument Labels<br>&gt;&gt;<br>&gt;&gt;    - Proposal: SE-NNNN<br>&gt;&gt;    &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0000-generalized-naming.md&gt;<br>&gt;&gt;    - Author(s): Doug Gregor &lt;https://github.com/DougGregor&gt;<br>&gt;&gt;    - Status: *Awaiting Review*<br>&gt;&gt;    - Review manager: TBD<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/DougGregor/swift-evolution/tree/generalized-naming#introduction&gt;<br>&gt;&gt; Introduction<br>&gt;&gt;<br>&gt;&gt; Swift includes support for first-class functions, such that any function<br>&gt;&gt; (or method) can be placed into a value of function type. However, when<br>&gt;&gt; specifying the name of a function, one can only provide the base name,<br>&gt;&gt; (e.g., insertSubview) without the argument labels. For overloaded<br>&gt;&gt; functions, this means that one must disambiguate based on type information,<br>&gt;&gt; which is awkward and verbose. This proposal allwos one<br>&gt;&gt;<br>&gt;&gt; it is not possible to specifically name every function that is part of a<br>&gt;&gt; Swift program---one cannot provide the argument labels when naming a<br>&gt;&gt; function, nor are property and subscript getters and setters referenceable.<br>&gt;&gt; This proposal introduces a general syntax that allows one to name anything<br>&gt;&gt; that is a function within Swift in an extensible manner.<br>&gt;&gt;<br>&gt;&gt; Swift-evolution thread: The first draft of this proposal was discussed<br>&gt;&gt; here<br>&gt;&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151221/004555.html&gt;.<br>&gt;&gt; It included support for naming getters/setters (separately brought up by<br>&gt;&gt; Michael Henson here<br>&gt;&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html&gt;,<br>&gt;&gt; continued here<br>&gt;&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002203.html&gt;).<br>&gt;&gt; Joe Groff convinced<br>&gt;&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151221/004579.html&gt; me<br>&gt;&gt; that lenses are a better approach for working with getters/setters, so I&#39;ve<br>&gt;&gt; dropped them from this version of the proposal.<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/DougGregor/swift-evolution/tree/generalized-naming#motivation&gt;<br>&gt;&gt; Motivation<br>&gt;&gt;<br>&gt;&gt; It&#39;s fairly common in Swift for multiple functions or methods to have the<br>&gt;&gt; same &quot;base name&quot;, but be distinguished by parameter labels. For example,<br>&gt;&gt; UIView has three methods with the same base name insertSubview:<br>&gt;&gt;<br>&gt;&gt; extension UIView {<br>&gt;&gt;   func insertSubview(view: UIView, at index: Int)<br>&gt;&gt;   func insertSubview(view: UIView, aboveSubview siblingSubview: UIView)<br>&gt;&gt;   func insertSubview(view: UIView, belowSubview siblingSubview: UIView)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; When calling these methods, the argument labels distinguish the different<br>&gt;&gt; methods, e.g.,<br>&gt;&gt;<br>&gt;&gt; someView.insertSubview(view, at: 3)<br>&gt;&gt; someView.insertSubview(view, aboveSubview: otherView)<br>&gt;&gt; someView.insertSubview(view, belowSubview: otherView)<br>&gt;&gt;<br>&gt;&gt; However, when referencing the function to create a function value, one<br>&gt;&gt; cannot provide the labels:<br>&gt;&gt;<br>&gt;&gt; let fn = someView.insertSubview // ambiguous: could be any of the three methods<br>&gt;&gt;<br>&gt;&gt; In some cases, it is possible to use type annotations to disambiguate:<br>&gt;&gt;<br>&gt;&gt; let fn: (UIView, Int) = someView.insertSubview    // ok: uses insertSubview(_:at:)let fn: (UIView, UIView) = someView.insertSubview // error: still ambiguous!<br>&gt;&gt;<br>&gt;&gt; To resolve the latter case, one must fall back to creating a closure:<br>&gt;&gt;<br>&gt;&gt; let fn: (UIView, UIView) = { view, otherView in<br>&gt;&gt;   button.insertSubview(view, aboveSubview: otherView)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; which is painfully tedious.<br>&gt;&gt;<br>&gt;&gt; One additional bit of motivation: Swift should probably get some way to<br>&gt;&gt; ask for the Objective-C selector for a given method (rather than writing a<br>&gt;&gt; string literal). The argument to such an operation would likely be a<br>&gt;&gt; reference to a method, which would benefit from being able to name any<br>&gt;&gt; method, including getters and setters.<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/DougGregor/swift-evolution/tree/generalized-naming#proposed-solution&gt;Proposed<br>&gt;&gt; solution<br>&gt;&gt;<br>&gt;&gt; I propose to extend function naming to allow compound Swift names (e.g.,<br>&gt;&gt; insertSubview(_:aboveSubview:)) anywhere a name can occur. Specifically,<br>&gt;&gt;<br>&gt;&gt; let fn = someView.insertSubview(_:at:)let fn1 = someView.insertSubview(_:aboveSubview:)<br>&gt;&gt;<br>&gt;&gt; The same syntax can also refer to initializers, e.g.,<br>&gt;&gt;<br>&gt;&gt; let buttonFactory = UIButton.init(type:)<br>&gt;&gt;<br>&gt;&gt; The &quot;produce the Objective-C selector for the given method&quot; operation<br>&gt;&gt; will be the subject of a separate proposal. However, here is one<br>&gt;&gt; possibility that illustrations how it uses the proposed syntax here:<br>&gt;&gt;<br>&gt;&gt; let getter = Selector(NSDictionary.insertSubview(_:aboveSubview:)) // produces insertSubview:aboveSubview:.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/DougGregor/swift-evolution/tree/generalized-naming#detailed-design&gt;Detailed<br>&gt;&gt; Design<br>&gt;&gt;<br>&gt;&gt; Grammatically, the *primary-expression* grammar will change from:<br>&gt;&gt;<br>&gt;&gt; primary-expression -&gt; identifier generic-argument-clause[opt]<br>&gt;&gt;<br>&gt;&gt; to:<br>&gt;&gt;<br>&gt;&gt; primary-expression -&gt; unqualified-name generic-argument-clause[opt]<br>&gt;&gt;<br>&gt;&gt; unqualified-name -&gt; identifier<br>&gt;&gt;                   | identifier &#39;(&#39; ((identifier | &#39;_&#39;) &#39;:&#39;)+ &#39;)&#39;<br>&gt;&gt;<br>&gt;&gt; Within the parentheses, the use of &quot;+&quot; is important, because it<br>&gt;&gt; disambiguates:<br>&gt;&gt;<br>&gt;&gt; f()<br>&gt;&gt;<br>&gt;&gt; as a call to f rather than a reference to an f with no arguments.<br>&gt;&gt; Zero-argument function references will still require disambiguation via<br>&gt;&gt; contextual type information.<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/DougGregor/swift-evolution/tree/generalized-naming#impact-on-existing-code&gt;Impact<br>&gt;&gt; on existing code<br>&gt;&gt;<br>&gt;&gt; This is a purely additive feature that has no impact on existing code.<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/DougGregor/swift-evolution/tree/generalized-naming#alternatives-considered&gt;Alternatives<br>&gt;&gt; considered<br>&gt;&gt;<br>&gt;&gt;    -<br>&gt;&gt;<br>&gt;&gt;    Joe Groff notes<br>&gt;&gt;    &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/003008.html&gt;<br>&gt;&gt;     that *lenses* are a better solution than manually retrieving<br>&gt;&gt;    getter/setter functions when the intent is to actually operate on the<br>&gt;&gt;    properties.<br>&gt;&gt;    -<br>&gt;&gt;<br>&gt;&gt;    Bartlomiej Cichosz suggests<br>&gt;&gt;    &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151228/004739.html&gt; a<br>&gt;&gt;    general partial application syntax using _ as a placeholder, e.g.,<br>&gt;&gt;<br>&gt;&gt;    aGameView.insertSubview(_, aboveSubview: playingSurfaceView)<br>&gt;&gt;<br>&gt;&gt;    When all arguments are _, this provides the ability to name any<br>&gt;&gt;    method:<br>&gt;&gt;<br>&gt;&gt;    aGameView.insertSubview(_, aboveSubview: _)<br>&gt;&gt;<br>&gt;&gt;    I decided not to go with this because I don&#39;t believe we need such a<br>&gt;&gt;    general partial application syntax in Swift. Closures using the $ names are<br>&gt;&gt;    nearly as concise, and eliminate any questions about how the _ placeholder<br>&gt;&gt;    maps to an argument of the partially-applied function:<br>&gt;&gt;<br>&gt;&gt;    { aGameView.insertSubview($0, aboveSubview: playingSurfaceView) }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; - Doug<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/e1c3f397/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[Proposal draft #2] Naming Functions with Argument Labels</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>January 11, 2016 at 02:00:00pm</p></header><div class="content"><p>I agree that a lot of developers might not end up using partial application if we went with Bartlomiej Cichosz&#39;s. However, it seems to me that the cost difference between his suggestion and the main one is very small, and partial application is definitely a lot more powerful. I find it pretty relevant considering that the special syntax for curried functions is going away. One parameter per underscore covers most use cases and you can fall back to closures if you need to.<br></p><p>I think that the current proposal is better than the statu quo, but I like that other solution best.<br></p><p>Félix<br></p><p>&gt; Le 11 janv. 2016 à 14:13:43, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 11, 2016, at 11:12 AM, T.J. Usiyan &lt;griotspeak at gmail.com &lt;mailto:griotspeak at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I thought that the backpacks were workable but this does look nicer. <br>&gt; <br>&gt; Backticks were workable and general but ugly.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Is there any way to specify which module/framework you are pulling the selector from? Is that information even part of the selector? Am I overestimated the usefulness of that possibility?<br>&gt; <br>&gt; This is about naming functions. You can use “modulename.fnname(arglabel1:arglabel2:)” to name a specific function from a module.<br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt;&gt; <br>&gt;&gt; TJ<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Mon, Jan 11, 2016 at 2:03 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; I’ve updated and simplified my “Generalized Naming for Any Function” proposal to only deal with naming functions with argument labels, and dropping the back-ticks. Comments welcome! Proposal is here<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md&gt;<br>&gt;&gt; <br>&gt;&gt; and inline:<br>&gt;&gt; <br>&gt;&gt; Naming Functions with Argument Labels<br>&gt;&gt; <br>&gt;&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0000-generalized-naming.md&gt;<br>&gt;&gt; Author(s): Doug Gregor &lt;https://github.com/DougGregor&gt;<br>&gt;&gt; Status: Awaiting Review<br>&gt;&gt; Review manager: TBD<br>&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/generalized-naming#introduction&gt;Introduction<br>&gt;&gt; <br>&gt;&gt; Swift includes support for first-class functions, such that any function (or method) can be placed into a value of function type. However, when specifying the name of a function, one can only provide the base name, (e.g., insertSubview) without the argument labels. For overloaded functions, this means that one must disambiguate based on type information, which is awkward and verbose. This proposal allwos one <br>&gt;&gt; <br>&gt;&gt; it is not possible to specifically name every function that is part of a Swift program---one cannot provide the argument labels when naming a function, nor are property and subscript getters and setters referenceable. This proposal introduces a general syntax that allows one to name anything that is a function within Swift in an extensible manner.<br>&gt;&gt; <br>&gt;&gt; Swift-evolution thread: The first draft of this proposal was discussed here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151221/004555.html&gt;. It included support for naming getters/setters (separately brought up by Michael Henson here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html&gt;, continued here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002203.html&gt;). Joe Groff convinced &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151221/004579.html&gt; me that lenses are a better approach for working with getters/setters, so I&#39;ve dropped them from this version of the proposal.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/generalized-naming#motivation&gt;Motivation<br>&gt;&gt; <br>&gt;&gt; It&#39;s fairly common in Swift for multiple functions or methods to have the same &quot;base name&quot;, but be distinguished by parameter labels. For example, UIView has three methods with the same base name insertSubview:<br>&gt;&gt; <br>&gt;&gt; extension UIView {<br>&gt;&gt;   func insertSubview(view: UIView, at index: Int)<br>&gt;&gt;   func insertSubview(view: UIView, aboveSubview siblingSubview: UIView)<br>&gt;&gt;   func insertSubview(view: UIView, belowSubview siblingSubview: UIView)<br>&gt;&gt; }<br>&gt;&gt; When calling these methods, the argument labels distinguish the different methods, e.g.,<br>&gt;&gt; <br>&gt;&gt; someView.insertSubview(view, at: 3)<br>&gt;&gt; someView.insertSubview(view, aboveSubview: otherView)<br>&gt;&gt; someView.insertSubview(view, belowSubview: otherView)<br>&gt;&gt; However, when referencing the function to create a function value, one cannot provide the labels:<br>&gt;&gt; <br>&gt;&gt; let fn = someView.insertSubview // ambiguous: could be any of the three methods<br>&gt;&gt; In some cases, it is possible to use type annotations to disambiguate:<br>&gt;&gt; <br>&gt;&gt; let fn: (UIView, Int) = someView.insertSubview    // ok: uses insertSubview(_:at:)<br>&gt;&gt; let fn: (UIView, UIView) = someView.insertSubview // error: still ambiguous!<br>&gt;&gt; To resolve the latter case, one must fall back to creating a closure:<br>&gt;&gt; <br>&gt;&gt; let fn: (UIView, UIView) = { view, otherView in<br>&gt;&gt;   button.insertSubview(view, aboveSubview: otherView)<br>&gt;&gt; }<br>&gt;&gt; which is painfully tedious. <br>&gt;&gt; <br>&gt;&gt; One additional bit of motivation: Swift should probably get some way to ask for the Objective-C selector for a given method (rather than writing a string literal). The argument to such an operation would likely be a reference to a method, which would benefit from being able to name any method, including getters and setters.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/generalized-naming#proposed-solution&gt;Proposed solution<br>&gt;&gt; <br>&gt;&gt; I propose to extend function naming to allow compound Swift names (e.g., insertSubview(_:aboveSubview:)) anywhere a name can occur. Specifically,<br>&gt;&gt; <br>&gt;&gt; let fn = someView.insertSubview(_:at:)<br>&gt;&gt; let fn1 = someView.insertSubview(_:aboveSubview:)<br>&gt;&gt; The same syntax can also refer to initializers, e.g.,<br>&gt;&gt; <br>&gt;&gt; let buttonFactory = UIButton.init(type:)<br>&gt;&gt; The &quot;produce the Objective-C selector for the given method&quot; operation will be the subject of a separate proposal. However, here is one possibility that illustrations how it uses the proposed syntax here:<br>&gt;&gt; <br>&gt;&gt; let getter = Selector(NSDictionary.insertSubview(_:aboveSubview:)) // produces insertSubview:aboveSubview:.<br>&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/generalized-naming#detailed-design&gt;Detailed Design<br>&gt;&gt; <br>&gt;&gt; Grammatically, the primary-expression grammar will change from:<br>&gt;&gt; <br>&gt;&gt; primary-expression -&gt; identifier generic-argument-clause[opt]<br>&gt;&gt; to:<br>&gt;&gt; <br>&gt;&gt; primary-expression -&gt; unqualified-name generic-argument-clause[opt]<br>&gt;&gt; <br>&gt;&gt; unqualified-name -&gt; identifier<br>&gt;&gt;                   | identifier &#39;(&#39; ((identifier | &#39;_&#39;) &#39;:&#39;)+ &#39;)&#39;<br>&gt;&gt; Within the parentheses, the use of &quot;+&quot; is important, because it disambiguates:<br>&gt;&gt; <br>&gt;&gt; f()<br>&gt;&gt; as a call to f rather than a reference to an f with no arguments. Zero-argument function references will still require disambiguation via contextual type information.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/generalized-naming#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt; <br>&gt;&gt; This is a purely additive feature that has no impact on existing code.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/generalized-naming#alternatives-considered&gt;Alternatives considered<br>&gt;&gt; <br>&gt;&gt; Joe Groff notes &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/003008.html&gt; that lenses are a better solution than manually retrieving getter/setter functions when the intent is to actually operate on the properties.<br>&gt;&gt; <br>&gt;&gt; Bartlomiej Cichosz suggests &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151228/004739.html&gt; a general partial application syntax using _ as a placeholder, e.g.,<br>&gt;&gt; <br>&gt;&gt; aGameView.insertSubview(_, aboveSubview: playingSurfaceView)<br>&gt;&gt; When all arguments are _, this provides the ability to name any method:<br>&gt;&gt; <br>&gt;&gt; aGameView.insertSubview(_, aboveSubview: _)<br>&gt;&gt; I decided not to go with this because I don&#39;t believe we need such a general partial application syntax in Swift. Closures using the $ names are nearly as concise, and eliminate any questions about how the _ placeholder maps to an argument of the partially-applied function:<br>&gt;&gt; <br>&gt;&gt; { aGameView.insertSubview($0, aboveSubview: playingSurfaceView) }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/83068ae5/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal draft #2] Naming Functions with Argument Labels</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January 11, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jan 11, 2016, at 11:44 AM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt; <br>&gt; I agree that a lot of developers might not end up using partial application if we went with Bartlomiej Cichosz&#39;s. However, it seems to me that the cost difference between his suggestion and the main one is very small, and partial application is definitely a lot more powerful.<br></p><p>Implementing generalized partial application is significantly more complicated than what I’m proposing.<br></p><p>&gt; I find it pretty relevant considering that the special syntax for curried functions is going away.<br></p><p>I don’t see how it’s related at all. That’s about removing special syntax for declaring curried functions; this is about naming in references to functions.<br></p><p>&gt; One parameter per underscore covers most use cases and you can fall back to closures if you need to.<br></p><p>This doesn’t seem like an area that benefits from Yet Another Intermediate Syntax.<br></p><p>	- Doug<br></p><p>&gt; <br>&gt; I think that the current proposal is better than the statu quo, but I like that other solution best.<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 11 janv. 2016 à 14:13:43, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 11, 2016, at 11:12 AM, T.J. Usiyan &lt;griotspeak at gmail.com &lt;mailto:griotspeak at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I thought that the backpacks were workable but this does look nicer. <br>&gt;&gt; <br>&gt;&gt; Backticks were workable and general but ugly.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Is there any way to specify which module/framework you are pulling the selector from? Is that information even part of the selector? Am I overestimated the usefulness of that possibility?<br>&gt;&gt; <br>&gt;&gt; This is about naming functions. You can use “modulename.fnname(arglabel1:arglabel2:)” to name a specific function from a module.<br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; TJ<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Mon, Jan 11, 2016 at 2:03 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’ve updated and simplified my “Generalized Naming for Any Function” proposal to only deal with naming functions with argument labels, and dropping the back-ticks. Comments welcome! Proposal is here<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; and inline:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Naming Functions with Argument Labels<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0000-generalized-naming.md&gt;<br>&gt;&gt;&gt; Author(s): Doug Gregor &lt;https://github.com/DougGregor&gt;<br>&gt;&gt;&gt; Status: Awaiting Review<br>&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/generalized-naming#introduction&gt;Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift includes support for first-class functions, such that any function (or method) can be placed into a value of function type. However, when specifying the name of a function, one can only provide the base name, (e.g., insertSubview) without the argument labels. For overloaded functions, this means that one must disambiguate based on type information, which is awkward and verbose. This proposal allwos one <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; it is not possible to specifically name every function that is part of a Swift program---one cannot provide the argument labels when naming a function, nor are property and subscript getters and setters referenceable. This proposal introduces a general syntax that allows one to name anything that is a function within Swift in an extensible manner.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift-evolution thread: The first draft of this proposal was discussed here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151221/004555.html&gt;. It included support for naming getters/setters (separately brought up by Michael Henson here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html&gt;, continued here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002203.html&gt;). Joe Groff convinced &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151221/004579.html&gt; me that lenses are a better approach for working with getters/setters, so I&#39;ve dropped them from this version of the proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/generalized-naming#motivation&gt;Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It&#39;s fairly common in Swift for multiple functions or methods to have the same &quot;base name&quot;, but be distinguished by parameter labels. For example, UIView has three methods with the same base name insertSubview:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension UIView {<br>&gt;&gt;&gt;   func insertSubview(view: UIView, at index: Int)<br>&gt;&gt;&gt;   func insertSubview(view: UIView, aboveSubview siblingSubview: UIView)<br>&gt;&gt;&gt;   func insertSubview(view: UIView, belowSubview siblingSubview: UIView)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; When calling these methods, the argument labels distinguish the different methods, e.g.,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; someView.insertSubview(view, at: 3)<br>&gt;&gt;&gt; someView.insertSubview(view, aboveSubview: otherView)<br>&gt;&gt;&gt; someView.insertSubview(view, belowSubview: otherView)<br>&gt;&gt;&gt; However, when referencing the function to create a function value, one cannot provide the labels:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let fn = someView.insertSubview // ambiguous: could be any of the three methods<br>&gt;&gt;&gt; In some cases, it is possible to use type annotations to disambiguate:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let fn: (UIView, Int) = someView.insertSubview    // ok: uses insertSubview(_:at:)<br>&gt;&gt;&gt; let fn: (UIView, UIView) = someView.insertSubview // error: still ambiguous!<br>&gt;&gt;&gt; To resolve the latter case, one must fall back to creating a closure:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let fn: (UIView, UIView) = { view, otherView in<br>&gt;&gt;&gt;   button.insertSubview(view, aboveSubview: otherView)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; which is painfully tedious. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One additional bit of motivation: Swift should probably get some way to ask for the Objective-C selector for a given method (rather than writing a string literal). The argument to such an operation would likely be a reference to a method, which would benefit from being able to name any method, including getters and setters.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/generalized-naming#proposed-solution&gt;Proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I propose to extend function naming to allow compound Swift names (e.g., insertSubview(_:aboveSubview:)) anywhere a name can occur. Specifically,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let fn = someView.insertSubview(_:at:)<br>&gt;&gt;&gt; let fn1 = someView.insertSubview(_:aboveSubview:)<br>&gt;&gt;&gt; The same syntax can also refer to initializers, e.g.,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let buttonFactory = UIButton.init(type:)<br>&gt;&gt;&gt; The &quot;produce the Objective-C selector for the given method&quot; operation will be the subject of a separate proposal. However, here is one possibility that illustrations how it uses the proposed syntax here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let getter = Selector(NSDictionary.insertSubview(_:aboveSubview:)) // produces insertSubview:aboveSubview:.<br>&gt;&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/generalized-naming#detailed-design&gt;Detailed Design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Grammatically, the primary-expression grammar will change from:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; primary-expression -&gt; identifier generic-argument-clause[opt]<br>&gt;&gt;&gt; to:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; primary-expression -&gt; unqualified-name generic-argument-clause[opt]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; unqualified-name -&gt; identifier<br>&gt;&gt;&gt;                   | identifier &#39;(&#39; ((identifier | &#39;_&#39;) &#39;:&#39;)+ &#39;)&#39;<br>&gt;&gt;&gt; Within the parentheses, the use of &quot;+&quot; is important, because it disambiguates:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; f()<br>&gt;&gt;&gt; as a call to f rather than a reference to an f with no arguments. Zero-argument function references will still require disambiguation via contextual type information.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/generalized-naming#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a purely additive feature that has no impact on existing code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/generalized-naming#alternatives-considered&gt;Alternatives considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Joe Groff notes &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/003008.html&gt; that lenses are a better solution than manually retrieving getter/setter functions when the intent is to actually operate on the properties.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Bartlomiej Cichosz suggests &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151228/004739.html&gt; a general partial application syntax using _ as a placeholder, e.g.,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; aGameView.insertSubview(_, aboveSubview: playingSurfaceView)<br>&gt;&gt;&gt; When all arguments are _, this provides the ability to name any method:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; aGameView.insertSubview(_, aboveSubview: _)<br>&gt;&gt;&gt; I decided not to go with this because I don&#39;t believe we need such a general partial application syntax in Swift. Closures using the $ names are nearly as concise, and eliminate any questions about how the _ placeholder maps to an argument of the partially-applied function:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; { aGameView.insertSubview($0, aboveSubview: playingSurfaceView) }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/c4c75b0d/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Proposal draft #2] Naming Functions with Argument Labels</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>January 11, 2016 at 08:00:00pm</p></header><div class="content"><p>I haven&#39;t had issues with ambiguous function names, but it just feels odd that there is no elegant way to solve those problems, so I agree that something should be done here.<br></p><p>Speaking of the details, &quot;(&quot; always is an indication to me that there is a function to be called (not only referenced). Are there any special reasons for the parenthesis in this context?<br>Wouldn&#39;t parsing be easier when we just leave out &quot;(&quot;, &quot;)&quot; and &quot;_&quot;?<br>let fn1 = someView.insertSubview:aboveSubview:<br>imho looks better.<br></p><p>Best regards,<br>Tino<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/30c0cc36/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal draft #2] Naming Functions with Argument Labels</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January 11, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jan 11, 2016, at 11:38 AM, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt; <br>&gt; I haven&#39;t had issues with ambiguous function names, but it just feels odd that there is no elegant way to solve those problems, so I agree that something should be done here.<br>&gt; <br>&gt; Speaking of the details, &quot;(&quot; always is an indication to me that there is a function to be called (not only referenced). Are there any special reasons for the parenthesis in this context?<br></p><p>That’s how we write Swift function names: basename(arglabel1:arglabel2:…arglabelN:).<br></p><p>&gt; Wouldn&#39;t parsing be easier when we just leave out &quot;(&quot;, &quot;)&quot; and &quot;_”?<br></p><p>Parsing is easy either way.<br></p><p>&gt; let fn1 = someView.insertSubview:aboveSubview:<br>&gt; imho looks better.<br></p><p>Sometimes the first argument has a label, so just dropping it doesn’t actually work. It would have to be<br></p><p>	let fn1 = someView.insertSubview:_:aboveSubview:<br></p><p>or <br></p><p>	let fn1 = someView.insertSubview::aboveSubview:<br></p><p>which looks almost like the Objective-C selector, but isn’t. And it doesn’t match the way these methods are called.<br></p><p>	- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/e5f9eb46/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b660eecceda60138f137d353b8289925?s=50"></div><header><strong>[Proposal draft #2] Naming Functions with Argument Labels</strong> from <string>Janosch Hildebrand</string> &lt;jnosh at jnosh.com&gt;<p>January 11, 2016 at 09:00:00pm</p></header><div class="content"><p>This is looking great and I&#39;m happy that the back-ticks are gone.<br></p><p><br>And just as a quick aside on the proposal text, something probably went amiss between these two sentences:<br>&gt; This proposal allwos one <br>&gt; <br>&gt; it is not possible to specifically name every function that is part of a Swift program<br>&gt; <br></p><p>- Janosch<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/3455fb3b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal draft #2] Naming Functions with Argument Labels</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January 11, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jan 11, 2016, at 12:48 PM, Janosch Hildebrand &lt;jnosh at jnosh.com&gt; wrote:<br>&gt; <br>&gt; This is looking great and I&#39;m happy that the back-ticks are gone.<br>&gt; <br>&gt; <br>&gt; And just as a quick aside on the proposal text, something probably went amiss between these two sentences:<br>&gt; <br>&gt;&gt; This proposal allwos one <br>&gt;&gt; <br>&gt;&gt; it is not possible to specifically name every function that is part of a Swift program<br>&gt;&gt; <br>&gt; <br>&gt; - Janosch<br>&gt; <br></p><p>Whoops, thanks!<br></p><p>	- Doug<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/05a78770/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal draft #2] Naming Functions with Argument Labels</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 11, 2016 at 12:00:00pm</p></header><div class="content"><p>SGTM. A few points I didn&#39;t see addressed from the last thread:<br></p><p>- Do we need the &#39;_&#39; representing unlabeled arguments? &#39;foo(:bar:)&#39; should be workable, as in ObjC.<br>- How do references to defaulted or variadic arguments work? Do you have to reference their labels completely in declared order, or could you refer to &#39;func foo(x: Int = 5, y: String = &quot;&quot;)&#39; as &#39;foo(y:x:)&#39;, &#39;foo(x:)&#39;, and/or &#39;foo(y:)&#39; as well?<br></p><p>-Joe<br></p><p>&gt; On Jan 11, 2016, at 11:03 AM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi all,<br>&gt; <br>&gt; I’ve updated and simplified my “Generalized Naming for Any Function” proposal to only deal with naming functions with argument labels, and dropping the back-ticks. Comments welcome! Proposal is here<br>&gt; <br>&gt; 	https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md&gt;<br>&gt; <br>&gt; and inline:<br>&gt; <br>&gt; Naming Functions with Argument Labels<br>&gt; <br>&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0000-generalized-naming.md&gt;<br>&gt; Author(s): Doug Gregor &lt;https://github.com/DougGregor&gt;<br>&gt; Status: Awaiting Review<br>&gt; Review manager: TBD<br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/generalized-naming#introduction&gt;Introduction<br>&gt; <br>&gt; Swift includes support for first-class functions, such that any function (or method) can be placed into a value of function type. However, when specifying the name of a function, one can only provide the base name, (e.g., insertSubview) without the argument labels. For overloaded functions, this means that one must disambiguate based on type information, which is awkward and verbose. This proposal allwos one <br>&gt; <br>&gt; it is not possible to specifically name every function that is part of a Swift program---one cannot provide the argument labels when naming a function, nor are property and subscript getters and setters referenceable. This proposal introduces a general syntax that allows one to name anything that is a function within Swift in an extensible manner.<br>&gt; <br>&gt; Swift-evolution thread: The first draft of this proposal was discussed here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151221/004555.html&gt;. It included support for naming getters/setters (separately brought up by Michael Henson here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html&gt;, continued here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002203.html&gt;). Joe Groff convinced &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151221/004579.html&gt; me that lenses are a better approach for working with getters/setters, so I&#39;ve dropped them from this version of the proposal.<br>&gt; <br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/generalized-naming#motivation&gt;Motivation<br>&gt; <br>&gt; It&#39;s fairly common in Swift for multiple functions or methods to have the same &quot;base name&quot;, but be distinguished by parameter labels. For example, UIView has three methods with the same base name insertSubview:<br>&gt; <br>&gt; extension UIView {<br>&gt;   func insertSubview(view: UIView, at index: Int)<br>&gt;   func insertSubview(view: UIView, aboveSubview siblingSubview: UIView)<br>&gt;   func insertSubview(view: UIView, belowSubview siblingSubview: UIView)<br>&gt; }<br>&gt; When calling these methods, the argument labels distinguish the different methods, e.g.,<br>&gt; <br>&gt; someView.insertSubview(view, at: 3)<br>&gt; someView.insertSubview(view, aboveSubview: otherView)<br>&gt; someView.insertSubview(view, belowSubview: otherView)<br>&gt; However, when referencing the function to create a function value, one cannot provide the labels:<br>&gt; <br>&gt; let fn = someView.insertSubview // ambiguous: could be any of the three methods<br>&gt; In some cases, it is possible to use type annotations to disambiguate:<br>&gt; <br>&gt; let fn: (UIView, Int) = someView.insertSubview    // ok: uses insertSubview(_:at:)<br>&gt; let fn: (UIView, UIView) = someView.insertSubview // error: still ambiguous!<br>&gt; To resolve the latter case, one must fall back to creating a closure:<br>&gt; <br>&gt; let fn: (UIView, UIView) = { view, otherView in<br>&gt;   button.insertSubview(view, aboveSubview: otherView)<br>&gt; }<br>&gt; which is painfully tedious. <br>&gt; <br>&gt; One additional bit of motivation: Swift should probably get some way to ask for the Objective-C selector for a given method (rather than writing a string literal). The argument to such an operation would likely be a reference to a method, which would benefit from being able to name any method, including getters and setters.<br>&gt; <br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/generalized-naming#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt; I propose to extend function naming to allow compound Swift names (e.g., insertSubview(_:aboveSubview:)) anywhere a name can occur. Specifically,<br>&gt; <br>&gt; let fn = someView.insertSubview(_:at:)<br>&gt; let fn1 = someView.insertSubview(_:aboveSubview:)<br>&gt; The same syntax can also refer to initializers, e.g.,<br>&gt; <br>&gt; let buttonFactory = UIButton.init(type:)<br>&gt; The &quot;produce the Objective-C selector for the given method&quot; operation will be the subject of a separate proposal. However, here is one possibility that illustrations how it uses the proposed syntax here:<br>&gt; <br>&gt; let getter = Selector(NSDictionary.insertSubview(_:aboveSubview:)) // produces insertSubview:aboveSubview:.<br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/generalized-naming#detailed-design&gt;Detailed Design<br>&gt; <br>&gt; Grammatically, the primary-expression grammar will change from:<br>&gt; <br>&gt; primary-expression -&gt; identifier generic-argument-clause[opt]<br>&gt; to:<br>&gt; <br>&gt; primary-expression -&gt; unqualified-name generic-argument-clause[opt]<br>&gt; <br>&gt; unqualified-name -&gt; identifier<br>&gt;                   | identifier &#39;(&#39; ((identifier | &#39;_&#39;) &#39;:&#39;)+ &#39;)&#39;<br>&gt; Within the parentheses, the use of &quot;+&quot; is important, because it disambiguates:<br>&gt; <br>&gt; f()<br>&gt; as a call to f rather than a reference to an f with no arguments. Zero-argument function references will still require disambiguation via contextual type information.<br>&gt; <br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/generalized-naming#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; This is a purely additive feature that has no impact on existing code.<br>&gt; <br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/generalized-naming#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt; Joe Groff notes &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/003008.html&gt; that lenses are a better solution than manually retrieving getter/setter functions when the intent is to actually operate on the properties.<br>&gt; <br>&gt; Bartlomiej Cichosz suggests &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151228/004739.html&gt; a general partial application syntax using _ as a placeholder, e.g.,<br>&gt; <br>&gt; aGameView.insertSubview(_, aboveSubview: playingSurfaceView)<br>&gt; When all arguments are _, this provides the ability to name any method:<br>&gt; <br>&gt; aGameView.insertSubview(_, aboveSubview: _)<br>&gt; I decided not to go with this because I don&#39;t believe we need such a general partial application syntax in Swift. Closures using the $ names are nearly as concise, and eliminate any questions about how the _ placeholder maps to an argument of the partially-applied function:<br>&gt; <br>&gt; { aGameView.insertSubview($0, aboveSubview: playingSurfaceView) }<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/4bd00aa3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal draft #2] Naming Functions with Argument Labels</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January 11, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jan 11, 2016, at 12:49 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; SGTM. A few points I didn&#39;t see addressed from the last thread:<br>&gt; <br>&gt; - Do we need the &#39;_&#39; representing unlabeled arguments? &#39;foo(:bar:)&#39; should be workable, as in ObjC.<br></p><p>We discussed this a looooong while back and decided that we wanted the ‘_’ to emphasize that there is an argument there. The difference between “foo(:bar:)” and “foo(bar:)” is barely visible.<br></p><p>&gt; - How do references to defaulted or variadic arguments work? Do you have to reference their labels completely in declared order, or could you refer to &#39;func foo(x: Int = 5, y: String = &quot;&quot;)&#39; as &#39;foo(y:x:)&#39;, &#39;foo(x:)&#39;, and/or &#39;foo(y:)&#39; as well?<br></p><p>You have to reference their labels completely in declared order; that’s the name of the method.<br></p><p>	- Doug<br></p><p>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; On Jan 11, 2016, at 11:03 AM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; I’ve updated and simplified my “Generalized Naming for Any Function” proposal to only deal with naming functions with argument labels, and dropping the back-ticks. Comments welcome! Proposal is here<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md&gt;<br>&gt;&gt; <br>&gt;&gt; and inline:<br>&gt;&gt; <br>&gt;&gt; Naming Functions with Argument Labels<br>&gt;&gt; <br>&gt;&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0000-generalized-naming.md&gt;<br>&gt;&gt; Author(s): Doug Gregor &lt;https://github.com/DougGregor&gt;<br>&gt;&gt; Status: Awaiting Review<br>&gt;&gt; Review manager: TBD<br>&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/generalized-naming#introduction&gt;Introduction<br>&gt;&gt; <br>&gt;&gt; Swift includes support for first-class functions, such that any function (or method) can be placed into a value of function type. However, when specifying the name of a function, one can only provide the base name, (e.g., insertSubview) without the argument labels. For overloaded functions, this means that one must disambiguate based on type information, which is awkward and verbose. This proposal allwos one <br>&gt;&gt; <br>&gt;&gt; it is not possible to specifically name every function that is part of a Swift program---one cannot provide the argument labels when naming a function, nor are property and subscript getters and setters referenceable. This proposal introduces a general syntax that allows one to name anything that is a function within Swift in an extensible manner.<br>&gt;&gt; <br>&gt;&gt; Swift-evolution thread: The first draft of this proposal was discussed here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151221/004555.html&gt;. It included support for naming getters/setters (separately brought up by Michael Henson here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html&gt;, continued here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002203.html&gt;). Joe Groff convinced &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151221/004579.html&gt; me that lenses are a better approach for working with getters/setters, so I&#39;ve dropped them from this version of the proposal.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/generalized-naming#motivation&gt;Motivation<br>&gt;&gt; <br>&gt;&gt; It&#39;s fairly common in Swift for multiple functions or methods to have the same &quot;base name&quot;, but be distinguished by parameter labels. For example, UIView has three methods with the same base name insertSubview:<br>&gt;&gt; <br>&gt;&gt; extension UIView {<br>&gt;&gt;   func insertSubview(view: UIView, at index: Int)<br>&gt;&gt;   func insertSubview(view: UIView, aboveSubview siblingSubview: UIView)<br>&gt;&gt;   func insertSubview(view: UIView, belowSubview siblingSubview: UIView)<br>&gt;&gt; }<br>&gt;&gt; When calling these methods, the argument labels distinguish the different methods, e.g.,<br>&gt;&gt; <br>&gt;&gt; someView.insertSubview(view, at: 3)<br>&gt;&gt; someView.insertSubview(view, aboveSubview: otherView)<br>&gt;&gt; someView.insertSubview(view, belowSubview: otherView)<br>&gt;&gt; However, when referencing the function to create a function value, one cannot provide the labels:<br>&gt;&gt; <br>&gt;&gt; let fn = someView.insertSubview // ambiguous: could be any of the three methods<br>&gt;&gt; In some cases, it is possible to use type annotations to disambiguate:<br>&gt;&gt; <br>&gt;&gt; let fn: (UIView, Int) = someView.insertSubview    // ok: uses insertSubview(_:at:)<br>&gt;&gt; let fn: (UIView, UIView) = someView.insertSubview // error: still ambiguous!<br>&gt;&gt; To resolve the latter case, one must fall back to creating a closure:<br>&gt;&gt; <br>&gt;&gt; let fn: (UIView, UIView) = { view, otherView in<br>&gt;&gt;   button.insertSubview(view, aboveSubview: otherView)<br>&gt;&gt; }<br>&gt;&gt; which is painfully tedious. <br>&gt;&gt; <br>&gt;&gt; One additional bit of motivation: Swift should probably get some way to ask for the Objective-C selector for a given method (rather than writing a string literal). The argument to such an operation would likely be a reference to a method, which would benefit from being able to name any method, including getters and setters.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/generalized-naming#proposed-solution&gt;Proposed solution<br>&gt;&gt; <br>&gt;&gt; I propose to extend function naming to allow compound Swift names (e.g., insertSubview(_:aboveSubview:)) anywhere a name can occur. Specifically,<br>&gt;&gt; <br>&gt;&gt; let fn = someView.insertSubview(_:at:)<br>&gt;&gt; let fn1 = someView.insertSubview(_:aboveSubview:)<br>&gt;&gt; The same syntax can also refer to initializers, e.g.,<br>&gt;&gt; <br>&gt;&gt; let buttonFactory = UIButton.init(type:)<br>&gt;&gt; The &quot;produce the Objective-C selector for the given method&quot; operation will be the subject of a separate proposal. However, here is one possibility that illustrations how it uses the proposed syntax here:<br>&gt;&gt; <br>&gt;&gt; let getter = Selector(NSDictionary.insertSubview(_:aboveSubview:)) // produces insertSubview:aboveSubview:.<br>&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/generalized-naming#detailed-design&gt;Detailed Design<br>&gt;&gt; <br>&gt;&gt; Grammatically, the primary-expression grammar will change from:<br>&gt;&gt; <br>&gt;&gt; primary-expression -&gt; identifier generic-argument-clause[opt]<br>&gt;&gt; to:<br>&gt;&gt; <br>&gt;&gt; primary-expression -&gt; unqualified-name generic-argument-clause[opt]<br>&gt;&gt; <br>&gt;&gt; unqualified-name -&gt; identifier<br>&gt;&gt;                   | identifier &#39;(&#39; ((identifier | &#39;_&#39;) &#39;:&#39;)+ &#39;)&#39;<br>&gt;&gt; Within the parentheses, the use of &quot;+&quot; is important, because it disambiguates:<br>&gt;&gt; <br>&gt;&gt; f()<br>&gt;&gt; as a call to f rather than a reference to an f with no arguments. Zero-argument function references will still require disambiguation via contextual type information.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/generalized-naming#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt; <br>&gt;&gt; This is a purely additive feature that has no impact on existing code.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/generalized-naming#alternatives-considered&gt;Alternatives considered<br>&gt;&gt; <br>&gt;&gt; Joe Groff notes &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/003008.html&gt; that lenses are a better solution than manually retrieving getter/setter functions when the intent is to actually operate on the properties.<br>&gt;&gt; <br>&gt;&gt; Bartlomiej Cichosz suggests &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151228/004739.html&gt; a general partial application syntax using _ as a placeholder, e.g.,<br>&gt;&gt; <br>&gt;&gt; aGameView.insertSubview(_, aboveSubview: playingSurfaceView)<br>&gt;&gt; When all arguments are _, this provides the ability to name any method:<br>&gt;&gt; <br>&gt;&gt; aGameView.insertSubview(_, aboveSubview: _)<br>&gt;&gt; I decided not to go with this because I don&#39;t believe we need such a general partial application syntax in Swift. Closures using the $ names are nearly as concise, and eliminate any questions about how the _ placeholder maps to an argument of the partially-applied function:<br>&gt;&gt; <br>&gt;&gt; { aGameView.insertSubview($0, aboveSubview: playingSurfaceView) }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/eba8999c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Proposal draft #2] Naming Functions with Argument Labels</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>January 11, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; We discussed this a looooong while back and decided that we wanted the ‘_’ to emphasize that there is an argument there. The difference between “foo(:bar:)” and “foo(bar:)” is barely visible.<br>That is true, but I think it is very uncommon to have such a set of methods — and afaics, it would violate the guidelines for method names.<br></p><p>But speaking of additional characters that might be useful:<br>What about the parameter types? When they are needed to identify the exact function, it would be nice if they could be included as well.<br></p><p>foo(bar:(Int))<br>(that&#39;s why I wanted to avoid the parenthesis in the first place…)<br></p><p>Tino<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/d83cc705/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal draft #2] Naming Functions with Argument Labels</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January 11, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jan 11, 2016, at 1:53 PM, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt; <br>&gt;&gt; We discussed this a looooong while back and decided that we wanted the ‘_’ to emphasize that there is an argument there. The difference between “foo(:bar:)” and “foo(bar:)” is barely visible.<br>&gt; That is true, but I think it is very uncommon to have such a set of methods — and afaics, it would violate the guidelines for method names.<br>&gt; <br>&gt; But speaking of additional characters that might be useful:<br>&gt; What about the parameter types? When they are needed to identify the exact function, it would be nice if they could be included as well.<br>&gt; <br>&gt; foo(bar:(Int))<br>&gt; (that&#39;s why I wanted to avoid the parenthesis in the first place…)<br></p><p>It’s grammatically ambiguous if you don’t have the “:)” at the end and, IMO, it’s not important enough to have special syntax for this: one can still coerce to a specific function type.<br></p><p>	- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/6851c9f8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Proposal draft #2] Naming Functions with Argument Labels</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>January 11, 2016 at 11:00:00pm</p></header><div class="content"><p>I really like this proposal and looking forward to the objc selector binding.<br></p><p>&gt; On 11 Jan 2016, at 22:54, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 11, 2016, at 1:53 PM, Tino Heth &lt;2th at gmx.de &lt;mailto:2th at gmx.de&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; We discussed this a looooong while back and decided that we wanted the ‘_’ to emphasize that there is an argument there. The difference between “foo(:bar:)” and “foo(bar:)” is barely visible.<br>&gt;&gt; That is true, but I think it is very uncommon to have such a set of methods — and afaics, it would violate the guidelines for method names.<br>&gt;&gt; <br>&gt;&gt; But speaking of additional characters that might be useful:<br>&gt;&gt; What about the parameter types? When they are needed to identify the exact function, it would be nice if they could be included as well.<br>&gt;&gt; <br>&gt;&gt; foo(bar:(Int))<br>&gt;&gt; (that&#39;s why I wanted to avoid the parenthesis in the first place…)<br>&gt; <br>&gt; It’s grammatically ambiguous if you don’t have the “:)” at the end and, IMO, it’s not important enough to have special syntax for this: one can still coerce to a specific function type.<br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/d0def0dd/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>[Proposal draft #2] Naming Functions with Argument Labels</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>January 12, 2016 at 10:00:00am</p></header><div class="content"><p>I&#39;m for this proposal, but not for the syntax. If this proposal is mutually<br>exclusive with Bartlomiej&#39;s then I am -1 on Douglas&#39;.<br></p><p>I was initially against _, but it is necessary to disambiguate cases like<br>this:<br></p><p>    naming a function: MyStruct.test(_),<br>    calling a function: MyStruct.test()<br></p><p>However I think that the syntax is closer to something we&#39;d expect in<br>Objective-C than in Swift. I wonder if it would make sense to someone<br>unfamiliar with Objective-C.<br></p><p>Consider:<br>    struct MyStruct {<br>        static func test(a: Int, _ b: Int, _ c: Int) {}<br>    }<br>    MyStruct.test(1,2,3) // calling the function<br>    MyStruct.test(_:_:_) // naming the function<br></p><p>In this case I would expect to name the function like one of these:<br>    MyStruct.test(_,_,_)<br>    MyStruct.test(,,)<br></p><p>I would +1 this proposal if the syntax was like this:<br>    let fn1 = someView.insertSubview(_,aboveSubview:_)<br>    let fn = someView.insertSubview(_,at:_)<br></p><p>Instead of:<br>    let fn1 = someView.insertSubview(_:aboveSubview:)<br>    let fn = someView.insertSubview(_:at:)<br></p><p>I think it&#39;s more consistent with other *Swift* function syntax.<br>Additionally it is compatible with the syntax Bartlomiej proposes (see fn1).<br></p><p>Perhaps you can make the _ optional (for disambiguation), but commas should<br>be consistent with declaration/calling syntax.<br></p><p>On Tue, Jan 12, 2016 at 8:54 AM, Douglas Gregor via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Jan 11, 2016, at 1:53 PM, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt;<br>&gt; We discussed this a looooong while back and decided that we wanted the<br>‘_’ to emphasize that there is an argument there. The difference between<br>“foo(:bar:)” and “foo(bar:)” is barely visible.<br>&gt;<br>&gt; That is true, but I think it is very uncommon to have such a set of<br>methods — and afaics, it would violate the guidelines for method names.<br>&gt;<br>&gt; But speaking of additional characters that might be useful:<br>&gt; What about the parameter types? When they are needed to identify the<br>exact function, it would be nice if they could be included as well.<br>&gt;<br>&gt; foo(bar:(Int))<br>&gt; (that&#39;s why I wanted to avoid the parenthesis in the first place…)<br>&gt;<br>&gt;<br>&gt; It’s grammatically ambiguous if you don’t have the “:)” at the end and,<br>IMO, it’s not important enough to have special syntax for this: one can<br>still coerce to a specific function type.<br>&gt;<br>&gt; - Doug<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160112/17be14a2/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal draft #2] Naming Functions with Argument Labels</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January 11, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt;&gt; foo(bar:(Int))<br>&gt;&gt; (that&#39;s why I wanted to avoid the parenthesis in the first place…)<br>&gt; <br>&gt; It’s grammatically ambiguous if you don’t have the “:)” at the end<br></p><p>Is it? It&#39;s not legal to pass a type name—`foo(bar: Int)` is not legal code; you have to say `foo(bar: Int.self)`.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal draft #2] Naming Functions with Argument Labels</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January 11, 2016 at 11:00:00pm</p></header><div class="content"><p>Sent from my iPhone<br></p><p>On Jan 11, 2016, at 11:22 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br></p><p>&gt;&gt;&gt; foo(bar:(Int))<br>&gt;&gt;&gt; (that&#39;s why I wanted to avoid the parenthesis in the first place…)<br>&gt;&gt; <br>&gt;&gt; It’s grammatically ambiguous if you don’t have the “:)” at the end<br>&gt; <br>&gt; Is it? It&#39;s not legal to pass a type name—`foo(bar: Int)` is not legal code; you have to say `foo(bar: Int.self)`.<br></p><p>&quot;Grammatically&quot; is key here: the parser doesn&#39;t know a type name from a variable name. <br></p><p>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal draft #2] Naming Functions with Argument Labels</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January 11, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt;&gt;&gt; It’s grammatically ambiguous if you don’t have the “:)” at the end<br>&gt;&gt; <br>&gt;&gt; Is it? It&#39;s not legal to pass a type name—`foo(bar: Int)` is not legal code; you have to say `foo(bar: Int.self)`.<br>&gt; <br>&gt; &quot;Grammatically&quot; is key here: the parser doesn&#39;t know a type name from a variable name. <br></p><p>Okay, but is it important to distinguish the two grammatically? A function call and a function reference are both expressions and can (types aside) both be used in the same places, right?<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal draft #2] Naming Functions with Argument Labels</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January 12, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 11, 2016, at 11:52 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt;&gt; It’s grammatically ambiguous if you don’t have the “:)” at the end<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Is it? It&#39;s not legal to pass a type name—`foo(bar: Int)` is not legal code; you have to say `foo(bar: Int.self)`.<br>&gt;&gt; <br>&gt;&gt; &quot;Grammatically&quot; is key here: the parser doesn&#39;t know a type name from a variable name. <br>&gt; <br>&gt; Okay, but is it important to distinguish the two grammatically? A function call and a function reference are both expressions and can (types aside) both be used in the same places, right?<br></p><p>IMO, it’s important to distinguish them grammatically. Yes, one could potentially make the type checker sort it out, but it adds significant complexity to the feature and the compiler, for the benefit of a small corner case that could be handled via type context already. Moreover, it means that we wouldn’t be able to take this currently-invalid code<br></p><p>	foo(bar: Int)<br></p><p>and correct it to<br></p><p>	foo(bar: Int.self)<br></p><p>which is almost surely what the user meant (the “.self” rule is a tricky one to remember).<br></p><p>	- Doug<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[Proposal draft #2] Naming Functions with Argument Labels</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>January 11, 2016 at 01:00:00pm</p></header><div class="content"><p>I like the proposal. It does illustrate one of the naming conventions I really dislike with Swift (implicitly unnamed first parameter).<br></p><p><br>&gt; let fn1 = someView.insert(subview:aboveSubview:)<br>Would have looked so much better. =)<br></p><p>Anyhow, +1 for the proposal.<br></p><p>-David<br></p><p>&gt; On Jan 11, 2016, at 11:03 AM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi all,<br>&gt; <br>&gt; I’ve updated and simplified my “Generalized Naming for Any Function” proposal to only deal with naming functions with argument labels, and dropping the back-ticks. Comments welcome! Proposal is here<br>&gt; <br>&gt; 	https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/d360a5e6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal draft #2] Naming Functions with Argument Labels</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 11, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jan 11, 2016, at 3:42 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; I like the proposal. It does illustrate one of the naming conventions I really dislike with Swift (implicitly unnamed first parameter).<br>&gt; <br>&gt; <br>&gt;&gt; let fn1 = someView.insert(subview:aboveSubview:)<br>&gt; Would have looked so much better. =)<br></p><p>I agree in this case, although there may be cases where unnamed arguments are still better.  This seems like it is at least partly a problem with how existing Cocoa APIs are imported.<br></p><p>&gt; <br>&gt; Anyhow, +1 for the proposal.<br></p><p>Agree.  +1 from me as well.  This looks really good.  <br></p><p>Now I’m looking forward to seeing more about lenses so we can also work with getters, setters, and subscripts.<br></p><p>Matthew<br></p><p>&gt; <br>&gt; -David<br>&gt; <br>&gt;&gt; On Jan 11, 2016, at 11:03 AM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; I’ve updated and simplified my “Generalized Naming for Any Function” proposal to only deal with naming functions with argument labels, and dropping the back-ticks. Comments welcome! Proposal is here<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/7f353db7/attachment-0001.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/47e3aeeaf151d4f51ee15fc7871bf584?s=50"></div><header><strong>[Proposal draft #2] Naming Functions with Argument Labels</strong> from <string>Rudolf Adamkovič</string> &lt;salutis at me.com&gt;<p>January 11, 2016 at 11:00:00pm</p></header><div class="content"><p>Doug, what a fantastic job.<br></p><p>Can&#39;t wait to see this happen!<br></p><p>R+<br></p><p>Sent from my iPhone<br></p><p>&gt; On 11 Jan 2016, at 20:03, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi all,<br>&gt; <br>&gt; I’ve updated and simplified my “Generalized Naming for Any Function” proposal to only deal with naming functions with argument labels, and dropping the back-ticks. Comments welcome! Proposal is here<br>&gt; <br>&gt; 	https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md<br>&gt; <br>&gt; and inline:<br>&gt; <br>&gt; Naming Functions with Argument Labels<br>&gt; Proposal: SE-NNNN<br>&gt; Author(s): Doug Gregor<br>&gt; Status: Awaiting Review<br>&gt; Review manager: TBD<br>&gt; Introduction<br>&gt; <br>&gt; Swift includes support for first-class functions, such that any function (or method) can be placed into a value of function type. However, when specifying the name of a function, one can only provide the base name, (e.g., insertSubview) without the argument labels. For overloaded functions, this means that one must disambiguate based on type information, which is awkward and verbose. This proposal allwos one <br>&gt; <br>&gt; it is not possible to specifically name every function that is part of a Swift program---one cannot provide the argument labels when naming a function, nor are property and subscript getters and setters referenceable. This proposal introduces a general syntax that allows one to name anything that is a function within Swift in an extensible manner.<br>&gt; <br>&gt; Swift-evolution thread: The first draft of this proposal was discussed here. It included support for naming getters/setters (separately brought up by Michael Henson here, continued here). Joe Groff convinced me that lenses are a better approach for working with getters/setters, so I&#39;ve dropped them from this version of the proposal.<br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; It&#39;s fairly common in Swift for multiple functions or methods to have the same &quot;base name&quot;, but be distinguished by parameter labels. For example, UIView has three methods with the same base name insertSubview:<br>&gt; <br>&gt; extension UIView {<br>&gt;   func insertSubview(view: UIView, at index: Int)<br>&gt;   func insertSubview(view: UIView, aboveSubview siblingSubview: UIView)<br>&gt;   func insertSubview(view: UIView, belowSubview siblingSubview: UIView)<br>&gt; }<br>&gt; When calling these methods, the argument labels distinguish the different methods, e.g.,<br>&gt; <br>&gt; someView.insertSubview(view, at: 3)<br>&gt; someView.insertSubview(view, aboveSubview: otherView)<br>&gt; someView.insertSubview(view, belowSubview: otherView)<br>&gt; However, when referencing the function to create a function value, one cannot provide the labels:<br>&gt; <br>&gt; let fn = someView.insertSubview // ambiguous: could be any of the three methods<br>&gt; In some cases, it is possible to use type annotations to disambiguate:<br>&gt; <br>&gt; let fn: (UIView, Int) = someView.insertSubview    // ok: uses insertSubview(_:at:)<br>&gt; let fn: (UIView, UIView) = someView.insertSubview // error: still ambiguous!<br>&gt; To resolve the latter case, one must fall back to creating a closure:<br>&gt; <br>&gt; let fn: (UIView, UIView) = { view, otherView in<br>&gt;   button.insertSubview(view, aboveSubview: otherView)<br>&gt; }<br>&gt; which is painfully tedious. <br>&gt; <br>&gt; One additional bit of motivation: Swift should probably get some way to ask for the Objective-C selector for a given method (rather than writing a string literal). The argument to such an operation would likely be a reference to a method, which would benefit from being able to name any method, including getters and setters.<br>&gt; <br>&gt; Proposed solution<br>&gt; <br>&gt; I propose to extend function naming to allow compound Swift names (e.g., insertSubview(_:aboveSubview:)) anywhere a name can occur. Specifically,<br>&gt; <br>&gt; let fn = someView.insertSubview(_:at:)<br>&gt; let fn1 = someView.insertSubview(_:aboveSubview:)<br>&gt; The same syntax can also refer to initializers, e.g.,<br>&gt; <br>&gt; let buttonFactory = UIButton.init(type:)<br>&gt; The &quot;produce the Objective-C selector for the given method&quot; operation will be the subject of a separate proposal. However, here is one possibility that illustrations how it uses the proposed syntax here:<br>&gt; <br>&gt; let getter = Selector(NSDictionary.insertSubview(_:aboveSubview:)) // produces insertSubview:aboveSubview:.<br>&gt; Detailed Design<br>&gt; <br>&gt; Grammatically, the primary-expression grammar will change from:<br>&gt; <br>&gt; primary-expression -&gt; identifier generic-argument-clause[opt]<br>&gt; to:<br>&gt; <br>&gt; primary-expression -&gt; unqualified-name generic-argument-clause[opt]<br>&gt; <br>&gt; unqualified-name -&gt; identifier<br>&gt;                   | identifier &#39;(&#39; ((identifier | &#39;_&#39;) &#39;:&#39;)+ &#39;)&#39;<br>&gt; Within the parentheses, the use of &quot;+&quot; is important, because it disambiguates:<br>&gt; <br>&gt; f()<br>&gt; as a call to f rather than a reference to an f with no arguments. Zero-argument function references will still require disambiguation via contextual type information.<br>&gt; <br>&gt; Impact on existing code<br>&gt; <br>&gt; This is a purely additive feature that has no impact on existing code.<br>&gt; <br>&gt; Alternatives considered<br>&gt; <br>&gt; Joe Groff notes that lenses are a better solution than manually retrieving getter/setter functions when the intent is to actually operate on the properties.<br>&gt; <br>&gt; Bartlomiej Cichosz suggests a general partial application syntax using _ as a placeholder, e.g.,<br>&gt; <br>&gt; aGameView.insertSubview(_, aboveSubview: playingSurfaceView)<br>&gt; When all arguments are _, this provides the ability to name any method:<br>&gt; <br>&gt; aGameView.insertSubview(_, aboveSubview: _)<br>&gt; I decided not to go with this because I don&#39;t believe we need such a general partial application syntax in Swift. Closures using the $ names are nearly as concise, and eliminate any questions about how the _ placeholder maps to an argument of the partially-applied function:<br>&gt; <br>&gt; { aGameView.insertSubview($0, aboveSubview: playingSurfaceView) }<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/ef8444f1/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2969f67fc010e956c71442148f3f6fc0?s=50"></div><header><strong>[Proposal draft #2] Naming Functions with Argument Labels</strong> from <string>Wallacy</string> &lt;wallacyf at gmail.com&gt;<p>January 11, 2016 at 10:00:00pm</p></header><div class="content"><p>+1 from me as well! This version looks pretty good.<br></p><p>Em seg, 11 de jan de 2016 às 17:03, Douglas Gregor via swift-evolution &lt;<br>swift-evolution at swift.org&gt; escreveu:<br></p><p>&gt; Hi all,<br>&gt;<br>&gt; I’ve updated and simplified my “Generalized Naming for Any Function”<br>&gt; proposal to only deal with naming functions with argument labels, and<br>&gt; dropping the back-ticks. Comments welcome! Proposal is here<br>&gt;<br>&gt;<br>&gt; https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md<br>&gt;<br>&gt; and inline:<br>&gt;<br>&gt; Naming Functions with Argument Labels<br>&gt;<br>&gt;    - Proposal: SE-NNNN<br>&gt;    &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0000-generalized-naming.md&gt;<br>&gt;    - Author(s): Doug Gregor &lt;https://github.com/DougGregor&gt;<br>&gt;    - Status: *Awaiting Review*<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/DougGregor/swift-evolution/tree/generalized-naming#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; Swift includes support for first-class functions, such that any function<br>&gt; (or method) can be placed into a value of function type. However, when<br>&gt; specifying the name of a function, one can only provide the base name,<br>&gt; (e.g., insertSubview) without the argument labels. For overloaded<br>&gt; functions, this means that one must disambiguate based on type information,<br>&gt; which is awkward and verbose. This proposal allwos one<br>&gt;<br>&gt; it is not possible to specifically name every function that is part of a<br>&gt; Swift program---one cannot provide the argument labels when naming a<br>&gt; function, nor are property and subscript getters and setters referenceable.<br>&gt; This proposal introduces a general syntax that allows one to name anything<br>&gt; that is a function within Swift in an extensible manner.<br>&gt;<br>&gt; Swift-evolution thread: The first draft of this proposal was discussed<br>&gt; here<br>&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151221/004555.html&gt;.<br>&gt; It included support for naming getters/setters (separately brought up by<br>&gt; Michael Henson here<br>&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html&gt;,<br>&gt; continued here<br>&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002203.html&gt;).<br>&gt; Joe Groff convinced<br>&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151221/004579.html&gt; me<br>&gt; that lenses are a better approach for working with getters/setters, so I&#39;ve<br>&gt; dropped them from this version of the proposal.<br>&gt;<br>&gt; &lt;https://github.com/DougGregor/swift-evolution/tree/generalized-naming#motivation&gt;<br>&gt; Motivation<br>&gt;<br>&gt; It&#39;s fairly common in Swift for multiple functions or methods to have the<br>&gt; same &quot;base name&quot;, but be distinguished by parameter labels. For example,<br>&gt; UIView has three methods with the same base name insertSubview:<br>&gt;<br>&gt; extension UIView {<br>&gt;   func insertSubview(view: UIView, at index: Int)<br>&gt;   func insertSubview(view: UIView, aboveSubview siblingSubview: UIView)<br>&gt;   func insertSubview(view: UIView, belowSubview siblingSubview: UIView)<br>&gt; }<br>&gt;<br>&gt; When calling these methods, the argument labels distinguish the different<br>&gt; methods, e.g.,<br>&gt;<br>&gt; someView.insertSubview(view, at: 3)<br>&gt; someView.insertSubview(view, aboveSubview: otherView)<br>&gt; someView.insertSubview(view, belowSubview: otherView)<br>&gt;<br>&gt; However, when referencing the function to create a function value, one<br>&gt; cannot provide the labels:<br>&gt;<br>&gt; let fn = someView.insertSubview // ambiguous: could be any of the three methods<br>&gt;<br>&gt; In some cases, it is possible to use type annotations to disambiguate:<br>&gt;<br>&gt; let fn: (UIView, Int) = someView.insertSubview    // ok: uses insertSubview(_:at:)let fn: (UIView, UIView) = someView.insertSubview // error: still ambiguous!<br>&gt;<br>&gt; To resolve the latter case, one must fall back to creating a closure:<br>&gt;<br>&gt; let fn: (UIView, UIView) = { view, otherView in<br>&gt;   button.insertSubview(view, aboveSubview: otherView)<br>&gt; }<br>&gt;<br>&gt; which is painfully tedious.<br>&gt;<br>&gt; One additional bit of motivation: Swift should probably get some way to<br>&gt; ask for the Objective-C selector for a given method (rather than writing a<br>&gt; string literal). The argument to such an operation would likely be a<br>&gt; reference to a method, which would benefit from being able to name any<br>&gt; method, including getters and setters.<br>&gt;<br>&gt; &lt;https://github.com/DougGregor/swift-evolution/tree/generalized-naming#proposed-solution&gt;Proposed<br>&gt; solution<br>&gt;<br>&gt; I propose to extend function naming to allow compound Swift names (e.g.,<br>&gt; insertSubview(_:aboveSubview:)) anywhere a name can occur. Specifically,<br>&gt;<br>&gt; let fn = someView.insertSubview(_:at:)let fn1 = someView.insertSubview(_:aboveSubview:)<br>&gt;<br>&gt; The same syntax can also refer to initializers, e.g.,<br>&gt;<br>&gt; let buttonFactory = UIButton.init(type:)<br>&gt;<br>&gt; The &quot;produce the Objective-C selector for the given method&quot; operation will<br>&gt; be the subject of a separate proposal. However, here is one possibility<br>&gt; that illustrations how it uses the proposed syntax here:<br>&gt;<br>&gt; let getter = Selector(NSDictionary.insertSubview(_:aboveSubview:)) // produces insertSubview:aboveSubview:.<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/DougGregor/swift-evolution/tree/generalized-naming#detailed-design&gt;Detailed<br>&gt; Design<br>&gt;<br>&gt; Grammatically, the *primary-expression* grammar will change from:<br>&gt;<br>&gt; primary-expression -&gt; identifier generic-argument-clause[opt]<br>&gt;<br>&gt; to:<br>&gt;<br>&gt; primary-expression -&gt; unqualified-name generic-argument-clause[opt]<br>&gt;<br>&gt; unqualified-name -&gt; identifier<br>&gt;                   | identifier &#39;(&#39; ((identifier | &#39;_&#39;) &#39;:&#39;)+ &#39;)&#39;<br>&gt;<br>&gt; Within the parentheses, the use of &quot;+&quot; is important, because it<br>&gt; disambiguates:<br>&gt;<br>&gt; f()<br>&gt;<br>&gt; as a call to f rather than a reference to an f with no arguments.<br>&gt; Zero-argument function references will still require disambiguation via<br>&gt; contextual type information.<br>&gt;<br>&gt; &lt;https://github.com/DougGregor/swift-evolution/tree/generalized-naming#impact-on-existing-code&gt;Impact<br>&gt; on existing code<br>&gt;<br>&gt; This is a purely additive feature that has no impact on existing code.<br>&gt;<br>&gt; &lt;https://github.com/DougGregor/swift-evolution/tree/generalized-naming#alternatives-considered&gt;Alternatives<br>&gt; considered<br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    Joe Groff notes<br>&gt;    &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/003008.html&gt;<br>&gt;     that *lenses* are a better solution than manually retrieving<br>&gt;    getter/setter functions when the intent is to actually operate on the<br>&gt;    properties.<br>&gt;    -<br>&gt;<br>&gt;    Bartlomiej Cichosz suggests<br>&gt;    &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151228/004739.html&gt; a<br>&gt;    general partial application syntax using _ as a placeholder, e.g.,<br>&gt;<br>&gt;    aGameView.insertSubview(_, aboveSubview: playingSurfaceView)<br>&gt;<br>&gt;    When all arguments are _, this provides the ability to name any method:<br>&gt;<br>&gt;    aGameView.insertSubview(_, aboveSubview: _)<br>&gt;<br>&gt;    I decided not to go with this because I don&#39;t believe we need such a<br>&gt;    general partial application syntax in Swift. Closures using the $ names are<br>&gt;    nearly as concise, and eliminate any questions about how the _ placeholder<br>&gt;    maps to an argument of the partially-applied function:<br>&gt;<br>&gt;    { aGameView.insertSubview($0, aboveSubview: playingSurfaceView) }<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; - Doug<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/cfe6ba82/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05e222e6ef4d84013bb3baeb0e25c90b?s=50"></div><header><strong>[Proposal draft #2] Naming Functions with Argument Labels</strong> from <string>Patrick Gili</string> &lt;gili.patrick.r at gili-labs.com&gt;<p>January 12, 2016 at 10:00:00am</p></header><div class="content"><p>One thing that stands out about this proposal. The syntax you have proposed to name functions aligns nicely with the documentation that Apple has been publishing for Swift. When first reading the documentation, this can take some time to assimilate, especially since it was abstract. This proposal would make this syntax more concrete, and I think it might help beginners to better understand Swift functions. Hence, I fully support this proposal.<br></p><p>Cheers,<br>-Patrick<br></p><p>&gt; On Jan 11, 2016, at 2:03 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi all,<br>&gt; <br>&gt; I’ve updated and simplified my “Generalized Naming for Any Function” proposal to only deal with naming functions with argument labels, and dropping the back-ticks. Comments welcome! Proposal is here<br>&gt; <br>&gt; 	https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md &lt;https://github.com/DougGregor/swift-evolution/blob/generalized-naming/proposals/0000-generalized-naming.md&gt;<br>&gt; <br>&gt; and inline:<br>&gt; <br>&gt; Naming Functions with Argument Labels<br>&gt; <br>&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0000-generalized-naming.md&gt;<br>&gt; Author(s): Doug Gregor &lt;https://github.com/DougGregor&gt;<br>&gt; Status: Awaiting Review<br>&gt; Review manager: TBD<br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/generalized-naming#introduction&gt;Introduction<br>&gt; <br>&gt; Swift includes support for first-class functions, such that any function (or method) can be placed into a value of function type. However, when specifying the name of a function, one can only provide the base name, (e.g., insertSubview) without the argument labels. For overloaded functions, this means that one must disambiguate based on type information, which is awkward and verbose. This proposal allwos one <br>&gt; <br>&gt; it is not possible to specifically name every function that is part of a Swift program---one cannot provide the argument labels when naming a function, nor are property and subscript getters and setters referenceable. This proposal introduces a general syntax that allows one to name anything that is a function within Swift in an extensible manner.<br>&gt; <br>&gt; Swift-evolution thread: The first draft of this proposal was discussed here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151221/004555.html&gt;. It included support for naming getters/setters (separately brought up by Michael Henson here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002168.html&gt;, continued here &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002203.html&gt;). Joe Groff convinced &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151221/004579.html&gt; me that lenses are a better approach for working with getters/setters, so I&#39;ve dropped them from this version of the proposal.<br>&gt; <br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/generalized-naming#motivation&gt;Motivation<br>&gt; <br>&gt; It&#39;s fairly common in Swift for multiple functions or methods to have the same &quot;base name&quot;, but be distinguished by parameter labels. For example, UIView has three methods with the same base name insertSubview:<br>&gt; <br>&gt; extension UIView {<br>&gt;   func insertSubview(view: UIView, at index: Int)<br>&gt;   func insertSubview(view: UIView, aboveSubview siblingSubview: UIView)<br>&gt;   func insertSubview(view: UIView, belowSubview siblingSubview: UIView)<br>&gt; }<br>&gt; When calling these methods, the argument labels distinguish the different methods, e.g.,<br>&gt; <br>&gt; someView.insertSubview(view, at: 3)<br>&gt; someView.insertSubview(view, aboveSubview: otherView)<br>&gt; someView.insertSubview(view, belowSubview: otherView)<br>&gt; However, when referencing the function to create a function value, one cannot provide the labels:<br>&gt; <br>&gt; let fn = someView.insertSubview // ambiguous: could be any of the three methods<br>&gt; In some cases, it is possible to use type annotations to disambiguate:<br>&gt; <br>&gt; let fn: (UIView, Int) = someView.insertSubview    // ok: uses insertSubview(_:at:)<br>&gt; let fn: (UIView, UIView) = someView.insertSubview // error: still ambiguous!<br>&gt; To resolve the latter case, one must fall back to creating a closure:<br>&gt; <br>&gt; let fn: (UIView, UIView) = { view, otherView in<br>&gt;   button.insertSubview(view, aboveSubview: otherView)<br>&gt; }<br>&gt; which is painfully tedious. <br>&gt; <br>&gt; One additional bit of motivation: Swift should probably get some way to ask for the Objective-C selector for a given method (rather than writing a string literal). The argument to such an operation would likely be a reference to a method, which would benefit from being able to name any method, including getters and setters.<br>&gt; <br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/generalized-naming#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt; I propose to extend function naming to allow compound Swift names (e.g., insertSubview(_:aboveSubview:)) anywhere a name can occur. Specifically,<br>&gt; <br>&gt; let fn = someView.insertSubview(_:at:)<br>&gt; let fn1 = someView.insertSubview(_:aboveSubview:)<br>&gt; The same syntax can also refer to initializers, e.g.,<br>&gt; <br>&gt; let buttonFactory = UIButton.init(type:)<br>&gt; The &quot;produce the Objective-C selector for the given method&quot; operation will be the subject of a separate proposal. However, here is one possibility that illustrations how it uses the proposed syntax here:<br>&gt; <br>&gt; let getter = Selector(NSDictionary.insertSubview(_:aboveSubview:)) // produces insertSubview:aboveSubview:.<br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/generalized-naming#detailed-design&gt;Detailed Design<br>&gt; <br>&gt; Grammatically, the primary-expression grammar will change from:<br>&gt; <br>&gt; primary-expression -&gt; identifier generic-argument-clause[opt]<br>&gt; to:<br>&gt; <br>&gt; primary-expression -&gt; unqualified-name generic-argument-clause[opt]<br>&gt; <br>&gt; unqualified-name -&gt; identifier<br>&gt;                   | identifier &#39;(&#39; ((identifier | &#39;_&#39;) &#39;:&#39;)+ &#39;)&#39;<br>&gt; Within the parentheses, the use of &quot;+&quot; is important, because it disambiguates:<br>&gt; <br>&gt; f()<br>&gt; as a call to f rather than a reference to an f with no arguments. Zero-argument function references will still require disambiguation via contextual type information.<br>&gt; <br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/generalized-naming#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; This is a purely additive feature that has no impact on existing code.<br>&gt; <br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/generalized-naming#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt; Joe Groff notes &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/003008.html&gt; that lenses are a better solution than manually retrieving getter/setter functions when the intent is to actually operate on the properties.<br>&gt; <br>&gt; Bartlomiej Cichosz suggests &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151228/004739.html&gt; a general partial application syntax using _ as a placeholder, e.g.,<br>&gt; <br>&gt; aGameView.insertSubview(_, aboveSubview: playingSurfaceView)<br>&gt; When all arguments are _, this provides the ability to name any method:<br>&gt; <br>&gt; aGameView.insertSubview(_, aboveSubview: _)<br>&gt; I decided not to go with this because I don&#39;t believe we need such a general partial application syntax in Swift. Closures using the $ names are nearly as concise, and eliminate any questions about how the _ placeholder maps to an argument of the partially-applied function:<br>&gt; <br>&gt; { aGameView.insertSubview($0, aboveSubview: playingSurfaceView) }<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160112/34eac370/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
