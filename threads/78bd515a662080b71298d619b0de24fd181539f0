<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/36d885cd7c1a16ab2a9331f9736ba138?s=50"></div><header><strong>Empower String type with regular expression</strong> from <string>John Joyce</string> &lt;uchuugaka at me.com&gt;<p>January  2, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; &gt; On Dec 8, 2015, at 12:14 PM, Jerome Paschoud via swift-evolution &lt;swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt; &gt; <br>&gt; &gt; I would like to see the String type to support regular expression per default. I think that a language that advertise itself as being a good scripting language should provide in its default implementation an easy way (=~ for example in Perl) to use regular expressions. I know that one can use the NSRegularExpression, but who really what to first create an NSRegularExpression object(whit all the nice escaping operation that come with every \), then get a NSTextCheckingResult, then get a range (and what I mean is a NSRange and not a NSRange&lt;String.Index&gt;) and finally perform slicing of your original string. <br>&gt; <br>&gt; Just MHO, but I’d really really like to see proper regex support in Swift someday.<br>&gt; <br>&gt; I think it could fit naturally into the pattern matching syntax we already have - the obvious syntax for this pattern would use // delimiters. <br>&gt; <br>&gt; It is also probably worth burning first-class language support for regexes.  This would allow specifying variable captures inline in the pattern, would allow flexible syntax for defining regexes, support powerful extensions to the base regex model (e.g. Perl 6 style), and would provide better compile-time checking and error recovery for mistakes.<br>&gt; <br>&gt; -Chris<br>I know this is an old thread already, but this sure would be one of the major breakout pieces of functionality.<br>If Swift had native regular expressions, without all the noise you see in the Objective-C API that exposes ICU regular expressions, the adoption rate would be huge.<br>If they were *truly* native, as in somebody sat down and built an NFA (or one of the fancier approaches that mixes with DFA) state machine, Swift&#39;s best-in-class Unicode support would and could result in amazing things.<br>It&#39;d boost the scripting use of Swift tremendously and seal the deal as a server side language.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160102/78bd39f0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Empower String type with regular expression</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January  3, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jan 1, 2016, at 4:44 PM, John Joyce via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; It is also probably worth burning first-class language support for regexes.  This would allow specifying variable captures inline in the pattern, would allow flexible syntax for defining regexes, support powerful extensions to the base regex model (e.g. Perl 6 style), and would provide better compile-time checking and error recovery for mistakes.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt; I know this is an old thread already, but this sure would be one of the major breakout pieces of functionality.<br>&gt; If Swift had native regular expressions, without all the noise you see in the Objective-C API that exposes ICU regular expressions, the adoption rate would be huge.<br>&gt; If they were *truly* native, as in somebody sat down and built an NFA (or one of the fancier approaches that mixes with DFA) state machine, Swift&#39;s best-in-class Unicode support would and could result in amazing things.<br>&gt; It&#39;d boost the scripting use of Swift tremendously and seal the deal as a server side language.<br></p><p>Totally agreed.  switch on a string with a bunch of regexes being matched should turn into a parallel state machine, just like a lexer :-)<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160103/a187b9f1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Empower String type with regular expression</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>January  3, 2016 at 05:00:00pm</p></header><div class="content"><p>+1 on first-class regex support/pattern matching on regex patterns.<br></p><p>There was a thread a while ago discussing compile-time code generation, and<br>if I recall correctly one of the stated use cases was<br>&#39;compiling&#39;/&#39;building&#39; (don&#39;t know the real terminology) regex literals at<br>compile-time. Is there a bigger overall vision for this sort of feature, or<br>would it be better to just focus on better regex support?<br></p><p>Best,<br>Austin<br></p><p>On Sun, Jan 3, 2016 at 1:35 PM, Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Jan 1, 2016, at 4:44 PM, John Joyce via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; It is also probably worth burning first-class language support for regexes.  This would allow specifying variable captures inline in the pattern, would allow flexible syntax for defining regexes, support powerful extensions to the base regex model (e.g. Perl 6 style), and would provide better compile-time checking and error recovery for mistakes.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt; I know this is an old thread already, but this sure would be one of the<br>&gt; major breakout pieces of functionality.<br>&gt; If Swift had native regular expressions, without all the noise you see in<br>&gt; the Objective-C API that exposes ICU regular expressions, the adoption rate<br>&gt; would be huge.<br>&gt; If they were *truly* native, as in somebody sat down and built an NFA (or<br>&gt; one of the fancier approaches that mixes with DFA) state machine, Swift&#39;s<br>&gt; best-in-class Unicode support would and could result in amazing things.<br>&gt; It&#39;d boost the scripting use of Swift tremendously and seal the deal as a<br>&gt; server side language.<br>&gt;<br>&gt;<br>&gt; Totally agreed.  switch on a string with a bunch of regexes being matched<br>&gt; should turn into a parallel state machine, just like a lexer :-)<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160103/9ba09f1b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/357b710213d3c0e01356f7c90f78b9f2?s=50"></div><header><strong>Empower String type with regular expression</strong> from <string>Vincent Esche</string> &lt;regexident.mailinglists at gmail.com&gt;<p>January  4, 2016 at 03:00:00pm</p></header><div class="content"><p>There is actually a Rust crate doing exactly that: https://github.com/jneem/regex-dfa<br>Rust however has powerful compile-time macros, enabling this, which Swift doesn’t (yet?).<br></p><p>&gt; On 04 Jan 2016, at 02:53, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; +1 on first-class regex support/pattern matching on regex patterns.<br>&gt; <br>&gt; There was a thread a while ago discussing compile-time code generation, and if I recall correctly one of the stated use cases was &#39;compiling&#39;/&#39;building&#39; (don&#39;t know the real terminology) regex literals at compile-time. Is there a bigger overall vision for this sort of feature, or would it be better to just focus on better regex support?<br>&gt; <br>&gt; Best,<br>&gt; Austin<br>&gt; <br>&gt; On Sun, Jan 3, 2016 at 1:35 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; On Jan 1, 2016, at 4:44 PM, John Joyce via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; It is also probably worth burning first-class language support for regexes.  This would allow specifying variable captures inline in the pattern, would allow flexible syntax for defining regexes, support powerful extensions to the base regex model (e.g. Perl 6 style), and would provide better compile-time checking and error recovery for mistakes.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt; I know this is an old thread already, but this sure would be one of the major breakout pieces of functionality.<br>&gt;&gt; If Swift had native regular expressions, without all the noise you see in the Objective-C API that exposes ICU regular expressions, the adoption rate would be huge.<br>&gt;&gt; If they were *truly* native, as in somebody sat down and built an NFA (or one of the fancier approaches that mixes with DFA) state machine, Swift&#39;s best-in-class Unicode support would and could result in amazing things.<br>&gt;&gt; It&#39;d boost the scripting use of Swift tremendously and seal the deal as a server side language.<br>&gt; <br>&gt; Totally agreed.  switch on a string with a bunch of regexes being matched should turn into a parallel state machine, just like a lexer :-)<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160104/c7b28686/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c40db4457ab2c91a0d8006da31b177c6?s=50"></div><header><strong>Empower String type with regular expression</strong> from <string>Trent Nadeau</string> &lt;tanadeau at gmail.com&gt;<p>January  4, 2016 at 01:00:00pm</p></header><div class="content"><p>Also https://github.com/rust-lang-nursery/regex, which is the process of<br>possibly being standardized either in the Rust stdlib or as a fully<br>supported crate (library). That crate is based on<br>https://github.com/google/re2 that is written in C++. Both could be used<br>for implementation ideas.<br></p><p>On Mon, Jan 4, 2016 at 9:52 AM, Vincent Esche via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; There is actually a Rust crate doing exactly that:<br>&gt; https://github.com/jneem/regex-dfa<br>&gt; Rust however has powerful compile-time macros, enabling this, which Swift<br>&gt; doesn’t (yet?).<br>&gt;<br>&gt; On 04 Jan 2016, at 02:53, Austin Zheng via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; +1 on first-class regex support/pattern matching on regex patterns.<br>&gt;<br>&gt; There was a thread a while ago discussing compile-time code generation,<br>&gt; and if I recall correctly one of the stated use cases was<br>&gt; &#39;compiling&#39;/&#39;building&#39; (don&#39;t know the real terminology) regex literals at<br>&gt; compile-time. Is there a bigger overall vision for this sort of feature, or<br>&gt; would it be better to just focus on better regex support?<br>&gt;<br>&gt; Best,<br>&gt; Austin<br>&gt;<br>&gt; On Sun, Jan 3, 2016 at 1:35 PM, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; On Jan 1, 2016, at 4:44 PM, John Joyce via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; It is also probably worth burning first-class language support for regexes.  This would allow specifying variable captures inline in the pattern, would allow flexible syntax for defining regexes, support powerful extensions to the base regex model (e.g. Perl 6 style), and would provide better compile-time checking and error recovery for mistakes.<br>&gt;&gt;<br>&gt;&gt; -Chris<br>&gt;&gt;<br>&gt;&gt; I know this is an old thread already, but this sure would be one of the<br>&gt;&gt; major breakout pieces of functionality.<br>&gt;&gt; If Swift had native regular expressions, without all the noise you see in<br>&gt;&gt; the Objective-C API that exposes ICU regular expressions, the adoption rate<br>&gt;&gt; would be huge.<br>&gt;&gt; If they were *truly* native, as in somebody sat down and built an NFA (or<br>&gt;&gt; one of the fancier approaches that mixes with DFA) state machine, Swift&#39;s<br>&gt;&gt; best-in-class Unicode support would and could result in amazing things.<br>&gt;&gt; It&#39;d boost the scripting use of Swift tremendously and seal the deal as a<br>&gt;&gt; server side language.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Totally agreed.  switch on a string with a bunch of regexes being matched<br>&gt;&gt; should turn into a parallel state machine, just like a lexer :-)<br>&gt;&gt;<br>&gt;&gt; -Chris<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p><p><br>-- <br>Trent Nadeau<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160104/c1fcee36/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05e222e6ef4d84013bb3baeb0e25c90b?s=50"></div><header><strong>Empower String type with regular expression</strong> from <string>Patrick Gili</string> &lt;gili.patrick.r at gili-labs.com&gt;<p>January 31, 2016 at 11:00:00am</p></header><div class="content"><p>There have been several threads that have discussed the notion of a regular expression literals. However, I didn&#39;t see anyone putting together a formal proposal, and hence I took the liberty to do so. I would appreciate discussion and comments on the proposal:<br></p><p>Regular Expression Literals<br>Proposal: [SE-NNNN] (https://github/apple/swift-evolution/blob/master/proposals/NNNN-name.md)<br>Author: Patrick Gili (https://github.com/gili-patrick-r)<br>Status: Awaiting review<br>Review manager: TBD<br>Introduction<br>The Swift language has no native support for regular expressions, which makes working with regular expressions in Swift awkward, tedious, and error prone. This proposal describes the addition of regular expressions literals to Swift.<br></p><p>Swift-evolution thread: Empower String type with regular expression &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151228/005126.html&gt;<br>Motivation<br>The definition of a pattern used by a regular expression is complicated by the fact that Swift does not support raw string literals (i.e., string literals that do not process character escapes or interpolation) or regular expression literals similar to Perl or Ruby. Rather, Swift only supports C-style string literals with support for interpolation. C-style string literals require a backslash to escape a backslash. The patterns representing regular expressions make frequent use of the backslash, and hence patterns represented by a Swift string literal become unreadable and difficult to maintain. For example, consider the following pattern to match and parse URLs:<br></p><p>^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$<br>To define this pattern in Swift, an application needs to define a string, such as<br></p><p>let pattern = &quot;^(https?:\\/\\/)?([\\da-z\\.-]+)\\.([a-z\\.]{2,6})([\\/\\w \\.-]*)*\\/?$&quot;<br>This later is obviously difficult to read and maintain.<br></p><p>Proposed solution<br>The proposed solution is to add regular expression literals to Swift, similar to regular expression literal support by other languages, such as Perl and Ruby. Regular expression literals differ from raw string literals in two primary ways. First, regular expression literals support string interpolation of the pattern, which allows an application to construct a regular expression at run-time. Second, a regular expression literal creates an instance of a NSRegularExpression, rather than an instance of String. The following example declares a regular expression for the purpose of matching and parsing URIs with a specified scheme:<br></p><p>let scheme = &quot;https&quot;<br>let urlRegex = /^(\(scheme)?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/<br>To make regular expression literals effective, it must be possible to replace the creation of any instance of NSRegularExpression. The initializer for NSRegularExpression accepts a string describing the pattern and a set of options. To support these options, a regular expression literal accepts a list of zero or more options after the delimiter closing the pattern. For example, consider a regular expression to match and parse email addresses.<br></p><p>let emailRegex = /^([a-z0-9_\.-]+)@([\da-z\.-]+)\.([a-z\.]{2,6})$/<br>This regular expression will match &quot;john.appleseed at apple.com&quot;&quot;, but not &quot;JOHN.APPLESEED at APPLE.COM&quot;. The regular expression has to allow for this, as email addresses are not case sensitive. Rather than add the complexity to the pattern to account for this, the following example achieves the same:<br></p><p>let emailRegex = /^([a-z0-9_\.-]+)@([\da-z\.-]+)\.([a-z\.]{2,6})$/i<br>In this case, the &quot;i&quot; following the delimiter closing the pattern maps to RegularExpressionOption.CaseInsensitive.<br></p><p>Detailed design<br>The following modification to the grammar of a literal adds support for regular expression literals:<br></p><p>literal → numeric-literal | string-literal | boolean-literal | regex-literal | nil-literal<br></p><p>The following grammar describes a regular expression literal:<br></p><p>regex-literal → static-regex-literal | interpolated-regex-literal<br></p><p>static-regex-literal → / patternopt / regex-optionsopt<br>pattern → pattern_item patternopt<br>pattern_item → any Unicode scalar value except /, U+000A, or U+000D<br></p><p>interpolated-string-literal → / interpolated-patternopt / regex-optionsopt<br>interpolated_pattern → interpolated_pattern_item interpolated_patternopt<br>interpolated_pattern_item → ( expression ) | pattern_item<br></p><p>regex-options → regex-option | regex-optionopt<br>regex_option → i | x | q | s | m | d | b<br></p><p>The following table summarize the regular expression options:<br></p><p>Option 	RegularExpressionOption <br>i 	CaseInsensitive <br>x 	AllowCommentsAndWhitespace <br>q 	IgnoreMetacharacters <br>s 	DotMatchesLineSeparations <br>m 	AnchorsMatchLines <br>d 	UseUnixLineSeparators <br>b 	UseUnicodeWordBoundaries <br>Impact on existing code<br>The use of regular expression literals is opt-in, and hence there is no impact to existing code.<br></p><p>Alternatives considered<br>There have been several threads on the swift-evoluation mailing list that have discussed alternatives to regular expression literals.<br></p><p>String literal suffixes for defining types &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002193.html&gt; discussed string literals with a single character appended after the closing delimiter to denote the type. For example, the string literal r&quot;\d+&quot; in Python denotes a regular expression literal. However, this approach suffers from two disadvantages: 1) it does not support string interpolation in the pattern, and 2) it uses double-quotes for the delimiter, which appears more frequently in regular expressions than the forward slash.<br></p><p>Muli-line string literals &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002325.html&gt; discussed string literals spanning more than one line. This would be a worthy addition to the regular expression literal discussed in this proposal. We should consider modifying the grammar to support this. However, I wanted to introduce changes incrementally to maintain focus.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160131/3cb35f41/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05e222e6ef4d84013bb3baeb0e25c90b?s=50"></div><header><strong>Empower String type with regular expression</strong> from <string>Patrick Gili</string> &lt;gili.patrick.r at gili-labs.com&gt;<p>January 31, 2016 at 12:00:00pm</p></header><div class="content"><p>Here is the link to the proposal on GitHub:<br></p><p>https://github.com/gili-patrick-r/swift-evolution/blob/master/proposals/NNNN-regular-expression-literals.md<br></p><p>Cheers,<br>-Patrick<br></p><p>&gt; On Jan 31, 2016, at 11:32 AM, Patrick Gili &lt;gili.patrick.r at gili-labs.com&gt; wrote:<br>&gt; <br>&gt; There have been several threads that have discussed the notion of a regular expression literals. However, I didn&#39;t see anyone putting together a formal proposal, and hence I took the liberty to do so. I would appreciate discussion and comments on the proposal:<br>&gt; <br>&gt; Regular Expression Literals<br>&gt; Proposal: [SE-NNNN] (https://github/apple/swift-evolution/blob/master/proposals/NNNN-name.md &lt;https://github/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;)<br>&gt; Author: Patrick Gili (https://github.com/gili-patrick-r &lt;https://github.com/gili-patrick-r&gt;)<br>&gt; Status: Awaiting review<br>&gt; Review manager: TBD<br>&gt; Introduction<br>&gt; The Swift language has no native support for regular expressions, which makes working with regular expressions in Swift awkward, tedious, and error prone. This proposal describes the addition of regular expressions literals to Swift.<br>&gt; <br>&gt; Swift-evolution thread: Empower String type with regular expression &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151228/005126.html&gt;<br>&gt; Motivation<br>&gt; The definition of a pattern used by a regular expression is complicated by the fact that Swift does not support raw string literals (i.e., string literals that do not process character escapes or interpolation) or regular expression literals similar to Perl or Ruby. Rather, Swift only supports C-style string literals with support for interpolation. C-style string literals require a backslash to escape a backslash. The patterns representing regular expressions make frequent use of the backslash, and hence patterns represented by a Swift string literal become unreadable and difficult to maintain. For example, consider the following pattern to match and parse URLs:<br>&gt; <br>&gt; ^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$<br>&gt; To define this pattern in Swift, an application needs to define a string, such as<br>&gt; <br>&gt; let pattern = &quot;^(https?:\\/\\/)?([\\da-z\\.-]+)\\.([a-z\\.]{2,6})([\\/\\w &lt;smb://///w&gt; \\.- &lt;smb://.-&gt;]*)*\\/?$&quot;<br>&gt; This later is obviously difficult to read and maintain.<br>&gt; <br>&gt; Proposed solution<br>&gt; The proposed solution is to add regular expression literals to Swift, similar to regular expression literal support by other languages, such as Perl and Ruby. Regular expression literals differ from raw string literals in two primary ways. First, regular expression literals support string interpolation of the pattern, which allows an application to construct a regular expression at run-time. Second, a regular expression literal creates an instance of a NSRegularExpression, rather than an instance of String. The following example declares a regular expression for the purpose of matching and parsing URIs with a specified scheme:<br>&gt; <br>&gt; let scheme = &quot;https&quot;<br>&gt; let urlRegex = /^(\(scheme)?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/<br>&gt; To make regular expression literals effective, it must be possible to replace the creation of any instance of NSRegularExpression. The initializer for NSRegularExpression accepts a string describing the pattern and a set of options. To support these options, a regular expression literal accepts a list of zero or more options after the delimiter closing the pattern. For example, consider a regular expression to match and parse email addresses.<br>&gt; <br>&gt; let emailRegex = /^([a-z0-9_\.-]+)@([\da-z\.-]+)\.([a-z\.]{2,6})$/<br>&gt; This regular expression will match &quot;john.appleseed at apple.com &lt;mailto:john.appleseed at apple.com&gt;&quot;&quot;, but not &quot;JOHN.APPLESEED at APPLE.COM &lt;mailto:JOHN.APPLESEED at apple.com&gt;&quot;. The regular expression has to allow for this, as email addresses are not case sensitive. Rather than add the complexity to the pattern to account for this, the following example achieves the same:<br>&gt; <br>&gt; let emailRegex = /^([a-z0-9_\.-]+)@([\da-z\.-]+)\.([a-z\.]{2,6})$/i<br>&gt; In this case, the &quot;i&quot; following the delimiter closing the pattern maps to RegularExpressionOption.CaseInsensitive.<br>&gt; <br>&gt; Detailed design<br>&gt; The following modification to the grammar of a literal adds support for regular expression literals:<br>&gt; <br>&gt; literal → numeric-literal | string-literal | boolean-literal | regex-literal | nil-literal<br>&gt; <br>&gt; The following grammar describes a regular expression literal:<br>&gt; <br>&gt; regex-literal → static-regex-literal | interpolated-regex-literal<br>&gt; <br>&gt; static-regex-literal → / patternopt / regex-optionsopt<br>&gt; pattern → pattern_item patternopt<br>&gt; pattern_item → any Unicode scalar value except /, U+000A, or U+000D<br>&gt; <br>&gt; interpolated-string-literal → / interpolated-patternopt / regex-optionsopt<br>&gt; interpolated_pattern → interpolated_pattern_item interpolated_patternopt<br>&gt; interpolated_pattern_item → ( expression ) | pattern_item<br>&gt; <br>&gt; regex-options → regex-option | regex-optionopt<br>&gt; regex_option → i | x | q | s | m | d | b<br>&gt; <br>&gt; The following table summarize the regular expression options:<br>&gt; <br>&gt; Option 	RegularExpressionOption <br>&gt; i 	CaseInsensitive <br>&gt; x 	AllowCommentsAndWhitespace <br>&gt; q 	IgnoreMetacharacters <br>&gt; s 	DotMatchesLineSeparations <br>&gt; m 	AnchorsMatchLines <br>&gt; d 	UseUnixLineSeparators <br>&gt; b 	UseUnicodeWordBoundaries <br>&gt; Impact on existing code<br>&gt; The use of regular expression literals is opt-in, and hence there is no impact to existing code.<br>&gt; <br>&gt; Alternatives considered<br>&gt; There have been several threads on the swift-evoluation mailing list that have discussed alternatives to regular expression literals.<br>&gt; <br>&gt; String literal suffixes for defining types &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002193.html&gt; discussed string literals with a single character appended after the closing delimiter to denote the type. For example, the string literal r&quot;\d+&quot; in Python denotes a regular expression literal. However, this approach suffers from two disadvantages: 1) it does not support string interpolation in the pattern, and 2) it uses double-quotes for the delimiter, which appears more frequently in regular expressions than the forward slash.<br>&gt; <br>&gt; Muli-line string literals &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002325.html&gt; discussed string literals spanning more than one line. This would be a worthy addition to the regular expression literal discussed in this proposal. We should consider modifying the grammar to support this. However, I wanted to introduce changes incrementally to maintain focus.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160131/ae6e6f83/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ab486d7597af4cfe0be33a762150848?s=50"></div><header><strong>Empower String type with regular expression</strong> from <string>Dany St-Amant</string> &lt;dsa.mls at icloud.com&gt;<p>January 31, 2016 at 03:00:00pm</p></header><div class="content"><p>This seem to be two proposals in one:<br>1. Initialize NSRegularExpression with a single String which includes options<br></p><p>The ultimate goal based on the earlier mail in the thread seems to be able in a future proposal do thing like: string ~= replacePattern, if string =~ pattern, decoupled from the legacy Obj-C. Isn’t NSRegularExpression part of the legacy? The conversion of the literal string as regular expression should probably part of the proposal for these operators; as this is the time we will know how we want the text to be interpreted.<br></p><p>2. Easily create a String without escaping (\n is not linefeed, but \ and n)<br></p><p>The ability to not interpret the backslash as escape can be useful in other scenario that creating a NSRegularExpression; like creating a Windows pathname, or creating regular expression which are then given to external tool.  So this part of the proposal should probably be generalized.<br></p><p>Dany<br></p><p>&gt; Le 31 janv. 2016 à 12:18, Patrick Gili via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Here is the link to the proposal on GitHub:<br>&gt; <br>&gt; https://github.com/gili-patrick-r/swift-evolution/blob/master/proposals/NNNN-regular-expression-literals.md &lt;https://github.com/gili-patrick-r/swift-evolution/blob/master/proposals/NNNN-regular-expression-literals.md&gt;<br>&gt; <br>&gt; Cheers,<br>&gt; -Patrick<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160131/b9112287/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05e222e6ef4d84013bb3baeb0e25c90b?s=50"></div><header><strong>Empower String type with regular expression</strong> from <string>Patrick Gili</string> &lt;gili.patrick.r at gili-labs.com&gt;<p>January 31, 2016 at 04:00:00pm</p></header><div class="content"><p>Hi Dany,<br></p><p>Please find my response inline below.<br></p><p>Cheers,<br>-Patrick<br></p><p>&gt; On Jan 31, 2016, at 3:46 PM, Dany St-Amant via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This seem to be two proposals in one:<br>&gt; 1. Initialize NSRegularExpression with a single String which includes options<br>&gt; <br>&gt; The ultimate goal based on the earlier mail in the thread seems to be able in a future proposal do thing like: string ~= replacePattern, if string =~ pattern, decoupled from the legacy Obj-C. Isn’t NSRegularExpression part of the legacy? The conversion of the literal string as regular expression should probably part of the proposal for these operators; as this is the time we will know how we want the text to be interpreted.<br></p><p>I don&#39;t see any evidence of NSRegularExpression becoming part of any legacy. Given SE-005, SE-006, and SE-023, the name is probably changing from NSRegularExpression to RegularExpression. However, I don&#39;t think the definition of the class will change, only the name.<br></p><p>I would like to see an operator regular expression matching operator, like Ruby and Perl. I was trying to keep the proposal a minimal increment that would buy the biggest bang for the buck. We can already accomplish much of what other languages can do with regard to regular expression. However, the notion of a regular expression isn&#39;t something we can work around with custom library today. Can you suggest something addition that should be in the proposal?<br></p><p>&gt; 2. Easily create a String without escaping (\n is not linefeed, but \ and n)<br>&gt; <br>&gt; The ability to not interpret the backslash as escape can be useful in other scenario that creating a NSRegularExpression; like creating a Windows pathname, or creating regular expression which are then given to external tool.  So this part of the proposal should probably be generalized.<br></p><p>Generalize it for what? If you&#39;re thinking along the line of raw strings, I agree that we need this capability, as well as multi-line string literals. However, I just soon we have separate proposals for this.<br></p><p>&gt; Dany<br>&gt; <br>&gt;&gt; Le 31 janv. 2016 à 12:18, Patrick Gili via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; Here is the link to the proposal on GitHub:<br>&gt;&gt; <br>&gt;&gt; https://github.com/gili-patrick-r/swift-evolution/blob/master/proposals/NNNN-regular-expression-literals.md &lt;https://github.com/gili-patrick-r/swift-evolution/blob/master/proposals/NNNN-regular-expression-literals.md&gt;<br>&gt;&gt; <br>&gt;&gt; Cheers,<br>&gt;&gt; -Patrick<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160131/c449206e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ab486d7597af4cfe0be33a762150848?s=50"></div><header><strong>Empower String type with regular expression</strong> from <string>Dany St-Amant</string> &lt;dsa.mls at icloud.com&gt;<p>January 31, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; Le 31 janv. 2016 à 16:46, Patrick Gili &lt;gili.patrick.r at gili-labs.com&gt; a écrit :<br>&gt; <br>&gt; Hi Dany,<br>&gt; <br>&gt; Please find my response inline below.<br>&gt; <br>&gt; Cheers,<br>&gt; -Patrick<br>&gt; <br>&gt;&gt; On Jan 31, 2016, at 3:46 PM, Dany St-Amant via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This seem to be two proposals in one:<br>&gt;&gt; 1. Initialize NSRegularExpression with a single String which includes options<br>&gt;&gt; <br>&gt;&gt; The ultimate goal based on the earlier mail in the thread seems to be able in a future proposal do thing like: string ~= replacePattern, if string =~ pattern, decoupled from the legacy Obj-C. Isn’t NSRegularExpression part of the legacy? The conversion of the literal string as regular expression should probably part of the proposal for these operators; as this is the time we will know how we want the text to be interpreted.<br>&gt; <br>&gt; I don&#39;t see any evidence of NSRegularExpression becoming part of any legacy. Given SE-005, SE-006, and SE-023, the name is probably changing from NSRegularExpression to RegularExpression. However, I don&#39;t think the definition of the class will change, only the name.<br>&gt; <br>&gt; I would like to see an operator regular expression matching operator, like Ruby and Perl. I was trying to keep the proposal a minimal increment that would buy the biggest bang for the buck. We can already accomplish much of what other languages can do with regard to regular expression. However, the notion of a regular expression isn&#39;t something we can work around with custom library today. Can you suggest something addition that should be in the proposal?<br></p><p>Splitting proposal in smaller ones have its advantage, but here I am just wondering if we are sure that these future operation will use the NSRegularExpression/RegularExpression. And does the currently selected syntax allow for future expansion, it would be bad to introduce something  that need to be torn away or changed in an incompatible way, once we really start to use them in their final location.<br></p><p>The proposal is focused on the search, but seem to skip the substitution; I am unable to see an option to replace all matches instead of the first one only in the proposal. I, as many other, would expect regular expression in a language to also support substitution.<br></p><p>As for addition to the proposal, the processing of the string could be support for any character (within some limit) for the slash delimiter. With sed, when replacing  path component, one can do: echo $PWD | sed -e &quot;s:^/usr/local/bin:/opt/share/bin:g&quot;, instead of escaping every single slashes. Which is really handy to make thing easier to read.<br></p><p>Also, putting aside that I think \(scheme) should not be interpreted in the example, with a syntax allowing such interpretation the variable should be processed to generate proper escaping. If one is to use \(filename) you get &quot;main.c&quot;, but one must use \(filename.escaped()) to get the proper &quot;main\.c&quot; to avoid matching &quot;mainac&quot;. The String.escaped() must be in a format compatible with the format used when converting the regular expression into NSRegularExpression (not sure if the two syntax are the same; I think that at least the handling of /  may differ)<br> <br></p><p>&gt; <br>&gt;&gt; 2. Easily create a String without escaping (\n is not linefeed, but \ and n)<br>&gt;&gt; <br>&gt;&gt; The ability to not interpret the backslash as escape can be useful in other scenario that creating a NSRegularExpression; like creating a Windows pathname, or creating regular expression which are then given to external tool.  So this part of the proposal should probably be generalized.<br>&gt; <br>&gt; Generalize it for what? If you&#39;re thinking along the line of raw strings, I agree that we need this capability, as well as multi-line string literals. However, I just soon we have separate proposals for this.<br></p><p>My point/opinion here, is that a regular expressions are just a String which are then interpreted; the same way as &quot;Good Morning&quot;, &quot;Bonjour&quot;, or &quot;Marhaba&quot; (even when using the arabic script) are just String when you assign then to a variable in Swift, and then interpreted by the intended user. They are not String, frenchString, rigthToLeftString. So I do not see why a regular expression should have privileged treatment and have its own language level syntax. The only difference when writing regular expression, or Windows pathname, or any String with a syntax with heavily uses of backslashes, is that one may want to disable the special meaning of the backslashes, to make thing more readable.<br></p><p>On the page of geeky-ing the String there’s four main part IMHO<br>- multi-line support<br>- no backslash escaping version (which should include no processing the \(variable) format)<br>- inclusion of String delimiter inside the String<br>- concat of backslash/no backslash version. Bash example echo &#39;echo &quot;$BASH&quot; shows &#39;&quot;$BASH&quot;<br></p><p>I’m still trying to find back the mail thread crumbs on these topics, since before restarting the discussion in these topics, the previous one should be properly summarized; unless such summary already exist.<br></p><p>Regards,<br>Dany<br></p><p>&gt;&gt; Dany<br>&gt;&gt; <br>&gt;&gt;&gt; Le 31 janv. 2016 à 12:18, Patrick Gili via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here is the link to the proposal on GitHub:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/gili-patrick-r/swift-evolution/blob/master/proposals/NNNN-regular-expression-literals.md &lt;https://github.com/gili-patrick-r/swift-evolution/blob/master/proposals/NNNN-regular-expression-literals.md&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt; -Patrick<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160131/3eaece8a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05e222e6ef4d84013bb3baeb0e25c90b?s=50"></div><header><strong>Empower String type with regular expression</strong> from <string>Patrick Gili</string> &lt;gili.patrick.r at gili-labs.com&gt;<p>February  1, 2016 at 09:00:00am</p></header><div class="content"><p>Hi Dany,<br></p><p>My response is inline below.<br></p><p>Cheers,<br>-Patrick<br></p><p>&gt; On Jan 31, 2016, at 8:56 PM, Dany St-Amant &lt;dsa.mls at icloud.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Le 31 janv. 2016 à 16:46, Patrick Gili &lt;gili.patrick.r at gili-labs.com &lt;mailto:gili.patrick.r at gili-labs.com&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; Hi Dany,<br>&gt;&gt; <br>&gt;&gt; Please find my response inline below.<br>&gt;&gt; <br>&gt;&gt; Cheers,<br>&gt;&gt; -Patrick<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 31, 2016, at 3:46 PM, Dany St-Amant via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This seem to be two proposals in one:<br>&gt;&gt;&gt; 1. Initialize NSRegularExpression with a single String which includes options<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The ultimate goal based on the earlier mail in the thread seems to be able in a future proposal do thing like: string ~= replacePattern, if string =~ pattern, decoupled from the legacy Obj-C. Isn’t NSRegularExpression part of the legacy? The conversion of the literal string as regular expression should probably part of the proposal for these operators; as this is the time we will know how we want the text to be interpreted.<br>&gt;&gt; <br>&gt;&gt; I don&#39;t see any evidence of NSRegularExpression becoming part of any legacy. Given SE-005, SE-006, and SE-023, the name is probably changing from NSRegularExpression to RegularExpression. However, I don&#39;t think the definition of the class will change, only the name.<br>&gt;&gt; <br>&gt;&gt; I would like to see an operator regular expression matching operator, like Ruby and Perl. I was trying to keep the proposal a minimal increment that would buy the biggest bang for the buck. We can already accomplish much of what other languages can do with regard to regular expression. However, the notion of a regular expression isn&#39;t something we can work around with custom library today. Can you suggest something addition that should be in the proposal?<br>&gt; <br>&gt; Splitting proposal in smaller ones have its advantage, but here I am just wondering if we are sure that these future operation will use the NSRegularExpression/RegularExpression. And does the currently selected syntax allow for future expansion, it would be bad to introduce something  that need to be torn away or changed in an incompatible way, once we really start to use them in their final location.<br>&gt; <br>&gt; The proposal is focused on the search, but seem to skip the substitution; I am unable to see an option to replace all matches instead of the first one only in the proposal. I, as many other, would expect regular expression in a language to also support substitution.<br>&gt; <br>&gt; As for addition to the proposal, the processing of the string could be support for any character (within some limit) for the slash delimiter. With sed, when replacing  path component, one can do: echo $PWD | sed -e &quot;s:^/usr/local/bin:/opt/share/bin:g&quot;, instead of escaping every single slashes. Which is really handy to make thing easier to read.<br>&gt; <br>&gt; Also, putting aside that I think \(scheme) should not be interpreted in the example, with a syntax allowing such interpretation the variable should be processed to generate proper escaping. If one is to use \(filename) you get &quot;main.c&quot;, but one must use \(filename.escaped()) to get the proper &quot;main\.c&quot; to avoid matching &quot;mainac&quot;. The String.escaped() must be in a format compatible with the format used when converting the regular expression into NSRegularExpression (not sure if the two syntax are the same; I think that at least the handling of /  may differ)<br></p><p>I agree. Perhaps I went too far with keeping the proposal short-and-sweet. Especially when you consider the rich syntax that Perl supports for substitution.<br></p><p>&gt;&gt; <br>&gt;&gt;&gt; 2. Easily create a String without escaping (\n is not linefeed, but \ and n)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The ability to not interpret the backslash as escape can be useful in other scenario that creating a NSRegularExpression; like creating a Windows pathname, or creating regular expression which are then given to external tool.  So this part of the proposal should probably be generalized.<br>&gt;&gt; <br>&gt;&gt; Generalize it for what? If you&#39;re thinking along the line of raw strings, I agree that we need this capability, as well as multi-line string literals. However, I just soon we have separate proposals for this.<br>&gt; <br>&gt; My point/opinion here, is that a regular expressions are just a String which are then interpreted; the same way as &quot;Good Morning&quot;, &quot;Bonjour&quot;, or &quot;Marhaba&quot; (even when using the arabic script) are just String when you assign then to a variable in Swift, and then interpreted by the intended user. They are not String, frenchString, rigthToLeftString. So I do not see why a regular expression should have privileged treatment and have its own language level syntax. The only difference when writing regular expression, or Windows pathname, or any String with a syntax with heavily uses of backslashes, is that one may want to disable the special meaning of the backslashes, to make thing more readable.<br>&gt; <br>&gt; On the page of geeky-ing the String there’s four main part IMHO<br>&gt; - multi-line support<br>&gt; - no backslash escaping version (which should include no processing the \(variable) format)<br>&gt; - inclusion of String delimiter inside the String<br>&gt; - concat of backslash/no backslash version. Bash example echo &#39;echo &quot;$BASH&quot; shows &#39;&quot;$BASH&quot;<br>&gt; <br>&gt; I’m still trying to find back the mail thread crumbs on these topics, since before restarting the discussion in these topics, the previous one should be properly summarized; unless such summary already exist.<br></p><p>I think supporting interpolation is important. Both Perl and Ruby support it, and I&#39;m sure there are other languages. One thing I forgot to put into the proposal: an option to disable interpolation or limit it to single pass.<br></p><p>Looking ahead at the other responses, Chris Lattner has suggested that the proposal would have more traction if we can find a way to fold this into Swift&#39;s pattern matching. I can&#39;t say as I disagree, as this makes regular expression more Swifty.<br></p><p>&gt; <br>&gt; Regards,<br>&gt; Dany<br>&gt; <br>&gt;&gt;&gt; Dany<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Le 31 janv. 2016 à 12:18, Patrick Gili via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Here is the link to the proposal on GitHub:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://github.com/gili-patrick-r/swift-evolution/blob/master/proposals/NNNN-regular-expression-literals.md &lt;https://github.com/gili-patrick-r/swift-evolution/blob/master/proposals/NNNN-regular-expression-literals.md&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt; -Patrick<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/7ecf4ebb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Empower String type with regular expression</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>February  1, 2016 at 02:00:00pm</p></header><div class="content"><p>It would be great if we could create a generic way of making this swifty.<br>You may let say want to implement a matching system for structure like JSON<br>or XML (i.e XQuery).<br></p><p><br></p><p>*___________________________________*<br></p><p>*James⎥Lead Engineer*<br></p><p>*james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com &lt;http://supmenow.com&gt;*<br></p><p>*Sup*<br></p><p>*Runway East *<br></p><p>*10 Finsbury Square*<br></p><p>*London*<br></p><p>* EC2A 1AF *<br></p><p>On Mon, Feb 1, 2016 at 2:43 PM, Patrick Gili via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hi Dany,<br>&gt;<br>&gt; My response is inline below.<br>&gt;<br>&gt; Cheers,<br>&gt; -Patrick<br>&gt;<br>&gt; On Jan 31, 2016, at 8:56 PM, Dany St-Amant &lt;dsa.mls at icloud.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; Le 31 janv. 2016 à 16:46, Patrick Gili &lt;gili.patrick.r at gili-labs.com&gt; a<br>&gt; écrit :<br>&gt;<br>&gt; Hi Dany,<br>&gt;<br>&gt; Please find my response inline below.<br>&gt;<br>&gt; Cheers,<br>&gt; -Patrick<br>&gt;<br>&gt; On Jan 31, 2016, at 3:46 PM, Dany St-Amant via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; This seem to be two proposals in one:<br>&gt; 1. Initialize NSRegularExpression with a single String which includes<br>&gt; options<br>&gt;<br>&gt; The ultimate goal based on the earlier mail in the thread seems to be able<br>&gt; in a future proposal do thing like: string ~= replacePattern, if string =~<br>&gt; pattern, decoupled from the legacy Obj-C. Isn’t NSRegularExpression part of<br>&gt; the legacy? The conversion of the literal string as regular expression<br>&gt; should probably part of the proposal for these operators; as this is the<br>&gt; time we will know how we want the text to be interpreted.<br>&gt;<br>&gt;<br>&gt; I don&#39;t see any evidence of NSRegularExpression becoming part of any<br>&gt; legacy. Given SE-005, SE-006, and SE-023, the name is probably changing<br>&gt; from NSRegularExpression to RegularExpression. However, I don&#39;t think the<br>&gt; definition of the class will change, only the name.<br>&gt;<br>&gt; I would like to see an operator regular expression matching operator, like<br>&gt; Ruby and Perl. I was trying to keep the proposal a minimal increment that<br>&gt; would buy the biggest bang for the buck. We can already accomplish much of<br>&gt; what other languages can do with regard to regular expression. However, the<br>&gt; notion of a regular expression isn&#39;t something we can work around with<br>&gt; custom library today. Can you suggest something addition that should be in<br>&gt; the proposal?<br>&gt;<br>&gt;<br>&gt; Splitting proposal in smaller ones have its advantage, but here I am just<br>&gt; wondering if we are sure that these future operation will use the<br>&gt; NSRegularExpression/RegularExpression. And does the currently selected<br>&gt; syntax allow for future expansion, it would be bad to introduce something<br>&gt;  that need to be torn away or changed in an incompatible way, once we<br>&gt; really start to use them in their final location.<br>&gt;<br>&gt; The proposal is focused on the search, but seem to skip the substitution;<br>&gt; I am unable to see an option to replace all matches instead of the first<br>&gt; one only in the proposal. I, as many other, would expect regular expression<br>&gt; in a language to also support substitution.<br>&gt;<br>&gt; As for addition to the proposal, the processing of the string could be<br>&gt; support for any character (within some limit) for the slash delimiter. With<br>&gt; sed, when replacing  path component, one can do: echo $PWD | sed -e<br>&gt; &quot;s:^/usr/local/bin:/opt/share/bin:g&quot;, instead of escaping every single<br>&gt; slashes. Which is really handy to make thing easier to read.<br>&gt;<br>&gt; Also, putting aside that I think \(scheme) should not be interpreted in<br>&gt; the example, with a syntax allowing such interpretation the variable should<br>&gt; be processed to generate proper escaping. If one is to use \(filename) you<br>&gt; get &quot;main.c&quot;, but one must use \(filename.escaped()) to get the proper<br>&gt; &quot;main\.c&quot; to avoid matching &quot;mainac&quot;. The String.escaped() must be in a<br>&gt; format compatible with the format used when converting the regular<br>&gt; expression into NSRegularExpression (not sure if the two syntax are the<br>&gt; same; I think that at least the handling of /  may differ)<br>&gt;<br>&gt;<br>&gt; I agree. Perhaps I went too far with keeping the proposal short-and-sweet.<br>&gt; Especially when you consider the rich syntax that Perl supports for<br>&gt; substitution.<br>&gt;<br>&gt;<br>&gt; 2. Easily create a String without escaping (\n is not linefeed, but \ and<br>&gt; n)<br>&gt;<br>&gt; The ability to not interpret the backslash as escape can be useful in<br>&gt; other scenario that creating a NSRegularExpression; like creating a Windows<br>&gt; pathname, or creating regular expression which are then given to external<br>&gt; tool.  So this part of the proposal should probably be generalized.<br>&gt;<br>&gt;<br>&gt; Generalize it for what? If you&#39;re thinking along the line of raw strings,<br>&gt; I agree that we need this capability, as well as multi-line string<br>&gt; literals. However, I just soon we have separate proposals for this.<br>&gt;<br>&gt;<br>&gt; My point/opinion here, is that a regular expressions are just a String<br>&gt; which are then interpreted; the same way as &quot;Good Morning&quot;, &quot;Bonjour&quot;, or<br>&gt; &quot;Marhaba&quot; (even when using the arabic script) are just String when you<br>&gt; assign then to a variable in Swift, and then interpreted by the intended<br>&gt; user. They are not String, frenchString, rigthToLeftString. So I do not see<br>&gt; why a regular expression should have privileged treatment and have its own<br>&gt; language level syntax. The only difference when writing regular expression,<br>&gt; or Windows pathname, or any String with a syntax with heavily uses of<br>&gt; backslashes, is that one may want to disable the special meaning of the<br>&gt; backslashes, to make thing more readable.<br>&gt;<br>&gt; On the page of geeky-ing the String there’s four main part IMHO<br>&gt; - multi-line support<br>&gt; - no backslash escaping version (which should include no processing the<br>&gt; \(variable) format)<br>&gt; - inclusion of String delimiter inside the String<br>&gt; - concat of backslash/no backslash version. Bash example echo &#39;echo<br>&gt; &quot;$BASH&quot; shows &#39;&quot;$BASH&quot;<br>&gt;<br>&gt; I’m still trying to find back the mail thread crumbs on these topics,<br>&gt; since before restarting the discussion in these topics, the previous one<br>&gt; should be properly summarized; unless such summary already exist.<br>&gt;<br>&gt;<br>&gt; I think supporting interpolation is important. Both Perl and Ruby support<br>&gt; it, and I&#39;m sure there are other languages. One thing I forgot to put into<br>&gt; the proposal: an option to disable interpolation or limit it to single pass.<br>&gt;<br>&gt; Looking ahead at the other responses, Chris Lattner has suggested that the<br>&gt; proposal would have more traction if we can find a way to fold this into<br>&gt; Swift&#39;s pattern matching. I can&#39;t say as I disagree, as this makes regular<br>&gt; expression more Swifty.<br>&gt;<br>&gt;<br>&gt; Regards,<br>&gt; Dany<br>&gt;<br>&gt; Dany<br>&gt;<br>&gt; Le 31 janv. 2016 à 12:18, Patrick Gili via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;<br>&gt; Here is the link to the proposal on GitHub:<br>&gt;<br>&gt;<br>&gt; https://github.com/gili-patrick-r/swift-evolution/blob/master/proposals/NNNN-regular-expression-literals.md<br>&gt;<br>&gt; Cheers,<br>&gt; -Patrick<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/587d94c8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05e222e6ef4d84013bb3baeb0e25c90b?s=50"></div><header><strong>Empower String type with regular expression</strong> from <string>Patrick Gili</string> &lt;gili.patrick.r at gili-labs.com&gt;<p>February  1, 2016 at 09:00:00am</p></header><div class="content"><p>Hi James,<br></p><p>While I&#39;m familiar with Query, I am not familiar with matching in JSON. Can you provide me an example or a pointer to something I can read?<br></p><p>Cheers,<br>-Patrik<br></p><p>&gt; On Feb 1, 2016, at 9:46 AM, James Campbell &lt;james at supmenow.com&gt; wrote:<br>&gt; <br>&gt; It would be great if we could create a generic way of making this swifty. You may let say want to implement a matching system for structure like JSON or XML (i.e XQuery).<br>&gt; <br>&gt; <br>&gt; <br>&gt; ___________________________________<br>&gt; <br>&gt; James⎥Lead Engineer<br>&gt; <br>&gt; james at supmenow.com &lt;mailto:james at supmenow.com&gt;⎥supmenow.com &lt;http://supmenow.com/&gt;<br>&gt; Sup<br>&gt; <br>&gt; Runway East &gt; <br>&gt; <br>&gt; 10 Finsbury Square<br>&gt; <br>&gt; London<br>&gt; <br>&gt;  &gt; EC2A 1AF <br>&gt; <br>&gt; <br>&gt; On Mon, Feb 1, 2016 at 2:43 PM, Patrick Gili via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Hi Dany,<br>&gt; <br>&gt; My response is inline below.<br>&gt; <br>&gt; Cheers,<br>&gt; -Patrick<br>&gt; <br>&gt;&gt; On Jan 31, 2016, at 8:56 PM, Dany St-Amant &lt;dsa.mls at icloud.com &lt;mailto:dsa.mls at icloud.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Le 31 janv. 2016 à 16:46, Patrick Gili &lt;gili.patrick.r at gili-labs.com &lt;mailto:gili.patrick.r at gili-labs.com&gt;&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi Dany,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Please find my response inline below.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt; -Patrick<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 31, 2016, at 3:46 PM, Dany St-Amant via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This seem to be two proposals in one:<br>&gt;&gt;&gt;&gt; 1. Initialize NSRegularExpression with a single String which includes options<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The ultimate goal based on the earlier mail in the thread seems to be able in a future proposal do thing like: string ~= replacePattern, if string =~ pattern, decoupled from the legacy Obj-C. Isn’t NSRegularExpression part of the legacy? The conversion of the literal string as regular expression should probably part of the proposal for these operators; as this is the time we will know how we want the text to be interpreted.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t see any evidence of NSRegularExpression becoming part of any legacy. Given SE-005, SE-006, and SE-023, the name is probably changing from NSRegularExpression to RegularExpression. However, I don&#39;t think the definition of the class will change, only the name.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would like to see an operator regular expression matching operator, like Ruby and Perl. I was trying to keep the proposal a minimal increment that would buy the biggest bang for the buck. We can already accomplish much of what other languages can do with regard to regular expression. However, the notion of a regular expression isn&#39;t something we can work around with custom library today. Can you suggest something addition that should be in the proposal?<br>&gt;&gt; <br>&gt;&gt; Splitting proposal in smaller ones have its advantage, but here I am just wondering if we are sure that these future operation will use the NSRegularExpression/RegularExpression. And does the currently selected syntax allow for future expansion, it would be bad to introduce something  that need to be torn away or changed in an incompatible way, once we really start to use them in their final location.<br>&gt;&gt; <br>&gt;&gt; The proposal is focused on the search, but seem to skip the substitution; I am unable to see an option to replace all matches instead of the first one only in the proposal. I, as many other, would expect regular expression in a language to also support substitution.<br>&gt;&gt; <br>&gt;&gt; As for addition to the proposal, the processing of the string could be support for any character (within some limit) for the slash delimiter. With sed, when replacing  path component, one can do: echo $PWD | sed -e &quot;s:^/usr/local/bin:/opt/share/bin:g&quot;, instead of escaping every single slashes. Which is really handy to make thing easier to read.<br>&gt;&gt; <br>&gt;&gt; Also, putting aside that I think \(scheme) should not be interpreted in the example, with a syntax allowing such interpretation the variable should be processed to generate proper escaping. If one is to use \(filename) you get &quot;main.c&quot;, but one must use \(filename.escaped()) to get the proper &quot;main\.c&quot; to avoid matching &quot;mainac&quot;. The String.escaped() must be in a format compatible with the format used when converting the regular expression into NSRegularExpression (not sure if the two syntax are the same; I think that at least the handling of /  may differ)<br>&gt; <br>&gt; I agree. Perhaps I went too far with keeping the proposal short-and-sweet. Especially when you consider the rich syntax that Perl supports for substitution.<br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2. Easily create a String without escaping (\n is not linefeed, but \ and n)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The ability to not interpret the backslash as escape can be useful in other scenario that creating a NSRegularExpression; like creating a Windows pathname, or creating regular expression which are then given to external tool.  So this part of the proposal should probably be generalized.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Generalize it for what? If you&#39;re thinking along the line of raw strings, I agree that we need this capability, as well as multi-line string literals. However, I just soon we have separate proposals for this.<br>&gt;&gt; <br>&gt;&gt; My point/opinion here, is that a regular expressions are just a String which are then interpreted; the same way as &quot;Good Morning&quot;, &quot;Bonjour&quot;, or &quot;Marhaba&quot; (even when using the arabic script) are just String when you assign then to a variable in Swift, and then interpreted by the intended user. They are not String, frenchString, rigthToLeftString. So I do not see why a regular expression should have privileged treatment and have its own language level syntax. The only difference when writing regular expression, or Windows pathname, or any String with a syntax with heavily uses of backslashes, is that one may want to disable the special meaning of the backslashes, to make thing more readable.<br>&gt;&gt; <br>&gt;&gt; On the page of geeky-ing the String there’s four main part IMHO<br>&gt;&gt; - multi-line support<br>&gt;&gt; - no backslash escaping version (which should include no processing the \(variable) format)<br>&gt;&gt; - inclusion of String delimiter inside the String<br>&gt;&gt; - concat of backslash/no backslash version. Bash example echo &#39;echo &quot;$BASH&quot; shows &#39;&quot;$BASH&quot;<br>&gt;&gt; <br>&gt;&gt; I’m still trying to find back the mail thread crumbs on these topics, since before restarting the discussion in these topics, the previous one should be properly summarized; unless such summary already exist.<br>&gt; <br>&gt; I think supporting interpolation is important. Both Perl and Ruby support it, and I&#39;m sure there are other languages. One thing I forgot to put into the proposal: an option to disable interpolation or limit it to single pass.<br>&gt; <br>&gt; Looking ahead at the other responses, Chris Lattner has suggested that the proposal would have more traction if we can find a way to fold this into Swift&#39;s pattern matching. I can&#39;t say as I disagree, as this makes regular expression more Swifty.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Regards,<br>&gt;&gt; Dany<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; Dany<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Le 31 janv. 2016 à 12:18, Patrick Gili via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Here is the link to the proposal on GitHub:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; https://github.com/gili-patrick-r/swift-evolution/blob/master/proposals/NNNN-regular-expression-literals.md &lt;https://github.com/gili-patrick-r/swift-evolution/blob/master/proposals/NNNN-regular-expression-literals.md&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt;&gt; -Patrick<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/a2301613/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Empower String type with regular expression</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>February  1, 2016 at 03:00:00pm</p></header><div class="content"><p>There is path match<br></p><p>http://goessner.net/articles/JsonPath/<br></p><p>*___________________________________*<br></p><p>*James⎥Lead Engineer*<br></p><p>*james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com &lt;http://supmenow.com&gt;*<br></p><p>*Sup*<br></p><p>*Runway East *<br></p><p>*10 Finsbury Square*<br></p><p>*London*<br></p><p>* EC2A 1AF *<br></p><p>On Mon, Feb 1, 2016 at 2:57 PM, Patrick Gili &lt;gili.patrick.r at gili-labs.com&gt;<br>wrote:<br></p><p>&gt; Hi James,<br>&gt;<br>&gt; While I&#39;m familiar with Query, I am not familiar with matching in JSON.<br>&gt; Can you provide me an example or a pointer to something I can read?<br>&gt;<br>&gt; Cheers,<br>&gt; -Patrik<br>&gt;<br>&gt; On Feb 1, 2016, at 9:46 AM, James Campbell &lt;james at supmenow.com&gt; wrote:<br>&gt;<br>&gt; It would be great if we could create a generic way of making this swifty.<br>&gt; You may let say want to implement a matching system for structure like JSON<br>&gt; or XML (i.e XQuery).<br>&gt;<br>&gt;<br>&gt;<br>&gt; *___________________________________*<br>&gt;<br>&gt; *James⎥Lead Engineer*<br>&gt;<br>&gt; *james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com<br>&gt; &lt;http://supmenow.com/&gt;*<br>&gt;<br>&gt; *Sup*<br>&gt;<br>&gt; *Runway East *<br>&gt;<br>&gt; *10 Finsbury Square*<br>&gt;<br>&gt; *London*<br>&gt;<br>&gt; * EC2A 1AF *<br>&gt;<br>&gt; On Mon, Feb 1, 2016 at 2:43 PM, Patrick Gili via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Hi Dany,<br>&gt;&gt;<br>&gt;&gt; My response is inline below.<br>&gt;&gt;<br>&gt;&gt; Cheers,<br>&gt;&gt; -Patrick<br>&gt;&gt;<br>&gt;&gt; On Jan 31, 2016, at 8:56 PM, Dany St-Amant &lt;dsa.mls at icloud.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Le 31 janv. 2016 à 16:46, Patrick Gili &lt;gili.patrick.r at gili-labs.com&gt; a<br>&gt;&gt; écrit :<br>&gt;&gt;<br>&gt;&gt; Hi Dany,<br>&gt;&gt;<br>&gt;&gt; Please find my response inline below.<br>&gt;&gt;<br>&gt;&gt; Cheers,<br>&gt;&gt; -Patrick<br>&gt;&gt;<br>&gt;&gt; On Jan 31, 2016, at 3:46 PM, Dany St-Amant via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; This seem to be two proposals in one:<br>&gt;&gt; 1. Initialize NSRegularExpression with a single String which includes<br>&gt;&gt; options<br>&gt;&gt;<br>&gt;&gt; The ultimate goal based on the earlier mail in the thread seems to be<br>&gt;&gt; able in a future proposal do thing like: string ~= replacePattern, if<br>&gt;&gt; string =~ pattern, decoupled from the legacy Obj-C. Isn’t<br>&gt;&gt; NSRegularExpression part of the legacy? The conversion of the literal<br>&gt;&gt; string as regular expression should probably part of the proposal for these<br>&gt;&gt; operators; as this is the time we will know how we want the text to be<br>&gt;&gt; interpreted.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I don&#39;t see any evidence of NSRegularExpression becoming part of any<br>&gt;&gt; legacy. Given SE-005, SE-006, and SE-023, the name is probably changing<br>&gt;&gt; from NSRegularExpression to RegularExpression. However, I don&#39;t think the<br>&gt;&gt; definition of the class will change, only the name.<br>&gt;&gt;<br>&gt;&gt; I would like to see an operator regular expression matching operator,<br>&gt;&gt; like Ruby and Perl. I was trying to keep the proposal a minimal increment<br>&gt;&gt; that would buy the biggest bang for the buck. We can already accomplish<br>&gt;&gt; much of what other languages can do with regard to regular expression.<br>&gt;&gt; However, the notion of a regular expression isn&#39;t something we can work<br>&gt;&gt; around with custom library today. Can you suggest something addition that<br>&gt;&gt; should be in the proposal?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Splitting proposal in smaller ones have its advantage, but here I am just<br>&gt;&gt; wondering if we are sure that these future operation will use the<br>&gt;&gt; NSRegularExpression/RegularExpression. And does the currently selected<br>&gt;&gt; syntax allow for future expansion, it would be bad to introduce something<br>&gt;&gt;  that need to be torn away or changed in an incompatible way, once we<br>&gt;&gt; really start to use them in their final location.<br>&gt;&gt;<br>&gt;&gt; The proposal is focused on the search, but seem to skip the substitution;<br>&gt;&gt; I am unable to see an option to replace all matches instead of the first<br>&gt;&gt; one only in the proposal. I, as many other, would expect regular expression<br>&gt;&gt; in a language to also support substitution.<br>&gt;&gt;<br>&gt;&gt; As for addition to the proposal, the processing of the string could be<br>&gt;&gt; support for any character (within some limit) for the slash delimiter. With<br>&gt;&gt; sed, when replacing  path component, one can do: echo $PWD | sed -e<br>&gt;&gt; &quot;s:^/usr/local/bin:/opt/share/bin:g&quot;, instead of escaping every single<br>&gt;&gt; slashes. Which is really handy to make thing easier to read.<br>&gt;&gt;<br>&gt;&gt; Also, putting aside that I think \(scheme) should not be interpreted in<br>&gt;&gt; the example, with a syntax allowing such interpretation the variable should<br>&gt;&gt; be processed to generate proper escaping. If one is to use \(filename) you<br>&gt;&gt; get &quot;main.c&quot;, but one must use \(filename.escaped()) to get the proper<br>&gt;&gt; &quot;main\.c&quot; to avoid matching &quot;mainac&quot;. The String.escaped() must be in a<br>&gt;&gt; format compatible with the format used when converting the regular<br>&gt;&gt; expression into NSRegularExpression (not sure if the two syntax are the<br>&gt;&gt; same; I think that at least the handling of /  may differ)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I agree. Perhaps I went too far with keeping the proposal<br>&gt;&gt; short-and-sweet. Especially when you consider the rich syntax that Perl<br>&gt;&gt; supports for substitution.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; 2. Easily create a String without escaping (\n is not linefeed, but \ and<br>&gt;&gt; n)<br>&gt;&gt;<br>&gt;&gt; The ability to not interpret the backslash as escape can be useful in<br>&gt;&gt; other scenario that creating a NSRegularExpression; like creating a Windows<br>&gt;&gt; pathname, or creating regular expression which are then given to external<br>&gt;&gt; tool.  So this part of the proposal should probably be generalized.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Generalize it for what? If you&#39;re thinking along the line of raw strings,<br>&gt;&gt; I agree that we need this capability, as well as multi-line string<br>&gt;&gt; literals. However, I just soon we have separate proposals for this.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; My point/opinion here, is that a regular expressions are just a String<br>&gt;&gt; which are then interpreted; the same way as &quot;Good Morning&quot;, &quot;Bonjour&quot;, or<br>&gt;&gt; &quot;Marhaba&quot; (even when using the arabic script) are just String when you<br>&gt;&gt; assign then to a variable in Swift, and then interpreted by the intended<br>&gt;&gt; user. They are not String, frenchString, rigthToLeftString. So I do not see<br>&gt;&gt; why a regular expression should have privileged treatment and have its own<br>&gt;&gt; language level syntax. The only difference when writing regular expression,<br>&gt;&gt; or Windows pathname, or any String with a syntax with heavily uses of<br>&gt;&gt; backslashes, is that one may want to disable the special meaning of the<br>&gt;&gt; backslashes, to make thing more readable.<br>&gt;&gt;<br>&gt;&gt; On the page of geeky-ing the String there’s four main part IMHO<br>&gt;&gt; - multi-line support<br>&gt;&gt; - no backslash escaping version (which should include no processing the<br>&gt;&gt; \(variable) format)<br>&gt;&gt; - inclusion of String delimiter inside the String<br>&gt;&gt; - concat of backslash/no backslash version. Bash example echo &#39;echo<br>&gt;&gt; &quot;$BASH&quot; shows &#39;&quot;$BASH&quot;<br>&gt;&gt;<br>&gt;&gt; I’m still trying to find back the mail thread crumbs on these topics,<br>&gt;&gt; since before restarting the discussion in these topics, the previous one<br>&gt;&gt; should be properly summarized; unless such summary already exist.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I think supporting interpolation is important. Both Perl and Ruby support<br>&gt;&gt; it, and I&#39;m sure there are other languages. One thing I forgot to put into<br>&gt;&gt; the proposal: an option to disable interpolation or limit it to single pass.<br>&gt;&gt;<br>&gt;&gt; Looking ahead at the other responses, Chris Lattner has suggested that<br>&gt;&gt; the proposal would have more traction if we can find a way to fold this<br>&gt;&gt; into Swift&#39;s pattern matching. I can&#39;t say as I disagree, as this makes<br>&gt;&gt; regular expression more Swifty.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Regards,<br>&gt;&gt; Dany<br>&gt;&gt;<br>&gt;&gt; Dany<br>&gt;&gt;<br>&gt;&gt; Le 31 janv. 2016 à 12:18, Patrick Gili via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;<br>&gt;&gt; Here is the link to the proposal on GitHub:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; https://github.com/gili-patrick-r/swift-evolution/blob/master/proposals/NNNN-regular-expression-literals.md<br>&gt;&gt;<br>&gt;&gt; Cheers,<br>&gt;&gt; -Patrick<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/a63acc8a/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Empower String type with regular expression</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>February  2, 2016 at 06:00:00am</p></header><div class="content"><p>Something like Scala&#39;s extractors or F#&#39;s Active Patterns would be most welcome to generalize pattern matching.<br></p><p>http://docs.scala-lang.org/tutorials/tour/extractor-objects.html<br>https://en.m.wikibooks.org/wiki/F_Sharp_Programming/Active_Patterns<br></p><p>-Thorsten <br></p><p>&gt; Am 01.02.2016 um 15:46 schrieb James Campbell via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; It would be great if we could create a generic way of making this swifty. You may let say want to implement a matching system for structure like JSON or XML (i.e XQuery).<br>&gt; <br>&gt; <br>&gt; <br>&gt; ___________________________________<br>&gt; <br>&gt; James⎥Lead Engineer<br>&gt; <br>&gt; james at supmenow.com⎥supmenow.com<br>&gt; <br>&gt; Sup<br>&gt; <br>&gt; Runway East &gt; <br>&gt; <br>&gt; 10 Finsbury Square<br>&gt; <br>&gt; London<br>&gt; <br>&gt;  &gt; EC2A 1AF <br>&gt; <br>&gt; <br>&gt;&gt; On Mon, Feb 1, 2016 at 2:43 PM, Patrick Gili via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Hi Dany,<br>&gt;&gt; <br>&gt;&gt; My response is inline below.<br>&gt;&gt; <br>&gt;&gt; Cheers,<br>&gt;&gt; -Patrick<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 31, 2016, at 8:56 PM, Dany St-Amant &lt;dsa.mls at icloud.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Le 31 janv. 2016 à 16:46, Patrick Gili &lt;gili.patrick.r at gili-labs.com&gt; a écrit :<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi Dany,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Please find my response inline below.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt; -Patrick<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 31, 2016, at 3:46 PM, Dany St-Amant via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This seem to be two proposals in one:<br>&gt;&gt;&gt;&gt;&gt; 1. Initialize NSRegularExpression with a single String which includes options<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The ultimate goal based on the earlier mail in the thread seems to be able in a future proposal do thing like: string ~= replacePattern, if string =~ pattern, decoupled from the legacy Obj-C. Isn’t NSRegularExpression part of the legacy? The conversion of the literal string as regular expression should probably part of the proposal for these operators; as this is the time we will know how we want the text to be interpreted.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don&#39;t see any evidence of NSRegularExpression becoming part of any legacy. Given SE-005, SE-006, and SE-023, the name is probably changing from NSRegularExpression to RegularExpression. However, I don&#39;t think the definition of the class will change, only the name.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I would like to see an operator regular expression matching operator, like Ruby and Perl. I was trying to keep the proposal a minimal increment that would buy the biggest bang for the buck. We can already accomplish much of what other languages can do with regard to regular expression. However, the notion of a regular expression isn&#39;t something we can work around with custom library today. Can you suggest something addition that should be in the proposal?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Splitting proposal in smaller ones have its advantage, but here I am just wondering if we are sure that these future operation will use the NSRegularExpression/RegularExpression. And does the currently selected syntax allow for future expansion, it would be bad to introduce something  that need to be torn away or changed in an incompatible way, once we really start to use them in their final location.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The proposal is focused on the search, but seem to skip the substitution; I am unable to see an option to replace all matches instead of the first one only in the proposal. I, as many other, would expect regular expression in a language to also support substitution.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As for addition to the proposal, the processing of the string could be support for any character (within some limit) for the slash delimiter. With sed, when replacing  path component, one can do: echo $PWD | sed -e &quot;s:^/usr/local/bin:/opt/share/bin:g&quot;, instead of escaping every single slashes. Which is really handy to make thing easier to read.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Also, putting aside that I think \(scheme) should not be interpreted in the example, with a syntax allowing such interpretation the variable should be processed to generate proper escaping. If one is to use \(filename) you get &quot;main.c&quot;, but one must use \(filename.escaped()) to get the proper &quot;main\.c&quot; to avoid matching &quot;mainac&quot;. The String.escaped() must be in a format compatible with the format used when converting the regular expression into NSRegularExpression (not sure if the two syntax are the same; I think that at least the handling of /  may differ)<br>&gt;&gt; <br>&gt;&gt; I agree. Perhaps I went too far with keeping the proposal short-and-sweet. Especially when you consider the rich syntax that Perl supports for substitution.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2. Easily create a String without escaping (\n is not linefeed, but \ and n)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The ability to not interpret the backslash as escape can be useful in other scenario that creating a NSRegularExpression; like creating a Windows pathname, or creating regular expression which are then given to external tool.  So this part of the proposal should probably be generalized.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Generalize it for what? If you&#39;re thinking along the line of raw strings, I agree that we need this capability, as well as multi-line string literals. However, I just soon we have separate proposals for this.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My point/opinion here, is that a regular expressions are just a String which are then interpreted; the same way as &quot;Good Morning&quot;, &quot;Bonjour&quot;, or &quot;Marhaba&quot; (even when using the arabic script) are just String when you assign then to a variable in Swift, and then interpreted by the intended user. They are not String, frenchString, rigthToLeftString. So I do not see why a regular expression should have privileged treatment and have its own language level syntax. The only difference when writing regular expression, or Windows pathname, or any String with a syntax with heavily uses of backslashes, is that one may want to disable the special meaning of the backslashes, to make thing more readable.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On the page of geeky-ing the String there’s four main part IMHO<br>&gt;&gt;&gt; - multi-line support<br>&gt;&gt;&gt; - no backslash escaping version (which should include no processing the \(variable) format)<br>&gt;&gt;&gt; - inclusion of String delimiter inside the String<br>&gt;&gt;&gt; - concat of backslash/no backslash version. Bash example echo &#39;echo &quot;$BASH&quot; shows &#39;&quot;$BASH&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m still trying to find back the mail thread crumbs on these topics, since before restarting the discussion in these topics, the previous one should be properly summarized; unless such summary already exist.<br>&gt;&gt; <br>&gt;&gt; I think supporting interpolation is important. Both Perl and Ruby support it, and I&#39;m sure there are other languages. One thing I forgot to put into the proposal: an option to disable interpolation or limit it to single pass.<br>&gt;&gt; <br>&gt;&gt; Looking ahead at the other responses, Chris Lattner has suggested that the proposal would have more traction if we can find a way to fold this into Swift&#39;s pattern matching. I can&#39;t say as I disagree, as this makes regular expression more Swifty.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Regards,<br>&gt;&gt;&gt; Dany<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Dany<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Le 31 janv. 2016 à 12:18, Patrick Gili via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Here is the link to the proposal on GitHub:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; https://github.com/gili-patrick-r/swift-evolution/blob/master/proposals/NNNN-regular-expression-literals.md<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt;&gt;&gt; -Patrick<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160202/0c3678ed/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Empower String type with regular expression</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>February  2, 2016 at 05:00:00pm</p></header><div class="content"><p>Others have suggested a programatic regex instead of a regex literal, how<br>about doing both? Something like:<br></p><p>enum RegexElement {<br></p><p>    case capture(name: String, value: String)<br></p><p>    case special(Special)<br></p><p>    // ...<br></p><p>    enum Special: String {<br></p><p>        case startOfLine = &quot;^&quot;<br></p><p>        // ...<br></p><p>        case endOfLine = &quot;$&quot;<br></p><p>    }<br></p><p>}<br></p><p><br>// Define a regexLiteral syntax that the compiler understands that is of<br>type Regex and consists of String representations of RegexElements, e.g.<br>using forward slash:<br></p><p>//    /&lt;RegexElements&gt;*/<br></p><p><br>struct Regex: CustomStringConvertible { // Compiled, immutable, thread<br>safe, and bridged to NSRegularExpression<br></p><p>    // ... internal compiled representation<br></p><p>    let elements: [RegexElement]<br></p><p>    var description: String {<br></p><p>        return RegexElement.Special.startOfLine.rawValue // Example. Really<br>returns all the elements converted back to a string<br></p><p>    }<br></p><p>    init(_ elements: RegexElement...) {<br></p><p>        self.elements = elements // Example. Really also compiles the<br>expression<br></p><p>    }<br></p><p>    // init(regexLiteral regex: Regex) {<br></p><p>    // init(concatAll regexes: Regex...) {<br></p><p>    // init(fromString string: String) {<br></p><p>    // ... more inits<br></p><p>    func map&lt;T&gt;(input: String, @noescape mapper: (element: RegexElement)<br>throws -&gt; T) rethrows -&gt; [T] {<br></p><p>        return [try mapper(element: RegexElement.special(.startOfLine))] //<br>Example. Really does the matching<br></p><p>    }<br></p><p>    // func flatMap&lt;T&gt;(input: String, @noescape mapper: (element:<br>RegexElement) throws -&gt; T?) rethrows -&gt; [T] {<br></p><p>    // func flatMap&lt;S: SequenceType&gt;(input: String, @noescape mapper:<br>(element: RegexElement) throws -&gt; S) rethrows -&gt; [S.Generator.Element] {<br></p><p>    // func forEach(input: String, @noescape eacher: (element:<br>RegexElement) throws -&gt; Void) rethrows {<br></p><p>    // ... more funcs<br></p><p>}<br></p><p><br>let regex = Regex(RegexElement.special(.startOfLine)) // Normally a regex<br>literal<br></p><p>let asStringArray = regex.map(&quot;Example&quot;) { element -&gt; String in // Returns<br>`[&quot;^&quot;]` in example<br></p><p>    switch element {<br></p><p>    case let .capture(_, v): return v<br></p><p>    case let .special(s): return s.rawValue<br></p><p>    }<br></p><p>}<br></p><p><br>The advantages are:<br></p><p>   1.   We get a literal type for convenience.<br>   2.   We get a programatic type when we need to manipulate regexes.<br>   3.   Breaking the regex matches into the enum defined elements of the<br>   regex works well with Swift pattern matching.<br></p><p>(Above is a very rough sketch!)<br></p><p><br>On 2 February 2016 at 16:44, Thorsten Seitz via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Something like Scala&#39;s extractors or F#&#39;s Active Patterns would be most<br>&gt; welcome to generalize pattern matching.<br>&gt;<br>&gt; http://docs.scala-lang.org/tutorials/tour/extractor-objects.html<br>&gt; https://en.m.wikibooks.org/wiki/F_Sharp_Programming/Active_Patterns<br>&gt;<br>&gt; -Thorsten<br>&gt;<br>&gt; Am 01.02.2016 um 15:46 schrieb James Campbell via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt;<br>&gt; It would be great if we could create a generic way of making this swifty.<br>&gt; You may let say want to implement a matching system for structure like JSON<br>&gt; or XML (i.e XQuery).<br>&gt;<br>&gt;<br>&gt;<br>&gt; *___________________________________*<br>&gt;<br>&gt; *James⎥Lead Engineer*<br>&gt;<br>&gt; *james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com<br>&gt; &lt;http://supmenow.com&gt;*<br>&gt;<br>&gt; *Sup*<br>&gt;<br>&gt; *Runway East *<br>&gt;<br>&gt; *10 Finsbury Square*<br>&gt;<br>&gt; *London*<br>&gt;<br>&gt; * EC2A 1AF *<br>&gt;<br>&gt; On Mon, Feb 1, 2016 at 2:43 PM, Patrick Gili via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Hi Dany,<br>&gt;&gt;<br>&gt;&gt; My response is inline below.<br>&gt;&gt;<br>&gt;&gt; Cheers,<br>&gt;&gt; -Patrick<br>&gt;&gt;<br>&gt;&gt; On Jan 31, 2016, at 8:56 PM, Dany St-Amant &lt;dsa.mls at icloud.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Le 31 janv. 2016 à 16:46, Patrick Gili &lt;gili.patrick.r at gili-labs.com&gt; a<br>&gt;&gt; écrit :<br>&gt;&gt;<br>&gt;&gt; Hi Dany,<br>&gt;&gt;<br>&gt;&gt; Please find my response inline below.<br>&gt;&gt;<br>&gt;&gt; Cheers,<br>&gt;&gt; -Patrick<br>&gt;&gt;<br>&gt;&gt; On Jan 31, 2016, at 3:46 PM, Dany St-Amant via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; This seem to be two proposals in one:<br>&gt;&gt; 1. Initialize NSRegularExpression with a single String which includes<br>&gt;&gt; options<br>&gt;&gt;<br>&gt;&gt; The ultimate goal based on the earlier mail in the thread seems to be<br>&gt;&gt; able in a future proposal do thing like: string ~= replacePattern, if<br>&gt;&gt; string =~ pattern, decoupled from the legacy Obj-C. Isn’t<br>&gt;&gt; NSRegularExpression part of the legacy? The conversion of the literal<br>&gt;&gt; string as regular expression should probably part of the proposal for these<br>&gt;&gt; operators; as this is the time we will know how we want the text to be<br>&gt;&gt; interpreted.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I don&#39;t see any evidence of NSRegularExpression becoming part of any<br>&gt;&gt; legacy. Given SE-005, SE-006, and SE-023, the name is probably changing<br>&gt;&gt; from NSRegularExpression to RegularExpression. However, I don&#39;t think the<br>&gt;&gt; definition of the class will change, only the name.<br>&gt;&gt;<br>&gt;&gt; I would like to see an operator regular expression matching operator,<br>&gt;&gt; like Ruby and Perl. I was trying to keep the proposal a minimal increment<br>&gt;&gt; that would buy the biggest bang for the buck. We can already accomplish<br>&gt;&gt; much of what other languages can do with regard to regular expression.<br>&gt;&gt; However, the notion of a regular expression isn&#39;t something we can work<br>&gt;&gt; around with custom library today. Can you suggest something addition that<br>&gt;&gt; should be in the proposal?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Splitting proposal in smaller ones have its advantage, but here I am just<br>&gt;&gt; wondering if we are sure that these future operation will use the<br>&gt;&gt; NSRegularExpression/RegularExpression. And does the currently selected<br>&gt;&gt; syntax allow for future expansion, it would be bad to introduce something<br>&gt;&gt;  that need to be torn away or changed in an incompatible way, once we<br>&gt;&gt; really start to use them in their final location.<br>&gt;&gt;<br>&gt;&gt; The proposal is focused on the search, but seem to skip the substitution;<br>&gt;&gt; I am unable to see an option to replace all matches instead of the first<br>&gt;&gt; one only in the proposal. I, as many other, would expect regular expression<br>&gt;&gt; in a language to also support substitution.<br>&gt;&gt;<br>&gt;&gt; As for addition to the proposal, the processing of the string could be<br>&gt;&gt; support for any character (within some limit) for the slash delimiter. With<br>&gt;&gt; sed, when replacing  path component, one can do: echo $PWD | sed -e<br>&gt;&gt; &quot;s:^/usr/local/bin:/opt/share/bin:g&quot;, instead of escaping every single<br>&gt;&gt; slashes. Which is really handy to make thing easier to read.<br>&gt;&gt;<br>&gt;&gt; Also, putting aside that I think \(scheme) should not be interpreted in<br>&gt;&gt; the example, with a syntax allowing such interpretation the variable should<br>&gt;&gt; be processed to generate proper escaping. If one is to use \(filename) you<br>&gt;&gt; get &quot;main.c&quot;, but one must use \(filename.escaped()) to get the proper<br>&gt;&gt; &quot;main\.c&quot; to avoid matching &quot;mainac&quot;. The String.escaped() must be in a<br>&gt;&gt; format compatible with the format used when converting the regular<br>&gt;&gt; expression into NSRegularExpression (not sure if the two syntax are the<br>&gt;&gt; same; I think that at least the handling of /  may differ)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I agree. Perhaps I went too far with keeping the proposal<br>&gt;&gt; short-and-sweet. Especially when you consider the rich syntax that Perl<br>&gt;&gt; supports for substitution.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; 2. Easily create a String without escaping (\n is not linefeed, but \ and<br>&gt;&gt; n)<br>&gt;&gt;<br>&gt;&gt; The ability to not interpret the backslash as escape can be useful in<br>&gt;&gt; other scenario that creating a NSRegularExpression; like creating a Windows<br>&gt;&gt; pathname, or creating regular expression which are then given to external<br>&gt;&gt; tool.  So this part of the proposal should probably be generalized.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Generalize it for what? If you&#39;re thinking along the line of raw strings,<br>&gt;&gt; I agree that we need this capability, as well as multi-line string<br>&gt;&gt; literals. However, I just soon we have separate proposals for this.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; My point/opinion here, is that a regular expressions are just a String<br>&gt;&gt; which are then interpreted; the same way as &quot;Good Morning&quot;, &quot;Bonjour&quot;, or<br>&gt;&gt; &quot;Marhaba&quot; (even when using the arabic script) are just String when you<br>&gt;&gt; assign then to a variable in Swift, and then interpreted by the intended<br>&gt;&gt; user. They are not String, frenchString, rigthToLeftString. So I do not see<br>&gt;&gt; why a regular expression should have privileged treatment and have its own<br>&gt;&gt; language level syntax. The only difference when writing regular expression,<br>&gt;&gt; or Windows pathname, or any String with a syntax with heavily uses of<br>&gt;&gt; backslashes, is that one may want to disable the special meaning of the<br>&gt;&gt; backslashes, to make thing more readable.<br>&gt;&gt;<br>&gt;&gt; On the page of geeky-ing the String there’s four main part IMHO<br>&gt;&gt; - multi-line support<br>&gt;&gt; - no backslash escaping version (which should include no processing the<br>&gt;&gt; \(variable) format)<br>&gt;&gt; - inclusion of String delimiter inside the String<br>&gt;&gt; - concat of backslash/no backslash version. Bash example echo &#39;echo<br>&gt;&gt; &quot;$BASH&quot; shows &#39;&quot;$BASH&quot;<br>&gt;&gt;<br>&gt;&gt; I’m still trying to find back the mail thread crumbs on these topics,<br>&gt;&gt; since before restarting the discussion in these topics, the previous one<br>&gt;&gt; should be properly summarized; unless such summary already exist.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I think supporting interpolation is important. Both Perl and Ruby support<br>&gt;&gt; it, and I&#39;m sure there are other languages. One thing I forgot to put into<br>&gt;&gt; the proposal: an option to disable interpolation or limit it to single pass.<br>&gt;&gt;<br>&gt;&gt; Looking ahead at the other responses, Chris Lattner has suggested that<br>&gt;&gt; the proposal would have more traction if we can find a way to fold this<br>&gt;&gt; into Swift&#39;s pattern matching. I can&#39;t say as I disagree, as this makes<br>&gt;&gt; regular expression more Swifty.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Regards,<br>&gt;&gt; Dany<br>&gt;&gt;<br>&gt;&gt; Dany<br>&gt;&gt;<br>&gt;&gt; Le 31 janv. 2016 à 12:18, Patrick Gili via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;<br>&gt;&gt; Here is the link to the proposal on GitHub:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; https://github.com/gili-patrick-r/swift-evolution/blob/master/proposals/NNNN-regular-expression-literals.md<br>&gt;&gt;<br>&gt;&gt; Cheers,<br>&gt;&gt; -Patrick<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p><p><br>-- <br>  -- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160202/a6aa6f1e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05e222e6ef4d84013bb3baeb0e25c90b?s=50"></div><header><strong>Empower String type with regular expression</strong> from <string>Patrick Gili</string> &lt;gili.patrick.r at gili-labs.com&gt;<p>February  2, 2016 at 07:00:00am</p></header><div class="content"><p>Hi Howard,<br></p><p>I don&#39;t see how this is very different from the Swift Verbal Expressions. It would suffer from the same disadvantages I have stated previously.<br></p><p>Cheers,<br>-Patrick<br></p><p>&gt; On Feb 2, 2016, at 1:51 AM, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Others have suggested a programatic regex instead of a regex literal, how about doing both? Something like:<br>&gt; <br>&gt; enum RegexElement {<br>&gt;     case capture(name: String, value: String)<br>&gt;     case special(Special)<br>&gt;     // ...<br>&gt;     enum Special: String {<br>&gt;         case startOfLine = &quot;^&quot;<br>&gt;         // ...<br>&gt;         case endOfLine = &quot;$&quot;<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; // Define a regexLiteral syntax that the compiler understands that is of type Regex and consists of String representations of RegexElements, e.g. using forward slash:<br>&gt; //    /&lt;RegexElements&gt;*/<br>&gt; <br>&gt; struct Regex: CustomStringConvertible { // Compiled, immutable, thread safe, and bridged to NSRegularExpression<br>&gt;     // ... internal compiled representation<br>&gt;     let elements: [RegexElement]<br>&gt;     var description: String {<br>&gt;         return RegexElement.Special.startOfLine.rawValue // Example. Really returns all the elements converted back to a string<br>&gt;     }<br>&gt;     init(_ elements: RegexElement...) {<br>&gt;         self.elements = elements // Example. Really also compiles the expression<br>&gt;     }<br>&gt;     // init(regexLiteral regex: Regex) {<br>&gt;     // init(concatAll regexes: Regex...) {<br>&gt;     // init(fromString string: String) {<br>&gt;     // ... more inits<br>&gt;     func map&lt;T&gt;(input: String, @noescape mapper: (element: RegexElement) throws -&gt; T) rethrows -&gt; [T] {<br>&gt;         return [try mapper(element: RegexElement.special(.startOfLine))] // Example. Really does the matching<br>&gt;     }<br>&gt;     // func flatMap&lt;T&gt;(input: String, @noescape mapper: (element: RegexElement) throws -&gt; T?) rethrows -&gt; [T] {<br>&gt;     // func flatMap&lt;S: SequenceType&gt;(input: String, @noescape mapper: (element: RegexElement) throws -&gt; S) rethrows -&gt; [S.Generator.Element] {<br>&gt;     // func forEach(input: String, @noescape eacher: (element: RegexElement) throws -&gt; Void) rethrows {<br>&gt;     // ... more funcs<br>&gt; }<br>&gt; <br>&gt; let regex = Regex(RegexElement.special(.startOfLine)) // Normally a regex literal<br>&gt; let asStringArray = regex.map(&quot;Example&quot;) { element -&gt; String in // Returns `[&quot;^&quot;]` in example<br>&gt;     switch element {<br>&gt;     case let .capture(_, v): return v<br>&gt;     case let .special(s): return s.rawValue<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; The advantages are:<br>&gt;   We get a literal type for convenience.<br>&gt;   We get a programatic type when we need to manipulate regexes.<br>&gt;   Breaking the regex matches into the enum defined elements of the regex works well with Swift pattern matching.<br>&gt; (Above is a very rough sketch!)<br>&gt; <br>&gt; <br>&gt; On 2 February 2016 at 16:44, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Something like Scala&#39;s extractors or F#&#39;s Active Patterns would be most welcome to generalize pattern matching.<br>&gt; <br>&gt; http://docs.scala-lang.org/tutorials/tour/extractor-objects.html &lt;http://docs.scala-lang.org/tutorials/tour/extractor-objects.html&gt;<br>&gt; https://en.m.wikibooks.org/wiki/F_Sharp_Programming/Active_Patterns &lt;https://en.m.wikibooks.org/wiki/F_Sharp_Programming/Active_Patterns&gt;<br>&gt; <br>&gt; -Thorsten <br>&gt; <br>&gt; Am 01.02.2016 um 15:46 schrieb James Campbell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; <br>&gt;&gt; It would be great if we could create a generic way of making this swifty. You may let say want to implement a matching system for structure like JSON or XML (i.e XQuery).<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; ___________________________________<br>&gt;&gt; <br>&gt;&gt; James⎥Lead Engineer<br>&gt;&gt; <br>&gt;&gt; james at supmenow.com &lt;mailto:james at supmenow.com&gt;⎥supmenow.com &lt;http://supmenow.com/&gt;<br>&gt;&gt; Sup<br>&gt;&gt; <br>&gt;&gt; Runway East &gt;&gt; <br>&gt;&gt; <br>&gt;&gt; 10 Finsbury Square<br>&gt;&gt; <br>&gt;&gt; London<br>&gt;&gt; <br>&gt;&gt;  &gt;&gt; EC2A 1AF <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Mon, Feb 1, 2016 at 2:43 PM, Patrick Gili via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Hi Dany,<br>&gt;&gt; <br>&gt;&gt; My response is inline below.<br>&gt;&gt; <br>&gt;&gt; Cheers,<br>&gt;&gt; -Patrick<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 31, 2016, at 8:56 PM, Dany St-Amant &lt;dsa.mls at icloud.com &lt;mailto:dsa.mls at icloud.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Le 31 janv. 2016 à 16:46, Patrick Gili &lt;gili.patrick.r at gili-labs.com &lt;mailto:gili.patrick.r at gili-labs.com&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi Dany,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Please find my response inline below.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt; -Patrick<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 31, 2016, at 3:46 PM, Dany St-Amant via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This seem to be two proposals in one:<br>&gt;&gt;&gt;&gt;&gt; 1. Initialize NSRegularExpression with a single String which includes options<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The ultimate goal based on the earlier mail in the thread seems to be able in a future proposal do thing like: string ~= replacePattern, if string =~ pattern, decoupled from the legacy Obj-C. Isn’t NSRegularExpression part of the legacy? The conversion of the literal string as regular expression should probably part of the proposal for these operators; as this is the time we will know how we want the text to be interpreted.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don&#39;t see any evidence of NSRegularExpression becoming part of any legacy. Given SE-005, SE-006, and SE-023, the name is probably changing from NSRegularExpression to RegularExpression. However, I don&#39;t think the definition of the class will change, only the name.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I would like to see an operator regular expression matching operator, like Ruby and Perl. I was trying to keep the proposal a minimal increment that would buy the biggest bang for the buck. We can already accomplish much of what other languages can do with regard to regular expression. However, the notion of a regular expression isn&#39;t something we can work around with custom library today. Can you suggest something addition that should be in the proposal?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Splitting proposal in smaller ones have its advantage, but here I am just wondering if we are sure that these future operation will use the NSRegularExpression/RegularExpression. And does the currently selected syntax allow for future expansion, it would be bad to introduce something  that need to be torn away or changed in an incompatible way, once we really start to use them in their final location.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The proposal is focused on the search, but seem to skip the substitution; I am unable to see an option to replace all matches instead of the first one only in the proposal. I, as many other, would expect regular expression in a language to also support substitution.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As for addition to the proposal, the processing of the string could be support for any character (within some limit) for the slash delimiter. With sed, when replacing  path component, one can do: echo $PWD | sed -e &quot;s:^/usr/local/bin:/opt/share/bin:g&quot;, instead of escaping every single slashes. Which is really handy to make thing easier to read.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Also, putting aside that I think \(scheme) should not be interpreted in the example, with a syntax allowing such interpretation the variable should be processed to generate proper escaping. If one is to use \(filename) you get &quot;main.c&quot;, but one must use \(filename.escaped()) to get the proper &quot;main\.c&quot; to avoid matching &quot;mainac&quot;. The String.escaped() must be in a format compatible with the format used when converting the regular expression into NSRegularExpression (not sure if the two syntax are the same; I think that at least the handling of /  may differ)<br>&gt;&gt; <br>&gt;&gt; I agree. Perhaps I went too far with keeping the proposal short-and-sweet. Especially when you consider the rich syntax that Perl supports for substitution.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2. Easily create a String without escaping (\n is not linefeed, but \ and n)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The ability to not interpret the backslash as escape can be useful in other scenario that creating a NSRegularExpression; like creating a Windows pathname, or creating regular expression which are then given to external tool.  So this part of the proposal should probably be generalized.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Generalize it for what? If you&#39;re thinking along the line of raw strings, I agree that we need this capability, as well as multi-line string literals. However, I just soon we have separate proposals for this.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My point/opinion here, is that a regular expressions are just a String which are then interpreted; the same way as &quot;Good Morning&quot;, &quot;Bonjour&quot;, or &quot;Marhaba&quot; (even when using the arabic script) are just String when you assign then to a variable in Swift, and then interpreted by the intended user. They are not String, frenchString, rigthToLeftString. So I do not see why a regular expression should have privileged treatment and have its own language level syntax. The only difference when writing regular expression, or Windows pathname, or any String with a syntax with heavily uses of backslashes, is that one may want to disable the special meaning of the backslashes, to make thing more readable.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On the page of geeky-ing the String there’s four main part IMHO<br>&gt;&gt;&gt; - multi-line support<br>&gt;&gt;&gt; - no backslash escaping version (which should include no processing the \(variable) format)<br>&gt;&gt;&gt; - inclusion of String delimiter inside the String<br>&gt;&gt;&gt; - concat of backslash/no backslash version. Bash example echo &#39;echo &quot;$BASH&quot; shows &#39;&quot;$BASH&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m still trying to find back the mail thread crumbs on these topics, since before restarting the discussion in these topics, the previous one should be properly summarized; unless such summary already exist.<br>&gt;&gt; <br>&gt;&gt; I think supporting interpolation is important. Both Perl and Ruby support it, and I&#39;m sure there are other languages. One thing I forgot to put into the proposal: an option to disable interpolation or limit it to single pass.<br>&gt;&gt; <br>&gt;&gt; Looking ahead at the other responses, Chris Lattner has suggested that the proposal would have more traction if we can find a way to fold this into Swift&#39;s pattern matching. I can&#39;t say as I disagree, as this makes regular expression more Swifty.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Regards,<br>&gt;&gt;&gt; Dany<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Dany<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Le 31 janv. 2016 à 12:18, Patrick Gili via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Here is the link to the proposal on GitHub:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; https://github.com/gili-patrick-r/swift-evolution/blob/master/proposals/NNNN-regular-expression-literals.md &lt;https://github.com/gili-patrick-r/swift-evolution/blob/master/proposals/NNNN-regular-expression-literals.md&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt;&gt;&gt; -Patrick<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt;   -- Howard.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160202/86a1014b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Empower String type with regular expression</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>February  3, 2016 at 09:00:00am</p></header><div class="content"><p>The difference is that I am proposing supporting both verbal expressions<br>and regex literals and that - literals are converted to verbals and the<br>processing happens at the verbal level. The reason for this is that verbals<br>are easy to handle programmatically whilst literals are great for quickly<br>specifying a regex.<br></p><p>On Tuesday, 2 February 2016, Patrick Gili &lt;gili.patrick.r at gili-labs.com&gt;<br>wrote:<br></p><p>&gt; Hi Howard,<br>&gt;<br>&gt; I don&#39;t see how this is very different from the Swift Verbal Expressions.<br>&gt; It would suffer from the same disadvantages I have stated previously.<br>&gt;<br>&gt; Cheers,<br>&gt; -Patrick<br>&gt;<br>&gt; On Feb 2, 2016, at 1:51 AM, Howard Lovatt via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt; Others have suggested a programatic regex instead of a regex literal, how<br>&gt; about doing both? Something like:<br>&gt;<br>&gt; enum RegexElement {<br>&gt;     case capture(name: String, value: String)<br>&gt;     case special(Special)<br>&gt;     // ...<br>&gt;     enum Special: String {<br>&gt;         case startOfLine = &quot;^&quot;<br>&gt;         // ...<br>&gt;         case endOfLine = &quot;$&quot;<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; // Define a regexLiteral syntax that the compiler understands that is of<br>&gt; type Regex and consists of String representations of RegexElements, e.g.<br>&gt; using forward slash:<br>&gt; //    /&lt;RegexElements&gt;*/<br>&gt;<br>&gt; struct Regex: CustomStringConvertible { // Compiled, immutable, thread<br>&gt; safe, and bridged to NSRegularExpression<br>&gt;     // ... internal compiled representation<br>&gt;     let elements: [RegexElement]<br>&gt;     var description: String {<br>&gt;         return RegexElement.Special.startOfLine.rawValue // Example.<br>&gt; Really returns all the elements converted back to a string<br>&gt;     }<br>&gt;     init(_ elements: RegexElement...) {<br>&gt;         self.elements = elements // Example. Really also compiles the<br>&gt; expression<br>&gt;     }<br>&gt;     // init(regexLiteral regex: Regex) {<br>&gt;     // init(concatAll regexes: Regex...) {<br>&gt;     // init(fromString string: String) {<br>&gt;     // ... more inits<br>&gt;     func map&lt;T&gt;(input: String, @noescape mapper: (element: RegexElement)<br>&gt; throws -&gt; T) rethrows -&gt; [T] {<br>&gt;         return [try mapper(element: RegexElement.special(.startOfLine))] //<br>&gt; Example. Really does the matching<br>&gt;     }<br>&gt;     // func flatMap&lt;T&gt;(input: String, @noescape mapper: (element:<br>&gt; RegexElement) throws -&gt; T?) rethrows -&gt; [T] {<br>&gt;     // func flatMap&lt;S: SequenceType&gt;(input: String, @noescape mapper:<br>&gt; (element: RegexElement) throws -&gt; S) rethrows -&gt; [S.Generator.Element] {<br>&gt;     // func forEach(input: String, @noescape eacher: (element:<br>&gt; RegexElement) throws -&gt; Void) rethrows {<br>&gt;     // ... more funcs<br>&gt; }<br>&gt;<br>&gt; let regex = Regex(RegexElement.special(.startOfLine)) // Normally a regex<br>&gt; literal<br>&gt; let asStringArray = regex.map(&quot;Example&quot;) { element -&gt; String in //<br>&gt; Returns `[&quot;^&quot;]` in example<br>&gt;     switch element {<br>&gt;     case let .capture(_, v): return v<br>&gt;     case let .special(s): return s.rawValue<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; The advantages are:<br>&gt;<br>&gt;    1.   We get a literal type for convenience.<br>&gt;    2.   We get a programatic type when we need to manipulate regexes.<br>&gt;    3.   Breaking the regex matches into the enum defined elements of the<br>&gt;    regex works well with Swift pattern matching.<br>&gt;<br>&gt; (Above is a very rough sketch!)<br>&gt;<br>&gt;<br>&gt; On 2 February 2016 at 16:44, Thorsten Seitz via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt;&gt; Something like Scala&#39;s extractors or F#&#39;s Active Patterns would be most<br>&gt;&gt; welcome to generalize pattern matching.<br>&gt;&gt;<br>&gt;&gt; http://docs.scala-lang.org/tutorials/tour/extractor-objects.html<br>&gt;&gt; https://en.m.wikibooks.org/wiki/F_Sharp_Programming/Active_Patterns<br>&gt;&gt;<br>&gt;&gt; -Thorsten<br>&gt;&gt;<br>&gt;&gt; Am 01.02.2016 um 15:46 schrieb James Campbell via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt;:<br>&gt;&gt;<br>&gt;&gt; It would be great if we could create a generic way of making this swifty.<br>&gt;&gt; You may let say want to implement a matching system for structure like JSON<br>&gt;&gt; or XML (i.e XQuery).<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *___________________________________*<br>&gt;&gt;<br>&gt;&gt; *James⎥Lead Engineer*<br>&gt;&gt;<br>&gt;&gt; *james at supmenow.com<br>&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;james at supmenow.com&#39;);&gt;⎥supmenow.com<br>&gt;&gt; &lt;http://supmenow.com/&gt;*<br>&gt;&gt;<br>&gt;&gt; *Sup*<br>&gt;&gt;<br>&gt;&gt; *Runway East *<br>&gt;&gt;<br>&gt;&gt; *10 Finsbury Square*<br>&gt;&gt;<br>&gt;&gt; *London*<br>&gt;&gt;<br>&gt;&gt; * EC2A 1AF *<br>&gt;&gt;<br>&gt;&gt; On Mon, Feb 1, 2016 at 2:43 PM, Patrick Gili via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Hi Dany,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; My response is inline below.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt; -Patrick<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Jan 31, 2016, at 8:56 PM, Dany St-Amant &lt;dsa.mls at icloud.com<br>&gt;&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;dsa.mls at icloud.com&#39;);&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Le 31 janv. 2016 à 16:46, Patrick Gili &lt;gili.patrick.r at gili-labs.com<br>&gt;&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;gili.patrick.r at gili-labs.com&#39;);&gt;&gt; a écrit<br>&gt;&gt;&gt; :<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Hi Dany,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Please find my response inline below.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt; -Patrick<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Jan 31, 2016, at 3:46 PM, Dany St-Amant via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This seem to be two proposals in one:<br>&gt;&gt;&gt; 1. Initialize NSRegularExpression with a single String which includes<br>&gt;&gt;&gt; options<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The ultimate goal based on the earlier mail in the thread seems to be<br>&gt;&gt;&gt; able in a future proposal do thing like: string ~= replacePattern, if<br>&gt;&gt;&gt; string =~ pattern, decoupled from the legacy Obj-C. Isn’t<br>&gt;&gt;&gt; NSRegularExpression part of the legacy? The conversion of the literal<br>&gt;&gt;&gt; string as regular expression should probably part of the proposal for these<br>&gt;&gt;&gt; operators; as this is the time we will know how we want the text to be<br>&gt;&gt;&gt; interpreted.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I don&#39;t see any evidence of NSRegularExpression becoming part of any<br>&gt;&gt;&gt; legacy. Given SE-005, SE-006, and SE-023, the name is probably changing<br>&gt;&gt;&gt; from NSRegularExpression to RegularExpression. However, I don&#39;t think the<br>&gt;&gt;&gt; definition of the class will change, only the name.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I would like to see an operator regular expression matching operator,<br>&gt;&gt;&gt; like Ruby and Perl. I was trying to keep the proposal a minimal increment<br>&gt;&gt;&gt; that would buy the biggest bang for the buck. We can already accomplish<br>&gt;&gt;&gt; much of what other languages can do with regard to regular expression.<br>&gt;&gt;&gt; However, the notion of a regular expression isn&#39;t something we can work<br>&gt;&gt;&gt; around with custom library today. Can you suggest something addition that<br>&gt;&gt;&gt; should be in the proposal?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Splitting proposal in smaller ones have its advantage, but here I am<br>&gt;&gt;&gt; just wondering if we are sure that these future operation will use the<br>&gt;&gt;&gt; NSRegularExpression/RegularExpression. And does the currently selected<br>&gt;&gt;&gt; syntax allow for future expansion, it would be bad to introduce something<br>&gt;&gt;&gt;  that need to be torn away or changed in an incompatible way, once we<br>&gt;&gt;&gt; really start to use them in their final location.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The proposal is focused on the search, but seem to skip the<br>&gt;&gt;&gt; substitution; I am unable to see an option to replace all matches instead<br>&gt;&gt;&gt; of the first one only in the proposal. I, as many other, would expect<br>&gt;&gt;&gt; regular expression in a language to also support substitution.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; As for addition to the proposal, the processing of the string could be<br>&gt;&gt;&gt; support for any character (within some limit) for the slash delimiter. With<br>&gt;&gt;&gt; sed, when replacing  path component, one can do: echo $PWD | sed -e<br>&gt;&gt;&gt; &quot;s:^/usr/local/bin:/opt/share/bin:g&quot;, instead of escaping every single<br>&gt;&gt;&gt; slashes. Which is really handy to make thing easier to read.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Also, putting aside that I think \(scheme) should not be interpreted in<br>&gt;&gt;&gt; the example, with a syntax allowing such interpretation the variable should<br>&gt;&gt;&gt; be processed to generate proper escaping. If one is to use \(filename) you<br>&gt;&gt;&gt; get &quot;main.c&quot;, but one must use \(filename.escaped()) to get the proper<br>&gt;&gt;&gt; &quot;main\.c&quot; to avoid matching &quot;mainac&quot;. The String.escaped() must be in a<br>&gt;&gt;&gt; format compatible with the format used when converting the regular<br>&gt;&gt;&gt; expression into NSRegularExpression (not sure if the two syntax are the<br>&gt;&gt;&gt; same; I think that at least the handling of /  may differ)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I agree. Perhaps I went too far with keeping the proposal<br>&gt;&gt;&gt; short-and-sweet. Especially when you consider the rich syntax that Perl<br>&gt;&gt;&gt; supports for substitution.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 2. Easily create a String without escaping (\n is not linefeed, but \<br>&gt;&gt;&gt; and n)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The ability to not interpret the backslash as escape can be useful in<br>&gt;&gt;&gt; other scenario that creating a NSRegularExpression; like creating a Windows<br>&gt;&gt;&gt; pathname, or creating regular expression which are then given to external<br>&gt;&gt;&gt; tool.  So this part of the proposal should probably be generalized.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Generalize it for what? If you&#39;re thinking along the line of raw<br>&gt;&gt;&gt; strings, I agree that we need this capability, as well as multi-line string<br>&gt;&gt;&gt; literals. However, I just soon we have separate proposals for this.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; My point/opinion here, is that a regular expressions are just a String<br>&gt;&gt;&gt; which are then interpreted; the same way as &quot;Good Morning&quot;, &quot;Bonjour&quot;, or<br>&gt;&gt;&gt; &quot;Marhaba&quot; (even when using the arabic script) are just String when you<br>&gt;&gt;&gt; assign then to a variable in Swift, and then interpreted by the intended<br>&gt;&gt;&gt; user. They are not String, frenchString, rigthToLeftString. So I do not see<br>&gt;&gt;&gt; why a regular expression should have privileged treatment and have its own<br>&gt;&gt;&gt; language level syntax. The only difference when writing regular expression,<br>&gt;&gt;&gt; or Windows pathname, or any String with a syntax with heavily uses of<br>&gt;&gt;&gt; backslashes, is that one may want to disable the special meaning of the<br>&gt;&gt;&gt; backslashes, to make thing more readable.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On the page of geeky-ing the String there’s four main part IMHO<br>&gt;&gt;&gt; - multi-line support<br>&gt;&gt;&gt; - no backslash escaping version (which should include no processing the<br>&gt;&gt;&gt; \(variable) format)<br>&gt;&gt;&gt; - inclusion of String delimiter inside the String<br>&gt;&gt;&gt; - concat of backslash/no backslash version. Bash example echo &#39;echo<br>&gt;&gt;&gt; &quot;$BASH&quot; shows &#39;&quot;$BASH&quot;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I’m still trying to find back the mail thread crumbs on these topics,<br>&gt;&gt;&gt; since before restarting the discussion in these topics, the previous one<br>&gt;&gt;&gt; should be properly summarized; unless such summary already exist.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I think supporting interpolation is important. Both Perl and Ruby<br>&gt;&gt;&gt; support it, and I&#39;m sure there are other languages. One thing I forgot to<br>&gt;&gt;&gt; put into the proposal: an option to disable interpolation or limit it to<br>&gt;&gt;&gt; single pass.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Looking ahead at the other responses, Chris Lattner has suggested that<br>&gt;&gt;&gt; the proposal would have more traction if we can find a way to fold this<br>&gt;&gt;&gt; into Swift&#39;s pattern matching. I can&#39;t say as I disagree, as this makes<br>&gt;&gt;&gt; regular expression more Swifty.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Regards,<br>&gt;&gt;&gt; Dany<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Dany<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Le 31 janv. 2016 à 12:18, Patrick Gili via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; a écrit :<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Here is the link to the proposal on GitHub:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; https://github.com/gili-patrick-r/swift-evolution/blob/master/proposals/NNNN-regular-expression-literals.md<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt; -Patrick<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt;   -- Howard.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br></p><p>-- <br>  -- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/5d5c848e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05e222e6ef4d84013bb3baeb0e25c90b?s=50"></div><header><strong>Empower String type with regular expression</strong> from <string>Patrick Gili</string> &lt;gili.patrick.r at gili-labs.com&gt;<p>February  2, 2016 at 06:00:00pm</p></header><div class="content"><p>I don&#39;t feel good about this direction for the following reasons:<br>1) Complexity<br>2) Maturity? I don&#39;t know how Verbal Expressions has been implemented. Does it leverage mature regex open source? Or, has it been written from scratch?<br>3) Performance? Compiling a regex literal typically results in a FSM of a sort, optimized to parse strings. I wouldn&#39;t think that converting a regex literal to Verbal Expressions would yield great performance every time a match or substitution is done.<br></p><p>-Patrick<br></p><p>&gt; On Feb 2, 2016, at 5:55 PM, Howard Lovatt &lt;howard.lovatt at gmail.com&gt; wrote:<br>&gt; <br>&gt; The difference is that I am proposing supporting both verbal expressions and regex literals and that - literals are converted to verbals and the processing happens at the verbal level. The reason for this is that verbals are easy to handle programmatically whilst literals are great for quickly specifying a regex.<br>&gt; <br>&gt; On Tuesday, 2 February 2016, Patrick Gili &lt;gili.patrick.r at gili-labs.com &lt;mailto:gili.patrick.r at gili-labs.com&gt;&gt; wrote:<br>&gt; Hi Howard,<br>&gt; <br>&gt; I don&#39;t see how this is very different from the Swift Verbal Expressions. It would suffer from the same disadvantages I have stated previously.<br>&gt; <br>&gt; Cheers,<br>&gt; -Patrick<br>&gt; <br>&gt;&gt; On Feb 2, 2016, at 1:51 AM, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Others have suggested a programatic regex instead of a regex literal, how about doing both? Something like:<br>&gt;&gt; <br>&gt;&gt; enum RegexElement {<br>&gt;&gt;     case capture(name: String, value: String)<br>&gt;&gt;     case special(Special)<br>&gt;&gt;     // ...<br>&gt;&gt;     enum Special: String {<br>&gt;&gt;         case startOfLine = &quot;^&quot;<br>&gt;&gt;         // ...<br>&gt;&gt;         case endOfLine = &quot;$&quot;<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // Define a regexLiteral syntax that the compiler understands that is of type Regex and consists of String representations of RegexElements, e.g. using forward slash:<br>&gt;&gt; //    /&lt;RegexElements&gt;*/<br>&gt;&gt; <br>&gt;&gt; struct Regex: CustomStringConvertible { // Compiled, immutable, thread safe, and bridged to NSRegularExpression<br>&gt;&gt;     // ... internal compiled representation<br>&gt;&gt;     let elements: [RegexElement]<br>&gt;&gt;     var description: String {<br>&gt;&gt;         return RegexElement.Special.startOfLine.rawValue // Example. Really returns all the elements converted back to a string<br>&gt;&gt;     }<br>&gt;&gt;     init(_ elements: RegexElement...) {<br>&gt;&gt;         self.elements = elements // Example. Really also compiles the expression<br>&gt;&gt;     }<br>&gt;&gt;     // init(regexLiteral regex: Regex) {<br>&gt;&gt;     // init(concatAll regexes: Regex...) {<br>&gt;&gt;     // init(fromString string: String) {<br>&gt;&gt;     // ... more inits<br>&gt;&gt;     func map&lt;T&gt;(input: String, @noescape mapper: (element: RegexElement) throws -&gt; T) rethrows -&gt; [T] {<br>&gt;&gt;         return [try mapper(element: RegexElement.special(.startOfLine))] // Example. Really does the matching<br>&gt;&gt;     }<br>&gt;&gt;     // func flatMap&lt;T&gt;(input: String, @noescape mapper: (element: RegexElement) throws -&gt; T?) rethrows -&gt; [T] {<br>&gt;&gt;     // func flatMap&lt;S: SequenceType&gt;(input: String, @noescape mapper: (element: RegexElement) throws -&gt; S) rethrows -&gt; [S.Generator.Element] {<br>&gt;&gt;     // func forEach(input: String, @noescape eacher: (element: RegexElement) throws -&gt; Void) rethrows {<br>&gt;&gt;     // ... more funcs<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let regex = Regex(RegexElement.special(.startOfLine)) // Normally a regex literal<br>&gt;&gt; let asStringArray = regex.map(&quot;Example&quot;) { element -&gt; String in // Returns `[&quot;^&quot;]` in example<br>&gt;&gt;     switch element {<br>&gt;&gt;     case let .capture(_, v): return v<br>&gt;&gt;     case let .special(s): return s.rawValue<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; The advantages are:<br>&gt;&gt;   We get a literal type for convenience.<br>&gt;&gt;   We get a programatic type when we need to manipulate regexes.<br>&gt;&gt;   Breaking the regex matches into the enum defined elements of the regex works well with Swift pattern matching.<br>&gt;&gt; (Above is a very rough sketch!)<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On 2 February 2016 at 16:44, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;&gt; Something like Scala&#39;s extractors or F#&#39;s Active Patterns would be most welcome to generalize pattern matching.<br>&gt;&gt; <br>&gt;&gt; http://docs.scala-lang.org/tutorials/tour/extractor-objects.html &lt;http://docs.scala-lang.org/tutorials/tour/extractor-objects.html&gt;<br>&gt;&gt; https://en.m.wikibooks.org/wiki/F_Sharp_Programming/Active_Patterns &lt;https://en.m.wikibooks.org/wiki/F_Sharp_Programming/Active_Patterns&gt;<br>&gt;&gt; <br>&gt;&gt; -Thorsten <br>&gt;&gt; <br>&gt;&gt; Am 01.02.2016 um 15:46 schrieb James Campbell via swift-evolution &lt;swift-evolution at swift.org &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; It would be great if we could create a generic way of making this swifty. You may let say want to implement a matching system for structure like JSON or XML (i.e XQuery).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ___________________________________<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; James⎥Lead Engineer<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; james at supmenow.com &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;james at supmenow.com&#39;);&gt;⎥supmenow.com &lt;http://supmenow.com/&gt;<br>&gt;&gt;&gt; Sup<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Runway East &gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 10 Finsbury Square<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; London<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &gt;&gt;&gt; EC2A 1AF <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Mon, Feb 1, 2016 at 2:43 PM, Patrick Gili via swift-evolution &lt;swift-evolution at swift.org &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;&gt;&gt; Hi Dany,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My response is inline below.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt; -Patrick<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 31, 2016, at 8:56 PM, Dany St-Amant &lt;dsa.mls at icloud.com &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;dsa.mls at icloud.com&#39;);&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Le 31 janv. 2016 à 16:46, Patrick Gili &lt;gili.patrick.r at gili-labs.com &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;gili.patrick.r at gili-labs.com&#39;);&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hi Dany,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Please find my response inline below.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt;&gt; -Patrick<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 31, 2016, at 3:46 PM, Dany St-Amant via swift-evolution &lt;swift-evolution at swift.org &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This seem to be two proposals in one:<br>&gt;&gt;&gt;&gt;&gt;&gt; 1. Initialize NSRegularExpression with a single String which includes options<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The ultimate goal based on the earlier mail in the thread seems to be able in a future proposal do thing like: string ~= replacePattern, if string =~ pattern, decoupled from the legacy Obj-C. Isn’t NSRegularExpression part of the legacy? The conversion of the literal string as regular expression should probably part of the proposal for these operators; as this is the time we will know how we want the text to be interpreted.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I don&#39;t see any evidence of NSRegularExpression becoming part of any legacy. Given SE-005, SE-006, and SE-023, the name is probably changing from NSRegularExpression to RegularExpression. However, I don&#39;t think the definition of the class will change, only the name.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I would like to see an operator regular expression matching operator, like Ruby and Perl. I was trying to keep the proposal a minimal increment that would buy the biggest bang for the buck. We can already accomplish much of what other languages can do with regard to regular expression. However, the notion of a regular expression isn&#39;t something we can work around with custom library today. Can you suggest something addition that should be in the proposal?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Splitting proposal in smaller ones have its advantage, but here I am just wondering if we are sure that these future operation will use the NSRegularExpression/RegularExpression. And does the currently selected syntax allow for future expansion, it would be bad to introduce something  that need to be torn away or changed in an incompatible way, once we really start to use them in their final location.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The proposal is focused on the search, but seem to skip the substitution; I am unable to see an option to replace all matches instead of the first one only in the proposal. I, as many other, would expect regular expression in a language to also support substitution.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As for addition to the proposal, the processing of the string could be support for any character (within some limit) for the slash delimiter. With sed, when replacing  path component, one can do: echo $PWD | sed -e &quot;s:^/usr/local/bin:/opt/share/bin:g&quot;, instead of escaping every single slashes. Which is really handy to make thing easier to read.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Also, putting aside that I think \(scheme) should not be interpreted in the example, with a syntax allowing such interpretation the variable should be processed to generate proper escaping. If one is to use \(filename) you get &quot;main.c&quot;, but one must use \(filename.escaped()) to get the proper &quot;main\.c&quot; to avoid matching &quot;mainac&quot;. The String.escaped() must be in a format compatible with the format used when converting the regular expression into NSRegularExpression (not sure if the two syntax are the same; I think that at least the handling of /  may differ)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree. Perhaps I went too far with keeping the proposal short-and-sweet. Especially when you consider the rich syntax that Perl supports for substitution.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 2. Easily create a String without escaping (\n is not linefeed, but \ and n)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The ability to not interpret the backslash as escape can be useful in other scenario that creating a NSRegularExpression; like creating a Windows pathname, or creating regular expression which are then given to external tool.  So this part of the proposal should probably be generalized.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Generalize it for what? If you&#39;re thinking along the line of raw strings, I agree that we need this capability, as well as multi-line string literals. However, I just soon we have separate proposals for this.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; My point/opinion here, is that a regular expressions are just a String which are then interpreted; the same way as &quot;Good Morning&quot;, &quot;Bonjour&quot;, or &quot;Marhaba&quot; (even when using the arabic script) are just String when you assign then to a variable in Swift, and then interpreted by the intended user. They are not String, frenchString, rigthToLeftString. So I do not see why a regular expression should have privileged treatment and have its own language level syntax. The only difference when writing regular expression, or Windows pathname, or any String with a syntax with heavily uses of backslashes, is that one may want to disable the special meaning of the backslashes, to make thing more readable.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On the page of geeky-ing the String there’s four main part IMHO<br>&gt;&gt;&gt;&gt; - multi-line support<br>&gt;&gt;&gt;&gt; - no backslash escaping version (which should include no processing the \(variable) format)<br>&gt;&gt;&gt;&gt; - inclusion of String delimiter inside the String<br>&gt;&gt;&gt;&gt; - concat of backslash/no backslash version. Bash example echo &#39;echo &quot;$BASH&quot; shows &#39;&quot;$BASH&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m still trying to find back the mail thread crumbs on these topics, since before restarting the discussion in these topics, the previous one should be properly summarized; unless such summary already exist.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think supporting interpolation is important. Both Perl and Ruby support it, and I&#39;m sure there are other languages. One thing I forgot to put into the proposal: an option to disable interpolation or limit it to single pass.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Looking ahead at the other responses, Chris Lattner has suggested that the proposal would have more traction if we can find a way to fold this into Swift&#39;s pattern matching. I can&#39;t say as I disagree, as this makes regular expression more Swifty.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Regards,<br>&gt;&gt;&gt;&gt; Dany<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Dany<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Le 31 janv. 2016 à 12:18, Patrick Gili via swift-evolution &lt;swift-evolution at swift.org &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Here is the link to the proposal on GitHub:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://github.com/gili-patrick-r/swift-evolution/blob/master/proposals/NNNN-regular-expression-literals.md &lt;https://github.com/gili-patrick-r/swift-evolution/blob/master/proposals/NNNN-regular-expression-literals.md&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Patrick<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt;   -- Howard.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt;   -- Howard.<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160202/0b26f9a6/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Empower String type with regular expression</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>February  3, 2016 at 10:00:00am</p></header><div class="content"><p>I don&#39;t see that the two have to be exclusive. If the design of the regex<br>literal is suitable for both a traditional NSRegularExpression and a verbal<br>type implementation then the two can co-exist. It can also be staged, so<br>that a literal can be introduced first with a bridge to legacy<br>NSRegularExpression and then later a verbal implementation could be added.<br>The key is to design a liberal that is future proofed.<br></p><p>On 3 February 2016 at 10:33, Patrick Gili &lt;gili.patrick.r at gili-labs.com&gt;<br>wrote:<br></p><p>&gt; I don&#39;t feel good about this direction for the following reasons:<br>&gt; 1) Complexity<br>&gt; 2) Maturity? I don&#39;t know how Verbal Expressions has been implemented.<br>&gt; Does it leverage mature regex open source? Or, has it been written from<br>&gt; scratch?<br>&gt; 3) Performance? Compiling a regex literal typically results in a FSM of a<br>&gt; sort, optimized to parse strings. I wouldn&#39;t think that converting a regex<br>&gt; literal to Verbal Expressions would yield great performance every time a<br>&gt; match or substitution is done.<br>&gt;<br>&gt; -Patrick<br>&gt;<br>&gt; On Feb 2, 2016, at 5:55 PM, Howard Lovatt &lt;howard.lovatt at gmail.com&gt; wrote:<br>&gt;<br>&gt; The difference is that I am proposing supporting both verbal expressions<br>&gt; and regex literals and that - literals are converted to verbals and the<br>&gt; processing happens at the verbal level. The reason for this is that verbals<br>&gt; are easy to handle programmatically whilst literals are great for quickly<br>&gt; specifying a regex.<br>&gt;<br>&gt; On Tuesday, 2 February 2016, Patrick Gili &lt;gili.patrick.r at gili-labs.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; Hi Howard,<br>&gt;&gt;<br>&gt;&gt; I don&#39;t see how this is very different from the Swift Verbal Expressions.<br>&gt;&gt; It would suffer from the same disadvantages I have stated previously.<br>&gt;&gt;<br>&gt;&gt; Cheers,<br>&gt;&gt; -Patrick<br>&gt;&gt;<br>&gt;&gt; On Feb 2, 2016, at 1:51 AM, Howard Lovatt via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Others have suggested a programatic regex instead of a regex literal, how<br>&gt;&gt; about doing both? Something like:<br>&gt;&gt;<br>&gt;&gt; enum RegexElement {<br>&gt;&gt;     case capture(name: String, value: String)<br>&gt;&gt;     case special(Special)<br>&gt;&gt;     // ...<br>&gt;&gt;     enum Special: String {<br>&gt;&gt;         case startOfLine = &quot;^&quot;<br>&gt;&gt;         // ...<br>&gt;&gt;         case endOfLine = &quot;$&quot;<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; // Define a regexLiteral syntax that the compiler understands that is of<br>&gt;&gt; type Regex and consists of String representations of RegexElements, e.g.<br>&gt;&gt; using forward slash:<br>&gt;&gt; //    /&lt;RegexElements&gt;*/<br>&gt;&gt;<br>&gt;&gt; struct Regex: CustomStringConvertible { // Compiled, immutable, thread<br>&gt;&gt; safe, and bridged to NSRegularExpression<br>&gt;&gt;     // ... internal compiled representation<br>&gt;&gt;     let elements: [RegexElement]<br>&gt;&gt;     var description: String {<br>&gt;&gt;         return RegexElement.Special.startOfLine.rawValue // Example.<br>&gt;&gt; Really returns all the elements converted back to a string<br>&gt;&gt;     }<br>&gt;&gt;     init(_ elements: RegexElement...) {<br>&gt;&gt;         self.elements = elements // Example. Really also compiles the<br>&gt;&gt; expression<br>&gt;&gt;     }<br>&gt;&gt;     // init(regexLiteral regex: Regex) {<br>&gt;&gt;     // init(concatAll regexes: Regex...) {<br>&gt;&gt;     // init(fromString string: String) {<br>&gt;&gt;     // ... more inits<br>&gt;&gt;     func map&lt;T&gt;(input: String, @noescape mapper: (element: RegexElement)<br>&gt;&gt; throws -&gt; T) rethrows -&gt; [T] {<br>&gt;&gt;         return [try mapper(element: RegexElement.special(.startOfLine))] //<br>&gt;&gt; Example. Really does the matching<br>&gt;&gt;     }<br>&gt;&gt;     // func flatMap&lt;T&gt;(input: String, @noescape mapper: (element:<br>&gt;&gt; RegexElement) throws -&gt; T?) rethrows -&gt; [T] {<br>&gt;&gt;     // func flatMap&lt;S: SequenceType&gt;(input: String, @noescape mapper:<br>&gt;&gt; (element: RegexElement) throws -&gt; S) rethrows -&gt; [S.Generator.Element] {<br>&gt;&gt;     // func forEach(input: String, @noescape eacher: (element:<br>&gt;&gt; RegexElement) throws -&gt; Void) rethrows {<br>&gt;&gt;     // ... more funcs<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; let regex = Regex(RegexElement.special(.startOfLine)) // Normally a<br>&gt;&gt; regex literal<br>&gt;&gt; let asStringArray = regex.map(&quot;Example&quot;) { element -&gt; String in //<br>&gt;&gt; Returns `[&quot;^&quot;]` in example<br>&gt;&gt;     switch element {<br>&gt;&gt;     case let .capture(_, v): return v<br>&gt;&gt;     case let .special(s): return s.rawValue<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; The advantages are:<br>&gt;&gt;<br>&gt;&gt;    1.   We get a literal type for convenience.<br>&gt;&gt;    2.   We get a programatic type when we need to manipulate regexes.<br>&gt;&gt;    3.   Breaking the regex matches into the enum defined elements of the<br>&gt;&gt;    regex works well with Swift pattern matching.<br>&gt;&gt;<br>&gt;&gt; (Above is a very rough sketch!)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On 2 February 2016 at 16:44, Thorsten Seitz via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Something like Scala&#39;s extractors or F#&#39;s Active Patterns would be most<br>&gt;&gt;&gt; welcome to generalize pattern matching.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; http://docs.scala-lang.org/tutorials/tour/extractor-objects.html<br>&gt;&gt;&gt; https://en.m.wikibooks.org/wiki/F_Sharp_Programming/Active_Patterns<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Am 01.02.2016 um 15:46 schrieb James Campbell via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It would be great if we could create a generic way of making this<br>&gt;&gt;&gt; swifty. You may let say want to implement a matching system for structure<br>&gt;&gt;&gt; like JSON or XML (i.e XQuery).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *___________________________________*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *James⎥Lead Engineer*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *james at supmenow.com⎥supmenow.com &lt;http://supmenow.com/&gt;*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *Sup*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *Runway East *<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *10 Finsbury Square*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *London*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; * EC2A 1AF *<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Mon, Feb 1, 2016 at 2:43 PM, Patrick Gili via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Hi Dany,<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; My response is inline below.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt; -Patrick<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Jan 31, 2016, at 8:56 PM, Dany St-Amant &lt;dsa.mls at icloud.com&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Le 31 janv. 2016 à 16:46, Patrick Gili &lt;gili.patrick.r at gili-labs.com&gt;<br>&gt;&gt;&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Hi Dany,<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Please find my response inline below.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt; -Patrick<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Jan 31, 2016, at 3:46 PM, Dany St-Amant via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This seem to be two proposals in one:<br>&gt;&gt;&gt;&gt; 1. Initialize NSRegularExpression with a single String which includes<br>&gt;&gt;&gt;&gt; options<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The ultimate goal based on the earlier mail in the thread seems to be<br>&gt;&gt;&gt;&gt; able in a future proposal do thing like: string ~= replacePattern, if<br>&gt;&gt;&gt;&gt; string =~ pattern, decoupled from the legacy Obj-C. Isn’t<br>&gt;&gt;&gt;&gt; NSRegularExpression part of the legacy? The conversion of the literal<br>&gt;&gt;&gt;&gt; string as regular expression should probably part of the proposal for these<br>&gt;&gt;&gt;&gt; operators; as this is the time we will know how we want the text to be<br>&gt;&gt;&gt;&gt; interpreted.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I don&#39;t see any evidence of NSRegularExpression becoming part of any<br>&gt;&gt;&gt;&gt; legacy. Given SE-005, SE-006, and SE-023, the name is probably changing<br>&gt;&gt;&gt;&gt; from NSRegularExpression to RegularExpression. However, I don&#39;t think the<br>&gt;&gt;&gt;&gt; definition of the class will change, only the name.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I would like to see an operator regular expression matching operator,<br>&gt;&gt;&gt;&gt; like Ruby and Perl. I was trying to keep the proposal a minimal increment<br>&gt;&gt;&gt;&gt; that would buy the biggest bang for the buck. We can already accomplish<br>&gt;&gt;&gt;&gt; much of what other languages can do with regard to regular expression.<br>&gt;&gt;&gt;&gt; However, the notion of a regular expression isn&#39;t something we can work<br>&gt;&gt;&gt;&gt; around with custom library today. Can you suggest something addition that<br>&gt;&gt;&gt;&gt; should be in the proposal?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Splitting proposal in smaller ones have its advantage, but here I am<br>&gt;&gt;&gt;&gt; just wondering if we are sure that these future operation will use the<br>&gt;&gt;&gt;&gt; NSRegularExpression/RegularExpression. And does the currently selected<br>&gt;&gt;&gt;&gt; syntax allow for future expansion, it would be bad to introduce something<br>&gt;&gt;&gt;&gt;  that need to be torn away or changed in an incompatible way, once we<br>&gt;&gt;&gt;&gt; really start to use them in their final location.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The proposal is focused on the search, but seem to skip the<br>&gt;&gt;&gt;&gt; substitution; I am unable to see an option to replace all matches instead<br>&gt;&gt;&gt;&gt; of the first one only in the proposal. I, as many other, would expect<br>&gt;&gt;&gt;&gt; regular expression in a language to also support substitution.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; As for addition to the proposal, the processing of the string could be<br>&gt;&gt;&gt;&gt; support for any character (within some limit) for the slash delimiter. With<br>&gt;&gt;&gt;&gt; sed, when replacing  path component, one can do: echo $PWD | sed -e<br>&gt;&gt;&gt;&gt; &quot;s:^/usr/local/bin:/opt/share/bin:g&quot;, instead of escaping every single<br>&gt;&gt;&gt;&gt; slashes. Which is really handy to make thing easier to read.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Also, putting aside that I think \(scheme) should not be interpreted in<br>&gt;&gt;&gt;&gt; the example, with a syntax allowing such interpretation the variable should<br>&gt;&gt;&gt;&gt; be processed to generate proper escaping. If one is to use \(filename) you<br>&gt;&gt;&gt;&gt; get &quot;main.c&quot;, but one must use \(filename.escaped()) to get the proper<br>&gt;&gt;&gt;&gt; &quot;main\.c&quot; to avoid matching &quot;mainac&quot;. The String.escaped() must be in a<br>&gt;&gt;&gt;&gt; format compatible with the format used when converting the regular<br>&gt;&gt;&gt;&gt; expression into NSRegularExpression (not sure if the two syntax are the<br>&gt;&gt;&gt;&gt; same; I think that at least the handling of /  may differ)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I agree. Perhaps I went too far with keeping the proposal<br>&gt;&gt;&gt;&gt; short-and-sweet. Especially when you consider the rich syntax that Perl<br>&gt;&gt;&gt;&gt; supports for substitution.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; 2. Easily create a String without escaping (\n is not linefeed, but \<br>&gt;&gt;&gt;&gt; and n)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The ability to not interpret the backslash as escape can be useful in<br>&gt;&gt;&gt;&gt; other scenario that creating a NSRegularExpression; like creating a Windows<br>&gt;&gt;&gt;&gt; pathname, or creating regular expression which are then given to external<br>&gt;&gt;&gt;&gt; tool.  So this part of the proposal should probably be generalized.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Generalize it for what? If you&#39;re thinking along the line of raw<br>&gt;&gt;&gt;&gt; strings, I agree that we need this capability, as well as multi-line string<br>&gt;&gt;&gt;&gt; literals. However, I just soon we have separate proposals for this.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; My point/opinion here, is that a regular expressions are just a String<br>&gt;&gt;&gt;&gt; which are then interpreted; the same way as &quot;Good Morning&quot;, &quot;Bonjour&quot;, or<br>&gt;&gt;&gt;&gt; &quot;Marhaba&quot; (even when using the arabic script) are just String when you<br>&gt;&gt;&gt;&gt; assign then to a variable in Swift, and then interpreted by the intended<br>&gt;&gt;&gt;&gt; user. They are not String, frenchString, rigthToLeftString. So I do not see<br>&gt;&gt;&gt;&gt; why a regular expression should have privileged treatment and have its own<br>&gt;&gt;&gt;&gt; language level syntax. The only difference when writing regular expression,<br>&gt;&gt;&gt;&gt; or Windows pathname, or any String with a syntax with heavily uses of<br>&gt;&gt;&gt;&gt; backslashes, is that one may want to disable the special meaning of the<br>&gt;&gt;&gt;&gt; backslashes, to make thing more readable.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On the page of geeky-ing the String there’s four main part IMHO<br>&gt;&gt;&gt;&gt; - multi-line support<br>&gt;&gt;&gt;&gt; - no backslash escaping version (which should include no processing the<br>&gt;&gt;&gt;&gt; \(variable) format)<br>&gt;&gt;&gt;&gt; - inclusion of String delimiter inside the String<br>&gt;&gt;&gt;&gt; - concat of backslash/no backslash version. Bash example echo &#39;echo<br>&gt;&gt;&gt;&gt; &quot;$BASH&quot; shows &#39;&quot;$BASH&quot;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I’m still trying to find back the mail thread crumbs on these topics,<br>&gt;&gt;&gt;&gt; since before restarting the discussion in these topics, the previous one<br>&gt;&gt;&gt;&gt; should be properly summarized; unless such summary already exist.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I think supporting interpolation is important. Both Perl and Ruby<br>&gt;&gt;&gt;&gt; support it, and I&#39;m sure there are other languages. One thing I forgot to<br>&gt;&gt;&gt;&gt; put into the proposal: an option to disable interpolation or limit it to<br>&gt;&gt;&gt;&gt; single pass.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Looking ahead at the other responses, Chris Lattner has suggested that<br>&gt;&gt;&gt;&gt; the proposal would have more traction if we can find a way to fold this<br>&gt;&gt;&gt;&gt; into Swift&#39;s pattern matching. I can&#39;t say as I disagree, as this makes<br>&gt;&gt;&gt;&gt; regular expression more Swifty.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Regards,<br>&gt;&gt;&gt;&gt; Dany<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Dany<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Le 31 janv. 2016 à 12:18, Patrick Gili via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Here is the link to the proposal on GitHub:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; https://github.com/gili-patrick-r/swift-evolution/blob/master/proposals/NNNN-regular-expression-literals.md<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt; -Patrick<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt;   -- Howard.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt; --<br>&gt;   -- Howard.<br>&gt;<br>&gt;<br>&gt;<br></p><p><br>-- <br>  -- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/70c0fcbd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Empower String type with regular expression</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>February  2, 2016 at 04:00:00pm</p></header><div class="content"><p>Assuming we’re still on track for getting an official package manager in Swift 3…<br></p><p>I vote we put the traditional regex in the stdlib, either as a non-final class or in combination with a “RegularExpressionParser” protocol, and make these “non-standard” parsers compatible with the stdlib implementation (that is, subclass the stdlib parser or conform to the protocol), and put them up in the package manager. “Swift Verbal Expressions&quot; looks very cool, but I’m not sure it’s “lean &amp; mean” enough for the stdlib.<br></p><p>- Dave Sweeris<br></p><p>&gt; On Feb 2, 2016, at 15:53, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I don&#39;t see that the two have to be exclusive. If the design of the regex literal is suitable for both a traditional NSRegularExpression and a verbal type implementation then the two can co-exist. It can also be staged, so that a literal can be introduced first with a bridge to legacy NSRegularExpression and then later a verbal implementation could be added. The key is to design a liberal that is future proofed. <br>&gt; <br>&gt; On 3 February 2016 at 10:33, Patrick Gili &lt;gili.patrick.r at gili-labs.com &lt;mailto:gili.patrick.r at gili-labs.com&gt;&gt; wrote:<br>&gt; I don&#39;t feel good about this direction for the following reasons:<br>&gt; 1) Complexity<br>&gt; 2) Maturity? I don&#39;t know how Verbal Expressions has been implemented. Does it leverage mature regex open source? Or, has it been written from scratch?<br>&gt; 3) Performance? Compiling a regex literal typically results in a FSM of a sort, optimized to parse strings. I wouldn&#39;t think that converting a regex literal to Verbal Expressions would yield great performance every time a match or substitution is done.<br>&gt; <br>&gt; -Patrick<br>&gt; <br>&gt;&gt; On Feb 2, 2016, at 5:55 PM, Howard Lovatt &lt;howard.lovatt at gmail.com &lt;mailto:howard.lovatt at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The difference is that I am proposing supporting both verbal expressions and regex literals and that - literals are converted to verbals and the processing happens at the verbal level. The reason for this is that verbals are easy to handle programmatically whilst literals are great for quickly specifying a regex.<br>&gt;&gt; <br>&gt;&gt; On Tuesday, 2 February 2016, Patrick Gili &lt;gili.patrick.r at gili-labs.com &lt;mailto:gili.patrick.r at gili-labs.com&gt;&gt; wrote:<br>&gt;&gt; Hi Howard,<br>&gt;&gt; <br>&gt;&gt; I don&#39;t see how this is very different from the Swift Verbal Expressions. It would suffer from the same disadvantages I have stated previously.<br>&gt;&gt; <br>&gt;&gt; Cheers,<br>&gt;&gt; -Patrick<br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 2, 2016, at 1:51 AM, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org &lt;&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Others have suggested a programatic regex instead of a regex literal, how about doing both? Something like:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; enum RegexElement {<br>&gt;&gt;&gt;     case capture(name: String, value: String)<br>&gt;&gt;&gt;     case special(Special)<br>&gt;&gt;&gt;     // ...<br>&gt;&gt;&gt;     enum Special: String {<br>&gt;&gt;&gt;         case startOfLine = &quot;^&quot;<br>&gt;&gt;&gt;         // ...<br>&gt;&gt;&gt;         case endOfLine = &quot;$&quot;<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Define a regexLiteral syntax that the compiler understands that is of type Regex and consists of String representations of RegexElements, e.g. using forward slash:<br>&gt;&gt;&gt; //    /&lt;RegexElements&gt;*/<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Regex: CustomStringConvertible { // Compiled, immutable, thread safe, and bridged to NSRegularExpression<br>&gt;&gt;&gt;     // ... internal compiled representation<br>&gt;&gt;&gt;     let elements: [RegexElement]<br>&gt;&gt;&gt;     var description: String {<br>&gt;&gt;&gt;         return RegexElement.Special.startOfLine.rawValue // Example. Really returns all the elements converted back to a string<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     init(_ elements: RegexElement...) {<br>&gt;&gt;&gt;         self.elements = elements // Example. Really also compiles the expression<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     // init(regexLiteral regex: Regex) {<br>&gt;&gt;&gt;     // init(concatAll regexes: Regex...) {<br>&gt;&gt;&gt;     // init(fromString string: String) {<br>&gt;&gt;&gt;     // ... more inits<br>&gt;&gt;&gt;     func map&lt;T&gt;(input: String, @noescape mapper: (element: RegexElement) throws -&gt; T) rethrows -&gt; [T] {<br>&gt;&gt;&gt;         return [try mapper(element: RegexElement.special(.startOfLine))] // Example. Really does the matching<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     // func flatMap&lt;T&gt;(input: String, @noescape mapper: (element: RegexElement) throws -&gt; T?) rethrows -&gt; [T] {<br>&gt;&gt;&gt;     // func flatMap&lt;S: SequenceType&gt;(input: String, @noescape mapper: (element: RegexElement) throws -&gt; S) rethrows -&gt; [S.Generator.Element] {<br>&gt;&gt;&gt;     // func forEach(input: String, @noescape eacher: (element: RegexElement) throws -&gt; Void) rethrows {<br>&gt;&gt;&gt;     // ... more funcs<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let regex = Regex(RegexElement.special(.startOfLine)) // Normally a regex literal<br>&gt;&gt;&gt; let asStringArray = regex.map(&quot;Example&quot;) { element -&gt; String in // Returns `[&quot;^&quot;]` in example<br>&gt;&gt;&gt;     switch element {<br>&gt;&gt;&gt;     case let .capture(_, v): return v<br>&gt;&gt;&gt;     case let .special(s): return s.rawValue<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The advantages are:<br>&gt;&gt;&gt;   We get a literal type for convenience.<br>&gt;&gt;&gt;   We get a programatic type when we need to manipulate regexes.<br>&gt;&gt;&gt;   Breaking the regex matches into the enum defined elements of the regex works well with Swift pattern matching.<br>&gt;&gt;&gt; (Above is a very rough sketch!)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 2 February 2016 at 16:44, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;&gt;&gt; wrote:<br>&gt;&gt;&gt; Something like Scala&#39;s extractors or F#&#39;s Active Patterns would be most welcome to generalize pattern matching.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; http://docs.scala-lang.org/tutorials/tour/extractor-objects.html &lt;http://docs.scala-lang.org/tutorials/tour/extractor-objects.html&gt;<br>&gt;&gt;&gt; https://en.m.wikibooks.org/wiki/F_Sharp_Programming/Active_Patterns &lt;https://en.m.wikibooks.org/wiki/F_Sharp_Programming/Active_Patterns&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Thorsten <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am 01.02.2016 um 15:46 schrieb James Campbell via swift-evolution &lt;swift-evolution at swift.org &lt;&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It would be great if we could create a generic way of making this swifty. You may let say want to implement a matching system for structure like JSON or XML (i.e XQuery).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ___________________________________<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; James⎥Lead Engineer<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; james at supmenow.com &lt;&gt;⎥supmenow.com &lt;http://supmenow.com/&gt;<br>&gt;&gt;&gt;&gt; Sup<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Runway East &gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 10 Finsbury Square<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; London<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  &gt;&gt;&gt;&gt; EC2A 1AF <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mon, Feb 1, 2016 at 2:43 PM, Patrick Gili via swift-evolution &lt;swift-evolution at swift.org &lt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; Hi Dany,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; My response is inline below.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt; -Patrick<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 31, 2016, at 8:56 PM, Dany St-Amant &lt;dsa.mls at icloud.com &lt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Le 31 janv. 2016 à 16:46, Patrick Gili &lt;gili.patrick.r at gili-labs.com &lt;&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Hi Dany,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Please find my response inline below.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt;&gt;&gt; -Patrick<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jan 31, 2016, at 3:46 PM, Dany St-Amant via swift-evolution &lt;swift-evolution at swift.org &lt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This seem to be two proposals in one:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1. Initialize NSRegularExpression with a single String which includes options<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The ultimate goal based on the earlier mail in the thread seems to be able in a future proposal do thing like: string ~= replacePattern, if string =~ pattern, decoupled from the legacy Obj-C. Isn’t NSRegularExpression part of the legacy? The conversion of the literal string as regular expression should probably part of the proposal for these operators; as this is the time we will know how we want the text to be interpreted.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t see any evidence of NSRegularExpression becoming part of any legacy. Given SE-005, SE-006, and SE-023, the name is probably changing from NSRegularExpression to RegularExpression. However, I don&#39;t think the definition of the class will change, only the name.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I would like to see an operator regular expression matching operator, like Ruby and Perl. I was trying to keep the proposal a minimal increment that would buy the biggest bang for the buck. We can already accomplish much of what other languages can do with regard to regular expression. However, the notion of a regular expression isn&#39;t something we can work around with custom library today. Can you suggest something addition that should be in the proposal?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Splitting proposal in smaller ones have its advantage, but here I am just wondering if we are sure that these future operation will use the NSRegularExpression/RegularExpression. And does the currently selected syntax allow for future expansion, it would be bad to introduce something  that need to be torn away or changed in an incompatible way, once we really start to use them in their final location.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The proposal is focused on the search, but seem to skip the substitution; I am unable to see an option to replace all matches instead of the first one only in the proposal. I, as many other, would expect regular expression in a language to also support substitution.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; As for addition to the proposal, the processing of the string could be support for any character (within some limit) for the slash delimiter. With sed, when replacing  path component, one can do: echo $PWD | sed -e &quot;s:^/usr/local/bin:/opt/share/bin:g&quot;, instead of escaping every single slashes. Which is really handy to make thing easier to read.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Also, putting aside that I think \(scheme) should not be interpreted in the example, with a syntax allowing such interpretation the variable should be processed to generate proper escaping. If one is to use \(filename) you get &quot;main.c&quot;, but one must use \(filename.escaped()) to get the proper &quot;main\.c&quot; to avoid matching &quot;mainac&quot;. The String.escaped() must be in a format compatible with the format used when converting the regular expression into NSRegularExpression (not sure if the two syntax are the same; I think that at least the handling of /  may differ)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I agree. Perhaps I went too far with keeping the proposal short-and-sweet. Especially when you consider the rich syntax that Perl supports for substitution.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2. Easily create a String without escaping (\n is not linefeed, but \ and n)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The ability to not interpret the backslash as escape can be useful in other scenario that creating a NSRegularExpression; like creating a Windows pathname, or creating regular expression which are then given to external tool.  So this part of the proposal should probably be generalized.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Generalize it for what? If you&#39;re thinking along the line of raw strings, I agree that we need this capability, as well as multi-line string literals. However, I just soon we have separate proposals for this.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; My point/opinion here, is that a regular expressions are just a String which are then interpreted; the same way as &quot;Good Morning&quot;, &quot;Bonjour&quot;, or &quot;Marhaba&quot; (even when using the arabic script) are just String when you assign then to a variable in Swift, and then interpreted by the intended user. They are not String, frenchString, rigthToLeftString. So I do not see why a regular expression should have privileged treatment and have its own language level syntax. The only difference when writing regular expression, or Windows pathname, or any String with a syntax with heavily uses of backslashes, is that one may want to disable the special meaning of the backslashes, to make thing more readable.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On the page of geeky-ing the String there’s four main part IMHO<br>&gt;&gt;&gt;&gt;&gt; - multi-line support<br>&gt;&gt;&gt;&gt;&gt; - no backslash escaping version (which should include no processing the \(variable) format)<br>&gt;&gt;&gt;&gt;&gt; - inclusion of String delimiter inside the String<br>&gt;&gt;&gt;&gt;&gt; - concat of backslash/no backslash version. Bash example echo &#39;echo &quot;$BASH&quot; shows &#39;&quot;$BASH&quot;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I’m still trying to find back the mail thread crumbs on these topics, since before restarting the discussion in these topics, the previous one should be properly summarized; unless such summary already exist.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think supporting interpolation is important. Both Perl and Ruby support it, and I&#39;m sure there are other languages. One thing I forgot to put into the proposal: an option to disable interpolation or limit it to single pass.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Looking ahead at the other responses, Chris Lattner has suggested that the proposal would have more traction if we can find a way to fold this into Swift&#39;s pattern matching. I can&#39;t say as I disagree, as this makes regular expression more Swifty.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Regards,<br>&gt;&gt;&gt;&gt;&gt; Dany<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Dany<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Le 31 janv. 2016 à 12:18, Patrick Gili via swift-evolution &lt;swift-evolution at swift.org &lt;&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Here is the link to the proposal on GitHub:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://github.com/gili-patrick-r/swift-evolution/blob/master/proposals/NNNN-regular-expression-literals.md &lt;https://github.com/gili-patrick-r/swift-evolution/blob/master/proposals/NNNN-regular-expression-literals.md&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Patrick<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt;   -- Howard.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt;   -- Howard.<br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt;   -- Howard.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160202/567cf130/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05e222e6ef4d84013bb3baeb0e25c90b?s=50"></div><header><strong>Empower String type with regular expression</strong> from <string>Patrick Gili</string> &lt;gili.patrick.r at gili-labs.com&gt;<p>February  3, 2016 at 08:00:00am</p></header><div class="content"><p>Hi Howard,<br></p><p>I&#39;m not saying the two methods don&#39;t have to be exclusive. However, you asked us to consider converting regex literals into Swift Verbal Expressions. My response highlighted potential issues with this approach.<br></p><p>Cheers,<br>-Patrick<br></p><p>&gt; On Feb 2, 2016, at 6:53 PM, Howard Lovatt &lt;howard.lovatt at gmail.com&gt; wrote:<br>&gt; <br>&gt; I don&#39;t see that the two have to be exclusive. If the design of the regex literal is suitable for both a traditional NSRegularExpression and a verbal type implementation then the two can co-exist. It can also be staged, so that a literal can be introduced first with a bridge to legacy NSRegularExpression and then later a verbal implementation could be added. The key is to design a liberal that is future proofed. <br>&gt; <br>&gt; On 3 February 2016 at 10:33, Patrick Gili &lt;gili.patrick.r at gili-labs.com &lt;mailto:gili.patrick.r at gili-labs.com&gt;&gt; wrote:<br>&gt; I don&#39;t feel good about this direction for the following reasons:<br>&gt; 1) Complexity<br>&gt; 2) Maturity? I don&#39;t know how Verbal Expressions has been implemented. Does it leverage mature regex open source? Or, has it been written from scratch?<br>&gt; 3) Performance? Compiling a regex literal typically results in a FSM of a sort, optimized to parse strings. I wouldn&#39;t think that converting a regex literal to Verbal Expressions would yield great performance every time a match or substitution is done.<br>&gt; <br>&gt; -Patrick<br>&gt; <br>&gt;&gt; On Feb 2, 2016, at 5:55 PM, Howard Lovatt &lt;howard.lovatt at gmail.com &lt;mailto:howard.lovatt at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The difference is that I am proposing supporting both verbal expressions and regex literals and that - literals are converted to verbals and the processing happens at the verbal level. The reason for this is that verbals are easy to handle programmatically whilst literals are great for quickly specifying a regex.<br>&gt;&gt; <br>&gt;&gt; On Tuesday, 2 February 2016, Patrick Gili &lt;gili.patrick.r at gili-labs.com &lt;mailto:gili.patrick.r at gili-labs.com&gt;&gt; wrote:<br>&gt;&gt; Hi Howard,<br>&gt;&gt; <br>&gt;&gt; I don&#39;t see how this is very different from the Swift Verbal Expressions. It would suffer from the same disadvantages I have stated previously.<br>&gt;&gt; <br>&gt;&gt; Cheers,<br>&gt;&gt; -Patrick<br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 2, 2016, at 1:51 AM, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org &lt;&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Others have suggested a programatic regex instead of a regex literal, how about doing both? Something like:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; enum RegexElement {<br>&gt;&gt;&gt;     case capture(name: String, value: String)<br>&gt;&gt;&gt;     case special(Special)<br>&gt;&gt;&gt;     // ...<br>&gt;&gt;&gt;     enum Special: String {<br>&gt;&gt;&gt;         case startOfLine = &quot;^&quot;<br>&gt;&gt;&gt;         // ...<br>&gt;&gt;&gt;         case endOfLine = &quot;$&quot;<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Define a regexLiteral syntax that the compiler understands that is of type Regex and consists of String representations of RegexElements, e.g. using forward slash:<br>&gt;&gt;&gt; //    /&lt;RegexElements&gt;*/<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Regex: CustomStringConvertible { // Compiled, immutable, thread safe, and bridged to NSRegularExpression<br>&gt;&gt;&gt;     // ... internal compiled representation<br>&gt;&gt;&gt;     let elements: [RegexElement]<br>&gt;&gt;&gt;     var description: String {<br>&gt;&gt;&gt;         return RegexElement.Special.startOfLine.rawValue // Example. Really returns all the elements converted back to a string<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     init(_ elements: RegexElement...) {<br>&gt;&gt;&gt;         self.elements = elements // Example. Really also compiles the expression<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     // init(regexLiteral regex: Regex) {<br>&gt;&gt;&gt;     // init(concatAll regexes: Regex...) {<br>&gt;&gt;&gt;     // init(fromString string: String) {<br>&gt;&gt;&gt;     // ... more inits<br>&gt;&gt;&gt;     func map&lt;T&gt;(input: String, @noescape mapper: (element: RegexElement) throws -&gt; T) rethrows -&gt; [T] {<br>&gt;&gt;&gt;         return [try mapper(element: RegexElement.special(.startOfLine))] // Example. Really does the matching<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     // func flatMap&lt;T&gt;(input: String, @noescape mapper: (element: RegexElement) throws -&gt; T?) rethrows -&gt; [T] {<br>&gt;&gt;&gt;     // func flatMap&lt;S: SequenceType&gt;(input: String, @noescape mapper: (element: RegexElement) throws -&gt; S) rethrows -&gt; [S.Generator.Element] {<br>&gt;&gt;&gt;     // func forEach(input: String, @noescape eacher: (element: RegexElement) throws -&gt; Void) rethrows {<br>&gt;&gt;&gt;     // ... more funcs<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let regex = Regex(RegexElement.special(.startOfLine)) // Normally a regex literal<br>&gt;&gt;&gt; let asStringArray = regex.map(&quot;Example&quot;) { element -&gt; String in // Returns `[&quot;^&quot;]` in example<br>&gt;&gt;&gt;     switch element {<br>&gt;&gt;&gt;     case let .capture(_, v): return v<br>&gt;&gt;&gt;     case let .special(s): return s.rawValue<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The advantages are:<br>&gt;&gt;&gt;   We get a literal type for convenience.<br>&gt;&gt;&gt;   We get a programatic type when we need to manipulate regexes.<br>&gt;&gt;&gt;   Breaking the regex matches into the enum defined elements of the regex works well with Swift pattern matching.<br>&gt;&gt;&gt; (Above is a very rough sketch!)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 2 February 2016 at 16:44, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;&gt;&gt; wrote:<br>&gt;&gt;&gt; Something like Scala&#39;s extractors or F#&#39;s Active Patterns would be most welcome to generalize pattern matching.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; http://docs.scala-lang.org/tutorials/tour/extractor-objects.html &lt;http://docs.scala-lang.org/tutorials/tour/extractor-objects.html&gt;<br>&gt;&gt;&gt; https://en.m.wikibooks.org/wiki/F_Sharp_Programming/Active_Patterns &lt;https://en.m.wikibooks.org/wiki/F_Sharp_Programming/Active_Patterns&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Thorsten <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am 01.02.2016 um 15:46 schrieb James Campbell via swift-evolution &lt;swift-evolution at swift.org &lt;&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It would be great if we could create a generic way of making this swifty. You may let say want to implement a matching system for structure like JSON or XML (i.e XQuery).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ___________________________________<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; James⎥Lead Engineer<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; james at supmenow.com &lt;&gt;⎥supmenow.com &lt;http://supmenow.com/&gt;<br>&gt;&gt;&gt;&gt; Sup<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Runway East &gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 10 Finsbury Square<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; London<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  &gt;&gt;&gt;&gt; EC2A 1AF <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mon, Feb 1, 2016 at 2:43 PM, Patrick Gili via swift-evolution &lt;swift-evolution at swift.org &lt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; Hi Dany,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; My response is inline below.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt; -Patrick<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 31, 2016, at 8:56 PM, Dany St-Amant &lt;dsa.mls at icloud.com &lt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Le 31 janv. 2016 à 16:46, Patrick Gili &lt;gili.patrick.r at gili-labs.com &lt;&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Hi Dany,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Please find my response inline below.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt;&gt;&gt; -Patrick<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jan 31, 2016, at 3:46 PM, Dany St-Amant via swift-evolution &lt;swift-evolution at swift.org &lt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This seem to be two proposals in one:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1. Initialize NSRegularExpression with a single String which includes options<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The ultimate goal based on the earlier mail in the thread seems to be able in a future proposal do thing like: string ~= replacePattern, if string =~ pattern, decoupled from the legacy Obj-C. Isn’t NSRegularExpression part of the legacy? The conversion of the literal string as regular expression should probably part of the proposal for these operators; as this is the time we will know how we want the text to be interpreted.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t see any evidence of NSRegularExpression becoming part of any legacy. Given SE-005, SE-006, and SE-023, the name is probably changing from NSRegularExpression to RegularExpression. However, I don&#39;t think the definition of the class will change, only the name.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I would like to see an operator regular expression matching operator, like Ruby and Perl. I was trying to keep the proposal a minimal increment that would buy the biggest bang for the buck. We can already accomplish much of what other languages can do with regard to regular expression. However, the notion of a regular expression isn&#39;t something we can work around with custom library today. Can you suggest something addition that should be in the proposal?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Splitting proposal in smaller ones have its advantage, but here I am just wondering if we are sure that these future operation will use the NSRegularExpression/RegularExpression. And does the currently selected syntax allow for future expansion, it would be bad to introduce something  that need to be torn away or changed in an incompatible way, once we really start to use them in their final location.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The proposal is focused on the search, but seem to skip the substitution; I am unable to see an option to replace all matches instead of the first one only in the proposal. I, as many other, would expect regular expression in a language to also support substitution.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; As for addition to the proposal, the processing of the string could be support for any character (within some limit) for the slash delimiter. With sed, when replacing  path component, one can do: echo $PWD | sed -e &quot;s:^/usr/local/bin:/opt/share/bin:g&quot;, instead of escaping every single slashes. Which is really handy to make thing easier to read.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Also, putting aside that I think \(scheme) should not be interpreted in the example, with a syntax allowing such interpretation the variable should be processed to generate proper escaping. If one is to use \(filename) you get &quot;main.c&quot;, but one must use \(filename.escaped()) to get the proper &quot;main\.c&quot; to avoid matching &quot;mainac&quot;. The String.escaped() must be in a format compatible with the format used when converting the regular expression into NSRegularExpression (not sure if the two syntax are the same; I think that at least the handling of /  may differ)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I agree. Perhaps I went too far with keeping the proposal short-and-sweet. Especially when you consider the rich syntax that Perl supports for substitution.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2. Easily create a String without escaping (\n is not linefeed, but \ and n)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The ability to not interpret the backslash as escape can be useful in other scenario that creating a NSRegularExpression; like creating a Windows pathname, or creating regular expression which are then given to external tool.  So this part of the proposal should probably be generalized.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Generalize it for what? If you&#39;re thinking along the line of raw strings, I agree that we need this capability, as well as multi-line string literals. However, I just soon we have separate proposals for this.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; My point/opinion here, is that a regular expressions are just a String which are then interpreted; the same way as &quot;Good Morning&quot;, &quot;Bonjour&quot;, or &quot;Marhaba&quot; (even when using the arabic script) are just String when you assign then to a variable in Swift, and then interpreted by the intended user. They are not String, frenchString, rigthToLeftString. So I do not see why a regular expression should have privileged treatment and have its own language level syntax. The only difference when writing regular expression, or Windows pathname, or any String with a syntax with heavily uses of backslashes, is that one may want to disable the special meaning of the backslashes, to make thing more readable.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On the page of geeky-ing the String there’s four main part IMHO<br>&gt;&gt;&gt;&gt;&gt; - multi-line support<br>&gt;&gt;&gt;&gt;&gt; - no backslash escaping version (which should include no processing the \(variable) format)<br>&gt;&gt;&gt;&gt;&gt; - inclusion of String delimiter inside the String<br>&gt;&gt;&gt;&gt;&gt; - concat of backslash/no backslash version. Bash example echo &#39;echo &quot;$BASH&quot; shows &#39;&quot;$BASH&quot;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I’m still trying to find back the mail thread crumbs on these topics, since before restarting the discussion in these topics, the previous one should be properly summarized; unless such summary already exist.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think supporting interpolation is important. Both Perl and Ruby support it, and I&#39;m sure there are other languages. One thing I forgot to put into the proposal: an option to disable interpolation or limit it to single pass.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Looking ahead at the other responses, Chris Lattner has suggested that the proposal would have more traction if we can find a way to fold this into Swift&#39;s pattern matching. I can&#39;t say as I disagree, as this makes regular expression more Swifty.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Regards,<br>&gt;&gt;&gt;&gt;&gt; Dany<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Dany<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Le 31 janv. 2016 à 12:18, Patrick Gili via swift-evolution &lt;swift-evolution at swift.org &lt;&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Here is the link to the proposal on GitHub:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://github.com/gili-patrick-r/swift-evolution/blob/master/proposals/NNNN-regular-expression-literals.md &lt;https://github.com/gili-patrick-r/swift-evolution/blob/master/proposals/NNNN-regular-expression-literals.md&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Patrick<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt;   -- Howard.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt;   -- Howard.<br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt;   -- Howard.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/4dd122cf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d042be5dcfe90e649f760303af3e429?s=50"></div><header><strong>Empower String type with regular expression</strong> from <string>Jens Persson</string> &lt;jens at bitcycle.com&gt;<p>February  6, 2016 at 04:00:00pm</p></header><div class="content"><p>I just stumbled on some interesting articles and notes about implementing<br>regular expressions, written by Russ Cox (Google, Go):<br>https://swtch.com/~rsc/regexp/<br></p><p><br>On Wed, Feb 3, 2016 at 2:06 PM, Patrick Gili via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hi Howard,<br>&gt;<br>&gt; I&#39;m not saying the two methods don&#39;t have to be exclusive. However, you<br>&gt; asked us to consider converting regex literals into Swift Verbal<br>&gt; Expressions. My response highlighted potential issues with this approach.<br>&gt;<br>&gt; Cheers,<br>&gt; -Patrick<br>&gt;<br>&gt; On Feb 2, 2016, at 6:53 PM, Howard Lovatt &lt;howard.lovatt at gmail.com&gt; wrote:<br>&gt;<br>&gt; I don&#39;t see that the two have to be exclusive. If the design of the regex<br>&gt; literal is suitable for both a traditional NSRegularExpression and a verbal<br>&gt; type implementation then the two can co-exist. It can also be staged, so<br>&gt; that a literal can be introduced first with a bridge to legacy<br>&gt; NSRegularExpression and then later a verbal implementation could be added.<br>&gt; The key is to design a liberal that is future proofed.<br>&gt;<br>&gt; On 3 February 2016 at 10:33, Patrick Gili &lt;gili.patrick.r at gili-labs.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; I don&#39;t feel good about this direction for the following reasons:<br>&gt;&gt; 1) Complexity<br>&gt;&gt; 2) Maturity? I don&#39;t know how Verbal Expressions has been implemented.<br>&gt;&gt; Does it leverage mature regex open source? Or, has it been written from<br>&gt;&gt; scratch?<br>&gt;&gt; 3) Performance? Compiling a regex literal typically results in a FSM of a<br>&gt;&gt; sort, optimized to parse strings. I wouldn&#39;t think that converting a regex<br>&gt;&gt; literal to Verbal Expressions would yield great performance every time a<br>&gt;&gt; match or substitution is done.<br>&gt;&gt;<br>&gt;&gt; -Patrick<br>&gt;&gt;<br>&gt;&gt; On Feb 2, 2016, at 5:55 PM, Howard Lovatt &lt;howard.lovatt at gmail.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; The difference is that I am proposing supporting both verbal expressions<br>&gt;&gt; and regex literals and that - literals are converted to verbals and the<br>&gt;&gt; processing happens at the verbal level. The reason for this is that verbals<br>&gt;&gt; are easy to handle programmatically whilst literals are great for quickly<br>&gt;&gt; specifying a regex.<br>&gt;&gt;<br>&gt;&gt; On Tuesday, 2 February 2016, Patrick Gili &lt;gili.patrick.r at gili-labs.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Hi Howard,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I don&#39;t see how this is very different from the Swift Verbal<br>&gt;&gt;&gt; Expressions. It would suffer from the same disadvantages I have stated<br>&gt;&gt;&gt; previously.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt; -Patrick<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Feb 2, 2016, at 1:51 AM, Howard Lovatt via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Others have suggested a programatic regex instead of a regex literal,<br>&gt;&gt;&gt; how about doing both? Something like:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; enum RegexElement {<br>&gt;&gt;&gt;     case capture(name: String, value: String)<br>&gt;&gt;&gt;     case special(Special)<br>&gt;&gt;&gt;     // ...<br>&gt;&gt;&gt;     enum Special: String {<br>&gt;&gt;&gt;         case startOfLine = &quot;^&quot;<br>&gt;&gt;&gt;         // ...<br>&gt;&gt;&gt;         case endOfLine = &quot;$&quot;<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; // Define a regexLiteral syntax that the compiler understands that is of<br>&gt;&gt;&gt; type Regex and consists of String representations of RegexElements, e.g.<br>&gt;&gt;&gt; using forward slash:<br>&gt;&gt;&gt; //    /&lt;RegexElements&gt;*/<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; struct Regex: CustomStringConvertible { // Compiled, immutable, thread<br>&gt;&gt;&gt; safe, and bridged to NSRegularExpression<br>&gt;&gt;&gt;     // ... internal compiled representation<br>&gt;&gt;&gt;     let elements: [RegexElement]<br>&gt;&gt;&gt;     var description: String {<br>&gt;&gt;&gt;         return RegexElement.Special.startOfLine.rawValue // Example.<br>&gt;&gt;&gt; Really returns all the elements converted back to a string<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     init(_ elements: RegexElement...) {<br>&gt;&gt;&gt;         self.elements = elements // Example. Really also compiles the<br>&gt;&gt;&gt; expression<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     // init(regexLiteral regex: Regex) {<br>&gt;&gt;&gt;     // init(concatAll regexes: Regex...) {<br>&gt;&gt;&gt;     // init(fromString string: String) {<br>&gt;&gt;&gt;     // ... more inits<br>&gt;&gt;&gt;     func map&lt;T&gt;(input: String, @noescape mapper: (element: RegexElement)<br>&gt;&gt;&gt; throws -&gt; T) rethrows -&gt; [T] {<br>&gt;&gt;&gt;         return [try mapper(element: RegexElement.special(.startOfLine))]<br>&gt;&gt;&gt; // Example. Really does the matching<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     // func flatMap&lt;T&gt;(input: String, @noescape mapper: (element:<br>&gt;&gt;&gt; RegexElement) throws -&gt; T?) rethrows -&gt; [T] {<br>&gt;&gt;&gt;     // func flatMap&lt;S: SequenceType&gt;(input: String, @noescape mapper:<br>&gt;&gt;&gt; (element: RegexElement) throws -&gt; S) rethrows -&gt; [S.Generator.Element] {<br>&gt;&gt;&gt;     // func forEach(input: String, @noescape eacher: (element:<br>&gt;&gt;&gt; RegexElement) throws -&gt; Void) rethrows {<br>&gt;&gt;&gt;     // ... more funcs<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let regex = Regex(RegexElement.special(.startOfLine)) // Normally a<br>&gt;&gt;&gt; regex literal<br>&gt;&gt;&gt; let asStringArray = regex.map(&quot;Example&quot;) { element -&gt; String in //<br>&gt;&gt;&gt; Returns `[&quot;^&quot;]` in example<br>&gt;&gt;&gt;     switch element {<br>&gt;&gt;&gt;     case let .capture(_, v): return v<br>&gt;&gt;&gt;     case let .special(s): return s.rawValue<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The advantages are:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    1.   We get a literal type for convenience.<br>&gt;&gt;&gt;    2.   We get a programatic type when we need to manipulate regexes.<br>&gt;&gt;&gt;    3.   Breaking the regex matches into the enum defined elements of<br>&gt;&gt;&gt;    the regex works well with Swift pattern matching.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; (Above is a very rough sketch!)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On 2 February 2016 at 16:44, Thorsten Seitz via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Something like Scala&#39;s extractors or F#&#39;s Active Patterns would be most<br>&gt;&gt;&gt;&gt; welcome to generalize pattern matching.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; http://docs.scala-lang.org/tutorials/tour/extractor-objects.html<br>&gt;&gt;&gt;&gt; https://en.m.wikibooks.org/wiki/F_Sharp_Programming/Active_Patterns<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Am 01.02.2016 um 15:46 schrieb James Campbell via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; It would be great if we could create a generic way of making this<br>&gt;&gt;&gt;&gt; swifty. You may let say want to implement a matching system for structure<br>&gt;&gt;&gt;&gt; like JSON or XML (i.e XQuery).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; *___________________________________*<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; *James⎥Lead Engineer*<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; *james at supmenow.com⎥supmenow.com &lt;http://supmenow.com/&gt;*<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; *Sup*<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; *Runway East *<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; *10 Finsbury Square*<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; *London*<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; * EC2A 1AF *<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Mon, Feb 1, 2016 at 2:43 PM, Patrick Gili via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Hi Dany,<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; My response is inline below.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt;&gt; -Patrick<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Jan 31, 2016, at 8:56 PM, Dany St-Amant &lt;dsa.mls at icloud.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Le 31 janv. 2016 à 16:46, Patrick Gili &lt;gili.patrick.r at gili-labs.com&gt;<br>&gt;&gt;&gt;&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Hi Dany,<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Please find my response inline below.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt;&gt; -Patrick<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Jan 31, 2016, at 3:46 PM, Dany St-Amant via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; This seem to be two proposals in one:<br>&gt;&gt;&gt;&gt;&gt; 1. Initialize NSRegularExpression with a single String which includes<br>&gt;&gt;&gt;&gt;&gt; options<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; The ultimate goal based on the earlier mail in the thread seems to be<br>&gt;&gt;&gt;&gt;&gt; able in a future proposal do thing like: string ~= replacePattern, if<br>&gt;&gt;&gt;&gt;&gt; string =~ pattern, decoupled from the legacy Obj-C. Isn’t<br>&gt;&gt;&gt;&gt;&gt; NSRegularExpression part of the legacy? The conversion of the literal<br>&gt;&gt;&gt;&gt;&gt; string as regular expression should probably part of the proposal for these<br>&gt;&gt;&gt;&gt;&gt; operators; as this is the time we will know how we want the text to be<br>&gt;&gt;&gt;&gt;&gt; interpreted.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I don&#39;t see any evidence of NSRegularExpression becoming part of any<br>&gt;&gt;&gt;&gt;&gt; legacy. Given SE-005, SE-006, and SE-023, the name is probably changing<br>&gt;&gt;&gt;&gt;&gt; from NSRegularExpression to RegularExpression. However, I don&#39;t think the<br>&gt;&gt;&gt;&gt;&gt; definition of the class will change, only the name.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I would like to see an operator regular expression matching operator,<br>&gt;&gt;&gt;&gt;&gt; like Ruby and Perl. I was trying to keep the proposal a minimal increment<br>&gt;&gt;&gt;&gt;&gt; that would buy the biggest bang for the buck. We can already accomplish<br>&gt;&gt;&gt;&gt;&gt; much of what other languages can do with regard to regular expression.<br>&gt;&gt;&gt;&gt;&gt; However, the notion of a regular expression isn&#39;t something we can work<br>&gt;&gt;&gt;&gt;&gt; around with custom library today. Can you suggest something addition that<br>&gt;&gt;&gt;&gt;&gt; should be in the proposal?<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Splitting proposal in smaller ones have its advantage, but here I am<br>&gt;&gt;&gt;&gt;&gt; just wondering if we are sure that these future operation will use the<br>&gt;&gt;&gt;&gt;&gt; NSRegularExpression/RegularExpression. And does the currently selected<br>&gt;&gt;&gt;&gt;&gt; syntax allow for future expansion, it would be bad to introduce something<br>&gt;&gt;&gt;&gt;&gt;  that need to be torn away or changed in an incompatible way, once we<br>&gt;&gt;&gt;&gt;&gt; really start to use them in their final location.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; The proposal is focused on the search, but seem to skip the<br>&gt;&gt;&gt;&gt;&gt; substitution; I am unable to see an option to replace all matches instead<br>&gt;&gt;&gt;&gt;&gt; of the first one only in the proposal. I, as many other, would expect<br>&gt;&gt;&gt;&gt;&gt; regular expression in a language to also support substitution.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; As for addition to the proposal, the processing of the string could be<br>&gt;&gt;&gt;&gt;&gt; support for any character (within some limit) for the slash delimiter. With<br>&gt;&gt;&gt;&gt;&gt; sed, when replacing  path component, one can do: echo $PWD | sed -e<br>&gt;&gt;&gt;&gt;&gt; &quot;s:^/usr/local/bin:/opt/share/bin:g&quot;, instead of escaping every<br>&gt;&gt;&gt;&gt;&gt; single slashes. Which is really handy to make thing easier to read.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Also, putting aside that I think \(scheme) should not be interpreted<br>&gt;&gt;&gt;&gt;&gt; in the example, with a syntax allowing such interpretation the variable<br>&gt;&gt;&gt;&gt;&gt; should be processed to generate proper escaping. If one is to use<br>&gt;&gt;&gt;&gt;&gt; \(filename) you get &quot;main.c&quot;, but one must use \(filename.escaped()) to get<br>&gt;&gt;&gt;&gt;&gt; the proper &quot;main\.c&quot; to avoid matching &quot;mainac&quot;. The String.escaped() must<br>&gt;&gt;&gt;&gt;&gt; be in a format compatible with the format used when converting the regular<br>&gt;&gt;&gt;&gt;&gt; expression into NSRegularExpression (not sure if the two syntax are the<br>&gt;&gt;&gt;&gt;&gt; same; I think that at least the handling of /  may differ)<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I agree. Perhaps I went too far with keeping the proposal<br>&gt;&gt;&gt;&gt;&gt; short-and-sweet. Especially when you consider the rich syntax that Perl<br>&gt;&gt;&gt;&gt;&gt; supports for substitution.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; 2. Easily create a String without escaping (\n is not linefeed, but \<br>&gt;&gt;&gt;&gt;&gt; and n)<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; The ability to not interpret the backslash as escape can be useful in<br>&gt;&gt;&gt;&gt;&gt; other scenario that creating a NSRegularExpression; like creating a Windows<br>&gt;&gt;&gt;&gt;&gt; pathname, or creating regular expression which are then given to external<br>&gt;&gt;&gt;&gt;&gt; tool.  So this part of the proposal should probably be generalized.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Generalize it for what? If you&#39;re thinking along the line of raw<br>&gt;&gt;&gt;&gt;&gt; strings, I agree that we need this capability, as well as multi-line string<br>&gt;&gt;&gt;&gt;&gt; literals. However, I just soon we have separate proposals for this.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; My point/opinion here, is that a regular expressions are just a String<br>&gt;&gt;&gt;&gt;&gt; which are then interpreted; the same way as &quot;Good Morning&quot;, &quot;Bonjour&quot;, or<br>&gt;&gt;&gt;&gt;&gt; &quot;Marhaba&quot; (even when using the arabic script) are just String when you<br>&gt;&gt;&gt;&gt;&gt; assign then to a variable in Swift, and then interpreted by the intended<br>&gt;&gt;&gt;&gt;&gt; user. They are not String, frenchString, rigthToLeftString. So I do not see<br>&gt;&gt;&gt;&gt;&gt; why a regular expression should have privileged treatment and have its own<br>&gt;&gt;&gt;&gt;&gt; language level syntax. The only difference when writing regular expression,<br>&gt;&gt;&gt;&gt;&gt; or Windows pathname, or any String with a syntax with heavily uses of<br>&gt;&gt;&gt;&gt;&gt; backslashes, is that one may want to disable the special meaning of the<br>&gt;&gt;&gt;&gt;&gt; backslashes, to make thing more readable.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On the page of geeky-ing the String there’s four main part IMHO<br>&gt;&gt;&gt;&gt;&gt; - multi-line support<br>&gt;&gt;&gt;&gt;&gt; - no backslash escaping version (which should include no processing<br>&gt;&gt;&gt;&gt;&gt; the \(variable) format)<br>&gt;&gt;&gt;&gt;&gt; - inclusion of String delimiter inside the String<br>&gt;&gt;&gt;&gt;&gt; - concat of backslash/no backslash version. Bash example echo &#39;echo<br>&gt;&gt;&gt;&gt;&gt; &quot;$BASH&quot; shows &#39;&quot;$BASH&quot;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I’m still trying to find back the mail thread crumbs on these topics,<br>&gt;&gt;&gt;&gt;&gt; since before restarting the discussion in these topics, the previous one<br>&gt;&gt;&gt;&gt;&gt; should be properly summarized; unless such summary already exist.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I think supporting interpolation is important. Both Perl and Ruby<br>&gt;&gt;&gt;&gt;&gt; support it, and I&#39;m sure there are other languages. One thing I forgot to<br>&gt;&gt;&gt;&gt;&gt; put into the proposal: an option to disable interpolation or limit it to<br>&gt;&gt;&gt;&gt;&gt; single pass.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Looking ahead at the other responses, Chris Lattner has suggested that<br>&gt;&gt;&gt;&gt;&gt; the proposal would have more traction if we can find a way to fold this<br>&gt;&gt;&gt;&gt;&gt; into Swift&#39;s pattern matching. I can&#39;t say as I disagree, as this makes<br>&gt;&gt;&gt;&gt;&gt; regular expression more Swifty.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Regards,<br>&gt;&gt;&gt;&gt;&gt; Dany<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Dany<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Le 31 janv. 2016 à 12:18, Patrick Gili via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Here is the link to the proposal on GitHub:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; https://github.com/gili-patrick-r/swift-evolution/blob/master/proposals/NNNN-regular-expression-literals.md<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt;&gt; -Patrick<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt;   -- Howard.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt;   -- Howard.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt;   -- Howard.<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p><p><br>-- <br>bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>http://www.bitcycle.com/<br>Phone: +46-73-753 24 62<br>E-mail: jens at bitcycle.com<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160206/57e85f6e/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Empower String type with regular expression</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>February  2, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Feb 1, 2016, at 9:44 PM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Something like Scala&#39;s extractors or F#&#39;s Active Patterns would be most welcome to generalize pattern matching.<br>&gt; <br>&gt; http://docs.scala-lang.org/tutorials/tour/extractor-objects.html &lt;http://docs.scala-lang.org/tutorials/tour/extractor-objects.html&gt;<br>&gt; https://en.m.wikibooks.org/wiki/F_Sharp_Programming/Active_Patterns &lt;https://en.m.wikibooks.org/wiki/F_Sharp_Programming/Active_Patterns&gt;<br>This is pretty interesting, and I agree with the general observation here: there is a duality between printing and parsing that should be modeled and exploited.<br></p><p>One of the things that we discussed in the time leading up to Swift 1 (but then pushed off and never came back to) was model for doing standardized formatted printing - capturing the power and expressiveness of printf, without the problems it entails.  A sketch of the proposal is here:<br>https://github.com/apple/swift/blob/master/docs/TextFormatting.rst &lt;https://github.com/apple/swift/blob/master/docs/TextFormatting.rst&gt;<br></p><p>The pertinent idea here is that types can have a default printing rule (e.g. integers print in decimal) but then can opt into providing a more powerful formatting model by supporting modifier characters (for example “x” for an integer could mean “hexadecimal”).  This would be protocol based, so arbitrary types could participate.<br></p><p>If you bring the same concept to regex parsing, I think it would make a lot of sense for primitive types to support “default” regex rules (e.g. integers would default to /[0-9]+/ ) and then have modifier characters that support other standard modes for them (e.g. x for hexadecimal).  This would obviously want to be extensible to arbitrary types, so that (e.g.) NSDate could support the format families that make sense.<br></p><p>Going with this would address one of my major gripes with regex’s used in practice, which is that they are a huge violation of the DRY principle, and that reuse of regex patterns almost never happens.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160202/40320666/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4030f7e8f6b6d3c09d10ec12691773c1?s=50"></div><header><strong>Empower String type with regular expression</strong> from <string>John Randolph</string> &lt;jcr at mac.com&gt;<p>February  3, 2016 at 03:00:00am</p></header><div class="content"><p>&gt; On Feb 2, 2016, at 9:29 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; If you bring the same concept to regex parsing, I think it would make a lot of sense for primitive types to support “default” regex rules (e.g. integers would default to /[0-9]+/ ) and then have modifier characters that support other standard modes for them (e.g. x for hexadecimal). <br></p><p><br>I really like this idea.   It would be very nice to be able to describe a regex like “(name:String),  (dateOfBirth: NSDate), (notes: String), (EOL)”   and have the details of what characters constitute each of these types be specified on a per-type basis.  NSScanner can do something a bit like this, but it requires quite a bit of care and feeding.<br></p><p>-jcr<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/96f9daa9/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05e222e6ef4d84013bb3baeb0e25c90b?s=50"></div><header><strong>Empower String type with regular expression</strong> from <string>Patrick Gili</string> &lt;gili.patrick.r at gili-labs.com&gt;<p>February  7, 2016 at 05:00:00pm</p></header><div class="content"><p>Hi Chris,<br></p><p>I have been reading the documentation and design notes for regular expressions in Perl6. Thank you for the pointer to the documentation. I really like what the Perl6 community has done with regular expressions (I like the notion of grammars too).<br></p><p>Given the insights you shared below, I imagine we can address your gripe with regular expressions by implementing something like Perl6&#39;s named regular expressions, which easily facilitates reuse.<br></p><p>To further encourage reuse, we could introduce the notion of &quot;standardized parsing&quot; of data types, much in the same way that Swift already supports the notion of &quot;standardized formatted printing&quot;.<br></p><p>To achieve this, we could introduce a protocol, similar to CustomStringConvertible (or maybe extend CustomStringConvertible) that would not define a method to convert a string to the data type, but define the regular expression that facilitates the conversion. The protocol could also facilitate the reuse of the regular expression in other regular expression literals.<br></p><p>Cheers,<br>-Patrick<br></p><p>Sent from my iPad Pro<br></p><p>&gt; On Feb 3, 2016, at 12:29 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 1, 2016, at 9:44 PM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Something like Scala&#39;s extractors or F#&#39;s Active Patterns would be most welcome to generalize pattern matching.<br>&gt;&gt; <br>&gt;&gt; http://docs.scala-lang.org/tutorials/tour/extractor-objects.html<br>&gt;&gt; https://en.m.wikibooks.org/wiki/F_Sharp_Programming/Active_Patterns<br>&gt; <br>&gt; This is pretty interesting, and I agree with the general observation here: there is a duality between printing and parsing that should be modeled and exploited.<br>&gt; <br>&gt; One of the things that we discussed in the time leading up to Swift 1 (but then pushed off and never came back to) was model for doing standardized formatted printing - capturing the power and expressiveness of printf, without the problems it entails.  A sketch of the proposal is here:<br>&gt; https://github.com/apple/swift/blob/master/docs/TextFormatting.rst<br>&gt; <br>&gt; The pertinent idea here is that types can have a default printing rule (e.g. integers print in decimal) but then can opt into providing a more powerful formatting model by supporting modifier characters (for example “x” for an integer could mean “hexadecimal”).  This would be protocol based, so arbitrary types could participate.<br>&gt; <br>&gt; If you bring the same concept to regex parsing, I think it would make a lot of sense for primitive types to support “default” regex rules (e.g. integers would default to /[0-9]+/ ) and then have modifier characters that support other standard modes for them (e.g. x for hexadecimal).  This would obviously want to be extensible to arbitrary types, so that (e.g.) NSDate could support the format families that make sense.<br>&gt; <br>&gt; Going with this would address one of my major gripes with regex’s used in practice, which is that they are a huge violation of the DRY principle, and that reuse of regex patterns almost never happens.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160207/5b97daf9/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05e222e6ef4d84013bb3baeb0e25c90b?s=50"></div><header><strong>Empower String type with regular expression</strong> from <string>Patrick Gili</string> &lt;gili.patrick.r at gili-labs.com&gt;<p>January 31, 2016 at 01:00:00pm</p></header><div class="content"><p>There is one thing I want to discuss with regard to this proposal. I think NSRegularExpression is part of the standard library. If Swift were to support regular expression literal, wouldn&#39;t it make sense to move NSRegularExpression to the foundation?<br></p><p>Cheers,<br>-Patrick<br></p><p>&gt; On Jan 31, 2016, at 11:32 AM, Patrick Gili &lt;gili.patrick.r at gili-labs.com&gt; wrote:<br>&gt; <br>&gt; There have been several threads that have discussed the notion of a regular expression literals. However, I didn&#39;t see anyone putting together a formal proposal, and hence I took the liberty to do so. I would appreciate discussion and comments on the proposal:<br>&gt; <br>&gt; Regular Expression Literals<br>&gt; Proposal: [SE-NNNN] (https://github/apple/swift-evolution/blob/master/proposals/NNNN-name.md &lt;https://github/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;)<br>&gt; Author: Patrick Gili (https://github.com/gili-patrick-r &lt;https://github.com/gili-patrick-r&gt;)<br>&gt; Status: Awaiting review<br>&gt; Review manager: TBD<br>&gt; Introduction<br>&gt; The Swift language has no native support for regular expressions, which makes working with regular expressions in Swift awkward, tedious, and error prone. This proposal describes the addition of regular expressions literals to Swift.<br>&gt; <br>&gt; Swift-evolution thread: Empower String type with regular expression &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151228/005126.html&gt;<br>&gt; Motivation<br>&gt; The definition of a pattern used by a regular expression is complicated by the fact that Swift does not support raw string literals (i.e., string literals that do not process character escapes or interpolation) or regular expression literals similar to Perl or Ruby. Rather, Swift only supports C-style string literals with support for interpolation. C-style string literals require a backslash to escape a backslash. The patterns representing regular expressions make frequent use of the backslash, and hence patterns represented by a Swift string literal become unreadable and difficult to maintain. For example, consider the following pattern to match and parse URLs:<br>&gt; <br>&gt; ^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$<br>&gt; To define this pattern in Swift, an application needs to define a string, such as<br>&gt; <br>&gt; let pattern = &quot;^(https?:\\/\\/)?([\\da-z\\.-]+)\\.([a-z\\.]{2,6})([\\/\\w &lt;smb://///w&gt; \\.- &lt;smb://.-&gt;]*)*\\/?$&quot;<br>&gt; This later is obviously difficult to read and maintain.<br>&gt; <br>&gt; Proposed solution<br>&gt; The proposed solution is to add regular expression literals to Swift, similar to regular expression literal support by other languages, such as Perl and Ruby. Regular expression literals differ from raw string literals in two primary ways. First, regular expression literals support string interpolation of the pattern, which allows an application to construct a regular expression at run-time. Second, a regular expression literal creates an instance of a NSRegularExpression, rather than an instance of String. The following example declares a regular expression for the purpose of matching and parsing URIs with a specified scheme:<br>&gt; <br>&gt; let scheme = &quot;https&quot;<br>&gt; let urlRegex = /^(\(scheme)?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/<br>&gt; To make regular expression literals effective, it must be possible to replace the creation of any instance of NSRegularExpression. The initializer for NSRegularExpression accepts a string describing the pattern and a set of options. To support these options, a regular expression literal accepts a list of zero or more options after the delimiter closing the pattern. For example, consider a regular expression to match and parse email addresses.<br>&gt; <br>&gt; let emailRegex = /^([a-z0-9_\.-]+)@([\da-z\.-]+)\.([a-z\.]{2,6})$/<br>&gt; This regular expression will match &quot;john.appleseed at apple.com &lt;mailto:john.appleseed at apple.com&gt;&quot;&quot;, but not &quot;JOHN.APPLESEED at APPLE.COM &lt;mailto:JOHN.APPLESEED at apple.com&gt;&quot;. The regular expression has to allow for this, as email addresses are not case sensitive. Rather than add the complexity to the pattern to account for this, the following example achieves the same:<br>&gt; <br>&gt; let emailRegex = /^([a-z0-9_\.-]+)@([\da-z\.-]+)\.([a-z\.]{2,6})$/i<br>&gt; In this case, the &quot;i&quot; following the delimiter closing the pattern maps to RegularExpressionOption.CaseInsensitive.<br>&gt; <br>&gt; Detailed design<br>&gt; The following modification to the grammar of a literal adds support for regular expression literals:<br>&gt; <br>&gt; literal → numeric-literal | string-literal | boolean-literal | regex-literal | nil-literal<br>&gt; <br>&gt; The following grammar describes a regular expression literal:<br>&gt; <br>&gt; regex-literal → static-regex-literal | interpolated-regex-literal<br>&gt; <br>&gt; static-regex-literal → / patternopt / regex-optionsopt<br>&gt; pattern → pattern_item patternopt<br>&gt; pattern_item → any Unicode scalar value except /, U+000A, or U+000D<br>&gt; <br>&gt; interpolated-string-literal → / interpolated-patternopt / regex-optionsopt<br>&gt; interpolated_pattern → interpolated_pattern_item interpolated_patternopt<br>&gt; interpolated_pattern_item → ( expression ) | pattern_item<br>&gt; <br>&gt; regex-options → regex-option | regex-optionopt<br>&gt; regex_option → i | x | q | s | m | d | b<br>&gt; <br>&gt; The following table summarize the regular expression options:<br>&gt; <br>&gt; Option 	RegularExpressionOption <br>&gt; i 	CaseInsensitive <br>&gt; x 	AllowCommentsAndWhitespace <br>&gt; q 	IgnoreMetacharacters <br>&gt; s 	DotMatchesLineSeparations <br>&gt; m 	AnchorsMatchLines <br>&gt; d 	UseUnixLineSeparators <br>&gt; b 	UseUnicodeWordBoundaries <br>&gt; Impact on existing code<br>&gt; The use of regular expression literals is opt-in, and hence there is no impact to existing code.<br>&gt; <br>&gt; Alternatives considered<br>&gt; There have been several threads on the swift-evoluation mailing list that have discussed alternatives to regular expression literals.<br>&gt; <br>&gt; String literal suffixes for defining types &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002193.html&gt; discussed string literals with a single character appended after the closing delimiter to denote the type. For example, the string literal r&quot;\d+&quot; in Python denotes a regular expression literal. However, this approach suffers from two disadvantages: 1) it does not support string interpolation in the pattern, and 2) it uses double-quotes for the delimiter, which appears more frequently in regular expressions than the forward slash.<br>&gt; <br>&gt; Muli-line string literals &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002325.html&gt; discussed string literals spanning more than one line. This would be a worthy addition to the regular expression literal discussed in this proposal. We should consider modifying the grammar to support this. However, I wanted to introduce changes incrementally to maintain focus.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160131/1bfd1975/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05e222e6ef4d84013bb3baeb0e25c90b?s=50"></div><header><strong>Empower String type with regular expression</strong> from <string>Patrick Gili</string> &lt;gili.patrick.r at gili-labs.com&gt;<p>January 31, 2016 at 01:00:00pm</p></header><div class="content"><p>Never mind, NSRegularExpression is in the Foundation.<br></p><p>&gt; On Jan 31, 2016, at 1:18 PM, Patrick Gili &lt;gili.patrick.r at gili-labs.com&gt; wrote:<br>&gt; <br>&gt; There is one thing I want to discuss with regard to this proposal. I think NSRegularExpression is part of the standard library. If Swift were to support regular expression literal, wouldn&#39;t it make sense to move NSRegularExpression to the foundation?<br>&gt; <br>&gt; Cheers,<br>&gt; -Patrick<br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Empower String type with regular expression</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 31, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Jan 31, 2016, at 8:32 AM, Patrick Gili via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; There have been several threads that have discussed the notion of a regular expression literals. However, I didn&#39;t see anyone putting together a formal proposal, and hence I took the liberty to do so. I would appreciate discussion and comments on the proposal:<br></p><p>I am +1 on the concept of adding regex literals to Swift, but -1 on this proposal.<br></p><p>Specifically, instead of introducing regex literals, I’d suggest that you investigate introducing regex’s to the pattern grammar, which is what Swift uses for matching already.  Regex’s should be usable in the cases of a switch, for example.  Similarly, they should be able to bind variables directly to subpatterns.<br></p><p>Further, I highly recommend checking out Perl 6’s regular expressions.  They are a community that has had an obsessive passion for regular expressions, and in Perl 6 they were given the chance to reinvent the wheel based on what they learned.  What they came up with is very powerful, and pretty good all around.<br></p><p>-Chris<br></p><p><br>&gt; <br>&gt; Regular Expression Literals<br>&gt; Proposal: [SE-NNNN] (https://github/apple/swift-evolution/blob/master/proposals/NNNN-name.md &lt;https://github/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;)<br>&gt; Author: Patrick Gili (https://github.com/gili-patrick-r &lt;https://github.com/gili-patrick-r&gt;)<br>&gt; Status: Awaiting review<br>&gt; Review manager: TBD<br>&gt; Introduction<br>&gt; The Swift language has no native support for regular expressions, which makes working with regular expressions in Swift awkward, tedious, and error prone. This proposal describes the addition of regular expressions literals to Swift.<br>&gt; <br>&gt; Swift-evolution thread: Empower String type with regular expression &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151228/005126.html&gt;<br>&gt; Motivation<br>&gt; The definition of a pattern used by a regular expression is complicated by the fact that Swift does not support raw string literals (i.e., string literals that do not process character escapes or interpolation) or regular expression literals similar to Perl or Ruby. Rather, Swift only supports C-style string literals with support for interpolation. C-style string literals require a backslash to escape a backslash. The patterns representing regular expressions make frequent use of the backslash, and hence patterns represented by a Swift string literal become unreadable and difficult to maintain. For example, consider the following pattern to match and parse URLs:<br>&gt; <br>&gt; ^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$<br>&gt; To define this pattern in Swift, an application needs to define a string, such as<br>&gt; <br>&gt; let pattern = &quot;^(https?:\\/\\/)?([\\da-z\\.-]+)\\.([a-z\\.]{2,6})([\\/\\w &lt;smb://///w&gt; \\.- &lt;smb://.-&gt;]*)*\\/?$&quot;<br>&gt; This later is obviously difficult to read and maintain.<br>&gt; <br>&gt; Proposed solution<br>&gt; The proposed solution is to add regular expression literals to Swift, similar to regular expression literal support by other languages, such as Perl and Ruby. Regular expression literals differ from raw string literals in two primary ways. First, regular expression literals support string interpolation of the pattern, which allows an application to construct a regular expression at run-time. Second, a regular expression literal creates an instance of a NSRegularExpression, rather than an instance of String. The following example declares a regular expression for the purpose of matching and parsing URIs with a specified scheme:<br>&gt; <br>&gt; let scheme = &quot;https&quot;<br>&gt; let urlRegex = /^(\(scheme)?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/<br>&gt; To make regular expression literals effective, it must be possible to replace the creation of any instance of NSRegularExpression. The initializer for NSRegularExpression accepts a string describing the pattern and a set of options. To support these options, a regular expression literal accepts a list of zero or more options after the delimiter closing the pattern. For example, consider a regular expression to match and parse email addresses.<br>&gt; <br>&gt; let emailRegex = /^([a-z0-9_\.-]+)@([\da-z\.-]+)\.([a-z\.]{2,6})$/<br>&gt; This regular expression will match &quot;john.appleseed at apple.com &lt;mailto:john.appleseed at apple.com&gt;&quot;&quot;, but not &quot;JOHN.APPLESEED at APPLE.COM &lt;mailto:JOHN.APPLESEED at apple.com&gt;&quot;. The regular expression has to allow for this, as email addresses are not case sensitive. Rather than add the complexity to the pattern to account for this, the following example achieves the same:<br>&gt; <br>&gt; let emailRegex = /^([a-z0-9_\.-]+)@([\da-z\.-]+)\.([a-z\.]{2,6})$/i<br>&gt; In this case, the &quot;i&quot; following the delimiter closing the pattern maps to RegularExpressionOption.CaseInsensitive.<br>&gt; <br>&gt; Detailed design<br>&gt; The following modification to the grammar of a literal adds support for regular expression literals:<br>&gt; <br>&gt; literal → numeric-literal | string-literal | boolean-literal | regex-literal | nil-literal<br>&gt; <br>&gt; The following grammar describes a regular expression literal:<br>&gt; <br>&gt; regex-literal → static-regex-literal | interpolated-regex-literal<br>&gt; <br>&gt; static-regex-literal → / patternopt / regex-optionsopt<br>&gt; pattern → pattern_item patternopt<br>&gt; pattern_item → any Unicode scalar value except /, U+000A, or U+000D<br>&gt; <br>&gt; interpolated-string-literal → / interpolated-patternopt / regex-optionsopt<br>&gt; interpolated_pattern → interpolated_pattern_item interpolated_patternopt<br>&gt; interpolated_pattern_item → ( expression ) | pattern_item<br>&gt; <br>&gt; regex-options → regex-option | regex-optionopt<br>&gt; regex_option → i | x | q | s | m | d | b<br>&gt; <br>&gt; The following table summarize the regular expression options:<br>&gt; <br>&gt; Option 	RegularExpressionOption <br>&gt; i 	CaseInsensitive <br>&gt; x 	AllowCommentsAndWhitespace <br>&gt; q 	IgnoreMetacharacters <br>&gt; s 	DotMatchesLineSeparations <br>&gt; m 	AnchorsMatchLines <br>&gt; d 	UseUnixLineSeparators <br>&gt; b 	UseUnicodeWordBoundaries <br>&gt; Impact on existing code<br>&gt; The use of regular expression literals is opt-in, and hence there is no impact to existing code.<br>&gt; <br>&gt; Alternatives considered<br>&gt; There have been several threads on the swift-evoluation mailing list that have discussed alternatives to regular expression literals.<br>&gt; <br>&gt; String literal suffixes for defining types &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002193.html&gt; discussed string literals with a single character appended after the closing delimiter to denote the type. For example, the string literal r&quot;\d+&quot; in Python denotes a regular expression literal. However, this approach suffers from two disadvantages: 1) it does not support string interpolation in the pattern, and 2) it uses double-quotes for the delimiter, which appears more frequently in regular expressions than the forward slash.<br>&gt; <br>&gt; Muli-line string literals &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002325.html&gt; discussed string literals spanning more than one line. This would be a worthy addition to the regular expression literal discussed in this proposal. We should consider modifying the grammar to support this. However, I wanted to introduce changes incrementally to maintain focus.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160131/e45d6682/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4030f7e8f6b6d3c09d10ec12691773c1?s=50"></div><header><strong>Empower String type with regular expression</strong> from <string>John Randolph</string> &lt;jcr at mac.com&gt;<p>January 31, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Jan 31, 2016, at 7:39 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 31, 2016, at 8:32 AM, Patrick Gili via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; There have been several threads that have discussed the notion of a regular expression literals. However, I didn&#39;t see anyone putting together a formal proposal, and hence I took the liberty to do so. I would appreciate discussion and comments on the proposal:<br>&gt; <br>&gt; I am +1 on the concept of adding regex literals to Swift, but -1 on this proposal.<br>&gt; <br>&gt; Specifically, instead of introducing regex literals, I’d suggest that you investigate introducing regex’s to the pattern grammar, which is what Swift uses for matching already.  Regex’s should be usable in the cases of a switch, for example.  Similarly, they should be able to bind variables directly to subpatterns.<br>&gt; <br>&gt; Further, I highly recommend checking out Perl 6’s regular expressions.  They are a community that has had an obsessive passion for regular expressions, and in Perl 6 they were given the chance to reinvent the wheel based on what they learned.  What they came up with is very powerful, and pretty good all around.<br></p><p>Perl 6’s regex implementation looks like a  logical progression of the grep style as we’ve come to know it over the years, but I’d really like to see Swift go with something like the Verbal Expressions approach.<br></p><p>https://github.com/VerbalExpressions/SwiftVerbalExpressions<br></p><p>All the power is there, but it’s far more readable.<br></p><p>-jcr<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160131/c65b68ea/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Empower String type with regular expression</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>February  1, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On 1 Feb 2016, at 03:48, John Randolph via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Perl 6’s regex implementation looks like a  logical progression of the grep style as we’ve come to know it over the years, but I’d really like to see Swift go with something like the Verbal Expressions approach.<br>&gt; <br>&gt; https://github.com/VerbalExpressions/SwiftVerbalExpressions &lt;https://github.com/VerbalExpressions/SwiftVerbalExpressions&gt;<br>&gt; <br>&gt; All the power is there, but it’s far more readable.<br></p><p>I like the verbal expressions syntax, could we do both? i.e- instead of mapping straight onto NSRegularExpression, could we have a Swift RegularExpression struct that can either take a traditional regular expression, or be constructed via verbal expressions? It might be mapped onto NSRegularExpression behind the scenes, but could let us use both forms easily.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/1ebcac23/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Empower String type with regular expression</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>February  1, 2016 at 09:00:00am</p></header><div class="content"><p>Yeah… that verbal expressions thing looks really cool, but it’s not a substitute for the “real thing”. If we put the testing bit in a protocol, anything that validates text could conform to it and automatically be usable with switches and such:<br>protocol RegExValidator {<br>    func validateRegEx(_: String) -&gt; Bool<br>}<br>func ~= (lhs: String, rhs: RegExValidator) -&gt; Bool {<br>    return rhs.validateRegEx(lhs)<br>}<br>func ~= (lhs: RegExValidator, rhs: String) -&gt; Bool {<br>    return lhs.validateRegEx(rhs)<br>}<br></p><p>- Dave Sweeris<br></p><p>&gt; On Feb 1, 2016, at 02:02, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 1 Feb 2016, at 03:48, John Randolph via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Perl 6’s regex implementation looks like a  logical progression of the grep style as we’ve come to know it over the years, but I’d really like to see Swift go with something like the Verbal Expressions approach.<br>&gt;&gt; <br>&gt;&gt; https://github.com/VerbalExpressions/SwiftVerbalExpressions &lt;https://github.com/VerbalExpressions/SwiftVerbalExpressions&gt;<br>&gt;&gt; <br>&gt;&gt; All the power is there, but it’s far more readable.<br>&gt; <br>&gt; I like the verbal expressions syntax, could we do both? i.e- instead of mapping straight onto NSRegularExpression, could we have a Swift RegularExpression struct that can either take a traditional regular expression, or be constructed via verbal expressions? It might be mapped onto NSRegularExpression behind the scenes, but could let us use both forms easily.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/436b08d0/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>Empower String type with regular expression</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>February  1, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; Le 1 févr. 2016 à 04:48, John Randolph via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 31, 2016, at 7:39 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 31, 2016, at 8:32 AM, Patrick Gili via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There have been several threads that have discussed the notion of a regular expression literals. However, I didn&#39;t see anyone putting together a formal proposal, and hence I took the liberty to do so. I would appreciate discussion and comments on the proposal:<br>&gt;&gt; <br>&gt;&gt; I am +1 on the concept of adding regex literals to Swift, but -1 on this proposal.<br>&gt;&gt; <br>&gt;&gt; Specifically, instead of introducing regex literals, I’d suggest that you investigate introducing regex’s to the pattern grammar, which is what Swift uses for matching already.  Regex’s should be usable in the cases of a switch, for example.  Similarly, they should be able to bind variables directly to subpatterns.<br>&gt;&gt; <br>&gt;&gt; Further, I highly recommend checking out Perl 6’s regular expressions.  They are a community that has had an obsessive passion for regular expressions, and in Perl 6 they were given the chance to reinvent the wheel based on what they learned.  What they came up with is very powerful, and pretty good all around.<br>&gt; <br>&gt; Perl 6’s regex implementation looks like a  logical progression of the grep style as we’ve come to know it over the years, but I’d really like to see Swift go with something like the Verbal Expressions approach.<br>&gt; <br>&gt; https://github.com/VerbalExpressions/SwiftVerbalExpressions<br>&gt; <br>&gt; All the power is there, but it’s far more readable.<br></p><p>It depends who is the reader.<br></p><p>When the reader is an expert, `VerEx().startOfLine().then(&quot;http&quot;)` is much less readable than /^http/. It’s all about calling a spade a spade, and a regular expression, a regular expression. See https://swift.org/documentation/api-design-guidelines/#use-terminology-well.<br></p><p>Swift should aim at expert features: the great open source community will provide libraries as SwiftVerbalExpressions. Expert features don’t have to be complex. they just need to be comprehensive and well-exposed.<br></p><p>In a related topic, I much prefer a Swift wrapper for a SQL database that gives me *optional* sugar on top on a *solid* support for SQL.<br></p><p>Gwendal Roué<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05e222e6ef4d84013bb3baeb0e25c90b?s=50"></div><header><strong>Empower String type with regular expression</strong> from <string>Patrick Gili</string> &lt;gili.patrick.r at gili-labs.com&gt;<p>February  1, 2016 at 09:00:00am</p></header><div class="content"><p>Agreed.<br></p><p>In addition, I would like to consider the direction suggested by Chris. I don&#39;t think something like Swift Verbal Expressions works well with this direction. However, I could be wrong. If someone can illustrate how to do this, I&#39;m open the idea.<br></p><p>Cheers,<br>-Patrick<br></p><p>&gt; On Feb 1, 2016, at 5:22 AM, Gwendal Roué via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Le 1 févr. 2016 à 04:48, John Randolph via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 31, 2016, at 7:39 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 31, 2016, at 8:32 AM, Patrick Gili via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There have been several threads that have discussed the notion of a regular expression literals. However, I didn&#39;t see anyone putting together a formal proposal, and hence I took the liberty to do so. I would appreciate discussion and comments on the proposal:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I am +1 on the concept of adding regex literals to Swift, but -1 on this proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Specifically, instead of introducing regex literals, I’d suggest that you investigate introducing regex’s to the pattern grammar, which is what Swift uses for matching already.  Regex’s should be usable in the cases of a switch, for example.  Similarly, they should be able to bind variables directly to subpatterns.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Further, I highly recommend checking out Perl 6’s regular expressions.  They are a community that has had an obsessive passion for regular expressions, and in Perl 6 they were given the chance to reinvent the wheel based on what they learned.  What they came up with is very powerful, and pretty good all around.<br>&gt;&gt; <br>&gt;&gt; Perl 6’s regex implementation looks like a  logical progression of the grep style as we’ve come to know it over the years, but I’d really like to see Swift go with something like the Verbal Expressions approach.<br>&gt;&gt; <br>&gt;&gt; https://github.com/VerbalExpressions/SwiftVerbalExpressions<br>&gt;&gt; <br>&gt;&gt; All the power is there, but it’s far more readable.<br>&gt; <br>&gt; It depends who is the reader.<br>&gt; <br>&gt; When the reader is an expert, `VerEx().startOfLine().then(&quot;http&quot;)` is much less readable than /^http/. It’s all about calling a spade a spade, and a regular expression, a regular expression. See https://swift.org/documentation/api-design-guidelines/#use-terminology-well &lt;https://swift.org/documentation/api-design-guidelines/#use-terminology-well&gt;.<br>&gt; <br>&gt; Swift should aim at expert features: the great open source community will provide libraries as SwiftVerbalExpressions. Expert features don’t have to be complex. they just need to be comprehensive and well-exposed.<br>&gt; <br>&gt; In a related topic, I much prefer a Swift wrapper for a SQL database that gives me *optional* sugar on top on a *solid* support for SQL.<br>&gt; <br>&gt; Gwendal Roué<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/827f557b/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05e222e6ef4d84013bb3baeb0e25c90b?s=50"></div><header><strong>Empower String type with regular expression</strong> from <string>Patrick Gili</string> &lt;gili.patrick.r at gili-labs.com&gt;<p>February  1, 2016 at 09:00:00am</p></header><div class="content"><p>Hi John,<br></p><p>I don&#39;t think this represents a good direction. IMHO, it is not as easy to read (or maintain) for two reasons:<br></p><p>1) The Unix grep and sed commands popularized a regular expression syntax that has been leveraged by numerous languages and libraries, and hence, most developers want that familiarity.<br></p><p>2) The syntax presented by Swift Verbal Expressions is noisy, and hence it lacks the clear and concise nature of the syntax used by grep and sed.<br></p><p>Cheers,<br>-Patrick<br></p><p>&gt; On Jan 31, 2016, at 10:48 PM, John Randolph &lt;jcr at mac.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 31, 2016, at 7:39 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 31, 2016, at 8:32 AM, Patrick Gili via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There have been several threads that have discussed the notion of a regular expression literals. However, I didn&#39;t see anyone putting together a formal proposal, and hence I took the liberty to do so. I would appreciate discussion and comments on the proposal:<br>&gt;&gt; <br>&gt;&gt; I am +1 on the concept of adding regex literals to Swift, but -1 on this proposal.<br>&gt;&gt; <br>&gt;&gt; Specifically, instead of introducing regex literals, I’d suggest that you investigate introducing regex’s to the pattern grammar, which is what Swift uses for matching already.  Regex’s should be usable in the cases of a switch, for example.  Similarly, they should be able to bind variables directly to subpatterns.<br>&gt;&gt; <br>&gt;&gt; Further, I highly recommend checking out Perl 6’s regular expressions.  They are a community that has had an obsessive passion for regular expressions, and in Perl 6 they were given the chance to reinvent the wheel based on what they learned.  What they came up with is very powerful, and pretty good all around.<br>&gt; <br>&gt; Perl 6’s regex implementation looks like a  logical progression of the grep style as we’ve come to know it over the years, but I’d really like to see Swift go with something like the Verbal Expressions approach.<br>&gt; <br>&gt; https://github.com/VerbalExpressions/SwiftVerbalExpressions &lt;https://github.com/VerbalExpressions/SwiftVerbalExpressions&gt;<br>&gt; <br>&gt; All the power is there, but it’s far more readable.<br>&gt; <br>&gt; -jcr<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/c6d1ac06/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ab486d7597af4cfe0be33a762150848?s=50"></div><header><strong>Empower String type with regular expression</strong> from <string>Dany St-Amant</string> &lt;dsa.mls at icloud.com&gt;<p>February  1, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; Le 31 janv. 2016 à 22:48, John Randolph via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 31, 2016, at 7:39 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 31, 2016, at 8:32 AM, Patrick Gili via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There have been several threads that have discussed the notion of a regular expression literals. However, I didn&#39;t see anyone putting together a formal proposal, and hence I took the liberty to do so. I would appreciate discussion and comments on the proposal:<br>&gt;&gt; <br>&gt;&gt; I am +1 on the concept of adding regex literals to Swift, but -1 on this proposal.<br>&gt;&gt; <br>&gt;&gt; Specifically, instead of introducing regex literals, I’d suggest that you investigate introducing regex’s to the pattern grammar, which is what Swift uses for matching already.  Regex’s should be usable in the cases of a switch, for example.  Similarly, they should be able to bind variables directly to subpatterns.<br>&gt;&gt; <br>&gt;&gt; Further, I highly recommend checking out Perl 6’s regular expressions.  They are a community that has had an obsessive passion for regular expressions, and in Perl 6 they were given the chance to reinvent the wheel based on what they learned.  What they came up with is very powerful, and pretty good all around.<br>&gt; <br>&gt; Perl 6’s regex implementation looks like a  logical progression of the grep style as we’ve come to know it over the years, but I’d really like to see Swift go with something like the Verbal Expressions approach.<br>&gt; <br>&gt; https://github.com/VerbalExpressions/SwiftVerbalExpressions &lt;https://github.com/VerbalExpressions/SwiftVerbalExpressions&gt;<br>&gt; <br>&gt; All the power is there, but it’s far more readable.<br></p><p>Nice (too verbose for me) but mainly missing some key use cases; beside<br>1. checking if something matches<br>2. replacing matches<br></p><p>One needs to be able to:<br>3. see the matches (as tuple?)  (the capturing concept in the perl documentation)<br>4. counting matches (common use: are there more than a single match raise)<br></p><p>And to satisfy people familiar with strstr() maybe:<br>5. location of first match<br></p><p>Dany<br></p><p><br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/cc381731/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>Empower String type with regular expression</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>February  1, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On 01 Feb 2016, at 04:39, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Further, I highly recommend checking out Perl 6’s regular expressions.  They are a community that has had an obsessive passion for regular expressions, and in Perl 6 they were given the chance to reinvent the wheel based on what they learned.  What they came up with is very powerful, and pretty good all around.<br></p><p>Hi Chris,<br></p><p>Which parts of the Perl 6 regexes do you think are interesting to keep for Swift? What you suggest also means dropping NSRegularExpression support for literals and instead introducing a Regex class in the stdlib. Correct?<br></p><p>David.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05e222e6ef4d84013bb3baeb0e25c90b?s=50"></div><header><strong>Empower String type with regular expression</strong> from <string>Patrick Gili</string> &lt;gili.patrick.r at gili-labs.com&gt;<p>February  1, 2016 at 09:00:00am</p></header><div class="content"><p>Hi Chris,<br></p><p>Thank you for the feedback; it is much appreciated.<br></p><p>I like the idea of folding this into the language&#39;s pattern grammar. It makes it more Swifty. I didn&#39;t see that direction, and I will investigate it further.<br></p><p>I have been looking a lot at Perl 6. In fact, a lot of languages these days use PCRE or PCRE2, which was based on Perl&#39;s implementation of regular expressions. Does this mean there is attitude to move away from the regular expression implementation used by the foundation today?<br></p><p>Cheers,<br>-Patrick<br></p><p>&gt; On Jan 31, 2016, at 10:39 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 31, 2016, at 8:32 AM, Patrick Gili via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; There have been several threads that have discussed the notion of a regular expression literals. However, I didn&#39;t see anyone putting together a formal proposal, and hence I took the liberty to do so. I would appreciate discussion and comments on the proposal:<br>&gt; <br>&gt; I am +1 on the concept of adding regex literals to Swift, but -1 on this proposal.<br>&gt; <br>&gt; Specifically, instead of introducing regex literals, I’d suggest that you investigate introducing regex’s to the pattern grammar, which is what Swift uses for matching already.  Regex’s should be usable in the cases of a switch, for example.  Similarly, they should be able to bind variables directly to subpatterns.<br>&gt; <br>&gt; Further, I highly recommend checking out Perl 6’s regular expressions.  They are a community that has had an obsessive passion for regular expressions, and in Perl 6 they were given the chance to reinvent the wheel based on what they learned.  What they came up with is very powerful, and pretty good all around.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; Regular Expression Literals<br>&gt;&gt; Proposal: [SE-NNNN] (https://github/apple/swift-evolution/blob/master/proposals/NNNN-name.md &lt;https://github/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;)<br>&gt;&gt; Author: Patrick Gili (https://github.com/gili-patrick-r &lt;https://github.com/gili-patrick-r&gt;)<br>&gt;&gt; Status: Awaiting review<br>&gt;&gt; Review manager: TBD<br>&gt;&gt; Introduction<br>&gt;&gt; The Swift language has no native support for regular expressions, which makes working with regular expressions in Swift awkward, tedious, and error prone. This proposal describes the addition of regular expressions literals to Swift.<br>&gt;&gt; <br>&gt;&gt; Swift-evolution thread: Empower String type with regular expression &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151228/005126.html&gt;<br>&gt;&gt; Motivation<br>&gt;&gt; The definition of a pattern used by a regular expression is complicated by the fact that Swift does not support raw string literals (i.e., string literals that do not process character escapes or interpolation) or regular expression literals similar to Perl or Ruby. Rather, Swift only supports C-style string literals with support for interpolation. C-style string literals require a backslash to escape a backslash. The patterns representing regular expressions make frequent use of the backslash, and hence patterns represented by a Swift string literal become unreadable and difficult to maintain. For example, consider the following pattern to match and parse URLs:<br>&gt;&gt; <br>&gt;&gt; ^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$<br>&gt;&gt; To define this pattern in Swift, an application needs to define a string, such as<br>&gt;&gt; <br>&gt;&gt; let pattern = &quot;^(https?:\\/\\/)?([\\da-z\\.-]+)\\.([a-z\\.]{2,6})([\\/\\w &lt;smb://///w&gt; \\.- &lt;smb://.-&gt;]*)*\\/?$&quot;<br>&gt;&gt; This later is obviously difficult to read and maintain.<br>&gt;&gt; <br>&gt;&gt; Proposed solution<br>&gt;&gt; The proposed solution is to add regular expression literals to Swift, similar to regular expression literal support by other languages, such as Perl and Ruby. Regular expression literals differ from raw string literals in two primary ways. First, regular expression literals support string interpolation of the pattern, which allows an application to construct a regular expression at run-time. Second, a regular expression literal creates an instance of a NSRegularExpression, rather than an instance of String. The following example declares a regular expression for the purpose of matching and parsing URIs with a specified scheme:<br>&gt;&gt; <br>&gt;&gt; let scheme = &quot;https&quot;<br>&gt;&gt; let urlRegex = /^(\(scheme)?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/<br>&gt;&gt; To make regular expression literals effective, it must be possible to replace the creation of any instance of NSRegularExpression. The initializer for NSRegularExpression accepts a string describing the pattern and a set of options. To support these options, a regular expression literal accepts a list of zero or more options after the delimiter closing the pattern. For example, consider a regular expression to match and parse email addresses.<br>&gt;&gt; <br>&gt;&gt; let emailRegex = /^([a-z0-9_\.-]+)@([\da-z\.-]+)\.([a-z\.]{2,6})$/<br>&gt;&gt; This regular expression will match &quot;john.appleseed at apple.com &lt;mailto:john.appleseed at apple.com&gt;&quot;&quot;, but not &quot;JOHN.APPLESEED at APPLE.COM &lt;mailto:JOHN.APPLESEED at apple.com&gt;&quot;. The regular expression has to allow for this, as email addresses are not case sensitive. Rather than add the complexity to the pattern to account for this, the following example achieves the same:<br>&gt;&gt; <br>&gt;&gt; let emailRegex = /^([a-z0-9_\.-]+)@([\da-z\.-]+)\.([a-z\.]{2,6})$/i<br>&gt;&gt; In this case, the &quot;i&quot; following the delimiter closing the pattern maps to RegularExpressionOption.CaseInsensitive.<br>&gt;&gt; <br>&gt;&gt; Detailed design<br>&gt;&gt; The following modification to the grammar of a literal adds support for regular expression literals:<br>&gt;&gt; <br>&gt;&gt; literal → numeric-literal | string-literal | boolean-literal | regex-literal | nil-literal<br>&gt;&gt; <br>&gt;&gt; The following grammar describes a regular expression literal:<br>&gt;&gt; <br>&gt;&gt; regex-literal → static-regex-literal | interpolated-regex-literal<br>&gt;&gt; <br>&gt;&gt; static-regex-literal → / patternopt / regex-optionsopt<br>&gt;&gt; pattern → pattern_item patternopt<br>&gt;&gt; pattern_item → any Unicode scalar value except /, U+000A, or U+000D<br>&gt;&gt; <br>&gt;&gt; interpolated-string-literal → / interpolated-patternopt / regex-optionsopt<br>&gt;&gt; interpolated_pattern → interpolated_pattern_item interpolated_patternopt<br>&gt;&gt; interpolated_pattern_item → ( expression ) | pattern_item<br>&gt;&gt; <br>&gt;&gt; regex-options → regex-option | regex-optionopt<br>&gt;&gt; regex_option → i | x | q | s | m | d | b<br>&gt;&gt; <br>&gt;&gt; The following table summarize the regular expression options:<br>&gt;&gt; <br>&gt;&gt; Option 	RegularExpressionOption <br>&gt;&gt; i 	CaseInsensitive <br>&gt;&gt; x 	AllowCommentsAndWhitespace <br>&gt;&gt; q 	IgnoreMetacharacters <br>&gt;&gt; s 	DotMatchesLineSeparations <br>&gt;&gt; m 	AnchorsMatchLines <br>&gt;&gt; d 	UseUnixLineSeparators <br>&gt;&gt; b 	UseUnicodeWordBoundaries <br>&gt;&gt; Impact on existing code<br>&gt;&gt; The use of regular expression literals is opt-in, and hence there is no impact to existing code.<br>&gt;&gt; <br>&gt;&gt; Alternatives considered<br>&gt;&gt; There have been several threads on the swift-evoluation mailing list that have discussed alternatives to regular expression literals.<br>&gt;&gt; <br>&gt;&gt; String literal suffixes for defining types &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002193.html&gt; discussed string literals with a single character appended after the closing delimiter to denote the type. For example, the string literal r&quot;\d+&quot; in Python denotes a regular expression literal. However, this approach suffers from two disadvantages: 1) it does not support string interpolation in the pattern, and 2) it uses double-quotes for the delimiter, which appears more frequently in regular expressions than the forward slash.<br>&gt;&gt; <br>&gt;&gt; Muli-line string literals &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002325.html&gt; discussed string literals spanning more than one line. This would be a worthy addition to the regular expression literal discussed in this proposal. We should consider modifying the grammar to support this. However, I wanted to introduce changes incrementally to maintain focus.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/5172fdf1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Empower String type with regular expression</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>February  1, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Feb 1, 2016, at 6:47 AM, Patrick Gili &lt;gili.patrick.r at gili-labs.com&gt; wrote:<br>&gt; <br>&gt; Hi Chris,<br>&gt; <br>&gt; Thank you for the feedback; it is much appreciated.<br>&gt; <br>&gt; I like the idea of folding this into the language&#39;s pattern grammar. It makes it more Swifty. I didn&#39;t see that direction, and I will investigate it further.<br>&gt; <br>&gt; I have been looking a lot at Perl 6. In fact, a lot of languages these days use PCRE or PCRE2, which was based on Perl&#39;s implementation of regular expressions. Does this mean there is attitude to move away from the regular expression implementation used by the foundation today?<br></p><p>PCRE is based on Perl 5 regular expressions.  You are correct that they are well known and widely used, but they also have a lot of problems, and Perl 6 made them a lot better.<br></p><p>This is the first hit I had for “Perl 6 regex”:<br>http://doc.perl6.org/language/regexes<br></p><p>Things I like about them:<br>1) They mostly use the standard regex operator grammar x?, x*, x+, etc.<br>2) They allow free form style.<br>3) They allow comments within them.<br>4) Unicode aware and correct.<br>5) They are checked and validated by the compiler (not just a string fed into a runtime call).<br></p><p>etc.<br></p><p><br></p><p><br>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05e222e6ef4d84013bb3baeb0e25c90b?s=50"></div><header><strong>Empower String type with regular expression</strong> from <string>Patrick Gili</string> &lt;gili.patrick.r at gili-labs.com&gt;<p>February  1, 2016 at 05:00:00pm</p></header><div class="content"><p>Hi Chris,<br></p><p>Appreciate the pointer. Let me look at this further. Do you know of any open source effort that implements this?<br></p><p>Cheers,<br>-Patrick<br></p><p>&gt; On Feb 1, 2016, at 4:55 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 1, 2016, at 6:47 AM, Patrick Gili &lt;gili.patrick.r at gili-labs.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi Chris,<br>&gt;&gt; <br>&gt;&gt; Thank you for the feedback; it is much appreciated.<br>&gt;&gt; <br>&gt;&gt; I like the idea of folding this into the language&#39;s pattern grammar. It makes it more Swifty. I didn&#39;t see that direction, and I will investigate it further.<br>&gt;&gt; <br>&gt;&gt; I have been looking a lot at Perl 6. In fact, a lot of languages these days use PCRE or PCRE2, which was based on Perl&#39;s implementation of regular expressions. Does this mean there is attitude to move away from the regular expression implementation used by the foundation today?<br>&gt; <br>&gt; PCRE is based on Perl 5 regular expressions.  You are correct that they are well known and widely used, but they also have a lot of problems, and Perl 6 made them a lot better.<br>&gt; <br>&gt; This is the first hit I had for “Perl 6 regex”:<br>&gt; http://doc.perl6.org/language/regexes<br>&gt; <br>&gt; Things I like about them:<br>&gt; 1) They mostly use the standard regex operator grammar x?, x*, x+, etc.<br>&gt; 2) They allow free form style.<br>&gt; 3) They allow comments within them.<br>&gt; 4) Unicode aware and correct.<br>&gt; 5) They are checked and validated by the compiler (not just a string fed into a runtime call).<br>&gt; <br>&gt; etc.<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; -Chris<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Empower String type with regular expression</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>February  1, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Feb 1, 2016, at 2:03 PM, Patrick Gili &lt;gili.patrick.r at gili-labs.com&gt; wrote:<br>&gt; <br>&gt; Hi Chris,<br>&gt; <br>&gt; Appreciate the pointer. Let me look at this further. Do you know of any open source effort that implements this?<br></p><p>I’m not sure what you mean.  Perl 6 is a large effort and all of it is open source AFAIK.<br></p><p>-Chris<br></p><p>&gt; <br>&gt; Cheers,<br>&gt; -Patrick<br>&gt; <br>&gt;&gt; On Feb 1, 2016, at 4:55 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 1, 2016, at 6:47 AM, Patrick Gili &lt;gili.patrick.r at gili-labs.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi Chris,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thank you for the feedback; it is much appreciated.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I like the idea of folding this into the language&#39;s pattern grammar. It makes it more Swifty. I didn&#39;t see that direction, and I will investigate it further.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I have been looking a lot at Perl 6. In fact, a lot of languages these days use PCRE or PCRE2, which was based on Perl&#39;s implementation of regular expressions. Does this mean there is attitude to move away from the regular expression implementation used by the foundation today?<br>&gt;&gt; <br>&gt;&gt; PCRE is based on Perl 5 regular expressions.  You are correct that they are well known and widely used, but they also have a lot of problems, and Perl 6 made them a lot better.<br>&gt;&gt; <br>&gt;&gt; This is the first hit I had for “Perl 6 regex”:<br>&gt;&gt; http://doc.perl6.org/language/regexes<br>&gt;&gt; <br>&gt;&gt; Things I like about them:<br>&gt;&gt; 1) They mostly use the standard regex operator grammar x?, x*, x+, etc.<br>&gt;&gt; 2) They allow free form style.<br>&gt;&gt; 3) They allow comments within them.<br>&gt;&gt; 4) Unicode aware and correct.<br>&gt;&gt; 5) They are checked and validated by the compiler (not just a string fed into a runtime call).<br>&gt;&gt; <br>&gt;&gt; etc.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05e222e6ef4d84013bb3baeb0e25c90b?s=50"></div><header><strong>Empower String type with regular expression</strong> from <string>Patrick Gili</string> &lt;gili.patrick.r at gili-labs.com&gt;<p>February  2, 2016 at 08:00:00am</p></header><div class="content"><p>Okay, I didn&#39;t know Perl was open source. I&#39;ll look at the Perl6 regular expression link you sent me.<br></p><p>Cheers,<br>-Patrick<br></p><p>&gt; On Feb 1, 2016, at 6:55 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 1, 2016, at 2:03 PM, Patrick Gili &lt;gili.patrick.r at gili-labs.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi Chris,<br>&gt;&gt; <br>&gt;&gt; Appreciate the pointer. Let me look at this further. Do you know of any open source effort that implements this?<br>&gt; <br>&gt; I’m not sure what you mean.  Perl 6 is a large effort and all of it is open source AFAIK.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Cheers,<br>&gt;&gt; -Patrick<br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 1, 2016, at 4:55 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 1, 2016, at 6:47 AM, Patrick Gili &lt;gili.patrick.r at gili-labs.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi Chris,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thank you for the feedback; it is much appreciated.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I like the idea of folding this into the language&#39;s pattern grammar. It makes it more Swifty. I didn&#39;t see that direction, and I will investigate it further.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I have been looking a lot at Perl 6. In fact, a lot of languages these days use PCRE or PCRE2, which was based on Perl&#39;s implementation of regular expressions. Does this mean there is attitude to move away from the regular expression implementation used by the foundation today?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; PCRE is based on Perl 5 regular expressions.  You are correct that they are well known and widely used, but they also have a lot of problems, and Perl 6 made them a lot better.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is the first hit I had for “Perl 6 regex”:<br>&gt;&gt;&gt; http://doc.perl6.org/language/regexes<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Things I like about them:<br>&gt;&gt;&gt; 1) They mostly use the standard regex operator grammar x?, x*, x+, etc.<br>&gt;&gt;&gt; 2) They allow free form style.<br>&gt;&gt;&gt; 3) They allow comments within them.<br>&gt;&gt;&gt; 4) Unicode aware and correct.<br>&gt;&gt;&gt; 5) They are checked and validated by the compiler (not just a string fed into a runtime call).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; etc.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1696913cf1335685a75e63e11b459ae3?s=50"></div><header><strong>Empower String type with regular expression</strong> from <string>Sune Foldager</string> &lt;cyano at me.com&gt;<p>February  1, 2016 at 04:00:00pm</p></header><div class="content"><p>On 01 Feb 2016, at 04:39, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I am +1 on the concept of adding regex literals to Swift, but -1 on this proposal.<br>&gt; <br>&gt; Specifically, instead of introducing regex literals, I’d suggest that you investigate introducing regex’s to the pattern grammar, which is what Swift uses for matching already.  Regex’s should be usable in the cases of a switch, for example.  Similarly, they should be able to bind variables directly to sub patterns.<br></p><p>These two things seem somewhat orthogonal to me, but I am also much more excited about what you propose; many languages have regex literals, and that’s great, but allowing them in pattern matching with variable binding and efficient parallel execution is much rarer.<br></p><p>Standard regex literals isn’t too important for Swift, IMO. Writing /…../ or Regex(‘…..’) isn’t that different, really. Regex could be initialised from strings as well, making the difference even smaller.<br></p><p>-Sune<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/a3d07c75/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Empower String type with regular expression</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>February  3, 2016 at 11:00:00am</p></header><div class="content"><p>Of course it is possible to create a regex from a string at runtime — but when you do so at compile time you<br>- can check the syntax<br>- compile the expression down to machine code for better performance (there could be a significant advantage).<br></p><p>Sidenote:<br>In 2013, when I got bored by Objective-C and didn&#39;t know about the secret work on Swift, I started playing with llvm and tried to build a regex-compiler to get familiar with the infrastructure.<br>I had to stop halfway because of &quot;real&quot; work, but I&#39;m sure native regex support would make Swift even better for server-side programming and scripting.<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ab486d7597af4cfe0be33a762150848?s=50"></div><header><strong>Empower String type with regular expression</strong> from <string>Dany St-Amant</string> &lt;dsa.mls at icloud.com&gt;<p>February  1, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; Le 31 janv. 2016 à 22:39, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 31, 2016, at 8:32 AM, Patrick Gili via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; There have been several threads that have discussed the notion of a regular expression literals. However, I didn&#39;t see anyone putting together a formal proposal, and hence I took the liberty to do so. I would appreciate discussion and comments on the proposal:<br>&gt; <br>&gt; I am +1 on the concept of adding regex literals to Swift, but -1 on this proposal.<br>&gt; <br>&gt; Specifically, instead of introducing regex literals, I’d suggest that you investigate introducing regex’s to the pattern grammar, which is what Swift uses for matching already.  Regex’s should be usable in the cases of a switch, for example.  Similarly, they should be able to bind variables directly to sub patterns.<br></p><p>I was seeing the sub patterns originally a bit like:<br>switch( string &lt;match-op&gt; regex) {<br>  case .matches(_, &quot;http&quot;, let port):<br>  case .matches(_, let name, &quot;8080&quot;):<br>  case .matches(_, &quot;\\smb\&quot;):<br>}<br>but the comment about the pattern grammar make me of:<br>switch( string ) {<br>  case regexp1: if ($0.1 = &quot;http&quot;) { }<br>  case regexp2:<br>}<br>Both have their uses<br></p><p>Dany<br></p><p><br>&gt; Further, I highly recommend checking out Perl 6’s regular expressions.  They are a community that has had an obsessive passion for regular expressions, and in Perl 6 they were given the chance to reinvent the wheel based on what they learned.  What they came up with is very powerful, and pretty good all around.<br>&gt; <br>&gt; -Chris<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/eb2427b4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05e222e6ef4d84013bb3baeb0e25c90b?s=50"></div><header><strong>Empower String type with regular expression</strong> from <string>Patrick Gili</string> &lt;gili.patrick.r at gili-labs.com&gt;<p>February  2, 2016 at 07:00:00am</p></header><div class="content"><p>Dany,<br></p><p>When you say &quot;sub patterns&quot;, do you mean &quot;capture groups&quot;?<br></p><p>-Patrick<br></p><p>&gt; On Feb 1, 2016, at 10:43 PM, Dany St-Amant via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Le 31 janv. 2016 à 22:39, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 31, 2016, at 8:32 AM, Patrick Gili via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There have been several threads that have discussed the notion of a regular expression literals. However, I didn&#39;t see anyone putting together a formal proposal, and hence I took the liberty to do so. I would appreciate discussion and comments on the proposal:<br>&gt;&gt; <br>&gt;&gt; I am +1 on the concept of adding regex literals to Swift, but -1 on this proposal.<br>&gt;&gt; <br>&gt;&gt; Specifically, instead of introducing regex literals, I’d suggest that you investigate introducing regex’s to the pattern grammar, which is what Swift uses for matching already.  Regex’s should be usable in the cases of a switch, for example.  Similarly, they should be able to bind variables directly to sub patterns.<br>&gt; <br>&gt; I was seeing the sub patterns originally a bit like:<br>&gt; switch( string &lt;match-op&gt; regex) {<br>&gt;   case .matches(_, &quot;http&quot;, let port):<br>&gt;   case .matches(_, let name, &quot;8080&quot;):<br>&gt;   case .matches(_, &quot;\\smb\ &lt;smb://smb/&gt;&quot;):<br>&gt; }<br>&gt; but the comment about the pattern grammar make me of:<br>&gt; switch( string ) {<br>&gt;   case regexp1: if ($0.1 = &quot;http&quot;) { }<br>&gt;   case regexp2:<br>&gt; }<br>&gt; Both have their uses<br>&gt; <br>&gt; Dany<br>&gt; <br>&gt; <br>&gt;&gt; Further, I highly recommend checking out Perl 6’s regular expressions.  They are a community that has had an obsessive passion for regular expressions, and in Perl 6 they were given the chance to reinvent the wheel based on what they learned.  What they came up with is very powerful, and pretty good all around.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160202/5b9e2430/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ab486d7597af4cfe0be33a762150848?s=50"></div><header><strong>Empower String type with regular expression</strong> from <string>Dany St-Amant</string> &lt;dsa.mls at icloud.com&gt;<p>February  2, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; Le 2 févr. 2016 à 07:43, Patrick Gili &lt;gili.patrick.r at gili-labs.com&gt; a écrit :<br>&gt; <br>&gt; Dany,<br>&gt; <br>&gt; When you say &quot;sub patterns&quot;, do you mean &quot;capture groups&quot;?<br></p><p>Looks like my sub-patterns/matches are in Perl parlance capture groups, but it seems that this may need support from the compiler. Tuple have fixed length (no support for variadic tuple), could not get arrays to work in switch case, enum cannot reuse same name with different set of associated value.<br></p><p>&gt;&gt; On Feb 1, 2016, at 10:43 PM, Dany St-Amant via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Le 31 janv. 2016 à 22:39, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 31, 2016, at 8:32 AM, Patrick Gili via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There have been several threads that have discussed the notion of a regular expression literals. However, I didn&#39;t see anyone putting together a formal proposal, and hence I took the liberty to do so. I would appreciate discussion and comments on the proposal:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I am +1 on the concept of adding regex literals to Swift, but -1 on this proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Specifically, instead of introducing regex literals, I’d suggest that you investigate introducing regex’s to the pattern grammar, which is what Swift uses for matching already.  Regex’s should be usable in the cases of a switch, for example.  Similarly, they should be able to bind variables directly to sub patterns.<br>&gt;&gt; <br>&gt;&gt; I was seeing the sub patterns originally a bit like:<br>&gt;&gt; switch( string &lt;match-op&gt; regex) {<br>&gt;&gt;   case .matches(_, &quot;http&quot;, let port):<br>&gt;&gt;   case .matches(_, let name, &quot;8080&quot;):<br>&gt;&gt;   case .matches(_, &quot;\\smb\ &lt;smb://smb/&gt;&quot;):<br>&gt;&gt; }<br>&gt;&gt; but the comment about the pattern grammar make me of:<br>&gt;&gt; switch( string ) {<br>&gt;&gt;   case regexp1: if ($0.1 = &quot;http&quot;) { }<br>&gt;&gt;   case regexp2:<br>&gt;&gt; }<br>&gt;&gt; Both have their uses<br>&gt;&gt; <br>&gt;&gt; Dany<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Further, I highly recommend checking out Perl 6’s regular expressions.  They are a community that has had an obsessive passion for regular expressions, and in Perl 6 they were given the chance to reinvent the wheel based on what they learned.  What they came up with is very powerful, and pretty good all around.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160202/e4701edf/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Empower String type with regular expression</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February  7, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; Further, I highly recommend checking out Perl 6’s regular expressions.  They are a community that has had an obsessive passion for regular expressions, and in Perl 6 they were given the chance to reinvent the wheel based on what they learned.  What they came up with is very powerful, and pretty good all around.<br></p><p>As someone who learned to argue about language design on perl6-language, you have my interest. :^)<br></p><p>How far do you want to go here? In the small, Perl 6 redesigned regex syntax to remove certain syntactic hacks and make more common operations more accessible; in the medium, they introduced extensibility and reusability with named rules; in the large, they made grammars of named rules a first-class language feature; and in the very large, they turned the parsing of Perl itself into a Perl grammar you could subclass and modify for metaprogramming. #1 and #4 are very different propositions.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05e222e6ef4d84013bb3baeb0e25c90b?s=50"></div><header><strong>Empower String type with regular expression</strong> from <string>Patrick Gili</string> &lt;gili.patrick.r at gili-labs.com&gt;<p>February  7, 2016 at 07:00:00pm</p></header><div class="content"><p>Hi Brent,<br></p><p>I think we should go all the way. The Perl6 community has done a bang up job: developers don&#39;t need to worry about writing tokenizers anymore, more intuitive and reduced number of meta characters, increased reusability and readability, and well throughout support for Unicode.<br></p><p>I like the new grammar feature, but I&#39;m still reading about this and playing with it. I wonder if it isn&#39;t something we can consider later.<br></p><p>Cheers,<br>-Patrick<br></p><p>Sent from my iPad<br></p><p>On Feb 7, 2016, at 5:13 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br></p><p>&gt;&gt; Further, I highly recommend checking out Perl 6’s regular expressions.  They are a community that has had an obsessive passion for regular expressions, and in Perl 6 they were given the chance to reinvent the wheel based on what they learned.  What they came up with is very powerful, and pretty good all around.<br>&gt; <br>&gt; As someone who learned to argue about language design on perl6-language, you have my interest. :^)<br>&gt; <br>&gt; How far do you want to go here? In the small, Perl 6 redesigned regex syntax to remove certain syntactic hacks and make more common operations more accessible; in the medium, they introduced extensibility and reusability with named rules; in the large, they made grammars of named rules a first-class language feature; and in the very large, they turned the parsing of Perl itself into a Perl grammar you could subclass and modify for metaprogramming. #1 and #4 are very different propositions.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Empower String type with regular expression</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>February 11, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Feb 7, 2016, at 2:13 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; Further, I highly recommend checking out Perl 6’s regular expressions.  They are a community that has had an obsessive passion for regular expressions, and in Perl 6 they were given the chance to reinvent the wheel based on what they learned.  What they came up with is very powerful, and pretty good all around.<br>&gt; <br>&gt; As someone who learned to argue about language design on perl6-language, you have my interest. :^)<br>&gt; <br>&gt; How far do you want to go here?<br></p><p>Honestly, I don’t know.  I haven’t had much time to think/fantasize about this since it is clearly outside the scope of what we can do in Swift 3.  I’d love to tackle regex’s in Swift 4, though it is too early to tell what we’ll be able to tackle there (depends on what all we get done in Swift 3).<br></p><p>&gt; In the small, Perl 6 redesigned regex syntax to remove certain syntactic hacks and make more common operations more accessible; in the medium, they introduced extensibility and reusability with named rules; in the large, they made grammars of named rules a first-class language feature; and in the very large, they turned the parsing of Perl itself into a Perl grammar you could subclass and modify for metaprogramming. #1 and #4 are very different propositions.<br></p><p>I don’t care about #4 at all, but I’m very interested in 1-3.  My interest in turning regex’s into a first class language feature (instead of, e.g., a new string literal type) is that we can get better compiler error recovery, IDE support, better integration with pattern matching, and generally “unlimited” integration with the rest of the language.<br></p><p>-Chris<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
