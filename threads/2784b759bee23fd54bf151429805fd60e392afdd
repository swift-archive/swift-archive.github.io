<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Review] SE-0068: Expanding Swift Self to class members and value types</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>April 20, 2016 at 10:00:00am</p></header><div class="content"><p>Hello Swift community,<br></p><p>The review of &quot;SE-0068: Expanding Swift Self to class members and value types&quot; begins now and runs through April 25. The proposal is available here:<br></p><p>	https://github.com/apple/swift-evolution/blob/master/proposals/0068-universal-self.md<br></p><p>Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br></p><p>	https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>or, if you would like to keep your feedback private, directly to the review manager.<br></p><p>What goes into a review?<br></p><p>The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br></p><p>	* What is your evaluation of the proposal?<br>	* Is the problem being addressed significant enough to warrant a change to Swift?<br>	* Does this proposal fit well with the feel and direction of Swift?<br>	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>More information about the Swift evolution process is available at<br></p><p>	https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br></p><p>Thank you,<br></p><p>-Chris Lattner<br>Review Manager<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution-announce/attachments/20160420/2784afdd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Review] SE-0068: Expanding Swift Self to class members and value types</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>April 20, 2016 at 07:00:00pm</p></header><div class="content"><p>+1<br>It&#39;s not breaking anything, it&#39;s a useful feature, and I think it adds consistency:<br>I already encountered situations where I tried to use &quot;Self&quot; in contexts where it is not available now. <br></p><p>Tino<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2a461f6af6a598c78eb573075ed2e577?s=50"></div><header><strong>[Review] SE-0068: Expanding Swift Self to class members and value types</strong> from <string>Ergin Bilgin</string> &lt;erginbil at gmail.com&gt;<p>April 21, 2016 at 03:00:00am</p></header><div class="content"><p>At first it looked like a good idea to me but then I realized it may lead<br>to a lot of confusion especially for beginners. self.dynamicType looks much<br>more self explanatory and actually little bit easier to read since I do not<br>have to pay attention to capitalization.<br></p><p>On 20 April 2016 at 20:16, Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hello Swift community,<br>&gt;<br>&gt; The review of &quot;SE-0068: Expanding Swift Self to class members and value<br>&gt; types&quot; begins now and runs through April 25. The proposal is available here:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0068-universal-self.md<br>&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt; should be sent to the swift-evolution mailing list at<br>&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the<br>&gt; review manager.<br>&gt;<br>&gt; What goes into a review?<br>&gt;<br>&gt; The goal of the review process is to improve the proposal under review<br>&gt; through constructive criticism and, eventually, determine the direction of<br>&gt; Swift. When writing your review, here are some questions you might want to<br>&gt; answer in your review:<br>&gt;<br>&gt; * What is your evaluation of the proposal?<br>&gt; * Is the problem being addressed significant enough to warrant a change to<br>&gt; Swift?<br>&gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt; * If you have you used other languages or libraries with a similar<br>&gt; feature, how do you feel that this proposal compares to those?<br>&gt; * How much effort did you put into your review? A glance, a quick reading,<br>&gt; or an in-depth study?<br>&gt;<br>&gt; More information about the Swift evolution process is available at<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;<br>&gt; Thank you,<br>&gt;<br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160421/8c7f5bc9/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Review] SE-0068: Expanding Swift Self to class members and value types</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>April 20, 2016 at 07:00:00pm</p></header><div class="content"><p>* What is your evaluation of the proposal?<br></p><p>Mixed. I definitely think we need the functionality, but I think naming it “Self” may be confusing, since it means “self” and “Self” will mean two distinct things, despite varying only in the case of the first letter.<br></p><p>* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Definitely. As the proposal says, MyExtremelyLargeTypeName.staticMember is very unwieldy and awkward, and also fragile in case the type&#39;s name is changed.<br></p><p>* Does this proposal fit well with the feel and direction of Swift?<br></p><p>I feel that if given a name other than Self, it will be. As proposed, there is a potential for confusion between “self” and “Self”.<br></p><p>* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>Objective-C has [[self class] classMethod] but lacks type checking on it. This is an improvement.<br></p><p>* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>Read through the whole thing.<br></p><p>Charles<br></p><p>&gt; On Apr 20, 2016, at 12:16 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;SE-0068: Expanding Swift Self to class members and value types&quot; begins now and runs through April 25. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0068-universal-self.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0068-universal-self.md&gt;<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160420/74067bff/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06130940a44c84dfc6c5aeabfd8482f8?s=50"></div><header><strong>[Review] SE-0068: Expanding Swift Self to class members and value types</strong> from <string>Timothy Wood</string> &lt;tjw at me.com&gt;<p>April 20, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Apr 20, 2016, at 10:16 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br></p><p>+1 — yes, please!<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes, this is a big cleanup of mental overhead when accessing class/static properties and functions that are related to the instance. This avoids the need to confirm, each time you read it, that the name of the receiver is the same as the name of the containing class/struct/whatever, as well as avoiding subtle bugs when refactoring code.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes, this helps avoid bugs, and shows clear intent. The name of `Self` shows the clear relationship between that and `self` where `dynamicType` does not.<br>&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>No, but I’ve certainly been annoyed by its lack in other languages…<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>A close reading of the proposal and associated threads.<br></p><p>-tim<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Review] SE-0068: Expanding Swift Self to class members and value types</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>April 21, 2016 at 09:00:00am</p></header><div class="content"><p>I almost totally support this proposal.<br></p><p>The only thing is worrying me in confusion between the currently defined <br>type(where method is declared) and dynamic type of class at runtime.<br></p><p>Plus, note that we have currently &quot;self&quot; as *type* object inside <br>class/static methods.<br></p><p>I.e. let&#39;s we have such code :<br></p><p>--------------------<br>class A {<br>     class func classX() { print(&quot;in classX : class A&quot;)  }<br></p><p>     class func classY() { self.classX() } // Self.classX() is proposed. if <br>we&#39;ll have A.classX() here - we&#39;ll have another behavior<br></p><p>     func y() { self.dynamicType.classY() }  // Self.classY() is proposed<br>}<br></p><p>class B: A {<br>    override class func classX() { print(&quot;in classX : class B&quot;) }<br>}<br></p><p>var a = A()<br>var b = B()<br></p><p>a.y() &gt;&gt; in classX : class A<br>b.y() &gt;&gt; in classX : class B<br>--------------------<br></p><p>Currently, in classY() &quot;self.classX()&quot; is also confusing. &quot;self&quot; is not &quot;A&quot; <br>here, but &quot;dynamicType&quot;. So it is ok to have &quot;Self.classX()&quot; at this place. <br>(the same (probably less) level of confusion i.e. &quot;is Self is A or <br>dynamicType&quot;)<br></p><p>But in y() the &quot;self.dynamicType&quot; is much more explicit and clear than <br>&quot;Self&quot;. Yes, if we&#39;ll know that Swift *is* dynamicType - we&#39;ll use it <br>correctly, I believe. And if I have to choose : to implement this proposal <br>or leave &quot;dynamicType&quot; and &quot;self&quot; in static/class methods - I choose to <br>have proposed &quot;Self&quot; in Swift 3.0.<br></p><p>Probably, it will be better to name this &quot;Self&quot; in some other way..<br>Don&#39;t have good variants.. like &quot;DynamicSelf&quot; ?<br></p><p><br>And, I believe we need some kind of &quot;Self&quot; to address currently defined <br>class like in this case(I support, we should be able to just copy-paste the <br>func from protocol to our class definition, typing the name of our class in <br>implementation is making our codebase more fragile if class is renamed ):<br></p><p>protocol AProtocol {<br>     func assignFrom(a: Self)  // now. confusing if this is Self = <br>&quot;dynamicType&quot; ?<br>     // func assignFrom(a: ThisType)  // suggested<br>}<br></p><p>class A : AProtocol {<br>     var x = 10<br></p><p>     func assignFrom(a: A) { // now . no that &quot;Self&quot; is placeholder for &quot;A&quot;<br>     // func assignFrom(a: ThisType) { // suggested<br></p><p>         self.x = a.x<br>     }<br>}<br></p><p>Probably #ThisType, as this is compilator&#39;s business to replace this with <br>actually defined class name. Or #Type.. Or even #Self. This can be discussed.<br></p><p>Opinions?<br></p><p>Btw, can&#39;t understand how self and Self could be confused - in Swift it is <br>so natural to have the instance name as just lowercased name of class :<br>let page = Page(withTitle: &quot;Page Title&quot;)<br>so, we have self, the instance of some type, and the type of that instance <br>is Self.<br></p><p><br>On 20.04.2016 20:16, Chris Lattner via swift-evolution wrote:<br>&gt; Hello Swift community,<br>&gt;<br>&gt; The review of &quot;SE-0068: Expanding Swift Self to class members and value<br>&gt; types&quot; begins now and runs through April 25. The proposal is available here:<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0068-universal-self.md<br>&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt; should be sent to the swift-evolution mailing list at<br>&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the review<br>&gt; manager.<br>&gt;<br>&gt; What goes into a review?<br>&gt;<br>&gt; The goal of the review process is to improve the proposal under review<br>&gt; through constructive criticism and, eventually, determine the direction of<br>&gt; Swift. When writing your review, here are some questions you might want to<br>&gt; answer in your review:<br>&gt;<br>&gt; * What is your evaluation of the proposal?<br>&gt; * Is the problem being addressed significant enough to warrant a change to<br>&gt; Swift?<br>&gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt; * If you have you used other languages or libraries with a similar feature,<br>&gt; how do you feel that this proposal compares to those?<br>&gt; * How much effort did you put into your review? A glance, a quick reading,<br>&gt; or an in-depth study?<br>&gt;<br>&gt; More information about the Swift evolution process is available at<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;<br>&gt; Thank you,<br>&gt;<br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0a299ea776456e5b490c6af93682926?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0068: Expanding Swift Self to class members and value types</strong> from <string>Sebastian Hagedorn</string> &lt;sebastian at iosphere.de&gt;<p>April 21, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; 	* What is your evaluation of the proposal?<br></p><p>Generally +1, but disagree on the naming.<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Generally, yes. However, I don’t think “Self” is very readable or easily understandable. “dynamicType” on the other hand can hardly be misunderstood. With Self, one first has to know/understand that there is a difference between static and dynamic types, and then know/look up which of these types is returned. With dynamicType, this is clear from the beginning. If you don’t know what a dynamic type is, you will stumble over the word and there’s a much higher chance you’d do the research. I don’t think we should value upper/lowercase consistency higher than readability of the code (including what it actually does).<br></p><p>&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>ObjC, but I don’t think this compares well, as type lookup at runtime is only available for classes.<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>Read the proposal and all replies that have come in since.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be09ed656d5d90501c958b001261f218?s=50"></div><header><strong>[Review] SE-0068: Expanding Swift Self to class members and value types</strong> from <string>Jeremy Pereira</string> &lt;jeremy.j.pereira at googlemail.com&gt;<p>April 21, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On 20 Apr 2016, at 18:16, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br></p><p>-1<br></p><p>Addressing the issues cited in the proposal:<br></p><p>&gt; 	• dynamicType remains an exception to Swift&#39;s lowercased keywords rule. This change eliminates a special case that&#39;s out of step with Swift&#39;s new standards.<br></p><p><br>Except for the fact that `dynamicType` cannot be used with implicit self, it has always felt more like a property to me than a keyword and the capitalisation is therefore not out of place. The camel case does not jar for me in the same way that writing `someInstance.Self` would.<br></p><p>NB the keyword `Self` would also violate the all-lowercase keyword rule.<br></p><p>&gt; 	• Self is shorter and clearer in its intent. It mirrors self, which refers to the current instance.<br></p><p>It is undeniably shorter, but it is not clearer in intent. `self.dynamicType` clearly and explicitly tells us we are referring to the runtime type of the instance. `Self` does not. Furthermore, it overloads the word with two subtly different meanings depending on context. <br></p><p>&gt; 	• It provides an easier way to access static members. As type names grow large, readability suffers. MyExtremelyLargeTypeName.staticMember is unwieldy to type and read.<br></p><p>I reject the assertion that readability suffers with large type names. `NSApplicationDelegate` is much more readable than `NSAppDlgt` for example.<br></p><p>Furthermore, this proposal does not address the length of `MyExtremelyLargeTypeName.someMember()` since that might not be the same method as `Self.someMember()` If you explicitly want the `someMember()` defined by `MyExtremelyLargeTypeName` you still have to spell it out in case it is a class function and the dynamic type is a subclass.  <br></p><p>&gt; 	• Code using hardwired type names is less portable than code that automatically knows its type.<br></p><p>And how does `self.dynamicType` fail here?<br></p><p>&gt; 	• Renaming a type means updating any TypeName references in code.<br></p><p>This is the same point as the previous one.<br></p><p>&gt; 	• Using self.dynamicType fights against Swift&#39;s goals of concision and clarity in that it is both noisy and esoteric.<br></p><p>I disagree. `self.dynamicType` is a clear and concise description of the object it represents.<br></p><p>Another observation: the proposal omits the “Impact own Existing Code” section. I think this would be a breaking change for a lot of existing code.<br></p><p>Also, I’m disappointed that no alternatives seem to have been documented.<br></p><p><br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>No.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>No, unless the direction of Swift is to go for maximum terseness at the expense of clarity.<br></p><p>&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>In Objective-C you can write [self class] to get the runtime class of an object. I think that is a better choice of name. In Swift the analogue would probably be `self.type`. Was this considered?<br></p><p><br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I’ve been following the thread.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Review] SE-0068: Expanding Swift Self to class members and value types</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April 21, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Apr 20, 2016, at 11:16 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;SE-0068: Expanding Swift Self to class members and value types&quot; begins now and runs through April 25. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0068-universal-self.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0068-universal-self.md&gt;<br></p><p><br>RELATED DISCUSSIONS<br></p><p>* Design Team feedback &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/15009&gt; on SE-0068<br>* [Pitch] Adding a Self type name shortcut for static member access &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/13708&gt;<br>* [Pitch] Rename `x.dynamicType` to `x.Self` &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/14445&gt;<br>* Making `.self` after `Type` optional &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/9059&gt;<br>* Remove the Need for &#39;self&#39; to Access &#39;dynamicType&#39; &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/14173&gt;<br></p><p>SHOULD .self BE REMOVED FROM TYPES<br></p><p>Design team notes say:<br></p><p>We have a proposal to remove .self on types. One reason .self exists is to avoid the mistake of writing let x = Int — the compiler will give you a weird type error later on in code if the value of x is what we today call Int.self but you meant to call the Int() initializer. Creating a metatype is not a common operation, so doing it explicitly is a good thing.<br></p><p>Coming back to this proposal, if we removed .self why would we want to add .Self?<br></p><p>Background:<br>From Joe Groff: &quot;`.self` is also a bit of load-bearing duct-tape that currently supports some other parsing aspects of Swift&#39;s syntax.&quot; <br>Jordan Rose adds, &quot;Swift&#39;s type-checking engine is strong enough to merit not needing the redundant `.self` safety check.&quot; <br></p><p>I personally like distinguishing `Type.self` from raw `Type` use for the reasons stated. This feature affirmatively prevents the use of `Typename` when `Typename()` is meant. In terms of this proposal, can this and should this be  retained in the language but renamed from `self`? That would update the quiz to:<br></p><p>Self.&lt;runcible&gt; // T.Type<br>self.Self       // T.Type<br>Self.Self       // T.Type.Type<br>self.&lt;runcible&gt; // == self<br>Which reduces at least some of the confusion. The actual runcible name could be bikeshedded.<br></p><p>IS `Self` THE RIGHT NAME? / SHOULD `dynamicType` require `self`<br></p><p>I like `Self`.  It is an existing keyword. It matches the approach used in protocols where `Self` is a placeholder for the type that conforms to that protocol. Under SE-0068, it refers to the dynamic type of the current instance. If it has to be a choice of one or the other, I&#39;d prefer renaming `.self` and retaining `Self`. If `Self` is not the right name, I&#39;d recommend either the `dynamictype` keyword and dropping the `self` prefix requirement or using a freestanding `dynamicType()` call. <br></p><p>We have one keyword left in the language, dynamicType, which is camel cased. This proposal renames it to Self instead.<br></p><p>Why don’t we turn this into a standard library function? It’s not something you need so often that the member access is very valuable. Putting it in the standard library as dynamicType(_:) does still allow for that function to be implemented using compiler magic.<br></p><p>Another approach would be to introduce a new dynamictype keyword that doesn’t need to be accessed as a member of self, and keep Self the way it is.  Self should work in structs as a type alias.<br></p><p>Another perspective is that .dynamicType is just an implicitly synthesized property on all type.<br></p><p>Subjectively, having dynamicType as a member feels weird.<br></p><p>If retained as a keyword, I believe it should be lowercased to `dynamictype`. This leaves two remaining outliers (`willSet` and `didSet`). If it is re-introduced as a stdlib function, it should be `dynamicType()`.<br></p><p>------<br></p><p>ORIGINAL DESIGN TEAM FEEDBACK<br>SE-0068: Expanding Swift Self to class members and value types &lt;file:///Users/alexmartini/DevPubs%20Git%20Repositories/Swift%20Language%20Review/_build/html/LR_MeetingNotes/2016-04-20.html#se-0068-expanding-swift-self-to-class-members-and-value-types&gt;<br>https://github.com/apple/swift-evolution/blob/master/proposals/0068-universal-self.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0068-universal-self.md&gt;<br>We have one keyword left in the language, dynamicType, which is camel cased. This proposal renames it to Self instead.<br></p><p>In a static function today, self.dynamicType will give you a metatype but the non-member Self will not. The most useful reason to reference it is to call an initializer. It makes accessing the metatype weirder. It’s not Self.Type; that’s a type — you have to spell it Self.type.<br></p><p>Quiz time! What do each of the permutations mean?<br></p><p>Self.self<br>self.Self<br>Self.Self<br>self.self<br>The number of capital letters gives you the level of meta-ness. This is very subtle, which is probably not a good thing.<br></p><p>Another approach would be to introduce a new dynamictype keyword that doesn’t need to be accessed as a member of self, and keep Self the way it is.  Self should work in structs as a type alias.<br></p><p>Why don’t we turn this into a standard library function? It’s not something you need so often that the member access is very valuable. Putting it in the standard library as dynamicType(_:) does still allow for that function to be implemented using compiler magic.<br></p><p>func dynamicType&lt;T&gt;(_: T) -&gt; T.Type { }<br>We have a proposal to remove .self on types. One reason .self exists is to avoid the mistake of writing let x = Int — the compiler will give you a weird type error later on in code if the value of x is what we today call Int.self but you meant to call the Int() initializer. Creating a metatype is not a common operation, so doing it explicitly is a good thing.<br></p><p>It’s weird that you can use the metatype directly to construct something or to do member access, but you can’t access it as a bare value.<br></p><p>Coming back to this proposal, if we removed .self why would we want to add .Self?<br></p><p>If you have a variable whose value is a metatype, you also keep its name in lower case. So Self makes a little less sense from that aspect too.<br></p><p>Another perspective is that .dynamicType is just an implicitly synthesized property on all type.<br></p><p>We do have other keywords that follow the dot on types, Int.Type and Fooable.Protocol, so this isn’t the only thing. Those things are magic nested types.<br></p><p>Subjectively, having dynamicType as a member feels weird.<br></p><p>If .self goes away, the four-self example above is simplified, and .Self doesn’t make sense anymore. There’s also the difference that .Self would be a runtime thing.<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160421/9718b192/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0068: Expanding Swift Self to class members and value types</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April 24, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0068-universal-self.md<br></p><p>I&#39;m not totally clear what&#39;s being proposed here.<br></p><p>Is this valid?<br></p><p>	class Foo {<br>		static func bar() { … }<br>		func baz(other: Foo) {<br>			Self.bar()<br>		}<br>	}<br></p><p>Is this valid?<br></p><p>	struct Foo {		// note: not class<br>		static func bar() { … }<br>		func baz(other: Foo) {<br>			Self.bar()<br>		}<br>	}<br></p><p>Is this valid?<br></p><p>	class Foo {<br>		static func bar() { … }<br>		func baz(other: Foo) {<br>			other.Self.bar()	// note: not self<br>		}<br>	}<br></p><p>Is this valid?<br></p><p>	struct Foo {		// note: not class<br>		static func bar() { … }<br>		func baz(other: Foo) {<br>			other.Self.bar()	// note: not self<br>		}<br>	}<br></p><p>Can a class have a variable (inside a method) of type Self? A return value? A parameter? A property?<br></p><p>Can a value type have a variable (inside a method) of type Self? A return value? A parameter? A property?<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0068: Expanding Swift Self to class members and value types</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April 24, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Apr 24, 2016, at 7:57 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0068-universal-self.md<br>&gt; <br>&gt; I&#39;m not totally clear what&#39;s being proposed here.<br>&gt; <br>&gt; Is this valid?<br>&gt; <br>&gt; 	class Foo {<br>&gt; 		static func bar() { … }<br>&gt; 		func baz(other: Foo) {<br>&gt; 			Self.bar()<br>&gt; 		}<br>&gt; 	}<br></p><p>This is valid. Foo.bar(). <br></p><p>&gt; <br>&gt; Is this valid?<br>&gt; <br>&gt; 	struct Foo {		// note: not class<br>&gt; 		static func bar() { … }<br>&gt; 		func baz(other: Foo) {<br>&gt; 			Self.bar()<br>&gt; 		}<br>&gt; 	}<br>&gt; <br></p><p>This is valid. Foo.bar()<br></p><p>&gt; Is this valid?<br>&gt; <br>&gt; 	class Foo {<br>&gt; 		static func bar() { … }<br>&gt; 		func baz(other: Foo) {<br>&gt; 			other.Self.bar()	// note: not self<br>&gt; 		}<br>&gt; 	}<br>&gt; <br></p><p>This is valid. Foo.bar(). All instances of the class share the static bar() member.<br></p><p>&gt; Is this valid?<br>&gt; <br>&gt; 	struct Foo {		// note: not class<br>&gt; 		static func bar() { … }<br>&gt; 		func baz(other: Foo) {<br>&gt; 			other.Self.bar()	// note: not self<br>&gt; 		}<br>&gt; 	}<br>&gt; <br></p><p>This is should be valid although it currently errors with `dynamicType` (error: type &#39;Foo&#39; has no member &#39;bar&#39;). <br></p><p>You missed subclassing, although being static members, methods are final and cannot be overridden. But if class Boo : Foo calls Self.bar() and Foo implements the static member, it&#39;s called from the Boo instance and uses the Foo implementation.<br></p><p>&gt; Can a class have a variable (inside a method) of type Self? A return value? A parameter? A property?<br></p><p>I think it should, however that technically may need to be of type #Self (per the original draft) instead of Self and have it expanded to the defining type at compile time.<br></p><p>&gt; Can a value type have a variable (inside a method) of type Self? A return value? A parameter? A property?<br></p><p>Ditto.<br></p><p>-- E<br></p><p>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160424/2e4a60a3/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
