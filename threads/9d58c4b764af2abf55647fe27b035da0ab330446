<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ec8a60462a511e833c5c4a83b424c958?s=50"></div><header><strong>[Pitch] Tuple Destructuring in Parameter Lists</strong> from <string>Dennis Weissmann</string> &lt;dennis at dennisweissmann.me&gt;<p>May  5, 2016 at 08:00:00pm</p></header><div class="content"><p>Following a short discussion with positive feedback on [swift-users](http://thread.gmane.org/gmane.comp.lang.swift.user/1812) I’d like to discuss the following:<br></p><p>Tuples should be destructible into their components in parameter lists.<br></p><p>Consider the following code:<br></p><p>let a = [0,1,2,3,4,5,6,7,8,9]<br>let b = [0,1,2,3,4,5,6,7,8,9]<br></p><p>let c = zip(a,b).reduce(0) { acc, tuple in<br>  acc + tuple.0 + tuple.1<br>}<br></p><p>tuple is of type (Int, Int).<br></p><p>The problem is that the calculation is not very comprehensible due to .0 and .1. That’s when destructuring tuples directly in the parameter list comes into play:<br></p><p>let c = zip(a,b).reduce(0) { acc, (valueA, valueB) in<br>  acc + valueA + valueB<br>}<br></p><p>The above is what I propose should be accepted by the compiler (but currently isn’t).<br></p><p>Currently tuple destructuring is possible like this:<br></p><p>let c = zip(a,b).reduce(0) { (acc, tuple) in<br>  let (valueA, valueB) = tuple<br>  return acc + valueA + valueB<br>}<br></p><p>This is not about saving one line ;-). I just find it much more intuitive to destructure the tuple in the parameter list itself.<br></p><p>The same thing could be done for functions:<br></p><p>func takesATuple(someInt: Int, tuple: (String, String))<br></p><p>Here we also need to destructure the tuple inside the function, but the intuitive place (at least for me) to do this would be the parameter list.<br></p><p>In the following example I&#39;m making use of Swift’s feature to name parameters different from their labels (for internal use inside the function, this is not visible to consumers of the API):<br></p><p>func takesATuple(someInt: Int, tuple (valueA, valueB): (String, String))<br></p><p>Here valueA and valueB would be directly usable within the function. The tuple as a whole would not be available anymore.<br></p><p><br>Now it’s your turn!<br></p><p>1. What do you think?<br>2. Is this worth being discussed now (i.e. is it implementable in the Swift 3 timeframe) or should I delay it?<br></p><p>Cheers,<br></p><p>- Dennis<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160505/9d580446/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Pitch] Tuple Destructuring in Parameter Lists</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>May  5, 2016 at 09:00:00pm</p></header><div class="content"><p>+1<br>I have wanted this since the first beta. I hadn&#39;t proposed because I<br>haven&#39;t come up with a nice syntax to do this in functions/methods. I don&#39;t<br>particularly like<br>    func takesATuple(someInt: Int, tuple (valueA, valueB): (String, String))<br></p><p>and the closes that I have come is to simply reuse the closure syntax with<br></p><p>    func takesATuple(someInt: Int, tuple: (String, String)) {<br>(someInt, (valueA,<br>valueB)) in<br></p><p>but that gets confusing in my opinion, specifically if you choose to have<br>different names inside and outside.<br></p><p><br></p><p>On Thu, May 5, 2016 at 11:22 AM, Dennis Weissmann via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Following a short discussion with positive feedback on [swift-users](<br>&gt; http://thread.gmane.org/gmane.comp.lang.swift.user/1812) I’d like to<br>&gt; discuss the following:<br>&gt;<br>&gt; Tuples should be destructible into their components in parameter lists.<br>&gt;<br>&gt; Consider the following code:<br>&gt;<br>&gt; let a = [0,1,2,3,4,5,6,7,8,9]<br>&gt; let b = [0,1,2,3,4,5,6,7,8,9]<br>&gt;<br>&gt; let c = zip(a,b).reduce(0) { acc, tuple in<br>&gt;   acc + tuple.0 + tuple.1<br>&gt; }<br>&gt;<br>&gt; tuple is of type (Int, Int).<br>&gt;<br>&gt; The problem is that the calculation is not very comprehensible due to .0<br>&gt; and .1. That’s when destructuring tuples directly in the parameter list<br>&gt; comes into play:<br>&gt;<br>&gt; let c = zip(a,b).reduce(0) { acc, (valueA, valueB) in<br>&gt;   acc + valueA + valueB<br>&gt; }<br>&gt;<br>&gt; The above is what I propose should be accepted by the compiler (but<br>&gt; currently isn’t).<br>&gt;<br>&gt; Currently tuple destructuring is possible like this:<br>&gt;<br>&gt; let c = zip(a,b).reduce(0) { (acc, tuple) in<br>&gt;   let (valueA, valueB) = tuple<br>&gt;   return acc + valueA + valueB<br>&gt; }<br>&gt;<br>&gt; This is not about saving one line ;-). I just find it much more intuitive<br>&gt; to destructure the tuple in the parameter list itself.<br>&gt;<br>&gt; The same thing could be done for functions:<br>&gt;<br>&gt; func takesATuple(someInt: Int, tuple: (String, String))<br>&gt;<br>&gt; Here we also need to destructure the tuple inside the function, but the<br>&gt; intuitive place (at least for me) to do this would be the parameter list.<br>&gt;<br>&gt; In the following example I&#39;m making use of Swift’s feature to name<br>&gt; parameters different from their labels (for internal use inside the<br>&gt; function, this is not visible to consumers of the API):<br>&gt;<br>&gt; func takesATuple(someInt: Int, tuple (valueA, valueB): (String, String))<br>&gt;<br>&gt; Here valueA and valueB would be directly usable within the function. The<br>&gt; tuple as a whole would not be available anymore.<br>&gt;<br>&gt;<br>&gt; Now it’s your turn!<br>&gt;<br>&gt; 1. What do you think?<br>&gt; 2. Is this worth being discussed now (i.e. is it implementable in the<br>&gt; Swift 3 timeframe) or should I delay it?<br>&gt;<br>&gt; Cheers,<br>&gt;<br>&gt; - Dennis<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160505/ada9e23a/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/15ed660cd9d971062f9dd5084932a698?s=50"></div><header><strong>[Pitch] Tuple Destructuring in Parameter Lists</strong> from <string>David Rönnqvist</string> &lt;david.ronnqvist at gmail.com&gt;<p>May  6, 2016 at 11:00:00am</p></header><div class="content"><p>+1 I’ve tried to write parameter lists like `acc, (valueA, valueB) in` in the past, expecting it to work like this<br></p><p>&gt; On 05 May 2016, at 20:22, Dennis Weissmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Following a short discussion with positive feedback on [swift-users](http://thread.gmane.org/gmane.comp.lang.swift.user/1812 &lt;http://thread.gmane.org/gmane.comp.lang.swift.user/1812&gt;) I’d like to discuss the following:<br>&gt; <br>&gt; Tuples should be destructible into their components in parameter lists.<br>&gt; <br>&gt; Consider the following code:<br>&gt; <br>&gt; let a = [0,1,2,3,4,5,6,7,8,9]<br>&gt; let b = [0,1,2,3,4,5,6,7,8,9]<br>&gt; <br>&gt; let c = zip(a,b).reduce(0) { acc, tuple in<br>&gt;   acc + tuple.0 + tuple.1<br>&gt; }<br>&gt; <br>&gt; tuple is of type (Int, Int).<br>&gt; <br>&gt; The problem is that the calculation is not very comprehensible due to .0 and .1. That’s when destructuring tuples directly in the parameter list comes into play:<br>&gt; <br>&gt; let c = zip(a,b).reduce(0) { acc, (valueA, valueB) in<br>&gt;   acc + valueA + valueB<br>&gt; }<br>&gt; <br>&gt; The above is what I propose should be accepted by the compiler (but currently isn’t).<br>&gt; <br>&gt; Currently tuple destructuring is possible like this:<br>&gt; <br>&gt; let c = zip(a,b).reduce(0) { (acc, tuple) in<br>&gt;   let (valueA, valueB) = tuple<br>&gt;   return acc + valueA + valueB<br>&gt; }<br>&gt; <br>&gt; This is not about saving one line ;-). I just find it much more intuitive to destructure the tuple in the parameter list itself.<br>&gt; <br>&gt; The same thing could be done for functions:<br>&gt; <br>&gt; func takesATuple(someInt: Int, tuple: (String, String))<br>&gt; <br>&gt; Here we also need to destructure the tuple inside the function, but the intuitive place (at least for me) to do this would be the parameter list.<br>&gt; <br>&gt; In the following example I&#39;m making use of Swift’s feature to name parameters different from their labels (for internal use inside the function, this is not visible to consumers of the API):<br>&gt; <br>&gt; func takesATuple(someInt: Int, tuple (valueA, valueB): (String, String))<br>&gt; <br>&gt; Here valueA and valueB would be directly usable within the function. The tuple as a whole would not be available anymore.<br>&gt; <br>&gt; <br>&gt; Now it’s your turn!<br>&gt; <br>&gt; 1. What do you think?<br>&gt; 2. Is this worth being discussed now (i.e. is it implementable in the Swift 3 timeframe) or should I delay it?<br>&gt; <br>&gt; Cheers,<br>&gt; <br>&gt; - Dennis<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160506/d753ceec/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4db4fede2f4e473341b873406b68e4e1?s=50"></div><header><strong>[Pitch] Tuple Destructuring in Parameter Lists</strong> from <string>Geordie Jay</string> &lt;geojay at gmail.com&gt;<p>May  8, 2016 at 06:00:00pm</p></header><div class="content"><p>Comments below<br></p><p>&gt; Am 05.05.2016 um 20:22 schrieb Dennis Weissmann via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Following a short discussion with positive feedback on [swift-users](http://thread.gmane.org/gmane.comp.lang.swift.user/1812 &lt;http://thread.gmane.org/gmane.comp.lang.swift.user/1812&gt;) I’d like to discuss the following:<br>&gt; <br>&gt; Tuples should be destructible into their components in parameter lists.<br>&gt; <br>&gt; Consider the following code:<br>&gt; <br>&gt; let a = [0,1,2,3,4,5,6,7,8,9]<br>&gt; let b = [0,1,2,3,4,5,6,7,8,9]<br>&gt; <br>&gt; let c = zip(a,b).reduce(0) { acc, tuple in<br>&gt;   acc + tuple.0 + tuple.1<br>&gt; }<br>&gt; <br>&gt; tuple is of type (Int, Int).<br>&gt; <br>&gt; The problem is that the calculation is not very comprehensible due to .0 and .1. That’s when destructuring tuples directly in the parameter list comes into play:<br>&gt; <br>&gt; let c = zip(a,b).reduce(0) { acc, (valueA, valueB) in<br>&gt;   acc + valueA + valueB<br>&gt; }<br></p><p>+1 I think this is a great way to go about it.<br></p><p>&gt; <br>&gt; The above is what I propose should be accepted by the compiler (but currently isn’t).<br>&gt; <br>&gt; Currently tuple destructuring is possible like this:<br>&gt; <br>&gt; let c = zip(a,b).reduce(0) { (acc, tuple) in<br>&gt;   let (valueA, valueB) = tuple<br>&gt;   return acc + valueA + valueB<br>&gt; }<br>&gt; <br>&gt; This is not about saving one line ;-). I just find it much more intuitive to destructure the tuple in the parameter list itself.<br></p><p>Agreed<br></p><p>&gt; <br>&gt; The same thing could be done for functions:<br>&gt; <br>&gt; func takesATuple(someInt: Int, tuple: (String, String))<br>&gt; <br>&gt; Here we also need to destructure the tuple inside the function, but the intuitive place (at least for me) to do this would be the parameter list.<br>&gt; <br>&gt; In the following example I&#39;m making use of Swift’s feature to name parameters different from their labels (for internal use inside the function, this is not visible to consumers of the API):<br>&gt; <br>&gt; func takesATuple(someInt: Int, tuple (valueA, valueB): (String, String))<br></p><p><br>I’m not such a fan of this though. I realize what I’m about to write here is discussing a slightly different point but bear with me: I was under the impression it was already possible to do something like this (maybe only possible with typealiases):<br></p><p>func takesATuple(someInt: Int, tuple: (valueA: String, valueB: String)) {}<br></p><p>I find that syntax readable and extensible: you can make a type alias for your tuple type &#39;(valueA: String, valueB: String)‘, you can then use it like this:<br></p><p>func takesATuple(someInt: Int, tuple: MyAliasedTupleType) {<br>  print(tuple.valueA)<br>}<br></p><p>It’s true that you still have the ‚overhead‘ of having to type tuple. before accessing its members. But this is almost always what I want (hopefully you’d never actually name your tuple ‚tuple‘, instead it’d be a logical namespace for what it contains). Do you have a real-world example where you’d need this? To me it seems that in a case like this the API that produced the tuple would need refining rather than the language itself.<br></p><p>&gt; <br>&gt; Here valueA and valueB would be directly usable within the function. The tuple as a whole would not be available anymore.<br>&gt; <br>&gt; <br>&gt; Now it’s your turn!<br>&gt; <br>&gt; 1. What do you think?<br>&gt; 2. Is this worth being discussed now (i.e. is it implementable in the Swift 3 timeframe) or should I delay it?<br>&gt; <br>&gt; Cheers,<br>&gt; <br>&gt; - Dennis<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160508/1242a2eb/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 455 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160508/1242a2eb/attachment.sig&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ec8a60462a511e833c5c4a83b424c958?s=50"></div><header><strong>[Pitch] Tuple Destructuring in Parameter Lists</strong> from <string>Dennis Weissmann</string> &lt;dennis at dennisweissmann.me&gt;<p>May 11, 2016 at 10:00:00am</p></header><div class="content"><p>Thanks for all your feedback!<br></p><p>This is the current statistic:<br>Closure syntax: All positive<br>Function syntax: 3 (or 4) positive, 2 negative<br></p><p>I’ll try to address the concern Geordie and T.J. have.<br></p><p>&gt; func takesATuple(someInt: Int, tuple: (valueA: String, valueB: String)) {}<br></p><p>&gt; It’s true that you still have the ‚overhead‘ of having to type tuple. before accessing its members. But this is almost always what I want (hopefully you’d never actually name your tuple ‚tuple‘, instead it’d be a logical namespace for what it contains). Do you have a real-world example where you’d need this? To me it seems that in a case like this the API that produced the tuple would need refining rather than the language itself.<br></p><p><br>What you suggest here is not tuple destructuring but using labeled tuples. And while I’m totally with you that this is for many cases the better approach, I still think we should introduce it to functions as well, for consistency and readability reasons.<br>In the end inconsistency is what led to this thread because tuple destructuring is already possible today - in for loops:<br></p><p>let stringTuple = [(&quot;&quot;, &quot;”), (&quot;&quot;, &quot;&quot;)]<br>for (i, j) in stringTuple {}<br></p><p>That made me wonder if it’s also possible for closures (because I needed it there - and eventually someone will definitely wonder if it’s possible for function arguments as well).<br></p><p>You also asked me for my use case. To be honest, I don’t have one for the function version, but imagine the following:<br></p><p>My current closure use case is this (template.points and resampledPoints are of type [CGPoint]):<br></p><p>let localHighestSimilarity = zip(template.points, resampledPoints).reduce(0.0) { accumulator, points in<br>  let (template, resampled) = points<br>  return accumulator + Double(template.x * resampled.x + template.y * resampled.y)<br>}<br></p><p>To reuse this code elsewhere I maybe want to refactor the closure into a function (using your labeled tuple suggestion):<br></p><p>func accumulateSimilarity(accumulator: Double, for points: (point1: CGPoint, point2: CGPoint)) -&gt; Double {<br>  return accumulator + Double(points.point1.x * points.point2.x + points.point1.y * points.point2.y)<br>}<br></p><p>This isn’t particularity readable (image passing a CGRect and you need the points or a more complex calculation). Compare it to this:<br></p><p>func accumulateSimilarity(accumulator: Double, for (point1, point2): (CGPoint, CGPoint)) -&gt; Double {<br>  return accumulator + Double(point1.x * point2.x + point1.y * point2.y)<br>}<br></p><p>You can of course still pass a named tuple instead of an unnamed, but it doesn’t make any difference, which brings me to an aside*.<br></p><p>I think the second approach makes the calculation much more comprehensible and it just feels “intuitive” (again, at least for me) :).<br></p><p><br>- Dennis<br></p><p>* I’m not sure how scientifically correct the following statement is but strictly speaking (at least for me) (valueA: String, valueB: String) is not of the same type as (String, String) just like func d(string: String, int: Int) is different from func e(_: String, _: Int) though in Swift the tuples are interchangeable (you can pass one where the other is expected).<br></p><p>&gt; On May 8, 2016, at 6:10 PM, Geordie J &lt;geojay at gmail.com&gt; wrote:<br>&gt; <br>&gt; Comments below<br>&gt; <br>&gt;&gt; Am 05.05.2016 um 20:22 schrieb Dennis Weissmann via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt; Following a short discussion with positive feedback on [swift-users](http://thread.gmane.org/gmane.comp.lang.swift.user/1812 &lt;http://thread.gmane.org/gmane.comp.lang.swift.user/1812&gt;) I’d like to discuss the following:<br>&gt;&gt; <br>&gt;&gt; Tuples should be destructible into their components in parameter lists.<br>&gt;&gt; <br>&gt;&gt; Consider the following code:<br>&gt;&gt; <br>&gt;&gt; let a = [0,1,2,3,4,5,6,7,8,9]<br>&gt;&gt; let b = [0,1,2,3,4,5,6,7,8,9]<br>&gt;&gt; <br>&gt;&gt; let c = zip(a,b).reduce(0) { acc, tuple in<br>&gt;&gt;   acc + tuple.0 + tuple.1<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; tuple is of type (Int, Int).<br>&gt;&gt; <br>&gt;&gt; The problem is that the calculation is not very comprehensible due to .0 and .1. That’s when destructuring tuples directly in the parameter list comes into play:<br>&gt;&gt; <br>&gt;&gt; let c = zip(a,b).reduce(0) { acc, (valueA, valueB) in<br>&gt;&gt;   acc + valueA + valueB<br>&gt;&gt; }<br>&gt; <br>&gt; +1 I think this is a great way to go about it.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; The above is what I propose should be accepted by the compiler (but currently isn’t).<br>&gt;&gt; <br>&gt;&gt; Currently tuple destructuring is possible like this:<br>&gt;&gt; <br>&gt;&gt; let c = zip(a,b).reduce(0) { (acc, tuple) in<br>&gt;&gt;   let (valueA, valueB) = tuple<br>&gt;&gt;   return acc + valueA + valueB<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This is not about saving one line ;-). I just find it much more intuitive to destructure the tuple in the parameter list itself.<br>&gt; <br>&gt; Agreed<br>&gt; <br>&gt;&gt; <br>&gt;&gt; The same thing could be done for functions:<br>&gt;&gt; <br>&gt;&gt; func takesATuple(someInt: Int, tuple: (String, String))<br>&gt;&gt; <br>&gt;&gt; Here we also need to destructure the tuple inside the function, but the intuitive place (at least for me) to do this would be the parameter list.<br>&gt;&gt; <br>&gt;&gt; In the following example I&#39;m making use of Swift’s feature to name parameters different from their labels (for internal use inside the function, this is not visible to consumers of the API):<br>&gt;&gt; <br>&gt;&gt; func takesATuple(someInt: Int, tuple (valueA, valueB): (String, String))<br>&gt; <br>&gt; <br>&gt; I’m not such a fan of this though. I realize what I’m about to write here is discussing a slightly different point but bear with me: I was under the impression it was already possible to do something like this (maybe only possible with typealiases):<br>&gt; <br>&gt; func takesATuple(someInt: Int, tuple: (valueA: String, valueB: String)) {}<br>&gt; <br>&gt; I find that syntax readable and extensible: you can make a type alias for your tuple type &#39;(valueA: String, valueB: String)‘, you can then use it like this:<br>&gt; <br>&gt; func takesATuple(someInt: Int, tuple: MyAliasedTupleType) {<br>&gt;   print(tuple.valueA)<br>&gt; }<br>&gt; <br>&gt; It’s true that you still have the ‚overhead‘ of having to type tuple. before accessing its members. But this is almost always what I want (hopefully you’d never actually name your tuple ‚tuple‘, instead it’d be a logical namespace for what it contains). Do you have a real-world example where you’d need this? To me it seems that in a case like this the API that produced the tuple would need refining rather than the language itself.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Here valueA and valueB would be directly usable within the function. The tuple as a whole would not be available anymore.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Now it’s your turn!<br>&gt;&gt; <br>&gt;&gt; 1. What do you think?<br>&gt;&gt; 2. Is this worth being discussed now (i.e. is it implementable in the Swift 3 timeframe) or should I delay it?<br>&gt;&gt; <br>&gt;&gt; Cheers,<br>&gt;&gt; <br>&gt;&gt; - Dennis<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160511/c23b5aed/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ec8a60462a511e833c5c4a83b424c958?s=50"></div><header><strong>[Pitch] Tuple Destructuring in Parameter Lists</strong> from <string>Dennis Weissmann</string> &lt;dennis at dennisweissmann.me&gt;<p>May 29, 2016 at 11:00:00pm</p></header><div class="content"><p>Thanks for everyone participating in this discussion! :)<br>I’ve drafted a formal proposal, it is available here: https://github.com/dennisweissmann/swift-evolution/blob/tuple-destructuring/proposals/0000-tuple-destructuring.md<br></p><p>Please let me know what you think (it would be great if a native speaker could take a look at grammar and spelling mistakes). Thanks!<br>Tuple Destructuring in Parameter Lists<br>Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;<br>Author(s): Dennis Weissmann &lt;https://github.com/dennisweissmann&gt;<br>Status: Awaiting review &lt;file:///Volumes/Data/Desktop/swift-evolution/proposals/0000-tuple-destructuring.md#rationale&gt;<br>Review manager: TBD<br>Introduction<br>Tuple destructuring is the process of extracting elements from tuples.<br></p><p>This is valid today:<br></p><p>Swift<br>let point = (x: 20.0, y: 31.0, z: 42.0)<br>// Approach 1:<br>let x = point.x<br>let y = point.y<br>let z = point.z<br></p><p>// Approach 2:<br>let (x, y, z) = point<br></p><p>// For-in loops support tuple destructuring<br>for (x, y, z) in [point] {<br>  // use x, y, z<br>}<br>Swift-evolution thread: [Pitch] Tuple Destructuring in Parameter Lists &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/16190&gt;<br>Motivation<br>This proposal seeks to generalize this behavior for every use case where tuples need to be destructured. These are parameter lists in closures and parameter lists in functions. Consistency is a major goal of Swift but it is currently only possible to destructure tuples in the above mentioned places.<br></p><p>Proposed solution<br>Extending tuple destructuring to parameter lists seems natural and improves consistency in the language.<br></p><p>Closures<br></p><p>Parameters in closures are currently not directly destructable. They can either be accessed via .0, .1, etc. or can be destructured by assigning them to variables in an explicit statement.<br></p><p>It feels natural to do this right in the parameter list itself (just like with for-in loops).<br></p><p>Swift<br>let a = [0,1,2,3,4,5,6,7,8,9]<br>let b = [0,1,2,3,4,5,6,7,8,9]<br></p><p>// Allowed today:<br>let c = zip(a,b).reduce(0) { acc, tuple in<br>  acc + tuple.0 + tuple.1<br>}<br></p><p>// Also allowed today:<br>let c = zip(a,b).reduce(0) { acc, tuple in<br>  let (valueA, valueB) = tuple<br>  return acc + valueA + valueB<br>}<br></p><p>// Proposed syntax:<br>let c = zip(a,b).reduce(0) { acc, (valueA, valueB) in<br>  acc + valueA + valueB<br>}<br>Functions<br></p><p>When it comes to functions this proposal uses Swift&#39;s feature of differentiating between internal and external parameter names.<br></p><p>Swift<br>// Allowed today:<br>func takesATuple(tuple: (Int, Int)) {<br>  let valueA = tuple.0<br>  let valueB = tuple.1<br>  // ...<br>}<br></p><p>// Proposed syntax:<br>func takesATuple(tuple (valueA, valueB): (Int, Int)) {<br>  // use valueA<br>  // use valueB<br>}<br>This design has no visible effects to the call site of a function but makes it very convenient for the function author to use the tuple&#39;s elements inside the function body.<br></p><p>Impact on existing code<br>This feature is strictly additive and does not effect current code.<br></p><p>Alternatives considered<br>Leave it as is destructure in a separate assignment.<br></p><p><br></p><p>- Dennis<br></p><p>&gt; On May 11, 2016, at 10:12 AM, Dennis Weissmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Thanks for all your feedback!<br>&gt; <br>&gt; This is the current statistic:<br>&gt; Closure syntax: All positive<br>&gt; Function syntax: 3 (or 4) positive, 2 negative<br>&gt; <br>&gt; I’ll try to address the concern Geordie and T.J. have.<br>&gt; <br>&gt;&gt; func takesATuple(someInt: Int, tuple: (valueA: String, valueB: String)) {}<br>&gt; <br>&gt;&gt; It’s true that you still have the ‚overhead‘ of having to type tuple. before accessing its members. But this is almost always what I want (hopefully you’d never actually name your tuple ‚tuple‘, instead it’d be a logical namespace for what it contains). Do you have a real-world example where you’d need this? To me it seems that in a case like this the API that produced the tuple would need refining rather than the language itself.<br>&gt; <br>&gt; <br>&gt; What you suggest here is not tuple destructuring but using labeled tuples. And while I’m totally with you that this is for many cases the better approach, I still think we should introduce it to functions as well, for consistency and readability reasons.<br>&gt; In the end inconsistency is what led to this thread because tuple destructuring is already possible today - in for loops:<br>&gt; <br>&gt; let stringTuple = [(&quot;&quot;, &quot;”), (&quot;&quot;, &quot;&quot;)]<br>&gt; for (i, j) in stringTuple {}<br>&gt; <br>&gt; That made me wonder if it’s also possible for closures (because I needed it there - and eventually someone will definitely wonder if it’s possible for function arguments as well).<br>&gt; <br>&gt; You also asked me for my use case. To be honest, I don’t have one for the function version, but imagine the following:<br>&gt; <br>&gt; My current closure use case is this (template.points and resampledPoints are of type [CGPoint]):<br>&gt; <br>&gt; let localHighestSimilarity = zip(template.points, resampledPoints).reduce(0.0) { accumulator, points in<br>&gt;   let (template, resampled) = points<br>&gt;   return accumulator + Double(template.x * resampled.x + template.y * resampled.y)<br>&gt; }<br>&gt; <br>&gt; To reuse this code elsewhere I maybe want to refactor the closure into a function (using your labeled tuple suggestion):<br>&gt; <br>&gt; func accumulateSimilarity(accumulator: Double, for points: (point1: CGPoint, point2: CGPoint)) -&gt; Double {<br>&gt;   return accumulator + Double(points.point1.x * points.point2.x + points.point1.y * points.point2.y)<br>&gt; }<br>&gt; <br>&gt; This isn’t particularity readable (image passing a CGRect and you need the points or a more complex calculation). Compare it to this:<br>&gt; <br>&gt; func accumulateSimilarity(accumulator: Double, for (point1, point2): (CGPoint, CGPoint)) -&gt; Double {<br>&gt;   return accumulator + Double(point1.x * point2.x + point1.y * point2.y)<br>&gt; }<br>&gt; <br>&gt; You can of course still pass a named tuple instead of an unnamed, but it doesn’t make any difference, which brings me to an aside*.<br>&gt; <br>&gt; I think the second approach makes the calculation much more comprehensible and it just feels “intuitive” (again, at least for me) :).<br>&gt; <br>&gt; <br>&gt; - Dennis<br>&gt; <br>&gt; * I’m not sure how scientifically correct the following statement is but strictly speaking (at least for me) (valueA: String, valueB: String) is not of the same type as (String, String) just like func d(string: String, int: Int) is different from func e(_: String, _: Int) though in Swift the tuples are interchangeable (you can pass one where the other is expected).<br>&gt; <br>&gt;&gt; On May 8, 2016, at 6:10 PM, Geordie J &lt;geojay at gmail.com &lt;mailto:geojay at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Comments below<br>&gt;&gt; <br>&gt;&gt;&gt; Am 05.05.2016 um 20:22 schrieb Dennis Weissmann via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Following a short discussion with positive feedback on [swift-users](http://thread.gmane.org/gmane.comp.lang.swift.user/1812 &lt;http://thread.gmane.org/gmane.comp.lang.swift.user/1812&gt;) I’d like to discuss the following:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Tuples should be destructible into their components in parameter lists.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Consider the following code:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let a = [0,1,2,3,4,5,6,7,8,9]<br>&gt;&gt;&gt; let b = [0,1,2,3,4,5,6,7,8,9]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let c = zip(a,b).reduce(0) { acc, tuple in<br>&gt;&gt;&gt;   acc + tuple.0 + tuple.1<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; tuple is of type (Int, Int).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The problem is that the calculation is not very comprehensible due to .0 and .1. That’s when destructuring tuples directly in the parameter list comes into play:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let c = zip(a,b).reduce(0) { acc, (valueA, valueB) in<br>&gt;&gt;&gt;   acc + valueA + valueB<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; +1 I think this is a great way to go about it.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The above is what I propose should be accepted by the compiler (but currently isn’t).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Currently tuple destructuring is possible like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let c = zip(a,b).reduce(0) { (acc, tuple) in<br>&gt;&gt;&gt;   let (valueA, valueB) = tuple<br>&gt;&gt;&gt;   return acc + valueA + valueB<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is not about saving one line ;-). I just find it much more intuitive to destructure the tuple in the parameter list itself.<br>&gt;&gt; <br>&gt;&gt; Agreed<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The same thing could be done for functions:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func takesATuple(someInt: Int, tuple: (String, String))<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here we also need to destructure the tuple inside the function, but the intuitive place (at least for me) to do this would be the parameter list.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In the following example I&#39;m making use of Swift’s feature to name parameters different from their labels (for internal use inside the function, this is not visible to consumers of the API):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func takesATuple(someInt: Int, tuple (valueA, valueB): (String, String))<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I’m not such a fan of this though. I realize what I’m about to write here is discussing a slightly different point but bear with me: I was under the impression it was already possible to do something like this (maybe only possible with typealiases):<br>&gt;&gt; <br>&gt;&gt; func takesATuple(someInt: Int, tuple: (valueA: String, valueB: String)) {}<br>&gt;&gt; <br>&gt;&gt; I find that syntax readable and extensible: you can make a type alias for your tuple type &#39;(valueA: String, valueB: String)‘, you can then use it like this:<br>&gt;&gt; <br>&gt;&gt; func takesATuple(someInt: Int, tuple: MyAliasedTupleType) {<br>&gt;&gt;   print(tuple.valueA)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; It’s true that you still have the ‚overhead‘ of having to type tuple. before accessing its members. But this is almost always what I want (hopefully you’d never actually name your tuple ‚tuple‘, instead it’d be a logical namespace for what it contains). Do you have a real-world example where you’d need this? To me it seems that in a case like this the API that produced the tuple would need refining rather than the language itself.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here valueA and valueB would be directly usable within the function. The tuple as a whole would not be available anymore.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Now it’s your turn!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. What do you think?<br>&gt;&gt;&gt; 2. Is this worth being discussed now (i.e. is it implementable in the Swift 3 timeframe) or should I delay it?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Dennis<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160529/f058a64f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Pitch] Tuple Destructuring in Parameter Lists</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 30, 2016 at 06:00:00am</p></header><div class="content"><p>&gt; // Allowed today:<br>&gt; func takesATuple(tuple: (Int, Int)) {<br>&gt;   let valueA = tuple.0<br>&gt;   let valueB = tuple.1<br>&gt;   // ...<br>&gt; }<br>&gt; <br>&gt; // Proposed syntax:<br>&gt; func takesATuple(tuple (valueA, valueB): (Int, Int)) {<br>&gt;   // use valueA<br>&gt;   // use valueB<br>&gt; }<br></p><p>Personally, I find this example confusing because the label is &quot;tuple&quot;, which kind of reads like a keyword, and because you&#39;re using the same name for the label and variable. If I understand the semantics you&#39;re proposing correctly, I think it would be clearer to write this example like:<br></p><p>// Allowed today:<br>func takes(a tuple: (Int, Int)) {<br>  let valueA = tuple.0<br>  let valueB = tuple.1<br>  // ...<br>}<br></p><p>// Proposed syntax:<br>func takes(a (valueA, valueB): (Int, Int)) {<br>  // use valueA<br>  // use valueB<br>}<br></p><p>Incidentally, it may also be a good idea to define what happens if you write:<br></p><p>func takes((valueA, valueB): (Int, Int))<br></p><p>Normally, if there&#39;s no separate label and variable name, they&#39;re the same, but you can&#39;t have a label like `(valueA, valueB)`. I see two reasonably sensible answers here:<br></p><p>1. It&#39;s equivalent to writing `_ (valueA, valueB)`.<br>2. It&#39;s illegal. You have to write a label, or `_` if you don&#39;t want one.<br></p><p>My preference would be for #2, but you&#39;re the designer, not me.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Tuple Destructuring in Parameter Lists</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 30, 2016 at 09:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>On May 30, 2016, at 8:01 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; // Allowed today:<br>&gt;&gt; func takesATuple(tuple: (Int, Int)) {<br>&gt;&gt;  let valueA = tuple.0<br>&gt;&gt;  let valueB = tuple.1<br>&gt;&gt;  // ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // Proposed syntax:<br>&gt;&gt; func takesATuple(tuple (valueA, valueB): (Int, Int)) {<br>&gt;&gt;  // use valueA<br>&gt;&gt;  // use valueB<br>&gt;&gt; }<br>&gt; <br>&gt; Personally, I find this example confusing because the label is &quot;tuple&quot;, which kind of reads like a keyword, and because you&#39;re using the same name for the label and variable. If I understand the semantics you&#39;re proposing correctly, I think it would be clearer to write this example like:<br>&gt; <br>&gt; // Allowed today:<br>&gt; func takes(a tuple: (Int, Int)) {<br>&gt;  let valueA = tuple.0<br>&gt;  let valueB = tuple.1<br>&gt;  // ...<br>&gt; }<br>&gt; <br>&gt; // Proposed syntax:<br>&gt; func takes(a (valueA, valueB): (Int, Int)) {<br>&gt;  // use valueA<br>&gt;  // use valueB<br>&gt; }<br>&gt; <br>&gt; Incidentally, it may also be a good idea to define what happens if you write:<br>&gt; <br>&gt; func takes((valueA, valueB): (Int, Int))<br>&gt; <br>&gt; Normally, if there&#39;s no separate label and variable name, they&#39;re the same, but you can&#39;t have a label like `(valueA, valueB)`. I see two reasonably sensible answers here:<br>&gt; <br>&gt; 1. It&#39;s equivalent to writing `_ (valueA, valueB)`.<br>&gt; 2. It&#39;s illegal. You have to write a label, or `_` if you don&#39;t want one.<br>&gt; <br>&gt; My preference would be for #2, but you&#39;re the designer, not me.<br></p><p>I agree.  #2 is more consistent with Swift 3 where all arguments have external names by default.  I don&#39;t think this should change just because there is no direct internal name that can also serve as an external name.<br></p><p>I like the idea of allowing destructuring everywhere we bind a name very much.  My only (minor) concern with doing this for tuples right now is that it might encourage overuse of them where a struct would be a better choice.  <br></p><p>I have been thinking about destructuring of structs and classes and wonder if it might be best to introduce that first.  That would avoid any temptation to abuse tuples just because they can be destructured.  This is probably an overblown concern but it is something to consider.   <br></p><p>Another option would be to just introduce a related proposal to destructure structs and classes at roughly the same time as the parameter destructuring proposal...<br></p><p>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ec8a60462a511e833c5c4a83b424c958?s=50"></div><header><strong>[Pitch] Tuple Destructuring in Parameter Lists</strong> from <string>Dennis Weissmann</string> &lt;dennis at dennisweissmann.me&gt;<p>May 30, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; I like the idea of allowing destructuring everywhere we bind a name very much.  My only (minor) concern with doing this for tuples right now is that it might encourage overuse of them where a struct would be a better choice.  <br>&gt; <br>&gt; I have been thinking about destructuring of structs and classes and wonder if it might be best to introduce that first.  That would avoid any temptation to abuse tuples just because they can be destructured.  This is probably an overblown concern but it is something to consider.   <br></p><p><br>That’s interesting! I haven’t had the time to look at destructuring of structs and classes but a quick look at how it’s done in Rust and looks promising.<br>It’s a fair point you made, I don’t have a problem delaying this proposal. <br></p><p>- Dennis<br></p><p>&gt; On May 30, 2016, at 4:14 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On May 30, 2016, at 8:01 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; // Allowed today:<br>&gt;&gt;&gt; func takesATuple(tuple: (Int, Int)) {<br>&gt;&gt;&gt; let valueA = tuple.0<br>&gt;&gt;&gt; let valueB = tuple.1<br>&gt;&gt;&gt; // ...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Proposed syntax:<br>&gt;&gt;&gt; func takesATuple(tuple (valueA, valueB): (Int, Int)) {<br>&gt;&gt;&gt; // use valueA<br>&gt;&gt;&gt; // use valueB<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Personally, I find this example confusing because the label is &quot;tuple&quot;, which kind of reads like a keyword, and because you&#39;re using the same name for the label and variable. If I understand the semantics you&#39;re proposing correctly, I think it would be clearer to write this example like:<br>&gt;&gt; <br>&gt;&gt; // Allowed today:<br>&gt;&gt; func takes(a tuple: (Int, Int)) {<br>&gt;&gt; let valueA = tuple.0<br>&gt;&gt; let valueB = tuple.1<br>&gt;&gt; // ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // Proposed syntax:<br>&gt;&gt; func takes(a (valueA, valueB): (Int, Int)) {<br>&gt;&gt; // use valueA<br>&gt;&gt; // use valueB<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Incidentally, it may also be a good idea to define what happens if you write:<br>&gt;&gt; <br>&gt;&gt; func takes((valueA, valueB): (Int, Int))<br>&gt;&gt; <br>&gt;&gt; Normally, if there&#39;s no separate label and variable name, they&#39;re the same, but you can&#39;t have a label like `(valueA, valueB)`. I see two reasonably sensible answers here:<br>&gt;&gt; <br>&gt;&gt; 1. It&#39;s equivalent to writing `_ (valueA, valueB)`.<br>&gt;&gt; 2. It&#39;s illegal. You have to write a label, or `_` if you don&#39;t want one.<br>&gt;&gt; <br>&gt;&gt; My preference would be for #2, but you&#39;re the designer, not me.<br>&gt; <br>&gt; I agree.  #2 is more consistent with Swift 3 where all arguments have external names by default.  I don&#39;t think this should change just because there is no direct internal name that can also serve as an external name.<br>&gt; <br>&gt; I like the idea of allowing destructuring everywhere we bind a name very much.  My only (minor) concern with doing this for tuples right now is that it might encourage overuse of them where a struct would be a better choice.  <br>&gt; <br>&gt; I have been thinking about destructuring of structs and classes and wonder if it might be best to introduce that first.  That would avoid any temptation to abuse tuples just because they can be destructured.  This is probably an overblown concern but it is something to consider.   <br>&gt; <br>&gt; Another option would be to just introduce a related proposal to destructure structs and classes at roughly the same time as the parameter destructuring proposal...<br>&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160530/0efecab3/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ec8a60462a511e833c5c4a83b424c958?s=50"></div><header><strong>[Pitch] Tuple Destructuring in Parameter Lists</strong> from <string>Dennis Weissmann</string> &lt;dennis at dennisweissmann.me&gt;<p>May 30, 2016 at 05:00:00pm</p></header><div class="content"><p>Hi Brent,<br></p><p>Thanks! Those are great points!<br></p><p>I haven’t thought about the possibility of suppressing the external label. I like your option 2 very much! I’ll add it to the proposal and change the used variable names. <br></p><p>- Dennis<br></p><p>&gt; On May 30, 2016, at 3:01 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; // Allowed today:<br>&gt;&gt; func takesATuple(tuple: (Int, Int)) {<br>&gt;&gt;  let valueA = tuple.0<br>&gt;&gt;  let valueB = tuple.1<br>&gt;&gt;  // ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // Proposed syntax:<br>&gt;&gt; func takesATuple(tuple (valueA, valueB): (Int, Int)) {<br>&gt;&gt;  // use valueA<br>&gt;&gt;  // use valueB<br>&gt;&gt; }<br>&gt; <br>&gt; Personally, I find this example confusing because the label is &quot;tuple&quot;, which kind of reads like a keyword, and because you&#39;re using the same name for the label and variable. If I understand the semantics you&#39;re proposing correctly, I think it would be clearer to write this example like:<br>&gt; <br>&gt; // Allowed today:<br>&gt; func takes(a tuple: (Int, Int)) {<br>&gt;  let valueA = tuple.0<br>&gt;  let valueB = tuple.1<br>&gt;  // ...<br>&gt; }<br>&gt; <br>&gt; // Proposed syntax:<br>&gt; func takes(a (valueA, valueB): (Int, Int)) {<br>&gt;  // use valueA<br>&gt;  // use valueB<br>&gt; }<br>&gt; <br>&gt; Incidentally, it may also be a good idea to define what happens if you write:<br>&gt; <br>&gt; func takes((valueA, valueB): (Int, Int))<br>&gt; <br>&gt; Normally, if there&#39;s no separate label and variable name, they&#39;re the same, but you can&#39;t have a label like `(valueA, valueB)`. I see two reasonably sensible answers here:<br>&gt; <br>&gt; 1. It&#39;s equivalent to writing `_ (valueA, valueB)`.<br>&gt; 2. It&#39;s illegal. You have to write a label, or `_` if you don&#39;t want one.<br>&gt; <br>&gt; My preference would be for #2, but you&#39;re the designer, not me.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160530/eab5789c/attachment-0001.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Pitch] Tuple Destructuring in Parameter Lists</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 30, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On May 30, 2016, at 6:01 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; // Proposed syntax:<br>&gt; func takes(a (valueA, valueB): (Int, Int)) {<br>&gt;  // use valueA<br>&gt;  // use valueB<br>&gt; }<br></p><p>FWIW, Swift 1 supported tuple destructuring in parameter lists, and we took it out to simplify the language and eliminate special cases.  Whereas as a very early version of swift modeled parameter lists using patterns (something very common in functional programming languages) we have progressively and intentionally move away from that approach.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Tuple Destructuring in Parameter Lists</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>May 30, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On May 30, 2016, at 2:39 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On May 30, 2016, at 6:01 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; // Proposed syntax:<br>&gt;&gt; func takes(a (valueA, valueB): (Int, Int)) {<br>&gt;&gt; // use valueA<br>&gt;&gt; // use valueB<br>&gt;&gt; }<br>&gt; <br>&gt; FWIW, Swift 1 supported tuple destructuring in parameter lists, and we took it out to simplify the language and eliminate special cases.  Whereas as a very early version of swift modeled parameter lists using patterns (something very common in functional programming languages) we have progressively and intentionally move away from that approach.<br>&gt; <br>&gt; -Chris<br></p><p>You can&#39;t splat but you can decompose a tuple by assignment:<br></p><p>let a = (1, 2, 3)<br>func foo(v1: Int, v2: Int, v3: Int) { print (v1, v2, v3) }<br></p><p>// Still works:<br>let (b, c, d) = a; print(b, c, d)<br></p><p>// And this works after the assignment:<br>foo(v1: b, v2: c, v3: d)<br></p><p>// No longer works:<br>foo(a) // tuple splat is gone<br></p><p>// These all work though:<br>func bar(arg: (Int, Int, Int)) { print(arg.0, arg.1, arg.2) }<br>bar(arg: a)<br>bar(arg: (b, c, d))<br></p><p>// You can add field names in the func&#39;s decl type<br>func blort(arg: (x: Int, y: Int, z: Int)) { print(arg.x, arg.y, arg.z) }<br>blort(arg: a) // works<br>blort(arg: (b, c, d)) // works<br></p><p>// But the following doesn&#39;t work, Error is &quot;cannot <br>// convert value of (l: Int, m: Int, n: Int)&quot;<br>blort(arg: (l: b, m: c, n: d))<br></p><p>I vaguely remember a discussion onlist about creating typealiases and then using casting to convert between structurally identical tuples but I don&#39;t think it went anywhere or had a strong use case.<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160530/ea9f1f10/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0411520c60ef1131670f84bb42dc8949?s=50"></div><header><strong>[Pitch] Tuple Destructuring in Parameter Lists</strong> from <string>Swift)</string> &lt;swift-callionica at callionica.com (Callionica&gt;<p>May 30, 2016 at 04:00:00pm</p></header><div class="content"><p>This is an interesting proposal, but I think splatting like Python would be<br>preferable: creators of functions use separate parameters and callers can<br>expand tuples as necessary by prefixing a tuple at point of use with * to<br>expand it into separate arguments.<br></p><p>Even with the Swift language as it is today, it looks like the right thing<br>to do when you want named pieces of data is to define separate parameters<br>(or fall back to using a tuple parameter with named components if that&#39;s<br>really impossible).<br></p><p>Erica points out that you can do a lot with the current language. I did<br>some experiments to see what&#39;s possible and it&#39;s really easy to enhance<br>Swift to make it possible to pass tuples to functions expecting separate<br>parameters. There are a couple of interesting ops that can go into a<br>library to make things easier:<br>1. Anonymize a tuple<br>2. Wrap a function that takes separate arguments with one that takes a tuple<br></p><p>The downside to doing it in a library instead of the compiler is that you<br>have to splat the function instead of the tuple.<br></p><p>If you have a function &#39;fn&#39; that takes separate arguments and a tuple &#39;t&#39;<br>that matches the arguments, you could call it like<br>(*fn)(t)<br>instead of<br>fn(*t)<br></p><p>That&#39;s not so bad if one tuple contains all the arguments<br></p><p>You can see experiments at<br>https://gist.github.com/callionica/43f79dd0a9b145746d72e8a8a62c2820<br>and I will probably write something about this at<br>http://www.callionica.com/developer/#swift-splat<br>at some point<br></p><p>-- Callionica<br></p><p>On Mon, May 30, 2016 at 2:09 PM, Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On May 30, 2016, at 2:39 PM, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On May 30, 2016, at 6:01 AM, Brent Royal-Gordon via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; // Proposed syntax:<br>&gt; func takes(a (valueA, valueB): (Int, Int)) {<br>&gt; // use valueA<br>&gt; // use valueB<br>&gt; }<br>&gt;<br>&gt;<br>&gt; FWIW, Swift 1 supported tuple destructuring in parameter lists, and we<br>&gt; took it out to simplify the language and eliminate special cases.  Whereas<br>&gt; as a very early version of swift modeled parameter lists using patterns<br>&gt; (something very common in functional programming languages) we have<br>&gt; progressively and intentionally move away from that approach.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br>&gt; You can&#39;t splat but you *can* decompose a tuple by assignment:<br>&gt;<br>&gt; let a = (1, 2, 3)<br>&gt; func foo(v1: Int, v2: Int, v3: Int) { print (v1, v2, v3) }<br>&gt;<br>&gt; // Still works:<br>&gt; let (b, c, d) = a; print(b, c, d)<br>&gt;<br>&gt; // And this works after the assignment:<br>&gt; foo(v1: b, v2: c, v3: d)<br>&gt;<br>&gt; // No longer works:<br>&gt; foo(a) // tuple splat is gone<br>&gt;<br>&gt; // These all work though:<br>&gt; func bar(arg: (Int, Int, Int)) { print(arg.0, arg.1, arg.2) }<br>&gt; bar(arg: a)<br>&gt; bar(arg: (b, c, d))<br>&gt;<br>&gt; // You can add field names in the func&#39;s decl type<br>&gt; func blort(arg: (x: Int, y: Int, z: Int)) { print(arg.x, arg.y, arg.z) }<br>&gt; blort(arg: a) // works<br>&gt; blort(arg: (b, c, d)) // works<br>&gt;<br>&gt; // But the following doesn&#39;t work, Error is &quot;cannot<br>&gt; // convert value of (l: Int, m: Int, n: Int)&quot;<br>&gt; blort(arg: (l: b, m: c, n: d))<br>&gt;<br>&gt; I vaguely remember a discussion onlist about creating typealiases and then<br>&gt; using casting to convert between structurally identical tuples but I don&#39;t<br>&gt; think it went anywhere or had a strong use case.<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160530/1e80ee62/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Pitch] Tuple Destructuring in Parameter Lists</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 31, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On May 30, 2016, at 3:09 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; You can&#39;t splat but you can decompose a tuple by assignment:<br></p><p>Right.  That is because assignment permits destructuring.  Parameter lists do not (anymore).<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/722ddb68/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Pitch] Tuple Destructuring in Parameter Lists</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 30, 2016 at 04:00:00pm</p></header><div class="content"><p>I believe you should add currently available syntax to proposal text:<br></p><p>let c = zip(a,b).reduce(0) { (acc, tuple: (a: Int, b: Int)) in<br>   acc + tuple.a + tuple.b<br>}<br></p><p>func takesATuple(tuple : (valueA: Int, valueB: Int)) {<br>   print(&quot;a: \(tuple.valueA) b:\(tuple.valueB)&quot;)<br>}<br></p><p>Not so nice as proposed, but not so ugly as just tuple.0.<br>I&#39;m not sure if the proposed feature is adding important improvement to the <br>language.<br></p><p>On 30.05.2016 0:20, Dennis Weissmann via swift-evolution wrote:<br>&gt; Thanks for everyone participating in this discussion! :)<br>&gt; I’ve drafted a formal proposal, it is available<br>&gt; here: https://github.com/dennisweissmann/swift-evolution/blob/tuple-destructuring/proposals/0000-tuple-destructuring.md<br>&gt;<br>&gt; Please let me know what you think (it would be great if a native speaker<br>&gt; could take a look at grammar and spelling mistakes). Thanks!<br>&gt;<br>&gt;<br>&gt;   Tuple Destructuring in Parameter Lists<br>&gt;<br>&gt;   * Proposal: SE-NNNN<br>&gt;     &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;<br>&gt;   * Author(s): Dennis Weissmann &lt;https://github.com/dennisweissmann&gt;<br>&gt;   * Status: *Awaiting review*<br>&gt;   * Review manager: TBD<br>&gt;<br>&gt;<br>&gt;     Introduction<br>&gt;<br>&gt; Tuple destructuring is the process of extracting elements from tuples.<br>&gt;<br>&gt; This is valid today:<br>&gt;<br>&gt; Swift<br>&gt;<br>&gt; |let point = (x: 20.0, y: 31.0, z: 42.0) // Approach 1: let x = point.x let<br>&gt; y = point.y let z = point.z // Approach 2: let (x, y, z) = point // For-in<br>&gt; loops support tuple destructuring for (x, y, z) in [point] { // use x, y, z }|<br>&gt;<br>&gt; Swift-evolution thread: [Pitch] Tuple Destructuring in Parameter Lists<br>&gt; &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/16190&gt;<br>&gt;<br>&gt;<br>&gt;     Motivation<br>&gt;<br>&gt; This proposal seeks to generalize this behavior for every use case where<br>&gt; tuples need to be destructured. These are parameter lists in closures and<br>&gt; parameter lists in functions. Consistency is a major goal of Swift but it<br>&gt; is currently only possible to destructure tuples in the above mentioned places.<br>&gt;<br>&gt;<br>&gt;     Proposed solution<br>&gt;<br>&gt; Extending tuple destructuring to parameter lists seems natural and improves<br>&gt; consistency in the language.<br>&gt;<br>&gt;<br>&gt;       Closures<br>&gt;<br>&gt; Parameters in closures are currently not directly destructable. They can<br>&gt; either be accessed via |.0|, |.1|, etc. or can be destructured by assigning<br>&gt; them to variables in an explicit statement.<br>&gt;<br>&gt; It feels natural to do this right in the parameter list itself (just like<br>&gt; with for-in loops).<br>&gt;<br>&gt; Swift<br>&gt;<br>&gt; |let a = [0,1,2,3,4,5,6,7,8,9] let b = [0,1,2,3,4,5,6,7,8,9] // Allowed<br>&gt; today: let c = zip(a,b).reduce(0) { acc, tuple in acc + tuple.0 + tuple.1 }<br>&gt; // Also allowed today: let c = zip(a,b).reduce(0) { acc, tuple in let<br>&gt; (valueA, valueB) = tuple return acc + valueA + valueB } // Proposed syntax:<br>&gt; let c = zip(a,b).reduce(0) { acc, (valueA, valueB) in acc + valueA + valueB }|<br>&gt;<br>&gt;<br>&gt;       Functions<br>&gt;<br>&gt; When it comes to functions this proposal uses Swift&#39;s feature of<br>&gt; differentiating between internal and external parameter names.<br>&gt;<br>&gt; Swift<br>&gt;<br>&gt; |// Allowed today: func takesATuple(tuple: (Int, Int)) { let valueA =<br>&gt; tuple.0 let valueB = tuple.1 // ... } // Proposed syntax: func<br>&gt; takesATuple(tuple (valueA, valueB): (Int, Int)) { // use valueA // use<br>&gt; valueB }|<br>&gt;<br>&gt; This design has no visible effects to the call site of a function but makes<br>&gt; it very convenient for the function author to use the tuple&#39;s elements<br>&gt; inside the function body.<br>&gt;<br>&gt;<br>&gt;     Impact on existing code<br>&gt;<br>&gt; This feature is strictly additive and does not effect current code.<br>&gt;<br>&gt;<br>&gt;     Alternatives considered<br>&gt;<br>&gt; Leave it as is destructure in a separate assignment.<br>&gt;<br>&gt;<br>&gt;<br>&gt; - Dennis<br>&gt;<br>&gt;&gt; On May 11, 2016, at 10:12 AM, Dennis Weissmann via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Thanks for all your feedback!<br>&gt;&gt;<br>&gt;&gt; This is the current statistic:<br>&gt;&gt; Closure syntax: All positive<br>&gt;&gt; Function syntax: 3 (or 4) positive, 2 negative<br>&gt;&gt;<br>&gt;&gt; I’ll try to address the concern Geordie and T.J. have.<br>&gt;&gt;<br>&gt;&gt;&gt; func takesATuple(someInt: Int, tuple: (valueA: String, valueB: String)) {}<br>&gt;&gt;<br>&gt;&gt;&gt; It’s true that you still have the ‚overhead‘ of having to<br>&gt;&gt;&gt; type /tuple./ before accessing its members. But this is almost always<br>&gt;&gt;&gt; what I want (hopefully you’d never actually name your tuple ‚tuple‘,<br>&gt;&gt;&gt; instead it’d be a logical namespace for what it contains). Do you have a<br>&gt;&gt;&gt; real-world example where you’d need this? To me it seems that in a case<br>&gt;&gt;&gt; like this the API that produced the tuple would need refining rather<br>&gt;&gt;&gt; than the language itself.<br>&gt;&gt;<br>&gt;&gt; What you suggest here is not tuple destructuring but using labeled<br>&gt;&gt; tuples. And while I’m totally with you that this is for many cases the<br>&gt;&gt; better approach, I still think we should introduce it to functions as<br>&gt;&gt; well, for consistency and readability reasons.<br>&gt;&gt; In the end inconsistency is what led to this thread because tuple<br>&gt;&gt; destructuring is already possible today - in for loops:<br>&gt;&gt;<br>&gt;&gt; letstringTuple = [(&quot;&quot;, &quot;”), (&quot;&quot;, &quot;&quot;)]<br>&gt;&gt; for(i, j) instringTuple {}<br>&gt;&gt;<br>&gt;&gt; That made me wonder if it’s also possible for closures (because I needed<br>&gt;&gt; it there - and eventually someone will definitely wonder if it’s possible<br>&gt;&gt; for function arguments as well).<br>&gt;&gt;<br>&gt;&gt; You also asked me for my use case. To be honest, I don’t have one for the<br>&gt;&gt; function version, but imagine the following:<br>&gt;&gt;<br>&gt;&gt; My current closure use case is this<br>&gt;&gt; (template.points and resampledPoints are of type [CGPoint]):<br>&gt;&gt;<br>&gt;&gt; letlocalHighestSimilarity = zip(template.points,<br>&gt;&gt; resampledPoints).reduce(0.0) { accumulator, points in<br>&gt;&gt;   let(template, resampled) = points<br>&gt;&gt;   returnaccumulator + Double(template.x* resampled.x+ template.y*<br>&gt;&gt; resampled.y)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; To reuse this code elsewhere I maybe want to refactor the closure into a<br>&gt;&gt; function (using your labeled tuple suggestion):<br>&gt;&gt;<br>&gt;&gt; funcaccumulateSimilarity(accumulator: Double, for points: (point1:<br>&gt;&gt; CGPoint, point2: CGPoint)) -&gt; Double{<br>&gt;&gt;   returnaccumulator + Double(points.point1.x* points.point2.x+<br>&gt;&gt; points.point1.y* points.point2.y)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; This isn’t particularity readable (image passing a CGRect and you need<br>&gt;&gt; the points or a more complex calculation). Compare it to this:<br>&gt;&gt;<br>&gt;&gt; funcaccumulateSimilarity(accumulator: Double, for (point1, point2):<br>&gt;&gt; (CGPoint, CGPoint)) -&gt; Double{<br>&gt;&gt;   returnaccumulator + Double(point1.x * point2.x + point1.y * point2.y)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; You can of course still pass a named tuple instead of an unnamed, but it<br>&gt;&gt; doesn’t make any difference, which brings me to an aside*.<br>&gt;&gt;<br>&gt;&gt; I think the second approach makes the calculation much more<br>&gt;&gt; comprehensible and it just feels “intuitive” (again, at least for me) :).<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; - Dennis<br>&gt;&gt;<br>&gt;&gt; * I’m not sure how scientifically correct the following statement is but<br>&gt;&gt; strictly speaking (at least for me) (valueA: String, valueB: String) is<br>&gt;&gt; not of the same type as (String, String) just like func d(string: String,<br>&gt;&gt; int: Int) is different from func e(_: String, _: Int) though in Swift the<br>&gt;&gt; tuples are interchangeable (you can pass one where the other is expected).<br>&gt;&gt;<br>&gt;&gt;&gt; On May 8, 2016, at 6:10 PM, Geordie J &lt;geojay at gmail.com<br>&gt;&gt;&gt; &lt;mailto:geojay at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Comments below<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Am 05.05.2016 um 20:22 schrieb Dennis Weissmann via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Following a short discussion with positive feedback on<br>&gt;&gt;&gt;&gt; [swift-users](http://thread.gmane.org/gmane.comp.lang.swift.user/1812)<br>&gt;&gt;&gt;&gt; I’d like to discuss the following:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Tuples should be destructible into their components in parameter lists.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Consider the following code:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; let a = [0,1,2,3,4,5,6,7,8,9]<br>&gt;&gt;&gt;&gt; let b = [0,1,2,3,4,5,6,7,8,9]<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; let c = zip(a,b).reduce(0) { acc, tuple in<br>&gt;&gt;&gt;&gt;   acc + tuple.0 + tuple.1<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; tuple is of type (Int, Int).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The problem is that the calculation is not very comprehensible due<br>&gt;&gt;&gt;&gt; to .0 and .1. That’s when destructuring tuples directly in the<br>&gt;&gt;&gt;&gt; parameter list comes into play:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; let c = zip(a,b).reduce(0) { acc, (valueA, valueB) in<br>&gt;&gt;&gt;&gt;   acc + valueA + valueB<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; +1 I think this is a great way to go about it.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The above is what I propose should be accepted by the compiler (but<br>&gt;&gt;&gt;&gt; currently isn’t).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Currently tuple destructuring is possible like this:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; let c = zip(a,b).reduce(0) { (acc, tuple) in<br>&gt;&gt;&gt;&gt;   let (valueA, valueB) = tuple<br>&gt;&gt;&gt;&gt;   return acc + valueA + valueB<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This is not about saving one line ;-). I just find it much more<br>&gt;&gt;&gt;&gt; intuitive to destructure the tuple in the parameter list itself.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Agreed<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The same thing could be done for functions:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; func takesATuple(someInt: Int, tuple: (String, String))<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Here we also need to destructure the tuple inside the function, but the<br>&gt;&gt;&gt;&gt; intuitive place (at least for me) to do this would be the parameter list.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; In the following example I&#39;m making use of Swift’s feature to name<br>&gt;&gt;&gt;&gt; parameters different from their labels (for internal use inside the<br>&gt;&gt;&gt;&gt; function, this is not visible to consumers of the API):<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; func takesATuple(someInt: Int, tuple (valueA, valueB): (String, String))<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I’m not such a fan of this though. I realize what I’m about to write<br>&gt;&gt;&gt; here is discussing a slightly different point but bear with me: I was<br>&gt;&gt;&gt; under the impression it was already possible to do something like this<br>&gt;&gt;&gt; (maybe only possible with typealiases):<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func takesATuple(someInt: Int, tuple: (valueA: String, valueB: String)) {}<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I find that syntax readable and extensible: you can make a type alias<br>&gt;&gt;&gt; for your tuple type &#39;(valueA: String, valueB: String)‘, you can then use<br>&gt;&gt;&gt; it like this:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func takesATuple(someInt: Int, tuple: MyAliasedTupleType) {<br>&gt;&gt;&gt;   print(tuple.valueA)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It’s true that you still have the ‚overhead‘ of having to<br>&gt;&gt;&gt; type /tuple./ before accessing its members. But this is almost always<br>&gt;&gt;&gt; what I want (hopefully you’d never actually name your tuple ‚tuple‘,<br>&gt;&gt;&gt; instead it’d be a logical namespace for what it contains). Do you have a<br>&gt;&gt;&gt; real-world example where you’d need this? To me it seems that in a case<br>&gt;&gt;&gt; like this the API that produced the tuple would need refining rather<br>&gt;&gt;&gt; than the language itself.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Here valueA and valueB would be directly usable within the function.<br>&gt;&gt;&gt;&gt; The tuple as a whole would not be available anymore.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Now it’s your turn!<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; 1. What do you think?<br>&gt;&gt;&gt;&gt; 2. Is this worth being discussed now (i.e. is it implementable in the<br>&gt;&gt;&gt;&gt; Swift 3 timeframe) or should I delay it?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; - Dennis<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ec8a60462a511e833c5c4a83b424c958?s=50"></div><header><strong>[Pitch] Tuple Destructuring in Parameter Lists</strong> from <string>Dennis Weissmann</string> &lt;dennis at dennisweissmann.me&gt;<p>May 30, 2016 at 05:00:00pm</p></header><div class="content"><p>Great catch! I didn’t know that was possible! I’ll add it to the proposal. Thanks!<br></p><p>- Dennis<br></p><p>&gt; On May 30, 2016, at 3:53 PM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt; <br>&gt; I believe you should add currently available syntax to proposal text:<br>&gt; <br>&gt; let c = zip(a,b).reduce(0) { (acc, tuple: (a: Int, b: Int)) in<br>&gt;  acc + tuple.a + tuple.b<br>&gt; }<br>&gt; <br>&gt; func takesATuple(tuple : (valueA: Int, valueB: Int)) {<br>&gt;  print(&quot;a: \(tuple.valueA) b:\(tuple.valueB)&quot;)<br>&gt; }<br>&gt; <br>&gt; Not so nice as proposed, but not so ugly as just tuple.0.<br>&gt; I&#39;m not sure if the proposed feature is adding important improvement to the language.<br>&gt; <br>&gt; On 30.05.2016 0:20, Dennis Weissmann via swift-evolution wrote:<br>&gt;&gt; Thanks for everyone participating in this discussion! :)<br>&gt;&gt; I’ve drafted a formal proposal, it is available<br>&gt;&gt; here: https://github.com/dennisweissmann/swift-evolution/blob/tuple-destructuring/proposals/0000-tuple-destructuring.md<br>&gt;&gt; <br>&gt;&gt; Please let me know what you think (it would be great if a native speaker<br>&gt;&gt; could take a look at grammar and spelling mistakes). Thanks!<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;  Tuple Destructuring in Parameter Lists<br>&gt;&gt; <br>&gt;&gt;  * Proposal: SE-NNNN<br>&gt;&gt;    &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;<br>&gt;&gt;  * Author(s): Dennis Weissmann &lt;https://github.com/dennisweissmann&gt;<br>&gt;&gt;  * Status: *Awaiting review*<br>&gt;&gt;  * Review manager: TBD<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;    Introduction<br>&gt;&gt; <br>&gt;&gt; Tuple destructuring is the process of extracting elements from tuples.<br>&gt;&gt; <br>&gt;&gt; This is valid today:<br>&gt;&gt; <br>&gt;&gt; Swift<br>&gt;&gt; <br>&gt;&gt; |let point = (x: 20.0, y: 31.0, z: 42.0) // Approach 1: let x = point.x let<br>&gt;&gt; y = point.y let z = point.z // Approach 2: let (x, y, z) = point // For-in<br>&gt;&gt; loops support tuple destructuring for (x, y, z) in [point] { // use x, y, z }|<br>&gt;&gt; <br>&gt;&gt; Swift-evolution thread: [Pitch] Tuple Destructuring in Parameter Lists<br>&gt;&gt; &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/16190&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;    Motivation<br>&gt;&gt; <br>&gt;&gt; This proposal seeks to generalize this behavior for every use case where<br>&gt;&gt; tuples need to be destructured. These are parameter lists in closures and<br>&gt;&gt; parameter lists in functions. Consistency is a major goal of Swift but it<br>&gt;&gt; is currently only possible to destructure tuples in the above mentioned places.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;    Proposed solution<br>&gt;&gt; <br>&gt;&gt; Extending tuple destructuring to parameter lists seems natural and improves<br>&gt;&gt; consistency in the language.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;      Closures<br>&gt;&gt; <br>&gt;&gt; Parameters in closures are currently not directly destructable. They can<br>&gt;&gt; either be accessed via |.0|, |.1|, etc. or can be destructured by assigning<br>&gt;&gt; them to variables in an explicit statement.<br>&gt;&gt; <br>&gt;&gt; It feels natural to do this right in the parameter list itself (just like<br>&gt;&gt; with for-in loops).<br>&gt;&gt; <br>&gt;&gt; Swift<br>&gt;&gt; <br>&gt;&gt; |let a = [0,1,2,3,4,5,6,7,8,9] let b = [0,1,2,3,4,5,6,7,8,9] // Allowed<br>&gt;&gt; today: let c = zip(a,b).reduce(0) { acc, tuple in acc + tuple.0 + tuple.1 }<br>&gt;&gt; // Also allowed today: let c = zip(a,b).reduce(0) { acc, tuple in let<br>&gt;&gt; (valueA, valueB) = tuple return acc + valueA + valueB } // Proposed syntax:<br>&gt;&gt; let c = zip(a,b).reduce(0) { acc, (valueA, valueB) in acc + valueA + valueB }|<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;      Functions<br>&gt;&gt; <br>&gt;&gt; When it comes to functions this proposal uses Swift&#39;s feature of<br>&gt;&gt; differentiating between internal and external parameter names.<br>&gt;&gt; <br>&gt;&gt; Swift<br>&gt;&gt; <br>&gt;&gt; |// Allowed today: func takesATuple(tuple: (Int, Int)) { let valueA =<br>&gt;&gt; tuple.0 let valueB = tuple.1 // ... } // Proposed syntax: func<br>&gt;&gt; takesATuple(tuple (valueA, valueB): (Int, Int)) { // use valueA // use<br>&gt;&gt; valueB }|<br>&gt;&gt; <br>&gt;&gt; This design has no visible effects to the call site of a function but makes<br>&gt;&gt; it very convenient for the function author to use the tuple&#39;s elements<br>&gt;&gt; inside the function body.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;    Impact on existing code<br>&gt;&gt; <br>&gt;&gt; This feature is strictly additive and does not effect current code.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;    Alternatives considered<br>&gt;&gt; <br>&gt;&gt; Leave it as is destructure in a separate assignment.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; - Dennis<br>&gt;&gt; <br>&gt;&gt;&gt; On May 11, 2016, at 10:12 AM, Dennis Weissmann via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks for all your feedback!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is the current statistic:<br>&gt;&gt;&gt; Closure syntax: All positive<br>&gt;&gt;&gt; Function syntax: 3 (or 4) positive, 2 negative<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’ll try to address the concern Geordie and T.J. have.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func takesATuple(someInt: Int, tuple: (valueA: String, valueB: String)) {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It’s true that you still have the ‚overhead‘ of having to<br>&gt;&gt;&gt;&gt; type /tuple./ before accessing its members. But this is almost always<br>&gt;&gt;&gt;&gt; what I want (hopefully you’d never actually name your tuple ‚tuple‘,<br>&gt;&gt;&gt;&gt; instead it’d be a logical namespace for what it contains). Do you have a<br>&gt;&gt;&gt;&gt; real-world example where you’d need this? To me it seems that in a case<br>&gt;&gt;&gt;&gt; like this the API that produced the tuple would need refining rather<br>&gt;&gt;&gt;&gt; than the language itself.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What you suggest here is not tuple destructuring but using labeled<br>&gt;&gt;&gt; tuples. And while I’m totally with you that this is for many cases the<br>&gt;&gt;&gt; better approach, I still think we should introduce it to functions as<br>&gt;&gt;&gt; well, for consistency and readability reasons.<br>&gt;&gt;&gt; In the end inconsistency is what led to this thread because tuple<br>&gt;&gt;&gt; destructuring is already possible today - in for loops:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; letstringTuple = [(&quot;&quot;, &quot;”), (&quot;&quot;, &quot;&quot;)]<br>&gt;&gt;&gt; for(i, j) instringTuple {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That made me wonder if it’s also possible for closures (because I needed<br>&gt;&gt;&gt; it there - and eventually someone will definitely wonder if it’s possible<br>&gt;&gt;&gt; for function arguments as well).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You also asked me for my use case. To be honest, I don’t have one for the<br>&gt;&gt;&gt; function version, but imagine the following:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My current closure use case is this<br>&gt;&gt;&gt; (template.points and resampledPoints are of type [CGPoint]):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; letlocalHighestSimilarity = zip(template.points,<br>&gt;&gt;&gt; resampledPoints).reduce(0.0) { accumulator, points in<br>&gt;&gt;&gt;  let(template, resampled) = points<br>&gt;&gt;&gt;  returnaccumulator + Double(template.x* resampled.x+ template.y*<br>&gt;&gt;&gt; resampled.y)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To reuse this code elsewhere I maybe want to refactor the closure into a<br>&gt;&gt;&gt; function (using your labeled tuple suggestion):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; funcaccumulateSimilarity(accumulator: Double, for points: (point1:<br>&gt;&gt;&gt; CGPoint, point2: CGPoint)) -&gt; Double{<br>&gt;&gt;&gt;  returnaccumulator + Double(points.point1.x* points.point2.x+<br>&gt;&gt;&gt; points.point1.y* points.point2.y)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This isn’t particularity readable (image passing a CGRect and you need<br>&gt;&gt;&gt; the points or a more complex calculation). Compare it to this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; funcaccumulateSimilarity(accumulator: Double, for (point1, point2):<br>&gt;&gt;&gt; (CGPoint, CGPoint)) -&gt; Double{<br>&gt;&gt;&gt;  returnaccumulator + Double(point1.x * point2.x + point1.y * point2.y)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You can of course still pass a named tuple instead of an unnamed, but it<br>&gt;&gt;&gt; doesn’t make any difference, which brings me to an aside*.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think the second approach makes the calculation much more<br>&gt;&gt;&gt; comprehensible and it just feels “intuitive” (again, at least for me) :).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Dennis<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * I’m not sure how scientifically correct the following statement is but<br>&gt;&gt;&gt; strictly speaking (at least for me) (valueA: String, valueB: String) is<br>&gt;&gt;&gt; not of the same type as (String, String) just like func d(string: String,<br>&gt;&gt;&gt; int: Int) is different from func e(_: String, _: Int) though in Swift the<br>&gt;&gt;&gt; tuples are interchangeable (you can pass one where the other is expected).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 8, 2016, at 6:10 PM, Geordie J &lt;geojay at gmail.com<br>&gt;&gt;&gt;&gt; &lt;mailto:geojay at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Comments below<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 05.05.2016 um 20:22 schrieb Dennis Weissmann via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Following a short discussion with positive feedback on<br>&gt;&gt;&gt;&gt;&gt; [swift-users](http://thread.gmane.org/gmane.comp.lang.swift.user/1812)<br>&gt;&gt;&gt;&gt;&gt; I’d like to discuss the following:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Tuples should be destructible into their components in parameter lists.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Consider the following code:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let a = [0,1,2,3,4,5,6,7,8,9]<br>&gt;&gt;&gt;&gt;&gt; let b = [0,1,2,3,4,5,6,7,8,9]<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let c = zip(a,b).reduce(0) { acc, tuple in<br>&gt;&gt;&gt;&gt;&gt;  acc + tuple.0 + tuple.1<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; tuple is of type (Int, Int).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The problem is that the calculation is not very comprehensible due<br>&gt;&gt;&gt;&gt;&gt; to .0 and .1. That’s when destructuring tuples directly in the<br>&gt;&gt;&gt;&gt;&gt; parameter list comes into play:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let c = zip(a,b).reduce(0) { acc, (valueA, valueB) in<br>&gt;&gt;&gt;&gt;&gt;  acc + valueA + valueB<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; +1 I think this is a great way to go about it.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The above is what I propose should be accepted by the compiler (but<br>&gt;&gt;&gt;&gt;&gt; currently isn’t).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Currently tuple destructuring is possible like this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let c = zip(a,b).reduce(0) { (acc, tuple) in<br>&gt;&gt;&gt;&gt;&gt;  let (valueA, valueB) = tuple<br>&gt;&gt;&gt;&gt;&gt;  return acc + valueA + valueB<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This is not about saving one line ;-). I just find it much more<br>&gt;&gt;&gt;&gt;&gt; intuitive to destructure the tuple in the parameter list itself.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Agreed<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The same thing could be done for functions:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func takesATuple(someInt: Int, tuple: (String, String))<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Here we also need to destructure the tuple inside the function, but the<br>&gt;&gt;&gt;&gt;&gt; intuitive place (at least for me) to do this would be the parameter list.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In the following example I&#39;m making use of Swift’s feature to name<br>&gt;&gt;&gt;&gt;&gt; parameters different from their labels (for internal use inside the<br>&gt;&gt;&gt;&gt;&gt; function, this is not visible to consumers of the API):<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func takesATuple(someInt: Int, tuple (valueA, valueB): (String, String))<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m not such a fan of this though. I realize what I’m about to write<br>&gt;&gt;&gt;&gt; here is discussing a slightly different point but bear with me: I was<br>&gt;&gt;&gt;&gt; under the impression it was already possible to do something like this<br>&gt;&gt;&gt;&gt; (maybe only possible with typealiases):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func takesATuple(someInt: Int, tuple: (valueA: String, valueB: String)) {}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I find that syntax readable and extensible: you can make a type alias<br>&gt;&gt;&gt;&gt; for your tuple type &#39;(valueA: String, valueB: String)‘, you can then use<br>&gt;&gt;&gt;&gt; it like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func takesATuple(someInt: Int, tuple: MyAliasedTupleType) {<br>&gt;&gt;&gt;&gt;  print(tuple.valueA)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It’s true that you still have the ‚overhead‘ of having to<br>&gt;&gt;&gt;&gt; type /tuple./ before accessing its members. But this is almost always<br>&gt;&gt;&gt;&gt; what I want (hopefully you’d never actually name your tuple ‚tuple‘,<br>&gt;&gt;&gt;&gt; instead it’d be a logical namespace for what it contains). Do you have a<br>&gt;&gt;&gt;&gt; real-world example where you’d need this? To me it seems that in a case<br>&gt;&gt;&gt;&gt; like this the API that produced the tuple would need refining rather<br>&gt;&gt;&gt;&gt; than the language itself.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Here valueA and valueB would be directly usable within the function.<br>&gt;&gt;&gt;&gt;&gt; The tuple as a whole would not be available anymore.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Now it’s your turn!<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 1. What do you think?<br>&gt;&gt;&gt;&gt;&gt; 2. Is this worth being discussed now (i.e. is it implementable in the<br>&gt;&gt;&gt;&gt;&gt; Swift 3 timeframe) or should I delay it?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - Dennis<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160530/1807434c/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
