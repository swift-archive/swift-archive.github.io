<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[RFC] New collections model: collections advance indices</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>March  1, 2016 at 06:00:00pm</p></header><div class="content"><p>Hi,<br></p><p>We would like to propose a major change to how collection indices<br>work.  The standard library team has discussed this idea internally<br>and we wrote a prototype.  Now we think it is a viable direction to<br>consider, and we are bringing it for wider public discussion.<br></p><p>I&#39;m pasting the first section of the proposal below to give you a<br>general idea about this change, but please read the proposal to<br>understand the full details.<br></p><p>You can find the most up to date version of the proposal at<br>https://github.com/gribozavr/swift-evolution/blob/new-collections/proposals/NNNN-collections-move-indices.md<br></p><p>Permalink: https://github.com/gribozavr/swift-evolution/blob/87df19a9a9d73e64a2a966b807440216a608b8ad/proposals/NNNN-collections-move-indices.md<br></p><p>Dmitri<br></p><p>## Introduction<br></p><p>We are proposing a new model for collections, where indices can only be<br>advanced forward or backward by the corresponding collection instance.<br>Indices become opaque tokens representing collection positions, that can<br>be produced and consumed by collection APIs.  This allows us to reduce<br>the amount of data stored in indices to the bare minimum.<br></p><p>Compared to the current state, the new scheme simplifies implementation<br>of non-trivial indices, and fixes concurrency issues in `Set` and<br>`Dictionary` indices.  It also allows us to eliminate reference-counted<br>stored properties from most indices, including non-trivial ones, like<br>`Set.Index` and `Dictionary.Index`, creating more optimizable code.<br></p><p>Out of scope for this proposal:<br></p><p>* Expanding the set of concrete collections provided by the standard<br>  library.<br></p><p>* Expanding the set of collection protocols to provide functionality<br>  beyond what is already provided (for example, protocols for sorted<br>  collections, queues etc.)  Discussing how other concrete collections<br>  fit into the current protocol hierarchy is in scope, though.<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c40db4457ab2c91a0d8006da31b177c6?s=50"></div><header><strong>[RFC] New collections model: collections advance indices</strong> from <string>Trent Nadeau</string> &lt;tanadeau at gmail.com&gt;<p>March  1, 2016 at 09:00:00pm</p></header><div class="content"><p>Why is the protocol for iterators called IteratorProtocol instead of<br>Iterator or Iterable? If that is/was discussed elsewhere, I apologize, but<br>I don&#39;t remember seeing that particular name before. Is that new to this<br>proposal?<br></p><p>On Tue, Mar 1, 2016 at 9:04 PM, Dmitri Gribenko via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hi,<br>&gt;<br>&gt; We would like to propose a major change to how collection indices<br>&gt; work.  The standard library team has discussed this idea internally<br>&gt; and we wrote a prototype.  Now we think it is a viable direction to<br>&gt; consider, and we are bringing it for wider public discussion.<br>&gt;<br>&gt; I&#39;m pasting the first section of the proposal below to give you a<br>&gt; general idea about this change, but please read the proposal to<br>&gt; understand the full details.<br>&gt;<br>&gt; You can find the most up to date version of the proposal at<br>&gt;<br>&gt; https://github.com/gribozavr/swift-evolution/blob/new-collections/proposals/NNNN-collections-move-indices.md<br>&gt;<br>&gt; Permalink:<br>&gt; https://github.com/gribozavr/swift-evolution/blob/87df19a9a9d73e64a2a966b807440216a608b8ad/proposals/NNNN-collections-move-indices.md<br>&gt;<br>&gt; Dmitri<br>&gt;<br>&gt; ## Introduction<br>&gt;<br>&gt; We are proposing a new model for collections, where indices can only be<br>&gt; advanced forward or backward by the corresponding collection instance.<br>&gt; Indices become opaque tokens representing collection positions, that can<br>&gt; be produced and consumed by collection APIs.  This allows us to reduce<br>&gt; the amount of data stored in indices to the bare minimum.<br>&gt;<br>&gt; Compared to the current state, the new scheme simplifies implementation<br>&gt; of non-trivial indices, and fixes concurrency issues in `Set` and<br>&gt; `Dictionary` indices.  It also allows us to eliminate reference-counted<br>&gt; stored properties from most indices, including non-trivial ones, like<br>&gt; `Set.Index` and `Dictionary.Index`, creating more optimizable code.<br>&gt;<br>&gt; Out of scope for this proposal:<br>&gt;<br>&gt; * Expanding the set of concrete collections provided by the standard<br>&gt;   library.<br>&gt;<br>&gt; * Expanding the set of collection protocols to provide functionality<br>&gt;   beyond what is already provided (for example, protocols for sorted<br>&gt;   collections, queues etc.)  Discussing how other concrete collections<br>&gt;   fit into the current protocol hierarchy is in scope, though.<br>&gt;<br>&gt; --<br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br></p><p>-- <br>Trent Nadeau<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160301/36abdb90/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[RFC] New collections model: collections advance indices</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>March  1, 2016 at 07:00:00pm</p></header><div class="content"><p>On Tue, Mar 1, 2016 at 6:55 PM, Trent Nadeau &lt;tanadeau at gmail.com&gt; wrote:<br>&gt; Why is the protocol for iterators called IteratorProtocol instead of<br>&gt; Iterator or Iterable? If that is/was discussed elsewhere, I apologize, but I<br>&gt; don&#39;t remember seeing that particular name before. Is that new to this<br>&gt; proposal?<br></p><p>I&#39;m using the new names introduced by SE-0006<br>https://github.com/apple/swift-evolution/blob/master/proposals/0006-apply-api-guidelines-to-the-standard-library.md<br></p><p>The protocol is not called Iterator to disambiguate it with the<br>Iterator associated type in Sequence from the protocol:<br></p><p>protocol Sequence {<br>  associatedtype Iterator : IteratorProtocol<br>}<br></p><p>It is not called Iterable because that would have the wrong meaning<br>(Sequence is iterable, the iterator iterates over its elements).<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c40db4457ab2c91a0d8006da31b177c6?s=50"></div><header><strong>[RFC] New collections model: collections advance indices</strong> from <string>Trent Nadeau</string> &lt;tanadeau at gmail.com&gt;<p>March  1, 2016 at 10:00:00pm</p></header><div class="content"><p>Ah. Thanks. I&#39;ve read through that proposal before but totally forgot that<br>change.<br></p><p>On Tue, Mar 1, 2016 at 10:01 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt;<br>wrote:<br></p><p>&gt; On Tue, Mar 1, 2016 at 6:55 PM, Trent Nadeau &lt;tanadeau at gmail.com&gt; wrote:<br>&gt; &gt; Why is the protocol for iterators called IteratorProtocol instead of<br>&gt; &gt; Iterator or Iterable? If that is/was discussed elsewhere, I apologize,<br>&gt; but I<br>&gt; &gt; don&#39;t remember seeing that particular name before. Is that new to this<br>&gt; &gt; proposal?<br>&gt;<br>&gt; I&#39;m using the new names introduced by SE-0006<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0006-apply-api-guidelines-to-the-standard-library.md<br>&gt;<br>&gt; The protocol is not called Iterator to disambiguate it with the<br>&gt; Iterator associated type in Sequence from the protocol:<br>&gt;<br>&gt; protocol Sequence {<br>&gt;   associatedtype Iterator : IteratorProtocol<br>&gt; }<br>&gt;<br>&gt; It is not called Iterable because that would have the wrong meaning<br>&gt; (Sequence is iterable, the iterator iterates over its elements).<br>&gt;<br>&gt; Dmitri<br>&gt;<br>&gt; --<br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;<br></p><p><br></p><p>-- <br>Trent Nadeau<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160301/49eb71ae/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[RFC] New collections model: collections advance indices</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>March  2, 2016 at 05:00:00pm</p></header><div class="content"><p>Sorry, unfortunately I can&#39;t see that it really helps. All that happens is<br>that the client of the collection now holds the reference to the collection<br>as well as the reference to the iterator. In the more traditional model the<br>client holds a reference to the iterator which in turn holds a reference to<br>the collection.<br></p><p>Maybe the problem arose with the double indirection trick. Would a better<br>approach be to keep it simple:<br></p><p>    struct SomeCollection&lt;E&gt;: Collection {<br>        private var refToInternalStorage: UnsafePointerOfSomeSort&lt;E&gt;<br>        func iterable() -&gt; SomeCollectionIterator { return<br>SomeCollectionIterator(self) }<br>        mutating func append(element: E) {<br>            copyInternalStorageIfNecessary(size + 1) // Makes a copy if<br>either not large enough or if already aliased<br>            // Append `element` to `refToInternalStorage`<br>        }<br>        // Other functions access `refToInternalStorage`, but if mutating<br>call `copyInternalStorageIfNecessary(Int)` before modifying<br>    }<br></p><p>    struct SomeCollectionIterator&lt;E&gt;: Iterator {<br>        private let someCollection: SomeCollection&lt;E&gt; // Note let not var -<br>could be direct link to internal storage<br>        private var index: Index<br>        init(someCollection: someCollection &lt;E&gt;) {<br>            self.someCollection = someCollection<br>            index = someCollection.firstIndex()<br>        }<br>        // next()<br>    }<br></p><p>Obviously above is pseudo code - but hopefully you get the idea.<br></p><p>The difference comes when with the proposal you do:<br></p><p>    var array = [1]<br>    var iterator = array.makeIterator()<br>    array.removeAll()<br>    array.next(iterator) // Runtime exception<br></p><p>Similarly with modifications in another thread. With the above suggested<br>`obvious` implementation:<br></p><p>    var array = [1]<br>    var iterator = array.iterator()<br>    array.removeAll()<br>    iterator.next() // OK, returns 1 because it has the original before<br>array was mutated.<br></p><p>In essence I am saying do the obvious, since that is easiest for the<br>clients (i.e. the programmers that use Swift).<br></p><p>Sorry to be negative,<br></p><p> -- Howard.<br></p><p>  -- Howard.<br></p><p>On 2 March 2016 at 14:03, Trent Nadeau via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Ah. Thanks. I&#39;ve read through that proposal before but totally forgot that<br>&gt; change.<br>&gt;<br>&gt; On Tue, Mar 1, 2016 at 10:01 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; On Tue, Mar 1, 2016 at 6:55 PM, Trent Nadeau &lt;tanadeau at gmail.com&gt; wrote:<br>&gt;&gt; &gt; Why is the protocol for iterators called IteratorProtocol instead of<br>&gt;&gt; &gt; Iterator or Iterable? If that is/was discussed elsewhere, I apologize,<br>&gt;&gt; but I<br>&gt;&gt; &gt; don&#39;t remember seeing that particular name before. Is that new to this<br>&gt;&gt; &gt; proposal?<br>&gt;&gt;<br>&gt;&gt; I&#39;m using the new names introduced by SE-0006<br>&gt;&gt;<br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0006-apply-api-guidelines-to-the-standard-library.md<br>&gt;&gt;<br>&gt;&gt; The protocol is not called Iterator to disambiguate it with the<br>&gt;&gt; Iterator associated type in Sequence from the protocol:<br>&gt;&gt;<br>&gt;&gt; protocol Sequence {<br>&gt;&gt;   associatedtype Iterator : IteratorProtocol<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; It is not called Iterable because that would have the wrong meaning<br>&gt;&gt; (Sequence is iterable, the iterator iterates over its elements).<br>&gt;&gt;<br>&gt;&gt; Dmitri<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt;&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Trent Nadeau<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160302/96d342b0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[RFC] New collections model: collections advance indices</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>March  1, 2016 at 11:00:00pm</p></header><div class="content"><p>On Tue, Mar 1, 2016 at 10:51 PM, Howard Lovatt &lt;howard.lovatt at gmail.com&gt; wrote:<br>&gt; Sorry, unfortunately I can&#39;t see that it really helps. All that happens is<br>&gt; that the client of the collection now holds the reference to the collection<br>&gt; as well as the reference to the iterator. In the more traditional model the<br>&gt; client holds a reference to the iterator which in turn holds a reference to<br>&gt; the collection.<br></p><p>I don&#39;t think there is a problem with iterators holding references to<br>the collection.  Iterators are value types, so they have to hold a<br>strong reference to the underlying collection, to make it non-uniquely<br>referenced, to prevent it from being mutated in place.  It is a<br>feature that iterators traverse a snapshot of the collection --<br>because of value semantics.<br></p><p>// Append array to itself:<br>for x in myArray { // for loop is just syntactic sugar for extracting<br>an iterator, and consuming it.<br>  myArray.append(x)<br>}<br></p><p>I think you might be confusing iterators and indexes.  Iterators<br>traverse the collection once.  Once you moved the iterator to the next<br>position, you can&#39;t move it back.  Sequences and collections both have<br>iterators.  Indices, on the other hand, are the basis of the<br>multi-pass nature of the collection.  If you hold onto an index, you<br>can use it multiple times to refer to collection&#39;s element, and even<br>mutate it.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0735d3bf1d76c0385258ac7a2a22d6fe?s=50"></div><header><strong>[RFC] New collections model: collections advance indices</strong> from <string>Károly Lőrentey</string> &lt;karoly at lorentey.hu&gt;<p>March  2, 2016 at 07:00:00am</p></header><div class="content"><p>This looks interesting! As the author of a number of custom collection<br>implementations, including a rather elaborate B-tree package<br>(https://github.com/lorentey/BTree), it always felt strange to me that<br>indices are expected to be able to move around the collection on their<br>own, while element access has to go through by the collection. It is a<br>great idea to fix this asymmetry.<br></p><p>I’ll have to carefully read through it a couple more times and look at<br>the prototype branch to form a real opinion, but at first glance I<br>like the proposal. Here are a couple of quick thoughts, with more to<br>come once I had time to think about the implications in detail:<br></p><p>- I’m not at a great fan of the `*IndexType` protocols in Swift 2. I<br>  do not believe they work hard enough compared to how hard it is to<br>  implement them, and I welcome any change that makes them even a <br>  little bit simpler for the collection writer.<br></p><p>- Having to call a collection method to increment an index looks<br>  unnatural at first glance, but I can see myself getting used to it<br>  in a few hours.<br></p><p>- I know that it isn&#39;t a new requirement, but I do dislike that<br>  `Indexable` specifies the complexity of index operations; this puts<br>  a hard constraint on custom collection design. I do understand the<br>  desire for concrete complexity promises on operations using<br>  indexes, but can&#39;t we express these instead e.g. in terms of number<br>  of index accesses?<br></p><p>- I love that there is a section with detailed guidance on designing <br>  tree-based collections. It’s interesting and informative.<br></p><p>- My B-trees are persistent data structures, thus my nodes cannot have<br>  parent or sibling links. Index lookup and navigation is still O(1)<br>  though, as my indices contain pointers to every node on the path to<br>  the current element. Since I have to keep looking up these nodes<br>  anyway to retrieve elements and to navigate around in the tree, I<br>  simply decided to keep them directly in the index. B-trees are super<br>  shallow, so there are only a handful of nodes on any path.<br></p><p>- I found that the most straightforward place to implement tree<br>  navigation methods like `next(:)` and `advance(:by:)` is on the path<br>  struct that contains the actual node references. There is no reason<br>  I couldn&#39;t have the new collection methods simply call through to<br>  these path methods, though -- I am currently doing the same thing in<br>  the BTreeIndex type anyway.<br>  <br>- I&#39;m using weak references inside the index, with a (seriously<br>  underdeveloped) index invalidation method that happens to be closer<br>  to #2b than #2a. I&#39;m not happy about using weak references, but this<br>  seemed the most sensible thing to do. I&#39;d love to replace them with<br>  `unowned(unsafe)`, and the mutation counter seems like a great idea.<br>  The ARC issue mentioned at the end of the proposal is rather scary,<br>  though -- I don&#39;t know how I would protect against that.<br>  <br>  Generators/iterators look to be safe from this issue,<br>  so I’ll probably optimize their path representation first. <br></p><p>- For mutation, I think custom APIs often make much more sense<br>  than general-purpose solutions. I try to discourage use of the normal<br>  B-tree index for doing complex tree mutations, and I instead provide <br>  a cursor construct that was designed especially for performing <br>  a batch of mutations in a batch:<br></p><p>  https://github.com/lorentey/BTree/blob/master/Sources/BTreeCursor.swift#L295-L707 <br></p><p>  The cursor is like an index on steroids. It has an identity with<br>  mutable state on its own, and it takes unique ownership of the tree<br>  while it is active. This frees the cursor to disable some costly<br>  invariants (such as maintaining up-to-date descendant counts in each<br>  node). This in turn allows for convenient batch editing of elements<br>  in the tree, with amortized O(1) insertion and removal operations.<br></p><p>  The cursor&#39;s approach goes the exact opposite way of this proposal:<br>  not only is the collection not necessary to use the cursor, but the<br>  collection&#39;s value isn&#39;t even available while there is an active<br>  cursor on it. (This is like how<br>  `Array.withUnsafeMutableBufferPointer()` works.)<br></p><p>- I&#39;m almost positive this has been discussed before, but what is the<br>  rationale behind allowing non-Int `IndexDistance`s? The distance is<br>  getting cast to Int in a lot of places anyway (IIRC, even the stdlib<br>  uses numericCasts to cut a way through it.)<br></p><p>    associatedtype IndexDistance : SignedIntegerType = Int<br></p><p>- The `Indices` associated type is intriguing. I assume it is brand new?<br>  It seems strange that it is allowed to hold a strong reference, but<br>  I’ll have to look through the prototype code to grok it.<br></p><p>  Superficial comment: I’m not too happy with the name. The irregular<br>  plural is hard on non-native English speakers, plus it seems weird<br>  to have both an `Index` and an `Indices` type. The `indices` property<br>  calls it `IndexRange` (I assume by accident); I think I like that <br>  name better.<br></p><p>- In this declaration:<br></p><p>    subscript(position: Index) -&gt; Generator.Element { get }<br></p><p>  I find the argument name rather unfortunate, because I&#39;ve been using<br>  the term &quot;position&quot; to consistently refer to the (numerical)<br>  position of an element in an ordered collection, which is typically<br>  not the same as the element&#39;s index. Could we just quietly rename<br>  this to `index` or `i`? :-)<br></p><p><br>&gt; On 2016-03-02, at 03:04, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; <br>&gt; Hi,<br>&gt; <br>&gt; We would like to propose a major change to how collection indices<br>&gt; work.  The standard library team has discussed this idea internally<br>&gt; and we wrote a prototype.  Now we think it is a viable direction to<br>&gt; consider, and we are bringing it for wider public discussion.<br>&gt; <br>&gt; I&#39;m pasting the first section of the proposal below to give you a<br>&gt; general idea about this change, but please read the proposal to<br>&gt; understand the full details.<br>&gt; <br>&gt; You can find the most up to date version of the proposal at<br>&gt; https://github.com/gribozavr/swift-evolution/blob/new-collections/proposals/NNNN-collections-move-indices.md<br>&gt; <br>&gt; Permalink: https://github.com/gribozavr/swift-evolution/blob/87df19a9a9d73e64a2a966b807440216a608b8ad/proposals/NNNN-collections-move-indices.md<br>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; ## Introduction<br>&gt; <br>&gt; We are proposing a new model for collections, where indices can only be<br>&gt; advanced forward or backward by the corresponding collection instance.<br>&gt; Indices become opaque tokens representing collection positions, that can<br>&gt; be produced and consumed by collection APIs.  This allows us to reduce<br>&gt; the amount of data stored in indices to the bare minimum.<br>&gt; <br>&gt; Compared to the current state, the new scheme simplifies implementation<br>&gt; of non-trivial indices, and fixes concurrency issues in `Set` and<br>&gt; `Dictionary` indices.  It also allows us to eliminate reference-counted<br>&gt; stored properties from most indices, including non-trivial ones, like<br>&gt; `Set.Index` and `Dictionary.Index`, creating more optimizable code.<br>&gt; <br>&gt; Out of scope for this proposal:<br>&gt; <br>&gt; * Expanding the set of concrete collections provided by the standard<br>&gt;  library.<br>&gt; <br>&gt; * Expanding the set of collection protocols to provide functionality<br>&gt;  beyond what is already provided (for example, protocols for sorted<br>&gt;  collections, queues etc.)  Discussing how other concrete collections<br>&gt;  fit into the current protocol hierarchy is in scope, though.<br></p><p>-- <br>Karoly<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[RFC] New collections model: collections advance indices</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>March  3, 2016 at 04:00:00pm</p></header><div class="content"><p>Hi Károly,<br></p><p>Sorry for a delayed reply!<br></p><p>On Tue, Mar 1, 2016 at 10:39 PM, Károly Lőrentey &lt;karoly at lorentey.hu&gt; wrote:<br>&gt; This looks interesting! As the author of a number of custom collection<br>&gt; implementations, including a rather elaborate B-tree package<br>&gt; (https://github.com/lorentey/BTree), it always felt strange to me that<br>&gt; indices are expected to be able to move around the collection on their<br>&gt; own, while element access has to go through by the collection. It is a<br>&gt; great idea to fix this asymmetry.<br>&gt;<br>&gt; I’ll have to carefully read through it a couple more times and look at<br>&gt; the prototype branch to form a real opinion, but at first glance I<br>&gt; like the proposal. Here are a couple of quick thoughts, with more to<br>&gt; come once I had time to think about the implications in detail:<br>&gt;<br>&gt; - I’m not at a great fan of the `*IndexType` protocols in Swift 2. I<br>&gt;   do not believe they work hard enough compared to how hard it is to<br>&gt;   implement them, and I welcome any change that makes them even a<br>&gt;   little bit simpler for the collection writer.<br></p><p>Thank you!  I added your point to the proposal.<br></p><p>&gt; - Having to call a collection method to increment an index looks<br>&gt;   unnatural at first glance, but I can see myself getting used to it<br>&gt;   in a few hours.<br>&gt;<br>&gt; - I know that it isn&#39;t a new requirement, but I do dislike that<br>&gt;   `Indexable` specifies the complexity of index operations; this puts<br>&gt;   a hard constraint on custom collection design. I do understand the<br>&gt;   desire for concrete complexity promises on operations using<br>&gt;   indexes, but can&#39;t we express these instead e.g. in terms of number<br>&gt;   of index accesses?<br></p><p>I think Dave answered this one.<br></p><p>&gt; - I love that there is a section with detailed guidance on designing<br>&gt;   tree-based collections. It’s interesting and informative.<br>&gt;<br>&gt; - My B-trees are persistent data structures, thus my nodes cannot have<br>&gt;   parent or sibling links. Index lookup and navigation is still O(1)<br>&gt;   though, as my indices contain pointers to every node on the path to<br>&gt;   the current element.<br></p><p>Are these pointers unsafe pointers or ARC references?  If they are ARC<br>references, then we get extra retain/releases.  If they are unsafe<br>pointers, we need a safety check -- and I am interested to know what<br>was your approach to this.<br></p><p>&gt; - I found that the most straightforward place to implement tree<br>&gt;   navigation methods like `next(:)` and `advance(:by:)` is on the path<br>&gt;   struct that contains the actual node references. There is no reason<br>&gt;   I couldn&#39;t have the new collection methods simply call through to<br>&gt;   these path methods, though -- I am currently doing the same thing in<br>&gt;   the BTreeIndex type anyway.<br>&gt;<br>&gt; - I&#39;m using weak references inside the index, with a (seriously<br>&gt;   underdeveloped) index invalidation method that happens to be closer<br>&gt;   to #2b than #2a. I&#39;m not happy about using weak references, but this<br>&gt;   seemed the most sensible thing to do. I&#39;d love to replace them with<br>&gt;   `unowned(unsafe)`, and the mutation counter seems like a great idea.<br>&gt;   The ARC issue mentioned at the end of the proposal is rather scary,<br>&gt;   though -- I don&#39;t know how I would protect against that.<br></p><p>Does your tree have in-place mutation?  (E.g., if a tree is uniquely<br>referenced, and there&#39;s only one live index, does tree[i] = 42<br>reallocate any nodes?)<br></p><p>I think the reasoning about unowned(safe) applies to weak references.<br>(The ARC issue.)<br></p><p>Fundamentally, the problem is that if you want an entity to be an<br>independent value, it has to hold strong references to all its<br>critical parts.  For example, an index can hold a weak reference to<br>something, but only if it does not care and continues to be fully<br>functional if that reference suddenly becomes nil.  But if a valid<br>index can&#39;t operate without a reference to collection&#39;s storage, it<br>has to be a strong reference.<br></p><p>You can replace a strong reference with an unsafe(unowned) reference,<br>but as an optimization, when it is possible to guarantee memory safety<br>by other means that are cheaper than ARC.  You should see no<br>functional difference between using a strong reference and<br>unsafe(unowned) + necessary safety checks.<br></p><p>&gt;   Generators/iterators look to be safe from this issue,<br>&gt;   so I’ll probably optimize their path representation first.<br></p><p>Generators/iterators are separate values.  So they should be<br>traversing a snapshot of the collection value.  Iterators shouldn&#39;t be<br>auto-updating with concurrent collection mutations.  For example, for<br>any collection implementation, this code terminates and appends<br>collection&#39;s elements to itself:<br></p><p>var c = getCollection()<br>for item in c {<br>  c.append(item)<br>}<br></p><p>Thus, iterators should be holding a strong reference to the<br>collection&#39;s storage, and make it non-uniquely referenced.<br></p><p>&gt; - For mutation, I think custom APIs often make much more sense<br>&gt;   than general-purpose solutions. I try to discourage use of the normal<br>&gt;   B-tree index for doing complex tree mutations, and I instead provide<br>&gt;   a cursor construct that was designed especially for performing<br>&gt;   a batch of mutations in a batch:<br>&gt;<br>&gt;   https://github.com/lorentey/BTree/blob/master/Sources/BTreeCursor.swift#L295-L707<br>&gt;<br>&gt;   The cursor is like an index on steroids. It has an identity with<br>&gt;   mutable state on its own, and it takes unique ownership of the tree<br>&gt;   while it is active. This frees the cursor to disable some costly<br>&gt;   invariants (such as maintaining up-to-date descendant counts in each<br>&gt;   node). This in turn allows for convenient batch editing of elements<br>&gt;   in the tree, with amortized O(1) insertion and removal operations.<br>&gt;<br>&gt;   The cursor&#39;s approach goes the exact opposite way of this proposal:<br>&gt;   not only is the collection not necessary to use the cursor, but the<br>&gt;   collection&#39;s value isn&#39;t even available while there is an active<br>&gt;   cursor on it. (This is like how<br>&gt;   `Array.withUnsafeMutableBufferPointer()` works.)<br></p><p>That&#39;s a very powerful concept!<br></p><p>&gt; - I&#39;m almost positive this has been discussed before, but what is the<br>&gt;   rationale behind allowing non-Int `IndexDistance`s? The distance is<br>&gt;   getting cast to Int in a lot of places anyway (IIRC, even the stdlib<br>&gt;   uses numericCasts to cut a way through it.)<br>&gt;<br>&gt;     associatedtype IndexDistance : SignedIntegerType = Int<br>&gt;<br>&gt; - The `Indices` associated type is intriguing. I assume it is brand new?<br>&gt;   It seems strange that it is allowed to hold a strong reference, but<br>&gt;   I’ll have to look through the prototype code to grok it.<br></p><p>No, it is not new.  It is a special type for `var indices`, which is<br>the collection of indices.  This variable used to be typed as<br>`Range&lt;Index&gt;` -- basically wrapping a pair of indices.<br>`Range&lt;Index&gt;` won&#39;t be able to conform to Collection in this<br>proposal, since you can&#39;t increment all indices in isolation.<br>Therefore, in the general case, `var indices` has to capture<br>startIndex, endIndex and the collection itself.  In some cases (for<br>example, Array) it can be Range&lt;Index&gt;.  To allow using the cheapest<br>possible implementation, we are making the type of `var indices` an<br>associated type.<br></p><p>The reason why it needs to hold a strong reference is the same as why<br>generators need to hold a strong reference.  This index collection is<br>a separate value.  The value should be usable regardless of what<br>happens to other values.<br></p><p>Consider this example:<br></p><p>var c = getCollection()<br>for i in c.indices {<br>  print(i)<br>  c.append(c[i])<br>}<br></p><p>Imagine that `c` is uniquely referenced, and `c.indices` holds an<br>unowned reference to `c` that does not increase the reference count.<br>Then, when a new element is appended, the collection might need to<br>reallocate the storage.  The old storage will be deallocated.  When<br>`c.indices` needs to increment the index, it will try to access an<br>unowned reference that was deallocated, and the program will trap.<br></p><p>&gt;   Superficial comment: I’m not too happy with the name. The irregular<br>&gt;   plural is hard on non-native English speakers, plus it seems weird<br>&gt;   to have both an `Index` and an `Indices` type. The `indices` property<br>&gt;   calls it `IndexRange` (I assume by accident); I think I like that<br>&gt;   name better.<br></p><p>I&#39;ll let Dave answer this one :)<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[RFC] New collections model: collections advance indices</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March  2, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; We would like to propose a major change to how collection indices<br>&gt; work.  The standard library team has discussed this idea internally<br>&gt; and we wrote a prototype.  Now we think it is a viable direction to<br>&gt; consider, and we are bringing it for wider public discussion.<br></p><p>This is super-interesting, and overall I think it&#39;s probably an improvement (although I haven&#39;t gone *really* deep with generic CollectionType code very often).<br></p><p>I do have a question, though it may simply betray my ignorance. `advance` has two forms:<br></p><p>	func advance(i: Index, by n: IndexDistance) -&gt; Index<br>	func advance(i: Index, by n: IndexDistance, limit: Index) -&gt; Index<br></p><p>This is a pretty straight port of the old `advance`:<br></p><p>	public func advancedBy(amount: Distance) -&gt; Self<br>	public func advancedBy(amount: Distance, limit: Self) -&gt; Self<br></p><p>But I&#39;m not sure the `limit` parameter is still appropriate. I&#39;ve always figured that you were supposed to pass the collection&#39;s `endIndex` there, but now that `advance` *is* a method on the collection, it can access that itself. Would we be better served with something like this?<br></p><p>	func unsafeAdvance(i: Index, by n: IndexDistance) -&gt; Index		// no endIndex check<br>	func advance(i: Index, by n: IndexDistance) -&gt; Index			// endIndex check<br></p><p>Or do you imagine the `limit` parameter being put to some other use that I&#39;m not thinking of?<br></p><p><br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[RFC] New collections model: collections advance indices</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>March  2, 2016 at 01:00:00am</p></header><div class="content"><p>On Wed, Mar 2, 2016 at 1:08 AM, Brent Royal-Gordon<br>&lt;brent at architechies.com&gt; wrote:<br>&gt;&gt; We would like to propose a major change to how collection indices<br>&gt;&gt; work.  The standard library team has discussed this idea internally<br>&gt;&gt; and we wrote a prototype.  Now we think it is a viable direction to<br>&gt;&gt; consider, and we are bringing it for wider public discussion.<br>&gt;<br>&gt; This is super-interesting, and overall I think it&#39;s probably an improvement (although I haven&#39;t gone *really* deep with generic CollectionType code very often).<br>&gt;<br>&gt; I do have a question, though it may simply betray my ignorance. `advance` has two forms:<br>&gt;<br>&gt;         func advance(i: Index, by n: IndexDistance) -&gt; Index<br>&gt;         func advance(i: Index, by n: IndexDistance, limit: Index) -&gt; Index<br>&gt;<br>&gt; This is a pretty straight port of the old `advance`:<br>&gt;<br>&gt;         public func advancedBy(amount: Distance) -&gt; Self<br>&gt;         public func advancedBy(amount: Distance, limit: Self) -&gt; Self<br>&gt;<br>&gt; But I&#39;m not sure the `limit` parameter is still appropriate. I&#39;ve always figured that you were supposed to pass the collection&#39;s `endIndex` there, but now that `advance` *is* a method on the collection, it can access that itself. Would we be better served with something like this?<br>&gt;<br>&gt;         func unsafeAdvance(i: Index, by n: IndexDistance) -&gt; Index              // no endIndex check<br>&gt;         func advance(i: Index, by n: IndexDistance) -&gt; Index                    // endIndex check<br>&gt;<br>&gt; Or do you imagine the `limit` parameter being put to some other use that I&#39;m not thinking of?<br></p><p>If limit was implied to be endIndex, how would Slice implement the<br>limiting advance?  Only by ignoring the advance() implementation from<br>the collection, and incrementing manually.  So it seems like advance<br>with an explicit limit is a basic operation that you can use to build<br>others.<br></p><p>Another thing is that &#39;unsafeAdvance&#39; is not really unsafe, it used to<br>be implementation-defined, but not memory-unsafe.  But now that the<br>collection is always available in advance(_:by:), we should be able to<br>require it to perform a trap if result is out of bounds.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[RFC] New collections model: collections advance indices</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>March  3, 2016 at 11:00:00am</p></header><div class="content"><p># General Remarks: Great!<br></p><p>Thanks for sharing this proposal; it&#39;s a big change, but will be a big improvement once it&#39;s in place, and it&#39;s encouraging to see the team is willing to undertake changes of such scale.<br></p><p>I&#39;m not sure how much discussion you&#39;ll actually manage to scare up b/c the issues this proposal addresses are *not* common, but are nevertheless rather significant when encountered.<br></p><p>E.G.: it&#39;s nice to be able to create simple chain/product/etc. collection-combinators which can, themselves, be collections, without winding up with indices indices forced to choose between *either* holding a back-reference to retrieve various startIndex/endIndex values as-needed *or* carrying around a complete set of all needed startIndex/endIndex values.<br></p><p>I don’t have any negative feedback that isn’t subsumed by the next section.<br></p><p># Concern: Linearity Baked-In <br></p><p>Even with this change, I have some concern that the proposed protocol hierarchy from `Collection` onward feels like it has a foreseeable lack of generality due to how strongly &quot;linear&quot; the design wants `Collection` to be. <br></p><p>Is this the right time to raise such concerns (e.g. in-scope for this discussion)?<br></p><p>Other than that concern about generality I think this proposal looks great &quot;on paper” and I hope to get a chance to experiment with it soon.<br></p><p>&gt; On Mar 1, 2016, at 8:04 PM, Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi,<br>&gt; <br>&gt; We would like to propose a major change to how collection indices<br>&gt; work.  The standard library team has discussed this idea internally<br>&gt; and we wrote a prototype.  Now we think it is a viable direction to<br>&gt; consider, and we are bringing it for wider public discussion.<br>&gt; <br>&gt; I&#39;m pasting the first section of the proposal below to give you a<br>&gt; general idea about this change, but please read the proposal to<br>&gt; understand the full details.<br>&gt; <br>&gt; You can find the most up to date version of the proposal at<br>&gt; https://github.com/gribozavr/swift-evolution/blob/new-collections/proposals/NNNN-collections-move-indices.md<br>&gt; <br>&gt; Permalink: https://github.com/gribozavr/swift-evolution/blob/87df19a9a9d73e64a2a966b807440216a608b8ad/proposals/NNNN-collections-move-indices.md<br>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; ## Introduction<br>&gt; <br>&gt; We are proposing a new model for collections, where indices can only be<br>&gt; advanced forward or backward by the corresponding collection instance.<br>&gt; Indices become opaque tokens representing collection positions, that can<br>&gt; be produced and consumed by collection APIs.  This allows us to reduce<br>&gt; the amount of data stored in indices to the bare minimum.<br>&gt; <br>&gt; Compared to the current state, the new scheme simplifies implementation<br>&gt; of non-trivial indices, and fixes concurrency issues in `Set` and<br>&gt; `Dictionary` indices.  It also allows us to eliminate reference-counted<br>&gt; stored properties from most indices, including non-trivial ones, like<br>&gt; `Set.Index` and `Dictionary.Index`, creating more optimizable code.<br>&gt; <br>&gt; Out of scope for this proposal:<br>&gt; <br>&gt; * Expanding the set of concrete collections provided by the standard<br>&gt;  library.<br>&gt; <br>&gt; * Expanding the set of collection protocols to provide functionality<br>&gt;  beyond what is already provided (for example, protocols for sorted<br>&gt;  collections, queues etc.)  Discussing how other concrete collections<br>&gt;  fit into the current protocol hierarchy is in scope, though.<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[RFC] New collections model: collections advance indices</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>March  3, 2016 at 01:00:00pm</p></header><div class="content"><p>On Thu, Mar 3, 2016 at 9:56 AM, plx via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; # General Remarks: Great!<br>&gt;<br>&gt; Thanks for sharing this proposal; it&#39;s a big change, but will be a big improvement once it&#39;s in place, and it&#39;s encouraging to see the team is willing to undertake changes of such scale.<br>&gt;<br>&gt; I&#39;m not sure how much discussion you&#39;ll actually manage to scare up b/c the issues this proposal addresses are *not* common, but are nevertheless rather significant when encountered.<br>&gt;<br>&gt; E.G.: it&#39;s nice to be able to create simple chain/product/etc. collection-combinators which can, themselves, be collections, without winding up with indices indices forced to choose between *either* holding a back-reference to retrieve various startIndex/endIndex values as-needed *or* carrying around a complete set of all needed startIndex/endIndex values.<br></p><p>Agreed!  We already have that problem in the lazy flatMap collection.<br></p><p>&gt; I don’t have any negative feedback that isn’t subsumed by the next section.<br>&gt;<br>&gt; # Concern: Linearity Baked-In<br>&gt;<br>&gt; Even with this change, I have some concern that the proposed protocol hierarchy from `Collection` onward feels like it has a foreseeable lack of generality due to how strongly &quot;linear&quot; the design wants `Collection` to be.<br>&gt;<br>&gt; Is this the right time to raise such concerns (e.g. in-scope for this discussion)?<br></p><p>We can definitely dive into more details about this.  One thing that I<br>would want to understand is whether this non-linearity concept could<br>be added later without a re-design.<br></p><p>Could you provide more information about the linearity issues that you<br>have in mind?  Are you thinking of something like Segmented Iterators<br>and Hierarchical Algorithms [1]?<br></p><p>[1] http://lafstern.org/matt/segmented.pdf<br></p><p>&gt; Other than that concern about generality I think this proposal looks great &quot;on paper” and I hope to get a chance to experiment with it soon.<br></p><p>If you want to try an early version, there is a prototype<br>implementation in<br>https://github.com/apple/swift/blob/master/test/Prototypes/CollectionsMoveIndices.swift<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[RFC] New collections model: collections advance indices</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>March  8, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Mar 3, 2016, at 3:28 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Thu, Mar 3, 2016 at 9:56 AM, plx via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; # General Remarks: Great!<br>&gt;&gt; <br>&gt;&gt; Thanks for sharing this proposal; it&#39;s a big change, but will be a big improvement once it&#39;s in place, and it&#39;s encouraging to see the team is willing to undertake changes of such scale.<br>&gt;&gt; <br>&gt;&gt; I&#39;m not sure how much discussion you&#39;ll actually manage to scare up b/c the issues this proposal addresses are *not* common, but are nevertheless rather significant when encountered.<br>&gt;&gt; <br>&gt;&gt; E.G.: it&#39;s nice to be able to create simple chain/product/etc. collection-combinators which can, themselves, be collections, without winding up with indices indices forced to choose between *either* holding a back-reference to retrieve various startIndex/endIndex values as-needed *or* carrying around a complete set of all needed startIndex/endIndex values.<br>&gt; <br>&gt; Agreed!  We already have that problem in the lazy flatMap collection.<br>&gt; <br>&gt;&gt; I don’t have any negative feedback that isn’t subsumed by the next section.<br>&gt;&gt; <br>&gt;&gt; # Concern: Linearity Baked-In<br>&gt;&gt; <br>&gt;&gt; Even with this change, I have some concern that the proposed protocol hierarchy from `Collection` onward feels like it has a foreseeable lack of generality due to how strongly &quot;linear&quot; the design wants `Collection` to be.<br>&gt;&gt; <br>&gt;&gt; Is this the right time to raise such concerns (e.g. in-scope for this discussion)?<br>&gt; <br>&gt; We can definitely dive into more details about this.  One thing that I<br>&gt; would want to understand is whether this non-linearity concept could<br>&gt; be added later without a re-design.<br></p><p>Sorry for the belated reply; I had to think for a bit about this one!<br></p><p>I’m not entirely sure, in part b/c I don’t have a ready-to-go alternative design to propose.<br></p><p>What I had in mind was to try and &quot;reserve room” for alternative indexing schemes to be added later without undue awkwardness.<br></p><p>However, when I went looking for real-world examples of such alternative indexing schemes it seems it’s just not something anyone actually does, and there’s probably a reason for that!<br></p><p>I think it’s possible to adjust the protocol hierarchy to “reserve room”—remove `Indexable`’s methods from `Collection`, add them back to a new `ForwardCollection` between `Collection` and `BidirectionalCollection`—but it’d only make sense to do that if you expect to have use for that room in the future.<br></p><p>&gt; Could you provide more information about the linearity issues that you<br>&gt; have in mind?  Are you thinking of something like Segmented Iterators<br>&gt; and Hierarchical Algorithms [1]?<br>&gt; <br>&gt; [1] http://lafstern.org/matt/segmented.pdf<br></p><p>That’s a neat paper! It also seems limited, insofar as it only demonstrated an improved implementation of `fill` (which is somewhat suggestive vis-a-vis the suspicions outlined above).<br></p><p>What I *was* thinking of was something generalizing the chapter on “Bifurcate Coordinates” in Stepanov’s “Elements of Programming” (this approach seems easily generalizable, but that doesn’t seem to have been taken up anywhere).<br></p><p>My thoughts were that as collections get stronger semantics, there’s an increasing disconnect between the semantics of the collection and the semantics of a “linear” index. Working up to it:<br></p><p>Arrays and array-like collections are truly “linear”, and are well-modeled by “linear” indices as-per the proposal; there’s a rich collection of generic algorithms that work on such collections and their indices, and it’s nice to have them in Swift.<br></p><p>Sets and dictionaries (and similar) are what I guess you could call “flat” (or “almost-linear”) collections: iteration aside, many index-based generic algorithms don’t work (particular mutating algorithms), and even where such algorithms *do work* it tends to be like this:<br></p><p>  let stringSet: Set&lt;String&gt; = [“a”, “b”, “c”, “d” ]<br>  let bPrefix = stringSet.prefixThrough(stringSet.indexOf(“b”)!)<br></p><p>…where the operation is *well-defined* but doesn’t have much to do with the semantics of `Set`.<br></p><p>Collections with even-stronger semantics (tree-shaped collections, order-maintaining collections, geometric collections, etc.) will likely have even further semantic disconnections!<br></p><p>As an example, one thing I’m working on is *basically* a “set&quot; of `(Value,CGRect)` pairs (with the rects possibly-overlapping each other); it keeps its contents organized so you can traverse its contents sorted by any combination of edge (north/south/east/west) and order (ascending/descending).<br></p><p>The way I have been structuring it is that each of those traversals is basically like this:<br></p><p>  extension CustomCollection {<br></p><p>    /// Returns a collection providing a specific, read-only, ordered “view” of the collection&#39;s contents.<br>    var byAscendingNorthernEdges: AscendingNorthernEdgeView { get }<br></p><p>  }<br></p><p>…and although I *did* make `CustomCollection` itself into a `CollectionType`, I can’t think of any scenario in which I’d ever intentionally want to use its `Index` for anything other than iteration.<br></p><p>Similarly, consider something like the tree-index situation vis-a-vis generic algorithms like `binarySearch`, `upperBound`, `lowerBound`, and `equalRange`:<br></p><p>- if the tree *isn’t* ordered-as-required the generic algorithms won’t work b/c the precondition isn’t being met<br>- if the tree *is* ordered-as-required the algorithms *will* work, but an implementation using linear-indices would likely be sub-optimal vis-a-vis implementations that exploit the tree-structure (start at root, follow appropriate branch, etc.) <br></p><p>…all of which leads me to wonder a bit about the general usefulness of such linear indices outside of iteration.<br></p><p>To be clear, there’s nothing in all of the above that has anything specifically to do with “Collections move Indices”; it’s all about potential future directions.<br></p><p>Even then, it seems like most other languages stick with what I’ve been calling a “linear” model and their “fancier&quot; collections *are* collections (as per their basic collection-API) and then use additional API to get at the “fancier” functionality, so it’s not clear there’s a real need to do different here.<br></p><p>&gt; <br>&gt;&gt; Other than that concern about generality I think this proposal looks great &quot;on paper” and I hope to get a chance to experiment with it soon.<br>&gt; <br>&gt; If you want to try an early version, there is a prototype<br>&gt; implementation in<br>&gt; https://github.com/apple/swift/blob/master/test/Prototypes/CollectionsMoveIndices.swift<br>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[RFC] New collections model: collections advance indices</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>March  7, 2016 at 05:00:00pm</p></header><div class="content"><p>Hi,<br></p><p>What does everyone think about requiring indices to conform to<br>Hashable, in addition to the existing requirements for Equatable and<br>Comparable?<br></p><p>I don&#39;t think this should limit any viable collection designs, and yet<br>might be useful, for example, to store indices in a set.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[RFC] New collections model: collections advance indices</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>March  8, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On 08 Mar 2016, at 03:25, Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; What does everyone think about requiring indices to conform to<br>&gt; Hashable, in addition to the existing requirements for Equatable and<br>&gt; Comparable?<br></p><p>Why impose such a restriction?<br></p><p>I think it&#39;s better to just make any concrete index types (e.g. DictionaryIndex&lt;K,V&gt;) in the standard library Hashable where possible. People are still free to constrain their algorithms to `C : CollectionType where C.Index : Hashable` whenever needed.<br></p><p>Besides, in the proposed design, is it really necessary to make Index also Comparable, or wouldn&#39;t Equatable be enough? Is it just a question of convenience and failing to find an example of and index type that&#39;s Equatable but not Comparable?<br></p><p>— Pyry<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160308/2a92ce46/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[RFC] New collections model: collections advance indices</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>March  8, 2016 at 09:00:00am</p></header><div class="content"><p>So far I can’t think of a single index that would have difficulty implementing `Hashable`.<br></p><p>One policy question though:<br></p><p>  struct MutationTrackingTreeIndex&lt;T&gt; {<br>    private let mutation: Int<br>    private unsafe(unowned) let treeNode: TreeNode&lt;T&gt;<br>  }<br></p><p>  // which hashValue would you expect:<br>  extension MutationTrackingTreeIndex : Hashable {<br></p><p>    var hashValue: Int {<br>      return ObjectIdentifier(treeNode).hashValue<br>    }<br></p><p>    var hashValue: Int {<br>      return ObjectIdentifier(treeNode).hashValue ^ self.mutation<br>    }<br></p><p>  }<br></p><p>…I’d assume the 2nd, but there’s then going to be room for confusion vis-a-vis how it works with Array (and other Int-indexed collections, or even e.g. an “Array” backed by a persistent tree of some kind).<br></p><p>I think `Hashable` indices is a good idea but I would want the expectation for considerations like the above to be documented for consistency’s sake.<br></p><p>&gt; On Mar 7, 2016, at 7:25 PM, Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi,<br>&gt; <br>&gt; What does everyone think about requiring indices to conform to<br>&gt; Hashable, in addition to the existing requirements for Equatable and<br>&gt; Comparable?<br>&gt; <br>&gt; I don&#39;t think this should limit any viable collection designs, and yet<br>&gt; might be useful, for example, to store indices in a set.<br>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[RFC] New collections model: collections advance indices</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March  8, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Mar 7, 2016, at 5:25 PM, Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi,<br>&gt; <br>&gt; What does everyone think about requiring indices to conform to<br>&gt; Hashable, in addition to the existing requirements for Equatable and<br>&gt; Comparable?<br>&gt; <br>&gt; I don&#39;t think this should limit any viable collection designs, and yet<br>&gt; might be useful, for example, to store indices in a set.<br></p><p>Is there a reason for Hashable to be distinct from Equatable at all? Every Equatable type can (badly) satisfy the requirements of Hashable with `return 0;`, if nothing else.<br></p><p>-Joe<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[RFC] New collections model: collections advance indices</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>March  9, 2016 at 09:00:00am</p></header><div class="content"><p>I have used the node of a linked list as the list&#39;s index! The node wasn&#39;t<br>Hashable, Equatable, or Comparable; hash and equate would be easy to add<br>but Comparable would be expensive. It is probably not a big deal since<br>linked lists aren&#39;t that great a data structure anyway. Code below:<br></p><p>class Node&lt;Element&gt; {<br></p><p>    var value: Element<br></p><p>    private(set) var next: Node&lt;Element&gt;? = nil<br></p><p>    init(_ value: Element) { self.value = value }<br></p><p>    init(value: Element, successor: Node&lt;Element&gt;) {<br></p><p>        self.value = value<br></p><p>        self.next = successor<br></p><p>    }<br></p><p>}<br></p><p><br>class LinkedListGenerator&lt;Element&gt;: GeneratorType {<br></p><p>    private var index: Node&lt;Element&gt;?<br></p><p>    init(_ startIndex: Node&lt;Element&gt;) { index = startIndex }<br></p><p>    func next() -&gt; Element? {<br></p><p>        guard let i = index else { return nil }<br></p><p>        let element = i.value<br></p><p>        index = i.next<br></p><p>        return element<br></p><p>    }<br></p><p>}<br></p><p><br>class LinkedList&lt;Element&gt;: SequenceType { // Has same interface as<br>Indexable, but without the ForwardIndexType constraint<br></p><p>    private(set) var startIndex: Node&lt;Element&gt;<br></p><p>    private(set) var endIndex: Node&lt;Element&gt;<br></p><p>    convenience init&lt;S: SequenceType where S.Generator.Element ==<br>Element&gt;(elements:<br>S) {<br></p><p>        var gen = elements.generate()<br></p><p>        var element = gen.next()<br></p><p>        guard let first = element else { fatalError(&quot;Empty list&quot;) }<br></p><p>        self.init(first)<br></p><p>        element = gen.next()<br></p><p>        while element != nil {<br></p><p>            append(element!)<br></p><p>            element = gen.next()<br></p><p>        }<br></p><p>    }<br></p><p>    init(_ element: Element) {<br></p><p>        startIndex = Node(element)<br></p><p>        endIndex = startIndex<br></p><p>    }<br></p><p>    subscript(index: Node&lt;Element&gt;) -&gt; Element {<br></p><p>        get { return index.value }<br></p><p>        set { index.value = newValue }<br></p><p>    }<br></p><p>    func generate() -&gt; LinkedListGenerator&lt;Element&gt; { return<br>LinkedListGenerator(startIndex) }<br></p><p>    func prepend(element: Element) { startIndex = Node(value: element,<br>successor: startIndex) }<br></p><p>    func prepend(elements elements: LinkedList&lt;Element&gt;) {<br></p><p>        let old = startIndex<br></p><p>        startIndex = elements.startIndex<br></p><p>        elements.endIndex.next = old<br></p><p>    }<br></p><p>    func append(element: Element) {<br></p><p>        endIndex.next = Node(element)<br></p><p>        endIndex = endIndex.next!<br></p><p>    }<br></p><p>    func append(elements elements: LinkedList&lt;Element&gt;) {<br></p><p>        endIndex.next = elements.startIndex<br></p><p>        endIndex = elements.endIndex<br></p><p>    }<br></p><p>}<br></p><p><br>  -- Howard.<br></p><p>On 8 March 2016 at 12:25, Dmitri Gribenko via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hi,<br>&gt;<br>&gt; What does everyone think about requiring indices to conform to<br>&gt; Hashable, in addition to the existing requirements for Equatable and<br>&gt; Comparable?<br>&gt;<br>&gt; I don&#39;t think this should limit any viable collection designs, and yet<br>&gt; might be useful, for example, to store indices in a set.<br>&gt;<br>&gt; Dmitri<br>&gt;<br>&gt; --<br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160309/6153818f/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
