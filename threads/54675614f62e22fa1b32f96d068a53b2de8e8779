<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Review] SE-0112: Improved NSError Bridging</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>June 30, 2016 at 11:00:00am</p></header><div class="content"><p>Hello Swift community,<br></p><p>The review of &quot;SE-0112: Improved NSError Bridging&quot; begins now and runs through July 4. The proposal is available here:<br></p><p>	https://github.com/apple/swift-evolution/blob/master/proposals/0112-nserror-bridging.md<br></p><p>Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br></p><p>	https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>or, if you would like to keep your feedback private, directly to the review manager.<br></p><p>What goes into a review?<br></p><p>The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br></p><p>	* What is your evaluation of the proposal?<br>	* Is the problem being addressed significant enough to warrant a change to Swift?<br>	* Does this proposal fit well with the feel and direction of Swift?<br>	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>More information about the Swift evolution process is available at<br></p><p>	https://github.com/apple/swift-evolution/blob/master/process.md<br></p><p>Thank you,<br></p><p>-Chris Lattner<br>Review Manager<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c72bd3ba434ad651a5d8d3d79f2d4c49?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0112: Improved NSError Bridging</strong> from <string>Scott James Remnant</string> &lt;scott at netsplit.com&gt;<p>June 30, 2016 at 11:00:00am</p></header><div class="content"><p>+1<br></p><p>I continually find the use of `as` for bridging between Objective-C and Swift types to be confusing, since they do not have a true place in the Swift type hierarchy and are not simple casts. The `catch let error as NSError` construct always implies that NSError is a true type that can be thrown, and this confusion gets worse in the places where NSError “leaks” out of APIs and you can’t actually cleanly bridge from an ErrorProtocol anyway.<br></p><p>One comment though:<br></p><p>Why is the errorDescription of LocalizedError an optional? Why would a type conform to this protocol, and then choose not to provide its only extension to ErrorProtocol?<br></p><p><br>Scott<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0112: Improved NSError Bridging</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>June 30, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jun 30, 2016, at 1:30 PM, Scott James Remnant via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; +1<br>&gt; <br>&gt; I continually find the use of `as` for bridging between Objective-C and Swift types to be confusing, since they do not have a true place in the Swift type hierarchy and are not simple casts. The `catch let error as NSError` construct always implies that NSError is a true type that can be thrown, and this confusion gets worse in the places where NSError “leaks” out of APIs and you can’t actually cleanly bridge from an ErrorProtocol anyway.<br></p><p>The weird and convoluted behavior of the “as” keyword is one of the uglier (and more error-prone) warts in the language as it currently stands. There was a proposal a while back to remove the bridging behavior from the “as” keyword, greatly simplifying its behavior, but discussion on it seems to have died down. I hope it can be revived once this proposal is accepted, since the need for “as NSError” was one of the main problems with that proposal.<br></p><p>&gt; One comment though:<br>&gt; <br>&gt; Why is the errorDescription of LocalizedError an optional? Why would a type conform to this protocol, and then choose not to provide its only extension to ErrorProtocol?<br></p><p>This one’s my fault; Gregory originally had this as a non-optional and I recommended changing it, because Cocoa uses a nil value for NSLocalizedDescriptionKey to indicate that the default behavior should be used to construct the error string. In my experience, this is usually in fact what you want, and NSLocalizedFailureReasonErrorKey is a better fit for most purposes. For example, when throwing an error in an NSDocument subclass:<br></p><p>override func read(from data: Data, ofType typeName: String) throws {<br>    let userInfo = [NSLocalizedFailureReasonErrorKey: &quot;Something went wrong.&quot;]<br>    throw NSError(domain: &quot;Foo&quot;, code: 1, userInfo: userInfo)<br>}<br></p><p>In the example above, the error is presented to the user as “The operation could not be completed. Something went wrong.”<br></p><p>However, if you fill in the localized description instead of the failure reason, like this:<br></p><p>override func read(from data: Data, ofType typeName: String) throws {<br>    let userInfo = [NSLocalizedDescriptionKey: &quot;Something went wrong.&quot;]<br>    throw NSError(domain: &quot;Foo&quot;, code: 1, userInfo: userInfo)<br>}<br></p><p>The user is shown “The operation could not be completed.” with no further information.<br></p><p>Even when you’re reporting errors directly, the behavior is different whether you provide the localized description or omit it. With a nil description, as below:<br></p><p>let userInfo = [NSLocalizedFailureReasonErrorKey: &quot;Something went wrong.&quot;]<br>NSApp.presentError(NSError(domain: &quot;Foo&quot;, code: 1, userInfo: userInfo))<br></p><p>The error is presented as “The operation could not be completed. Something went wrong.” By comparison, if we provide the description:<br></p><p>let userInfo = [NSLocalizedDescriptionKey: &quot;Something went wrong.&quot;]<br>NSApp.presentError(NSError(domain: &quot;Foo&quot;, code: 1, userInfo: userInfo))<br></p><p>The error is simply reported as “Something went wrong.” This seems somewhat brusque, compared to the more polite and blow-softening behavior of the former example.<br></p><p>Unfortunately, I can’t think of any way for this property to return a non-optional, human-readable string to the end user while still communicating to NSError that the field should be nil, unless the default implementation can either copy the code that NSError uses to generate this value, or call through to NSError to generate it. I do notice that NSError always returns something appropriate when you call -localizedDescription on it, although it has the advantage that that method is only used to retrieve the value, not to provide it, unlike here.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160630/2f8ba91b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0112: Improved NSError Bridging</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>June 30, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jun 30, 2016, at 5:36 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; One comment though:<br>&gt;&gt; <br>&gt;&gt; Why is the errorDescription of LocalizedError an optional? Why would a type conform to this protocol, and then choose not to provide its only extension to ErrorProtocol?<br>&gt; <br>&gt; This one’s my fault; Gregory originally had this as a non-optional and I recommended changing it, because Cocoa uses a nil value for NSLocalizedDescriptionKey to indicate that the default behavior should be used to construct the error string. In my experience, this is usually in fact what you want, and NSLocalizedFailureReasonErrorKey is a better fit for most purposes. For example, when throwing an error in an NSDocument subclass:<br>&gt; <br>&gt; override func read(from data: Data, ofType typeName: String) throws {<br>&gt;     let userInfo = [NSLocalizedFailureReasonErrorKey: &quot;Something went wrong.&quot;]<br>&gt;     throw NSError(domain: &quot;Foo&quot;, code: 1, userInfo: userInfo)<br>&gt; }<br>&gt; <br>&gt; In the example above, the error is presented to the user as “The operation could not be completed. Something went wrong.”<br>&gt; <br>&gt; However, if you fill in the localized description instead of the failure reason, like this:<br>&gt; <br>&gt; override func read(from data: Data, ofType typeName: String) throws {<br>&gt;     let userInfo = [NSLocalizedDescriptionKey: &quot;Something went wrong.&quot;]<br>&gt;     throw NSError(domain: &quot;Foo&quot;, code: 1, userInfo: userInfo)<br>&gt; }<br>&gt; <br>&gt; The user is shown “The operation could not be completed.” with no further information.<br>&gt; <br>&gt; Even when you’re reporting errors directly, the behavior is different whether you provide the localized description or omit it. With a nil description, as below:<br>&gt; <br>&gt; let userInfo = [NSLocalizedFailureReasonErrorKey: &quot;Something went wrong.&quot;]<br>&gt; NSApp.presentError(NSError(domain: &quot;Foo&quot;, code: 1, userInfo: userInfo))<br>&gt; <br>&gt; The error is presented as “The operation could not be completed. Something went wrong.” By comparison, if we provide the description:<br>&gt; <br>&gt; let userInfo = [NSLocalizedDescriptionKey: &quot;Something went wrong.&quot;]<br>&gt; NSApp.presentError(NSError(domain: &quot;Foo&quot;, code: 1, userInfo: userInfo))<br>&gt; <br>&gt; The error is simply reported as “Something went wrong.” This seems somewhat brusque, compared to the more polite and blow-softening behavior of the former example.<br>&gt; <br>&gt; Unfortunately, I can’t think of any way for this property to return a non-optional, human-readable string to the end user while still communicating to NSError that the field should be nil, unless the default implementation can either copy the code that NSError uses to generate this value, or call through to NSError to generate it. I do notice that NSError always returns something appropriate when you call -localizedDescription on it, although it has the advantage that that method is only used to retrieve the value, not to provide it, unlike here.<br></p><p>Actually, looking at the proposal again, it looks like Gregory has already solved this issue. #4 under Proposed Solution mentions a “localizedDescription” property on Error/ErrorProperty, provided by Foundation, which appears to do the equivalent of calling -localizedDescription on NSError. The optional “errorDescription” property on CustomCocoaError/CustomNSError is there for bridging purposes, and localizedDescription is what you’d use to get the string for presentation. Having separate APIs for separate purposes is probably better than trying to hack two uses into the same property, honestly.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160630/62a87c3f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0112: Improved NSError Bridging</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>June 30, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jun 30, 2016, at 9:19 PM, Charles Srstka &lt;cocoadev at charlessoft.com&gt; wrote:<br>&gt; <br>&gt; Actually, looking at the proposal again, it looks like Gregory has already solved this issue.<br></p><p>*Douglas<br></p><p>(Not sure how I swapped your first and last names in my mind. Sorry about that!)<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160630/38ef76df/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0112: Improved NSError Bridging</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 30, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br></p><p>+1.  This looks like a very nice improvement.<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes.  It’s important to continue improving the safety and Swiftiness of Apple’s Objective-C APIs.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Very much.<br></p><p>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>N/A<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>A careful reading.<br></p><p>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution-announce mailing list<br>&gt; swift-evolution-announce at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution-announce<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Review] SE-0112: Improved NSError Bridging</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>July  1, 2016 at 02:00:00pm</p></header><div class="content"><p>FYI, in-progress implementation is available at:<br></p><p>	https://github.com/apple/swift/tree/nserror-bridging &lt;https://github.com/apple/swift/tree/nserror-bridging&gt;<br></p><p>The only issue I’ve found so far with the proposal is this bit:<br></p><p>	When we introduce this bridging, we will need to remove NSError&#39;s conformance to ErrorProtocol to avoid creating cyclic implicit conversions. However, one can still explicitly turn an NSError into ErrorProtocol via a bridging cast, e.g., nsError as ErrorProtocol.<br></p><p>This doesn’t work, because the model really needs NSError to conform to ErrorProtocol. Instead, we should break the implicit conversion by not allowing an implicit conversion from an arbitrary ErrorProtocol to NSError, which is in line with what SE-0072 would do anyway.<br></p><p>	- Doug<br></p><p>&gt; On Jun 30, 2016, at 11:22 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;SE-0112: Improved NSError Bridging&quot; begins now and runs through July 4. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0112-nserror-bridging.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160701/06ab1962/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Review] SE-0112: Improved NSError Bridging</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>July  1, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Jul 1, 2016, at 4:12 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; FYI, in-progress implementation is available at:<br>&gt; <br>&gt; 	https://github.com/apple/swift/tree/nserror-bridging &lt;https://github.com/apple/swift/tree/nserror-bridging&gt;<br>&gt; <br>&gt; The only issue I’ve found so far with the proposal is this bit:<br>&gt; <br>&gt; 	When we introduce this bridging, we will need to remove NSError&#39;s conformance to ErrorProtocol to avoid creating cyclic implicit conversions. However, one can still explicitly turn an NSError into ErrorProtocol via a bridging cast, e.g., nsError as ErrorProtocol.<br>&gt; <br>&gt; This doesn’t work, because the model really needs NSError to conform to ErrorProtocol. Instead, we should break the implicit conversion by not allowing an implicit conversion from an arbitrary ErrorProtocol to NSError, which is in line with what SE-0072 would do anyway.<br></p><p>What exactly in the model causes it to require NSError to conform to ErrorProtocol?<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160701/1224397c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Review] SE-0112: Improved NSError Bridging</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>July  1, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jul 1, 2016, at 5:25 PM, Charles Srstka &lt;cocoadev at charlessoft.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Jul 1, 2016, at 4:12 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; FYI, in-progress implementation is available at:<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift/tree/nserror-bridging &lt;https://github.com/apple/swift/tree/nserror-bridging&gt;<br>&gt;&gt; <br>&gt;&gt; The only issue I’ve found so far with the proposal is this bit:<br>&gt;&gt; <br>&gt;&gt; 	When we introduce this bridging, we will need to remove NSError&#39;s conformance to ErrorProtocol to avoid creating cyclic implicit conversions. However, one can still explicitly turn an NSError into ErrorProtocol via a bridging cast, e.g., nsError as ErrorProtocol.<br>&gt;&gt; <br>&gt;&gt; This doesn’t work, because the model really needs NSError to conform to ErrorProtocol. Instead, we should break the implicit conversion by not allowing an implicit conversion from an arbitrary ErrorProtocol to NSError, which is in line with what SE-0072 would do anyway.<br>&gt; <br>&gt; What exactly in the model causes it to require NSError to conform to ErrorProtocol?<br></p><p>ErrorProtocol uses a single-pointer, boxed representation where an NSError pointer can be used directly. Basically, ErrorProtocol is represented as an NSError, always.<br></p><p>	- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160701/ad61170b/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Review] SE-0112: Improved NSError Bridging</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>July  1, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; 	* What is your evaluation of the proposal?<br></p><p>Massively in favor overall. I use NSError features heavily in Objective-C, and I&#39;ll be very, very glad to get powerful error bridging in Swift.<br></p><p>I don&#39;t think it&#39;s mentioned anywhere, but are the new protocols in Foundation or Stdlib? I&#39;m hoping they&#39;re in Foundation, because I consider localization to be a Foundation-level concern.<br></p><p>I have a number of critiques:<br></p><p>* I think we need the word &quot;localized&quot; on the properties of `LocalizedError`. The fact that they&#39;re localized is a very important semantic, and I don&#39;t think the fact that they come from a protocol called &quot;Localized&quot; is enough to signal that at use sites. (With &quot;localized&quot; added, `errorDescription` would no longer need the vacuous word &quot;error&quot; to avoid colliding with `CustomStringConvertible`.)<br></p><p>* I&#39;m not sure about including the `helpAnchor` property in `LocalizedError`. It&#39;s not even relevant on three of *Apple&#39;s* four platforms, let alone on others. Could it be separated?<br></p><p>* I would like to see more work on `RecoverableError`. I know this is a more or less faithful translation of `NSErrorRecoveryAttempting`, but I don&#39;t think that&#39;s a particularly good API, and I would like to see it revisited.<br></p><p>The design I&#39;d prefer would look more like this:<br></p><p>	protocol RecoverableError: Error {<br>		var recoveryOptions: [ErrorRecoveryOption] { get }<br>	}<br>	<br>	typealias ErrorRecoveryCompletionHandler = (recovered: Bool) -&gt; Void<br>	<br>	protocol ErrorRecoveryOption {<br>		var localizedName: String { get }<br>		func attemptRecovery(completion: ErrorRecoveryCompletionHandler) {…}<br>	}<br>	<br>	struct AnyErrorRecoveryOption: ErrorRecoveryOption {<br>		typealias RecoveryAttempter = (ErrorRecoveryCompletionHandler) -&gt; Void<br>		<br>		var localizedName: String<br>		var attempter: RecoveryAttempter<br>		<br>		init(localizedName: String, attempter: RecoveryAttempter) {…}<br>		<br>		func attemptRecovery(completion: CompletionHandler) { attempter(completion) }<br>	}<br></p><p>Though further from the equivalent Foundation API, I think this is a much cleaner design. It requires no `switch` statements, avoids issues with matching indices between the option array and the recovery attempter, and makes it easier for interested subtypes to add or remove recovery options.<br>		<br>In particular, in my view, there should be only one way to attempt recovery, and that way should not be application-modal. If a client wants to recover modally, we should invoke the non-modal API and then spin the runloop until the completion handler runs.<br></p><p>If a better `RecoverableError` design isn&#39;t feasible in Swift 3, I think we can defer it. In a pinch, `CustomNSError` provides the ability to specify error-handling behavior the old-fashioned way.<br></p><p>* You show an AVError struct with a nested .Code enum. Do you envision people doing similar things for pure-Swift error types? If so, what would that look like, and could it be made more ergonomic? If not, what do you imagine a similarly full-featured error type would look like?<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Absolutely! NSError provides a remarkably powerful infrastructure, especially on the Mac, and most developers ignore it to their detriment. This stuff ought to be made as easy as possible to implement.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes. These changes seem very much in line with existing Swift practice.<br></p><p>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>N/A.<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>Quick reading.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Review] SE-0112: Improved NSError Bridging</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>July  1, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Jul 1, 2016, at 8:25 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; * I think we need the word &quot;localized&quot; on the properties of `LocalizedError`. The fact that they&#39;re localized is a very important semantic, and I don&#39;t think the fact that they come from a protocol called &quot;Localized&quot; is enough to signal that at use sites. (With &quot;localized&quot; added, `errorDescription` would no longer need the vacuous word &quot;error&quot; to avoid colliding with `CustomStringConvertible`.)<br></p><p>I disagree, for a few reasons:<br></p><p>1. The most common user of this protocol is the person implementing conformance for it. “Localized” is right up there in the protocol name, which usually won’t be far from the declarations of these properties. Repeating it in all the property names seems redundant and unnecessarily verbose, and very much not in keeping with the general feel of Swift 3.<br></p><p>2. The word “error” would need to be kept in “errorDescription” anyway, since simply renaming it “localizedDescription” would cause it to conflict with the property that is being added to ErrorProtocol itself. It would probably need to be named “localizedErrorDescription” or some such, which is really getting too long.<br></p><p>3. I’ve always felt the “Localized” in all those constant names was unnecessary, even in the old Objective-C API. Isn’t it kind of a given that a user-facing string should be localized? Why would you ever want a non-localized error description, failure reason, etc. in the first place? Should we add “localized” to the beginnings of, for example, NSAlert’s ‘messageText&#39; and ‘informativeText&#39; properties? Those properties certainly should be localized. How about NSSavePanel’s ‘prompt’ property? IMO, it’s unnecessary verbiage.<br></p><p>Charles<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160701/1698f62d/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Review] SE-0112: Improved NSError Bridging</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>July  3, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jul 1, 2016, at 6:25 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt; <br>&gt; Massively in favor overall. I use NSError features heavily in Objective-C, and I&#39;ll be very, very glad to get powerful error bridging in Swift.<br>&gt; <br>&gt; I don&#39;t think it&#39;s mentioned anywhere, but are the new protocols in Foundation or Stdlib? I&#39;m hoping they&#39;re in Foundation, because I consider localization to be a Foundation-level concern.<br></p><p>Yes, they’re all in Foundation.<br></p><p>&gt; <br>&gt; I have a number of critiques:<br>&gt; <br>&gt; * I think we need the word &quot;localized&quot; on the properties of `LocalizedError`. The fact that they&#39;re localized is a very important semantic, and I don&#39;t think the fact that they come from a protocol called &quot;Localized&quot; is enough to signal that at use sites. (With &quot;localized&quot; added, `errorDescription` would no longer need the vacuous word &quot;error&quot; to avoid colliding with `CustomStringConvertible`.)<br></p><p>To a close approximation, there are no use sites of these protocols. Error types will conform to this protocol to provide more information, and we expect all of these to be, e.g.,<br></p><p>	extension MyError : LocalizedError { … }<br></p><p>where we don’t need the repeated “localized”.<br></p><p>For the very few that might want to handle a localized error on their own, this will be in the context of<br></p><p>	if let localizedError = theError as? LocalizedError { … }<br></p><p>and again I think the context is clear.<br></p><p>&gt; <br>&gt; * I&#39;m not sure about including the `helpAnchor` property in `LocalizedError`. It&#39;s not even relevant on three of *Apple&#39;s* four platforms, let alone on others. Could it be separated?<br></p><p>It’s defaulted; why bother to split it into a separate protocol?<br></p><p>&gt; <br>&gt; * I would like to see more work on `RecoverableError`. I know this is a more or less faithful translation of `NSErrorRecoveryAttempting`, but I don&#39;t think that&#39;s a particularly good API, and I would like to see it revisited.<br>&gt; <br>&gt; The design I&#39;d prefer would look more like this:<br>&gt; <br>&gt; 	protocol RecoverableError: Error {<br>&gt; 		var recoveryOptions: [ErrorRecoveryOption] { get }<br>&gt; 	}<br>&gt; 	<br>&gt; 	typealias ErrorRecoveryCompletionHandler = (recovered: Bool) -&gt; Void<br>&gt; 	<br>&gt; 	protocol ErrorRecoveryOption {<br>&gt; 		var localizedName: String { get }<br>&gt; 		func attemptRecovery(completion: ErrorRecoveryCompletionHandler) {…}<br>&gt; 	}<br>&gt; 	<br>&gt; 	struct AnyErrorRecoveryOption: ErrorRecoveryOption {<br>&gt; 		typealias RecoveryAttempter = (ErrorRecoveryCompletionHandler) -&gt; Void<br>&gt; 		<br>&gt; 		var localizedName: String<br>&gt; 		var attempter: RecoveryAttempter<br>&gt; 		<br>&gt; 		init(localizedName: String, attempter: RecoveryAttempter) {…}<br>&gt; 		<br>&gt; 		func attemptRecovery(completion: CompletionHandler) { attempter(completion) }<br>&gt; 	}<br>&gt; <br>&gt; Though further from the equivalent Foundation API, I think this is a much cleaner design. It requires no `switch` statements, avoids issues with matching indices between the option array and the recovery attempter, and makes it easier for interested subtypes to add or remove recovery options.<br></p><p>I agree that we could probably do better with the design, although this feels a bit heavy with the introduction of the ErrorRecoveryOption protocol. The common case is probably an enum where each case  describes an option, but I don’t have a natural way to model that.<br>		<br>&gt; In particular, in my view, there should be only one way to attempt recovery, and that way should not be application-modal. If a client wants to recover modally, we should invoke the non-modal API and then spin the runloop until the completion handler runs.<br></p><p>Hrm. I’d very much prefer to let the system frameworks handle this, but that’s partly because I don’t have a lot of experience to fall back on with recovering from errors in Cocoa.<br></p><p>&gt; <br>&gt; If a better `RecoverableError` design isn&#39;t feasible in Swift 3, I think we can defer it. In a pinch, `CustomNSError` provides the ability to specify error-handling behavior the old-fashioned way.<br></p><p>Sure, we could delay just this bit if we think some significantly better design is coming.<br></p><p>&gt; <br>&gt; * You show an AVError struct with a nested .Code enum. Do you envision people doing similar things for pure-Swift error types? If so, what would that look like, and could it be made more ergonomic? If not, what do you imagine a similarly full-featured error type would look like?<br></p><p>I wouldn’t expect to see this come up often, because error types are generally enums, and Swift enums can carry arbitrary data in their cases. Imported enums are different because we might need to be able to refer to the “raw” code type in other APIs.<br></p><p>	- Doug<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bdd257c9369fb68e1d06923d10ff789e?s=50"></div><header><strong>[Review] SE-0112: Improved NSError Bridging</strong> from <string>Ben Rimmington</string> &lt;me at benrimmington.com&gt;<p>July  5, 2016 at 06:00:00am</p></header><div class="content"><p>&lt;https://github.com/apple/swift-evolution/blob/master/proposals/0112-nserror-bridging.md&gt;<br></p><p>If &lt;Foundation/NSError.h&gt; uses NS_EXTENSIBLE_STRING_ENUM for `domain` names and `userInfo` keys, would a generic type (cf. DispatchSpecificKey) also be possible?<br></p><p>	FOUNDATION_EXPORT NSErrorUserInfoKey&lt;NSNumber&gt; const NSStringEncodingErrorKey;<br>	FOUNDATION_EXPORT NSErrorUserInfoKey&lt;NSURL&gt;    const NSURLErrorKey;<br>	FOUNDATION_EXPORT NSErrorUserInfoKey&lt;NSString&gt; const NSFilePathErrorKey;<br></p><p>This could provide a more typesafe API, without the need for typed accessors in each SDK overlay.<br></p><p>	func userInfoValue&lt;Value&gt;(forKey: NSError.UserInfoKey&lt;Value&gt;) -&gt; Value?<br></p><p>The following comment is incorrect, AFAIK. The `helpAnchor` is the name attribute of a HTML anchor element.<br></p><p>	/// A localized message providing &quot;help&quot; text if the user requests help.<br>	var helpAnchor: String? { get }<br></p><p>Also in the LocalizedError protocol, should the `errorDescription` property return a non-optional String, to match the NSError API?<br></p><p>Should there be an API for non-localized errors? This is currently available in &lt;CoreFoundation/CFError.h&gt; using kCFErrorDescriptionKey.<br></p><p>I agree with Brent&#39;s feedback of the RecoverableError protocol.<br>&lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/22485/focus=22793&gt;<br>* It reminds me of the deprecated UIActionSheetDelegate, which also used an Int index to identify an action.<br>* The newer UIAlertController uses UIAlertAction objects, similar to Brent&#39;s ErrorRecoveryOption protocol.<br></p><p>If error recovery and help anchors are only available in macOS, should there be conditional #if os(macOS) blocks?<br></p><p>Is the `errorDomain` property of CustomNSError allowed to vary its result? For example:<br>* an SQLite error &lt;https://www.sqlite.org/rescode.html&gt; could return the &quot;primary result code&quot; name.<br>* an HRESULT &lt;https://en.wikipedia.org/wiki/HRESULT&gt; wrapper could return the FACILITY name.<br>Would a varying domain affect the registered setUserInfoValueProvider(forDomain:provider:) callback?<br></p><p>-- Ben<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Review] SE-0112: Improved NSError Bridging</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>July  5, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jul 4, 2016, at 10:15 PM, Ben Rimmington &lt;me at benrimmington.com&gt; wrote:<br>&gt; <br>&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0112-nserror-bridging.md&gt;<br>&gt; <br>&gt; If &lt;Foundation/NSError.h&gt; uses NS_EXTENSIBLE_STRING_ENUM for `domain` names and `userInfo` keys, would a generic type (cf. DispatchSpecificKey) also be possible?<br>&gt; <br>&gt; 	FOUNDATION_EXPORT NSErrorUserInfoKey&lt;NSNumber&gt; const NSStringEncodingErrorKey;<br>&gt; 	FOUNDATION_EXPORT NSErrorUserInfoKey&lt;NSURL&gt;    const NSURLErrorKey;<br>&gt; 	FOUNDATION_EXPORT NSErrorUserInfoKey&lt;NSString&gt; const NSFilePathErrorKey;<br>&gt; <br>&gt; This could provide a more typesafe API, without the need for typed accessors in each SDK overlay.<br>&gt; <br>&gt; 	func userInfoValue&lt;Value&gt;(forKey: NSError.UserInfoKey&lt;Value&gt;) -&gt; Value?<br></p><p>This is complicated by the fact that userInfo keys don’t have to be strings, so making the type stronger may not be possible. <br></p><p>That technicality aside, why? While NSError itself is centered around userInfo, Swift errors are not: they’re strongly-typed values for which one would expect to have accessors to get additional information about the errors. One would not define new userInfo keys in Swift nor (directly) define new error domain strings, except to refer to those errors from Objective-C code. In many ways, that’s the goal of this proposal: to take away the need for Swift programmers to think about NSError’s domain/code/userInfo by providing type-safe, easy-to-use APIs. In that context, it seems unfortunate to restyle something that Swift programmers shouldn’t have to use.<br></p><p>&gt; <br>&gt; The following comment is incorrect, AFAIK. The `helpAnchor` is the name attribute of a HTML anchor element.<br>&gt; <br>&gt; 	/// A localized message providing &quot;help&quot; text if the user requests help.<br>&gt; 	var helpAnchor: String? { get }<br></p><p>Apple’s documentation says:<br></p><p>NSHelpAnchorErrorKey<br>The corresponding value is an NSString containing the localized help corresponding to the help button. See helpAnchor &lt;https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSError_Class/#//apple_ref/occ/instp/NSError/helpAnchor&gt; for more information.<br></p><p>Available in OS X v10.6 and later.<br></p><p>&gt; <br>&gt; Also in the LocalizedError protocol, should the `errorDescription` property return a non-optional String, to match the NSError API?<br></p><p>No; one can omit the errorDescription property (which is tantamount to omitting the NSLocalizedDescriptionKey value in NSError’s userInfo) and Cocoa will create a default.<br></p><p>&gt; <br>&gt; Should there be an API for non-localized errors? This is currently available in &lt;CoreFoundation/CFError.h&gt; using kCFErrorDescriptionKey.<br></p><p>IMO, no. Leave it at the defaults or do it correctly.<br></p><p>&gt; <br>&gt; If error recovery and help anchors are only available in macOS, should there be conditional #if os(macOS) blocks?<br></p><p>Practically speaking, this <br></p><p>&gt; <br>&gt; Is the `errorDomain` property of CustomNSError allowed to vary its result? For example:<br>&gt; * an SQLite error &lt;https://www.sqlite.org/rescode.html&gt; could return the &quot;primary result code&quot; name.<br>&gt; * an HRESULT &lt;https://en.wikipedia.org/wiki/HRESULT&gt; wrapper could return the FACILITY name.<br>&gt; Would a varying domain affect the registered setUserInfoValueProvider(forDomain:provider:) callback?<br></p><p>‘errorDomain’ must not vary, because it effectively identifies the Swift type.<br></p><p>In fact, it should be ‘static’. I’ll fix that, thanks!<br></p><p>	- Doug<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160705/d331f2d4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bdd257c9369fb68e1d06923d10ff789e?s=50"></div><header><strong>[Review] SE-0112: Improved NSError Bridging</strong> from <string>Ben Rimmington</string> &lt;me at benrimmington.com&gt;<p>July  6, 2016 at 06:00:00am</p></header><div class="content"><p>&gt; On 5 Jul 2016, at 21:41, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; The following comment is incorrect, AFAIK. The `helpAnchor` is the name attribute of a HTML anchor element.<br>&gt;&gt; <br>&gt;&gt; 	/// A localized message providing &quot;help&quot; text if the user requests help.<br>&gt;&gt; 	var helpAnchor: String? { get }<br>&gt; <br>&gt; Apple’s documentation says:<br>&gt; <br>&gt; NSHelpAnchorErrorKey<br>&gt; The corresponding value is an NSString containing the localized help corresponding to the help button. See helpAnchor &lt;https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSError_Class/#//apple_ref/occ/instp/NSError/helpAnchor&gt; for more information.<br>&gt; <br></p><p>A `helpAnchor` in AppKit is the name of an HTML anchor element:<br></p><p>AppKit &gt; NSPrintPanel &gt; helpAnchor<br>&lt;https://developer.apple.com/reference/appkit/nsprintpanel/1490537-helpanchor&gt;<br></p><p>AppKit &gt; NSHelpManager &gt; openHelpAnchor(_:inBook:)<br>&lt;https://developer.apple.com/reference/appkit/nshelpmanager/1500908-openhelpanchor&gt;<br></p><p>Apple Help Programming Guide &gt; Authoring Apple Help &gt; Indexing Your Help Book &gt; Setting Anchors<br>&lt;https://developer.apple.com/library/mac/documentation/Carbon/Conceptual/ProvidingUserAssitAppleHelp/authoring_help/authoring_help_book.html#//apple_ref/doc/uid/TP30000903-CH206-CHDFBEHF&gt;<br></p><p>-- Ben<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160706/80069469/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Review] SE-0112: Improved NSError Bridging</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>July  6, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jul 5, 2016, at 10:35 PM, Ben Rimmington &lt;me at benrimmington.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 5 Jul 2016, at 21:41, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; The following comment is incorrect, AFAIK. The `helpAnchor` is the name attribute of a HTML anchor element.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	/// A localized message providing &quot;help&quot; text if the user requests help.<br>&gt;&gt;&gt; 	var helpAnchor: String? { get }<br>&gt;&gt; <br>&gt;&gt; Apple’s documentation says:<br>&gt;&gt; <br>&gt;&gt; NSHelpAnchorErrorKey<br>&gt;&gt; The corresponding value is an NSString containing the localized help corresponding to the help button. See helpAnchor &lt;https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSError_Class/#//apple_ref/occ/instp/NSError/helpAnchor&gt; for more information.<br>&gt;&gt; <br>&gt; <br>&gt; A `helpAnchor` in AppKit is the name of an HTML anchor element:<br>&gt; <br>&gt; AppKit &gt; NSPrintPanel &gt; helpAnchor<br>&gt; &lt;https://developer.apple.com/reference/appkit/nsprintpanel/1490537-helpanchor &lt;https://developer.apple.com/reference/appkit/nsprintpanel/1490537-helpanchor&gt;&gt;<br>&gt; <br>&gt; AppKit &gt; NSHelpManager &gt; openHelpAnchor(_:inBook:)<br>&gt; &lt;https://developer.apple.com/reference/appkit/nshelpmanager/1500908-openhelpanchor &lt;https://developer.apple.com/reference/appkit/nshelpmanager/1500908-openhelpanchor&gt;&gt;<br>&gt; <br>&gt; Apple Help Programming Guide &gt; Authoring Apple Help &gt; Indexing Your Help Book &gt; Setting Anchors<br>&gt; &lt;https://developer.apple.com/library/mac/documentation/Carbon/Conceptual/ProvidingUserAssitAppleHelp/authoring_help/authoring_help_book.html#//apple_ref/doc/uid/TP30000903-CH206-CHDFBEHF &lt;https://developer.apple.com/library/mac/documentation/Carbon/Conceptual/ProvidingUserAssitAppleHelp/authoring_help/authoring_help_book.html#//apple_ref/doc/uid/TP30000903-CH206-CHDFBEHF&gt;&gt;<br></p><p>The relevant “helpAnchor” is from the NSError reference documentation:<br></p><p>	https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSError_Class/#//apple_ref/occ/instp/NSError/helpAnchor &lt;https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSError_Class/#//apple_ref/occ/instp/NSError/helpAnchor&gt;<br></p><p>which says:<br></p><p>A string to display in response to an alert panel help anchor button being pressed. (read-only)<br></p><p>Declaration<br>SWIFT<br>var helpAnchor: String &lt;https://developer.apple.com/library/mac/documentation/Swift/Reference/Swift_String_Structure/index.html#//apple_ref/swift/struct/s:SS&gt;? { get }<br>OBJECTIVE-C<br>@property(readonly, copy) NSString  &lt;https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSString_Class/index.html#//apple_ref/doc/c_ref/NSString&gt;*helpAnchor<br>Discussion<br>The object in the user info dictionary for the key NSHelpAnchorErrorKey &lt;https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSError_Class/#//apple_ref/c/data/NSHelpAnchorErrorKey&gt;. If the user info dictionary doesn’t contain a value for NSHelpAnchorErrorKey &lt;https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSError_Class/#//apple_ref/c/data/NSHelpAnchorErrorKey&gt;, this property is nil.<br></p><p>If this property is non-nil for an error being presented by alertWithError: &lt;https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ApplicationKit/Classes/NSAlert_Class/index.html#//apple_ref/occ/clm/NSAlert/alertWithError:&gt;, the alert panel will include a help anchor button that can display this string.<br></p><p>Availability<br>Available in OS X v10.6 and later.<br></p><p>	- Doug<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160706/c80a25a0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bdd257c9369fb68e1d06923d10ff789e?s=50"></div><header><strong>[Review] SE-0112: Improved NSError Bridging</strong> from <string>Ben Rimmington</string> &lt;me at benrimmington.com&gt;<p>July  7, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On 6 Jul 2016, at 18:09, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Jul 5, 2016, at 10:35 PM, Ben Rimmington &lt;me at benrimmington.com &lt;mailto:me at benrimmington.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On 5 Jul 2016, at 21:41, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The following comment is incorrect, AFAIK. The `helpAnchor` is the name attribute of a HTML anchor element.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	/// A localized message providing &quot;help&quot; text if the user requests help.<br>&gt;&gt;&gt;&gt; 	var helpAnchor: String? { get }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Apple’s documentation says:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; NSHelpAnchorErrorKey<br>&gt;&gt;&gt; The corresponding value is an NSString containing the localized help corresponding to the help button. See helpAnchor &lt;https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSError_Class/#//apple_ref/occ/instp/NSError/helpAnchor&gt; for more information.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; A `helpAnchor` in AppKit is the name of an HTML anchor element:<br>&gt;&gt; <br>&gt;&gt; AppKit &gt; NSPrintPanel &gt; helpAnchor<br>&gt;&gt; &lt;https://developer.apple.com/reference/appkit/nsprintpanel/1490537-helpanchor &lt;https://developer.apple.com/reference/appkit/nsprintpanel/1490537-helpanchor&gt;&gt;<br>&gt;&gt; <br>&gt;&gt; AppKit &gt; NSHelpManager &gt; openHelpAnchor(_:inBook:)<br>&gt;&gt; &lt;https://developer.apple.com/reference/appkit/nshelpmanager/1500908-openhelpanchor &lt;https://developer.apple.com/reference/appkit/nshelpmanager/1500908-openhelpanchor&gt;&gt;<br>&gt;&gt; <br>&gt;&gt; Apple Help Programming Guide &gt; Authoring Apple Help &gt; Indexing Your Help Book &gt; Setting Anchors<br>&gt;&gt; &lt;https://developer.apple.com/library/mac/documentation/Carbon/Conceptual/ProvidingUserAssitAppleHelp/authoring_help/authoring_help_book.html#//apple_ref/doc/uid/TP30000903-CH206-CHDFBEHF &lt;https://developer.apple.com/library/mac/documentation/Carbon/Conceptual/ProvidingUserAssitAppleHelp/authoring_help/authoring_help_book.html#//apple_ref/doc/uid/TP30000903-CH206-CHDFBEHF&gt;&gt;<br>&gt; <br>&gt; The relevant “helpAnchor” is from the NSError reference documentation:<br>&gt; <br>&gt; 	https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSError_Class/#//apple_ref/occ/instp/NSError/helpAnchor &lt;https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSError_Class/#//apple_ref/occ/instp/NSError/helpAnchor&gt;<br>&gt; <br>&gt; which says:<br>&gt; <br>&gt; A string to display in response to an alert panel help anchor button being pressed. (read-only)<br>&gt; <br>&gt; Declaration<br>&gt; SWIFT<br>&gt; var helpAnchor: String &lt;https://developer.apple.com/library/mac/documentation/Swift/Reference/Swift_String_Structure/index.html#//apple_ref/swift/struct/s:SS&gt;? { get }<br>&gt; OBJECTIVE-C<br>&gt; @property(readonly, copy) NSString  &lt;https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSString_Class/index.html#//apple_ref/doc/c_ref/NSString&gt;*helpAnchor<br>&gt; Discussion<br>&gt; The object in the user info dictionary for the key NSHelpAnchorErrorKey &lt;https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSError_Class/#//apple_ref/c/data/NSHelpAnchorErrorKey&gt;. If the user info dictionary doesn’t contain a value for NSHelpAnchorErrorKey &lt;https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSError_Class/#//apple_ref/c/data/NSHelpAnchorErrorKey&gt;, this property is nil.<br>&gt; <br>&gt; If this property is non-nil for an error being presented by alertWithError: &lt;https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ApplicationKit/Classes/NSAlert_Class/index.html#//apple_ref/occ/clm/NSAlert/alertWithError:&gt;, the alert panel will include a help anchor button that can display this string.<br>&gt; <br>&gt; Availability<br>&gt; Available in OS X v10.6 and later.<br>&gt; <br>&gt; 	- Doug<br>&gt; <br></p><p>The documentation on NSError help anchors is incorrect.<br></p><p>	&lt;rdar://problem/27208074&gt;<br></p><p>I&#39;ve tested this with a document-based Cocoa application. In the NSDocument subclass, I modified the template as follows:<br></p><p>	override func data(ofType typeName: String) throws -&gt; Data {<br>	    throw NSError(domain: NSOSStatusErrorDomain, code: unimpErr, userInfo: [NSHelpAnchorErrorKey: &quot;ibks5f526382&quot;])<br>	}<br></p><p>	override func read(from data: Data, ofType typeName: String) throws {<br>	    throw NSError(domain: NSOSStatusErrorDomain, code: unimpErr, userInfo: [NSHelpAnchorErrorKey: &quot;pbhlp3714a9d&quot;])<br>	}<br></p><p>Those help anchors were copied from the following file (in macOS 10.11.5):<br>&lt;file:/Library/Documentation/Help/MacHelp.help/Contents/Resources/en.lproj/navigation.json&gt;<br></p><p>When I try to open or save a document, an NSAlert with a help button is presented. Clicking on that help button shows the expected help page:<br></p><p>	{&quot;name&quot;:&quot;Read books in iBooks&quot;,&quot;href&quot;:&quot;help:anchor=&#39;ibks5f526382&#39; bookID=&#39;com.apple.iBooksX.help&#39;&quot;}<br></p><p>	{&quot;name&quot;:&quot;Take a Photo Booth photo&quot;,&quot;href&quot;:&quot;help:anchor=&#39;pbhlp3714a9d&#39; bookID=&#39;com.apple.PhotoBooth.help&#39;&quot;}<br></p><p>But if I use a normal word or phrase with NSHelpAnchorErrorKey, the Mac Help window displays:<br></p><p>	The selected topic is currently unavailable.<br>	The topic you were trying to view could not be found.<br></p><p>-- Ben<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160707/a93bc8c3/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bdd257c9369fb68e1d06923d10ff789e?s=50"></div><header><strong>[Review] SE-0112: Improved NSError Bridging</strong> from <string>Ben Rimmington</string> &lt;me at benrimmington.com&gt;<p>July  6, 2016 at 01:00:00am</p></header><div class="content"><p>&lt;https://github.com/apple/swift-evolution/blob/master/proposals/0112-nserror-bridging.md&gt;<br></p><p>The new protocols could be combined into a single CustomNSError protocol.<br>This would mirror the NSError class APIs, which are being customized.<br></p><p>Instead of using NSError.setUserInfoValueProvider(forDomain:provider:) <br>could you wrap the CustomNSError value inside an NSError subclass?<br></p><p>	class _CustomNSError: NSError {<br></p><p>	    private let _error: CustomNSError<br></p><p>	    init(_error: CustomNSError) {<br>	        self._error = _error<br>	        super.init(<br>	            domain:   _error.dynamicType.errorDomain,<br>	            code:     _error.errorCode,<br>	            userInfo: _error.errorUserInfo)<br>	    }<br></p><p>	    override var localizedDescription: String {<br>	        return _error.errorDescription ?? super.localizedDescription<br>	    }<br></p><p>	    override var localizedFailureReason: String? {<br>	        return _error.failureReason ?? super.localizedFailureReason<br>	    }<br></p><p>	    override var localizedRecoverySuggestion: String? {<br>	        return _error.recoverySuggestion ?? super.localizedRecoverySuggestion<br>	    }<br></p><p>	    override var localizedRecoveryOptions: [String]? {<br>	        return _error.recoveryOptions ?? super.localizedRecoveryOptions<br>	    }<br></p><p>	    override var recoveryAttempter: AnyObject? {<br>	        if _error.recoveryOptions != nil {<br>	            return _NSErrorRecoveryAttempter(error: _error)<br>	        } else {<br>	            return super.recoveryAttempter<br>	        }<br>	    }<br></p><p>	    override var helpAnchor: String? {<br>	        return _error.helpAnchor ?? super.helpAnchor<br>	    }<br>	}<br></p><p>-- Ben<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Review] SE-0112: Improved NSError Bridging</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>July  5, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jul 5, 2016, at 5:00 PM, Ben Rimmington &lt;me at benrimmington.com&gt; wrote:<br>&gt; <br>&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0112-nserror-bridging.md&gt;<br>&gt; <br>&gt; The new protocols could be combined into a single CustomNSError protocol.<br>&gt; This would mirror the NSError class APIs, which are being customized.<br></p><p>Why is that good? The two primary protocols—LocalizedError and RecoverableError—provide a more focused, easy-to-understand experience for opting in to specific behavior. CustomNSError is a fallback for “I want to do something special with the generated NSError”.<br></p><p>&gt; <br>&gt; Instead of using NSError.setUserInfoValueProvider(forDomain:provider:) <br>&gt; could you wrap the CustomNSError value inside an NSError subclass?<br>&gt; <br>&gt; 	class _CustomNSError: NSError {<br>&gt; <br>&gt; 	    private let _error: CustomNSError<br>&gt; <br>&gt; 	    init(_error: CustomNSError) {<br>&gt; 	        self._error = _error<br>&gt; 	        super.init(<br>&gt; 	            domain:   _error.dynamicType.errorDomain,<br>&gt; 	            code:     _error.errorCode,<br>&gt; 	            userInfo: _error.errorUserInfo)<br>&gt; 	    }<br>&gt; <br>&gt; 	    override var localizedDescription: String {<br>&gt; 	        return _error.errorDescription ?? super.localizedDescription<br>&gt; 	    }<br>&gt; <br>&gt; 	    override var localizedFailureReason: String? {<br>&gt; 	        return _error.failureReason ?? super.localizedFailureReason<br>&gt; 	    }<br>&gt; <br>&gt; 	    override var localizedRecoverySuggestion: String? {<br>&gt; 	        return _error.recoverySuggestion ?? super.localizedRecoverySuggestion<br>&gt; 	    }<br>&gt; <br>&gt; 	    override var localizedRecoveryOptions: [String]? {<br>&gt; 	        return _error.recoveryOptions ?? super.localizedRecoveryOptions<br>&gt; 	    }<br>&gt; <br>&gt; 	    override var recoveryAttempter: AnyObject? {<br>&gt; 	        if _error.recoveryOptions != nil {<br>&gt; 	            return _NSErrorRecoveryAttempter(error: _error)<br>&gt; 	        } else {<br>&gt; 	            return super.recoveryAttempter<br>&gt; 	        }<br>&gt; 	    }<br>&gt; <br>&gt; 	    override var helpAnchor: String? {<br>&gt; 	        return _error.helpAnchor ?? super.helpAnchor<br>&gt; 	    }<br>&gt; 	}<br></p><p>We could, but why? This is precisely what user-info value providers were designed for.<br></p><p>	- Doug<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bdd257c9369fb68e1d06923d10ff789e?s=50"></div><header><strong>[Review] SE-0112: Improved NSError Bridging</strong> from <string>Ben Rimmington</string> &lt;me at benrimmington.com&gt;<p>July  6, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; On 6 Jul 2016, at 01:02, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Jul 5, 2016, at 5:00 PM, Ben Rimmington &lt;me at benrimmington.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0112-nserror-bridging.md&gt;<br>&gt;&gt; <br>&gt;&gt; The new protocols could be combined into a single CustomNSError protocol.<br>&gt;&gt; This would mirror the NSError class APIs, which are being customized.<br>&gt; <br>&gt; Why is that good? The two primary protocols—LocalizedError and RecoverableError—provide a more focused, easy-to-understand experience for opting in to specific behavior. CustomNSError is a fallback for “I want to do something special with the generated NSError”.<br></p><p>You wrote previously:<br>&quot;To a close approximation, there are no use sites of these protocols.&quot;<br>&lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/22485/focus=22919&gt;<br></p><p>If the Printable protocol was renamed to CustomStringConvertible to discourage use sites, then having a single CustomNSError protocol should have a similar effect. The protocol will be as easy-to-understand as the NSError class itself. If there are default implementations for all requirements, a conforming type can still opt into specific behavior.<br></p><p>&gt;&gt; Instead of using NSError.setUserInfoValueProvider(forDomain:provider:) <br>&gt;&gt; could you wrap the CustomNSError value inside an NSError subclass?<br>&gt;&gt; <br>&gt;&gt; 	class _CustomNSError: NSError {<br>&gt;&gt; <br>&gt;&gt; 	    private let _error: CustomNSError<br>&gt;&gt; <br>&gt;&gt; 	    init(_error: CustomNSError) {<br>&gt;&gt; 	        self._error = _error<br>&gt;&gt; 	        super.init(<br>&gt;&gt; 	            domain:   _error.dynamicType.errorDomain,<br>&gt;&gt; 	            code:     _error.errorCode,<br>&gt;&gt; 	            userInfo: _error.errorUserInfo)<br>&gt;&gt; 	    }<br>&gt;&gt; <br>&gt;&gt; 	    override var localizedDescription: String {<br>&gt;&gt; 	        return _error.errorDescription ?? super.localizedDescription<br>&gt;&gt; 	    }<br>&gt;&gt; <br>&gt;&gt; 	    override var localizedFailureReason: String? {<br>&gt;&gt; 	        return _error.failureReason ?? super.localizedFailureReason<br>&gt;&gt; 	    }<br>&gt;&gt; <br>&gt;&gt; 	    override var localizedRecoverySuggestion: String? {<br>&gt;&gt; 	        return _error.recoverySuggestion ?? super.localizedRecoverySuggestion<br>&gt;&gt; 	    }<br>&gt;&gt; <br>&gt;&gt; 	    override var localizedRecoveryOptions: [String]? {<br>&gt;&gt; 	        return _error.recoveryOptions ?? super.localizedRecoveryOptions<br>&gt;&gt; 	    }<br>&gt;&gt; <br>&gt;&gt; 	    override var recoveryAttempter: AnyObject? {<br>&gt;&gt; 	        if _error.recoveryOptions != nil {<br>&gt;&gt; 	            return _NSErrorRecoveryAttempter(error: _error)<br>&gt;&gt; 	        } else {<br>&gt;&gt; 	            return super.recoveryAttempter<br>&gt;&gt; 	        }<br>&gt;&gt; 	    }<br>&gt;&gt; <br>&gt;&gt; 	    override var helpAnchor: String? {<br>&gt;&gt; 	        return _error.helpAnchor ?? super.helpAnchor<br>&gt;&gt; 	    }<br>&gt;&gt; 	}<br>&gt; <br>&gt; We could, but why? This is precisely what user-info value providers were designed for.<br></p><p>If the NSError.setUserInfoValueProvider(forDomain:provider:) method isn&#39;t available in all supported target platforms, an NSError subclass seems to be the simpler option.<br></p><p>-- Ben<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Review] SE-0112: Improved NSError Bridging</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>July  5, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jul 5, 2016, at 5:54 PM, Ben Rimmington &lt;me at benrimmington.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On 6 Jul 2016, at 01:02, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 5, 2016, at 5:00 PM, Ben Rimmington &lt;me at benrimmington.com &lt;mailto:me at benrimmington.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0112-nserror-bridging.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0112-nserror-bridging.md&gt;&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The new protocols could be combined into a single CustomNSError protocol.<br>&gt;&gt;&gt; This would mirror the NSError class APIs, which are being customized.<br>&gt;&gt; <br>&gt;&gt; Why is that good? The two primary protocols—LocalizedError and RecoverableError—provide a more focused, easy-to-understand experience for opting in to specific behavior. CustomNSError is a fallback for “I want to do something special with the generated NSError”.<br>&gt; <br>&gt; You wrote previously:<br>&gt; &quot;To a close approximation, there are no use sites of these protocols.&quot;<br>&gt; &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/22485/focus=22919 &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/22485/focus=22919&gt;&gt;<br>&gt; <br>&gt; If the Printable protocol was renamed to CustomStringConvertible to discourage use sites, then having a single CustomNSError protocol should have a similar effect.<br></p><p>We don’t need to discourage use sites; I just don’t expect them to be common because it’s the library that will be querying these conformances. Regardless, we shouldn’t contort a protocol design to discourage usage; we should make it clear what conforming to the protocol implies.<br></p><p>&gt; The protocol will be as easy-to-understand as the NSError class itself. If there are default implementations for all requirements, a conforming type can still opt into specific behavior.<br></p><p>“As easy-to-understand as the NSError class” is not the goal here. We want to do better, and that means detangling the various different things that NSError puts together.<br></p><p>With this proposal, you define an error type like this:<br></p><p>enum HomeworkError : ErrorProtocol {<br>  case forgotten<br>  case lost<br>  case dogAteIt<br>}<br></p><p>To give it a nice, localized error message (or other localized information), you conform to LocalizedError:<br></p><p>extension HomeworkError : LocalizedError {<br>  var errorDescription: String? {<br>    switch self {<br>    case .forgotten: return NSLocalizedString(&quot;I forgot it&quot;)<br>    case .lost: return NSLocalizedString(&quot;I lost it&quot;)<br>    case .dogAteIt: return NSLocalizedString(&quot;The dog ate it&quot;)<br>    }<br>  }<br>}<br></p><p>and if you want to implement recovery attempts for your error, you conform to RecoverableError:<br></p><p>extension HomeworkError : RecoverableError {<br>  // implementation here<br>}<br></p><p>You can catch these errors with “catch let error as HomeworkError”, or “catch HomeworkError.forgotten”, or whatever.<br></p><p>Nowhere in any of that did I mention NSError, or error domains, or codes, or user-info dictionaries. You shouldn’t need them with this model, at all. NSError is bridged away completely, and is an implementation detail of Objective-C interoperability. CustomNSError, and references to the NSError type, is an escape hatch so that one can get precise control over the interoperability with NSError for those (hopefully rare) cases where the Swift error-handling model can’t express something that NSError can.<br></p><p><br>&gt; <br>&gt;&gt;&gt; Instead of using NSError.setUserInfoValueProvider(forDomain:provider:) <br>&gt;&gt;&gt; could you wrap the CustomNSError value inside an NSError subclass?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	class _CustomNSError: NSError {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	    private let _error: CustomNSError<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	    init(_error: CustomNSError) {<br>&gt;&gt;&gt; 	        self._error = _error<br>&gt;&gt;&gt; 	        super.init(<br>&gt;&gt;&gt; 	            domain:   _error.dynamicType.errorDomain,<br>&gt;&gt;&gt; 	            code:     _error.errorCode,<br>&gt;&gt;&gt; 	            userInfo: _error.errorUserInfo)<br>&gt;&gt;&gt; 	    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	    override var localizedDescription: String {<br>&gt;&gt;&gt; 	        return _error.errorDescription ?? super.localizedDescription<br>&gt;&gt;&gt; 	    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	    override var localizedFailureReason: String? {<br>&gt;&gt;&gt; 	        return _error.failureReason ?? super.localizedFailureReason<br>&gt;&gt;&gt; 	    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	    override var localizedRecoverySuggestion: String? {<br>&gt;&gt;&gt; 	        return _error.recoverySuggestion ?? super.localizedRecoverySuggestion<br>&gt;&gt;&gt; 	    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	    override var localizedRecoveryOptions: [String]? {<br>&gt;&gt;&gt; 	        return _error.recoveryOptions ?? super.localizedRecoveryOptions<br>&gt;&gt;&gt; 	    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	    override var recoveryAttempter: AnyObject? {<br>&gt;&gt;&gt; 	        if _error.recoveryOptions != nil {<br>&gt;&gt;&gt; 	            return _NSErrorRecoveryAttempter(error: _error)<br>&gt;&gt;&gt; 	        } else {<br>&gt;&gt;&gt; 	            return super.recoveryAttempter<br>&gt;&gt;&gt; 	        }<br>&gt;&gt;&gt; 	    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	    override var helpAnchor: String? {<br>&gt;&gt;&gt; 	        return _error.helpAnchor ?? super.helpAnchor<br>&gt;&gt;&gt; 	    }<br>&gt;&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; We could, but why? This is precisely what user-info value providers were designed for.<br>&gt; <br>&gt; If the NSError.setUserInfoValueProvider(forDomain:provider:) method isn&#39;t available in all supported target platforms, an NSError subclass seems to be the simpler option.<br></p><p>When/where it is available, NSError.setUserInfoValueProvider(forDomain:provider:) is the solution recommended by Cocoa as the best way to lazily populate the userInfo dictionary, so it makes sense for us to use that mechanism. Sure, we need to implement a fallback, but the use of that fallback will go away at some point and we’ll be back to one implementation.<br></p><p>	- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160705/ce2194ff/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
