<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0a88a27755600d9f1c1ce00e3c209a38?s=50"></div><header><strong>[Pitch] Allow nested protocol declarations</strong> from <string>Brad Hilton</string> &lt;brad.hilton.nw at gmail.com&gt;<p>April 28, 2016 at 11:00:00am</p></header><div class="content"><p>Type nesting allows some convenient and straightforward semantics that we see inside the Swift standard library such as views on String like String.CharacterView, String.UnicodeScalarView, etc. However a protocol cannot be nested in a type and gives a non-obvious error that the “Declaration is only valid at file scope.” Just as other nested types allow proper contextual scoping, a nested protocol could make a lot sense for a number of patterns. For example, there are many “Delegate” protocols throughout the Cocoa frameworks. Here’s a controller/delegate pattern before and after type nesting:<br></p><p>// Without type nesting<br></p><p>protocol MyControllerDelegate : class {<br>    <br>}<br></p><p>class MyController {<br>    <br>    weak var delegate: MyControllerDelegate?<br>    <br>}<br></p><p>// With type nesting<br></p><p>class MyController {<br>    <br>    weak var delegate: Delegate?<br>    <br>    protocol Delegate : class {<br>        <br>    }<br>    <br>}<br></p><p>Though the change is mostly semantics, it does allow an explicit association between My Controller and the Delegate instead of only a named association. It also cleans up the module name space like other nested types and makes associated protocols more discoverable in my opinion. <br></p><p>I’d love to hear everyone’s thoughts.<br></p><p>Brad Hilton<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160428/26b023f9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Pitch] Allow nested protocol declarations</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>April 28, 2016 at 05:00:00pm</p></header><div class="content"><p>In your example, other types would still be able to conform to Delegate, by referencing it as &quot;MyController.Delegate”, right? If so, I’m +1.<br></p><p>I’d imagine that it might also simplify the compiler a bit if we got rid of restrictions on where nested types are allowed to be declared.<br></p><p>- Dave Sweeris<br></p><p>&gt; On Apr 28, 2016, at 12:15 PM, Brad Hilton via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Type nesting allows some convenient and straightforward semantics that we see inside the Swift standard library such as views on String like String.CharacterView, String.UnicodeScalarView, etc. However a protocol cannot be nested in a type and gives a non-obvious error that the “Declaration is only valid at file scope.” Just as other nested types allow proper contextual scoping, a nested protocol could make a lot sense for a number of patterns. For example, there are many “Delegate” protocols throughout the Cocoa frameworks. Here’s a controller/delegate pattern before and after type nesting:<br>&gt; <br>&gt; // Without type nesting<br>&gt; <br>&gt; protocol MyControllerDelegate : class {<br>&gt;     <br>&gt; }<br>&gt; <br>&gt; class MyController {<br>&gt;     <br>&gt;     weak var delegate: MyControllerDelegate?<br>&gt;     <br>&gt; }<br>&gt; <br>&gt; // With type nesting<br>&gt; <br>&gt; class MyController {<br>&gt;     <br>&gt;     weak var delegate: Delegate?<br>&gt;     <br>&gt;     protocol Delegate : class {<br>&gt;         <br>&gt;     }<br>&gt;     <br>&gt; }<br>&gt; <br>&gt; Though the change is mostly semantics, it does allow an explicit association between My Controller and the Delegate instead of only a named association. It also cleans up the module name space like other nested types and makes associated protocols more discoverable in my opinion. <br>&gt; <br>&gt; I’d love to hear everyone’s thoughts.<br>&gt; <br>&gt; Brad Hilton<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160428/50c0eda7/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>[Pitch] Allow nested protocol declarations</strong> from <string>Michael Peternell</string> &lt;michael.peternell at gmx.at&gt;<p>April 29, 2016 at 12:00:00am</p></header><div class="content"><p>I think that would be a good feature.<br></p><p>&gt; Am 28.04.2016 um 19:15 schrieb Brad Hilton via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Type nesting allows some convenient and straightforward semantics that we see inside the Swift standard library such as views on String like String.CharacterView, String.UnicodeScalarView, etc. However a protocol cannot be nested in a type and gives a non-obvious error that the “Declaration is only valid at file scope.” Just as other nested types allow proper contextual scoping, a nested protocol could make a lot sense for a number of patterns. For example, there are many “Delegate” protocols throughout the Cocoa frameworks. Here’s a controller/delegate pattern before and after type nesting:<br>&gt; <br>&gt; // Without type nesting<br>&gt; <br>&gt; protocol MyControllerDelegate : class {<br>&gt;     <br>&gt; }<br>&gt; <br>&gt; class MyController {<br>&gt;     <br>&gt;     weak var delegate: MyControllerDelegate?<br>&gt;     <br>&gt; }<br>&gt; <br>&gt; // With type nesting<br>&gt; <br>&gt; class MyController {<br>&gt;     <br>&gt;     weak var delegate: Delegate?<br>&gt;     <br>&gt;     protocol Delegate : class {<br>&gt;         <br>&gt;     }<br>&gt;     <br>&gt; }<br>&gt; <br>&gt; Though the change is mostly semantics, it does allow an explicit association between My Controller and the Delegate instead of only a named association. It also cleans up the module name space like other nested types and makes associated protocols more discoverable in my opinion. <br>&gt; <br>&gt; I’d love to hear everyone’s thoughts.<br>&gt; <br>&gt; Brad Hilton<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Pitch] Allow nested protocol declarations</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>April 29, 2016 at 08:00:00am</p></header><div class="content"><p>+1 very handy to associate types together<br></p><p>On Friday, 29 April 2016, Michael Peternell via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I think that would be a good feature.<br>&gt;<br>&gt; &gt; Am 28.04.2016 um 19:15 schrieb Brad Hilton via swift-evolution &lt;<br>&gt; swift-evolution at swift.org &lt;javascript:;&gt;&gt;:<br>&gt; &gt;<br>&gt; &gt; Type nesting allows some convenient and straightforward semantics that<br>&gt; we see inside the Swift standard library such as views on String like<br>&gt; String.CharacterView, String.UnicodeScalarView, etc. However a protocol<br>&gt; cannot be nested in a type and gives a non-obvious error that the<br>&gt; “Declaration is only valid at file scope.” Just as other nested types allow<br>&gt; proper contextual scoping, a nested protocol could make a lot sense for a<br>&gt; number of patterns. For example, there are many “Delegate” protocols<br>&gt; throughout the Cocoa frameworks. Here’s a controller/delegate pattern<br>&gt; before and after type nesting:<br>&gt; &gt;<br>&gt; &gt; // Without type nesting<br>&gt; &gt;<br>&gt; &gt; protocol MyControllerDelegate : class {<br>&gt; &gt;<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; class MyController {<br>&gt; &gt;<br>&gt; &gt;     weak var delegate: MyControllerDelegate?<br>&gt; &gt;<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; // With type nesting<br>&gt; &gt;<br>&gt; &gt; class MyController {<br>&gt; &gt;<br>&gt; &gt;     weak var delegate: Delegate?<br>&gt; &gt;<br>&gt; &gt;     protocol Delegate : class {<br>&gt; &gt;<br>&gt; &gt;     }<br>&gt; &gt;<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; Though the change is mostly semantics, it does allow an explicit<br>&gt; association between My Controller and the Delegate instead of only a named<br>&gt; association. It also cleans up the module name space like other nested<br>&gt; types and makes associated protocols more discoverable in my opinion.<br>&gt; &gt;<br>&gt; &gt; I’d love to hear everyone’s thoughts.<br>&gt; &gt;<br>&gt; &gt; Brad Hilton<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br>-- <br>-- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160429/ab3e2a89/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/27ca9066ad05bd8aa9ec366115f3cd38?s=50"></div><header><strong>[Pitch] Allow nested protocol declarations</strong> from <string>Kurt Werle</string> &lt;kurt at circlew.org&gt;<p>April 28, 2016 at 07:00:00pm</p></header><div class="content"><p>As a ruby programmer, I have to admit that I&#39;ve tried to do this in Swift<br>several times before remembering again that it isn&#39;t possible.<br>+1<br></p><p>On Thu, Apr 28, 2016 at 3:44 PM, Howard Lovatt via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; +1 very handy to associate types together<br>&gt;<br>&gt;<br>&gt; On Friday, 29 April 2016, Michael Peternell via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; I think that would be a good feature.<br>&gt;&gt;<br>&gt;&gt; &gt; Am 28.04.2016 um 19:15 schrieb Brad Hilton via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt;:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Type nesting allows some convenient and straightforward semantics that<br>&gt;&gt; we see inside the Swift standard library such as views on String like<br>&gt;&gt; String.CharacterView, String.UnicodeScalarView, etc. However a protocol<br>&gt;&gt; cannot be nested in a type and gives a non-obvious error that the<br>&gt;&gt; “Declaration is only valid at file scope.” Just as other nested types allow<br>&gt;&gt; proper contextual scoping, a nested protocol could make a lot sense for a<br>&gt;&gt; number of patterns. For example, there are many “Delegate” protocols<br>&gt;&gt; throughout the Cocoa frameworks. Here’s a controller/delegate pattern<br>&gt;&gt; before and after type nesting:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; // Without type nesting<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; protocol MyControllerDelegate : class {<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; class MyController {<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;     weak var delegate: MyControllerDelegate?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; // With type nesting<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; class MyController {<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;     weak var delegate: Delegate?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;     protocol Delegate : class {<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;     }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Though the change is mostly semantics, it does allow an explicit<br>&gt;&gt; association between My Controller and the Delegate instead of only a named<br>&gt;&gt; association. It also cleans up the module name space like other nested<br>&gt;&gt; types and makes associated protocols more discoverable in my opinion.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I’d love to hear everyone’s thoughts.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Brad Hilton<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; -- Howard.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p><p><br>-- <br>kurt at CircleW.org<br>http://www.CircleW.org/kurt/<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160428/b86de21e/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e910871dda004717de19e83626308b5a?s=50"></div><header><strong>[Pitch] Allow nested protocol declarations</strong> from <string>Tony Allevato</string> &lt;allevato at google.com&gt;<p>April 28, 2016 at 10:00:00pm</p></header><div class="content"><p>+1, would love to see UIKit&#39;s (and other frameworks&#39;) delegates/datasources<br>nested like this one day.<br></p><p>It seems like there&#39;s nothing that should prevent nesting like this; it&#39;s<br>just going to produce a different mangled name.<br></p><p><br>On Thu, Apr 28, 2016 at 10:15 AM Brad Hilton via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Type nesting allows some convenient and straightforward semantics that we<br>&gt; see inside the Swift standard library such as views on String like<br>&gt; String.CharacterView, String.UnicodeScalarView, etc. However a protocol<br>&gt; cannot be nested in a type and gives a non-obvious error that the<br>&gt; “Declaration is only valid at file scope.” Just as other nested types allow<br>&gt; proper contextual scoping, a nested protocol could make a lot sense for a<br>&gt; number of patterns. For example, there are many “Delegate” protocols<br>&gt; throughout the Cocoa frameworks. Here’s a controller/delegate pattern<br>&gt; before and after type nesting:<br>&gt;<br>&gt; // Without type nesting<br>&gt;<br>&gt; protocol MyControllerDelegate : class {<br>&gt;<br>&gt;<br>&gt; }<br>&gt;<br>&gt; class MyController {<br>&gt;<br>&gt;<br>&gt;     weak var delegate: MyControllerDelegate?<br>&gt;<br>&gt;<br>&gt; }<br>&gt;<br>&gt; // With type nesting<br>&gt;<br>&gt; class MyController {<br>&gt;<br>&gt;<br>&gt;     weak var delegate: Delegate?<br>&gt;<br>&gt;<br>&gt;     protocol Delegate : class {<br>&gt;<br>&gt;<br>&gt;     }<br>&gt;<br>&gt;<br>&gt; }<br>&gt;<br>&gt; Though the change is mostly semantics, it does allow an explicit<br>&gt; association between My Controller and the Delegate instead of only a named<br>&gt; association. It also cleans up the module name space like other nested<br>&gt; types and makes associated protocols more discoverable in my opinion.<br>&gt;<br>&gt; I’d love to hear everyone’s thoughts.<br>&gt;<br>&gt; Brad Hilton<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160428/4077ec10/attachment-0001.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Pitch] Allow nested protocol declarations</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>April 28, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Apr 28, 2016, at 10:15 AM, Brad Hilton via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Type nesting allows some convenient and straightforward semantics that we see inside the Swift standard library such as views on String like String.CharacterView, String.UnicodeScalarView, etc. However a protocol cannot be nested in a type and gives a non-obvious error that the “Declaration is only valid at file scope.” Just as other nested types allow proper contextual scoping, a nested protocol could make a lot sense for a number of patterns. For example, there are many “Delegate” protocols throughout the Cocoa frameworks. Here’s a controller/delegate pattern before and after type nesting:<br>&gt; <br>&gt; // Without type nesting<br>&gt; <br>&gt; protocol MyControllerDelegate : class {<br>&gt;     <br>&gt; }<br>&gt; <br>&gt; class MyController {<br>&gt;     <br>&gt;     weak var delegate: MyControllerDelegate?<br>&gt;     <br>&gt; }<br>&gt; <br>&gt; // With type nesting<br>&gt; <br>&gt; class MyController {<br>&gt;     <br>&gt;     weak var delegate: Delegate?<br>&gt;     <br>&gt;     protocol Delegate : class {<br>&gt;         <br>&gt;     }<br>&gt;     <br>&gt; }<br>&gt; <br>&gt; Though the change is mostly semantics, it does allow an explicit association between My Controller and the Delegate instead of only a named association. It also cleans up the module name space like other nested types and makes associated protocols more discoverable in my opinion. <br>&gt; <br>&gt; I’d love to hear everyone’s thoughts.<br></p><p>Note that this cannot work when any enclosing type is generic, e.g.,<br></p><p>class MyController&lt;T&gt; {<br>  protocol Delegate {<br>    // I’ve just created a parameterized protocol!<br>  }<br>}<br></p><p>Otherwise, I don’t see any issues with the proposal, and I like that it eliminates a large number of top-level names.<br></p><p>	- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160428/01fe13f5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Pitch] Allow nested protocol declarations</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>April 29, 2016 at 09:00:00am</p></header><div class="content"><p>To get over issues like the inner protocol accessing outer quantities like<br>properties and generics you could add keyword noaccess (bike-shedding<br>name) to the declaration to make it clear that it does not have access,<br>e.g.:<br></p><p>class MyController&lt;T&gt; {<br>  noaccess protocol Delegate {<br>    // No access to T<br>  }<br>}<br></p><p>Java does something along these lines using static and it works out well.<br>As an aside static is insufficient in Swift because statics have access to<br>generics in Swift, unlike Java.<br></p><p>On Friday, 29 April 2016, Douglas Gregor via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Apr 28, 2016, at 10:15 AM, Brad Hilton via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt; Type nesting allows some convenient and straightforward semantics that we<br>&gt; see inside the Swift standard library such as views on String like<br>&gt; String.CharacterView, String.UnicodeScalarView, etc. However a protocol<br>&gt; cannot be nested in a type and gives a non-obvious error that the<br>&gt; “Declaration is only valid at file scope.” Just as other nested types allow<br>&gt; proper contextual scoping, a nested protocol could make a lot sense for a<br>&gt; number of patterns. For example, there are many “Delegate” protocols<br>&gt; throughout the Cocoa frameworks. Here’s a controller/delegate pattern<br>&gt; before and after type nesting:<br>&gt;<br>&gt; // Without type nesting<br>&gt;<br>&gt; protocol MyControllerDelegate : class {<br>&gt;<br>&gt; }<br>&gt;<br>&gt; class MyController {<br>&gt;<br>&gt;     weak var delegate: MyControllerDelegate?<br>&gt;<br>&gt; }<br>&gt;<br>&gt; // With type nesting<br>&gt;<br>&gt; class MyController {<br>&gt;<br>&gt;     weak var delegate: Delegate?<br>&gt;<br>&gt;     protocol Delegate : class {<br>&gt;<br>&gt;     }<br>&gt;<br>&gt; }<br>&gt;<br>&gt; Though the change is mostly semantics, it does allow an explicit<br>&gt; association between My Controller and the Delegate instead of only a named<br>&gt; association. It also cleans up the module name space like other nested<br>&gt; types and makes associated protocols more discoverable in my opinion.<br>&gt;<br>&gt; I’d love to hear everyone’s thoughts.<br>&gt;<br>&gt;<br>&gt; Note that this cannot work when any enclosing type is generic, e.g.,<br>&gt;<br>&gt; class MyController&lt;T&gt; {<br>&gt;   protocol Delegate {<br>&gt;     // I’ve just created a parameterized protocol!<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Otherwise, I don’t see any issues with the proposal, and I like that it<br>&gt; eliminates a large number of top-level names.<br>&gt;<br>&gt; - Doug<br>&gt;<br>&gt;<br>&gt;<br></p><p>-- <br>-- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160429/0a89672a/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Pitch] Allow nested protocol declarations</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>April 28, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Apr 28, 2016, at 6:27 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Note that this cannot work when any enclosing type is generic, e.g.,<br>&gt; <br>&gt; class MyController&lt;T&gt; {<br>&gt;   protocol Delegate {<br>&gt;     // I’ve just created a parameterized protocol!<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; Otherwise, I don’t see any issues with the proposal, and I like that it eliminates a large number of top-level names.<br>&gt; <br>&gt; 	- Doug<br></p><p>Is that a bad, or are you just pointing out that this proposal would implicitly add parameterized protocols to Swift? I don’t think they’re *exactly* the same as “naked” parameterized protocols, since you wouldn’t be able access a nested protocol without specifying all the container type’s generic parameters, but maybe that’s a difference that makes no difference.<br></p><p>- Dave Sweeris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160428/8a81704e/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0a88a27755600d9f1c1ce00e3c209a38?s=50"></div><header><strong>[Pitch] Allow nested protocol declarations</strong> from <string>Brad Hilton</string> &lt;brad.hilton.nw at gmail.com&gt;<p>April 28, 2016 at 08:00:00pm</p></header><div class="content"><p>You&#39;re right and since you can&#39;t nest any kind of type in a generic type<br>right, that wouldn&#39;t work even with this proposal. However, in the generics<br>manifesto they did say that they intend to remove that restriction. If they<br>do lift the restriction, they may have to leave an exception in place for<br>protocols.<br></p><p>On Thu, Apr 28, 2016 at 5:27 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Apr 28, 2016, at 10:15 AM, Brad Hilton via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Type nesting allows some convenient and straightforward semantics that we<br>&gt; see inside the Swift standard library such as views on String like<br>&gt; String.CharacterView, String.UnicodeScalarView, etc. However a protocol<br>&gt; cannot be nested in a type and gives a non-obvious error that the<br>&gt; “Declaration is only valid at file scope.” Just as other nested types allow<br>&gt; proper contextual scoping, a nested protocol could make a lot sense for a<br>&gt; number of patterns. For example, there are many “Delegate” protocols<br>&gt; throughout the Cocoa frameworks. Here’s a controller/delegate pattern<br>&gt; before and after type nesting:<br>&gt;<br>&gt; // Without type nesting<br>&gt;<br>&gt; protocol MyControllerDelegate : class {<br>&gt;<br>&gt; }<br>&gt;<br>&gt; class MyController {<br>&gt;<br>&gt;     weak var delegate: MyControllerDelegate?<br>&gt;<br>&gt; }<br>&gt;<br>&gt; // With type nesting<br>&gt;<br>&gt; class MyController {<br>&gt;<br>&gt;     weak var delegate: Delegate?<br>&gt;<br>&gt;     protocol Delegate : class {<br>&gt;<br>&gt;     }<br>&gt;<br>&gt; }<br>&gt;<br>&gt; Though the change is mostly semantics, it does allow an explicit<br>&gt; association between My Controller and the Delegate instead of only a named<br>&gt; association. It also cleans up the module name space like other nested<br>&gt; types and makes associated protocols more discoverable in my opinion.<br>&gt;<br>&gt; I’d love to hear everyone’s thoughts.<br>&gt;<br>&gt;<br>&gt; Note that this cannot work when any enclosing type is generic, e.g.,<br>&gt;<br>&gt; class MyController&lt;T&gt; {<br>&gt;   protocol Delegate {<br>&gt;     // I’ve just created a parameterized protocol!<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Otherwise, I don’t see any issues with the proposal, and I like that it<br>&gt; eliminates a large number of top-level names.<br>&gt;<br>&gt; - Doug<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160428/1f341894/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e2000c4913814c2ca9e16442ae908265?s=50"></div><header><strong>[Pitch] Allow nested protocol declarations</strong> from <string>Krishna Kumar</string> &lt;kkdevenda at gmail.com&gt;<p>April 29, 2016 at 01:00:00pm</p></header><div class="content"><p>Hey Brad<br></p><p>+1 I think this will make delegate controller pattern a lot more clean and readable.<br></p><p>I was thinking about other areas where this can be useful, and I thought it will be great for property injection from parent controller to children.<br></p><p>class ParentController{<br>    protocol Injection: class{<br>        <br>    }<br>    override func prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject?){<br>        let childVC = segue.destinationViewController as? Injection<br>        ...<br>    }<br>}<br></p><p>class ChildController: ParentController.Injection{<br>    <br>}<br></p><p><br>Does this make sense?<br></p><p>-Krishna<br></p><p>&gt; On Apr 28, 2016, at 10:45 PM, Brad Hilton via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Type nesting allows some convenient and straightforward semantics that we see inside the Swift standard library such as views on String like String.CharacterView, String.UnicodeScalarView, etc. However a protocol cannot be nested in a type and gives a non-obvious error that the “Declaration is only valid at file scope.” Just as other nested types allow proper contextual scoping, a nested protocol could make a lot sense for a number of patterns. For example, there are many “Delegate” protocols throughout the Cocoa frameworks. Here’s a controller/delegate pattern before and after type nesting:<br>&gt; <br>&gt; // Without type nesting<br>&gt; <br>&gt; protocol MyControllerDelegate : class {<br>&gt;     <br>&gt; }<br>&gt; <br>&gt; class MyController {<br>&gt;     <br>&gt;     weak var delegate: MyControllerDelegate?<br>&gt;     <br>&gt; }<br>&gt; <br>&gt; // With type nesting<br>&gt; <br>&gt; class MyController {<br>&gt;     <br>&gt;     weak var delegate: Delegate?<br>&gt;     <br>&gt;     protocol Delegate : class {<br>&gt;         <br>&gt;     }<br>&gt;     <br>&gt; }<br>&gt; <br>&gt; Though the change is mostly semantics, it does allow an explicit association between My Controller and the Delegate instead of only a named association. It also cleans up the module name space like other nested types and makes associated protocols more discoverable in my opinion. <br>&gt; <br>&gt; I’d love to hear everyone’s thoughts.<br>&gt; <br>&gt; Brad Hilton<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160429/5073c1ae/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Pitch] Allow nested protocol declarations</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>May  6, 2016 at 09:00:00am</p></header><div class="content"><p>+1 I can’t wait for Swift 3 anymore. This ability would be great.<br></p><p>Additionally what do you think about something like this?<br></p><p>protocol DelegatableType {<br></p><p>     protocol Delegate: class // enforced you to create a nested protocol<br></p><p>     weak var delegate: Delegate? // or Self.Delegate?<br>} <br></p><p>class A: DelegatableType {<br></p><p>    protocol Delegate { /* create something fancy */ }<br></p><p>    var delegate: Delegate? // or A.Delegate? but I tend to just writing Delegate?<br>}<br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 29. April 2016 bei 09:56:55, Krishna Kumar via swift-evolution (swift-evolution at swift.org) schrieb:<br></p><p>Hey Brad<br></p><p>+1 I think this will make delegate controller pattern a lot more clean and readable.<br></p><p>I was thinking about other areas where this can be useful, and I thought it will be great for property injection from parent controller to children.<br></p><p>class ParentController{<br>    protocol Injection: class{<br>        <br>    }<br>    override func prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject?){<br>        let childVC = segue.destinationViewController as? Injection<br>        ...<br>    }<br>}<br></p><p>class ChildController: ParentController.Injection{<br>    <br>}<br></p><p><br>Does this make sense?<br></p><p>-Krishna<br></p><p>On Apr 28, 2016, at 10:45 PM, Brad Hilton via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>Type nesting allows some convenient and straightforward semantics that we see inside the Swift standard library such as views on String like String.CharacterView, String.UnicodeScalarView, etc. However a protocol cannot be nested in a type and gives a non-obvious error that the “Declaration is only valid at file scope.” Just as other nested types allow proper contextual scoping, a nested protocol could make a lot sense for a number of patterns. For example, there are many “Delegate” protocols throughout the Cocoa frameworks. Here’s a controller/delegate pattern before and after type nesting:<br></p><p>// Without type nesting<br></p><p>protocol MyControllerDelegate : class {<br>    <br>}<br></p><p>class MyController {<br>    <br>    weak var delegate: MyControllerDelegate?<br>    <br>}<br></p><p>// With type nesting<br></p><p>class MyController {<br>    <br>    weak var delegate: Delegate?<br>    <br>    protocol Delegate : class {<br>        <br>    }<br>    <br>}<br></p><p>Though the change is mostly semantics, it does allow an explicit association between My Controller and the Delegate instead of only a named association. It also cleans up the module name space like other nested types and makes associated protocols more discoverable in my opinion. <br></p><p>I’d love to hear everyone’s thoughts.<br></p><p>Brad Hilton<br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160506/3ffc147a/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
