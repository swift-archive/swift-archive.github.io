<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8809800aec2460f291384b794d7e6f8f?s=50"></div><header><strong>Swift for bare-metal programming</strong> from <string>Rick Mann</string> &lt;rmann at latencyzero.com&gt;<p>August 16, 2016 at 01:00:00pm</p></header><div class="content"><p>I&#39;m not sure what effort is already underway to support this, but I&#39;d like to be able to take advantage of Swift&#39;s inherent robustness to develop code for embedded devices without the benefit of an OS like Linux. I see at least two classes of such development: small and large embedded processors. &quot;Large&quot; ones typically have external DRAM and flash (think Beaglebone Black or Raspberry Pi), small ones have on-board DRAM and flash, and execute directly from flash. The smallest ones don&#39;t even have a RAM-based stack, and I&#39;m not considering those. But there are a large number of small MCUs that can be programmed in C++, and it&#39;s those I&#39;d like to eventually be able to target.<br></p><p>But to start, I&#39;d like to be able to target the Beaglebone Black (TI Sitara AM335x ARM processor). On the swift-users list we talked about this a bit (Subject: &quot;Swift in bare-metal embedded programming/Swift runtime&quot;). Most of my initial questions centered on the Swift runtime and how bulky that might be, and about how to statically link a set of Swift files and the runtime into a monolithic block of code.<br></p><p>But then I remembered the need for something as basic as a &quot;naked&quot; function, one that could serve as an entry point for an interrupt vector. In GCC (and Clang, presumably), you can prepend &quot;__attribute__ ((naked))&quot; on a function declaration. You can then use those function names in the assembly file you build for the vector table.<br></p><p>There&#39;s also the need to be able to name a specific physical (perhaps virtual) memory address and do bit operations on them. In C/C++, this is relatively easy. Not sure how one would do this in Swift.<br></p><p>In a lot of embedded programming, one pre-allocates all memory so that the running program need not allocate and deallocate memory as it goes. This enhances reliability. It would be nice for Swift to support this, in that you&#39;d want to be able to ensure the runtime isn&#39;t calling malloc when you don&#39;t want it to.<br></p><p>I&#39;d eventually love to be able to write a real-time OS largely in Swift (with perhaps only startup code like the vector table and thread context switch code done in assembly).<br></p><p>Thanks!<br></p><p>-- <br>Rick Mann<br>rmann at latencyzero.com<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>Swift for bare-metal programming</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>August 17, 2016 at 01:00:00am</p></header><div class="content"><p>2016-08-16 23:07 GMT+03:00 Rick Mann via swift-evolution &lt;<br>swift-evolution at swift.org&gt;:<br></p><p>&gt; I&#39;m not sure what effort is already underway to support this, but I&#39;d like<br>&gt; to be able to take advantage of Swift&#39;s inherent robustness to develop code<br>&gt; for embedded devices without the benefit of an OS like Linux. I see at<br>&gt; least two classes of such development: small and large embedded processors.<br>&gt; &quot;Large&quot; ones typically have external DRAM and flash (think Beaglebone Black<br>&gt; or Raspberry Pi), small ones have on-board DRAM and flash, and execute<br>&gt; directly from flash. The smallest ones don&#39;t even have a RAM-based stack,<br>&gt; and I&#39;m not considering those. But there are a large number of small MCUs<br>&gt; that can be programmed in C++, and it&#39;s those I&#39;d like to eventually be<br>&gt; able to target.<br>&gt;<br>&gt; But to start, I&#39;d like to be able to target the Beaglebone Black (TI<br>&gt; Sitara AM335x ARM processor). On the swift-users list we talked about this<br>&gt; a bit (Subject: &quot;Swift in bare-metal embedded programming/Swift runtime&quot;).<br></p><p><br>This itself is not a question of SE, but rather of implementation for these<br>platforms. I guess, Apple engineers won&#39;t really want to do this work.<br></p><p>Most of my initial questions centered on the Swift runtime and how bulky<br>&gt; that might be, and about how to statically link a set of Swift files and<br>&gt; the runtime into a monolithic block of code.<br>&gt;<br></p><p>`swiftc` already generates dependency-free executables.<br></p><p>But then I remembered the need for something as basic as a &quot;naked&quot;<br>&gt; function, one that could serve as an entry point for an interrupt vector.<br>&gt; In GCC (and Clang, presumably), you can prepend &quot;__attribute__ ((naked))&quot;<br>&gt; on a function declaration. You can then use those function names in the<br>&gt; assembly file you build for the vector table.<br>&gt;<br></p><p>Agreed, something like `@export(demangledName)` would be useful.<br></p><p><br>&gt; There&#39;s also the need to be able to name a specific physical (perhaps<br>&gt; virtual) memory address and do bit operations on them. In C/C++, this is<br>&gt; relatively easy. Not sure how one would do this in Swift.<br>&gt;<br></p><p>UnsafeBytes, UnsafePointer, UnsafeBufferPointer do this. Suddenly,<br>interaction with C gets more verbose, but it is also verbose in many other<br>&quot;safe&quot; languages.<br></p><p>In a lot of embedded programming, one pre-allocates all memory so that the<br>&gt; running program need not allocate and deallocate memory as it goes. This<br>&gt; enhances reliability. It would be nice for Swift to support this, in that<br>&gt; you&#39;d want to be able to ensure the runtime isn&#39;t calling malloc when you<br>&gt; don&#39;t want it to.<br></p><p><br>We could create a list of malloc-free standard library entities. Then if<br>you use only this subset of language, you&#39;ll be fine. Plus, no classes,<br>closures, `indirect`, and existential protocols.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160817/7250e465/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8809800aec2460f291384b794d7e6f8f?s=50"></div><header><strong>Swift for bare-metal programming</strong> from <string>Rick Mann</string> &lt;rmann at latencyzero.com&gt;<p>August 16, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Aug 16, 2016, at 15:27 , Anton Zhilin &lt;antonyzhilin at gmail.com&gt; wrote:<br>&gt; <br>&gt; 2016-08-16 23:07 GMT+03:00 Rick Mann via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; But to start, I&#39;d like to be able to target the Beaglebone Black (TI Sitara AM335x ARM processor). On the swift-users list we talked about this a bit (Subject: &quot;Swift in bare-metal embedded programming/Swift runtime&quot;).<br>&gt; <br>&gt; This itself is not a question of SE, but rather of implementation for these platforms. I guess, Apple engineers won&#39;t really want to do this work.<br></p><p>I only mention this platform specifically as an example to help illustrate what I&#39;m hoping to be able to accomplish. On the low end of the spectrum, I&#39;d love to be able to target an Atmel ATmega32.<br></p><p>&gt;&gt; Most of my initial questions centered on the Swift runtime and how bulky that might be, and about how to statically link a set of Swift files and the runtime into a monolithic block of code.<br>&gt; <br>&gt; `swiftc` already generates dependency-free executables.<br></p><p>Cool, I&#39;ll examine that a bit.<br></p><p>&gt;&gt; But then I remembered the need for something as basic as a &quot;naked&quot; function, one that could serve as an entry point for an interrupt vector. In GCC (and Clang, presumably), you can prepend &quot;__attribute__ ((naked))&quot; on a function declaration. You can then use those function names in the assembly file you build for the vector table.<br>&gt; <br>&gt; Agreed, something like `@export(demangledName)` would be useful.<br></p><p>I understand this to be a proposed mechanism for specifying the function name, but it also needs something like @naked to indicate that no prologue or epilogue should be generated for the function.<br></p><p>&gt;&gt; There&#39;s also the need to be able to name a specific physical (perhaps virtual) memory address and do bit operations on them. In C/C++, this is relatively easy. Not sure how one would do this in Swift.<br>&gt; <br>&gt; UnsafeBytes, UnsafePointer, UnsafeBufferPointer do this. Suddenly, interaction with C gets more verbose, but it is also verbose in many other &quot;safe&quot; languages.<br></p><p>In C on an Atmel MCU, it&#39;s done with macros:<br></p><p>#define _MMIO_BYTE(mem_addr) (*(volatile uint8_t *)(mem_addr))<br>#define DIDR1 _MMIO_BYTE(0x7F)<br></p><p>In code, you can then write:<br></p><p>DIDR1 = 0xXX;<br></p><p>And that writes that byte to address 0x7F.<br></p><p>In more sophisticated MCUs, a hardware peripheral will have several registers in memory, and they&#39;ll be defined by a struct in C. The base address of the struct is changed depending on which instance of the hardware peripheral you&#39;re talking about (i.e. there can be four USARTS, each with several bytes of configuration registers). Then the client code looks like (in C):<br></p><p>USART1-&gt;BAUD = ...;<br>USART1-&gt;CFG = ...;<br></p><p>USART1-&gt;TXDATA = ...;<br></p><p>Importantly, the struct members have no padding, and an instance of the struct is declared to exist at a specific memory address.<br></p><p>Can that be done in Swift?<br></p><p>&gt; In a lot of embedded programming, one pre-allocates all memory so that the running program need not allocate and deallocate memory as it goes. This enhances reliability. It would be nice for Swift to support this, in that you&#39;d want to be able to ensure the runtime isn&#39;t calling malloc when you don&#39;t want it to.<br>&gt; <br>&gt; We could create a list of malloc-free standard library entities. Then if you use only this subset of language, you&#39;ll be fine. Plus, no classes, closures, `indirect`, and existential protocols. <br></p><p>It would be a shame to have to lose all that. I can still use classes in C++, even on very small MCUs. Sometimes I disable RTTI and exception handling because they cause a lot of bloat. I avoid the STL in some cases for the same reason. Calling malloc() isn&#39;t bad, you just want to know when it&#39;s called, and do that in your app&#39;s initialization, and not during the run loop (whatever form your run loop takes).<br></p><p>Thanks!<br></p><p>-- <br>Rick Mann<br>rmann at latencyzero.com<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>Swift for bare-metal programming</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>August 17, 2016 at 03:00:00am</p></header><div class="content"><p>2016-08-17 3:27 GMT+03:00 Roderick Mann &lt;rmann at latencyzero.com&gt;:<br>&gt;<br>&gt; &gt;&gt; There&#39;s also the need to be able to name a specific physical (perhaps<br>&gt; virtual) memory address and do bit operations on them. In C/C++, this is<br>&gt; relatively easy. Not sure how one would do this in Swift.<br>&gt; &gt;<br>&gt; &gt; UnsafeBytes, UnsafePointer, UnsafeBufferPointer do this. Suddenly,<br>&gt; interaction with C gets more verbose, but it is also verbose in many other<br>&gt; &quot;safe&quot; languages.<br>&gt;<br>&gt; In C on an Atmel MCU, it&#39;s done with macros:<br>&gt;<br>&gt; #define _MMIO_BYTE(mem_addr) (*(volatile uint8_t *)(mem_addr))<br>&gt; #define DIDR1 _MMIO_BYTE(0x7F)<br>&gt;<br>&gt; In code, you can then write:<br>&gt;<br>&gt; DIDR1 = 0xXX;<br>&gt;<br>&gt; And that writes that byte to address 0x7F.<br>&gt;<br>&gt; In more sophisticated MCUs, a hardware peripheral will have several<br>&gt; registers in memory, and they&#39;ll be defined by a struct in C. The base<br>&gt; address of the struct is changed depending on which instance of the<br>&gt; hardware peripheral you&#39;re talking about (i.e. there can be four USARTS,<br>&gt; each with several bytes of configuration registers). Then the client code<br>&gt; looks like (in C):<br>&gt;<br>&gt; USART1-&gt;BAUD = ...;<br>&gt; USART1-&gt;CFG = ...;<br>&gt;<br>&gt; USART1-&gt;TXDATA = ...;<br>&gt;<br>&gt; Importantly, the struct members have no padding, and an instance of the<br>&gt; struct is declared to exist at a specific memory address.<br>&gt;<br>&gt; Can that be done in Swift?<br></p><p><br>Yes, using UnsafeMutablePointer. But I&#39;m not sure about padding.<br></p><p><br>&gt; &gt; In a lot of embedded programming, one pre-allocates all memory so that<br>&gt; the running program need not allocate and deallocate memory as it goes.<br>&gt; This enhances reliability. It would be nice for Swift to support this, in<br>&gt; that you&#39;d want to be able to ensure the runtime isn&#39;t calling malloc when<br>&gt; you don&#39;t want it to.<br>&gt; &gt;<br>&gt; &gt; We could create a list of malloc-free standard library entities. Then if<br>&gt; you use only this subset of language, you&#39;ll be fine. Plus, no classes,<br>&gt; closures, `indirect`, and existential protocols.<br>&gt;<br>&gt; It would be a shame to have to lose all that. I can still use classes in<br>&gt; C++, even on very small MCUs. Sometimes I disable RTTI and exception<br>&gt; handling because they cause a lot of bloat. I avoid the STL in some cases<br>&gt; for the same reason. Calling malloc() isn&#39;t bad, you just want to know when<br>&gt; it&#39;s called, and do that in your app&#39;s initialization, and not during the<br>&gt; run loop (whatever form your run loop takes).<br></p><p><br>Ok, you should be able to use classes, etc. You just won&#39;t be able to<br>create new instances without heap allocation. Just as in C++. And for<br>&quot;classes on stack&quot;, we&#39;ve got struct types.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160817/c66af556/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>Swift for bare-metal programming</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>August 17, 2016 at 06:00:00am</p></header><div class="content"><p>&gt; On Aug 17, 2016, at 2:47 AM, Anton Zhilin via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; 2016-08-17 3:27 GMT+03:00 Roderick Mann &lt;rmann at latencyzero.com &lt;mailto:rmann at latencyzero.com&gt;&gt;:<br>&gt; &gt;&gt; There&#39;s also the need to be able to name a specific physical (perhaps virtual) memory address and do bit operations on them. In C/C++, this is relatively easy. Not sure how one would do this in Swift.<br>&gt; &gt;<br>&gt; &gt; UnsafeBytes, UnsafePointer, UnsafeBufferPointer do this. Suddenly, interaction with C gets more verbose, but it is also verbose in many other &quot;safe&quot; languages.<br>&gt; <br>&gt; In C on an Atmel MCU, it&#39;s done with macros:<br>&gt; <br>&gt; #define _MMIO_BYTE(mem_addr) (*(volatile uint8_t *)(mem_addr))<br>&gt; #define DIDR1 _MMIO_BYTE(0x7F)<br>&gt; <br>&gt; In code, you can then write:<br>&gt; <br>&gt; DIDR1 = 0xXX;<br>&gt; <br>&gt; And that writes that byte to address 0x7F.<br>&gt; <br>&gt; In more sophisticated MCUs, a hardware peripheral will have several registers in memory, and they&#39;ll be defined by a struct in C. The base address of the struct is changed depending on which instance of the hardware peripheral you&#39;re talking about (i.e. there can be four USARTS, each with several bytes of configuration registers). Then the client code looks like (in C):<br>&gt; <br>&gt; USART1-&gt;BAUD = ...;<br>&gt; USART1-&gt;CFG = ...;<br>&gt; <br>&gt; USART1-&gt;TXDATA = ...;<br>&gt; <br>&gt; Importantly, the struct members have no padding, and an instance of the struct is declared to exist at a specific memory address.<br>&gt; <br>&gt; Can that be done in Swift?<br>&gt; <br>&gt; Yes, using UnsafeMutablePointer. But I&#39;m not sure about padding.<br></p><p><br>AFAICT, there is no way to create a packed struct in Swift. I was thinking about making a proposal for it, but there are fairly easy workarounds:<br></p><p>http://stackoverflow.com/questions/24139149/how-do-i-create-a-packed-data-structure-in-swift &lt;http://stackoverflow.com/questions/24139149/how-do-i-create-a-packed-data-structure-in-swift&gt;<br>&gt;  <br>&gt; &gt; In a lot of embedded programming, one pre-allocates all memory so that the running program need not allocate and deallocate memory as it goes. This enhances reliability. It would be nice for Swift to support this, in that you&#39;d want to be able to ensure the runtime isn&#39;t calling malloc when you don&#39;t want it to.<br>&gt; &gt;<br>&gt; &gt; We could create a list of malloc-free standard library entities. Then if you use only this subset of language, you&#39;ll be fine. Plus, no classes, closures, `indirect`, and existential protocols.<br>&gt; <br>&gt; It would be a shame to have to lose all that. I can still use classes in C++, even on very small MCUs. Sometimes I disable RTTI and exception handling because they cause a lot of bloat. I avoid the STL in some cases for the same reason. Calling malloc() isn&#39;t bad, you just want to know when it&#39;s called, and do that in your app&#39;s initialization, and not during the run loop (whatever form your run loop takes).<br>&gt; <br>&gt; Ok, you should be able to use classes, etc. You just won&#39;t be able to create new instances without heap allocation. Just as in C++. And for &quot;classes on stack&quot;, we&#39;ve got struct types.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160817/a93dcfa3/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
