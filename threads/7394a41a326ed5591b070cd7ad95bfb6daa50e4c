<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d042be5dcfe90e649f760303af3e429?s=50"></div><header><strong>Why are BinaryFloatingPoint&#39;s RawSignificand and RawExponent different type?</strong> from <string>Jens Persson</string> &lt;jens at bitcycle.com&gt;<p>August 27, 2016 at 12:00:00am</p></header><div class="content"><p>I can understand why<br>Double.RawSignificand is UInt64<br>and<br>Float.RawSignificand is UInt32<br></p><p>But I can&#39;t understand why both<br>Double.RawExponent<br>and<br>Float.RawExponent<br>should be UInt.<br></p><p>Why aren&#39;t they also just UInt64 and UInt32, resp.?<br></p><p>/Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160827/73940e4c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>Why are BinaryFloatingPoint&#39;s RawSignificand and RawExponent different type?</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>August 26, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Aug 26, 2016, at 6:06 PM, Jens Persson via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; I can understand why<br>&gt; Double.RawSignificand is UInt64<br>&gt; and<br>&gt; Float.RawSignificand is UInt32<br>&gt; <br>&gt; But I can&#39;t understand why both<br>&gt; Double.RawExponent<br>&gt; and<br>&gt; Float.RawExponent<br>&gt; should be UInt.<br>&gt; <br>&gt; Why aren&#39;t they also just UInt64 and UInt32, resp.?<br></p><p>Let me flip the question: why would they be UInt64 and UInt32?  Absent a reason to prefer a specific fixed-with type, Swift integers should generally default to being [U]Int (and ideally Int, but RawExponent is Unsigned).<br></p><p>– Steve<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d042be5dcfe90e649f760303af3e429?s=50"></div><header><strong>Why are BinaryFloatingPoint&#39;s RawSignificand and RawExponent different type?</strong> from <string>Jens Persson</string> &lt;jens at bitcycle.com&gt;<p>August 27, 2016 at 01:00:00am</p></header><div class="content"><p>Reason for asking is that I have this:<br></p><p>extension Double {<br>    init(unitRangeFromRawSignificand s: RawSignificand) {<br>        let bitPattern = s | (1023 &lt;&lt; 52)<br>        self = unsafeBitCast(bitPattern, to: Double.self) - 1.0<br>    }<br>}<br>extension Float {<br>    init(unitRangeFromRawSignificand s: RawSignificand) {<br>        let bitPattern = s | (127 &lt;&lt; 23)<br>        self = unsafeBitCast(bitPattern, to: Float.self) - 1.0<br>    }<br>}<br></p><p>But they would be better as:<br>extension BinaryFloatingPoint {<br>    init(unitRangeFromRawSignificand s: RawSignificand) {<br>        ... problems here, have to try casting things into RawSignificand&#39;s<br>type ...<br>    }<br>}<br></p><p>Please have a go at that and perhaps you see what I mean or you will come<br>up with a nice solution that I have missed. (Speed is very important btw.)<br></p><p>/Jens<br></p><p><br>On Sat, Aug 27, 2016 at 1:02 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br></p><p>&gt; &gt; On Aug 26, 2016, at 6:06 PM, Jens Persson via swift-dev &lt;<br>&gt; swift-dev at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I can understand why<br>&gt; &gt; Double.RawSignificand is UInt64<br>&gt; &gt; and<br>&gt; &gt; Float.RawSignificand is UInt32<br>&gt; &gt;<br>&gt; &gt; But I can&#39;t understand why both<br>&gt; &gt; Double.RawExponent<br>&gt; &gt; and<br>&gt; &gt; Float.RawExponent<br>&gt; &gt; should be UInt.<br>&gt; &gt;<br>&gt; &gt; Why aren&#39;t they also just UInt64 and UInt32, resp.?<br>&gt;<br>&gt; Let me flip the question: why would they be UInt64 and UInt32?  Absent a<br>&gt; reason to prefer a specific fixed-with type, Swift integers should<br>&gt; generally default to being [U]Int (and ideally Int, but RawExponent is<br>&gt; Unsigned).<br>&gt;<br>&gt; – Steve<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160827/968a5ccd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d042be5dcfe90e649f760303af3e429?s=50"></div><header><strong>Why are BinaryFloatingPoint&#39;s RawSignificand and RawExponent different type?</strong> from <string>Jens Persson</string> &lt;jens at bitcycle.com&gt;<p>August 27, 2016 at 01:00:00am</p></header><div class="content"><p>Oh, to more directly answer your question: I don&#39;t like having to create a<br>UInt (UInt64) value when all my bit manipulaton code happens in UInt32 (for<br>Float) for example.<br></p><p>The most probable context for using these computed properties and types of<br>BinaryFloatingPoint is one in which specific fixed width types really<br>matters a lot (look at the name of the protocol and the properties and<br>assocated types we are talking about).<br></p><p>/Jens<br></p><p><br>On Sat, Aug 27, 2016 at 1:15 AM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br></p><p>&gt; Reason for asking is that I have this:<br>&gt;<br>&gt; extension Double {<br>&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;         let bitPattern = s | (1023 &lt;&lt; 52)<br>&gt;         self = unsafeBitCast(bitPattern, to: Double.self) - 1.0<br>&gt;     }<br>&gt; }<br>&gt; extension Float {<br>&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;         let bitPattern = s | (127 &lt;&lt; 23)<br>&gt;         self = unsafeBitCast(bitPattern, to: Float.self) - 1.0<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; But they would be better as:<br>&gt; extension BinaryFloatingPoint {<br>&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;         ... problems here, have to try casting things into<br>&gt; RawSignificand&#39;s type ...<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; Please have a go at that and perhaps you see what I mean or you will come<br>&gt; up with a nice solution that I have missed. (Speed is very important btw.)<br>&gt;<br>&gt; /Jens<br>&gt;<br>&gt;<br>&gt; On Sat, Aug 27, 2016 at 1:02 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt; &gt; On Aug 26, 2016, at 6:06 PM, Jens Persson via swift-dev &lt;<br>&gt;&gt; swift-dev at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I can understand why<br>&gt;&gt; &gt; Double.RawSignificand is UInt64<br>&gt;&gt; &gt; and<br>&gt;&gt; &gt; Float.RawSignificand is UInt32<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; But I can&#39;t understand why both<br>&gt;&gt; &gt; Double.RawExponent<br>&gt;&gt; &gt; and<br>&gt;&gt; &gt; Float.RawExponent<br>&gt;&gt; &gt; should be UInt.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Why aren&#39;t they also just UInt64 and UInt32, resp.?<br>&gt;&gt;<br>&gt;&gt; Let me flip the question: why would they be UInt64 and UInt32?  Absent a<br>&gt;&gt; reason to prefer a specific fixed-with type, Swift integers should<br>&gt;&gt; generally default to being [U]Int (and ideally Int, but RawExponent is<br>&gt;&gt; Unsigned).<br>&gt;&gt;<br>&gt;&gt; – Steve<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160827/3071816c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>Why are BinaryFloatingPoint&#39;s RawSignificand and RawExponent different type?</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>August 26, 2016 at 07:00:00pm</p></header><div class="content"><p>This doesn’t really scale up very well, though.  BinaryFloatingPoint needs to also be able to model e.g. Float2048 or similar; we generally don&#39;t want to require that RawExponent to be the same type as RawSignificand (which I think is what you’re really suggesting), because in typical bignum usage significands are much larger than exponents.<br></p><p>It sounds like maybe you actually want to be operating directly on bitPatterns, rather than the abstract fields of the types.<br></p><p>– Steve<br></p><p>&gt; On Aug 26, 2016, at 7:21 PM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt; <br>&gt; Oh, to more directly answer your question: I don&#39;t like having to create a UInt (UInt64) value when all my bit manipulaton code happens in UInt32 (for Float) for example.<br>&gt; <br>&gt; The most probable context for using these computed properties and types of BinaryFloatingPoint is one in which specific fixed width types really matters a lot (look at the name of the protocol and the properties and assocated types we are talking about).<br>&gt; <br>&gt; /Jens<br>&gt; <br>&gt; <br>&gt; On Sat, Aug 27, 2016 at 1:15 AM, Jens Persson &lt;jens at bitcycle.com &lt;mailto:jens at bitcycle.com&gt;&gt; wrote:<br>&gt; Reason for asking is that I have this:<br>&gt; <br>&gt; extension Double {<br>&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;         let bitPattern = s | (1023 &lt;&lt; 52)<br>&gt;         self = unsafeBitCast(bitPattern, to: Double.self) - 1.0<br>&gt;     }<br>&gt; }<br>&gt; extension Float {<br>&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;         let bitPattern = s | (127 &lt;&lt; 23)<br>&gt;         self = unsafeBitCast(bitPattern, to: Float.self) - 1.0<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; But they would be better as:<br>&gt; extension BinaryFloatingPoint {<br>&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;         ... problems here, have to try casting things into RawSignificand&#39;s type ...<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; Please have a go at that and perhaps you see what I mean or you will come up with a nice solution that I have missed. (Speed is very important btw.)<br>&gt; <br>&gt; /Jens<br>&gt; <br>&gt; <br>&gt; On Sat, Aug 27, 2016 at 1:02 AM, Stephen Canon &lt;scanon at apple.com &lt;mailto:scanon at apple.com&gt;&gt; wrote:<br>&gt; &gt; On Aug 26, 2016, at 6:06 PM, Jens Persson via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I can understand why<br>&gt; &gt; Double.RawSignificand is UInt64<br>&gt; &gt; and<br>&gt; &gt; Float.RawSignificand is UInt32<br>&gt; &gt;<br>&gt; &gt; But I can&#39;t understand why both<br>&gt; &gt; Double.RawExponent<br>&gt; &gt; and<br>&gt; &gt; Float.RawExponent<br>&gt; &gt; should be UInt.<br>&gt; &gt;<br>&gt; &gt; Why aren&#39;t they also just UInt64 and UInt32, resp.?<br>&gt; <br>&gt; Let me flip the question: why would they be UInt64 and UInt32?  Absent a reason to prefer a specific fixed-with type, Swift integers should generally default to being [U]Int (and ideally Int, but RawExponent is Unsigned).<br>&gt; <br>&gt; – Steve<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160826/6b173a55/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d042be5dcfe90e649f760303af3e429?s=50"></div><header><strong>Why are BinaryFloatingPoint&#39;s RawSignificand and RawExponent different type?</strong> from <string>Jens Persson</string> &lt;jens at bitcycle.com&gt;<p>August 27, 2016 at 01:00:00am</p></header><div class="content"><p>I understand.<br>It&#39;s just very tempting to try and use the new static computed properties<br>for eg 23 and 52 etc.<br>I guess I&#39;ll just have to write a lot of boilerplate, or perhaps a protocol<br>that is just implemented by Double and Float (that will be very similar to<br>BinaryFloatingPoint in a lot of ways).<br>/Jens<br></p><p>On Sat, Aug 27, 2016 at 1:25 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br></p><p>&gt; This doesn’t really scale up very well, though.  BinaryFloatingPoint needs<br>&gt; to also be able to model e.g. Float2048 or similar; we generally don&#39;t want<br>&gt; to require that RawExponent to be the same type as RawSignificand (which I<br>&gt; think is what you’re really suggesting), because in typical bignum usage<br>&gt; significands are much larger than exponents.<br>&gt;<br>&gt; It sounds like maybe you actually want to be operating directly on<br>&gt; bitPatterns, rather than the abstract fields of the types.<br>&gt;<br>&gt; – Steve<br>&gt;<br>&gt; On Aug 26, 2016, at 7:21 PM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt;<br>&gt; Oh, to more directly answer your question: I don&#39;t like having to create a<br>&gt; UInt (UInt64) value when all my bit manipulaton code happens in UInt32 (for<br>&gt; Float) for example.<br>&gt;<br>&gt; The most probable context for using these computed properties and types of<br>&gt; BinaryFloatingPoint is one in which specific fixed width types really<br>&gt; matters a lot (look at the name of the protocol and the properties and<br>&gt; assocated types we are talking about).<br>&gt;<br>&gt; /Jens<br>&gt;<br>&gt;<br>&gt; On Sat, Aug 27, 2016 at 1:15 AM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt;<br>&gt;&gt; Reason for asking is that I have this:<br>&gt;&gt;<br>&gt;&gt; extension Double {<br>&gt;&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;&gt;         let bitPattern = s | (1023 &lt;&lt; 52)<br>&gt;&gt;         self = unsafeBitCast(bitPattern, to: Double.self) - 1.0<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; extension Float {<br>&gt;&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;&gt;         let bitPattern = s | (127 &lt;&lt; 23)<br>&gt;&gt;         self = unsafeBitCast(bitPattern, to: Float.self) - 1.0<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; But they would be better as:<br>&gt;&gt; extension BinaryFloatingPoint {<br>&gt;&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;&gt;         ... problems here, have to try casting things into<br>&gt;&gt; RawSignificand&#39;s type ...<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Please have a go at that and perhaps you see what I mean or you will come<br>&gt;&gt; up with a nice solution that I have missed. (Speed is very important btw.)<br>&gt;&gt;<br>&gt;&gt; /Jens<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Sat, Aug 27, 2016 at 1:02 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; &gt; On Aug 26, 2016, at 6:06 PM, Jens Persson via swift-dev &lt;<br>&gt;&gt;&gt; swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I can understand why<br>&gt;&gt;&gt; &gt; Double.RawSignificand is UInt64<br>&gt;&gt;&gt; &gt; and<br>&gt;&gt;&gt; &gt; Float.RawSignificand is UInt32<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; But I can&#39;t understand why both<br>&gt;&gt;&gt; &gt; Double.RawExponent<br>&gt;&gt;&gt; &gt; and<br>&gt;&gt;&gt; &gt; Float.RawExponent<br>&gt;&gt;&gt; &gt; should be UInt.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Why aren&#39;t they also just UInt64 and UInt32, resp.?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Let me flip the question: why would they be UInt64 and UInt32?  Absent a<br>&gt;&gt;&gt; reason to prefer a specific fixed-with type, Swift integers should<br>&gt;&gt;&gt; generally default to being [U]Int (and ideally Int, but RawExponent is<br>&gt;&gt;&gt; Unsigned).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; – Steve<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160827/41bd07b6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d042be5dcfe90e649f760303af3e429?s=50"></div><header><strong>Why are BinaryFloatingPoint&#39;s RawSignificand and RawExponent different type?</strong> from <string>Jens Persson</string> &lt;jens at bitcycle.com&gt;<p>August 27, 2016 at 01:00:00am</p></header><div class="content"><p>Correction &quot; ... a protocol that only Double and Float conforms to ...&quot;.<br></p><p>On Sat, Aug 27, 2016 at 1:30 AM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br></p><p>&gt; I understand.<br>&gt; It&#39;s just very tempting to try and use the new static computed properties<br>&gt; for eg 23 and 52 etc.<br>&gt; I guess I&#39;ll just have to write a lot of boilerplate, or perhaps a<br>&gt; protocol that is just implemented by Double and Float (that will be very<br>&gt; similar to BinaryFloatingPoint in a lot of ways).<br>&gt; /Jens<br>&gt;<br>&gt; On Sat, Aug 27, 2016 at 1:25 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt; This doesn’t really scale up very well, though.  BinaryFloatingPoint<br>&gt;&gt; needs to also be able to model e.g. Float2048 or similar; we generally<br>&gt;&gt; don&#39;t want to require that RawExponent to be the same type as<br>&gt;&gt; RawSignificand (which I think is what you’re really suggesting), because in<br>&gt;&gt; typical bignum usage significands are much larger than exponents.<br>&gt;&gt;<br>&gt;&gt; It sounds like maybe you actually want to be operating directly on<br>&gt;&gt; bitPatterns, rather than the abstract fields of the types.<br>&gt;&gt;<br>&gt;&gt; – Steve<br>&gt;&gt;<br>&gt;&gt; On Aug 26, 2016, at 7:21 PM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Oh, to more directly answer your question: I don&#39;t like having to create<br>&gt;&gt; a UInt (UInt64) value when all my bit manipulaton code happens in UInt32<br>&gt;&gt; (for Float) for example.<br>&gt;&gt;<br>&gt;&gt; The most probable context for using these computed properties and types<br>&gt;&gt; of BinaryFloatingPoint is one in which specific fixed width types really<br>&gt;&gt; matters a lot (look at the name of the protocol and the properties and<br>&gt;&gt; assocated types we are talking about).<br>&gt;&gt;<br>&gt;&gt; /Jens<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Sat, Aug 27, 2016 at 1:15 AM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Reason for asking is that I have this:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; extension Double {<br>&gt;&gt;&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;&gt;&gt;         let bitPattern = s | (1023 &lt;&lt; 52)<br>&gt;&gt;&gt;         self = unsafeBitCast(bitPattern, to: Double.self) - 1.0<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; extension Float {<br>&gt;&gt;&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;&gt;&gt;         let bitPattern = s | (127 &lt;&lt; 23)<br>&gt;&gt;&gt;         self = unsafeBitCast(bitPattern, to: Float.self) - 1.0<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; But they would be better as:<br>&gt;&gt;&gt; extension BinaryFloatingPoint {<br>&gt;&gt;&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;&gt;&gt;         ... problems here, have to try casting things into<br>&gt;&gt;&gt; RawSignificand&#39;s type ...<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Please have a go at that and perhaps you see what I mean or you will<br>&gt;&gt;&gt; come up with a nice solution that I have missed. (Speed is very important<br>&gt;&gt;&gt; btw.)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; /Jens<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Sat, Aug 27, 2016 at 1:02 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt; On Aug 26, 2016, at 6:06 PM, Jens Persson via swift-dev &lt;<br>&gt;&gt;&gt;&gt; swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; I can understand why<br>&gt;&gt;&gt;&gt; &gt; Double.RawSignificand is UInt64<br>&gt;&gt;&gt;&gt; &gt; and<br>&gt;&gt;&gt;&gt; &gt; Float.RawSignificand is UInt32<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; But I can&#39;t understand why both<br>&gt;&gt;&gt;&gt; &gt; Double.RawExponent<br>&gt;&gt;&gt;&gt; &gt; and<br>&gt;&gt;&gt;&gt; &gt; Float.RawExponent<br>&gt;&gt;&gt;&gt; &gt; should be UInt.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; Why aren&#39;t they also just UInt64 and UInt32, resp.?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Let me flip the question: why would they be UInt64 and UInt32?  Absent<br>&gt;&gt;&gt;&gt; a reason to prefer a specific fixed-with type, Swift integers should<br>&gt;&gt;&gt;&gt; generally default to being [U]Int (and ideally Int, but RawExponent is<br>&gt;&gt;&gt;&gt; Unsigned).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; – Steve<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160827/35cfc937/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>Why are BinaryFloatingPoint&#39;s RawSignificand and RawExponent different type?</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>August 26, 2016 at 07:00:00pm</p></header><div class="content"><p>Where does your RawSignificand input come from?  Is that really the type that you want?<br></p><p>I don’t think you really need very much boilerplate at all here.<br></p><p>&gt; On Aug 26, 2016, at 7:30 PM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt; <br>&gt; I understand.<br>&gt; It&#39;s just very tempting to try and use the new static computed properties for eg 23 and 52 etc.<br>&gt; I guess I&#39;ll just have to write a lot of boilerplate, or perhaps a protocol that is just implemented by Double and Float (that will be very similar to BinaryFloatingPoint in a lot of ways).<br>&gt; /Jens<br>&gt; <br>&gt; On Sat, Aug 27, 2016 at 1:25 AM, Stephen Canon &lt;scanon at apple.com &lt;mailto:scanon at apple.com&gt;&gt; wrote:<br>&gt; This doesn’t really scale up very well, though.  BinaryFloatingPoint needs to also be able to model e.g. Float2048 or similar; we generally don&#39;t want to require that RawExponent to be the same type as RawSignificand (which I think is what you’re really suggesting), because in typical bignum usage significands are much larger than exponents.<br>&gt; <br>&gt; It sounds like maybe you actually want to be operating directly on bitPatterns, rather than the abstract fields of the types.<br>&gt; <br>&gt; – Steve<br>&gt; <br>&gt;&gt; On Aug 26, 2016, at 7:21 PM, Jens Persson &lt;jens at bitcycle.com &lt;mailto:jens at bitcycle.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Oh, to more directly answer your question: I don&#39;t like having to create a UInt (UInt64) value when all my bit manipulaton code happens in UInt32 (for Float) for example.<br>&gt;&gt; <br>&gt;&gt; The most probable context for using these computed properties and types of BinaryFloatingPoint is one in which specific fixed width types really matters a lot (look at the name of the protocol and the properties and assocated types we are talking about).<br>&gt;&gt; <br>&gt;&gt; /Jens<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Sat, Aug 27, 2016 at 1:15 AM, Jens Persson &lt;jens at bitcycle.com &lt;mailto:jens at bitcycle.com&gt;&gt; wrote:<br>&gt;&gt; Reason for asking is that I have this:<br>&gt;&gt; <br>&gt;&gt; extension Double {<br>&gt;&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;&gt;         let bitPattern = s | (1023 &lt;&lt; 52)<br>&gt;&gt;         self = unsafeBitCast(bitPattern, to: Double.self) - 1.0<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; extension Float {<br>&gt;&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;&gt;         let bitPattern = s | (127 &lt;&lt; 23)<br>&gt;&gt;         self = unsafeBitCast(bitPattern, to: Float.self) - 1.0<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; But they would be better as:<br>&gt;&gt; extension BinaryFloatingPoint {<br>&gt;&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;&gt;         ... problems here, have to try casting things into RawSignificand&#39;s type ...<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Please have a go at that and perhaps you see what I mean or you will come up with a nice solution that I have missed. (Speed is very important btw.)<br>&gt;&gt; <br>&gt;&gt; /Jens<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Sat, Aug 27, 2016 at 1:02 AM, Stephen Canon &lt;scanon at apple.com &lt;mailto:scanon at apple.com&gt;&gt; wrote:<br>&gt;&gt; &gt; On Aug 26, 2016, at 6:06 PM, Jens Persson via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I can understand why<br>&gt;&gt; &gt; Double.RawSignificand is UInt64<br>&gt;&gt; &gt; and<br>&gt;&gt; &gt; Float.RawSignificand is UInt32<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; But I can&#39;t understand why both<br>&gt;&gt; &gt; Double.RawExponent<br>&gt;&gt; &gt; and<br>&gt;&gt; &gt; Float.RawExponent<br>&gt;&gt; &gt; should be UInt.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Why aren&#39;t they also just UInt64 and UInt32, resp.?<br>&gt;&gt; <br>&gt;&gt; Let me flip the question: why would they be UInt64 and UInt32?  Absent a reason to prefer a specific fixed-with type, Swift integers should generally default to being [U]Int (and ideally Int, but RawExponent is Unsigned).<br>&gt;&gt; <br>&gt;&gt; – Steve<br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160826/7c28a94e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d042be5dcfe90e649f760303af3e429?s=50"></div><header><strong>Why are BinaryFloatingPoint&#39;s RawSignificand and RawExponent different type?</strong> from <string>Jens Persson</string> &lt;jens at bitcycle.com&gt;<p>August 27, 2016 at 01:00:00am</p></header><div class="content"><p>The above is just a useful init for Double and Float. For example I use it<br>for creating random Double&#39;s and Float&#39;s in the unit range [0, 1) from 64<br>bit prng like xorshift128Plus or xoroshiro128Plus.<br></p><p>It would also be used when trying to write something like this:<br></p><p>Double.init(unitRangeMapped value: Int8)<br>Double.init(unitRangeMapped value: UInt8)<br>Double.init(unitRangeMapped value: Int16)<br>Double.init(unitRangeMapped value: UInt16)<br>...<br>Float.init(unitRangeMapped value: Int8)<br>Float.init(unitRangeMapped value: UInt8)<br>Float.init(unitRangeMapped value: Int16)<br>Float.init(unitRangeMapped value: UInt16)<br>...<br></p><p>Or perhaps that could be better written the other way around, as instance<br>methods for all IntegerTypes, result in Float and Double:<br></p><p>let f: Float = UInt8(123).mappedToUnitRange<br>let d: Double = Int8(-123).mappedToUnitRange<br></p><p>in any case, it would be nice if I could write these as one method (or<br>computed property) in a protocol extension.<br></p><p>/Jens<br></p><p>On Sat, Aug 27, 2016 at 1:38 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br></p><p>&gt; Where does your RawSignificand input come from?  Is that really the type<br>&gt; that you want?<br>&gt;<br>&gt; I don’t think you really need very much boilerplate at all here.<br>&gt;<br>&gt; On Aug 26, 2016, at 7:30 PM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt;<br>&gt; I understand.<br>&gt; It&#39;s just very tempting to try and use the new static computed properties<br>&gt; for eg 23 and 52 etc.<br>&gt; I guess I&#39;ll just have to write a lot of boilerplate, or perhaps a<br>&gt; protocol that is just implemented by Double and Float (that will be very<br>&gt; similar to BinaryFloatingPoint in a lot of ways).<br>&gt; /Jens<br>&gt;<br>&gt; On Sat, Aug 27, 2016 at 1:25 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt; This doesn’t really scale up very well, though.  BinaryFloatingPoint<br>&gt;&gt; needs to also be able to model e.g. Float2048 or similar; we generally<br>&gt;&gt; don&#39;t want to require that RawExponent to be the same type as<br>&gt;&gt; RawSignificand (which I think is what you’re really suggesting), because in<br>&gt;&gt; typical bignum usage significands are much larger than exponents.<br>&gt;&gt;<br>&gt;&gt; It sounds like maybe you actually want to be operating directly on<br>&gt;&gt; bitPatterns, rather than the abstract fields of the types.<br>&gt;&gt;<br>&gt;&gt; – Steve<br>&gt;&gt;<br>&gt;&gt; On Aug 26, 2016, at 7:21 PM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Oh, to more directly answer your question: I don&#39;t like having to create<br>&gt;&gt; a UInt (UInt64) value when all my bit manipulaton code happens in UInt32<br>&gt;&gt; (for Float) for example.<br>&gt;&gt;<br>&gt;&gt; The most probable context for using these computed properties and types<br>&gt;&gt; of BinaryFloatingPoint is one in which specific fixed width types really<br>&gt;&gt; matters a lot (look at the name of the protocol and the properties and<br>&gt;&gt; assocated types we are talking about).<br>&gt;&gt;<br>&gt;&gt; /Jens<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Sat, Aug 27, 2016 at 1:15 AM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Reason for asking is that I have this:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; extension Double {<br>&gt;&gt;&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;&gt;&gt;         let bitPattern = s | (1023 &lt;&lt; 52)<br>&gt;&gt;&gt;         self = unsafeBitCast(bitPattern, to: Double.self) - 1.0<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; extension Float {<br>&gt;&gt;&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;&gt;&gt;         let bitPattern = s | (127 &lt;&lt; 23)<br>&gt;&gt;&gt;         self = unsafeBitCast(bitPattern, to: Float.self) - 1.0<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; But they would be better as:<br>&gt;&gt;&gt; extension BinaryFloatingPoint {<br>&gt;&gt;&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;&gt;&gt;         ... problems here, have to try casting things into<br>&gt;&gt;&gt; RawSignificand&#39;s type ...<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Please have a go at that and perhaps you see what I mean or you will<br>&gt;&gt;&gt; come up with a nice solution that I have missed. (Speed is very important<br>&gt;&gt;&gt; btw.)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; /Jens<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Sat, Aug 27, 2016 at 1:02 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt; On Aug 26, 2016, at 6:06 PM, Jens Persson via swift-dev &lt;<br>&gt;&gt;&gt;&gt; swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; I can understand why<br>&gt;&gt;&gt;&gt; &gt; Double.RawSignificand is UInt64<br>&gt;&gt;&gt;&gt; &gt; and<br>&gt;&gt;&gt;&gt; &gt; Float.RawSignificand is UInt32<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; But I can&#39;t understand why both<br>&gt;&gt;&gt;&gt; &gt; Double.RawExponent<br>&gt;&gt;&gt;&gt; &gt; and<br>&gt;&gt;&gt;&gt; &gt; Float.RawExponent<br>&gt;&gt;&gt;&gt; &gt; should be UInt.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; Why aren&#39;t they also just UInt64 and UInt32, resp.?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Let me flip the question: why would they be UInt64 and UInt32?  Absent<br>&gt;&gt;&gt;&gt; a reason to prefer a specific fixed-with type, Swift integers should<br>&gt;&gt;&gt;&gt; generally default to being [U]Int (and ideally Int, but RawExponent is<br>&gt;&gt;&gt;&gt; Unsigned).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; – Steve<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160827/ce03a74a/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>Why are BinaryFloatingPoint&#39;s RawSignificand and RawExponent different type?</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>August 26, 2016 at 07:00:00pm</p></header><div class="content"><p>Assuming RawSignificand really is the type you want, I think this does what you’re looking for?<br></p><p>protocol BinaryFloatingPointWithBitPattern: BinaryFloatingPoint {<br>    init(bitPattern: RawSignificand)<br>    var bitPattern: RawSignificand { get }<br>}<br></p><p>extension Float: BinaryFloatingPointWithBitPattern { }<br>extension Double: BinaryFloatingPointWithBitPattern { }<br></p><p>extension BinaryFloatingPointWithBitPattern {<br>    init(unitRangeFromRawSignificand s: RawSignificand) {<br>        self = Self(bitPattern: Self(1).bitPattern | s) - 1<br>    }<br>}<br></p><p>&gt; On Aug 26, 2016, at 7:38 PM, Stephen Canon via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Where does your RawSignificand input come from?  Is that really the type that you want?<br>&gt; <br>&gt; I don’t think you really need very much boilerplate at all here.<br>&gt; <br>&gt;&gt; On Aug 26, 2016, at 7:30 PM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I understand.<br>&gt;&gt; It&#39;s just very tempting to try and use the new static computed properties for eg 23 and 52 etc.<br>&gt;&gt; I guess I&#39;ll just have to write a lot of boilerplate, or perhaps a protocol that is just implemented by Double and Float (that will be very similar to BinaryFloatingPoint in a lot of ways).<br>&gt;&gt; /Jens<br>&gt;&gt; <br>&gt;&gt; On Sat, Aug 27, 2016 at 1:25 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;&gt; This doesn’t really scale up very well, though.  BinaryFloatingPoint needs to also be able to model e.g. Float2048 or similar; we generally don&#39;t want to require that RawExponent to be the same type as RawSignificand (which I think is what you’re really suggesting), because in typical bignum usage significands are much larger than exponents.<br>&gt;&gt; <br>&gt;&gt; It sounds like maybe you actually want to be operating directly on bitPatterns, rather than the abstract fields of the types.<br>&gt;&gt; <br>&gt;&gt; – Steve<br>&gt;&gt; <br>&gt;&gt;&gt; On Aug 26, 2016, at 7:21 PM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Oh, to more directly answer your question: I don&#39;t like having to create a UInt (UInt64) value when all my bit manipulaton code happens in UInt32 (for Float) for example.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The most probable context for using these computed properties and types of BinaryFloatingPoint is one in which specific fixed width types really matters a lot (look at the name of the protocol and the properties and assocated types we are talking about).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; /Jens<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Sat, Aug 27, 2016 at 1:15 AM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt;&gt;&gt; Reason for asking is that I have this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Double {<br>&gt;&gt;&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;&gt;&gt;         let bitPattern = s | (1023 &lt;&lt; 52)<br>&gt;&gt;&gt;         self = unsafeBitCast(bitPattern, to: Double.self) - 1.0<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; extension Float {<br>&gt;&gt;&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;&gt;&gt;         let bitPattern = s | (127 &lt;&lt; 23)<br>&gt;&gt;&gt;         self = unsafeBitCast(bitPattern, to: Float.self) - 1.0<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But they would be better as:<br>&gt;&gt;&gt; extension BinaryFloatingPoint {<br>&gt;&gt;&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;&gt;&gt;         ... problems here, have to try casting things into RawSignificand&#39;s type ...<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Please have a go at that and perhaps you see what I mean or you will come up with a nice solution that I have missed. (Speed is very important btw.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; /Jens<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Sat, Aug 27, 2016 at 1:02 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;&gt;&gt; &gt; On Aug 26, 2016, at 6:06 PM, Jens Persson via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I can understand why<br>&gt;&gt;&gt; &gt; Double.RawSignificand is UInt64<br>&gt;&gt;&gt; &gt; and<br>&gt;&gt;&gt; &gt; Float.RawSignificand is UInt32<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; But I can&#39;t understand why both<br>&gt;&gt;&gt; &gt; Double.RawExponent<br>&gt;&gt;&gt; &gt; and<br>&gt;&gt;&gt; &gt; Float.RawExponent<br>&gt;&gt;&gt; &gt; should be UInt.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Why aren&#39;t they also just UInt64 and UInt32, resp.?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Let me flip the question: why would they be UInt64 and UInt32?  Absent a reason to prefer a specific fixed-with type, Swift integers should generally default to being [U]Int (and ideally Int, but RawExponent is Unsigned).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; – Steve<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160826/aaa8d1c3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>Why are BinaryFloatingPoint&#39;s RawSignificand and RawExponent different type?</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>August 26, 2016 at 07:00:00pm</p></header><div class="content"><p>If BinaryFloatingPoint had init(_: RawSignificand), you could also just write:<br></p><p>extension BinaryFloatingPoint {<br>    init(unitRangeFromRawSignificand s: RawSignificand) {<br>        self = Self(s) * .ulpOfOne<br>    }<br>}<br></p><p>(this is why I ask if RawSignificand is really the type you want; if you use some concrete integer type this will work).  But once we have all the new integer protocol conformances, we’ll have a generic init from any integer type (this was already reviewed for FloatingPoint, but isn’t implementable without the Integer support), which will also make this possible.<br></p><p>&gt; On Aug 26, 2016, at 7:47 PM, Stephen Canon via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Assuming RawSignificand really is the type you want, I think this does what you’re looking for?<br>&gt; <br>&gt; protocol BinaryFloatingPointWithBitPattern: BinaryFloatingPoint {<br>&gt;     init(bitPattern: RawSignificand)<br>&gt;     var bitPattern: RawSignificand { get }<br>&gt; }<br>&gt; <br>&gt; extension Float: BinaryFloatingPointWithBitPattern { }<br>&gt; extension Double: BinaryFloatingPointWithBitPattern { }<br>&gt; <br>&gt; extension BinaryFloatingPointWithBitPattern {<br>&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;         self = Self(bitPattern: Self(1).bitPattern | s) - 1<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt;&gt; On Aug 26, 2016, at 7:38 PM, Stephen Canon via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Where does your RawSignificand input come from?  Is that really the type that you want?<br>&gt;&gt; <br>&gt;&gt; I don’t think you really need very much boilerplate at all here.<br>&gt;&gt; <br>&gt;&gt;&gt; On Aug 26, 2016, at 7:30 PM, Jens Persson &lt;jens at bitcycle.com &lt;mailto:jens at bitcycle.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I understand.<br>&gt;&gt;&gt; It&#39;s just very tempting to try and use the new static computed properties for eg 23 and 52 etc.<br>&gt;&gt;&gt; I guess I&#39;ll just have to write a lot of boilerplate, or perhaps a protocol that is just implemented by Double and Float (that will be very similar to BinaryFloatingPoint in a lot of ways).<br>&gt;&gt;&gt; /Jens<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Sat, Aug 27, 2016 at 1:25 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;&gt;&gt; This doesn’t really scale up very well, though.  BinaryFloatingPoint needs to also be able to model e.g. Float2048 or similar; we generally don&#39;t want to require that RawExponent to be the same type as RawSignificand (which I think is what you’re really suggesting), because in typical bignum usage significands are much larger than exponents.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It sounds like maybe you actually want to be operating directly on bitPatterns, rather than the abstract fields of the types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; – Steve<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Aug 26, 2016, at 7:21 PM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Oh, to more directly answer your question: I don&#39;t like having to create a UInt (UInt64) value when all my bit manipulaton code happens in UInt32 (for Float) for example.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The most probable context for using these computed properties and types of BinaryFloatingPoint is one in which specific fixed width types really matters a lot (look at the name of the protocol and the properties and assocated types we are talking about).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; /Jens<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Sat, Aug 27, 2016 at 1:15 AM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt;&gt;&gt;&gt; Reason for asking is that I have this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension Double {<br>&gt;&gt;&gt;&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;&gt;&gt;&gt;         let bitPattern = s | (1023 &lt;&lt; 52)<br>&gt;&gt;&gt;&gt;         self = unsafeBitCast(bitPattern, to: Double.self) - 1.0<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; extension Float {<br>&gt;&gt;&gt;&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;&gt;&gt;&gt;         let bitPattern = s | (127 &lt;&lt; 23)<br>&gt;&gt;&gt;&gt;         self = unsafeBitCast(bitPattern, to: Float.self) - 1.0<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; But they would be better as:<br>&gt;&gt;&gt;&gt; extension BinaryFloatingPoint {<br>&gt;&gt;&gt;&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;&gt;&gt;&gt;         ... problems here, have to try casting things into RawSignificand&#39;s type ...<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Please have a go at that and perhaps you see what I mean or you will come up with a nice solution that I have missed. (Speed is very important btw.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; /Jens<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Sat, Aug 27, 2016 at 1:02 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt; On Aug 26, 2016, at 6:06 PM, Jens Persson via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; I can understand why<br>&gt;&gt;&gt;&gt; &gt; Double.RawSignificand is UInt64<br>&gt;&gt;&gt;&gt; &gt; and<br>&gt;&gt;&gt;&gt; &gt; Float.RawSignificand is UInt32<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; But I can&#39;t understand why both<br>&gt;&gt;&gt;&gt; &gt; Double.RawExponent<br>&gt;&gt;&gt;&gt; &gt; and<br>&gt;&gt;&gt;&gt; &gt; Float.RawExponent<br>&gt;&gt;&gt;&gt; &gt; should be UInt.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; Why aren&#39;t they also just UInt64 and UInt32, resp.?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Let me flip the question: why would they be UInt64 and UInt32?  Absent a reason to prefer a specific fixed-with type, Swift integers should generally default to being [U]Int (and ideally Int, but RawExponent is Unsigned).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; – Steve<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160826/f666b894/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d042be5dcfe90e649f760303af3e429?s=50"></div><header><strong>Why are BinaryFloatingPoint&#39;s RawSignificand and RawExponent different type?</strong> from <string>Jens Persson</string> &lt;jens at bitcycle.com&gt;<p>August 27, 2016 at 02:00:00am</p></header><div class="content"><p>Thanks, but there seem to be something not working the same as in my<br>original code, here is a quick test of your code:<br></p><p>protocol BinaryFloatingPointWithBitPattern: BinaryFloatingPoint {<br>    init(bitPattern: RawSignificand)<br>    var bitPattern: RawSignificand { get }<br>}<br></p><p>extension Float: BinaryFloatingPointWithBitPattern { }<br>extension Double: BinaryFloatingPointWithBitPattern { }<br></p><p>extension BinaryFloatingPointWithBitPattern {<br>    init(unitRangeFromRawSignificand s: RawSignificand) {<br>        self = Self(bitPattern: Self(1).bitPattern | s) - 1<br>    }<br>}<br></p><p>typealias T = Double<br>// typealias T = Float<br></p><p>let allSignificantBitsSet = T.RawSignificand((1 &lt;&lt; T.significandBitCount) -<br>1)<br>print(&quot;bits set in signigicant:&quot;, String(allSignificantBitsSet, radix:<br>2).characters.count) // 52<br>let a = T.init(bitPattern: 0)<br>let b = T.init(bitPattern: allSignificantBitsSet)<br>print(a) // 0.0, correct.<br>print(b) // 2.2250738585072e-308. Wrong, this should be (1.0).nextDown.<br></p><p><br>On Sat, Aug 27, 2016 at 1:57 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br></p><p>&gt; If BinaryFloatingPoint had init(_: RawSignificand), you could also just<br>&gt; write:<br>&gt;<br>&gt; extension BinaryFloatingPoint {<br>&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;         self = Self(s) * .ulpOfOne<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; (this is why I ask if RawSignificand is really the type you want; if you<br>&gt; use some concrete integer type this will work).  But once we have all the<br>&gt; new integer protocol conformances, we’ll have a generic init from any<br>&gt; integer type (this was already reviewed for FloatingPoint, but isn’t<br>&gt; implementable without the Integer support), which will also make this<br>&gt; possible.<br>&gt;<br>&gt; On Aug 26, 2016, at 7:47 PM, Stephen Canon via swift-dev &lt;<br>&gt; swift-dev at swift.org&gt; wrote:<br>&gt;<br>&gt; Assuming RawSignificand really is the type you want, I think this does<br>&gt; what you’re looking for?<br>&gt;<br>&gt; protocol BinaryFloatingPointWithBitPattern: BinaryFloatingPoint {<br>&gt;     init(bitPattern: RawSignificand)<br>&gt;     var bitPattern: RawSignificand { get }<br>&gt; }<br>&gt;<br>&gt; extension Float: BinaryFloatingPointWithBitPattern { }<br>&gt; extension Double: BinaryFloatingPointWithBitPattern { }<br>&gt;<br>&gt; extension BinaryFloatingPointWithBitPattern {<br>&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;         self = Self(bitPattern: Self(1).bitPattern | s) - 1<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; On Aug 26, 2016, at 7:38 PM, Stephen Canon via swift-dev &lt;<br>&gt; swift-dev at swift.org&gt; wrote:<br>&gt;<br>&gt; Where does your RawSignificand input come from?  Is that really the type<br>&gt; that you want?<br>&gt;<br>&gt; I don’t think you really need very much boilerplate at all here.<br>&gt;<br>&gt; On Aug 26, 2016, at 7:30 PM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt;<br>&gt; I understand.<br>&gt; It&#39;s just very tempting to try and use the new static computed properties<br>&gt; for eg 23 and 52 etc.<br>&gt; I guess I&#39;ll just have to write a lot of boilerplate, or perhaps a<br>&gt; protocol that is just implemented by Double and Float (that will be very<br>&gt; similar to BinaryFloatingPoint in a lot of ways).<br>&gt; /Jens<br>&gt;<br>&gt; On Sat, Aug 27, 2016 at 1:25 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt; This doesn’t really scale up very well, though.  BinaryFloatingPoint needs<br>&gt; to also be able to model e.g. Float2048 or similar; we generally don&#39;t want<br>&gt; to require that RawExponent to be the same type as RawSignificand (which I<br>&gt; think is what you’re really suggesting), because in typical bignum usage<br>&gt; significands are much larger than exponents.<br>&gt;<br>&gt; It sounds like maybe you actually want to be operating directly on<br>&gt; bitPatterns, rather than the abstract fields of the types.<br>&gt;<br>&gt; – Steve<br>&gt;<br>&gt; On Aug 26, 2016, at 7:21 PM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt;<br>&gt; Oh, to more directly answer your question: I don&#39;t like having to create a<br>&gt; UInt (UInt64) value when all my bit manipulaton code happens in UInt32 (for<br>&gt; Float) for example.<br>&gt;<br>&gt; The most probable context for using these computed properties and types of<br>&gt; BinaryFloatingPoint is one in which specific fixed width types really<br>&gt; matters a lot (look at the name of the protocol and the properties and<br>&gt; assocated types we are talking about).<br>&gt;<br>&gt; /Jens<br>&gt;<br>&gt;<br>&gt; On Sat, Aug 27, 2016 at 1:15 AM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt; Reason for asking is that I have this:<br>&gt;<br>&gt; extension Double {<br>&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;         let bitPattern = s | (1023 &lt;&lt; 52)<br>&gt;         self = unsafeBitCast(bitPattern, to: Double.self) - 1.0<br>&gt;     }<br>&gt; }<br>&gt; extension Float {<br>&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;         let bitPattern = s | (127 &lt;&lt; 23)<br>&gt;         self = unsafeBitCast(bitPattern, to: Float.self) - 1.0<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; But they would be better as:<br>&gt; extension BinaryFloatingPoint {<br>&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;         ... problems here, have to try casting things into<br>&gt; RawSignificand&#39;s type ...<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; Please have a go at that and perhaps you see what I mean or you will come<br>&gt; up with a nice solution that I have missed. (Speed is very important btw.)<br>&gt;<br>&gt; /Jens<br>&gt;<br>&gt;<br>&gt; On Sat, Aug 27, 2016 at 1:02 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt; &gt; On Aug 26, 2016, at 6:06 PM, Jens Persson via swift-dev &lt;<br>&gt; swift-dev at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I can understand why<br>&gt; &gt; Double.RawSignificand is UInt64<br>&gt; &gt; and<br>&gt; &gt; Float.RawSignificand is UInt32<br>&gt; &gt;<br>&gt; &gt; But I can&#39;t understand why both<br>&gt; &gt; Double.RawExponent<br>&gt; &gt; and<br>&gt; &gt; Float.RawExponent<br>&gt; &gt; should be UInt.<br>&gt; &gt;<br>&gt; &gt; Why aren&#39;t they also just UInt64 and UInt32, resp.?<br>&gt;<br>&gt; Let me flip the question: why would they be UInt64 and UInt32?  Absent a<br>&gt; reason to prefer a specific fixed-with type, Swift integers should<br>&gt; generally default to being [U]Int (and ideally Int, but RawExponent<br>&gt; is Unsigned).<br>&gt;<br>&gt; – Steve<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160827/2209dcc8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d042be5dcfe90e649f760303af3e429?s=50"></div><header><strong>Why are BinaryFloatingPoint&#39;s RawSignificand and RawExponent different type?</strong> from <string>Jens Persson</string> &lt;jens at bitcycle.com&gt;<p>August 27, 2016 at 02:00:00am</p></header><div class="content"><p>Ouch, saw my mistake : )<br></p><p>On Sat, Aug 27, 2016 at 2:00 AM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br></p><p>&gt; Thanks, but there seem to be something not working the same as in my<br>&gt; original code, here is a quick test of your code:<br>&gt;<br>&gt; protocol BinaryFloatingPointWithBitPattern: BinaryFloatingPoint {<br>&gt;     init(bitPattern: RawSignificand)<br>&gt;     var bitPattern: RawSignificand { get }<br>&gt; }<br>&gt;<br>&gt; extension Float: BinaryFloatingPointWithBitPattern { }<br>&gt; extension Double: BinaryFloatingPointWithBitPattern { }<br>&gt;<br>&gt; extension BinaryFloatingPointWithBitPattern {<br>&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;         self = Self(bitPattern: Self(1).bitPattern | s) - 1<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; typealias T = Double<br>&gt; // typealias T = Float<br>&gt;<br>&gt; let allSignificantBitsSet = T.RawSignificand((1 &lt;&lt; T.significandBitCount)<br>&gt; - 1)<br>&gt; print(&quot;bits set in signigicant:&quot;, String(allSignificantBitsSet, radix:<br>&gt; 2).characters.count) // 52<br>&gt; let a = T.init(bitPattern: 0)<br>&gt; let b = T.init(bitPattern: allSignificantBitsSet)<br>&gt; print(a) // 0.0, correct.<br>&gt; print(b) // 2.2250738585072e-308. Wrong, this should be (1.0).nextDown.<br>&gt;<br>&gt;<br>&gt; On Sat, Aug 27, 2016 at 1:57 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt; If BinaryFloatingPoint had init(_: RawSignificand), you could also just<br>&gt;&gt; write:<br>&gt;&gt;<br>&gt;&gt; extension BinaryFloatingPoint {<br>&gt;&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;&gt;         self = Self(s) * .ulpOfOne<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; (this is why I ask if RawSignificand is really the type you want; if you<br>&gt;&gt; use some concrete integer type this will work).  But once we have all the<br>&gt;&gt; new integer protocol conformances, we’ll have a generic init from any<br>&gt;&gt; integer type (this was already reviewed for FloatingPoint, but isn’t<br>&gt;&gt; implementable without the Integer support), which will also make this<br>&gt;&gt; possible.<br>&gt;&gt;<br>&gt;&gt; On Aug 26, 2016, at 7:47 PM, Stephen Canon via swift-dev &lt;<br>&gt;&gt; swift-dev at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Assuming RawSignificand really is the type you want, I think this does<br>&gt;&gt; what you’re looking for?<br>&gt;&gt;<br>&gt;&gt; protocol BinaryFloatingPointWithBitPattern: BinaryFloatingPoint {<br>&gt;&gt;     init(bitPattern: RawSignificand)<br>&gt;&gt;     var bitPattern: RawSignificand { get }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; extension Float: BinaryFloatingPointWithBitPattern { }<br>&gt;&gt; extension Double: BinaryFloatingPointWithBitPattern { }<br>&gt;&gt;<br>&gt;&gt; extension BinaryFloatingPointWithBitPattern {<br>&gt;&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;&gt;         self = Self(bitPattern: Self(1).bitPattern | s) - 1<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; On Aug 26, 2016, at 7:38 PM, Stephen Canon via swift-dev &lt;<br>&gt;&gt; swift-dev at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Where does your RawSignificand input come from?  Is that really the type<br>&gt;&gt; that you want?<br>&gt;&gt;<br>&gt;&gt; I don’t think you really need very much boilerplate at all here.<br>&gt;&gt;<br>&gt;&gt; On Aug 26, 2016, at 7:30 PM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I understand.<br>&gt;&gt; It&#39;s just very tempting to try and use the new static computed properties<br>&gt;&gt; for eg 23 and 52 etc.<br>&gt;&gt; I guess I&#39;ll just have to write a lot of boilerplate, or perhaps a<br>&gt;&gt; protocol that is just implemented by Double and Float (that will be very<br>&gt;&gt; similar to BinaryFloatingPoint in a lot of ways).<br>&gt;&gt; /Jens<br>&gt;&gt;<br>&gt;&gt; On Sat, Aug 27, 2016 at 1:25 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;&gt; This doesn’t really scale up very well, though.  BinaryFloatingPoint<br>&gt;&gt; needs to also be able to model e.g. Float2048 or similar; we generally<br>&gt;&gt; don&#39;t want to require that RawExponent to be the same type as<br>&gt;&gt; RawSignificand (which I think is what you’re really suggesting), because in<br>&gt;&gt; typical bignum usage significands are much larger than exponents.<br>&gt;&gt;<br>&gt;&gt; It sounds like maybe you actually want to be operating directly on<br>&gt;&gt; bitPatterns, rather than the abstract fields of the types.<br>&gt;&gt;<br>&gt;&gt; – Steve<br>&gt;&gt;<br>&gt;&gt; On Aug 26, 2016, at 7:21 PM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Oh, to more directly answer your question: I don&#39;t like having to create<br>&gt;&gt; a UInt (UInt64) value when all my bit manipulaton code happens in UInt32<br>&gt;&gt; (for Float) for example.<br>&gt;&gt;<br>&gt;&gt; The most probable context for using these computed properties and types<br>&gt;&gt; of BinaryFloatingPoint is one in which specific fixed width types really<br>&gt;&gt; matters a lot (look at the name of the protocol and the properties and<br>&gt;&gt; assocated types we are talking about).<br>&gt;&gt;<br>&gt;&gt; /Jens<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Sat, Aug 27, 2016 at 1:15 AM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt;&gt; Reason for asking is that I have this:<br>&gt;&gt;<br>&gt;&gt; extension Double {<br>&gt;&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;&gt;         let bitPattern = s | (1023 &lt;&lt; 52)<br>&gt;&gt;         self = unsafeBitCast(bitPattern, to: Double.self) - 1.0<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; extension Float {<br>&gt;&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;&gt;         let bitPattern = s | (127 &lt;&lt; 23)<br>&gt;&gt;         self = unsafeBitCast(bitPattern, to: Float.self) - 1.0<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; But they would be better as:<br>&gt;&gt; extension BinaryFloatingPoint {<br>&gt;&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;&gt;         ... problems here, have to try casting things into<br>&gt;&gt; RawSignificand&#39;s type ...<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Please have a go at that and perhaps you see what I mean or you will come<br>&gt;&gt; up with a nice solution that I have missed. (Speed is very important btw.)<br>&gt;&gt;<br>&gt;&gt; /Jens<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Sat, Aug 27, 2016 at 1:02 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;&gt; &gt; On Aug 26, 2016, at 6:06 PM, Jens Persson via swift-dev &lt;<br>&gt;&gt; swift-dev at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I can understand why<br>&gt;&gt; &gt; Double.RawSignificand is UInt64<br>&gt;&gt; &gt; and<br>&gt;&gt; &gt; Float.RawSignificand is UInt32<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; But I can&#39;t understand why both<br>&gt;&gt; &gt; Double.RawExponent<br>&gt;&gt; &gt; and<br>&gt;&gt; &gt; Float.RawExponent<br>&gt;&gt; &gt; should be UInt.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Why aren&#39;t they also just UInt64 and UInt32, resp.?<br>&gt;&gt;<br>&gt;&gt; Let me flip the question: why would they be UInt64 and UInt32?  Absent a<br>&gt;&gt; reason to prefer a specific fixed-with type, Swift integers should<br>&gt;&gt; generally default to being [U]Int (and ideally Int, but RawExponent<br>&gt;&gt; is Unsigned).<br>&gt;&gt;<br>&gt;&gt; – Steve<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160827/b76b88d3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d042be5dcfe90e649f760303af3e429?s=50"></div><header><strong>Why are BinaryFloatingPoint&#39;s RawSignificand and RawExponent different type?</strong> from <string>Jens Persson</string> &lt;jens at bitcycle.com&gt;<p>August 27, 2016 at 02:00:00am</p></header><div class="content"><p>...<br>let a = T.init(unitRangeFromRawSignificand: 0)<br>let b = T.init(unitRangeFromRawSignificand: allSignificantBitsSet)<br>print(a) // 0.0, correct.<br>print(b) // (1.0).nextDown<br></p><p>Thanks a lot for all your help!<br></p><p><br>On Sat, Aug 27, 2016 at 2:01 AM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br></p><p>&gt; Ouch, saw my mistake : )<br>&gt;<br>&gt; On Sat, Aug 27, 2016 at 2:00 AM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt;<br>&gt;&gt; Thanks, but there seem to be something not working the same as in my<br>&gt;&gt; original code, here is a quick test of your code:<br>&gt;&gt;<br>&gt;&gt; protocol BinaryFloatingPointWithBitPattern: BinaryFloatingPoint {<br>&gt;&gt;     init(bitPattern: RawSignificand)<br>&gt;&gt;     var bitPattern: RawSignificand { get }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; extension Float: BinaryFloatingPointWithBitPattern { }<br>&gt;&gt; extension Double: BinaryFloatingPointWithBitPattern { }<br>&gt;&gt;<br>&gt;&gt; extension BinaryFloatingPointWithBitPattern {<br>&gt;&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;&gt;         self = Self(bitPattern: Self(1).bitPattern | s) - 1<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; typealias T = Double<br>&gt;&gt; // typealias T = Float<br>&gt;&gt;<br>&gt;&gt; let allSignificantBitsSet = T.RawSignificand((1 &lt;&lt; T.significandBitCount)<br>&gt;&gt; - 1)<br>&gt;&gt; print(&quot;bits set in signigicant:&quot;, String(allSignificantBitsSet, radix:<br>&gt;&gt; 2).characters.count) // 52<br>&gt;&gt; let a = T.init(bitPattern: 0)<br>&gt;&gt; let b = T.init(bitPattern: allSignificantBitsSet)<br>&gt;&gt; print(a) // 0.0, correct.<br>&gt;&gt; print(b) // 2.2250738585072e-308. Wrong, this should be (1.0).nextDown.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Sat, Aug 27, 2016 at 1:57 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; If BinaryFloatingPoint had init(_: RawSignificand), you could also just<br>&gt;&gt;&gt; write:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; extension BinaryFloatingPoint {<br>&gt;&gt;&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;&gt;&gt;         self = Self(s) * .ulpOfOne<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; (this is why I ask if RawSignificand is really the type you want; if you<br>&gt;&gt;&gt; use some concrete integer type this will work).  But once we have all the<br>&gt;&gt;&gt; new integer protocol conformances, we’ll have a generic init from any<br>&gt;&gt;&gt; integer type (this was already reviewed for FloatingPoint, but isn’t<br>&gt;&gt;&gt; implementable without the Integer support), which will also make this<br>&gt;&gt;&gt; possible.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Aug 26, 2016, at 7:47 PM, Stephen Canon via swift-dev &lt;<br>&gt;&gt;&gt; swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Assuming RawSignificand really is the type you want, I think this does<br>&gt;&gt;&gt; what you’re looking for?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; protocol BinaryFloatingPointWithBitPattern: BinaryFloatingPoint {<br>&gt;&gt;&gt;     init(bitPattern: RawSignificand)<br>&gt;&gt;&gt;     var bitPattern: RawSignificand { get }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; extension Float: BinaryFloatingPointWithBitPattern { }<br>&gt;&gt;&gt; extension Double: BinaryFloatingPointWithBitPattern { }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; extension BinaryFloatingPointWithBitPattern {<br>&gt;&gt;&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;&gt;&gt;         self = Self(bitPattern: Self(1).bitPattern | s) - 1<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Aug 26, 2016, at 7:38 PM, Stephen Canon via swift-dev &lt;<br>&gt;&gt;&gt; swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Where does your RawSignificand input come from?  Is that really the type<br>&gt;&gt;&gt; that you want?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I don’t think you really need very much boilerplate at all here.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Aug 26, 2016, at 7:30 PM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I understand.<br>&gt;&gt;&gt; It&#39;s just very tempting to try and use the new static computed<br>&gt;&gt;&gt; properties for eg 23 and 52 etc.<br>&gt;&gt;&gt; I guess I&#39;ll just have to write a lot of boilerplate, or perhaps a<br>&gt;&gt;&gt; protocol that is just implemented by Double and Float (that will be very<br>&gt;&gt;&gt; similar to BinaryFloatingPoint in a lot of ways).<br>&gt;&gt;&gt; /Jens<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Sat, Aug 27, 2016 at 1:25 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;&gt;&gt; This doesn’t really scale up very well, though.  BinaryFloatingPoint<br>&gt;&gt;&gt; needs to also be able to model e.g. Float2048 or similar; we generally<br>&gt;&gt;&gt; don&#39;t want to require that RawExponent to be the same type as<br>&gt;&gt;&gt; RawSignificand (which I think is what you’re really suggesting), because in<br>&gt;&gt;&gt; typical bignum usage significands are much larger than exponents.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It sounds like maybe you actually want to be operating directly on<br>&gt;&gt;&gt; bitPatterns, rather than the abstract fields of the types.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; – Steve<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Aug 26, 2016, at 7:21 PM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Oh, to more directly answer your question: I don&#39;t like having to create<br>&gt;&gt;&gt; a UInt (UInt64) value when all my bit manipulaton code happens in UInt32<br>&gt;&gt;&gt; (for Float) for example.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The most probable context for using these computed properties and types<br>&gt;&gt;&gt; of BinaryFloatingPoint is one in which specific fixed width types really<br>&gt;&gt;&gt; matters a lot (look at the name of the protocol and the properties and<br>&gt;&gt;&gt; assocated types we are talking about).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; /Jens<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Sat, Aug 27, 2016 at 1:15 AM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt;&gt;&gt; Reason for asking is that I have this:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; extension Double {<br>&gt;&gt;&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;&gt;&gt;         let bitPattern = s | (1023 &lt;&lt; 52)<br>&gt;&gt;&gt;         self = unsafeBitCast(bitPattern, to: Double.self) - 1.0<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; extension Float {<br>&gt;&gt;&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;&gt;&gt;         let bitPattern = s | (127 &lt;&lt; 23)<br>&gt;&gt;&gt;         self = unsafeBitCast(bitPattern, to: Float.self) - 1.0<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; But they would be better as:<br>&gt;&gt;&gt; extension BinaryFloatingPoint {<br>&gt;&gt;&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;&gt;&gt;         ... problems here, have to try casting things into<br>&gt;&gt;&gt; RawSignificand&#39;s type ...<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Please have a go at that and perhaps you see what I mean or you will<br>&gt;&gt;&gt; come up with a nice solution that I have missed. (Speed is very important<br>&gt;&gt;&gt; btw.)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; /Jens<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Sat, Aug 27, 2016 at 1:02 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;&gt;&gt; &gt; On Aug 26, 2016, at 6:06 PM, Jens Persson via swift-dev &lt;<br>&gt;&gt;&gt; swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I can understand why<br>&gt;&gt;&gt; &gt; Double.RawSignificand is UInt64<br>&gt;&gt;&gt; &gt; and<br>&gt;&gt;&gt; &gt; Float.RawSignificand is UInt32<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; But I can&#39;t understand why both<br>&gt;&gt;&gt; &gt; Double.RawExponent<br>&gt;&gt;&gt; &gt; and<br>&gt;&gt;&gt; &gt; Float.RawExponent<br>&gt;&gt;&gt; &gt; should be UInt.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Why aren&#39;t they also just UInt64 and UInt32, resp.?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Let me flip the question: why would they be UInt64 and UInt32?  Absent a<br>&gt;&gt;&gt; reason to prefer a specific fixed-with type, Swift integers should<br>&gt;&gt;&gt; generally default to being [U]Int (and ideally Int, but RawExponent<br>&gt;&gt;&gt; is Unsigned).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; – Steve<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt; swift-dev at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt; swift-dev at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160827/cf87134d/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>Why are BinaryFloatingPoint&#39;s RawSignificand and RawExponent different type?</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>August 26, 2016 at 08:00:00pm</p></header><div class="content"><p>Note that with the bug fixed, the result will still not be 1.nextDown, because the size of an ulp changes at 1; the values you produce will be space .ulpOfOne apart, but 1.nextDown is 1 - ulpOfOne/2.<br></p><p>– Steve<br></p><p>&gt; On Aug 26, 2016, at 8:00 PM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt; <br>&gt; Thanks, but there seem to be something not working the same as in my original code, here is a quick test of your code:<br>&gt; <br>&gt; protocol BinaryFloatingPointWithBitPattern: BinaryFloatingPoint {<br>&gt;     init(bitPattern: RawSignificand)<br>&gt;     var bitPattern: RawSignificand { get }<br>&gt; }<br>&gt; <br>&gt; extension Float: BinaryFloatingPointWithBitPattern { }<br>&gt; extension Double: BinaryFloatingPointWithBitPattern { }<br>&gt; <br>&gt; extension BinaryFloatingPointWithBitPattern {<br>&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;         self = Self(bitPattern: Self(1).bitPattern | s) - 1<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; typealias T = Double<br>&gt; // typealias T = Float<br>&gt; <br>&gt; let allSignificantBitsSet = T.RawSignificand((1 &lt;&lt; T.significandBitCount) - 1)<br>&gt; print(&quot;bits set in signigicant:&quot;, String(allSignificantBitsSet, radix: 2).characters.count) // 52<br>&gt; let a = T.init(bitPattern: 0)<br>&gt; let b = T.init(bitPattern: allSignificantBitsSet)<br>&gt; print(a) // 0.0, correct.<br>&gt; print(b) // 2.2250738585072e-308. Wrong, this should be (1.0).nextDown.<br>&gt; <br>&gt; <br>&gt; On Sat, Aug 27, 2016 at 1:57 AM, Stephen Canon &lt;scanon at apple.com &lt;mailto:scanon at apple.com&gt;&gt; wrote:<br>&gt; If BinaryFloatingPoint had init(_: RawSignificand), you could also just write:<br>&gt; <br>&gt; extension BinaryFloatingPoint {<br>&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;         self = Self(s) * .ulpOfOne<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; (this is why I ask if RawSignificand is really the type you want; if you use some concrete integer type this will work).  But once we have all the new integer protocol conformances, we’ll have a generic init from any integer type (this was already reviewed for FloatingPoint, but isn’t implementable without the Integer support), which will also make this possible.<br>&gt; <br>&gt;&gt; On Aug 26, 2016, at 7:47 PM, Stephen Canon via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Assuming RawSignificand really is the type you want, I think this does what you’re looking for?<br>&gt;&gt; <br>&gt;&gt; protocol BinaryFloatingPointWithBitPattern: BinaryFloatingPoint {<br>&gt;&gt;     init(bitPattern: RawSignificand)<br>&gt;&gt;     var bitPattern: RawSignificand { get }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension Float: BinaryFloatingPointWithBitPattern { }<br>&gt;&gt; extension Double: BinaryFloatingPointWithBitPattern { }<br>&gt;&gt; <br>&gt;&gt; extension BinaryFloatingPointWithBitPattern {<br>&gt;&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;&gt;         self = Self(bitPattern: Self(1).bitPattern | s) - 1<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt;&gt; On Aug 26, 2016, at 7:38 PM, Stephen Canon via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Where does your RawSignificand input come from?  Is that really the type that you want?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don’t think you really need very much boilerplate at all here.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Aug 26, 2016, at 7:30 PM, Jens Persson &lt;jens at bitcycle.com &lt;mailto:jens at bitcycle.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I understand.<br>&gt;&gt;&gt;&gt; It&#39;s just very tempting to try and use the new static computed properties for eg 23 and 52 etc.<br>&gt;&gt;&gt;&gt; I guess I&#39;ll just have to write a lot of boilerplate, or perhaps a protocol that is just implemented by Double and Float (that will be very similar to BinaryFloatingPoint in a lot of ways).<br>&gt;&gt;&gt;&gt; /Jens<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Sat, Aug 27, 2016 at 1:25 AM, Stephen Canon &lt;scanon at apple.com &lt;mailto:scanon at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; This doesn’t really scale up very well, though.  BinaryFloatingPoint needs to also be able to model e.g. Float2048 or similar; we generally don&#39;t want to require that RawExponent to be the same type as RawSignificand (which I think is what you’re really suggesting), because in typical bignum usage significands are much larger than exponents.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It sounds like maybe you actually want to be operating directly on bitPatterns, rather than the abstract fields of the types.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; – Steve<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Aug 26, 2016, at 7:21 PM, Jens Persson &lt;jens at bitcycle.com &lt;mailto:jens at bitcycle.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Oh, to more directly answer your question: I don&#39;t like having to create a UInt (UInt64) value when all my bit manipulaton code happens in UInt32 (for Float) for example.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The most probable context for using these computed properties and types of BinaryFloatingPoint is one in which specific fixed width types really matters a lot (look at the name of the protocol and the properties and assocated types we are talking about).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; /Jens<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Sat, Aug 27, 2016 at 1:15 AM, Jens Persson &lt;jens at bitcycle.com &lt;mailto:jens at bitcycle.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; Reason for asking is that I have this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; extension Double {<br>&gt;&gt;&gt;&gt;&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;&gt;&gt;&gt;&gt;         let bitPattern = s | (1023 &lt;&lt; 52)<br>&gt;&gt;&gt;&gt;&gt;         self = unsafeBitCast(bitPattern, to: Double.self) - 1.0<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; extension Float {<br>&gt;&gt;&gt;&gt;&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;&gt;&gt;&gt;&gt;         let bitPattern = s | (127 &lt;&lt; 23)<br>&gt;&gt;&gt;&gt;&gt;         self = unsafeBitCast(bitPattern, to: Float.self) - 1.0<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; But they would be better as:<br>&gt;&gt;&gt;&gt;&gt; extension BinaryFloatingPoint {<br>&gt;&gt;&gt;&gt;&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;&gt;&gt;&gt;&gt;         ... problems here, have to try casting things into RawSignificand&#39;s type ...<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Please have a go at that and perhaps you see what I mean or you will come up with a nice solution that I have missed. (Speed is very important btw.)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; /Jens<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Sat, Aug 27, 2016 at 1:02 AM, Stephen Canon &lt;scanon at apple.com &lt;mailto:scanon at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt; On Aug 26, 2016, at 6:06 PM, Jens Persson via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; I can understand why<br>&gt;&gt;&gt;&gt;&gt; &gt; Double.RawSignificand is UInt64<br>&gt;&gt;&gt;&gt;&gt; &gt; and<br>&gt;&gt;&gt;&gt;&gt; &gt; Float.RawSignificand is UInt32<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; But I can&#39;t understand why both<br>&gt;&gt;&gt;&gt;&gt; &gt; Double.RawExponent<br>&gt;&gt;&gt;&gt;&gt; &gt; and<br>&gt;&gt;&gt;&gt;&gt; &gt; Float.RawExponent<br>&gt;&gt;&gt;&gt;&gt; &gt; should be UInt.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Why aren&#39;t they also just UInt64 and UInt32, resp.?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Let me flip the question: why would they be UInt64 and UInt32?  Absent a reason to prefer a specific fixed-with type, Swift integers should generally default to being [U]Int (and ideally Int, but RawExponent is Unsigned).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; – Steve<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160826/87c489b5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d042be5dcfe90e649f760303af3e429?s=50"></div><header><strong>Why are BinaryFloatingPoint&#39;s RawSignificand and RawExponent different type?</strong> from <string>Jens Persson</string> &lt;jens at bitcycle.com&gt;<p>August 27, 2016 at 02:00:00am</p></header><div class="content"><p>Ah, right! Thanks again.<br>How would you make all integer type (UIntN, IntN) convertible/mappable from<br>their respective [.min, .max] range to Double/Float unit range [0, 1)?<br>/Jens<br></p><p>On Sat, Aug 27, 2016 at 2:06 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br></p><p>&gt; Note that with the bug fixed, the result will still not be 1.nextDown,<br>&gt; because the size of an ulp changes at 1; the values you produce will be<br>&gt; space .ulpOfOne apart, but 1.nextDown is 1 - ulpOfOne/2.<br>&gt;<br>&gt; – Steve<br>&gt;<br>&gt; On Aug 26, 2016, at 8:00 PM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt;<br>&gt; Thanks, but there seem to be something not working the same as in my<br>&gt; original code, here is a quick test of your code:<br>&gt;<br>&gt; protocol BinaryFloatingPointWithBitPattern: BinaryFloatingPoint {<br>&gt;     init(bitPattern: RawSignificand)<br>&gt;     var bitPattern: RawSignificand { get }<br>&gt; }<br>&gt;<br>&gt; extension Float: BinaryFloatingPointWithBitPattern { }<br>&gt; extension Double: BinaryFloatingPointWithBitPattern { }<br>&gt;<br>&gt; extension BinaryFloatingPointWithBitPattern {<br>&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;         self = Self(bitPattern: Self(1).bitPattern | s) - 1<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; typealias T = Double<br>&gt; // typealias T = Float<br>&gt;<br>&gt; let allSignificantBitsSet = T.RawSignificand((1 &lt;&lt; T.significandBitCount)<br>&gt; - 1)<br>&gt; print(&quot;bits set in signigicant:&quot;, String(allSignificantBitsSet, radix:<br>&gt; 2).characters.count) // 52<br>&gt; let a = T.init(bitPattern: 0)<br>&gt; let b = T.init(bitPattern: allSignificantBitsSet)<br>&gt; print(a) // 0.0, correct.<br>&gt; print(b) // 2.2250738585072e-308. Wrong, this should be (1.0).nextDown.<br>&gt;<br>&gt;<br>&gt; On Sat, Aug 27, 2016 at 1:57 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt; If BinaryFloatingPoint had init(_: RawSignificand), you could also just<br>&gt;&gt; write:<br>&gt;&gt;<br>&gt;&gt; extension BinaryFloatingPoint {<br>&gt;&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;&gt;         self = Self(s) * .ulpOfOne<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; (this is why I ask if RawSignificand is really the type you want; if you<br>&gt;&gt; use some concrete integer type this will work).  But once we have all the<br>&gt;&gt; new integer protocol conformances, we’ll have a generic init from any<br>&gt;&gt; integer type (this was already reviewed for FloatingPoint, but isn’t<br>&gt;&gt; implementable without the Integer support), which will also make this<br>&gt;&gt; possible.<br>&gt;&gt;<br>&gt;&gt; On Aug 26, 2016, at 7:47 PM, Stephen Canon via swift-dev &lt;<br>&gt;&gt; swift-dev at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Assuming RawSignificand really is the type you want, I think this does<br>&gt;&gt; what you’re looking for?<br>&gt;&gt;<br>&gt;&gt; protocol BinaryFloatingPointWithBitPattern: BinaryFloatingPoint {<br>&gt;&gt;     init(bitPattern: RawSignificand)<br>&gt;&gt;     var bitPattern: RawSignificand { get }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; extension Float: BinaryFloatingPointWithBitPattern { }<br>&gt;&gt; extension Double: BinaryFloatingPointWithBitPattern { }<br>&gt;&gt;<br>&gt;&gt; extension BinaryFloatingPointWithBitPattern {<br>&gt;&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;&gt;         self = Self(bitPattern: Self(1).bitPattern | s) - 1<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; On Aug 26, 2016, at 7:38 PM, Stephen Canon via swift-dev &lt;<br>&gt;&gt; swift-dev at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Where does your RawSignificand input come from?  Is that really the type<br>&gt;&gt; that you want?<br>&gt;&gt;<br>&gt;&gt; I don’t think you really need very much boilerplate at all here.<br>&gt;&gt;<br>&gt;&gt; On Aug 26, 2016, at 7:30 PM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I understand.<br>&gt;&gt; It&#39;s just very tempting to try and use the new static computed properties<br>&gt;&gt; for eg 23 and 52 etc.<br>&gt;&gt; I guess I&#39;ll just have to write a lot of boilerplate, or perhaps a<br>&gt;&gt; protocol that is just implemented by Double and Float (that will be very<br>&gt;&gt; similar to BinaryFloatingPoint in a lot of ways).<br>&gt;&gt; /Jens<br>&gt;&gt;<br>&gt;&gt; On Sat, Aug 27, 2016 at 1:25 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;&gt; This doesn’t really scale up very well, though.  BinaryFloatingPoint<br>&gt;&gt; needs to also be able to model e.g. Float2048 or similar; we generally<br>&gt;&gt; don&#39;t want to require that RawExponent to be the same type as<br>&gt;&gt; RawSignificand (which I think is what you’re really suggesting), because in<br>&gt;&gt; typical bignum usage significands are much larger than exponents.<br>&gt;&gt;<br>&gt;&gt; It sounds like maybe you actually want to be operating directly on<br>&gt;&gt; bitPatterns, rather than the abstract fields of the types.<br>&gt;&gt;<br>&gt;&gt; – Steve<br>&gt;&gt;<br>&gt;&gt; On Aug 26, 2016, at 7:21 PM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Oh, to more directly answer your question: I don&#39;t like having to create<br>&gt;&gt; a UInt (UInt64) value when all my bit manipulaton code happens in UInt32<br>&gt;&gt; (for Float) for example.<br>&gt;&gt;<br>&gt;&gt; The most probable context for using these computed properties and types<br>&gt;&gt; of BinaryFloatingPoint is one in which specific fixed width types really<br>&gt;&gt; matters a lot (look at the name of the protocol and the properties and<br>&gt;&gt; assocated types we are talking about).<br>&gt;&gt;<br>&gt;&gt; /Jens<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Sat, Aug 27, 2016 at 1:15 AM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt;&gt; Reason for asking is that I have this:<br>&gt;&gt;<br>&gt;&gt; extension Double {<br>&gt;&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;&gt;         let bitPattern = s | (1023 &lt;&lt; 52)<br>&gt;&gt;         self = unsafeBitCast(bitPattern, to: Double.self) - 1.0<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; extension Float {<br>&gt;&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;&gt;         let bitPattern = s | (127 &lt;&lt; 23)<br>&gt;&gt;         self = unsafeBitCast(bitPattern, to: Float.self) - 1.0<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; But they would be better as:<br>&gt;&gt; extension BinaryFloatingPoint {<br>&gt;&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;&gt;         ... problems here, have to try casting things into<br>&gt;&gt; RawSignificand&#39;s type ...<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Please have a go at that and perhaps you see what I mean or you will come<br>&gt;&gt; up with a nice solution that I have missed. (Speed is very important btw.)<br>&gt;&gt;<br>&gt;&gt; /Jens<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Sat, Aug 27, 2016 at 1:02 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;&gt; &gt; On Aug 26, 2016, at 6:06 PM, Jens Persson via swift-dev &lt;<br>&gt;&gt; swift-dev at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I can understand why<br>&gt;&gt; &gt; Double.RawSignificand is UInt64<br>&gt;&gt; &gt; and<br>&gt;&gt; &gt; Float.RawSignificand is UInt32<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; But I can&#39;t understand why both<br>&gt;&gt; &gt; Double.RawExponent<br>&gt;&gt; &gt; and<br>&gt;&gt; &gt; Float.RawExponent<br>&gt;&gt; &gt; should be UInt.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Why aren&#39;t they also just UInt64 and UInt32, resp.?<br>&gt;&gt;<br>&gt;&gt; Let me flip the question: why would they be UInt64 and UInt32?  Absent a<br>&gt;&gt; reason to prefer a specific fixed-with type, Swift integers should<br>&gt;&gt; generally default to being [U]Int (and ideally Int, but RawExponent<br>&gt;&gt; is Unsigned).<br>&gt;&gt;<br>&gt;&gt; – Steve<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160827/6c81051e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>Why are BinaryFloatingPoint&#39;s RawSignificand and RawExponent different type?</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>August 26, 2016 at 08:00:00pm</p></header><div class="content"><p>For any given concrete type, it’s pretty straightforward to map [0, .max] to [0,1) — note that this is a bit different from what you seem to have been doing originally, mapping e.g. [0, 2**52) to [0, 1):<br></p><p>    init(unitRange s: UInt64) {<br>        self = Self(s &gt;&gt; UInt64(63 - Self.significandBitCount)) * .ulpOfOne/2<br>    }<br></p><p>Making this generic over integer types is painful without the SE-0104 integer protocols, however.<br></p><p>– Steve<br></p><p>&gt; On Aug 26, 2016, at 8:13 PM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt; <br>&gt; Ah, right! Thanks again.<br>&gt; How would you make all integer type (UIntN, IntN) convertible/mappable from their respective [.min, .max] range to Double/Float unit range [0, 1)?<br>&gt; /Jens<br>&gt; <br>&gt; On Sat, Aug 27, 2016 at 2:06 AM, Stephen Canon &lt;scanon at apple.com &lt;mailto:scanon at apple.com&gt;&gt; wrote:<br>&gt; Note that with the bug fixed, the result will still not be 1.nextDown, because the size of an ulp changes at 1; the values you produce will be space .ulpOfOne apart, but 1.nextDown is 1 - ulpOfOne/2.<br>&gt; <br>&gt; – Steve<br>&gt; <br>&gt;&gt; On Aug 26, 2016, at 8:00 PM, Jens Persson &lt;jens at bitcycle.com &lt;mailto:jens at bitcycle.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Thanks, but there seem to be something not working the same as in my original code, here is a quick test of your code:<br>&gt;&gt; <br>&gt;&gt; protocol BinaryFloatingPointWithBitPattern: BinaryFloatingPoint {<br>&gt;&gt;     init(bitPattern: RawSignificand)<br>&gt;&gt;     var bitPattern: RawSignificand { get }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension Float: BinaryFloatingPointWithBitPattern { }<br>&gt;&gt; extension Double: BinaryFloatingPointWithBitPattern { }<br>&gt;&gt; <br>&gt;&gt; extension BinaryFloatingPointWithBitPattern {<br>&gt;&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;&gt;         self = Self(bitPattern: Self(1).bitPattern | s) - 1<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; typealias T = Double<br>&gt;&gt; // typealias T = Float<br>&gt;&gt; <br>&gt;&gt; let allSignificantBitsSet = T.RawSignificand((1 &lt;&lt; T.significandBitCount) - 1)<br>&gt;&gt; print(&quot;bits set in signigicant:&quot;, String(allSignificantBitsSet, radix: 2).characters.count) // 52<br>&gt;&gt; let a = T.init(bitPattern: 0)<br>&gt;&gt; let b = T.init(bitPattern: allSignificantBitsSet)<br>&gt;&gt; print(a) // 0.0, correct.<br>&gt;&gt; print(b) // 2.2250738585072e-308. Wrong, this should be (1.0).nextDown.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Sat, Aug 27, 2016 at 1:57 AM, Stephen Canon &lt;scanon at apple.com &lt;mailto:scanon at apple.com&gt;&gt; wrote:<br>&gt;&gt; If BinaryFloatingPoint had init(_: RawSignificand), you could also just write:<br>&gt;&gt; <br>&gt;&gt; extension BinaryFloatingPoint {<br>&gt;&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;&gt;         self = Self(s) * .ulpOfOne<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; (this is why I ask if RawSignificand is really the type you want; if you use some concrete integer type this will work).  But once we have all the new integer protocol conformances, we’ll have a generic init from any integer type (this was already reviewed for FloatingPoint, but isn’t implementable without the Integer support), which will also make this possible.<br>&gt;&gt; <br>&gt;&gt;&gt; On Aug 26, 2016, at 7:47 PM, Stephen Canon via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Assuming RawSignificand really is the type you want, I think this does what you’re looking for?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol BinaryFloatingPointWithBitPattern: BinaryFloatingPoint {<br>&gt;&gt;&gt;     init(bitPattern: RawSignificand)<br>&gt;&gt;&gt;     var bitPattern: RawSignificand { get }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Float: BinaryFloatingPointWithBitPattern { }<br>&gt;&gt;&gt; extension Double: BinaryFloatingPointWithBitPattern { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension BinaryFloatingPointWithBitPattern {<br>&gt;&gt;&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;&gt;&gt;         self = Self(bitPattern: Self(1).bitPattern | s) - 1<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Aug 26, 2016, at 7:38 PM, Stephen Canon via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Where does your RawSignificand input come from?  Is that really the type that you want?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don’t think you really need very much boilerplate at all here.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Aug 26, 2016, at 7:30 PM, Jens Persson &lt;jens at bitcycle.com &lt;mailto:jens at bitcycle.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I understand.<br>&gt;&gt;&gt;&gt;&gt; It&#39;s just very tempting to try and use the new static computed properties for eg 23 and 52 etc.<br>&gt;&gt;&gt;&gt;&gt; I guess I&#39;ll just have to write a lot of boilerplate, or perhaps a protocol that is just implemented by Double and Float (that will be very similar to BinaryFloatingPoint in a lot of ways).<br>&gt;&gt;&gt;&gt;&gt; /Jens<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Sat, Aug 27, 2016 at 1:25 AM, Stephen Canon &lt;scanon at apple.com &lt;mailto:scanon at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; This doesn’t really scale up very well, though.  BinaryFloatingPoint needs to also be able to model e.g. Float2048 or similar; we generally don&#39;t want to require that RawExponent to be the same type as RawSignificand (which I think is what you’re really suggesting), because in typical bignum usage significands are much larger than exponents.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It sounds like maybe you actually want to be operating directly on bitPatterns, rather than the abstract fields of the types.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; – Steve<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Aug 26, 2016, at 7:21 PM, Jens Persson &lt;jens at bitcycle.com &lt;mailto:jens at bitcycle.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Oh, to more directly answer your question: I don&#39;t like having to create a UInt (UInt64) value when all my bit manipulaton code happens in UInt32 (for Float) for example.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The most probable context for using these computed properties and types of BinaryFloatingPoint is one in which specific fixed width types really matters a lot (look at the name of the protocol and the properties and assocated types we are talking about).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; /Jens<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Sat, Aug 27, 2016 at 1:15 AM, Jens Persson &lt;jens at bitcycle.com &lt;mailto:jens at bitcycle.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; Reason for asking is that I have this:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; extension Double {<br>&gt;&gt;&gt;&gt;&gt;&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;&gt;&gt;&gt;&gt;&gt;         let bitPattern = s | (1023 &lt;&lt; 52)<br>&gt;&gt;&gt;&gt;&gt;&gt;         self = unsafeBitCast(bitPattern, to: Double.self) - 1.0<br>&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; extension Float {<br>&gt;&gt;&gt;&gt;&gt;&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;&gt;&gt;&gt;&gt;&gt;         let bitPattern = s | (127 &lt;&lt; 23)<br>&gt;&gt;&gt;&gt;&gt;&gt;         self = unsafeBitCast(bitPattern, to: Float.self) - 1.0<br>&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; But they would be better as:<br>&gt;&gt;&gt;&gt;&gt;&gt; extension BinaryFloatingPoint {<br>&gt;&gt;&gt;&gt;&gt;&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;&gt;&gt;&gt;&gt;&gt;         ... problems here, have to try casting things into RawSignificand&#39;s type ...<br>&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Please have a go at that and perhaps you see what I mean or you will come up with a nice solution that I have missed. (Speed is very important btw.)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; /Jens<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Sat, Aug 27, 2016 at 1:02 AM, Stephen Canon &lt;scanon at apple.com &lt;mailto:scanon at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; On Aug 26, 2016, at 6:06 PM, Jens Persson via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; I can understand why<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Double.RawSignificand is UInt64<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; and<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Float.RawSignificand is UInt32<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; But I can&#39;t understand why both<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Double.RawExponent<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; and<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Float.RawExponent<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; should be UInt.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Why aren&#39;t they also just UInt64 and UInt32, resp.?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Let me flip the question: why would they be UInt64 and UInt32?  Absent a reason to prefer a specific fixed-with type, Swift integers should generally default to being [U]Int (and ideally Int, but RawExponent is Unsigned).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; – Steve<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160826/b8929a9e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d042be5dcfe90e649f760303af3e429?s=50"></div><header><strong>Why are BinaryFloatingPoint&#39;s RawSignificand and RawExponent different type?</strong> from <string>Jens Persson</string> &lt;jens at bitcycle.com&gt;<p>August 27, 2016 at 02:00:00am</p></header><div class="content"><p>Ok, I&#39;ve learned a lot, thanks!<br>/Jens<br></p><p>On Sat, Aug 27, 2016 at 2:26 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br></p><p>&gt; For any given concrete type, it’s pretty straightforward to map [0, .max]<br>&gt; to [0,1) — note that this is a bit different from what you seem to have<br>&gt; been doing originally, mapping e.g. [0, 2**52) to [0, 1):<br>&gt;<br>&gt;     init(unitRange s: UInt64) {<br>&gt;         self = Self(s &gt;&gt; UInt64(63 - Self.significandBitCount)) * .<br>&gt; ulpOfOne/2<br>&gt;     }<br>&gt;<br>&gt; Making this generic over integer types is painful without the SE-0104<br>&gt; integer protocols, however.<br>&gt;<br>&gt; – Steve<br>&gt;<br>&gt;<br>&gt; On Aug 26, 2016, at 8:13 PM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt;<br>&gt; Ah, right! Thanks again.<br>&gt; How would you make all integer type (UIntN, IntN) convertible/mappable<br>&gt; from their respective [.min, .max] range to Double/Float unit range [0, 1)?<br>&gt; /Jens<br>&gt;<br>&gt; On Sat, Aug 27, 2016 at 2:06 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt; Note that with the bug fixed, the result will still not be 1.nextDown,<br>&gt;&gt; because the size of an ulp changes at 1; the values you produce will be<br>&gt;&gt; space .ulpOfOne apart, but 1.nextDown is 1 - ulpOfOne/2.<br>&gt;&gt;<br>&gt;&gt; – Steve<br>&gt;&gt;<br>&gt;&gt; On Aug 26, 2016, at 8:00 PM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Thanks, but there seem to be something not working the same as in my<br>&gt;&gt; original code, here is a quick test of your code:<br>&gt;&gt;<br>&gt;&gt; protocol BinaryFloatingPointWithBitPattern: BinaryFloatingPoint {<br>&gt;&gt;     init(bitPattern: RawSignificand)<br>&gt;&gt;     var bitPattern: RawSignificand { get }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; extension Float: BinaryFloatingPointWithBitPattern { }<br>&gt;&gt; extension Double: BinaryFloatingPointWithBitPattern { }<br>&gt;&gt;<br>&gt;&gt; extension BinaryFloatingPointWithBitPattern {<br>&gt;&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;&gt;         self = Self(bitPattern: Self(1).bitPattern | s) - 1<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; typealias T = Double<br>&gt;&gt; // typealias T = Float<br>&gt;&gt;<br>&gt;&gt; let allSignificantBitsSet = T.RawSignificand((1 &lt;&lt; T.significandBitCount)<br>&gt;&gt; - 1)<br>&gt;&gt; print(&quot;bits set in signigicant:&quot;, String(allSignificantBitsSet, radix:<br>&gt;&gt; 2).characters.count) // 52<br>&gt;&gt; let a = T.init(bitPattern: 0)<br>&gt;&gt; let b = T.init(bitPattern: allSignificantBitsSet)<br>&gt;&gt; print(a) // 0.0, correct.<br>&gt;&gt; print(b) // 2.2250738585072e-308. Wrong, this should be (1.0).nextDown.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Sat, Aug 27, 2016 at 1:57 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; If BinaryFloatingPoint had init(_: RawSignificand), you could also just<br>&gt;&gt;&gt; write:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; extension BinaryFloatingPoint {<br>&gt;&gt;&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;&gt;&gt;         self = Self(s) * .ulpOfOne<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; (this is why I ask if RawSignificand is really the type you want; if you<br>&gt;&gt;&gt; use some concrete integer type this will work).  But once we have all the<br>&gt;&gt;&gt; new integer protocol conformances, we’ll have a generic init from any<br>&gt;&gt;&gt; integer type (this was already reviewed for FloatingPoint, but isn’t<br>&gt;&gt;&gt; implementable without the Integer support), which will also make this<br>&gt;&gt;&gt; possible.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Aug 26, 2016, at 7:47 PM, Stephen Canon via swift-dev &lt;<br>&gt;&gt;&gt; swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Assuming RawSignificand really is the type you want, I think this does<br>&gt;&gt;&gt; what you’re looking for?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; protocol BinaryFloatingPointWithBitPattern: BinaryFloatingPoint {<br>&gt;&gt;&gt;     init(bitPattern: RawSignificand)<br>&gt;&gt;&gt;     var bitPattern: RawSignificand { get }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; extension Float: BinaryFloatingPointWithBitPattern { }<br>&gt;&gt;&gt; extension Double: BinaryFloatingPointWithBitPattern { }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; extension BinaryFloatingPointWithBitPattern {<br>&gt;&gt;&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;&gt;&gt;         self = Self(bitPattern: Self(1).bitPattern | s) - 1<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Aug 26, 2016, at 7:38 PM, Stephen Canon via swift-dev &lt;<br>&gt;&gt;&gt; swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Where does your RawSignificand input come from?  Is that really the type<br>&gt;&gt;&gt; that you want?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I don’t think you really need very much boilerplate at all here.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Aug 26, 2016, at 7:30 PM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I understand.<br>&gt;&gt;&gt; It&#39;s just very tempting to try and use the new static computed<br>&gt;&gt;&gt; properties for eg 23 and 52 etc.<br>&gt;&gt;&gt; I guess I&#39;ll just have to write a lot of boilerplate, or perhaps a<br>&gt;&gt;&gt; protocol that is just implemented by Double and Float (that will be very<br>&gt;&gt;&gt; similar to BinaryFloatingPoint in a lot of ways).<br>&gt;&gt;&gt; /Jens<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Sat, Aug 27, 2016 at 1:25 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;&gt;&gt; This doesn’t really scale up very well, though.  BinaryFloatingPoint<br>&gt;&gt;&gt; needs to also be able to model e.g. Float2048 or similar; we generally<br>&gt;&gt;&gt; don&#39;t want to require that RawExponent to be the same type as<br>&gt;&gt;&gt; RawSignificand (which I think is what you’re really suggesting), because in<br>&gt;&gt;&gt; typical bignum usage significands are much larger than exponents.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It sounds like maybe you actually want to be operating directly on<br>&gt;&gt;&gt; bitPatterns, rather than the abstract fields of the types.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; – Steve<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Aug 26, 2016, at 7:21 PM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Oh, to more directly answer your question: I don&#39;t like having to create<br>&gt;&gt;&gt; a UInt (UInt64) value when all my bit manipulaton code happens in UInt32<br>&gt;&gt;&gt; (for Float) for example.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The most probable context for using these computed properties and types<br>&gt;&gt;&gt; of BinaryFloatingPoint is one in which specific fixed width types really<br>&gt;&gt;&gt; matters a lot (look at the name of the protocol and the properties and<br>&gt;&gt;&gt; assocated types we are talking about).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; /Jens<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Sat, Aug 27, 2016 at 1:15 AM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt;&gt;&gt; Reason for asking is that I have this:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; extension Double {<br>&gt;&gt;&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;&gt;&gt;         let bitPattern = s | (1023 &lt;&lt; 52)<br>&gt;&gt;&gt;         self = unsafeBitCast(bitPattern, to: Double.self) - 1.0<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; extension Float {<br>&gt;&gt;&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;&gt;&gt;         let bitPattern = s | (127 &lt;&lt; 23)<br>&gt;&gt;&gt;         self = unsafeBitCast(bitPattern, to: Float.self) - 1.0<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; But they would be better as:<br>&gt;&gt;&gt; extension BinaryFloatingPoint {<br>&gt;&gt;&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;&gt;&gt;         ... problems here, have to try casting things into<br>&gt;&gt;&gt; RawSignificand&#39;s type ...<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Please have a go at that and perhaps you see what I mean or you will<br>&gt;&gt;&gt; come up with a nice solution that I have missed. (Speed is very important<br>&gt;&gt;&gt; btw.)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; /Jens<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Sat, Aug 27, 2016 at 1:02 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;&gt;&gt; &gt; On Aug 26, 2016, at 6:06 PM, Jens Persson via swift-dev &lt;<br>&gt;&gt;&gt; swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I can understand why<br>&gt;&gt;&gt; &gt; Double.RawSignificand is UInt64<br>&gt;&gt;&gt; &gt; and<br>&gt;&gt;&gt; &gt; Float.RawSignificand is UInt32<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; But I can&#39;t understand why both<br>&gt;&gt;&gt; &gt; Double.RawExponent<br>&gt;&gt;&gt; &gt; and<br>&gt;&gt;&gt; &gt; Float.RawExponent<br>&gt;&gt;&gt; &gt; should be UInt.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Why aren&#39;t they also just UInt64 and UInt32, resp.?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Let me flip the question: why would they be UInt64 and UInt32?  Absent a<br>&gt;&gt;&gt; reason to prefer a specific fixed-with type, Swift integers should<br>&gt;&gt;&gt; generally default to being [U]Int (and ideally Int, but RawExponent<br>&gt;&gt;&gt; is Unsigned).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; – Steve<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt; swift-dev at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt; swift-dev at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160827/21f2b1b3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d042be5dcfe90e649f760303af3e429?s=50"></div><header><strong>Why are BinaryFloatingPoint&#39;s RawSignificand and RawExponent different type?</strong> from <string>Jens Persson</string> &lt;jens at bitcycle.com&gt;<p>August 27, 2016 at 10:00:00am</p></header><div class="content"><p>Btw, I had a look quick at the development snapshot 08-25-a toolchain and<br>it seems like it has SE-0104 partly implemented.<br></p><p>(For example Double doesn&#39;t conform to SignedArithmetic while it does<br>conform to Arithmetic. And the Integer types doesn&#39;t conform to Arithmetic)<br></p><p>Is SE-0104 not part of Swift 3, and will thus not be included in Xcode 8 GM?<br></p><p>/Jens<br></p><p><br></p><p>On Sat, Aug 27, 2016 at 2:31 AM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br></p><p>&gt; Ok, I&#39;ve learned a lot, thanks!<br>&gt; /Jens<br>&gt;<br>&gt; On Sat, Aug 27, 2016 at 2:26 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt; For any given concrete type, it’s pretty straightforward to map [0, .max]<br>&gt;&gt; to [0,1) — note that this is a bit different from what you seem to have<br>&gt;&gt; been doing originally, mapping e.g. [0, 2**52) to [0, 1):<br>&gt;&gt;<br>&gt;&gt;     init(unitRange s: UInt64) {<br>&gt;&gt;         self = Self(s &gt;&gt; UInt64(63 - Self.significandBitCount)) * .<br>&gt;&gt; ulpOfOne/2<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt; Making this generic over integer types is painful without the SE-0104<br>&gt;&gt; integer protocols, however.<br>&gt;&gt;<br>&gt;&gt; – Steve<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Aug 26, 2016, at 8:13 PM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Ah, right! Thanks again.<br>&gt;&gt; How would you make all integer type (UIntN, IntN) convertible/mappable<br>&gt;&gt; from their respective [.min, .max] range to Double/Float unit range [0, 1)?<br>&gt;&gt; /Jens<br>&gt;&gt;<br>&gt;&gt; On Sat, Aug 27, 2016 at 2:06 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Note that with the bug fixed, the result will still not be 1.nextDown,<br>&gt;&gt;&gt; because the size of an ulp changes at 1; the values you produce will be<br>&gt;&gt;&gt; space .ulpOfOne apart, but 1.nextDown is 1 - ulpOfOne/2.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; – Steve<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Aug 26, 2016, at 8:00 PM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Thanks, but there seem to be something not working the same as in my<br>&gt;&gt;&gt; original code, here is a quick test of your code:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; protocol BinaryFloatingPointWithBitPattern: BinaryFloatingPoint {<br>&gt;&gt;&gt;     init(bitPattern: RawSignificand)<br>&gt;&gt;&gt;     var bitPattern: RawSignificand { get }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; extension Float: BinaryFloatingPointWithBitPattern { }<br>&gt;&gt;&gt; extension Double: BinaryFloatingPointWithBitPattern { }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; extension BinaryFloatingPointWithBitPattern {<br>&gt;&gt;&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;&gt;&gt;         self = Self(bitPattern: Self(1).bitPattern | s) - 1<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; typealias T = Double<br>&gt;&gt;&gt; // typealias T = Float<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let allSignificantBitsSet = T.RawSignificand((1 &lt;&lt;<br>&gt;&gt;&gt; T.significandBitCount) - 1)<br>&gt;&gt;&gt; print(&quot;bits set in signigicant:&quot;, String(allSignificantBitsSet, radix:<br>&gt;&gt;&gt; 2).characters.count) // 52<br>&gt;&gt;&gt; let a = T.init(bitPattern: 0)<br>&gt;&gt;&gt; let b = T.init(bitPattern: allSignificantBitsSet)<br>&gt;&gt;&gt; print(a) // 0.0, correct.<br>&gt;&gt;&gt; print(b) // 2.2250738585072e-308. Wrong, this should be (1.0).nextDown.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Sat, Aug 27, 2016 at 1:57 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; If BinaryFloatingPoint had init(_: RawSignificand), you could also just<br>&gt;&gt;&gt;&gt; write:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; extension BinaryFloatingPoint {<br>&gt;&gt;&gt;&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;&gt;&gt;&gt;         self = Self(s) * .ulpOfOne<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; (this is why I ask if RawSignificand is really the type you want; if<br>&gt;&gt;&gt;&gt; you use some concrete integer type this will work).  But once we have all<br>&gt;&gt;&gt;&gt; the new integer protocol conformances, we’ll have a generic init from any<br>&gt;&gt;&gt;&gt; integer type (this was already reviewed for FloatingPoint, but isn’t<br>&gt;&gt;&gt;&gt; implementable without the Integer support), which will also make this<br>&gt;&gt;&gt;&gt; possible.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Aug 26, 2016, at 7:47 PM, Stephen Canon via swift-dev &lt;<br>&gt;&gt;&gt;&gt; swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Assuming RawSignificand really is the type you want, I think this does<br>&gt;&gt;&gt;&gt; what you’re looking for?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; protocol BinaryFloatingPointWithBitPattern: BinaryFloatingPoint {<br>&gt;&gt;&gt;&gt;     init(bitPattern: RawSignificand)<br>&gt;&gt;&gt;&gt;     var bitPattern: RawSignificand { get }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; extension Float: BinaryFloatingPointWithBitPattern { }<br>&gt;&gt;&gt;&gt; extension Double: BinaryFloatingPointWithBitPattern { }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; extension BinaryFloatingPointWithBitPattern {<br>&gt;&gt;&gt;&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;&gt;&gt;&gt;         self = Self(bitPattern: Self(1).bitPattern | s) - 1<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Aug 26, 2016, at 7:38 PM, Stephen Canon via swift-dev &lt;<br>&gt;&gt;&gt;&gt; swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Where does your RawSignificand input come from?  Is that really the<br>&gt;&gt;&gt;&gt; type that you want?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I don’t think you really need very much boilerplate at all here.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Aug 26, 2016, at 7:30 PM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I understand.<br>&gt;&gt;&gt;&gt; It&#39;s just very tempting to try and use the new static computed<br>&gt;&gt;&gt;&gt; properties for eg 23 and 52 etc.<br>&gt;&gt;&gt;&gt; I guess I&#39;ll just have to write a lot of boilerplate, or perhaps a<br>&gt;&gt;&gt;&gt; protocol that is just implemented by Double and Float (that will be very<br>&gt;&gt;&gt;&gt; similar to BinaryFloatingPoint in a lot of ways).<br>&gt;&gt;&gt;&gt; /Jens<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Sat, Aug 27, 2016 at 1:25 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote<br>&gt;&gt;&gt;&gt; :<br>&gt;&gt;&gt;&gt; This doesn’t really scale up very well, though.  BinaryFloatingPoint<br>&gt;&gt;&gt;&gt; needs to also be able to model e.g. Float2048 or similar; we generally<br>&gt;&gt;&gt;&gt; don&#39;t want to require that RawExponent to be the same type as<br>&gt;&gt;&gt;&gt; RawSignificand (which I think is what you’re really suggesting), because in<br>&gt;&gt;&gt;&gt; typical bignum usage significands are much larger than exponents.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; It sounds like maybe you actually want to be operating directly on<br>&gt;&gt;&gt;&gt; bitPatterns, rather than the abstract fields of the types.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; – Steve<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Aug 26, 2016, at 7:21 PM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Oh, to more directly answer your question: I don&#39;t like having to<br>&gt;&gt;&gt;&gt; create a UInt (UInt64) value when all my bit manipulaton code happens in<br>&gt;&gt;&gt;&gt; UInt32 (for Float) for example.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The most probable context for using these computed properties and types<br>&gt;&gt;&gt;&gt; of BinaryFloatingPoint is one in which specific fixed width types really<br>&gt;&gt;&gt;&gt; matters a lot (look at the name of the protocol and the properties and<br>&gt;&gt;&gt;&gt; assocated types we are talking about).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; /Jens<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Sat, Aug 27, 2016 at 1:15 AM, Jens Persson &lt;jens at bitcycle.com&gt; wr<br>&gt;&gt;&gt;&gt; ote:<br>&gt;&gt;&gt;&gt; Reason for asking is that I have this:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; extension Double {<br>&gt;&gt;&gt;&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;&gt;&gt;&gt;         let bitPattern = s | (1023 &lt;&lt; 52)<br>&gt;&gt;&gt;&gt;         self = unsafeBitCast(bitPattern, to: Double.self) - 1.0<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; extension Float {<br>&gt;&gt;&gt;&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;&gt;&gt;&gt;         let bitPattern = s | (127 &lt;&lt; 23)<br>&gt;&gt;&gt;&gt;         self = unsafeBitCast(bitPattern, to: Float.self) - 1.0<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; But they would be better as:<br>&gt;&gt;&gt;&gt; extension BinaryFloatingPoint {<br>&gt;&gt;&gt;&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;&gt;&gt;&gt;         ... problems here, have to try casting things into<br>&gt;&gt;&gt;&gt; RawSignificand&#39;s type ...<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Please have a go at that and perhaps you see what I mean or you will<br>&gt;&gt;&gt;&gt; come up with a nice solution that I have missed. (Speed is very important<br>&gt;&gt;&gt;&gt; btw.)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; /Jens<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Sat, Aug 27, 2016 at 1:02 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote<br>&gt;&gt;&gt;&gt; :<br>&gt;&gt;&gt;&gt; &gt; On Aug 26, 2016, at 6:06 PM, Jens Persson via swift-dev &lt;<br>&gt;&gt;&gt;&gt; swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; I can understand why<br>&gt;&gt;&gt;&gt; &gt; Double.RawSignificand is UInt64<br>&gt;&gt;&gt;&gt; &gt; and<br>&gt;&gt;&gt;&gt; &gt; Float.RawSignificand is UInt32<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; But I can&#39;t understand why both<br>&gt;&gt;&gt;&gt; &gt; Double.RawExponent<br>&gt;&gt;&gt;&gt; &gt; and<br>&gt;&gt;&gt;&gt; &gt; Float.RawExponent<br>&gt;&gt;&gt;&gt; &gt; should be UInt.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; Why aren&#39;t they also just UInt64 and UInt32, resp.?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Let me flip the question: why would they be UInt64 and UInt32?  Absent<br>&gt;&gt;&gt;&gt; a reason to prefer a specific fixed-with type, Swift integers should<br>&gt;&gt;&gt;&gt; generally default to being [U]Int (and ideally Int, but RawExponent<br>&gt;&gt;&gt;&gt; is Unsigned).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; – Steve<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt; swift-dev at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt; swift-dev at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160827/44893546/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d042be5dcfe90e649f760303af3e429?s=50"></div><header><strong>Why are BinaryFloatingPoint&#39;s RawSignificand and RawExponent different type?</strong> from <string>Jens Persson</string> &lt;jens at bitcycle.com&gt;<p>August 27, 2016 at 10:00:00am</p></header><div class="content"><p>Oh, I just saw that SE-0104 was accepted for Swift 3:<br>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160627/022977.html<br></p><p>Sorry for the noise, I will try to check basic things like this up before<br>asking here next time.<br></p><p><br>On Sat, Aug 27, 2016 at 10:20 AM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br></p><p>&gt; Btw, I had a look quick at the development snapshot 08-25-a toolchain and<br>&gt; it seems like it has SE-0104 partly implemented.<br>&gt;<br>&gt; (For example Double doesn&#39;t conform to SignedArithmetic while it does<br>&gt; conform to Arithmetic. And the Integer types doesn&#39;t conform to Arithmetic)<br>&gt;<br>&gt; Is SE-0104 not part of Swift 3, and will thus not be included in Xcode 8<br>&gt; GM?<br>&gt;<br>&gt; /Jens<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Sat, Aug 27, 2016 at 2:31 AM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt;<br>&gt;&gt; Ok, I&#39;ve learned a lot, thanks!<br>&gt;&gt; /Jens<br>&gt;&gt;<br>&gt;&gt; On Sat, Aug 27, 2016 at 2:26 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; For any given concrete type, it’s pretty straightforward to map [0,<br>&gt;&gt;&gt; .max] to [0,1) — note that this is a bit different from what you seem to<br>&gt;&gt;&gt; have been doing originally, mapping e.g. [0, 2**52) to [0, 1):<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     init(unitRange s: UInt64) {<br>&gt;&gt;&gt;         self = Self(s &gt;&gt; UInt64(63 - Self.significandBitCount)) * .<br>&gt;&gt;&gt; ulpOfOne/2<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Making this generic over integer types is painful without the SE-0104<br>&gt;&gt;&gt; integer protocols, however.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; – Steve<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Aug 26, 2016, at 8:13 PM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Ah, right! Thanks again.<br>&gt;&gt;&gt; How would you make all integer type (UIntN, IntN) convertible/mappable<br>&gt;&gt;&gt; from their respective [.min, .max] range to Double/Float unit range [0, 1)?<br>&gt;&gt;&gt; /Jens<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Sat, Aug 27, 2016 at 2:06 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Note that with the bug fixed, the result will still not be 1.nextDown,<br>&gt;&gt;&gt;&gt; because the size of an ulp changes at 1; the values you produce will be<br>&gt;&gt;&gt;&gt; space .ulpOfOne apart, but 1.nextDown is 1 - ulpOfOne/2.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; – Steve<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Aug 26, 2016, at 8:00 PM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Thanks, but there seem to be something not working the same as in my<br>&gt;&gt;&gt;&gt; original code, here is a quick test of your code:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; protocol BinaryFloatingPointWithBitPattern: BinaryFloatingPoint {<br>&gt;&gt;&gt;&gt;     init(bitPattern: RawSignificand)<br>&gt;&gt;&gt;&gt;     var bitPattern: RawSignificand { get }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; extension Float: BinaryFloatingPointWithBitPattern { }<br>&gt;&gt;&gt;&gt; extension Double: BinaryFloatingPointWithBitPattern { }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; extension BinaryFloatingPointWithBitPattern {<br>&gt;&gt;&gt;&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;&gt;&gt;&gt;         self = Self(bitPattern: Self(1).bitPattern | s) - 1<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; typealias T = Double<br>&gt;&gt;&gt;&gt; // typealias T = Float<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; let allSignificantBitsSet = T.RawSignificand((1 &lt;&lt;<br>&gt;&gt;&gt;&gt; T.significandBitCount) - 1)<br>&gt;&gt;&gt;&gt; print(&quot;bits set in signigicant:&quot;, String(allSignificantBitsSet, radix:<br>&gt;&gt;&gt;&gt; 2).characters.count) // 52<br>&gt;&gt;&gt;&gt; let a = T.init(bitPattern: 0)<br>&gt;&gt;&gt;&gt; let b = T.init(bitPattern: allSignificantBitsSet)<br>&gt;&gt;&gt;&gt; print(a) // 0.0, correct.<br>&gt;&gt;&gt;&gt; print(b) // 2.2250738585072e-308. Wrong, this should be (1.0).nextDown.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Sat, Aug 27, 2016 at 1:57 AM, Stephen Canon &lt;scanon at apple.com&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; If BinaryFloatingPoint had init(_: RawSignificand), you could also<br>&gt;&gt;&gt;&gt;&gt; just write:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; extension BinaryFloatingPoint {<br>&gt;&gt;&gt;&gt;&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;&gt;&gt;&gt;&gt;         self = Self(s) * .ulpOfOne<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; (this is why I ask if RawSignificand is really the type you want; if<br>&gt;&gt;&gt;&gt;&gt; you use some concrete integer type this will work).  But once we have all<br>&gt;&gt;&gt;&gt;&gt; the new integer protocol conformances, we’ll have a generic init from any<br>&gt;&gt;&gt;&gt;&gt; integer type (this was already reviewed for FloatingPoint, but isn’t<br>&gt;&gt;&gt;&gt;&gt; implementable without the Integer support), which will also make this<br>&gt;&gt;&gt;&gt;&gt; possible.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Aug 26, 2016, at 7:47 PM, Stephen Canon via swift-dev &lt;<br>&gt;&gt;&gt;&gt;&gt; swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Assuming RawSignificand really is the type you want, I think this does<br>&gt;&gt;&gt;&gt;&gt; what you’re looking for?<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; protocol BinaryFloatingPointWithBitPattern: BinaryFloatingPoint {<br>&gt;&gt;&gt;&gt;&gt;     init(bitPattern: RawSignificand)<br>&gt;&gt;&gt;&gt;&gt;     var bitPattern: RawSignificand { get }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; extension Float: BinaryFloatingPointWithBitPattern { }<br>&gt;&gt;&gt;&gt;&gt; extension Double: BinaryFloatingPointWithBitPattern { }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; extension BinaryFloatingPointWithBitPattern {<br>&gt;&gt;&gt;&gt;&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;&gt;&gt;&gt;&gt;         self = Self(bitPattern: Self(1).bitPattern | s) - 1<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Aug 26, 2016, at 7:38 PM, Stephen Canon via swift-dev &lt;<br>&gt;&gt;&gt;&gt;&gt; swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Where does your RawSignificand input come from?  Is that really the<br>&gt;&gt;&gt;&gt;&gt; type that you want?<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I don’t think you really need very much boilerplate at all here.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Aug 26, 2016, at 7:30 PM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I understand.<br>&gt;&gt;&gt;&gt;&gt; It&#39;s just very tempting to try and use the new static computed<br>&gt;&gt;&gt;&gt;&gt; properties for eg 23 and 52 etc.<br>&gt;&gt;&gt;&gt;&gt; I guess I&#39;ll just have to write a lot of boilerplate, or perhaps a<br>&gt;&gt;&gt;&gt;&gt; protocol that is just implemented by Double and Float (that will be very<br>&gt;&gt;&gt;&gt;&gt; similar to BinaryFloatingPoint in a lot of ways).<br>&gt;&gt;&gt;&gt;&gt; /Jens<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Sat, Aug 27, 2016 at 1:25 AM, Stephen Canon &lt;scanon at apple.com<br>&gt;&gt;&gt;&gt;&gt; &gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; This doesn’t really scale up very well, though.  BinaryFloatingPoint<br>&gt;&gt;&gt;&gt;&gt; needs to also be able to model e.g. Float2048 or similar; we generally<br>&gt;&gt;&gt;&gt;&gt; don&#39;t want to require that RawExponent to be the same type as<br>&gt;&gt;&gt;&gt;&gt; RawSignificand (which I think is what you’re really suggesting), because in<br>&gt;&gt;&gt;&gt;&gt; typical bignum usage significands are much larger than exponents.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; It sounds like maybe you actually want to be operating directly on<br>&gt;&gt;&gt;&gt;&gt; bitPatterns, rather than the abstract fields of the types.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; – Steve<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Aug 26, 2016, at 7:21 PM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Oh, to more directly answer your question: I don&#39;t like having to<br>&gt;&gt;&gt;&gt;&gt; create a UInt (UInt64) value when all my bit manipulaton code happens in<br>&gt;&gt;&gt;&gt;&gt; UInt32 (for Float) for example.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; The most probable context for using these computed properties and<br>&gt;&gt;&gt;&gt;&gt; types of BinaryFloatingPoint is one in which specific fixed width types<br>&gt;&gt;&gt;&gt;&gt; really matters a lot (look at the name of the protocol and the properties<br>&gt;&gt;&gt;&gt;&gt; and assocated types we are talking about).<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; /Jens<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Sat, Aug 27, 2016 at 1:15 AM, Jens Persson &lt;jens at bitcycle.com&gt; wr<br>&gt;&gt;&gt;&gt;&gt; ote:<br>&gt;&gt;&gt;&gt;&gt; Reason for asking is that I have this:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; extension Double {<br>&gt;&gt;&gt;&gt;&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;&gt;&gt;&gt;&gt;         let bitPattern = s | (1023 &lt;&lt; 52)<br>&gt;&gt;&gt;&gt;&gt;         self = unsafeBitCast(bitPattern, to: Double.self) - 1.0<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; extension Float {<br>&gt;&gt;&gt;&gt;&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;&gt;&gt;&gt;&gt;         let bitPattern = s | (127 &lt;&lt; 23)<br>&gt;&gt;&gt;&gt;&gt;         self = unsafeBitCast(bitPattern, to: Float.self) - 1.0<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; But they would be better as:<br>&gt;&gt;&gt;&gt;&gt; extension BinaryFloatingPoint {<br>&gt;&gt;&gt;&gt;&gt;     init(unitRangeFromRawSignificand s: RawSignificand) {<br>&gt;&gt;&gt;&gt;&gt;         ... problems here, have to try casting things into<br>&gt;&gt;&gt;&gt;&gt; RawSignificand&#39;s type ...<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Please have a go at that and perhaps you see what I mean or you will<br>&gt;&gt;&gt;&gt;&gt; come up with a nice solution that I have missed. (Speed is very important<br>&gt;&gt;&gt;&gt;&gt; btw.)<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; /Jens<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Sat, Aug 27, 2016 at 1:02 AM, Stephen Canon &lt;scanon at apple.com<br>&gt;&gt;&gt;&gt;&gt; &gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt; On Aug 26, 2016, at 6:06 PM, Jens Persson via swift-dev &lt;<br>&gt;&gt;&gt;&gt;&gt; swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; I can understand why<br>&gt;&gt;&gt;&gt;&gt; &gt; Double.RawSignificand is UInt64<br>&gt;&gt;&gt;&gt;&gt; &gt; and<br>&gt;&gt;&gt;&gt;&gt; &gt; Float.RawSignificand is UInt32<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; But I can&#39;t understand why both<br>&gt;&gt;&gt;&gt;&gt; &gt; Double.RawExponent<br>&gt;&gt;&gt;&gt;&gt; &gt; and<br>&gt;&gt;&gt;&gt;&gt; &gt; Float.RawExponent<br>&gt;&gt;&gt;&gt;&gt; &gt; should be UInt.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Why aren&#39;t they also just UInt64 and UInt32, resp.?<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Let me flip the question: why would they be UInt64 and UInt32?  Absent<br>&gt;&gt;&gt;&gt;&gt; a reason to prefer a specific fixed-with type, Swift integers should<br>&gt;&gt;&gt;&gt;&gt; generally default to being [U]Int (and ideally Int, but RawExponent<br>&gt;&gt;&gt;&gt;&gt; is Unsigned).<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; – Steve<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-dev at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-dev at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160827/826ca547/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
