<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b35b44357e4cca3a1de39ba1199c9ab5?s=50"></div><header><strong>What about a VBA style with Statement?</strong> from <string>ted van gaalen</string> &lt;tedvgiosdev at gmail.com&gt;<p>April 14, 2016 at 12:00:00am</p></header><div class="content"><p>Well, method cascading might also be<br>an alternative to consider?<br></p><p>In Smalltalk this is possible like so: <br></p><p>     someInstance<br>            eat: ‘cookie&#39;<br>            print: “Hmmm, that was good!”<br>            beHappy<br>            singCookiesSong ;<br> <br>In Smalltalk, the semicolon closes the method cascading <br>       <br></p><p>In Dart, method cascading goes like this:<br></p><p>     someInstance<br>            ..eat (“‘cookie”)<br>            ..print( “Hmmm, that was good!”)<br>            ..beHappy()<br>            ..singCookiesSong();<br></p><p><br>cascading is indicated by a  .. doubleDot, preceding the method names<br></p><p>Why not implement this in Swift?<br>in that case the semicolon would not be needed.<br></p><p>What to do with methods (functions) that return something? <br>(in Smalltalk, like in Swift?, if i remember correctly,  ‘self’ is implicitly<br>returned in absence of a return value and can be ignored.<br></p><p>  <br>TedvG<br></p><p><br></p><p><br></p><p><br>&gt; On 13.04.2016 18:09, Radosław Pietruszewski wrote:<br>&gt;&gt; I’m -1, at least in the foreseeable future. I do agree that this is a<br>&gt;&gt; useful construct, but if I can do it in library code, paying only a small<br>&gt;&gt; price for this, I’d prefer Swift to grow better in places that a library<br>&gt;&gt; *can’t* fix.<br>&gt; <br>&gt; Well, there a lot of things that *your personal* library can fix for you.<br>&gt; Should we stop improve the language and start to write just personal libs <br>&gt; with improvements?<br>&gt; This proposals about the feature that makes Swift better, more enjoyable to <br>&gt; work with.<br>&gt; <br>&gt; Btw, this &quot;with&quot; method you suggest is not replacement for language <br>&gt; construction - it allows compilation when struct instance constant (let s = <br>&gt; SomeStruct()) is changed inside block. Do you like this? Do you want to <br>&gt; produce such an non-safe code to your projects?<br>&gt; <br>&gt;&gt; <br>&gt;&gt; No — for now, it’s best to use a free function for now. And, like I<br>&gt; <br>&gt; No, not best, even not OK. Described above.<br>&gt; <br>&gt;&gt; mentioned, universal conformances could allow this to be easily added to<br>&gt;&gt; all types — and so I’d focus on pushing *that* proposal.<br>&gt; <br>&gt; As I understand, such a method will have the same problem with un-safe <br>&gt; behavior in case of constant.<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>What about a VBA style with Statement?</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>April 14, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; (in Smalltalk, like in Swift?, if i remember correctly,  ‘self’ is implicitly<br>&gt; returned in absence of a return value and can be ignored.<br>I&#39;m a big fan of returning self — its much more useful than void…<br>But it seems the Swift-community doesn&#39;t like method chaining.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc045f9bdc3bd1885767f2a2ba8af458?s=50"></div><header><strong>What about a VBA style with Statement?</strong> from <string>Jonathan Tang</string> &lt;jonathan.d.tang at gmail.com&gt;<p>April 14, 2016 at 09:00:00am</p></header><div class="content"><p>On Thu, Apr 14, 2016 at 8:23 AM, Tino Heth via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; (in Smalltalk, like in Swift?, if i remember correctly,  ‘self’ is<br>&gt; implicitly<br>&gt; &gt; returned in absence of a return value and can be ignored.<br>&gt; I&#39;m a big fan of returning self — its much more useful than void…<br>&gt; But it seems the Swift-community doesn&#39;t like method chaining.<br>&gt;<br>&gt;<br>I dunno about that... AlamoFire and SwiftyJSON both use it, and are quite<br>popular with rank-and-file Swift programmers.  It&#39;s certainly not popular<br>in the Objective-C community (where the syntax doesn&#39;t really support it),<br>but it seems like the Swift community may be warming up to it.<br></p><p>I also like the idea of a dedicated method-cascading operator, like what<br>Dart has.  It eliminates the need for a programmer to explicitly remember<br>to &#39;return self&#39; at the end of a chainable method.  Not sure how well it&#39;d<br>integrate with SE-0047 (@discardableResult) though.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160414/146adf26/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>What about a VBA style with Statement?</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April 14, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Apr 14, 2016, at 10:42 AM, Jonathan Tang via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Thu, Apr 14, 2016 at 8:23 AM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; &gt; (in Smalltalk, like in Swift?, if i remember correctly,  ‘self’ is implicitly<br>&gt; &gt; returned in absence of a return value and can be ignored.<br>&gt; I&#39;m a big fan of returning self — its much more useful than void…<br>&gt; But it seems the Swift-community doesn&#39;t like method chaining.<br>&gt; <br>&gt; <br>&gt; I dunno about that... AlamoFire and SwiftyJSON both use it, and are quite popular with rank-and-file Swift programmers.  It&#39;s certainly not popular in the Objective-C community (where the syntax doesn&#39;t really support it), but it seems like the Swift community may be warming up to it.<br>&gt; <br>&gt; I also like the idea of a dedicated method-cascading operator, like what Dart has.  It eliminates the need for a programmer to explicitly remember to &#39;return self&#39; at the end of a chainable method.  Not sure how well it&#39;d integrate with SE-0047 (@discardableResult) though.<br></p><p>Method cascades draft: https://gist.github.com/erica/6794d48d917e2084d6ed<br></p><p>deferred to after 3.0<br></p><p>-- E<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160414/0724b4ae/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>What about a VBA style with Statement?</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>April 15, 2016 at 12:00:00am</p></header><div class="content"><p>&gt;&gt; I also like the idea of a dedicated method-cascading operator, like what Dart has.  It eliminates the need for a programmer to explicitly remember to &#39;return self&#39; at the end of a chainable method.  Not sure how well it&#39;d integrate with SE-0047 (@discardableResult) though.<br>&gt; <br>&gt; Method cascades draft: https://gist.github.com/erica/6794d48d917e2084d6ed &lt;https://gist.github.com/erica/6794d48d917e2084d6ed&gt;<br>&gt; <br>&gt; deferred to after 3.0<br></p><p>I really think this settles the discussion, because methods cascades are *the* way to implement this kind of thing. (And for the record, I would prefer a SmallTalk/Dart-like syntax to a &quot;with&quot; statement.)<br></p><p>A<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160415/f6479cd6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>What about a VBA style with Statement?</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April 14, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Apr 14, 2016, at 12:30 PM, Andrey Tarantsov &lt;andrey at tarantsov.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; I also like the idea of a dedicated method-cascading operator, like what Dart has.  It eliminates the need for a programmer to explicitly remember to &#39;return self&#39; at the end of a chainable method.  Not sure how well it&#39;d integrate with SE-0047 (@discardableResult) though.<br>&gt;&gt; <br>&gt;&gt; Method cascades draft: https://gist.github.com/erica/6794d48d917e2084d6ed &lt;https://gist.github.com/erica/6794d48d917e2084d6ed&gt;<br>&gt;&gt; <br>&gt;&gt; deferred to after 3.0<br>&gt; <br>&gt; I really think this settles the discussion, because methods cascades are *the* way to implement this kind of thing. (And for the record, I would prefer a SmallTalk/Dart-like syntax to a &quot;with&quot; statement.)<br></p><p>It&#39;s been quite a while since the original discussion and I&#39;m going to go all Brent R-G on the answer, which is I&#39;ve come to prefer the Dart solution for cascading, think `with` is better suited for mutating copies of struct constants (Immutable setters &lt;http://ericasadun.com/2016/03/24/immutable-setters/&gt;, may not be language-inclusion suitable), and think binding self in closures is yet a third issue.<br></p><p>Brent, concur?<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160414/c5d22363/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>What about a VBA style with Statement?</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April 14, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt;&gt; I really think this settles the discussion, because methods cascades are *the* way to implement this kind of thing. (And for the record, I would prefer a SmallTalk/Dart-like syntax to a &quot;with&quot; statement.)<br>&gt; <br>&gt; It&#39;s been quite a while since the original discussion and I&#39;m going to go all Brent R-G on the answer, which is I&#39;ve come to prefer the Dart solution for cascading, think `with` is better suited for mutating copies of struct constants (Immutable setters, may not be language-inclusion suitable), and think binding self in closures is yet a third issue.<br>&gt; <br>&gt; Brent, concur?<br></p><p>I&#39;m not totally sold on Dart-style method cascading (although that&#39;s partly just the `..` syntax), but if that&#39;s been deferred to after Swift 3, then we&#39;re certainly in agreement on what we want now. :^)<br></p><p>In terms of the `with` function, I think one version would handle both shorthanding a long variable name *and* modifying and returning a value:<br></p><p>	@discardableResult public func with&lt;T&gt;(_ value: T, user: @noescape inout T throws -&gt; Void) rethrows -&gt; T {<br>		var copy = value<br>		try user(&amp;copy)<br>		return copy<br>	}<br></p><p>At some point, they fixed the weird thing where you had to explicitly give the type of an inout closure parameter, so there&#39;s no syntactic penalty if you don&#39;t need to mutate. `user` could be `@noescape(once)` if that feature is ever added.<br></p><p>In theory, it might be nice to have two versions, one mutating and one not, simply so you don&#39;t accidentally throw away a mutation:<br></p><p>	public func with&lt;T&gt;(_ value: T, user: @noescape inout T throws -&gt; Void) rethrows -&gt; T {<br>		var copy = value<br>		try user(&amp;copy)<br>		return copy<br>	}<br></p><p>	public func with&lt;T&gt;(_ value: T, user: @noescape T throws -&gt; Void) rethrows {<br>		try user(value)<br>	}<br></p><p>In practice, however, Swift (or Swift 2 at least) seems to consider this ambiguous, so we&#39;re probably out of luck there.<br></p><p>In terms of `self` parameters, I think the rule is simply this:<br></p><p>* Functions and closures (but not methods) may give a parameter the internal name `self`.<br>* If there is a `self` parameter, it behaves just as `self` in a method would—implicit method calls, special treatment in terms of capturing by closures, assignable only if it&#39;s `inout`, etc.<br>* If a closure has a `self` parameter, there is no way to access the outer scope&#39;s `self`, just like any other shadowed variable.<br></p><p>I would actually like to see `self` become as shadowable as any other variable, but there seems to be some resistance to that idea.<br></p><p><br></p><p>P.S. Does that mean that blithely declaring that something is actually several orthogonal features is now a Royal decree?<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>What about a VBA style with Statement?</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>April 18, 2016 at 06:00:00pm</p></header><div class="content"><p>As for methods cascades, IMO it is a good feature and I support it as <br>addition to &#39;with&#39; feature. Method cascading can&#39;t be used to set/get <br>values of multiply props, the main purpose of &#39;with&#39;<br></p><p>I strongly feel that functions is not a solution for &#39;with&#39; feature.<br>Functions add additional complexity, more possibilities for <br>problems/errors, as we are creating the bock and calling it then.<br>It seems like functions allows to produce code that will compile, but will <br>raise error on execution like<br>struct ST {<br>     var x = 5<br>}<br></p><p>with (ST) {  // just type here<br>     print($0.x)<br>}<br></p><p>and some number of similar problems. Also, why do we need parenthesis in <br>with? Do we need them in &quot;if&quot;? in &quot;for&quot; ? in &quot;switch&quot;?<br></p><p>with s {<br>}<br></p><p>I believe &quot;with&quot; should be implemented as standard construction of the <br>language. Opinions?<br></p><p>On 15.04.2016 5:12, Brent Royal-Gordon via swift-evolution wrote:<br>&gt;&gt;&gt; I really think this settles the discussion, because methods cascades are *the* way to implement this kind of thing. (And for the record, I would prefer a SmallTalk/Dart-like syntax to a &quot;with&quot; statement.)<br>&gt;&gt;<br>&gt;&gt; It&#39;s been quite a while since the original discussion and I&#39;m going to go all Brent R-G on the answer, which is I&#39;ve come to prefer the Dart solution for cascading, think `with` is better suited for mutating copies of struct constants (Immutable setters, may not be language-inclusion suitable), and think binding self in closures is yet a third issue.<br>&gt;&gt;<br>&gt;&gt; Brent, concur?<br>&gt;<br>&gt; I&#39;m not totally sold on Dart-style method cascading (although that&#39;s partly just the `..` syntax), but if that&#39;s been deferred to after Swift 3, then we&#39;re certainly in agreement on what we want now. :^)<br>&gt;<br>&gt; In terms of the `with` function, I think one version would handle both shorthanding a long variable name *and* modifying and returning a value:<br>&gt;<br>&gt; 	@discardableResult public func with&lt;T&gt;(_ value: T, user: @noescape inout T throws -&gt; Void) rethrows -&gt; T {<br>&gt; 		var copy = value<br>&gt; 		try user(&amp;copy)<br>&gt; 		return copy<br>&gt; 	}<br>&gt;<br>&gt; At some point, they fixed the weird thing where you had to explicitly give the type of an inout closure parameter, so there&#39;s no syntactic penalty if you don&#39;t need to mutate. `user` could be `@noescape(once)` if that feature is ever added.<br>&gt;<br>&gt; In theory, it might be nice to have two versions, one mutating and one not, simply so you don&#39;t accidentally throw away a mutation:<br>&gt;<br>&gt; 	public func with&lt;T&gt;(_ value: T, user: @noescape inout T throws -&gt; Void) rethrows -&gt; T {<br>&gt; 		var copy = value<br>&gt; 		try user(&amp;copy)<br>&gt; 		return copy<br>&gt; 	}<br>&gt;<br>&gt; 	public func with&lt;T&gt;(_ value: T, user: @noescape T throws -&gt; Void) rethrows {<br>&gt; 		try user(value)<br>&gt; 	}<br>&gt;<br>&gt; In practice, however, Swift (or Swift 2 at least) seems to consider this ambiguous, so we&#39;re probably out of luck there.<br>&gt;<br>&gt; In terms of `self` parameters, I think the rule is simply this:<br>&gt;<br>&gt; * Functions and closures (but not methods) may give a parameter the internal name `self`.<br>&gt; * If there is a `self` parameter, it behaves just as `self` in a method would—implicit method calls, special treatment in terms of capturing by closures, assignable only if it&#39;s `inout`, etc.<br>&gt; * If a closure has a `self` parameter, there is no way to access the outer scope&#39;s `self`, just like any other shadowed variable.<br>&gt;<br>&gt; I would actually like to see `self` become as shadowable as any other variable, but there seems to be some resistance to that idea.<br>&gt;<br>&gt;<br>&gt;<br>&gt; P.S. Does that mean that blithely declaring that something is actually several orthogonal features is now a Royal decree?<br>&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>What about a VBA style with Statement?</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>April 19, 2016 at 10:00:00am</p></header><div class="content"><p>-1<br>I can&#39;t see a significant advantage over using the library based approach where the receiver is clearly recognizable and no context problems arise.<br></p><p>-Thorsten <br></p><p>&gt; Am 14.04.2016 um 19:03 schrieb Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 14, 2016, at 10:42 AM, Jonathan Tang via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Thu, Apr 14, 2016 at 8:23 AM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; (in Smalltalk, like in Swift?, if i remember correctly,  ‘self’ is implicitly<br>&gt;&gt;&gt; &gt; returned in absence of a return value and can be ignored.<br>&gt;&gt;&gt; I&#39;m a big fan of returning self — its much more useful than void…<br>&gt;&gt;&gt; But it seems the Swift-community doesn&#39;t like method chaining.<br>&gt;&gt; <br>&gt;&gt; I dunno about that... AlamoFire and SwiftyJSON both use it, and are quite popular with rank-and-file Swift programmers.  It&#39;s certainly not popular in the Objective-C community (where the syntax doesn&#39;t really support it), but it seems like the Swift community may be warming up to it.<br>&gt;&gt; <br>&gt;&gt; I also like the idea of a dedicated method-cascading operator, like what Dart has.  It eliminates the need for a programmer to explicitly remember to &#39;return self&#39; at the end of a chainable method.  Not sure how well it&#39;d integrate with SE-0047 (@discardableResult) though.<br>&gt; <br>&gt; Method cascades draft: https://gist.github.com/erica/6794d48d917e2084d6ed<br>&gt; <br>&gt; deferred to after 3.0<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160419/37fbeba1/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>What about a VBA style with Statement?</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>April 19, 2016 at 10:00:00am</p></header><div class="content"><p>Returning self is not needed for method cascades in Smalltalk. Actually the return values are ignored because all methods of a cascade are sent to the same receiver. Only the last return value is used as result of the whole cascade.<br></p><p>The method cascade in Smalltalk is written as follows:<br></p><p>receive method1: x; method2: y; method3: z.<br></p><p>i.e. messages which ar part of the cascade are separated by &#39;;&#39; and the statement is finished by &#39;.&#39; like all statements in Smalltalk.<br></p><p>-Thorsten <br></p><p>&gt; Am 14.04.2016 um 17:23 schrieb Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; (in Smalltalk, like in Swift?, if i remember correctly,  ‘self’ is implicitly<br>&gt;&gt; returned in absence of a return value and can be ignored.<br>&gt; I&#39;m a big fan of returning self — its much more useful than void…<br>&gt; But it seems the Swift-community doesn&#39;t like method chaining.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
