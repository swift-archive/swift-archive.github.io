<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/30aa7afb91d7cf736566fa69a4459a07?s=50"></div><header><strong>Proposal: Package Manager Version Pinning</strong> from <string>Ankit Aggarwal</string> &lt;ankit_aggarwal at apple.com&gt;<p>October 14, 2016 at 11:00:00am</p></header><div class="content"><p>Hi,<br></p><p>We&#39;re proposing version pinning feature in Swift Package Manager. The proposal is available here &lt;https://github.com/aciidb0mb3r/swift-evolution/blob/version-pinning/proposals/NNNN-Version-Pinning.md&gt; and also in this email:<br></p><p>Feedback welcomed!<br></p><p>Thanks,<br>Ankit<br></p><p>--------<br></p><p>Package Manager Version Pinning<br>Proposal: SE-XXXX<br>Author: Daniel Dunbar &lt;https://github.com/ddunbar&gt;, Ankit Aggarwal &lt;https://github.com/aciidb0mb3r&gt;<br>Review Manager: TBD<br>Status: Discussion<br>Introduction<br>This is a proposal for adding package manager features to &quot;pin&quot; or &quot;lock&quot; package dependencies to particular versions.<br></p><p>Motivation<br>As used in this proposal, version pinning refers to the practice of controlling exactly which specific version of a dependency is selected by the dependency resolution algorithm, independent from the semantic versioning specification. Thus, it is a way of instructing the package manager to select a particular version from among all of the versions of a package which could be chosen while honoring the dependency constraints.<br></p><p>Terminology<br></p><p>We have chosen to use &quot;pinning&quot; to refer to this feature, over &quot;lockfiles&quot;, since the term &quot;lock&quot; is already overloaded between POSIX file locks and locks in concurrent programming.<br></p><p>Philosophy<br></p><p>Our philosophy with regard to pinning is that we actively want to encourage packages to develop against the latest semantically appropriate versions of their dependencies, in order to foster rapid development amongst the ecosystem and strong reliance on the semantic versioning concept. Our design for version pinning is thus intended to be a feature for package authors and users to use in crafting specific workflows, not be a mechanism by which most of the packages in the ecosystem pin themselves to specific versions of each other.<br></p><p>Use Cases<br></p><p>Our proposal is designed to satisfy several different use cases for such a behavior:<br></p><p>Standardizing team workflows<br></p><p>When collaborating on a package, it can be valuable for team members (and continuous integration) to all know they are using the same exact version of dependencies, to avoid &quot;works for me&quot; situations.<br></p><p>This can be particularly important for certain kinds of open source projects which are actively being cloned by new users, and which want to have some measure of control around exactly which available version of a dependency is selected.<br></p><p>Difficult to test packages or dependencies<br></p><p>Complex packages which have dependencies which may be hard to test, or hard to analyze when they break, may choose to maintain careful control over what versions of their upstream dependencies they recommend -- even if conceptually they regularly update those recommendations following the true semantic version specification of the dependency.<br></p><p>Dependency locking w.r.t. deployment<br></p><p>When stabilizing a release for deployment, or building a version of a package for deployment, it is important to be able to lock down the exact versions of dependencies in use, so that the resulting product can be exactly recreated later if necessary.<br></p><p>Proposed solution<br>We will introduce support for an optional new file Package.pins adjacent to the Package.swift manifest, called the &quot;pins file&quot;. We will also introduce a number of new commands (see below) for maintaining the pins file.<br></p><p>This file will record the active version pin information for the package, including data such as the package identifier, the pinned version, and explicit information on the pinned version (e.g., the commit hash/SHA for the resolved tag).<br></p><p>The exact file format is unspecified/implementation defined, however, in practice it will be a JSON data file.<br></p><p>This file may be checked into SCM by the user, so that its effects apply to all users of the package. However, it may also be maintained only locally (e.g., placed in the .gitignore file). We intend to leave it to package authors to decide which use case is best for their project.<br></p><p>In the presence of a Package.pins file, the package manager will respect the pinned dependencies recorded in the file whenever it needs to do dependency resolution (e.g., on the initial checkout or when updating).<br></p><p>The pins file will not override Manifest specified version requirements and it will be an error (with proper diagnostics) if there is a conflict between the pins and the manifest specification.<br></p><p>Detailed Design<br>We will add a new command pin to swift package tool with following semantics:<br></p><p>$ swift package pin ( [--all] | [&lt;package-name&gt;] [&lt;version&gt;] ) [--message &lt;message&gt;]<br>The package-name refers to the name of the package as specified in its manifest.<br></p><p>This command pins one or all dependencies. The command which pins a single version can optionally take a specific version to pin to, if unspecified (or with --all) the behaviour is to pin to the current package version in use. Examples: <br></p><p>$ swift package pin --all - pins all the dependencies.<br>$ swift package pin Foo - pins Foo at current resolved version.<br>$ swift package pin Foo 1.2.3 - pins Foo at 1.2.3. The specified version should be valid and resolvable.<br>The --reason option is an optional argument to document the reason for pinning a dependency. This could be helpful for user to later remember why a dependency was pinned. Example: <br></p><p>$ swift package pin Foo --reason &quot;The patch updates for Foo are really unstable and need screening.&quot;<br>Dependencies are never automatically pinned, pinning is only ever taken as a result of an explicit user action.<br></p><p>We will add a new command unpin:<br></p><p>$ swift package unpin ( [--all] | [&lt;package-name&gt;] )<br>This is the counterpart to the pin command, and unpins one or all packages.<br></p><p>We will fetch and resolve the dependencies when running the pin commands, in case we don&#39;t have the complete dependency graph yet.<br></p><p>We will extend the workflow for update to honour version pinning, that is, it will only update packages which are unpinned, and it will only update to versions which can satisfy the existing pins. The update command will, however, also take an optional argument --repin:<br></p><p>$ swift package update [--repin]<br>Update command errors if there are no unpinned packages which can be updated.<br></p><p>Otherwise, the behaviour is to update all unpinned packages to the latest possible versions which can be resolved while respecting the existing pins.<br></p><p>The [--repin] argument can be used to lift the version pinning restrictions. In this case, the behaviour is that all packages are updated, and packages which were previously pinned are then repinned to the latest resolved versions.<br></p><p>The update and checkout will both emit logs, notifying the user that pinning is in effect.<br></p><p>The swift package show-dependencies subcommand will be updated to indicate if a dependency is pinned.<br></p><p>As a future extension, we anticipate using the SHA information recorded in a pins file as a security feature, to prevent man-in-the-middle attacks on parts of the package graph.<br></p><p>Impact on existing code<br>There will be change in the behaviours of swift build and swift package update in presence of the pins file, as noted in the proposal however the existing package will continue to build without any modifications.<br></p><p>Alternative considered<br>We considered making the pinning behavior default on running swift build, however we think that pinning by default is likely to make the package graph more constrained than it should be. It drives the user away from taking full advantage of semantic versioning. We think it will be good for the package ecosystem if such a restriction is not the default behavior and that this design will lead to faster discovery of bugs and fixes in the upstream.<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20161014/09c7b646/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f116cb3be23153ec08b94e8bd4dbcfeb?s=50"></div><header><strong>Proposal: Package Manager Version Pinning</strong> from <string>orta therox</string> &lt;orta.therox at gmail.com&gt;<p>October 14, 2016 at 08:00:00am</p></header><div class="content"><p>Please don’t make this a separate command, it should ideally be created at the end of an build (when there isn’t one already) or an update of your dependencies - most people will be expecting to get the same set of dependencies as the rest of their team. This pattern makes that harder.<br></p><p>NPM shrinkwrap is an example of this, and it’s a bad one - I’ve wasted a lot of time trying to keep that up to date for our npm projects. Facebook made a replacement for NPM with mainly the  feature of “always locking” in yarn &lt;https://yarnpkg.com/&gt; and I’d expect that to take a lot of the JS mindshare on this one feature alone.<br></p><p>-- <br></p><p>[A.]	    Orta Therox<br></p><p>&gt; w/ Artsy &lt;http://artsy.net/&gt;CocoaPods &lt;http://cocoapods.org/&gt; / CocoaDocs &lt;http://cocoadocs.org/&gt; / GIFs.app &lt;https://itunes.apple.com/us/app/gifs/id961850017?l=en&amp;mt=12&gt;<br>&gt; @orta &lt;http://twitter.com/orta&gt; / orta.github.com &lt;http://orta.github.com/&gt;<br>&gt; Artsy is totally hiring iOS Devs &lt;https://artsy.net/job/mobile-engineer&gt; ATM<br></p><p>&gt; On 14 Oct 2016, at 07:01, Ankit Aggarwal via swift-build-dev &lt;swift-build-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi,<br>&gt; <br>&gt; We&#39;re proposing version pinning feature in Swift Package Manager. The proposal is available here &lt;https://github.com/aciidb0mb3r/swift-evolution/blob/version-pinning/proposals/NNNN-Version-Pinning.md&gt; and also in this email:<br>&gt; <br>&gt; Feedback welcomed!<br>&gt; <br>&gt; Thanks,<br>&gt; Ankit<br>&gt; <br>&gt; --------<br>&gt; <br>&gt; Package Manager Version Pinning<br>&gt; Proposal: SE-XXXX<br>&gt; Author: Daniel Dunbar &lt;https://github.com/ddunbar&gt;, Ankit Aggarwal &lt;https://github.com/aciidb0mb3r&gt;<br>&gt; Review Manager: TBD<br>&gt; Status: Discussion<br>&gt; Introduction<br>&gt; This is a proposal for adding package manager features to &quot;pin&quot; or &quot;lock&quot; package dependencies to particular versions.<br>&gt; <br>&gt; Motivation<br>&gt; As used in this proposal, version pinning refers to the practice of controlling exactly which specific version of a dependency is selected by the dependency resolution algorithm, independent from the semantic versioning specification. Thus, it is a way of instructing the package manager to select a particular version from among all of the versions of a package which could be chosen while honoring the dependency constraints.<br>&gt; <br>&gt; Terminology<br>&gt; <br>&gt; We have chosen to use &quot;pinning&quot; to refer to this feature, over &quot;lockfiles&quot;, since the term &quot;lock&quot; is already overloaded between POSIX file locks and locks in concurrent programming.<br>&gt; <br>&gt; Philosophy<br>&gt; <br>&gt; Our philosophy with regard to pinning is that we actively want to encourage packages to develop against the latest semantically appropriate versions of their dependencies, in order to foster rapid development amongst the ecosystem and strong reliance on the semantic versioning concept. Our design for version pinning is thus intended to be a feature for package authors and users to use in crafting specific workflows, not be a mechanism by which most of the packages in the ecosystem pin themselves to specific versions of each other.<br>&gt; <br>&gt; Use Cases<br>&gt; <br>&gt; Our proposal is designed to satisfy several different use cases for such a behavior:<br>&gt; <br>&gt; Standardizing team workflows<br>&gt; <br>&gt; When collaborating on a package, it can be valuable for team members (and continuous integration) to all know they are using the same exact version of dependencies, to avoid &quot;works for me&quot; situations.<br>&gt; <br>&gt; This can be particularly important for certain kinds of open source projects which are actively being cloned by new users, and which want to have some measure of control around exactly which available version of a dependency is selected.<br>&gt; <br>&gt; Difficult to test packages or dependencies<br>&gt; <br>&gt; Complex packages which have dependencies which may be hard to test, or hard to analyze when they break, may choose to maintain careful control over what versions of their upstream dependencies they recommend -- even if conceptually they regularly update those recommendations following the true semantic version specification of the dependency.<br>&gt; <br>&gt; Dependency locking w.r.t. deployment<br>&gt; <br>&gt; When stabilizing a release for deployment, or building a version of a package for deployment, it is important to be able to lock down the exact versions of dependencies in use, so that the resulting product can be exactly recreated later if necessary.<br>&gt; <br>&gt; Proposed solution<br>&gt; We will introduce support for an optional new file Package.pins adjacent to the Package.swift manifest, called the &quot;pins file&quot;. We will also introduce a number of new commands (see below) for maintaining the pins file.<br>&gt; <br>&gt; This file will record the active version pin information for the package, including data such as the package identifier, the pinned version, and explicit information on the pinned version (e.g., the commit hash/SHA for the resolved tag).<br>&gt; <br>&gt; The exact file format is unspecified/implementation defined, however, in practice it will be a JSON data file.<br>&gt; <br>&gt; This file may be checked into SCM by the user, so that its effects apply to all users of the package. However, it may also be maintained only locally (e.g., placed in the .gitignore file). We intend to leave it to package authors to decide which use case is best for their project.<br>&gt; <br>&gt; In the presence of a Package.pins file, the package manager will respect the pinned dependencies recorded in the file whenever it needs to do dependency resolution (e.g., on the initial checkout or when updating).<br>&gt; <br>&gt; The pins file will not override Manifest specified version requirements and it will be an error (with proper diagnostics) if there is a conflict between the pins and the manifest specification.<br>&gt; <br>&gt; Detailed Design<br>&gt; We will add a new command pin to swift package tool with following semantics:<br>&gt; <br>&gt; $ swift package pin ( [--all] | [&lt;package-name&gt;] [&lt;version&gt;] ) [--message &lt;message&gt;]<br>&gt; The package-name refers to the name of the package as specified in its manifest.<br>&gt; <br>&gt; This command pins one or all dependencies. The command which pins a single version can optionally take a specific version to pin to, if unspecified (or with --all) the behaviour is to pin to the current package version in use. Examples: <br>&gt; <br>&gt; $ swift package pin --all - pins all the dependencies.<br>&gt; $ swift package pin Foo - pins Foo at current resolved version.<br>&gt; $ swift package pin Foo 1.2.3 - pins Foo at 1.2.3. The specified version should be valid and resolvable.<br>&gt; The --reason option is an optional argument to document the reason for pinning a dependency. This could be helpful for user to later remember why a dependency was pinned. Example: <br>&gt; <br>&gt; $ swift package pin Foo --reason &quot;The patch updates for Foo are really unstable and need screening.&quot;<br>&gt; Dependencies are never automatically pinned, pinning is only ever taken as a result of an explicit user action.<br>&gt; <br>&gt; We will add a new command unpin:<br>&gt; <br>&gt; $ swift package unpin ( [--all] | [&lt;package-name&gt;] )<br>&gt; This is the counterpart to the pin command, and unpins one or all packages.<br>&gt; <br>&gt; We will fetch and resolve the dependencies when running the pin commands, in case we don&#39;t have the complete dependency graph yet.<br>&gt; <br>&gt; We will extend the workflow for update to honour version pinning, that is, it will only update packages which are unpinned, and it will only update to versions which can satisfy the existing pins. The update command will, however, also take an optional argument --repin:<br>&gt; <br>&gt; $ swift package update [--repin]<br>&gt; Update command errors if there are no unpinned packages which can be updated.<br>&gt; <br>&gt; Otherwise, the behaviour is to update all unpinned packages to the latest possible versions which can be resolved while respecting the existing pins.<br>&gt; <br>&gt; The [--repin] argument can be used to lift the version pinning restrictions. In this case, the behaviour is that all packages are updated, and packages which were previously pinned are then repinned to the latest resolved versions.<br>&gt; <br>&gt; The update and checkout will both emit logs, notifying the user that pinning is in effect.<br>&gt; <br>&gt; The swift package show-dependencies subcommand will be updated to indicate if a dependency is pinned.<br>&gt; <br>&gt; As a future extension, we anticipate using the SHA information recorded in a pins file as a security feature, to prevent man-in-the-middle attacks on parts of the package graph.<br>&gt; <br>&gt; Impact on existing code<br>&gt; There will be change in the behaviours of swift build and swift package update in presence of the pins file, as noted in the proposal however the existing package will continue to build without any modifications.<br>&gt; <br>&gt; Alternative considered<br>&gt; We considered making the pinning behavior default on running swift build, however we think that pinning by default is likely to make the package graph more constrained than it should be. It drives the user away from taking full advantage of semantic versioning. We think it will be good for the package ecosystem if such a restriction is not the default behavior and that this design will lead to faster discovery of bugs and fixes in the upstream.<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-build-dev mailing list<br>&gt; swift-build-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20161014/8adf4bce/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/424a9ce662b059c35063b405e160461d?s=50"></div><header><strong>Proposal: Package Manager Version Pinning</strong> from <string>Eloy Durán</string> &lt;eloy.de.enige at gmail.com&gt;<p>October 14, 2016 at 01:00:00pm</p></header><div class="content"><p>I cannot agree more with Orta.<br></p><p>&gt; It drives the user away from taking full advantage of semantic versioning.<br></p><p>While I ideally subscribe to this thought, the truth of the matter is that this has proven unreliable on multiple occasions. Promoting the idea that it works is going to inevitably lead users into problems when they did not take explicit user action to update dependencies.<br></p><p>Semantic versioning is a great tool when you decide to sit down and explicitly update dependencies.<br></p><p>&gt; We think it will be good for the package ecosystem if such a restriction is not the default behavior and that this design will lead to faster discovery of bugs and fixes in the upstream.<br></p><p>Again, ideally I would subscribe to this, but the truth is that when people are working on their projects they *really really really* do *not* like their builds breaking, especially not when it’s seemingly caused outside of their own fault.<br></p><p>In the end, it comes down to whether you prioritise surfacing bugs (long term happiness) over user-experience (short term happiness). As a dependency manager author, I can tell you that I agree with your ideals and would want to choose the former, but as a user of dependency managers I would choose UX and Getting (The) Things (I Really Wanted To Do) Done over surfacing bugs *any* day.<br></p><p>[A.]		Eloy Durán<br>		Artsy &lt;http://artsy.net/&gt;<br>		<br>		eloy at artsy.net &lt;mailto:eloy at artsy.net&gt;		Twitter &lt;https://twitter.com/alloy&gt;<br>		GitHub &lt;https://github.com/alloy&gt;<br>&gt; On 14 Oct 2016, at 09:29, orta therox via swift-build-dev &lt;swift-build-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Please don’t make this a separate command, it should ideally be created at the end of an build (when there isn’t one already) or an update of your dependencies - most people will be expecting to get the same set of dependencies as the rest of their team. This pattern makes that harder.<br>&gt; <br>&gt; NPM shrinkwrap is an example of this, and it’s a bad one - I’ve wasted a lot of time trying to keep that up to date for our npm projects. Facebook made a replacement for NPM with mainly the  feature of “always locking” in yarn &lt;https://yarnpkg.com/&gt; and I’d expect that to take a lot of the JS mindshare on this one feature alone.<br>&gt; <br>&gt; -- <br>&gt; <br>&gt; [A.]	    Orta Therox<br>&gt; <br>&gt;&gt; w/ Artsy &lt;http://artsy.net/&gt;CocoaPods &lt;http://cocoapods.org/&gt; / CocoaDocs &lt;http://cocoadocs.org/&gt; / GIFs.app &lt;https://itunes.apple.com/us/app/gifs/id961850017?l=en&amp;mt=12&gt;<br>&gt;&gt; @orta &lt;http://twitter.com/orta&gt; / orta.github.com &lt;http://orta.github.com/&gt;<br>&gt;&gt; Artsy is totally hiring iOS Devs &lt;https://artsy.net/job/mobile-engineer&gt; ATM<br>&gt; <br>&gt;&gt; On 14 Oct 2016, at 07:01, Ankit Aggarwal via swift-build-dev &lt;swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi,<br>&gt;&gt; <br>&gt;&gt; We&#39;re proposing version pinning feature in Swift Package Manager. The proposal is available here &lt;https://github.com/aciidb0mb3r/swift-evolution/blob/version-pinning/proposals/NNNN-Version-Pinning.md&gt; and also in this email:<br>&gt;&gt; <br>&gt;&gt; Feedback welcomed!<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; Ankit<br>&gt;&gt; <br>&gt;&gt; --------<br>&gt;&gt; <br>&gt;&gt; Package Manager Version Pinning<br>&gt;&gt; Proposal: SE-XXXX<br>&gt;&gt; Author: Daniel Dunbar &lt;https://github.com/ddunbar&gt;, Ankit Aggarwal &lt;https://github.com/aciidb0mb3r&gt;<br>&gt;&gt; Review Manager: TBD<br>&gt;&gt; Status: Discussion<br>&gt;&gt; Introduction<br>&gt;&gt; This is a proposal for adding package manager features to &quot;pin&quot; or &quot;lock&quot; package dependencies to particular versions.<br>&gt;&gt; <br>&gt;&gt; Motivation<br>&gt;&gt; As used in this proposal, version pinning refers to the practice of controlling exactly which specific version of a dependency is selected by the dependency resolution algorithm, independent from the semantic versioning specification. Thus, it is a way of instructing the package manager to select a particular version from among all of the versions of a package which could be chosen while honoring the dependency constraints.<br>&gt;&gt; <br>&gt;&gt; Terminology<br>&gt;&gt; <br>&gt;&gt; We have chosen to use &quot;pinning&quot; to refer to this feature, over &quot;lockfiles&quot;, since the term &quot;lock&quot; is already overloaded between POSIX file locks and locks in concurrent programming.<br>&gt;&gt; <br>&gt;&gt; Philosophy<br>&gt;&gt; <br>&gt;&gt; Our philosophy with regard to pinning is that we actively want to encourage packages to develop against the latest semantically appropriate versions of their dependencies, in order to foster rapid development amongst the ecosystem and strong reliance on the semantic versioning concept. Our design for version pinning is thus intended to be a feature for package authors and users to use in crafting specific workflows, not be a mechanism by which most of the packages in the ecosystem pin themselves to specific versions of each other.<br>&gt;&gt; <br>&gt;&gt; Use Cases<br>&gt;&gt; <br>&gt;&gt; Our proposal is designed to satisfy several different use cases for such a behavior:<br>&gt;&gt; <br>&gt;&gt; Standardizing team workflows<br>&gt;&gt; <br>&gt;&gt; When collaborating on a package, it can be valuable for team members (and continuous integration) to all know they are using the same exact version of dependencies, to avoid &quot;works for me&quot; situations.<br>&gt;&gt; <br>&gt;&gt; This can be particularly important for certain kinds of open source projects which are actively being cloned by new users, and which want to have some measure of control around exactly which available version of a dependency is selected.<br>&gt;&gt; <br>&gt;&gt; Difficult to test packages or dependencies<br>&gt;&gt; <br>&gt;&gt; Complex packages which have dependencies which may be hard to test, or hard to analyze when they break, may choose to maintain careful control over what versions of their upstream dependencies they recommend -- even if conceptually they regularly update those recommendations following the true semantic version specification of the dependency.<br>&gt;&gt; <br>&gt;&gt; Dependency locking w.r.t. deployment<br>&gt;&gt; <br>&gt;&gt; When stabilizing a release for deployment, or building a version of a package for deployment, it is important to be able to lock down the exact versions of dependencies in use, so that the resulting product can be exactly recreated later if necessary.<br>&gt;&gt; <br>&gt;&gt; Proposed solution<br>&gt;&gt; We will introduce support for an optional new file Package.pins adjacent to the Package.swift manifest, called the &quot;pins file&quot;. We will also introduce a number of new commands (see below) for maintaining the pins file.<br>&gt;&gt; <br>&gt;&gt; This file will record the active version pin information for the package, including data such as the package identifier, the pinned version, and explicit information on the pinned version (e.g., the commit hash/SHA for the resolved tag).<br>&gt;&gt; <br>&gt;&gt; The exact file format is unspecified/implementation defined, however, in practice it will be a JSON data file.<br>&gt;&gt; <br>&gt;&gt; This file may be checked into SCM by the user, so that its effects apply to all users of the package. However, it may also be maintained only locally (e.g., placed in the .gitignore file). We intend to leave it to package authors to decide which use case is best for their project.<br>&gt;&gt; <br>&gt;&gt; In the presence of a Package.pins file, the package manager will respect the pinned dependencies recorded in the file whenever it needs to do dependency resolution (e.g., on the initial checkout or when updating).<br>&gt;&gt; <br>&gt;&gt; The pins file will not override Manifest specified version requirements and it will be an error (with proper diagnostics) if there is a conflict between the pins and the manifest specification.<br>&gt;&gt; <br>&gt;&gt; Detailed Design<br>&gt;&gt; We will add a new command pin to swift package tool with following semantics:<br>&gt;&gt; <br>&gt;&gt; $ swift package pin ( [--all] | [&lt;package-name&gt;] [&lt;version&gt;] ) [--message &lt;message&gt;]<br>&gt;&gt; The package-name refers to the name of the package as specified in its manifest.<br>&gt;&gt; <br>&gt;&gt; This command pins one or all dependencies. The command which pins a single version can optionally take a specific version to pin to, if unspecified (or with --all) the behaviour is to pin to the current package version in use. Examples: <br>&gt;&gt; <br>&gt;&gt; $ swift package pin --all - pins all the dependencies.<br>&gt;&gt; $ swift package pin Foo - pins Foo at current resolved version.<br>&gt;&gt; $ swift package pin Foo 1.2.3 - pins Foo at 1.2.3. The specified version should be valid and resolvable.<br>&gt;&gt; The --reason option is an optional argument to document the reason for pinning a dependency. This could be helpful for user to later remember why a dependency was pinned. Example: <br>&gt;&gt; <br>&gt;&gt; $ swift package pin Foo --reason &quot;The patch updates for Foo are really unstable and need screening.&quot;<br>&gt;&gt; Dependencies are never automatically pinned, pinning is only ever taken as a result of an explicit user action.<br>&gt;&gt; <br>&gt;&gt; We will add a new command unpin:<br>&gt;&gt; <br>&gt;&gt; $ swift package unpin ( [--all] | [&lt;package-name&gt;] )<br>&gt;&gt; This is the counterpart to the pin command, and unpins one or all packages.<br>&gt;&gt; <br>&gt;&gt; We will fetch and resolve the dependencies when running the pin commands, in case we don&#39;t have the complete dependency graph yet.<br>&gt;&gt; <br>&gt;&gt; We will extend the workflow for update to honour version pinning, that is, it will only update packages which are unpinned, and it will only update to versions which can satisfy the existing pins. The update command will, however, also take an optional argument --repin:<br>&gt;&gt; <br>&gt;&gt; $ swift package update [--repin]<br>&gt;&gt; Update command errors if there are no unpinned packages which can be updated.<br>&gt;&gt; <br>&gt;&gt; Otherwise, the behaviour is to update all unpinned packages to the latest possible versions which can be resolved while respecting the existing pins.<br>&gt;&gt; <br>&gt;&gt; The [--repin] argument can be used to lift the version pinning restrictions. In this case, the behaviour is that all packages are updated, and packages which were previously pinned are then repinned to the latest resolved versions.<br>&gt;&gt; <br>&gt;&gt; The update and checkout will both emit logs, notifying the user that pinning is in effect.<br>&gt;&gt; <br>&gt;&gt; The swift package show-dependencies subcommand will be updated to indicate if a dependency is pinned.<br>&gt;&gt; <br>&gt;&gt; As a future extension, we anticipate using the SHA information recorded in a pins file as a security feature, to prevent man-in-the-middle attacks on parts of the package graph.<br>&gt;&gt; <br>&gt;&gt; Impact on existing code<br>&gt;&gt; There will be change in the behaviours of swift build and swift package update in presence of the pins file, as noted in the proposal however the existing package will continue to build without any modifications.<br>&gt;&gt; <br>&gt;&gt; Alternative considered<br>&gt;&gt; We considered making the pinning behavior default on running swift build, however we think that pinning by default is likely to make the package graph more constrained than it should be. It drives the user away from taking full advantage of semantic versioning. We think it will be good for the package ecosystem if such a restriction is not the default behavior and that this design will lead to faster discovery of bugs and fixes in the upstream.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-build-dev mailing list<br>&gt;&gt; swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-build-dev mailing list<br>&gt; swift-build-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20161014/eb7d70b3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d9baa679148bd83458d11df12327ce0?s=50"></div><header><strong>[swift-evolution] Proposal: Package Manager Version Pinning</strong> from <string>Daniel Dunbar</string> &lt;daniel_dunbar at apple.com&gt;<p>October 14, 2016 at 09:00:00am</p></header><div class="content"><p>Hey Eloy,<br></p><p>Same question as I sent to Orta, can you detail exactly what you would prefer to change?<br></p><p>&gt; On Oct 14, 2016, at 4:06 AM, Eloy Durán via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I cannot agree more with Orta.<br>&gt; <br>&gt; &gt; It drives the user away from taking full advantage of semantic versioning.<br>&gt; <br>&gt; While I ideally subscribe to this thought, the truth of the matter is that this has proven unreliable on multiple occasions. Promoting the idea that it works is going to inevitably lead users into problems when they did not take explicit user action to update dependencies.<br></p><p>This makes a lot of sense to me. The open question in my mind is, given our other goals, are we in a position to make this model work, or to make it &quot;the right model for us&quot;. Some of the other things I am considering (and maybe should go into the proposal):<br></p><p>1. Swift is still evolving in a much greater way than other languages. That means we continue to need to have a very strong push towards forward versions. This is also true for the package manager features, we need the ecosystem to move forward aggressively so that we can move our own features forward aggressively.<br></p><p>2. We have some lofty goals around semantic versioning, like trying to have a much deeper integration with the compiler, API, and ABI, and testing in order to help manage this more effectively.<br></p><p>&gt; Semantic versioning is a great tool when you decide to sit down and explicitly update dependencies.<br></p><p>The problem is they go hand in hand. The more people pin versus following the semantic versioning, the more and more likely it is that those specifications are wrong. That leads to more pinning, which leads to more wrong specifications.<br></p><p>My preference is that we very aggressively commit to using semantic versioning, and then follow up with the entire cross functional design (an index, if we ever do one, the compiler features, any IDE integration) to make this work. I think we are in a better position than other tools which didn&#39;t have the ability to make as many cross functional changes (e.g., integration with the compiler to assist in semantic versioning).<br></p><p>On the other hand, I am also very pragmatic, and I respect your experience here... if this model simply isn&#39;t going to work, then we shouldn&#39;t try to go that way.<br></p><p>The big struggle I have is that if we go the other direction, and as a result people&#39;s semantic versions become poorly specified, we will never be able to recover. The converse is not true, if we start with this direction and realize it doesn&#39;t work, we can relax our behavior.<br></p><p>&gt; &gt; We think it will be good for the package ecosystem if such a restriction is not the default behavior and that this design will lead to faster discovery of bugs and fixes in the upstream.<br>&gt; <br>&gt; Again, ideally I would subscribe to this, but the truth is that when people are working on their projects they *really really really* do *not* like their builds breaking, especially not when it’s seemingly caused outside of their own fault.<br></p><p>One discussion we had a lot was that there are very different workflows between when you are largely the consumer of packages, versus when you are working on a package that is shared.<br></p><p>We generally agree that when you are simply the consumer of packages, pinning makes sense.<br></p><p>However, when you are primarily a distributor of packages (and this is expected to *most* of the momentum behind SwiftPM in the near term), I believe that it is very important to the ecosystem that the semver specs be correct, and so even if the team *wants* to pin, doing so would be actively harmful.<br></p><p>&gt; In the end, it comes down to whether you prioritise surfacing bugs (long term happiness) over user-experience (short term happiness). As a dependency manager author, I can tell you that I agree with your ideals and would want to choose the former, but as a user of dependency managers I would choose UX and Getting (The) Things (I Really Wanted To Do) Done over surfacing bugs *any* day.<br></p><p>I really appreciate the feedback. Do my arguments that we might be in a position to do better here have any weight with you?<br></p><p> - Daniel<br></p><p>&gt; <br>&gt; [A.]		Eloy Durán<br>&gt; 		Artsy &lt;http://artsy.net/&gt;<br>&gt; 		<br>&gt; 		eloy at artsy.net &lt;mailto:eloy at artsy.net&gt;		Twitter &lt;https://twitter.com/alloy&gt;<br>&gt; 		GitHub &lt;https://github.com/alloy&gt;<br>&gt;&gt; On 14 Oct 2016, at 09:29, orta therox via swift-build-dev &lt;swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Please don’t make this a separate command, it should ideally be created at the end of an build (when there isn’t one already) or an update of your dependencies - most people will be expecting to get the same set of dependencies as the rest of their team. This pattern makes that harder.<br>&gt;&gt; <br>&gt;&gt; NPM shrinkwrap is an example of this, and it’s a bad one - I’ve wasted a lot of time trying to keep that up to date for our npm projects. Facebook made a replacement for NPM with mainly the  feature of “always locking” in yarn &lt;https://yarnpkg.com/&gt; and I’d expect that to take a lot of the JS mindshare on this one feature alone.<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; <br>&gt;&gt; [A.]	    Orta Therox<br>&gt;&gt; <br>&gt;&gt;&gt; w/ Artsy &lt;http://artsy.net/&gt;CocoaPods &lt;http://cocoapods.org/&gt; / CocoaDocs &lt;http://cocoadocs.org/&gt; / GIFs.app &lt;https://itunes.apple.com/us/app/gifs/id961850017?l=en&amp;mt=12&gt;<br>&gt;&gt;&gt; @orta &lt;http://twitter.com/orta&gt; / orta.github.com &lt;http://orta.github.com/&gt;<br>&gt;&gt;&gt; Artsy is totally hiring iOS Devs &lt;https://artsy.net/job/mobile-engineer&gt; ATM<br>&gt;&gt; <br>&gt;&gt;&gt; On 14 Oct 2016, at 07:01, Ankit Aggarwal via swift-build-dev &lt;swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We&#39;re proposing version pinning feature in Swift Package Manager. The proposal is available here &lt;https://github.com/aciidb0mb3r/swift-evolution/blob/version-pinning/proposals/NNNN-Version-Pinning.md&gt; and also in this email:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Feedback welcomed!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt; Ankit<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; --------<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Package Manager Version Pinning<br>&gt;&gt;&gt; Proposal: SE-XXXX<br>&gt;&gt;&gt; Author: Daniel Dunbar &lt;https://github.com/ddunbar&gt;, Ankit Aggarwal &lt;https://github.com/aciidb0mb3r&gt;<br>&gt;&gt;&gt; Review Manager: TBD<br>&gt;&gt;&gt; Status: Discussion<br>&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt; This is a proposal for adding package manager features to &quot;pin&quot; or &quot;lock&quot; package dependencies to particular versions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt; As used in this proposal, version pinning refers to the practice of controlling exactly which specific version of a dependency is selected by the dependency resolution algorithm, independent from the semantic versioning specification. Thus, it is a way of instructing the package manager to select a particular version from among all of the versions of a package which could be chosen while honoring the dependency constraints.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Terminology<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We have chosen to use &quot;pinning&quot; to refer to this feature, over &quot;lockfiles&quot;, since the term &quot;lock&quot; is already overloaded between POSIX file locks and locks in concurrent programming.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Philosophy<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Our philosophy with regard to pinning is that we actively want to encourage packages to develop against the latest semantically appropriate versions of their dependencies, in order to foster rapid development amongst the ecosystem and strong reliance on the semantic versioning concept. Our design for version pinning is thus intended to be a feature for package authors and users to use in crafting specific workflows, not be a mechanism by which most of the packages in the ecosystem pin themselves to specific versions of each other.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Use Cases<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Our proposal is designed to satisfy several different use cases for such a behavior:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Standardizing team workflows<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When collaborating on a package, it can be valuable for team members (and continuous integration) to all know they are using the same exact version of dependencies, to avoid &quot;works for me&quot; situations.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This can be particularly important for certain kinds of open source projects which are actively being cloned by new users, and which want to have some measure of control around exactly which available version of a dependency is selected.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Difficult to test packages or dependencies<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Complex packages which have dependencies which may be hard to test, or hard to analyze when they break, may choose to maintain careful control over what versions of their upstream dependencies they recommend -- even if conceptually they regularly update those recommendations following the true semantic version specification of the dependency.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Dependency locking w.r.t. deployment<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When stabilizing a release for deployment, or building a version of a package for deployment, it is important to be able to lock down the exact versions of dependencies in use, so that the resulting product can be exactly recreated later if necessary.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt; We will introduce support for an optional new file Package.pins adjacent to the Package.swift manifest, called the &quot;pins file&quot;. We will also introduce a number of new commands (see below) for maintaining the pins file.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This file will record the active version pin information for the package, including data such as the package identifier, the pinned version, and explicit information on the pinned version (e.g., the commit hash/SHA for the resolved tag).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The exact file format is unspecified/implementation defined, however, in practice it will be a JSON data file.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This file may be checked into SCM by the user, so that its effects apply to all users of the package. However, it may also be maintained only locally (e.g., placed in the .gitignore file). We intend to leave it to package authors to decide which use case is best for their project.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In the presence of a Package.pins file, the package manager will respect the pinned dependencies recorded in the file whenever it needs to do dependency resolution (e.g., on the initial checkout or when updating).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The pins file will not override Manifest specified version requirements and it will be an error (with proper diagnostics) if there is a conflict between the pins and the manifest specification.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Detailed Design<br>&gt;&gt;&gt; We will add a new command pin to swift package tool with following semantics:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; $ swift package pin ( [--all] | [&lt;package-name&gt;] [&lt;version&gt;] ) [--message &lt;message&gt;]<br>&gt;&gt;&gt; The package-name refers to the name of the package as specified in its manifest.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This command pins one or all dependencies. The command which pins a single version can optionally take a specific version to pin to, if unspecified (or with --all) the behaviour is to pin to the current package version in use. Examples: <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; $ swift package pin --all - pins all the dependencies.<br>&gt;&gt;&gt; $ swift package pin Foo - pins Foo at current resolved version.<br>&gt;&gt;&gt; $ swift package pin Foo 1.2.3 - pins Foo at 1.2.3. The specified version should be valid and resolvable.<br>&gt;&gt;&gt; The --reason option is an optional argument to document the reason for pinning a dependency. This could be helpful for user to later remember why a dependency was pinned. Example: <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; $ swift package pin Foo --reason &quot;The patch updates for Foo are really unstable and need screening.&quot;<br>&gt;&gt;&gt; Dependencies are never automatically pinned, pinning is only ever taken as a result of an explicit user action.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We will add a new command unpin:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; $ swift package unpin ( [--all] | [&lt;package-name&gt;] )<br>&gt;&gt;&gt; This is the counterpart to the pin command, and unpins one or all packages.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We will fetch and resolve the dependencies when running the pin commands, in case we don&#39;t have the complete dependency graph yet.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We will extend the workflow for update to honour version pinning, that is, it will only update packages which are unpinned, and it will only update to versions which can satisfy the existing pins. The update command will, however, also take an optional argument --repin:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; $ swift package update [--repin]<br>&gt;&gt;&gt; Update command errors if there are no unpinned packages which can be updated.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Otherwise, the behaviour is to update all unpinned packages to the latest possible versions which can be resolved while respecting the existing pins.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The [--repin] argument can be used to lift the version pinning restrictions. In this case, the behaviour is that all packages are updated, and packages which were previously pinned are then repinned to the latest resolved versions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The update and checkout will both emit logs, notifying the user that pinning is in effect.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The swift package show-dependencies subcommand will be updated to indicate if a dependency is pinned.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As a future extension, we anticipate using the SHA information recorded in a pins file as a security feature, to prevent man-in-the-middle attacks on parts of the package graph.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt; There will be change in the behaviours of swift build and swift package update in presence of the pins file, as noted in the proposal however the existing package will continue to build without any modifications.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alternative considered<br>&gt;&gt;&gt; We considered making the pinning behavior default on running swift build, however we think that pinning by default is likely to make the package graph more constrained than it should be. It drives the user away from taking full advantage of semantic versioning. We think it will be good for the package ecosystem if such a restriction is not the default behavior and that this design will lead to faster discovery of bugs and fixes in the upstream.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-build-dev mailing list<br>&gt;&gt;&gt; swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev &lt;https://lists.swift.org/mailman/listinfo/swift-build-dev&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-build-dev mailing list<br>&gt;&gt; swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20161014/ea5924eb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/424a9ce662b059c35063b405e160461d?s=50"></div><header><strong>[swift-evolution] Proposal: Package Manager Version Pinning</strong> from <string>Eloy Durán</string> &lt;eloy.de.enige at gmail.com&gt;<p>October 14, 2016 at 07:00:00pm</p></header><div class="content"><p>Hey Daniel,<br></p><p>Totally 👍<br></p><p>I think you should pin by default, I wouldn&#39;t even provide some option to disable it.<br></p><p>As others have touched on, which I forgot to include, is that a library can choose to not include the lock file in SCM. Especially if the lib uses a CI for testing, that should bring up any issues with the latest versions of dependencies while keeping a paper trail (local lock file) of dependency versions that did work.<br></p><p>The key here is that it remains an explicit choice. The default should imo always be consistent builds.<br></p><p>----<br></p><p>With regards to being in a different position, I doubt it. Swift developers are, like in other languages, just humans, we all make mistakes. I think we&#39;ve all accepted that we&#39;ll always introduce bugs any time we have to make decisions, the same applies to determining semantic versions.<br></p><p>You could automate some of that (e.g. check interfaces), but you cannot guarantee behavioral intent and thus there&#39;s room left for human mistakes.<br></p><p>Please note, though, that I&#39;m kinda pessimistic (realistic) about this and it&#39;s solely based on experience with established ecosystems, where people generally don&#39;t like being told how to do things. It may well be that your situation will turn out to be different.<br></p><p>As the Queen would say, Godspeed!<br></p><p>&gt; On 14 Oct 2016, at 18:42, Daniel Dunbar &lt;daniel_dunbar at apple.com&gt; wrote:<br>&gt; <br>&gt; Hey Eloy,<br>&gt; <br>&gt; Same question as I sent to Orta, can you detail exactly what you would prefer to change?<br>&gt; <br>&gt;&gt; On Oct 14, 2016, at 4:06 AM, Eloy Durán via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I cannot agree more with Orta.<br>&gt;&gt; <br>&gt;&gt; &gt; It drives the user away from taking full advantage of semantic versioning.<br>&gt;&gt; <br>&gt;&gt; While I ideally subscribe to this thought, the truth of the matter is that this has proven unreliable on multiple occasions. Promoting the idea that it works is going to inevitably lead users into problems when they did not take explicit user action to update dependencies.<br>&gt; <br>&gt; This makes a lot of sense to me. The open question in my mind is, given our other goals, are we in a position to make this model work, or to make it &quot;the right model for us&quot;. Some of the other things I am considering (and maybe should go into the proposal):<br>&gt; <br>&gt; 1. Swift is still evolving in a much greater way than other languages. That means we continue to need to have a very strong push towards forward versions. This is also true for the package manager features, we need the ecosystem to move forward aggressively so that we can move our own features forward aggressively.<br>&gt; <br>&gt; 2. We have some lofty goals around semantic versioning, like trying to have a much deeper integration with the compiler, API, and ABI, and testing in order to help manage this more effectively.<br>&gt; <br>&gt;&gt; Semantic versioning is a great tool when you decide to sit down and explicitly update dependencies.<br>&gt; <br>&gt; The problem is they go hand in hand. The more people pin versus following the semantic versioning, the more and more likely it is that those specifications are wrong. That leads to more pinning, which leads to more wrong specifications.<br>&gt; <br>&gt; My preference is that we very aggressively commit to using semantic versioning, and then follow up with the entire cross functional design (an index, if we ever do one, the compiler features, any IDE integration) to make this work. I think we are in a better position than other tools which didn&#39;t have the ability to make as many cross functional changes (e.g., integration with the compiler to assist in semantic versioning).<br>&gt; <br>&gt; On the other hand, I am also very pragmatic, and I respect your experience here... if this model simply isn&#39;t going to work, then we shouldn&#39;t try to go that way.<br>&gt; <br>&gt; The big struggle I have is that if we go the other direction, and as a result people&#39;s semantic versions become poorly specified, we will never be able to recover. The converse is not true, if we start with this direction and realize it doesn&#39;t work, we can relax our behavior.<br>&gt; <br>&gt;&gt; &gt; We think it will be good for the package ecosystem if such a restriction is not the default behavior and that this design will lead to faster discovery of bugs and fixes in the upstream.<br>&gt;&gt; <br>&gt;&gt; Again, ideally I would subscribe to this, but the truth is that when people are working on their projects they *really really really* do *not* like their builds breaking, especially not when it’s seemingly caused outside of their own fault.<br>&gt; <br>&gt; One discussion we had a lot was that there are very different workflows between when you are largely the consumer of packages, versus when you are working on a package that is shared.<br>&gt; <br>&gt; We generally agree that when you are simply the consumer of packages, pinning makes sense.<br>&gt; <br>&gt; However, when you are primarily a distributor of packages (and this is expected to *most* of the momentum behind SwiftPM in the near term), I believe that it is very important to the ecosystem that the semver specs be correct, and so even if the team *wants* to pin, doing so would be actively harmful.<br>&gt; <br>&gt;&gt; In the end, it comes down to whether you prioritise surfacing bugs (long term happiness) over user-experience (short term happiness). As a dependency manager author, I can tell you that I agree with your ideals and would want to choose the former, but as a user of dependency managers I would choose UX and Getting (The) Things (I Really Wanted To Do) Done over surfacing bugs *any* day.<br>&gt; <br>&gt; I really appreciate the feedback. Do my arguments that we might be in a position to do better here have any weight with you?<br>&gt; <br>&gt;  - Daniel<br>&gt; <br>&gt;&gt; <br>&gt;&gt; [A.]		Eloy Durán<br>&gt;&gt; 		Artsy<br>&gt;&gt; 		<br>&gt;&gt; 		eloy at artsy.net<br>&gt;&gt; 		Twitter<br>&gt;&gt; 		GitHub<br>&gt;&gt; <br>&gt;&gt;&gt; On 14 Oct 2016, at 09:29, orta therox via swift-build-dev &lt;swift-build-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Please don’t make this a separate command, it should ideally be created at the end of an build (when there isn’t one already) or an update of your dependencies - most people will be expecting to get the same set of dependencies as the rest of their team. This pattern makes that harder.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; NPM shrinkwrap is an example of this, and it’s a bad one - I’ve wasted a lot of time trying to keep that up to date for our npm projects. Facebook made a replacement for NPM with mainly the  feature of “always locking” in yarn and I’d expect that to take a lot of the JS mindshare on this one feature alone.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; [A.]	    Orta Therox<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; w/ Artsy<br>&gt;&gt;&gt;&gt; CocoaPods / CocoaDocs / GIFs.app<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; @orta / orta.github.com<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Artsy is totally hiring iOS Devs ATM<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 14 Oct 2016, at 07:01, Ankit Aggarwal via swift-build-dev &lt;swift-build-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We&#39;re proposing version pinning feature in Swift Package Manager. The proposal is available here and also in this email:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Feedback welcomed!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt; Ankit<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; --------<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Package Manager Version Pinning<br>&gt;&gt;&gt;&gt; Proposal: SE-XXXX<br>&gt;&gt;&gt;&gt; Author: Daniel Dunbar, Ankit Aggarwal<br>&gt;&gt;&gt;&gt; Review Manager: TBD<br>&gt;&gt;&gt;&gt; Status: Discussion<br>&gt;&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;&gt; This is a proposal for adding package manager features to &quot;pin&quot; or &quot;lock&quot; package dependencies to particular versions.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;&gt; As used in this proposal, version pinning refers to the practice of controlling exactly which specific version of a dependency is selected by the dependency resolution algorithm, independent from the semantic versioning specification. Thus, it is a way of instructing the package manager to select a particular version from among all of the versions of a package which could be chosen while honoring the dependency constraints.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Terminology<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We have chosen to use &quot;pinning&quot; to refer to this feature, over &quot;lockfiles&quot;, since the term &quot;lock&quot; is already overloaded between POSIX file locks and locks in concurrent programming.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Philosophy<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Our philosophy with regard to pinning is that we actively want to encourage packages to develop against the latest semantically appropriate versions of their dependencies, in order to foster rapid development amongst the ecosystem and strong reliance on the semantic versioning concept. Our design for version pinning is thus intended to be a feature for package authors and users to use in crafting specific workflows, not be a mechanism by which most of the packages in the ecosystem pin themselves to specific versions of each other.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Use Cases<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Our proposal is designed to satisfy several different use cases for such a behavior:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Standardizing team workflows<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; When collaborating on a package, it can be valuable for team members (and continuous integration) to all know they are using the same exact version of dependencies, to avoid &quot;works for me&quot; situations.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This can be particularly important for certain kinds of open source projects which are actively being cloned by new users, and which want to have some measure of control around exactly which available version of a dependency is selected.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Difficult to test packages or dependencies<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Complex packages which have dependencies which may be hard to test, or hard to analyze when they break, may choose to maintain careful control over what versions of their upstream dependencies they recommend -- even if conceptually they regularly update those recommendations following the true semantic version specification of the dependency.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Dependency locking w.r.t. deployment<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; When stabilizing a release for deployment, or building a version of a package for deployment, it is important to be able to lock down the exact versions of dependencies in use, so that the resulting product can be exactly recreated later if necessary.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt;&gt; We will introduce support for an optional new file Package.pins adjacent to the Package.swift manifest, called the &quot;pins file&quot;. We will also introduce a number of new commands (see below) for maintaining the pins file.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This file will record the active version pin information for the package, including data such as the package identifier, the pinned version, and explicit information on the pinned version (e.g., the commit hash/SHA for the resolved tag).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The exact file format is unspecified/implementation defined, however, in practice it will be a JSON data file.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This file may be checked into SCM by the user, so that its effects apply to all users of the package. However, it may also be maintained only locally (e.g., placed in the .gitignore file). We intend to leave it to package authors to decide which use case is best for their project.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In the presence of a Package.pins file, the package manager will respect the pinned dependencies recorded in the file whenever it needs to do dependency resolution (e.g., on the initial checkout or when updating).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The pins file will not override Manifest specified version requirements and it will be an error (with proper diagnostics) if there is a conflict between the pins and the manifest specification.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Detailed Design<br>&gt;&gt;&gt;&gt; We will add a new command pin to swift package tool with following semantics:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; $ swift package pin ( [--all] | [&lt;package-name&gt;] [&lt;version&gt;] ) [--message &lt;message&gt;]<br>&gt;&gt;&gt;&gt; The package-name refers to the name of the package as specified in its manifest.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This command pins one or all dependencies. The command which pins a single version can optionally take a specific version to pin to, if unspecified (or with --all) the behaviour is to pin to the current package version in use. Examples: <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; $ swift package pin --all - pins all the dependencies.<br>&gt;&gt;&gt;&gt; $ swift package pin Foo - pins Foo at current resolved version.<br>&gt;&gt;&gt;&gt; $ swift package pin Foo 1.2.3 - pins Foo at 1.2.3. The specified version should be valid and resolvable.<br>&gt;&gt;&gt;&gt; The --reason option is an optional argument to document the reason for pinning a dependency. This could be helpful for user to later remember why a dependency was pinned. Example: <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; $ swift package pin Foo --reason &quot;The patch updates for Foo are really unstable and need screening.&quot;<br>&gt;&gt;&gt;&gt; Dependencies are never automatically pinned, pinning is only ever taken as a result of an explicit user action.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We will add a new command unpin:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; $ swift package unpin ( [--all] | [&lt;package-name&gt;] )<br>&gt;&gt;&gt;&gt; This is the counterpart to the pin command, and unpins one or all packages.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We will fetch and resolve the dependencies when running the pin commands, in case we don&#39;t have the complete dependency graph yet.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We will extend the workflow for update to honour version pinning, that is, it will only update packages which are unpinned, and it will only update to versions which can satisfy the existing pins. The update command will, however, also take an optional argument --repin:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; $ swift package update [--repin]<br>&gt;&gt;&gt;&gt; Update command errors if there are no unpinned packages which can be updated.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Otherwise, the behaviour is to update all unpinned packages to the latest possible versions which can be resolved while respecting the existing pins.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The [--repin] argument can be used to lift the version pinning restrictions. In this case, the behaviour is that all packages are updated, and packages which were previously pinned are then repinned to the latest resolved versions.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The update and checkout will both emit logs, notifying the user that pinning is in effect.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The swift package show-dependencies subcommand will be updated to indicate if a dependency is pinned.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As a future extension, we anticipate using the SHA information recorded in a pins file as a security feature, to prevent man-in-the-middle attacks on parts of the package graph.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt;&gt; There will be change in the behaviours of swift build and swift package update in presence of the pins file, as noted in the proposal however the existing package will continue to build without any modifications.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Alternative considered<br>&gt;&gt;&gt;&gt; We considered making the pinning behavior default on running swift build, however we think that pinning by default is likely to make the package graph more constrained than it should be. It drives the user away from taking full advantage of semantic versioning. We think it will be good for the package ecosystem if such a restriction is not the default behavior and that this design will lead to faster discovery of bugs and fixes in the upstream.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-build-dev mailing list<br>&gt;&gt;&gt;&gt; swift-build-dev at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-build-dev mailing list<br>&gt;&gt;&gt; swift-build-dev at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20161014/10bd5f43/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d9baa679148bd83458d11df12327ce0?s=50"></div><header><strong>[swift-evolution] Proposal: Package Manager Version Pinning</strong> from <string>Daniel Dunbar</string> &lt;daniel_dunbar at apple.com&gt;<p>October 14, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Oct 14, 2016, at 10:37 AM, Eloy Duran &lt;eloy.de.enige at gmail.com&gt; wrote:<br>&gt; <br>&gt; Hey Daniel,<br>&gt; <br>&gt; Totally 👍<br></p><p>I&#39;m not sure what this is to. :)<br></p><p>&gt; I think you should pin by default, I wouldn&#39;t even provide some option to disable it.<br></p><p>Pin by default in the sense you are using it just means we automatically would create &quot;Package.pins&quot;, that is the only behavior change (i.e., you don&#39;t inherit it from your dependencies).<br></p><p>Can you explain why simply needing to run one more command when you want to do this is a big deal? If you don&#39;t check it in, it doesn&#39;t change anything when you run `swift build`, that always kept a consistent set of versions. It changes `swift update`, but you were already running it at that point, so I&#39;m not sure why that is desired.<br></p><p>Is it possible that we have a different expectation about what the tools do when you don&#39;t create this file? Our expectation is that you only ever get updated packages in a local build when you explicitly run `swift package update`. We expect to add features to notice when new dependencies are available, and let you choose to update, but for any one local build we are never talking about changing your dependencies without your interaction.<br></p><p>&gt; As others have touched on, which I forgot to include, is that a library can choose to not include the lock file in SCM. Especially if the lib uses a CI for testing, that should bring up any issues with the latest versions of dependencies while keeping a paper trail (local lock file) of dependency versions that did work.<br>&gt; <br>&gt; The key here is that it remains an explicit choice. The default should imo always be consistent builds.<br></p><p>Consistent across what axis? If you don&#39;t inherit it, then you still don&#39;t get consistency between yourself and your clients. If you don&#39;t check it in, you don&#39;t get much of a behavior change. However, as is touched on in other places, choosing to inherit has big downsides.<br></p><p>&gt; ----<br>&gt; <br>&gt; With regards to being in a different position, I doubt it. Swift developers are, like in other languages, just humans, we all make mistakes. I think we&#39;ve all accepted that we&#39;ll always introduce bugs any time we have to make decisions, the same applies to determining semantic versions.<br>&gt; <br>&gt; You could automate some of that (e.g. check interfaces), but you cannot guarantee behavioral intent and thus there&#39;s room left for human mistakes.<br></p><p>You can, however, in theory, apply a lot of automation for testing downstream dependencies (see earlier response).<br></p><p>&gt; Please note, though, that I&#39;m kinda pessimistic (realistic) about this and it&#39;s solely based on experience with established ecosystems, where people generally don&#39;t like being told how to do things. It may well be that your situation will turn out to be different.<br></p><p>This is the trickiest part of this design question. We don&#39;t really know how the ecosystem will behave, we don&#39;t know how resilient Swift packages will be w.r.t. bugs and semantic versioning, etc. At the end of the day, we all just are sticking our fingers to the wind and hoping to do the best thing for everyone.<br></p><p>One argument I haven&#39;t heard anyone refute is that we can always back down from this position, but the converse isn&#39;t true (because its impact will have permeated the ecosystem). I consider that an important point.<br></p><p>&gt; As the Queen would say, Godspeed!<br></p><p>:)<br></p><p> - Daniel<br></p><p>&gt; <br>&gt; On 14 Oct 2016, at 18:42, Daniel Dunbar &lt;daniel_dunbar at apple.com &lt;mailto:daniel_dunbar at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Hey Eloy,<br>&gt;&gt; <br>&gt;&gt; Same question as I sent to Orta, can you detail exactly what you would prefer to change?<br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 14, 2016, at 4:06 AM, Eloy Durán via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I cannot agree more with Orta.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; It drives the user away from taking full advantage of semantic versioning.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; While I ideally subscribe to this thought, the truth of the matter is that this has proven unreliable on multiple occasions. Promoting the idea that it works is going to inevitably lead users into problems when they did not take explicit user action to update dependencies.<br>&gt;&gt; <br>&gt;&gt; This makes a lot of sense to me. The open question in my mind is, given our other goals, are we in a position to make this model work, or to make it &quot;the right model for us&quot;. Some of the other things I am considering (and maybe should go into the proposal):<br>&gt;&gt; <br>&gt;&gt; 1. Swift is still evolving in a much greater way than other languages. That means we continue to need to have a very strong push towards forward versions. This is also true for the package manager features, we need the ecosystem to move forward aggressively so that we can move our own features forward aggressively.<br>&gt;&gt; <br>&gt;&gt; 2. We have some lofty goals around semantic versioning, like trying to have a much deeper integration with the compiler, API, and ABI, and testing in order to help manage this more effectively.<br>&gt;&gt; <br>&gt;&gt;&gt; Semantic versioning is a great tool when you decide to sit down and explicitly update dependencies.<br>&gt;&gt; <br>&gt;&gt; The problem is they go hand in hand. The more people pin versus following the semantic versioning, the more and more likely it is that those specifications are wrong. That leads to more pinning, which leads to more wrong specifications.<br>&gt;&gt; <br>&gt;&gt; My preference is that we very aggressively commit to using semantic versioning, and then follow up with the entire cross functional design (an index, if we ever do one, the compiler features, any IDE integration) to make this work. I think we are in a better position than other tools which didn&#39;t have the ability to make as many cross functional changes (e.g., integration with the compiler to assist in semantic versioning).<br>&gt;&gt; <br>&gt;&gt; On the other hand, I am also very pragmatic, and I respect your experience here... if this model simply isn&#39;t going to work, then we shouldn&#39;t try to go that way.<br>&gt;&gt; <br>&gt;&gt; The big struggle I have is that if we go the other direction, and as a result people&#39;s semantic versions become poorly specified, we will never be able to recover. The converse is not true, if we start with this direction and realize it doesn&#39;t work, we can relax our behavior.<br>&gt;&gt; <br>&gt;&gt;&gt; &gt; We think it will be good for the package ecosystem if such a restriction is not the default behavior and that this design will lead to faster discovery of bugs and fixes in the upstream.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Again, ideally I would subscribe to this, but the truth is that when people are working on their projects they *really really really* do *not* like their builds breaking, especially not when it’s seemingly caused outside of their own fault.<br>&gt;&gt; <br>&gt;&gt; One discussion we had a lot was that there are very different workflows between when you are largely the consumer of packages, versus when you are working on a package that is shared.<br>&gt;&gt; <br>&gt;&gt; We generally agree that when you are simply the consumer of packages, pinning makes sense.<br>&gt;&gt; <br>&gt;&gt; However, when you are primarily a distributor of packages (and this is expected to *most* of the momentum behind SwiftPM in the near term), I believe that it is very important to the ecosystem that the semver specs be correct, and so even if the team *wants* to pin, doing so would be actively harmful.<br>&gt;&gt; <br>&gt;&gt;&gt; In the end, it comes down to whether you prioritise surfacing bugs (long term happiness) over user-experience (short term happiness). As a dependency manager author, I can tell you that I agree with your ideals and would want to choose the former, but as a user of dependency managers I would choose UX and Getting (The) Things (I Really Wanted To Do) Done over surfacing bugs *any* day.<br>&gt;&gt; <br>&gt;&gt; I really appreciate the feedback. Do my arguments that we might be in a position to do better here have any weight with you?<br>&gt;&gt; <br>&gt;&gt;  - Daniel<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; [A.]		Eloy Durán<br>&gt;&gt;&gt; 		Artsy &lt;http://artsy.net/&gt;<br>&gt;&gt;&gt; 		<br>&gt;&gt;&gt; 		eloy at artsy.net &lt;mailto:eloy at artsy.net&gt;		Twitter &lt;https://twitter.com/alloy&gt;<br>&gt;&gt;&gt; 		GitHub &lt;https://github.com/alloy&gt;<br>&gt;&gt;&gt;&gt; On 14 Oct 2016, at 09:29, orta therox via swift-build-dev &lt;swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Please don’t make this a separate command, it should ideally be created at the end of an build (when there isn’t one already) or an update of your dependencies - most people will be expecting to get the same set of dependencies as the rest of their team. This pattern makes that harder.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; NPM shrinkwrap is an example of this, and it’s a bad one - I’ve wasted a lot of time trying to keep that up to date for our npm projects. Facebook made a replacement for NPM with mainly the  feature of “always locking” in yarn &lt;https://yarnpkg.com/&gt; and I’d expect that to take a lot of the JS mindshare on this one feature alone.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; [A.]	    Orta Therox<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; w/ Artsy &lt;http://artsy.net/&gt;CocoaPods &lt;http://cocoapods.org/&gt; / CocoaDocs &lt;http://cocoadocs.org/&gt; / GIFs.app &lt;https://itunes.apple.com/us/app/gifs/id961850017?l=en&amp;mt=12&gt;<br>&gt;&gt;&gt;&gt;&gt; @orta &lt;http://twitter.com/orta&gt; / orta.github.com &lt;http://orta.github.com/&gt;<br>&gt;&gt;&gt;&gt;&gt; Artsy is totally hiring iOS Devs &lt;https://artsy.net/job/mobile-engineer&gt; ATM<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 14 Oct 2016, at 07:01, Ankit Aggarwal via swift-build-dev &lt;swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; We&#39;re proposing version pinning feature in Swift Package Manager. The proposal is available here &lt;https://github.com/aciidb0mb3r/swift-evolution/blob/version-pinning/proposals/NNNN-Version-Pinning.md&gt; and also in this email:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Feedback welcomed!<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt; Ankit<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; --------<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Package Manager Version Pinning<br>&gt;&gt;&gt;&gt;&gt; Proposal: SE-XXXX<br>&gt;&gt;&gt;&gt;&gt; Author: Daniel Dunbar &lt;https://github.com/ddunbar&gt;, Ankit Aggarwal &lt;https://github.com/aciidb0mb3r&gt;<br>&gt;&gt;&gt;&gt;&gt; Review Manager: TBD<br>&gt;&gt;&gt;&gt;&gt; Status: Discussion<br>&gt;&gt;&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;&gt;&gt; This is a proposal for adding package manager features to &quot;pin&quot; or &quot;lock&quot; package dependencies to particular versions.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;&gt;&gt; As used in this proposal, version pinning refers to the practice of controlling exactly which specific version of a dependency is selected by the dependency resolution algorithm, independent from the semantic versioning specification. Thus, it is a way of instructing the package manager to select a particular version from among all of the versions of a package which could be chosen while honoring the dependency constraints.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Terminology<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; We have chosen to use &quot;pinning&quot; to refer to this feature, over &quot;lockfiles&quot;, since the term &quot;lock&quot; is already overloaded between POSIX file locks and locks in concurrent programming.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Philosophy<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Our philosophy with regard to pinning is that we actively want to encourage packages to develop against the latest semantically appropriate versions of their dependencies, in order to foster rapid development amongst the ecosystem and strong reliance on the semantic versioning concept. Our design for version pinning is thus intended to be a feature for package authors and users to use in crafting specific workflows, not be a mechanism by which most of the packages in the ecosystem pin themselves to specific versions of each other.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Use Cases<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Our proposal is designed to satisfy several different use cases for such a behavior:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Standardizing team workflows<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; When collaborating on a package, it can be valuable for team members (and continuous integration) to all know they are using the same exact version of dependencies, to avoid &quot;works for me&quot; situations.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This can be particularly important for certain kinds of open source projects which are actively being cloned by new users, and which want to have some measure of control around exactly which available version of a dependency is selected.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Difficult to test packages or dependencies<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Complex packages which have dependencies which may be hard to test, or hard to analyze when they break, may choose to maintain careful control over what versions of their upstream dependencies they recommend -- even if conceptually they regularly update those recommendations following the true semantic version specification of the dependency.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Dependency locking w.r.t. deployment<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; When stabilizing a release for deployment, or building a version of a package for deployment, it is important to be able to lock down the exact versions of dependencies in use, so that the resulting product can be exactly recreated later if necessary.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt;&gt;&gt; We will introduce support for an optional new file Package.pins adjacent to the Package.swift manifest, called the &quot;pins file&quot;. We will also introduce a number of new commands (see below) for maintaining the pins file.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This file will record the active version pin information for the package, including data such as the package identifier, the pinned version, and explicit information on the pinned version (e.g., the commit hash/SHA for the resolved tag).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The exact file format is unspecified/implementation defined, however, in practice it will be a JSON data file.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This file may be checked into SCM by the user, so that its effects apply to all users of the package. However, it may also be maintained only locally (e.g., placed in the .gitignore file). We intend to leave it to package authors to decide which use case is best for their project.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In the presence of a Package.pins file, the package manager will respect the pinned dependencies recorded in the file whenever it needs to do dependency resolution (e.g., on the initial checkout or when updating).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The pins file will not override Manifest specified version requirements and it will be an error (with proper diagnostics) if there is a conflict between the pins and the manifest specification.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Detailed Design<br>&gt;&gt;&gt;&gt;&gt; We will add a new command pin to swift package tool with following semantics:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; $ swift package pin ( [--all] | [&lt;package-name&gt;] [&lt;version&gt;] ) [--message &lt;message&gt;]<br>&gt;&gt;&gt;&gt;&gt; The package-name refers to the name of the package as specified in its manifest.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This command pins one or all dependencies. The command which pins a single version can optionally take a specific version to pin to, if unspecified (or with --all) the behaviour is to pin to the current package version in use. Examples: <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; $ swift package pin --all - pins all the dependencies.<br>&gt;&gt;&gt;&gt;&gt; $ swift package pin Foo - pins Foo at current resolved version.<br>&gt;&gt;&gt;&gt;&gt; $ swift package pin Foo 1.2.3 - pins Foo at 1.2.3. The specified version should be valid and resolvable.<br>&gt;&gt;&gt;&gt;&gt; The --reason option is an optional argument to document the reason for pinning a dependency. This could be helpful for user to later remember why a dependency was pinned. Example: <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; $ swift package pin Foo --reason &quot;The patch updates for Foo are really unstable and need screening.&quot;<br>&gt;&gt;&gt;&gt;&gt; Dependencies are never automatically pinned, pinning is only ever taken as a result of an explicit user action.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; We will add a new command unpin:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; $ swift package unpin ( [--all] | [&lt;package-name&gt;] )<br>&gt;&gt;&gt;&gt;&gt; This is the counterpart to the pin command, and unpins one or all packages.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; We will fetch and resolve the dependencies when running the pin commands, in case we don&#39;t have the complete dependency graph yet.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; We will extend the workflow for update to honour version pinning, that is, it will only update packages which are unpinned, and it will only update to versions which can satisfy the existing pins. The update command will, however, also take an optional argument --repin:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; $ swift package update [--repin]<br>&gt;&gt;&gt;&gt;&gt; Update command errors if there are no unpinned packages which can be updated.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Otherwise, the behaviour is to update all unpinned packages to the latest possible versions which can be resolved while respecting the existing pins.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The [--repin] argument can be used to lift the version pinning restrictions. In this case, the behaviour is that all packages are updated, and packages which were previously pinned are then repinned to the latest resolved versions.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The update and checkout will both emit logs, notifying the user that pinning is in effect.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The swift package show-dependencies subcommand will be updated to indicate if a dependency is pinned.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; As a future extension, we anticipate using the SHA information recorded in a pins file as a security feature, to prevent man-in-the-middle attacks on parts of the package graph.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt;&gt;&gt; There will be change in the behaviours of swift build and swift package update in presence of the pins file, as noted in the proposal however the existing package will continue to build without any modifications.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Alternative considered<br>&gt;&gt;&gt;&gt;&gt; We considered making the pinning behavior default on running swift build, however we think that pinning by default is likely to make the package graph more constrained than it should be. It drives the user away from taking full advantage of semantic versioning. We think it will be good for the package ecosystem if such a restriction is not the default behavior and that this design will lead to faster discovery of bugs and fixes in the upstream.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-build-dev mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev &lt;https://lists.swift.org/mailman/listinfo/swift-build-dev&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-build-dev mailing list<br>&gt;&gt;&gt;&gt; swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev &lt;https://lists.swift.org/mailman/listinfo/swift-build-dev&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20161014/80910fbf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/424a9ce662b059c35063b405e160461d?s=50"></div><header><strong>[swift-evolution] Proposal: Package Manager Version Pinning</strong> from <string>Eloy Durán</string> &lt;eloy.de.enige at gmail.com&gt;<p>October 14, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt;&gt; Totally 👍<br>&gt; <br>&gt; I&#39;m not sure what this is to. :)<br></p><p>You and me both… Guess I must have lost track of my thought here while trying to respond from my phone and playing with the baby in between.<br></p><p>&gt; Pin by default in the sense you are using it just means we automatically would create &quot;Package.pins&quot;, that is the only behavior change (i.e., you don&#39;t inherit it from your dependencies).<br>&gt; <br>&gt; Can you explain why simply needing to run one more command when you want to do this is a big deal?<br></p><p>It’s clearly not a big deal in amount of work, what it comes down to is setting an example. If you, as an authority, make it the default option to not pin, then to many people that will signal that that’s The Right Thing to do.<br></p><p>&gt; Is it possible that we have a different expectation about what the tools do when you don&#39;t create this file?<br></p><p>No, it’s a philosophical difference in thinking about dependencies.<br></p><p>I see it as my responsibility to know exactly what code I’m pulling into my package. In my view, it’s absolutely unsafe to trust other people’s code. Even when they mean no harm, trusting them to properly apply SemVer is the same issue.<br></p><p>My worst nightmare is people updating dependencies and getting lazy in vetting them, a mindset that is in my observation the status quo in e.g. npm, a dependency manager which makes it the default to not pin and trust SemVer. On the other hand, the laziness might also be compounded by the micro-lib norm, it’s not unusual for npm packages to have a dependency graph of dozens, if not hundreds of packages.<br></p><p>This also leads me to the following point you bring up:<br></p><p>&gt; One argument I haven&#39;t heard anyone refute is that we can always back down from this position, but the converse isn&#39;t true (because its impact will have permeated the ecosystem). I consider that an important point.<br></p><p>The reason I would not try to refute it is A) simply because it’s true and B) it’s, to me, more of a technicality that’s moot in contrast to my philosophical thoughts, as explained above.<br></p><p>One final note, playing the devil’s advocate against my own opinion, seeing as you are at a place where you can try it and later change, I’d say do it. However, it might be a good idea to document the possibility of this changing in the future, just so expectations are set correct and the thought to keep an eye on this is kept alive in the community.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20161014/cace8ddd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/353d1c09444050fea4228317eaefafda?s=50"></div><header><strong>[swift-evolution] Proposal: Package Manager Version Pinning</strong> from <string>Johannes Weiß</string> &lt;johannesweiss at apple.com&gt;<p>October 14, 2016 at 04:00:00pm</p></header><div class="content"><p>Hey,<br></p><p>&gt; [...]<br>&gt; I see it as my responsibility to know exactly what code I’m pulling into my package. In my view, it’s absolutely unsafe to trust other people’s code. Even when they mean no harm, trusting them to properly apply SemVer is the same issue.<br></p><p>maybe we should have the tooling support that? Elm does try to enforce correct semantic versioning. Maybe swift-pm should do that too?<br></p><p>See http://elm-lang.org :<br>&lt;quote&gt;<br>Enforced Semantic Versioning<br></p><p>Elm can detect all API changes automatically thanks to its type system. We use that information to force everything in our package catalog to follow semantic versioning precisely. No more surprises in PATCH releases!<br>&lt;/quote&gt;<br></p><p>I have no idea how well it works but if we&#39;ll end up relying on proper semantic versioning, tool support sounds like a good idea to me.<br></p><p><br>&gt; [...]<br></p><p>Cheers,<br>  Johannes<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/424a9ce662b059c35063b405e160461d?s=50"></div><header><strong>[swift-evolution] Proposal: Package Manager Version Pinning</strong> from <string>Eloy Durán</string> &lt;eloy.de.enige at gmail.com&gt;<p>October 15, 2016 at 01:00:00am</p></header><div class="content"><p>&gt;&gt; [...]<br>&gt;&gt; I see it as my responsibility to know exactly what code I’m pulling into my package. In my view, it’s absolutely unsafe to trust other people’s code. Even when they mean no harm, trusting them to properly apply SemVer is the same issue.<br>&gt; <br>&gt; maybe we should have the tooling support that? Elm does try to enforce correct semantic versioning. Maybe swift-pm should do that too?<br>&gt; <br>&gt; See http://elm-lang.org :<br>&gt; &lt;quote&gt;<br>&gt; Enforced Semantic Versioning<br>&gt; <br>&gt; Elm can detect all API changes automatically thanks to its type system. We use that information to force everything in our package catalog to follow semantic versioning precisely. No more surprises in PATCH releases!<br>&gt; &lt;/quote&gt;<br>&gt; <br>&gt; I have no idea how well it works but if we&#39;ll end up relying on proper semantic versioning, tool support sounds like a good idea to me.<br></p><p>This is what I was referring to when I mentioned that automation can only take you so far. It is easily possible to do a patch release where the API might not change, but the semantics of the code does.<br></p><p>In my opinion it requires human judgement to determine if a change is really something you can trust. Trusting SemVer for that is going to lead to problems and making people think that they can is just misleading in my book.<br></p><p>Not saying you can’t have tools to help guide choosing versions, though.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/353d1c09444050fea4228317eaefafda?s=50"></div><header><strong>[swift-evolution] Proposal: Package Manager Version Pinning</strong> from <string>Johannes Weiß</string> &lt;johannesweiss at apple.com&gt;<p>October 14, 2016 at 04:00:00pm</p></header><div class="content"><p>Hi Eloy,<br></p><p>&gt; &gt; [...]<br>&gt;&gt; I have no idea how well it works but if we&#39;ll end up relying on proper semantic versioning, tool support sounds like a good idea to me.<br>&gt; <br>&gt; This is what I was referring to when I mentioned that automation can only take you so far. It is easily possible to do a patch release where the API might not change, but the semantics of the code does.<br>&gt; <br>&gt; In my opinion it requires human judgement to determine if a change is really something you can trust. Trusting SemVer for that is going to lead to problems and making people think that they can is just misleading in my book.<br>&gt; <br>&gt; Not saying you can’t have tools to help guide choosing versions, though.<br></p><p>agreed. But I think that if (whether that&#39;s good or bad) we rely on semantic versioning, tool support can make that a lot easier.<br></p><p>Cheers,<br>  Johannes<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/424a9ce662b059c35063b405e160461d?s=50"></div><header><strong>[swift-evolution] Proposal: Package Manager Version Pinning</strong> from <string>Eloy Durán</string> &lt;eloy.de.enige at gmail.com&gt;<p>October 15, 2016 at 01:00:00am</p></header><div class="content"><p>&gt;&gt; Not saying you can’t have tools to help guide choosing versions, though.<br>&gt; <br>&gt; agreed. But I think that if (whether that&#39;s good or bad) we rely on semantic versioning, tool support can make that a lot easier.<br></p><p>Aye, agreed.<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d9baa679148bd83458d11df12327ce0?s=50"></div><header><strong>[swift-evolution] Proposal: Package Manager Version Pinning</strong> from <string>Daniel Dunbar</string> &lt;daniel_dunbar at apple.com&gt;<p>October 14, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Oct 14, 2016, at 4:15 PM, Johannes Weiß &lt;johannesweiss at apple.com&gt; wrote:<br>&gt; <br>&gt; Hey,<br>&gt; <br>&gt;&gt; [...]<br>&gt;&gt; I see it as my responsibility to know exactly what code I’m pulling into my package. In my view, it’s absolutely unsafe to trust other people’s code. Even when they mean no harm, trusting them to properly apply SemVer is the same issue.<br>&gt; <br>&gt; maybe we should have the tooling support that? Elm does try to enforce correct semantic versioning. Maybe swift-pm should do that too?<br></p><p>We would like to (try to), and it is on the long list of ideal future things to do. It requires a lot of compiler support no one has signed up for yet, though...<br></p><p> - Daniel<br></p><p>&gt; See http://elm-lang.org :<br>&gt; &lt;quote&gt;<br>&gt; Enforced Semantic Versioning<br>&gt; <br>&gt; Elm can detect all API changes automatically thanks to its type system. We use that information to force everything in our package catalog to follow semantic versioning precisely. No more surprises in PATCH releases!<br>&gt; &lt;/quote&gt;<br>&gt; <br>&gt; I have no idea how well it works but if we&#39;ll end up relying on proper semantic versioning, tool support sounds like a good idea to me.<br>&gt; <br>&gt; <br>&gt;&gt; [...]<br>&gt; <br>&gt; Cheers,<br>&gt;  Johannes<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/424a9ce662b059c35063b405e160461d?s=50"></div><header><strong>[swift-evolution] Proposal: Package Manager Version Pinning</strong> from <string>Eloy Durán</string> &lt;eloy.de.enige at gmail.com&gt;<p>October 14, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; The big struggle I have is that if we go the other direction, and as a result people&#39;s semantic versions become poorly specified, we will never be able to recover. The converse is not true, if we start with this direction and realize it doesn&#39;t work, we can relax our behavior.<br></p><p>Forgot to touch on this. One interesting thing we can observe from the current npm/yarn split is that because npm has set the tone about trusting semver plenty of people will still follow this, but in my opinion it&#39;s mostly a matter of them not being burned *yet*.<br></p><p>Whatever you decide is the right thing to do now will probably cement in users minds for years to come, regardless of how easy it technically is to make a change.<br></p><p>(Did I say yet that I&#39;m pessimistic about these things?)<br></p><p>&gt; On 14 Oct 2016, at 18:42, Daniel Dunbar &lt;daniel_dunbar at apple.com&gt; wrote:<br>&gt; <br>&gt; Hey Eloy,<br>&gt; <br>&gt; Same question as I sent to Orta, can you detail exactly what you would prefer to change?<br>&gt; <br>&gt;&gt; On Oct 14, 2016, at 4:06 AM, Eloy Durán via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I cannot agree more with Orta.<br>&gt;&gt; <br>&gt;&gt; &gt; It drives the user away from taking full advantage of semantic versioning.<br>&gt;&gt; <br>&gt;&gt; While I ideally subscribe to this thought, the truth of the matter is that this has proven unreliable on multiple occasions. Promoting the idea that it works is going to inevitably lead users into problems when they did not take explicit user action to update dependencies.<br>&gt; <br>&gt; This makes a lot of sense to me. The open question in my mind is, given our other goals, are we in a position to make this model work, or to make it &quot;the right model for us&quot;. Some of the other things I am considering (and maybe should go into the proposal):<br>&gt; <br>&gt; 1. Swift is still evolving in a much greater way than other languages. That means we continue to need to have a very strong push towards forward versions. This is also true for the package manager features, we need the ecosystem to move forward aggressively so that we can move our own features forward aggressively.<br>&gt; <br>&gt; 2. We have some lofty goals around semantic versioning, like trying to have a much deeper integration with the compiler, API, and ABI, and testing in order to help manage this more effectively.<br>&gt; <br>&gt;&gt; Semantic versioning is a great tool when you decide to sit down and explicitly update dependencies.<br>&gt; <br>&gt; The problem is they go hand in hand. The more people pin versus following the semantic versioning, the more and more likely it is that those specifications are wrong. That leads to more pinning, which leads to more wrong specifications.<br>&gt; <br>&gt; My preference is that we very aggressively commit to using semantic versioning, and then follow up with the entire cross functional design (an index, if we ever do one, the compiler features, any IDE integration) to make this work. I think we are in a better position than other tools which didn&#39;t have the ability to make as many cross functional changes (e.g., integration with the compiler to assist in semantic versioning).<br>&gt; <br>&gt; On the other hand, I am also very pragmatic, and I respect your experience here... if this model simply isn&#39;t going to work, then we shouldn&#39;t try to go that way.<br>&gt; <br>&gt; The big struggle I have is that if we go the other direction, and as a result people&#39;s semantic versions become poorly specified, we will never be able to recover. The converse is not true, if we start with this direction and realize it doesn&#39;t work, we can relax our behavior.<br>&gt; <br>&gt;&gt; &gt; We think it will be good for the package ecosystem if such a restriction is not the default behavior and that this design will lead to faster discovery of bugs and fixes in the upstream.<br>&gt;&gt; <br>&gt;&gt; Again, ideally I would subscribe to this, but the truth is that when people are working on their projects they *really really really* do *not* like their builds breaking, especially not when it’s seemingly caused outside of their own fault.<br>&gt; <br>&gt; One discussion we had a lot was that there are very different workflows between when you are largely the consumer of packages, versus when you are working on a package that is shared.<br>&gt; <br>&gt; We generally agree that when you are simply the consumer of packages, pinning makes sense.<br>&gt; <br>&gt; However, when you are primarily a distributor of packages (and this is expected to *most* of the momentum behind SwiftPM in the near term), I believe that it is very important to the ecosystem that the semver specs be correct, and so even if the team *wants* to pin, doing so would be actively harmful.<br>&gt; <br>&gt;&gt; In the end, it comes down to whether you prioritise surfacing bugs (long term happiness) over user-experience (short term happiness). As a dependency manager author, I can tell you that I agree with your ideals and would want to choose the former, but as a user of dependency managers I would choose UX and Getting (The) Things (I Really Wanted To Do) Done over surfacing bugs *any* day.<br>&gt; <br>&gt; I really appreciate the feedback. Do my arguments that we might be in a position to do better here have any weight with you?<br>&gt; <br>&gt;  - Daniel<br>&gt; <br>&gt;&gt; <br>&gt;&gt; [A.]		Eloy Durán<br>&gt;&gt; 		Artsy<br>&gt;&gt; 		<br>&gt;&gt; 		eloy at artsy.net<br>&gt;&gt; 		Twitter<br>&gt;&gt; 		GitHub<br>&gt;&gt; <br>&gt;&gt;&gt; On 14 Oct 2016, at 09:29, orta therox via swift-build-dev &lt;swift-build-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Please don’t make this a separate command, it should ideally be created at the end of an build (when there isn’t one already) or an update of your dependencies - most people will be expecting to get the same set of dependencies as the rest of their team. This pattern makes that harder.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; NPM shrinkwrap is an example of this, and it’s a bad one - I’ve wasted a lot of time trying to keep that up to date for our npm projects. Facebook made a replacement for NPM with mainly the  feature of “always locking” in yarn and I’d expect that to take a lot of the JS mindshare on this one feature alone.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; [A.]	    Orta Therox<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; w/ Artsy<br>&gt;&gt;&gt;&gt; CocoaPods / CocoaDocs / GIFs.app<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; @orta / orta.github.com<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Artsy is totally hiring iOS Devs ATM<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 14 Oct 2016, at 07:01, Ankit Aggarwal via swift-build-dev &lt;swift-build-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We&#39;re proposing version pinning feature in Swift Package Manager. The proposal is available here and also in this email:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Feedback welcomed!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt; Ankit<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; --------<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Package Manager Version Pinning<br>&gt;&gt;&gt;&gt; Proposal: SE-XXXX<br>&gt;&gt;&gt;&gt; Author: Daniel Dunbar, Ankit Aggarwal<br>&gt;&gt;&gt;&gt; Review Manager: TBD<br>&gt;&gt;&gt;&gt; Status: Discussion<br>&gt;&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;&gt; This is a proposal for adding package manager features to &quot;pin&quot; or &quot;lock&quot; package dependencies to particular versions.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;&gt; As used in this proposal, version pinning refers to the practice of controlling exactly which specific version of a dependency is selected by the dependency resolution algorithm, independent from the semantic versioning specification. Thus, it is a way of instructing the package manager to select a particular version from among all of the versions of a package which could be chosen while honoring the dependency constraints.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Terminology<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We have chosen to use &quot;pinning&quot; to refer to this feature, over &quot;lockfiles&quot;, since the term &quot;lock&quot; is already overloaded between POSIX file locks and locks in concurrent programming.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Philosophy<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Our philosophy with regard to pinning is that we actively want to encourage packages to develop against the latest semantically appropriate versions of their dependencies, in order to foster rapid development amongst the ecosystem and strong reliance on the semantic versioning concept. Our design for version pinning is thus intended to be a feature for package authors and users to use in crafting specific workflows, not be a mechanism by which most of the packages in the ecosystem pin themselves to specific versions of each other.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Use Cases<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Our proposal is designed to satisfy several different use cases for such a behavior:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Standardizing team workflows<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; When collaborating on a package, it can be valuable for team members (and continuous integration) to all know they are using the same exact version of dependencies, to avoid &quot;works for me&quot; situations.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This can be particularly important for certain kinds of open source projects which are actively being cloned by new users, and which want to have some measure of control around exactly which available version of a dependency is selected.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Difficult to test packages or dependencies<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Complex packages which have dependencies which may be hard to test, or hard to analyze when they break, may choose to maintain careful control over what versions of their upstream dependencies they recommend -- even if conceptually they regularly update those recommendations following the true semantic version specification of the dependency.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Dependency locking w.r.t. deployment<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; When stabilizing a release for deployment, or building a version of a package for deployment, it is important to be able to lock down the exact versions of dependencies in use, so that the resulting product can be exactly recreated later if necessary.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt;&gt; We will introduce support for an optional new file Package.pins adjacent to the Package.swift manifest, called the &quot;pins file&quot;. We will also introduce a number of new commands (see below) for maintaining the pins file.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This file will record the active version pin information for the package, including data such as the package identifier, the pinned version, and explicit information on the pinned version (e.g., the commit hash/SHA for the resolved tag).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The exact file format is unspecified/implementation defined, however, in practice it will be a JSON data file.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This file may be checked into SCM by the user, so that its effects apply to all users of the package. However, it may also be maintained only locally (e.g., placed in the .gitignore file). We intend to leave it to package authors to decide which use case is best for their project.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In the presence of a Package.pins file, the package manager will respect the pinned dependencies recorded in the file whenever it needs to do dependency resolution (e.g., on the initial checkout or when updating).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The pins file will not override Manifest specified version requirements and it will be an error (with proper diagnostics) if there is a conflict between the pins and the manifest specification.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Detailed Design<br>&gt;&gt;&gt;&gt; We will add a new command pin to swift package tool with following semantics:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; $ swift package pin ( [--all] | [&lt;package-name&gt;] [&lt;version&gt;] ) [--message &lt;message&gt;]<br>&gt;&gt;&gt;&gt; The package-name refers to the name of the package as specified in its manifest.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This command pins one or all dependencies. The command which pins a single version can optionally take a specific version to pin to, if unspecified (or with --all) the behaviour is to pin to the current package version in use. Examples: <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; $ swift package pin --all - pins all the dependencies.<br>&gt;&gt;&gt;&gt; $ swift package pin Foo - pins Foo at current resolved version.<br>&gt;&gt;&gt;&gt; $ swift package pin Foo 1.2.3 - pins Foo at 1.2.3. The specified version should be valid and resolvable.<br>&gt;&gt;&gt;&gt; The --reason option is an optional argument to document the reason for pinning a dependency. This could be helpful for user to later remember why a dependency was pinned. Example: <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; $ swift package pin Foo --reason &quot;The patch updates for Foo are really unstable and need screening.&quot;<br>&gt;&gt;&gt;&gt; Dependencies are never automatically pinned, pinning is only ever taken as a result of an explicit user action.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We will add a new command unpin:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; $ swift package unpin ( [--all] | [&lt;package-name&gt;] )<br>&gt;&gt;&gt;&gt; This is the counterpart to the pin command, and unpins one or all packages.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We will fetch and resolve the dependencies when running the pin commands, in case we don&#39;t have the complete dependency graph yet.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We will extend the workflow for update to honour version pinning, that is, it will only update packages which are unpinned, and it will only update to versions which can satisfy the existing pins. The update command will, however, also take an optional argument --repin:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; $ swift package update [--repin]<br>&gt;&gt;&gt;&gt; Update command errors if there are no unpinned packages which can be updated.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Otherwise, the behaviour is to update all unpinned packages to the latest possible versions which can be resolved while respecting the existing pins.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The [--repin] argument can be used to lift the version pinning restrictions. In this case, the behaviour is that all packages are updated, and packages which were previously pinned are then repinned to the latest resolved versions.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The update and checkout will both emit logs, notifying the user that pinning is in effect.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The swift package show-dependencies subcommand will be updated to indicate if a dependency is pinned.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As a future extension, we anticipate using the SHA information recorded in a pins file as a security feature, to prevent man-in-the-middle attacks on parts of the package graph.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt;&gt; There will be change in the behaviours of swift build and swift package update in presence of the pins file, as noted in the proposal however the existing package will continue to build without any modifications.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Alternative considered<br>&gt;&gt;&gt;&gt; We considered making the pinning behavior default on running swift build, however we think that pinning by default is likely to make the package graph more constrained than it should be. It drives the user away from taking full advantage of semantic versioning. We think it will be good for the package ecosystem if such a restriction is not the default behavior and that this design will lead to faster discovery of bugs and fixes in the upstream.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-build-dev mailing list<br>&gt;&gt;&gt;&gt; swift-build-dev at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-build-dev mailing list<br>&gt;&gt;&gt; swift-build-dev at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20161014/d7e26c30/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d9baa679148bd83458d11df12327ce0?s=50"></div><header><strong>[swift-evolution] Proposal: Package Manager Version Pinning</strong> from <string>Daniel Dunbar</string> &lt;daniel_dunbar at apple.com&gt;<p>October 14, 2016 at 09:00:00am</p></header><div class="content"><p>Hey Orta,<br></p><p>Thanks for this feedback, this was one of the hotly debated points as you might imagine.<br></p><p>Can you elaborate on exactly how you would prefer this to work?<br></p><p>The way I see it, the only thing that this changes is that the initial package **author** who wants to be in this situation has to, one time, run &quot;package pin --all&quot;, and then &quot;git add Package.pins&quot;. The latter is always going to be necessary, so are you arguing the first should just be done by default, or is there something deeper here?<br></p><p> - Daniel<br></p><p>&gt; On Oct 14, 2016, at 12:29 AM, orta therox via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Please don’t make this a separate command, it should ideally be created at the end of an build (when there isn’t one already) or an update of your dependencies - most people will be expecting to get the same set of dependencies as the rest of their team. This pattern makes that harder.<br>&gt; <br>&gt; NPM shrinkwrap is an example of this, and it’s a bad one - I’ve wasted a lot of time trying to keep that up to date for our npm projects. Facebook made a replacement for NPM with mainly the  feature of “always locking” in yarn &lt;https://yarnpkg.com/&gt; and I’d expect that to take a lot of the JS mindshare on this one feature alone.<br>&gt; <br>&gt; -- <br>&gt; <br>&gt; [A.]	    Orta Therox<br>&gt; <br>&gt;&gt; w/ Artsy &lt;http://artsy.net/&gt;CocoaPods &lt;http://cocoapods.org/&gt; / CocoaDocs &lt;http://cocoadocs.org/&gt; / GIFs.app &lt;https://itunes.apple.com/us/app/gifs/id961850017?l=en&amp;mt=12&gt;<br>&gt;&gt; @orta &lt;http://twitter.com/orta&gt; / orta.github.com &lt;http://orta.github.com/&gt;<br>&gt;&gt; Artsy is totally hiring iOS Devs &lt;https://artsy.net/job/mobile-engineer&gt; ATM<br>&gt; <br>&gt;&gt; On 14 Oct 2016, at 07:01, Ankit Aggarwal via swift-build-dev &lt;swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi,<br>&gt;&gt; <br>&gt;&gt; We&#39;re proposing version pinning feature in Swift Package Manager. The proposal is available here &lt;https://github.com/aciidb0mb3r/swift-evolution/blob/version-pinning/proposals/NNNN-Version-Pinning.md&gt; and also in this email:<br>&gt;&gt; <br>&gt;&gt; Feedback welcomed!<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; Ankit<br>&gt;&gt; <br>&gt;&gt; --------<br>&gt;&gt; <br>&gt;&gt; Package Manager Version Pinning<br>&gt;&gt; Proposal: SE-XXXX<br>&gt;&gt; Author: Daniel Dunbar &lt;https://github.com/ddunbar&gt;, Ankit Aggarwal &lt;https://github.com/aciidb0mb3r&gt;<br>&gt;&gt; Review Manager: TBD<br>&gt;&gt; Status: Discussion<br>&gt;&gt; Introduction<br>&gt;&gt; This is a proposal for adding package manager features to &quot;pin&quot; or &quot;lock&quot; package dependencies to particular versions.<br>&gt;&gt; <br>&gt;&gt; Motivation<br>&gt;&gt; As used in this proposal, version pinning refers to the practice of controlling exactly which specific version of a dependency is selected by the dependency resolution algorithm, independent from the semantic versioning specification. Thus, it is a way of instructing the package manager to select a particular version from among all of the versions of a package which could be chosen while honoring the dependency constraints.<br>&gt;&gt; <br>&gt;&gt; Terminology<br>&gt;&gt; <br>&gt;&gt; We have chosen to use &quot;pinning&quot; to refer to this feature, over &quot;lockfiles&quot;, since the term &quot;lock&quot; is already overloaded between POSIX file locks and locks in concurrent programming.<br>&gt;&gt; <br>&gt;&gt; Philosophy<br>&gt;&gt; <br>&gt;&gt; Our philosophy with regard to pinning is that we actively want to encourage packages to develop against the latest semantically appropriate versions of their dependencies, in order to foster rapid development amongst the ecosystem and strong reliance on the semantic versioning concept. Our design for version pinning is thus intended to be a feature for package authors and users to use in crafting specific workflows, not be a mechanism by which most of the packages in the ecosystem pin themselves to specific versions of each other.<br>&gt;&gt; <br>&gt;&gt; Use Cases<br>&gt;&gt; <br>&gt;&gt; Our proposal is designed to satisfy several different use cases for such a behavior:<br>&gt;&gt; <br>&gt;&gt; Standardizing team workflows<br>&gt;&gt; <br>&gt;&gt; When collaborating on a package, it can be valuable for team members (and continuous integration) to all know they are using the same exact version of dependencies, to avoid &quot;works for me&quot; situations.<br>&gt;&gt; <br>&gt;&gt; This can be particularly important for certain kinds of open source projects which are actively being cloned by new users, and which want to have some measure of control around exactly which available version of a dependency is selected.<br>&gt;&gt; <br>&gt;&gt; Difficult to test packages or dependencies<br>&gt;&gt; <br>&gt;&gt; Complex packages which have dependencies which may be hard to test, or hard to analyze when they break, may choose to maintain careful control over what versions of their upstream dependencies they recommend -- even if conceptually they regularly update those recommendations following the true semantic version specification of the dependency.<br>&gt;&gt; <br>&gt;&gt; Dependency locking w.r.t. deployment<br>&gt;&gt; <br>&gt;&gt; When stabilizing a release for deployment, or building a version of a package for deployment, it is important to be able to lock down the exact versions of dependencies in use, so that the resulting product can be exactly recreated later if necessary.<br>&gt;&gt; <br>&gt;&gt; Proposed solution<br>&gt;&gt; We will introduce support for an optional new file Package.pins adjacent to the Package.swift manifest, called the &quot;pins file&quot;. We will also introduce a number of new commands (see below) for maintaining the pins file.<br>&gt;&gt; <br>&gt;&gt; This file will record the active version pin information for the package, including data such as the package identifier, the pinned version, and explicit information on the pinned version (e.g., the commit hash/SHA for the resolved tag).<br>&gt;&gt; <br>&gt;&gt; The exact file format is unspecified/implementation defined, however, in practice it will be a JSON data file.<br>&gt;&gt; <br>&gt;&gt; This file may be checked into SCM by the user, so that its effects apply to all users of the package. However, it may also be maintained only locally (e.g., placed in the .gitignore file). We intend to leave it to package authors to decide which use case is best for their project.<br>&gt;&gt; <br>&gt;&gt; In the presence of a Package.pins file, the package manager will respect the pinned dependencies recorded in the file whenever it needs to do dependency resolution (e.g., on the initial checkout or when updating).<br>&gt;&gt; <br>&gt;&gt; The pins file will not override Manifest specified version requirements and it will be an error (with proper diagnostics) if there is a conflict between the pins and the manifest specification.<br>&gt;&gt; <br>&gt;&gt; Detailed Design<br>&gt;&gt; We will add a new command pin to swift package tool with following semantics:<br>&gt;&gt; <br>&gt;&gt; $ swift package pin ( [--all] | [&lt;package-name&gt;] [&lt;version&gt;] ) [--message &lt;message&gt;]<br>&gt;&gt; The package-name refers to the name of the package as specified in its manifest.<br>&gt;&gt; <br>&gt;&gt; This command pins one or all dependencies. The command which pins a single version can optionally take a specific version to pin to, if unspecified (or with --all) the behaviour is to pin to the current package version in use. Examples: <br>&gt;&gt; <br>&gt;&gt; $ swift package pin --all - pins all the dependencies.<br>&gt;&gt; $ swift package pin Foo - pins Foo at current resolved version.<br>&gt;&gt; $ swift package pin Foo 1.2.3 - pins Foo at 1.2.3. The specified version should be valid and resolvable.<br>&gt;&gt; The --reason option is an optional argument to document the reason for pinning a dependency. This could be helpful for user to later remember why a dependency was pinned. Example: <br>&gt;&gt; <br>&gt;&gt; $ swift package pin Foo --reason &quot;The patch updates for Foo are really unstable and need screening.&quot;<br>&gt;&gt; Dependencies are never automatically pinned, pinning is only ever taken as a result of an explicit user action.<br>&gt;&gt; <br>&gt;&gt; We will add a new command unpin:<br>&gt;&gt; <br>&gt;&gt; $ swift package unpin ( [--all] | [&lt;package-name&gt;] )<br>&gt;&gt; This is the counterpart to the pin command, and unpins one or all packages.<br>&gt;&gt; <br>&gt;&gt; We will fetch and resolve the dependencies when running the pin commands, in case we don&#39;t have the complete dependency graph yet.<br>&gt;&gt; <br>&gt;&gt; We will extend the workflow for update to honour version pinning, that is, it will only update packages which are unpinned, and it will only update to versions which can satisfy the existing pins. The update command will, however, also take an optional argument --repin:<br>&gt;&gt; <br>&gt;&gt; $ swift package update [--repin]<br>&gt;&gt; Update command errors if there are no unpinned packages which can be updated.<br>&gt;&gt; <br>&gt;&gt; Otherwise, the behaviour is to update all unpinned packages to the latest possible versions which can be resolved while respecting the existing pins.<br>&gt;&gt; <br>&gt;&gt; The [--repin] argument can be used to lift the version pinning restrictions. In this case, the behaviour is that all packages are updated, and packages which were previously pinned are then repinned to the latest resolved versions.<br>&gt;&gt; <br>&gt;&gt; The update and checkout will both emit logs, notifying the user that pinning is in effect.<br>&gt;&gt; <br>&gt;&gt; The swift package show-dependencies subcommand will be updated to indicate if a dependency is pinned.<br>&gt;&gt; <br>&gt;&gt; As a future extension, we anticipate using the SHA information recorded in a pins file as a security feature, to prevent man-in-the-middle attacks on parts of the package graph.<br>&gt;&gt; <br>&gt;&gt; Impact on existing code<br>&gt;&gt; There will be change in the behaviours of swift build and swift package update in presence of the pins file, as noted in the proposal however the existing package will continue to build without any modifications.<br>&gt;&gt; <br>&gt;&gt; Alternative considered<br>&gt;&gt; We considered making the pinning behavior default on running swift build, however we think that pinning by default is likely to make the package graph more constrained than it should be. It drives the user away from taking full advantage of semantic versioning. We think it will be good for the package ecosystem if such a restriction is not the default behavior and that this design will lead to faster discovery of bugs and fixes in the upstream.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-build-dev mailing list<br>&gt;&gt; swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20161014/9c2763b2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/79d9ba388d6b6cf4ec7310cad9fa8c8a?s=50"></div><header><strong>[swift-evolution] Proposal: Package Manager Version Pinning</strong> from <string>Rob Allen</string> &lt;rob at akrabat.com&gt;<p>October 14, 2016 at 06:00:00pm</p></header><div class="content"><p>Hi,<br></p><p>As noted by others, the standard extension for this file .lock, so I would prefer to keep that convention.<br></p><p>As I would never want my CI or any random team member to build a different package to what I&#39;ve developed and tested already, I will always want Package.lock to exist. It&#39;s much easier if the system always creates Package.lock on swift package update and always uses it (if it exists) with swift build. This way, I get to choose when to go from 1.3.1 to 1.3.2 just in case I happen to depend on that bug that&#39;s now been fixed…<br></p><p>I can&#39;t see any downside to not creating it automatically and it results in so much more consistency across a team.<br></p><p>Regards,<br></p><p>Rob...<br></p><p><br>&gt; On 14 Oct 2016, at 17:29, Daniel Dunbar via swift-build-dev &lt;swift-build-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Hey Orta,<br>&gt; <br>&gt; Thanks for this feedback, this was one of the hotly debated points as you might imagine.<br>&gt; <br>&gt; Can you elaborate on exactly how you would prefer this to work?<br>&gt; <br>&gt; The way I see it, the only thing that this changes is that the initial package **author** who wants to be in this situation has to, one time, run &quot;package pin --all&quot;, and then &quot;git add Package.pins&quot;. The latter is always going to be necessary, so are you arguing the first should just be done by default, or is there something deeper here?<br>&gt; <br>&gt;  - Daniel<br>&gt; <br>&gt;&gt; On Oct 14, 2016, at 12:29 AM, orta therox via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Please don’t make this a separate command, it should ideally be created at the end of an build (when there isn’t one already) or an update of your dependencies - most people will be expecting to get the same set of dependencies as the rest of their team. This pattern makes that harder.<br>&gt;&gt; <br>&gt;&gt; NPM shrinkwrap is an example of this, and it’s a bad one - I’ve wasted a lot of time trying to keep that up to date for our npm projects. Facebook made a replacement for NPM with mainly the  feature of “always locking” in yarn &lt;https://yarnpkg.com/&gt; and I’d expect that to take a lot of the JS mindshare on this one feature alone.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20161014/5889e39a/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ad5d998258bab37d23bc9555b0d6c237?s=50"></div><header><strong>Proposal: Package Manager Version Pinning</strong> from <string>Max Desiatov</string> &lt;max.desiatov at gmail.com&gt;<p>October 14, 2016 at 05:00:00pm</p></header><div class="content"><p>I also strongly agree with this, I&#39;d prefer version pinning to happen by default, rather than with explicit command as it will make builds reproducible by default. <br></p><p>I totally agree that we can rely on past experience with other package managers (npm being the case), where pinning with a separate command caused more harm than good.<br></p><p>Overall, I think that it would be great if Package.lock was created by default when it&#39;s not present and be updated only with an explicit command for updating.<br></p><p>With best regards, Max.<br></p><p><br>&gt; On 14 Oct 2016, at 08:29, orta therox via swift-build-dev &lt;swift-build-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Please don’t make this a separate command, it should ideally be created at the end of an build (when there isn’t one already) or an update of your dependencies - most people will be expecting to get the same set of dependencies as the rest of their team. This pattern makes that harder.<br>&gt; <br>&gt; NPM shrinkwrap is an example of this, and it’s a bad one - I’ve wasted a lot of time trying to keep that up to date for our npm projects. Facebook made a replacement for NPM with mainly the  feature of “always locking” in yarn &lt;https://yarnpkg.com/&gt; and I’d expect that to take a lot of the JS mindshare on this one feature alone.<br>&gt; <br>&gt; -- <br>&gt; <br>&gt; [A.]	    Orta Therox<br>&gt; <br>&gt;&gt; w/ Artsy &lt;http://artsy.net/&gt;CocoaPods &lt;http://cocoapods.org/&gt; / CocoaDocs &lt;http://cocoadocs.org/&gt; / GIFs.app &lt;https://itunes.apple.com/us/app/gifs/id961850017?l=en&amp;mt=12&gt;<br>&gt;&gt; @orta &lt;http://twitter.com/orta&gt; / orta.github.com &lt;http://orta.github.com/&gt;<br>&gt;&gt; Artsy is totally hiring iOS Devs &lt;https://artsy.net/job/mobile-engineer&gt; ATM<br>&gt; <br>&gt;&gt; On 14 Oct 2016, at 07:01, Ankit Aggarwal via swift-build-dev &lt;swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi,<br>&gt;&gt; <br>&gt;&gt; We&#39;re proposing version pinning feature in Swift Package Manager. The proposal is available here &lt;https://github.com/aciidb0mb3r/swift-evolution/blob/version-pinning/proposals/NNNN-Version-Pinning.md&gt; and also in this email:<br>&gt;&gt; <br>&gt;&gt; Feedback welcomed!<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; Ankit<br>&gt;&gt; <br>&gt;&gt; --------<br>&gt;&gt; <br>&gt;&gt; Package Manager Version Pinning<br>&gt;&gt; Proposal: SE-XXXX<br>&gt;&gt; Author: Daniel Dunbar &lt;https://github.com/ddunbar&gt;, Ankit Aggarwal &lt;https://github.com/aciidb0mb3r&gt;<br>&gt;&gt; Review Manager: TBD<br>&gt;&gt; Status: Discussion<br>&gt;&gt; Introduction<br>&gt;&gt; This is a proposal for adding package manager features to &quot;pin&quot; or &quot;lock&quot; package dependencies to particular versions.<br>&gt;&gt; <br>&gt;&gt; Motivation<br>&gt;&gt; As used in this proposal, version pinning refers to the practice of controlling exactly which specific version of a dependency is selected by the dependency resolution algorithm, independent from the semantic versioning specification. Thus, it is a way of instructing the package manager to select a particular version from among all of the versions of a package which could be chosen while honoring the dependency constraints.<br>&gt;&gt; <br>&gt;&gt; Terminology<br>&gt;&gt; <br>&gt;&gt; We have chosen to use &quot;pinning&quot; to refer to this feature, over &quot;lockfiles&quot;, since the term &quot;lock&quot; is already overloaded between POSIX file locks and locks in concurrent programming.<br>&gt;&gt; <br>&gt;&gt; Philosophy<br>&gt;&gt; <br>&gt;&gt; Our philosophy with regard to pinning is that we actively want to encourage packages to develop against the latest semantically appropriate versions of their dependencies, in order to foster rapid development amongst the ecosystem and strong reliance on the semantic versioning concept. Our design for version pinning is thus intended to be a feature for package authors and users to use in crafting specific workflows, not be a mechanism by which most of the packages in the ecosystem pin themselves to specific versions of each other.<br>&gt;&gt; <br>&gt;&gt; Use Cases<br>&gt;&gt; <br>&gt;&gt; Our proposal is designed to satisfy several different use cases for such a behavior:<br>&gt;&gt; <br>&gt;&gt; Standardizing team workflows<br>&gt;&gt; <br>&gt;&gt; When collaborating on a package, it can be valuable for team members (and continuous integration) to all know they are using the same exact version of dependencies, to avoid &quot;works for me&quot; situations.<br>&gt;&gt; <br>&gt;&gt; This can be particularly important for certain kinds of open source projects which are actively being cloned by new users, and which want to have some measure of control around exactly which available version of a dependency is selected.<br>&gt;&gt; <br>&gt;&gt; Difficult to test packages or dependencies<br>&gt;&gt; <br>&gt;&gt; Complex packages which have dependencies which may be hard to test, or hard to analyze when they break, may choose to maintain careful control over what versions of their upstream dependencies they recommend -- even if conceptually they regularly update those recommendations following the true semantic version specification of the dependency.<br>&gt;&gt; <br>&gt;&gt; Dependency locking w.r.t. deployment<br>&gt;&gt; <br>&gt;&gt; When stabilizing a release for deployment, or building a version of a package for deployment, it is important to be able to lock down the exact versions of dependencies in use, so that the resulting product can be exactly recreated later if necessary.<br>&gt;&gt; <br>&gt;&gt; Proposed solution<br>&gt;&gt; We will introduce support for an optional new file Package.pins adjacent to the Package.swift manifest, called the &quot;pins file&quot;. We will also introduce a number of new commands (see below) for maintaining the pins file.<br>&gt;&gt; <br>&gt;&gt; This file will record the active version pin information for the package, including data such as the package identifier, the pinned version, and explicit information on the pinned version (e.g., the commit hash/SHA for the resolved tag).<br>&gt;&gt; <br>&gt;&gt; The exact file format is unspecified/implementation defined, however, in practice it will be a JSON data file.<br>&gt;&gt; <br>&gt;&gt; This file may be checked into SCM by the user, so that its effects apply to all users of the package. However, it may also be maintained only locally (e.g., placed in the .gitignore file). We intend to leave it to package authors to decide which use case is best for their project.<br>&gt;&gt; <br>&gt;&gt; In the presence of a Package.pins file, the package manager will respect the pinned dependencies recorded in the file whenever it needs to do dependency resolution (e.g., on the initial checkout or when updating).<br>&gt;&gt; <br>&gt;&gt; The pins file will not override Manifest specified version requirements and it will be an error (with proper diagnostics) if there is a conflict between the pins and the manifest specification.<br>&gt;&gt; <br>&gt;&gt; Detailed Design<br>&gt;&gt; We will add a new command pin to swift package tool with following semantics:<br>&gt;&gt; <br>&gt;&gt; $ swift package pin ( [--all] | [&lt;package-name&gt;] [&lt;version&gt;] ) [--message &lt;message&gt;]<br>&gt;&gt; The package-name refers to the name of the package as specified in its manifest.<br>&gt;&gt; <br>&gt;&gt; This command pins one or all dependencies. The command which pins a single version can optionally take a specific version to pin to, if unspecified (or with --all) the behaviour is to pin to the current package version in use. Examples: <br>&gt;&gt; <br>&gt;&gt; $ swift package pin --all - pins all the dependencies.<br>&gt;&gt; $ swift package pin Foo - pins Foo at current resolved version.<br>&gt;&gt; $ swift package pin Foo 1.2.3 - pins Foo at 1.2.3. The specified version should be valid and resolvable.<br>&gt;&gt; The --reason option is an optional argument to document the reason for pinning a dependency. This could be helpful for user to later remember why a dependency was pinned. Example: <br>&gt;&gt; <br>&gt;&gt; $ swift package pin Foo --reason &quot;The patch updates for Foo are really unstable and need screening.&quot;<br>&gt;&gt; Dependencies are never automatically pinned, pinning is only ever taken as a result of an explicit user action.<br>&gt;&gt; <br>&gt;&gt; We will add a new command unpin:<br>&gt;&gt; <br>&gt;&gt; $ swift package unpin ( [--all] | [&lt;package-name&gt;] )<br>&gt;&gt; This is the counterpart to the pin command, and unpins one or all packages.<br>&gt;&gt; <br>&gt;&gt; We will fetch and resolve the dependencies when running the pin commands, in case we don&#39;t have the complete dependency graph yet.<br>&gt;&gt; <br>&gt;&gt; We will extend the workflow for update to honour version pinning, that is, it will only update packages which are unpinned, and it will only update to versions which can satisfy the existing pins. The update command will, however, also take an optional argument --repin:<br>&gt;&gt; <br>&gt;&gt; $ swift package update [--repin]<br>&gt;&gt; Update command errors if there are no unpinned packages which can be updated.<br>&gt;&gt; <br>&gt;&gt; Otherwise, the behaviour is to update all unpinned packages to the latest possible versions which can be resolved while respecting the existing pins.<br>&gt;&gt; <br>&gt;&gt; The [--repin] argument can be used to lift the version pinning restrictions. In this case, the behaviour is that all packages are updated, and packages which were previously pinned are then repinned to the latest resolved versions.<br>&gt;&gt; <br>&gt;&gt; The update and checkout will both emit logs, notifying the user that pinning is in effect.<br>&gt;&gt; <br>&gt;&gt; The swift package show-dependencies subcommand will be updated to indicate if a dependency is pinned.<br>&gt;&gt; <br>&gt;&gt; As a future extension, we anticipate using the SHA information recorded in a pins file as a security feature, to prevent man-in-the-middle attacks on parts of the package graph.<br>&gt;&gt; <br>&gt;&gt; Impact on existing code<br>&gt;&gt; There will be change in the behaviours of swift build and swift package update in presence of the pins file, as noted in the proposal however the existing package will continue to build without any modifications.<br>&gt;&gt; <br>&gt;&gt; Alternative considered<br>&gt;&gt; We considered making the pinning behavior default on running swift build, however we think that pinning by default is likely to make the package graph more constrained than it should be. It drives the user away from taking full advantage of semantic versioning. We think it will be good for the package ecosystem if such a restriction is not the default behavior and that this design will lead to faster discovery of bugs and fixes in the upstream.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-build-dev mailing list<br>&gt;&gt; swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-build-dev mailing list<br>&gt; swift-build-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20161014/62de63c7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d9baa679148bd83458d11df12327ce0?s=50"></div><header><strong>Proposal: Package Manager Version Pinning</strong> from <string>Daniel Dunbar</string> &lt;daniel_dunbar at apple.com&gt;<p>October 14, 2016 at 09:00:00am</p></header><div class="content"><p>Can you check my reply to Eloy and see how it weighs with you?<br></p><p> - Daniel<br></p><p>&gt; On Oct 14, 2016, at 9:33 AM, Max Desiatov via swift-build-dev &lt;swift-build-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; I also strongly agree with this, I&#39;d prefer version pinning to happen by default, rather than with explicit command as it will make builds reproducible by default. <br>&gt; <br>&gt; I totally agree that we can rely on past experience with other package managers (npm being the case), where pinning with a separate command caused more harm than good.<br>&gt; <br>&gt; Overall, I think that it would be great if Package.lock was created by default when it&#39;s not present and be updated only with an explicit command for updating.<br>&gt; <br>&gt; With best regards, Max.<br>&gt; <br>&gt; <br>&gt;&gt; On 14 Oct 2016, at 08:29, orta therox via swift-build-dev &lt;swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Please don’t make this a separate command, it should ideally be created at the end of an build (when there isn’t one already) or an update of your dependencies - most people will be expecting to get the same set of dependencies as the rest of their team. This pattern makes that harder.<br>&gt;&gt; <br>&gt;&gt; NPM shrinkwrap is an example of this, and it’s a bad one - I’ve wasted a lot of time trying to keep that up to date for our npm projects. Facebook made a replacement for NPM with mainly the  feature of “always locking” in yarn &lt;https://yarnpkg.com/&gt; and I’d expect that to take a lot of the JS mindshare on this one feature alone.<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; <br>&gt;&gt; [A.]	    Orta Therox<br>&gt;&gt; <br>&gt;&gt;&gt; w/ Artsy &lt;http://artsy.net/&gt;CocoaPods &lt;http://cocoapods.org/&gt; / CocoaDocs &lt;http://cocoadocs.org/&gt; / GIFs.app &lt;https://itunes.apple.com/us/app/gifs/id961850017?l=en&amp;mt=12&gt;<br>&gt;&gt;&gt; @orta &lt;http://twitter.com/orta&gt; / orta.github.com &lt;http://orta.github.com/&gt;<br>&gt;&gt;&gt; Artsy is totally hiring iOS Devs &lt;https://artsy.net/job/mobile-engineer&gt; ATM<br>&gt;&gt; <br>&gt;&gt;&gt; On 14 Oct 2016, at 07:01, Ankit Aggarwal via swift-build-dev &lt;swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We&#39;re proposing version pinning feature in Swift Package Manager. The proposal is available here &lt;https://github.com/aciidb0mb3r/swift-evolution/blob/version-pinning/proposals/NNNN-Version-Pinning.md&gt; and also in this email:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Feedback welcomed!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt; Ankit<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; --------<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Package Manager Version Pinning<br>&gt;&gt;&gt; Proposal: SE-XXXX<br>&gt;&gt;&gt; Author: Daniel Dunbar &lt;https://github.com/ddunbar&gt;, Ankit Aggarwal &lt;https://github.com/aciidb0mb3r&gt;<br>&gt;&gt;&gt; Review Manager: TBD<br>&gt;&gt;&gt; Status: Discussion<br>&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt; This is a proposal for adding package manager features to &quot;pin&quot; or &quot;lock&quot; package dependencies to particular versions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt; As used in this proposal, version pinning refers to the practice of controlling exactly which specific version of a dependency is selected by the dependency resolution algorithm, independent from the semantic versioning specification. Thus, it is a way of instructing the package manager to select a particular version from among all of the versions of a package which could be chosen while honoring the dependency constraints.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Terminology<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We have chosen to use &quot;pinning&quot; to refer to this feature, over &quot;lockfiles&quot;, since the term &quot;lock&quot; is already overloaded between POSIX file locks and locks in concurrent programming.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Philosophy<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Our philosophy with regard to pinning is that we actively want to encourage packages to develop against the latest semantically appropriate versions of their dependencies, in order to foster rapid development amongst the ecosystem and strong reliance on the semantic versioning concept. Our design for version pinning is thus intended to be a feature for package authors and users to use in crafting specific workflows, not be a mechanism by which most of the packages in the ecosystem pin themselves to specific versions of each other.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Use Cases<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Our proposal is designed to satisfy several different use cases for such a behavior:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Standardizing team workflows<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When collaborating on a package, it can be valuable for team members (and continuous integration) to all know they are using the same exact version of dependencies, to avoid &quot;works for me&quot; situations.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This can be particularly important for certain kinds of open source projects which are actively being cloned by new users, and which want to have some measure of control around exactly which available version of a dependency is selected.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Difficult to test packages or dependencies<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Complex packages which have dependencies which may be hard to test, or hard to analyze when they break, may choose to maintain careful control over what versions of their upstream dependencies they recommend -- even if conceptually they regularly update those recommendations following the true semantic version specification of the dependency.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Dependency locking w.r.t. deployment<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When stabilizing a release for deployment, or building a version of a package for deployment, it is important to be able to lock down the exact versions of dependencies in use, so that the resulting product can be exactly recreated later if necessary.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt; We will introduce support for an optional new file Package.pins adjacent to the Package.swift manifest, called the &quot;pins file&quot;. We will also introduce a number of new commands (see below) for maintaining the pins file.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This file will record the active version pin information for the package, including data such as the package identifier, the pinned version, and explicit information on the pinned version (e.g., the commit hash/SHA for the resolved tag).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The exact file format is unspecified/implementation defined, however, in practice it will be a JSON data file.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This file may be checked into SCM by the user, so that its effects apply to all users of the package. However, it may also be maintained only locally (e.g., placed in the .gitignore file). We intend to leave it to package authors to decide which use case is best for their project.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In the presence of a Package.pins file, the package manager will respect the pinned dependencies recorded in the file whenever it needs to do dependency resolution (e.g., on the initial checkout or when updating).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The pins file will not override Manifest specified version requirements and it will be an error (with proper diagnostics) if there is a conflict between the pins and the manifest specification.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Detailed Design<br>&gt;&gt;&gt; We will add a new command pin to swift package tool with following semantics:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; $ swift package pin ( [--all] | [&lt;package-name&gt;] [&lt;version&gt;] ) [--message &lt;message&gt;]<br>&gt;&gt;&gt; The package-name refers to the name of the package as specified in its manifest.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This command pins one or all dependencies. The command which pins a single version can optionally take a specific version to pin to, if unspecified (or with --all) the behaviour is to pin to the current package version in use. Examples: <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; $ swift package pin --all - pins all the dependencies.<br>&gt;&gt;&gt; $ swift package pin Foo - pins Foo at current resolved version.<br>&gt;&gt;&gt; $ swift package pin Foo 1.2.3 - pins Foo at 1.2.3. The specified version should be valid and resolvable.<br>&gt;&gt;&gt; The --reason option is an optional argument to document the reason for pinning a dependency. This could be helpful for user to later remember why a dependency was pinned. Example: <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; $ swift package pin Foo --reason &quot;The patch updates for Foo are really unstable and need screening.&quot;<br>&gt;&gt;&gt; Dependencies are never automatically pinned, pinning is only ever taken as a result of an explicit user action.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We will add a new command unpin:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; $ swift package unpin ( [--all] | [&lt;package-name&gt;] )<br>&gt;&gt;&gt; This is the counterpart to the pin command, and unpins one or all packages.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We will fetch and resolve the dependencies when running the pin commands, in case we don&#39;t have the complete dependency graph yet.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We will extend the workflow for update to honour version pinning, that is, it will only update packages which are unpinned, and it will only update to versions which can satisfy the existing pins. The update command will, however, also take an optional argument --repin:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; $ swift package update [--repin]<br>&gt;&gt;&gt; Update command errors if there are no unpinned packages which can be updated.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Otherwise, the behaviour is to update all unpinned packages to the latest possible versions which can be resolved while respecting the existing pins.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The [--repin] argument can be used to lift the version pinning restrictions. In this case, the behaviour is that all packages are updated, and packages which were previously pinned are then repinned to the latest resolved versions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The update and checkout will both emit logs, notifying the user that pinning is in effect.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The swift package show-dependencies subcommand will be updated to indicate if a dependency is pinned.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As a future extension, we anticipate using the SHA information recorded in a pins file as a security feature, to prevent man-in-the-middle attacks on parts of the package graph.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt; There will be change in the behaviours of swift build and swift package update in presence of the pins file, as noted in the proposal however the existing package will continue to build without any modifications.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alternative considered<br>&gt;&gt;&gt; We considered making the pinning behavior default on running swift build, however we think that pinning by default is likely to make the package graph more constrained than it should be. It drives the user away from taking full advantage of semantic versioning. We think it will be good for the package ecosystem if such a restriction is not the default behavior and that this design will lead to faster discovery of bugs and fixes in the upstream.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-build-dev mailing list<br>&gt;&gt;&gt; swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev &lt;https://lists.swift.org/mailman/listinfo/swift-build-dev&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-build-dev mailing list<br>&gt;&gt; swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-build-dev mailing list<br>&gt; swift-build-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20161014/a16c07cb/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f116cb3be23153ec08b94e8bd4dbcfeb?s=50"></div><header><strong>Proposal: Package Manager Version Pinning</strong> from <string>orta therox</string> &lt;orta.therox at gmail.com&gt;<p>October 14, 2016 at 06:00:00pm</p></header><div class="content"><p>Afraid it doesn’t convince me. Even if you have an index that has strict semver adherence, the idea that you can trust people / machines to actually understand whether something will break other people&#39;s build seems unreasonable. Updates to code ships bugs. Updates you don’t expect gives you bugs you didn’t expect.<br></p><p>Alexis hits it on the head with the differentiation between a library and an app - libraries should define their own supported ranges, and they require far less locking than applications. An application should always have a lock so you have determinate builds and can update dependencies on purpose.<br></p><p>&gt; We generally agree that when you are simply the consumer of packages, pinning makes sense.<br></p><p>Isn’t this going to be the majority of the behaviour for the tool on the long run? So I would expect that to be where locking happens.<br></p><p>Sidenote: FWIW not a fan of the name change from lockfile - it feels arbitrary, but I figured the change to a separate command was a bigger elephant in the room.<br></p><p>-- <br></p><p>[A.]	    Orta Therox<br></p><p>&gt; w/ Artsy &lt;http://artsy.net/&gt;CocoaPods &lt;http://cocoapods.org/&gt; / CocoaDocs &lt;http://cocoadocs.org/&gt; / GIFs.app &lt;https://itunes.apple.com/us/app/gifs/id961850017?l=en&amp;mt=12&gt;<br>&gt; @orta &lt;http://twitter.com/orta&gt; / orta.github.com &lt;http://orta.github.com/&gt;<br>&gt; On 14 Oct 2016, at 17:43, Daniel Dunbar &lt;daniel_dunbar at apple.com&gt; wrote:<br>&gt; <br>&gt; Can you check my reply to Eloy and see how it weighs with you?<br>&gt; <br>&gt;  - Daniel<br>&gt; <br>&gt;&gt; On Oct 14, 2016, at 9:33 AM, Max Desiatov via swift-build-dev &lt;swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I also strongly agree with this, I&#39;d prefer version pinning to happen by default, rather than with explicit command as it will make builds reproducible by default. <br>&gt;&gt; <br>&gt;&gt; I totally agree that we can rely on past experience with other package managers (npm being the case), where pinning with a separate command caused more harm than good.<br>&gt;&gt; <br>&gt;&gt; Overall, I think that it would be great if Package.lock was created by default when it&#39;s not present and be updated only with an explicit command for updating.<br>&gt;&gt; <br>&gt;&gt; With best regards, Max.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 14 Oct 2016, at 08:29, orta therox via swift-build-dev &lt;swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Please don’t make this a separate command, it should ideally be created at the end of an build (when there isn’t one already) or an update of your dependencies - most people will be expecting to get the same set of dependencies as the rest of their team. This pattern makes that harder.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; NPM shrinkwrap is an example of this, and it’s a bad one - I’ve wasted a lot of time trying to keep that up to date for our npm projects. Facebook made a replacement for NPM with mainly the  feature of “always locking” in yarn &lt;https://yarnpkg.com/&gt; and I’d expect that to take a lot of the JS mindshare on this one feature alone.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; [A.]	    Orta Therox<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; w/ Artsy &lt;http://artsy.net/&gt;CocoaPods &lt;http://cocoapods.org/&gt; / CocoaDocs &lt;http://cocoadocs.org/&gt; / GIFs.app &lt;https://itunes.apple.com/us/app/gifs/id961850017?l=en&amp;mt=12&gt;<br>&gt;&gt;&gt;&gt; @orta &lt;http://twitter.com/orta&gt; / orta.github.com &lt;http://orta.github.com/&gt;<br>&gt;&gt;&gt;&gt; Artsy is totally hiring iOS Devs &lt;https://artsy.net/job/mobile-engineer&gt; ATM<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 14 Oct 2016, at 07:01, Ankit Aggarwal via swift-build-dev &lt;swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We&#39;re proposing version pinning feature in Swift Package Manager. The proposal is available here &lt;https://github.com/aciidb0mb3r/swift-evolution/blob/version-pinning/proposals/NNNN-Version-Pinning.md&gt; and also in this email:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Feedback welcomed!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt; Ankit<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; --------<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Package Manager Version Pinning<br>&gt;&gt;&gt;&gt; Proposal: SE-XXXX<br>&gt;&gt;&gt;&gt; Author: Daniel Dunbar &lt;https://github.com/ddunbar&gt;, Ankit Aggarwal &lt;https://github.com/aciidb0mb3r&gt;<br>&gt;&gt;&gt;&gt; Review Manager: TBD<br>&gt;&gt;&gt;&gt; Status: Discussion<br>&gt;&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;&gt; This is a proposal for adding package manager features to &quot;pin&quot; or &quot;lock&quot; package dependencies to particular versions.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;&gt; As used in this proposal, version pinning refers to the practice of controlling exactly which specific version of a dependency is selected by the dependency resolution algorithm, independent from the semantic versioning specification. Thus, it is a way of instructing the package manager to select a particular version from among all of the versions of a package which could be chosen while honoring the dependency constraints.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Terminology<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We have chosen to use &quot;pinning&quot; to refer to this feature, over &quot;lockfiles&quot;, since the term &quot;lock&quot; is already overloaded between POSIX file locks and locks in concurrent programming.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Philosophy<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Our philosophy with regard to pinning is that we actively want to encourage packages to develop against the latest semantically appropriate versions of their dependencies, in order to foster rapid development amongst the ecosystem and strong reliance on the semantic versioning concept. Our design for version pinning is thus intended to be a feature for package authors and users to use in crafting specific workflows, not be a mechanism by which most of the packages in the ecosystem pin themselves to specific versions of each other.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Use Cases<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Our proposal is designed to satisfy several different use cases for such a behavior:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Standardizing team workflows<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; When collaborating on a package, it can be valuable for team members (and continuous integration) to all know they are using the same exact version of dependencies, to avoid &quot;works for me&quot; situations.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This can be particularly important for certain kinds of open source projects which are actively being cloned by new users, and which want to have some measure of control around exactly which available version of a dependency is selected.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Difficult to test packages or dependencies<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Complex packages which have dependencies which may be hard to test, or hard to analyze when they break, may choose to maintain careful control over what versions of their upstream dependencies they recommend -- even if conceptually they regularly update those recommendations following the true semantic version specification of the dependency.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Dependency locking w.r.t. deployment<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; When stabilizing a release for deployment, or building a version of a package for deployment, it is important to be able to lock down the exact versions of dependencies in use, so that the resulting product can be exactly recreated later if necessary.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt;&gt; We will introduce support for an optional new file Package.pins adjacent to the Package.swift manifest, called the &quot;pins file&quot;. We will also introduce a number of new commands (see below) for maintaining the pins file.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This file will record the active version pin information for the package, including data such as the package identifier, the pinned version, and explicit information on the pinned version (e.g., the commit hash/SHA for the resolved tag).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The exact file format is unspecified/implementation defined, however, in practice it will be a JSON data file.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This file may be checked into SCM by the user, so that its effects apply to all users of the package. However, it may also be maintained only locally (e.g., placed in the .gitignore file). We intend to leave it to package authors to decide which use case is best for their project.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In the presence of a Package.pins file, the package manager will respect the pinned dependencies recorded in the file whenever it needs to do dependency resolution (e.g., on the initial checkout or when updating).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The pins file will not override Manifest specified version requirements and it will be an error (with proper diagnostics) if there is a conflict between the pins and the manifest specification.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Detailed Design<br>&gt;&gt;&gt;&gt; We will add a new command pin to swift package tool with following semantics:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; $ swift package pin ( [--all] | [&lt;package-name&gt;] [&lt;version&gt;] ) [--message &lt;message&gt;]<br>&gt;&gt;&gt;&gt; The package-name refers to the name of the package as specified in its manifest.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This command pins one or all dependencies. The command which pins a single version can optionally take a specific version to pin to, if unspecified (or with --all) the behaviour is to pin to the current package version in use. Examples: <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; $ swift package pin --all - pins all the dependencies.<br>&gt;&gt;&gt;&gt; $ swift package pin Foo - pins Foo at current resolved version.<br>&gt;&gt;&gt;&gt; $ swift package pin Foo 1.2.3 - pins Foo at 1.2.3. The specified version should be valid and resolvable.<br>&gt;&gt;&gt;&gt; The --reason option is an optional argument to document the reason for pinning a dependency. This could be helpful for user to later remember why a dependency was pinned. Example: <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; $ swift package pin Foo --reason &quot;The patch updates for Foo are really unstable and need screening.&quot;<br>&gt;&gt;&gt;&gt; Dependencies are never automatically pinned, pinning is only ever taken as a result of an explicit user action.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We will add a new command unpin:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; $ swift package unpin ( [--all] | [&lt;package-name&gt;] )<br>&gt;&gt;&gt;&gt; This is the counterpart to the pin command, and unpins one or all packages.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We will fetch and resolve the dependencies when running the pin commands, in case we don&#39;t have the complete dependency graph yet.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We will extend the workflow for update to honour version pinning, that is, it will only update packages which are unpinned, and it will only update to versions which can satisfy the existing pins. The update command will, however, also take an optional argument --repin:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; $ swift package update [--repin]<br>&gt;&gt;&gt;&gt; Update command errors if there are no unpinned packages which can be updated.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Otherwise, the behaviour is to update all unpinned packages to the latest possible versions which can be resolved while respecting the existing pins.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The [--repin] argument can be used to lift the version pinning restrictions. In this case, the behaviour is that all packages are updated, and packages which were previously pinned are then repinned to the latest resolved versions.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The update and checkout will both emit logs, notifying the user that pinning is in effect.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The swift package show-dependencies subcommand will be updated to indicate if a dependency is pinned.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As a future extension, we anticipate using the SHA information recorded in a pins file as a security feature, to prevent man-in-the-middle attacks on parts of the package graph.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt;&gt; There will be change in the behaviours of swift build and swift package update in presence of the pins file, as noted in the proposal however the existing package will continue to build without any modifications.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Alternative considered<br>&gt;&gt;&gt;&gt; We considered making the pinning behavior default on running swift build, however we think that pinning by default is likely to make the package graph more constrained than it should be. It drives the user away from taking full advantage of semantic versioning. We think it will be good for the package ecosystem if such a restriction is not the default behavior and that this design will lead to faster discovery of bugs and fixes in the upstream.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-build-dev mailing list<br>&gt;&gt;&gt;&gt; swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev &lt;https://lists.swift.org/mailman/listinfo/swift-build-dev&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-build-dev mailing list<br>&gt;&gt;&gt; swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev &lt;https://lists.swift.org/mailman/listinfo/swift-build-dev&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-build-dev mailing list<br>&gt;&gt; swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20161014/a1b427b6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d9baa679148bd83458d11df12327ce0?s=50"></div><header><strong>Proposal: Package Manager Version Pinning</strong> from <string>Daniel Dunbar</string> &lt;daniel_dunbar at apple.com&gt;<p>October 14, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Oct 14, 2016, at 10:13 AM, orta therox &lt;orta.therox at gmail.com&gt; wrote:<br>&gt; <br>&gt; Afraid it doesn’t convince me. Even if you have an index that has strict semver adherence, the idea that you can trust people / machines to actually understand whether something will break other people&#39;s build seems unreasonable. Updates to code ships bugs. Updates you don’t expect gives you bugs you didn’t expect<br></p><p>Updates you don&#39;t expect can also fix bugs you didn&#39;t find (or found but hadn&#39;t diagnosed). I&#39;m not sure it is a one way street.<br></p><p>I completely agree with you here though, you can&#39;t trust the tooling. However, we also have the ability to test things via running actual tests against downstream dependencies. The combination of those two may be quite powerful, even if the latter is naturally resource constrained.<br></p><p>&gt; Alexis hits it on the head with the differentiation between a library and an app - libraries should define their own supported ranges, and they require far less locking than applications. An application should always have a lock so you have determinate builds and can update dependencies on purpose.<br></p><p>Yup, we agree here. I&#39;ll reply to this on Alexis&#39;s post.<br></p><p>&gt; &gt; We generally agree that when you are simply the consumer of packages, pinning makes sense.<br>&gt; <br>&gt; Isn’t this going to be the majority of the behaviour for the tool on the long run? So I would expect that to be where locking happens.<br></p><p>I don&#39;t think so.<br></p><p>Consider the Xcode use case, for example: we are not actively planning on adding support for all the myriad kinds of top-level targets and app needs, so the packages used in that context will by nature be a package which was shared.<br></p><p>&gt; Sidenote: FWIW not a fan of the name change from lockfile - it feels arbitrary, but I figured the change to a separate command was a bigger elephant in the room.<br></p><p>I agree keeping them in separate threads is handy. I&#39;ll reply to this on Max&#39;s post.<br></p><p> - Daniel<br></p><p>&gt; <br>&gt; -- <br>&gt; <br>&gt; [A.]	    Orta Therox<br>&gt; <br>&gt;&gt; w/ Artsy &lt;http://artsy.net/&gt;CocoaPods &lt;http://cocoapods.org/&gt; / CocoaDocs &lt;http://cocoadocs.org/&gt; / GIFs.app &lt;https://itunes.apple.com/us/app/gifs/id961850017?l=en&amp;mt=12&gt;<br>&gt;&gt; @orta &lt;http://twitter.com/orta&gt; / orta.github.com &lt;http://orta.github.com/&gt;<br>&gt;&gt; On 14 Oct 2016, at 17:43, Daniel Dunbar &lt;daniel_dunbar at apple.com &lt;mailto:daniel_dunbar at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Can you check my reply to Eloy and see how it weighs with you?<br>&gt;&gt; <br>&gt;&gt;  - Daniel<br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 14, 2016, at 9:33 AM, Max Desiatov via swift-build-dev &lt;swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I also strongly agree with this, I&#39;d prefer version pinning to happen by default, rather than with explicit command as it will make builds reproducible by default. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I totally agree that we can rely on past experience with other package managers (npm being the case), where pinning with a separate command caused more harm than good.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Overall, I think that it would be great if Package.lock was created by default when it&#39;s not present and be updated only with an explicit command for updating.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; With best regards, Max.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 14 Oct 2016, at 08:29, orta therox via swift-build-dev &lt;swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Please don’t make this a separate command, it should ideally be created at the end of an build (when there isn’t one already) or an update of your dependencies - most people will be expecting to get the same set of dependencies as the rest of their team. This pattern makes that harder.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; NPM shrinkwrap is an example of this, and it’s a bad one - I’ve wasted a lot of time trying to keep that up to date for our npm projects. Facebook made a replacement for NPM with mainly the  feature of “always locking” in yarn &lt;https://yarnpkg.com/&gt; and I’d expect that to take a lot of the JS mindshare on this one feature alone.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; [A.]	    Orta Therox<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; w/ Artsy &lt;http://artsy.net/&gt;CocoaPods &lt;http://cocoapods.org/&gt; / CocoaDocs &lt;http://cocoadocs.org/&gt; / GIFs.app &lt;https://itunes.apple.com/us/app/gifs/id961850017?l=en&amp;mt=12&gt;<br>&gt;&gt;&gt;&gt;&gt; @orta &lt;http://twitter.com/orta&gt; / orta.github.com &lt;http://orta.github.com/&gt;<br>&gt;&gt;&gt;&gt;&gt; Artsy is totally hiring iOS Devs &lt;https://artsy.net/job/mobile-engineer&gt; ATM<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 14 Oct 2016, at 07:01, Ankit Aggarwal via swift-build-dev &lt;swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; We&#39;re proposing version pinning feature in Swift Package Manager. The proposal is available here &lt;https://github.com/aciidb0mb3r/swift-evolution/blob/version-pinning/proposals/NNNN-Version-Pinning.md&gt; and also in this email:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Feedback welcomed!<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt; Ankit<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; --------<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Package Manager Version Pinning<br>&gt;&gt;&gt;&gt;&gt; Proposal: SE-XXXX<br>&gt;&gt;&gt;&gt;&gt; Author: Daniel Dunbar &lt;https://github.com/ddunbar&gt;, Ankit Aggarwal &lt;https://github.com/aciidb0mb3r&gt;<br>&gt;&gt;&gt;&gt;&gt; Review Manager: TBD<br>&gt;&gt;&gt;&gt;&gt; Status: Discussion<br>&gt;&gt;&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;&gt;&gt; This is a proposal for adding package manager features to &quot;pin&quot; or &quot;lock&quot; package dependencies to particular versions.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;&gt;&gt; As used in this proposal, version pinning refers to the practice of controlling exactly which specific version of a dependency is selected by the dependency resolution algorithm, independent from the semantic versioning specification. Thus, it is a way of instructing the package manager to select a particular version from among all of the versions of a package which could be chosen while honoring the dependency constraints.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Terminology<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; We have chosen to use &quot;pinning&quot; to refer to this feature, over &quot;lockfiles&quot;, since the term &quot;lock&quot; is already overloaded between POSIX file locks and locks in concurrent programming.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Philosophy<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Our philosophy with regard to pinning is that we actively want to encourage packages to develop against the latest semantically appropriate versions of their dependencies, in order to foster rapid development amongst the ecosystem and strong reliance on the semantic versioning concept. Our design for version pinning is thus intended to be a feature for package authors and users to use in crafting specific workflows, not be a mechanism by which most of the packages in the ecosystem pin themselves to specific versions of each other.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Use Cases<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Our proposal is designed to satisfy several different use cases for such a behavior:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Standardizing team workflows<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; When collaborating on a package, it can be valuable for team members (and continuous integration) to all know they are using the same exact version of dependencies, to avoid &quot;works for me&quot; situations.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This can be particularly important for certain kinds of open source projects which are actively being cloned by new users, and which want to have some measure of control around exactly which available version of a dependency is selected.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Difficult to test packages or dependencies<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Complex packages which have dependencies which may be hard to test, or hard to analyze when they break, may choose to maintain careful control over what versions of their upstream dependencies they recommend -- even if conceptually they regularly update those recommendations following the true semantic version specification of the dependency.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Dependency locking w.r.t. deployment<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; When stabilizing a release for deployment, or building a version of a package for deployment, it is important to be able to lock down the exact versions of dependencies in use, so that the resulting product can be exactly recreated later if necessary.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt;&gt;&gt; We will introduce support for an optional new file Package.pins adjacent to the Package.swift manifest, called the &quot;pins file&quot;. We will also introduce a number of new commands (see below) for maintaining the pins file.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This file will record the active version pin information for the package, including data such as the package identifier, the pinned version, and explicit information on the pinned version (e.g., the commit hash/SHA for the resolved tag).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The exact file format is unspecified/implementation defined, however, in practice it will be a JSON data file.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This file may be checked into SCM by the user, so that its effects apply to all users of the package. However, it may also be maintained only locally (e.g., placed in the .gitignore file). We intend to leave it to package authors to decide which use case is best for their project.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In the presence of a Package.pins file, the package manager will respect the pinned dependencies recorded in the file whenever it needs to do dependency resolution (e.g., on the initial checkout or when updating).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The pins file will not override Manifest specified version requirements and it will be an error (with proper diagnostics) if there is a conflict between the pins and the manifest specification.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Detailed Design<br>&gt;&gt;&gt;&gt;&gt; We will add a new command pin to swift package tool with following semantics:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; $ swift package pin ( [--all] | [&lt;package-name&gt;] [&lt;version&gt;] ) [--message &lt;message&gt;]<br>&gt;&gt;&gt;&gt;&gt; The package-name refers to the name of the package as specified in its manifest.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This command pins one or all dependencies. The command which pins a single version can optionally take a specific version to pin to, if unspecified (or with --all) the behaviour is to pin to the current package version in use. Examples: <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; $ swift package pin --all - pins all the dependencies.<br>&gt;&gt;&gt;&gt;&gt; $ swift package pin Foo - pins Foo at current resolved version.<br>&gt;&gt;&gt;&gt;&gt; $ swift package pin Foo 1.2.3 - pins Foo at 1.2.3. The specified version should be valid and resolvable.<br>&gt;&gt;&gt;&gt;&gt; The --reason option is an optional argument to document the reason for pinning a dependency. This could be helpful for user to later remember why a dependency was pinned. Example: <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; $ swift package pin Foo --reason &quot;The patch updates for Foo are really unstable and need screening.&quot;<br>&gt;&gt;&gt;&gt;&gt; Dependencies are never automatically pinned, pinning is only ever taken as a result of an explicit user action.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; We will add a new command unpin:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; $ swift package unpin ( [--all] | [&lt;package-name&gt;] )<br>&gt;&gt;&gt;&gt;&gt; This is the counterpart to the pin command, and unpins one or all packages.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; We will fetch and resolve the dependencies when running the pin commands, in case we don&#39;t have the complete dependency graph yet.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; We will extend the workflow for update to honour version pinning, that is, it will only update packages which are unpinned, and it will only update to versions which can satisfy the existing pins. The update command will, however, also take an optional argument --repin:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; $ swift package update [--repin]<br>&gt;&gt;&gt;&gt;&gt; Update command errors if there are no unpinned packages which can be updated.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Otherwise, the behaviour is to update all unpinned packages to the latest possible versions which can be resolved while respecting the existing pins.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The [--repin] argument can be used to lift the version pinning restrictions. In this case, the behaviour is that all packages are updated, and packages which were previously pinned are then repinned to the latest resolved versions.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The update and checkout will both emit logs, notifying the user that pinning is in effect.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The swift package show-dependencies subcommand will be updated to indicate if a dependency is pinned.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; As a future extension, we anticipate using the SHA information recorded in a pins file as a security feature, to prevent man-in-the-middle attacks on parts of the package graph.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt;&gt;&gt; There will be change in the behaviours of swift build and swift package update in presence of the pins file, as noted in the proposal however the existing package will continue to build without any modifications.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Alternative considered<br>&gt;&gt;&gt;&gt;&gt; We considered making the pinning behavior default on running swift build, however we think that pinning by default is likely to make the package graph more constrained than it should be. It drives the user away from taking full advantage of semantic versioning. We think it will be good for the package ecosystem if such a restriction is not the default behavior and that this design will lead to faster discovery of bugs and fixes in the upstream.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-build-dev mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev &lt;https://lists.swift.org/mailman/listinfo/swift-build-dev&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-build-dev mailing list<br>&gt;&gt;&gt;&gt; swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev &lt;https://lists.swift.org/mailman/listinfo/swift-build-dev&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-build-dev mailing list<br>&gt;&gt;&gt; swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev &lt;https://lists.swift.org/mailman/listinfo/swift-build-dev&gt;<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20161014/bacb7162/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ad5d998258bab37d23bc9555b0d6c237?s=50"></div><header><strong>Proposal: Package Manager Version Pinning</strong> from <string>Max Desiatov</string> &lt;max.desiatov at gmail.com&gt;<p>October 14, 2016 at 06:00:00pm</p></header><div class="content"><p>Unfortunately, I&#39;m not convinced that semantic versioning would help here. It could have been different if any of the tools in Apple&#39;s ecosystem and other ecosystems emphasized semantic versioning from the start.<br></p><p>I also strongly agree with issues highlighted by Orta, specifically with:<br></p><p>&gt; Updates to code ships bugs. Updates you don’t expect gives you bugs you didn’t expect.<br></p><p>I would prefer the code that compiles on CI to be exactly the same that I run locally without having a need to commit all the dependencies. I also think that it makes sense for this to be the default behaviour.<br></p><p>With best regards, Max.<br></p><p><br>&gt; On 14 Oct 2016, at 17:43, Daniel Dunbar &lt;daniel_dunbar at apple.com&gt; wrote:<br>&gt; <br>&gt; Can you check my reply to Eloy and see how it weighs with you?<br>&gt; <br>&gt;  - Daniel<br>&gt; <br>&gt;&gt; On Oct 14, 2016, at 9:33 AM, Max Desiatov via swift-build-dev &lt;swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I also strongly agree with this, I&#39;d prefer version pinning to happen by default, rather than with explicit command as it will make builds reproducible by default. <br>&gt;&gt; <br>&gt;&gt; I totally agree that we can rely on past experience with other package managers (npm being the case), where pinning with a separate command caused more harm than good.<br>&gt;&gt; <br>&gt;&gt; Overall, I think that it would be great if Package.lock was created by default when it&#39;s not present and be updated only with an explicit command for updating.<br>&gt;&gt; <br>&gt;&gt; With best regards, Max.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 14 Oct 2016, at 08:29, orta therox via swift-build-dev &lt;swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Please don’t make this a separate command, it should ideally be created at the end of an build (when there isn’t one already) or an update of your dependencies - most people will be expecting to get the same set of dependencies as the rest of their team. This pattern makes that harder.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; NPM shrinkwrap is an example of this, and it’s a bad one - I’ve wasted a lot of time trying to keep that up to date for our npm projects. Facebook made a replacement for NPM with mainly the  feature of “always locking” in yarn &lt;https://yarnpkg.com/&gt; and I’d expect that to take a lot of the JS mindshare on this one feature alone.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; [A.]	    Orta Therox<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; w/ Artsy &lt;http://artsy.net/&gt;CocoaPods &lt;http://cocoapods.org/&gt; / CocoaDocs &lt;http://cocoadocs.org/&gt; / GIFs.app &lt;https://itunes.apple.com/us/app/gifs/id961850017?l=en&amp;mt=12&gt;<br>&gt;&gt;&gt;&gt; @orta &lt;http://twitter.com/orta&gt; / orta.github.com &lt;http://orta.github.com/&gt;<br>&gt;&gt;&gt;&gt; Artsy is totally hiring iOS Devs &lt;https://artsy.net/job/mobile-engineer&gt; ATM<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 14 Oct 2016, at 07:01, Ankit Aggarwal via swift-build-dev &lt;swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We&#39;re proposing version pinning feature in Swift Package Manager. The proposal is available here &lt;https://github.com/aciidb0mb3r/swift-evolution/blob/version-pinning/proposals/NNNN-Version-Pinning.md&gt; and also in this email:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Feedback welcomed!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt; Ankit<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; --------<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Package Manager Version Pinning<br>&gt;&gt;&gt;&gt; Proposal: SE-XXXX<br>&gt;&gt;&gt;&gt; Author: Daniel Dunbar &lt;https://github.com/ddunbar&gt;, Ankit Aggarwal &lt;https://github.com/aciidb0mb3r&gt;<br>&gt;&gt;&gt;&gt; Review Manager: TBD<br>&gt;&gt;&gt;&gt; Status: Discussion<br>&gt;&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;&gt; This is a proposal for adding package manager features to &quot;pin&quot; or &quot;lock&quot; package dependencies to particular versions.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;&gt; As used in this proposal, version pinning refers to the practice of controlling exactly which specific version of a dependency is selected by the dependency resolution algorithm, independent from the semantic versioning specification. Thus, it is a way of instructing the package manager to select a particular version from among all of the versions of a package which could be chosen while honoring the dependency constraints.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Terminology<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We have chosen to use &quot;pinning&quot; to refer to this feature, over &quot;lockfiles&quot;, since the term &quot;lock&quot; is already overloaded between POSIX file locks and locks in concurrent programming.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Philosophy<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Our philosophy with regard to pinning is that we actively want to encourage packages to develop against the latest semantically appropriate versions of their dependencies, in order to foster rapid development amongst the ecosystem and strong reliance on the semantic versioning concept. Our design for version pinning is thus intended to be a feature for package authors and users to use in crafting specific workflows, not be a mechanism by which most of the packages in the ecosystem pin themselves to specific versions of each other.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Use Cases<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Our proposal is designed to satisfy several different use cases for such a behavior:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Standardizing team workflows<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; When collaborating on a package, it can be valuable for team members (and continuous integration) to all know they are using the same exact version of dependencies, to avoid &quot;works for me&quot; situations.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This can be particularly important for certain kinds of open source projects which are actively being cloned by new users, and which want to have some measure of control around exactly which available version of a dependency is selected.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Difficult to test packages or dependencies<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Complex packages which have dependencies which may be hard to test, or hard to analyze when they break, may choose to maintain careful control over what versions of their upstream dependencies they recommend -- even if conceptually they regularly update those recommendations following the true semantic version specification of the dependency.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Dependency locking w.r.t. deployment<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; When stabilizing a release for deployment, or building a version of a package for deployment, it is important to be able to lock down the exact versions of dependencies in use, so that the resulting product can be exactly recreated later if necessary.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt;&gt; We will introduce support for an optional new file Package.pins adjacent to the Package.swift manifest, called the &quot;pins file&quot;. We will also introduce a number of new commands (see below) for maintaining the pins file.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This file will record the active version pin information for the package, including data such as the package identifier, the pinned version, and explicit information on the pinned version (e.g., the commit hash/SHA for the resolved tag).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The exact file format is unspecified/implementation defined, however, in practice it will be a JSON data file.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This file may be checked into SCM by the user, so that its effects apply to all users of the package. However, it may also be maintained only locally (e.g., placed in the .gitignore file). We intend to leave it to package authors to decide which use case is best for their project.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In the presence of a Package.pins file, the package manager will respect the pinned dependencies recorded in the file whenever it needs to do dependency resolution (e.g., on the initial checkout or when updating).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The pins file will not override Manifest specified version requirements and it will be an error (with proper diagnostics) if there is a conflict between the pins and the manifest specification.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Detailed Design<br>&gt;&gt;&gt;&gt; We will add a new command pin to swift package tool with following semantics:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; $ swift package pin ( [--all] | [&lt;package-name&gt;] [&lt;version&gt;] ) [--message &lt;message&gt;]<br>&gt;&gt;&gt;&gt; The package-name refers to the name of the package as specified in its manifest.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This command pins one or all dependencies. The command which pins a single version can optionally take a specific version to pin to, if unspecified (or with --all) the behaviour is to pin to the current package version in use. Examples: <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; $ swift package pin --all - pins all the dependencies.<br>&gt;&gt;&gt;&gt; $ swift package pin Foo - pins Foo at current resolved version.<br>&gt;&gt;&gt;&gt; $ swift package pin Foo 1.2.3 - pins Foo at 1.2.3. The specified version should be valid and resolvable.<br>&gt;&gt;&gt;&gt; The --reason option is an optional argument to document the reason for pinning a dependency. This could be helpful for user to later remember why a dependency was pinned. Example: <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; $ swift package pin Foo --reason &quot;The patch updates for Foo are really unstable and need screening.&quot;<br>&gt;&gt;&gt;&gt; Dependencies are never automatically pinned, pinning is only ever taken as a result of an explicit user action.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We will add a new command unpin:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; $ swift package unpin ( [--all] | [&lt;package-name&gt;] )<br>&gt;&gt;&gt;&gt; This is the counterpart to the pin command, and unpins one or all packages.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We will fetch and resolve the dependencies when running the pin commands, in case we don&#39;t have the complete dependency graph yet.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We will extend the workflow for update to honour version pinning, that is, it will only update packages which are unpinned, and it will only update to versions which can satisfy the existing pins. The update command will, however, also take an optional argument --repin:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; $ swift package update [--repin]<br>&gt;&gt;&gt;&gt; Update command errors if there are no unpinned packages which can be updated.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Otherwise, the behaviour is to update all unpinned packages to the latest possible versions which can be resolved while respecting the existing pins.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The [--repin] argument can be used to lift the version pinning restrictions. In this case, the behaviour is that all packages are updated, and packages which were previously pinned are then repinned to the latest resolved versions.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The update and checkout will both emit logs, notifying the user that pinning is in effect.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The swift package show-dependencies subcommand will be updated to indicate if a dependency is pinned.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As a future extension, we anticipate using the SHA information recorded in a pins file as a security feature, to prevent man-in-the-middle attacks on parts of the package graph.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt;&gt; There will be change in the behaviours of swift build and swift package update in presence of the pins file, as noted in the proposal however the existing package will continue to build without any modifications.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Alternative considered<br>&gt;&gt;&gt;&gt; We considered making the pinning behavior default on running swift build, however we think that pinning by default is likely to make the package graph more constrained than it should be. It drives the user away from taking full advantage of semantic versioning. We think it will be good for the package ecosystem if such a restriction is not the default behavior and that this design will lead to faster discovery of bugs and fixes in the upstream.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-build-dev mailing list<br>&gt;&gt;&gt;&gt; swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev &lt;https://lists.swift.org/mailman/listinfo/swift-build-dev&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-build-dev mailing list<br>&gt;&gt;&gt; swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev &lt;https://lists.swift.org/mailman/listinfo/swift-build-dev&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-build-dev mailing list<br>&gt;&gt; swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20161014/54154804/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d9baa679148bd83458d11df12327ce0?s=50"></div><header><strong>Proposal: Package Manager Version Pinning</strong> from <string>Daniel Dunbar</string> &lt;daniel_dunbar at apple.com&gt;<p>October 14, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Oct 14, 2016, at 10:39 AM, Max Desiatov &lt;max.desiatov at gmail.com&gt; wrote:<br>&gt; <br>&gt; Unfortunately, I&#39;m not convinced that semantic versioning would help here. It could have been different if any of the tools in Apple&#39;s ecosystem and other ecosystems emphasized semantic versioning from the start.<br>&gt; <br>&gt; I also strongly agree with issues highlighted by Orta, specifically with:<br>&gt; <br>&gt; &gt; Updates to code ships bugs. Updates you don’t expect gives you bugs you didn’t expect.<br>&gt; <br>&gt; I would prefer the code that compiles on CI to be exactly the same that I run locally without having a need to commit all the dependencies. I also think that it makes sense for this to be the default behavior.<br></p><p>I agree this is true for your app (actually, what I think is ideal for an app is that you have two branches of CI, one for your pinned dependencies and one with them lifted, so you are detecting incoming future regressions ASAP).<br></p><p>This argument doesn&#39;t work for packages being shared, because you don&#39;t control what your dependencies do (unless we choose to inherit pins, which has larger problems).<br></p><p> - Daniel<br></p><p>&gt; <br>&gt; With best regards, Max.<br>&gt; <br>&gt; <br>&gt;&gt; On 14 Oct 2016, at 17:43, Daniel Dunbar &lt;daniel_dunbar at apple.com &lt;mailto:daniel_dunbar at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Can you check my reply to Eloy and see how it weighs with you?<br>&gt;&gt; <br>&gt;&gt;  - Daniel<br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 14, 2016, at 9:33 AM, Max Desiatov via swift-build-dev &lt;swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I also strongly agree with this, I&#39;d prefer version pinning to happen by default, rather than with explicit command as it will make builds reproducible by default. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I totally agree that we can rely on past experience with other package managers (npm being the case), where pinning with a separate command caused more harm than good.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Overall, I think that it would be great if Package.lock was created by default when it&#39;s not present and be updated only with an explicit command for updating.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; With best regards, Max.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 14 Oct 2016, at 08:29, orta therox via swift-build-dev &lt;swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Please don’t make this a separate command, it should ideally be created at the end of an build (when there isn’t one already) or an update of your dependencies - most people will be expecting to get the same set of dependencies as the rest of their team. This pattern makes that harder.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; NPM shrinkwrap is an example of this, and it’s a bad one - I’ve wasted a lot of time trying to keep that up to date for our npm projects. Facebook made a replacement for NPM with mainly the  feature of “always locking” in yarn &lt;https://yarnpkg.com/&gt; and I’d expect that to take a lot of the JS mindshare on this one feature alone.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; [A.]	    Orta Therox<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; w/ Artsy &lt;http://artsy.net/&gt;CocoaPods &lt;http://cocoapods.org/&gt; / CocoaDocs &lt;http://cocoadocs.org/&gt; / GIFs.app &lt;https://itunes.apple.com/us/app/gifs/id961850017?l=en&amp;mt=12&gt;<br>&gt;&gt;&gt;&gt;&gt; @orta &lt;http://twitter.com/orta&gt; / orta.github.com &lt;http://orta.github.com/&gt;<br>&gt;&gt;&gt;&gt;&gt; Artsy is totally hiring iOS Devs &lt;https://artsy.net/job/mobile-engineer&gt; ATM<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 14 Oct 2016, at 07:01, Ankit Aggarwal via swift-build-dev &lt;swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; We&#39;re proposing version pinning feature in Swift Package Manager. The proposal is available here &lt;https://github.com/aciidb0mb3r/swift-evolution/blob/version-pinning/proposals/NNNN-Version-Pinning.md&gt; and also in this email:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Feedback welcomed!<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt; Ankit<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; --------<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Package Manager Version Pinning<br>&gt;&gt;&gt;&gt;&gt; Proposal: SE-XXXX<br>&gt;&gt;&gt;&gt;&gt; Author: Daniel Dunbar &lt;https://github.com/ddunbar&gt;, Ankit Aggarwal &lt;https://github.com/aciidb0mb3r&gt;<br>&gt;&gt;&gt;&gt;&gt; Review Manager: TBD<br>&gt;&gt;&gt;&gt;&gt; Status: Discussion<br>&gt;&gt;&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;&gt;&gt; This is a proposal for adding package manager features to &quot;pin&quot; or &quot;lock&quot; package dependencies to particular versions.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;&gt;&gt; As used in this proposal, version pinning refers to the practice of controlling exactly which specific version of a dependency is selected by the dependency resolution algorithm, independent from the semantic versioning specification. Thus, it is a way of instructing the package manager to select a particular version from among all of the versions of a package which could be chosen while honoring the dependency constraints.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Terminology<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; We have chosen to use &quot;pinning&quot; to refer to this feature, over &quot;lockfiles&quot;, since the term &quot;lock&quot; is already overloaded between POSIX file locks and locks in concurrent programming.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Philosophy<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Our philosophy with regard to pinning is that we actively want to encourage packages to develop against the latest semantically appropriate versions of their dependencies, in order to foster rapid development amongst the ecosystem and strong reliance on the semantic versioning concept. Our design for version pinning is thus intended to be a feature for package authors and users to use in crafting specific workflows, not be a mechanism by which most of the packages in the ecosystem pin themselves to specific versions of each other.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Use Cases<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Our proposal is designed to satisfy several different use cases for such a behavior:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Standardizing team workflows<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; When collaborating on a package, it can be valuable for team members (and continuous integration) to all know they are using the same exact version of dependencies, to avoid &quot;works for me&quot; situations.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This can be particularly important for certain kinds of open source projects which are actively being cloned by new users, and which want to have some measure of control around exactly which available version of a dependency is selected.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Difficult to test packages or dependencies<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Complex packages which have dependencies which may be hard to test, or hard to analyze when they break, may choose to maintain careful control over what versions of their upstream dependencies they recommend -- even if conceptually they regularly update those recommendations following the true semantic version specification of the dependency.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Dependency locking w.r.t. deployment<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; When stabilizing a release for deployment, or building a version of a package for deployment, it is important to be able to lock down the exact versions of dependencies in use, so that the resulting product can be exactly recreated later if necessary.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt;&gt;&gt; We will introduce support for an optional new file Package.pins adjacent to the Package.swift manifest, called the &quot;pins file&quot;. We will also introduce a number of new commands (see below) for maintaining the pins file.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This file will record the active version pin information for the package, including data such as the package identifier, the pinned version, and explicit information on the pinned version (e.g., the commit hash/SHA for the resolved tag).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The exact file format is unspecified/implementation defined, however, in practice it will be a JSON data file.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This file may be checked into SCM by the user, so that its effects apply to all users of the package. However, it may also be maintained only locally (e.g., placed in the .gitignore file). We intend to leave it to package authors to decide which use case is best for their project.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In the presence of a Package.pins file, the package manager will respect the pinned dependencies recorded in the file whenever it needs to do dependency resolution (e.g., on the initial checkout or when updating).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The pins file will not override Manifest specified version requirements and it will be an error (with proper diagnostics) if there is a conflict between the pins and the manifest specification.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Detailed Design<br>&gt;&gt;&gt;&gt;&gt; We will add a new command pin to swift package tool with following semantics:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; $ swift package pin ( [--all] | [&lt;package-name&gt;] [&lt;version&gt;] ) [--message &lt;message&gt;]<br>&gt;&gt;&gt;&gt;&gt; The package-name refers to the name of the package as specified in its manifest.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This command pins one or all dependencies. The command which pins a single version can optionally take a specific version to pin to, if unspecified (or with --all) the behaviour is to pin to the current package version in use. Examples: <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; $ swift package pin --all - pins all the dependencies.<br>&gt;&gt;&gt;&gt;&gt; $ swift package pin Foo - pins Foo at current resolved version.<br>&gt;&gt;&gt;&gt;&gt; $ swift package pin Foo 1.2.3 - pins Foo at 1.2.3. The specified version should be valid and resolvable.<br>&gt;&gt;&gt;&gt;&gt; The --reason option is an optional argument to document the reason for pinning a dependency. This could be helpful for user to later remember why a dependency was pinned. Example: <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; $ swift package pin Foo --reason &quot;The patch updates for Foo are really unstable and need screening.&quot;<br>&gt;&gt;&gt;&gt;&gt; Dependencies are never automatically pinned, pinning is only ever taken as a result of an explicit user action.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; We will add a new command unpin:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; $ swift package unpin ( [--all] | [&lt;package-name&gt;] )<br>&gt;&gt;&gt;&gt;&gt; This is the counterpart to the pin command, and unpins one or all packages.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; We will fetch and resolve the dependencies when running the pin commands, in case we don&#39;t have the complete dependency graph yet.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; We will extend the workflow for update to honour version pinning, that is, it will only update packages which are unpinned, and it will only update to versions which can satisfy the existing pins. The update command will, however, also take an optional argument --repin:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; $ swift package update [--repin]<br>&gt;&gt;&gt;&gt;&gt; Update command errors if there are no unpinned packages which can be updated.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Otherwise, the behaviour is to update all unpinned packages to the latest possible versions which can be resolved while respecting the existing pins.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The [--repin] argument can be used to lift the version pinning restrictions. In this case, the behaviour is that all packages are updated, and packages which were previously pinned are then repinned to the latest resolved versions.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The update and checkout will both emit logs, notifying the user that pinning is in effect.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The swift package show-dependencies subcommand will be updated to indicate if a dependency is pinned.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; As a future extension, we anticipate using the SHA information recorded in a pins file as a security feature, to prevent man-in-the-middle attacks on parts of the package graph.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt;&gt;&gt; There will be change in the behaviours of swift build and swift package update in presence of the pins file, as noted in the proposal however the existing package will continue to build without any modifications.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Alternative considered<br>&gt;&gt;&gt;&gt;&gt; We considered making the pinning behavior default on running swift build, however we think that pinning by default is likely to make the package graph more constrained than it should be. It drives the user away from taking full advantage of semantic versioning. We think it will be good for the package ecosystem if such a restriction is not the default behavior and that this design will lead to faster discovery of bugs and fixes in the upstream.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-build-dev mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev &lt;https://lists.swift.org/mailman/listinfo/swift-build-dev&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-build-dev mailing list<br>&gt;&gt;&gt;&gt; swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev &lt;https://lists.swift.org/mailman/listinfo/swift-build-dev&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-build-dev mailing list<br>&gt;&gt;&gt; swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev &lt;https://lists.swift.org/mailman/listinfo/swift-build-dev&gt;<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20161014/9179e8f0/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f6b7154fd1d6a470d0b521a2e484bffc?s=50"></div><header><strong>[swift-evolution] Proposal: Package Manager Version Pinning</strong> from <string>Daniel Duan</string> &lt;daniel at duan.org&gt;<p>October 13, 2016 at 11:00:00pm</p></header><div class="content"><p>This is a familiar feature among package managers and has been proven useful in practice. Two points regarding the proposed text:<br></p><p>1. “honor” is mis-spelled in “weird queen’s dialect”.<br>2. SHA/man-in-the-middle attack section needs either more detailed explanation/reference materials, or shouldn’t be included at all (assuming when the hash feature gets introduced, there’d be another proposal for it).<br></p><p>Overall strong +1.<br>&gt; On Oct 13, 2016, at 11:01 PM, Ankit Aggarwal via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi,<br>&gt; <br>&gt; We&#39;re proposing version pinning feature in Swift Package Manager. The proposal is available here &lt;https://github.com/aciidb0mb3r/swift-evolution/blob/version-pinning/proposals/NNNN-Version-Pinning.md&gt; and also in this email:<br>&gt; <br>&gt; Feedback welcomed!<br>&gt; <br>&gt; Thanks,<br>&gt; Ankit<br>&gt; <br>&gt; --------<br>&gt; <br>&gt; Package Manager Version Pinning<br>&gt; Proposal: SE-XXXX<br>&gt; Author: Daniel Dunbar &lt;https://github.com/ddunbar&gt;, Ankit Aggarwal &lt;https://github.com/aciidb0mb3r&gt;<br>&gt; Review Manager: TBD<br>&gt; Status: Discussion<br>&gt; Introduction<br>&gt; This is a proposal for adding package manager features to &quot;pin&quot; or &quot;lock&quot; package dependencies to particular versions.<br>&gt; <br>&gt; Motivation<br>&gt; As used in this proposal, version pinning refers to the practice of controlling exactly which specific version of a dependency is selected by the dependency resolution algorithm, independent from the semantic versioning specification. Thus, it is a way of instructing the package manager to select a particular version from among all of the versions of a package which could be chosen while honoring the dependency constraints.<br>&gt; <br>&gt; Terminology<br>&gt; <br>&gt; We have chosen to use &quot;pinning&quot; to refer to this feature, over &quot;lockfiles&quot;, since the term &quot;lock&quot; is already overloaded between POSIX file locks and locks in concurrent programming.<br>&gt; <br>&gt; Philosophy<br>&gt; <br>&gt; Our philosophy with regard to pinning is that we actively want to encourage packages to develop against the latest semantically appropriate versions of their dependencies, in order to foster rapid development amongst the ecosystem and strong reliance on the semantic versioning concept. Our design for version pinning is thus intended to be a feature for package authors and users to use in crafting specific workflows, not be a mechanism by which most of the packages in the ecosystem pin themselves to specific versions of each other.<br>&gt; <br>&gt; Use Cases<br>&gt; <br>&gt; Our proposal is designed to satisfy several different use cases for such a behavior:<br>&gt; <br>&gt; Standardizing team workflows<br>&gt; <br>&gt; When collaborating on a package, it can be valuable for team members (and continuous integration) to all know they are using the same exact version of dependencies, to avoid &quot;works for me&quot; situations.<br>&gt; <br>&gt; This can be particularly important for certain kinds of open source projects which are actively being cloned by new users, and which want to have some measure of control around exactly which available version of a dependency is selected.<br>&gt; <br>&gt; Difficult to test packages or dependencies<br>&gt; <br>&gt; Complex packages which have dependencies which may be hard to test, or hard to analyze when they break, may choose to maintain careful control over what versions of their upstream dependencies they recommend -- even if conceptually they regularly update those recommendations following the true semantic version specification of the dependency.<br>&gt; <br>&gt; Dependency locking w.r.t. deployment<br>&gt; <br>&gt; When stabilizing a release for deployment, or building a version of a package for deployment, it is important to be able to lock down the exact versions of dependencies in use, so that the resulting product can be exactly recreated later if necessary.<br>&gt; <br>&gt; Proposed solution<br>&gt; We will introduce support for an optional new file Package.pins adjacent to the Package.swift manifest, called the &quot;pins file&quot;. We will also introduce a number of new commands (see below) for maintaining the pins file.<br>&gt; <br>&gt; This file will record the active version pin information for the package, including data such as the package identifier, the pinned version, and explicit information on the pinned version (e.g., the commit hash/SHA for the resolved tag).<br>&gt; <br>&gt; The exact file format is unspecified/implementation defined, however, in practice it will be a JSON data file.<br>&gt; <br>&gt; This file may be checked into SCM by the user, so that its effects apply to all users of the package. However, it may also be maintained only locally (e.g., placed in the .gitignore file). We intend to leave it to package authors to decide which use case is best for their project.<br>&gt; <br>&gt; In the presence of a Package.pins file, the package manager will respect the pinned dependencies recorded in the file whenever it needs to do dependency resolution (e.g., on the initial checkout or when updating).<br>&gt; <br>&gt; The pins file will not override Manifest specified version requirements and it will be an error (with proper diagnostics) if there is a conflict between the pins and the manifest specification.<br>&gt; <br>&gt; Detailed Design<br>&gt; We will add a new command pin to swift package tool with following semantics:<br>&gt; <br>&gt; $ swift package pin ( [--all] | [&lt;package-name&gt;] [&lt;version&gt;] ) [--message &lt;message&gt;]<br>&gt; The package-name refers to the name of the package as specified in its manifest.<br>&gt; <br>&gt; This command pins one or all dependencies. The command which pins a single version can optionally take a specific version to pin to, if unspecified (or with --all) the behaviour is to pin to the current package version in use. Examples: <br>&gt; <br>&gt; $ swift package pin --all - pins all the dependencies.<br>&gt; $ swift package pin Foo - pins Foo at current resolved version.<br>&gt; $ swift package pin Foo 1.2.3 - pins Foo at 1.2.3. The specified version should be valid and resolvable.<br>&gt; The --reason option is an optional argument to document the reason for pinning a dependency. This could be helpful for user to later remember why a dependency was pinned. Example: <br>&gt; <br>&gt; $ swift package pin Foo --reason &quot;The patch updates for Foo are really unstable and need screening.&quot;<br>&gt; Dependencies are never automatically pinned, pinning is only ever taken as a result of an explicit user action.<br>&gt; <br>&gt; We will add a new command unpin:<br>&gt; <br>&gt; $ swift package unpin ( [--all] | [&lt;package-name&gt;] )<br>&gt; This is the counterpart to the pin command, and unpins one or all packages.<br>&gt; <br>&gt; We will fetch and resolve the dependencies when running the pin commands, in case we don&#39;t have the complete dependency graph yet.<br>&gt; <br>&gt; We will extend the workflow for update to honour version pinning, that is, it will only update packages which are unpinned, and it will only update to versions which can satisfy the existing pins. The update command will, however, also take an optional argument --repin:<br>&gt; <br>&gt; $ swift package update [--repin]<br>&gt; Update command errors if there are no unpinned packages which can be updated.<br>&gt; <br>&gt; Otherwise, the behaviour is to update all unpinned packages to the latest possible versions which can be resolved while respecting the existing pins.<br>&gt; <br>&gt; The [--repin] argument can be used to lift the version pinning restrictions. In this case, the behaviour is that all packages are updated, and packages which were previously pinned are then repinned to the latest resolved versions.<br>&gt; <br>&gt; The update and checkout will both emit logs, notifying the user that pinning is in effect.<br>&gt; <br>&gt; The swift package show-dependencies subcommand will be updated to indicate if a dependency is pinned.<br>&gt; <br>&gt; As a future extension, we anticipate using the SHA information recorded in a pins file as a security feature, to prevent man-in-the-middle attacks on parts of the package graph.<br>&gt; <br>&gt; Impact on existing code<br>&gt; There will be change in the behaviours of swift build and swift package update in presence of the pins file, as noted in the proposal however the existing package will continue to build without any modifications.<br>&gt; <br>&gt; Alternative considered<br>&gt; We considered making the pinning behavior default on running swift build, however we think that pinning by default is likely to make the package graph more constrained than it should be. It drives the user away from taking full advantage of semantic versioning. We think it will be good for the package ecosystem if such a restriction is not the default behavior and that this design will lead to faster discovery of bugs and fixes in the upstream.<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20161013/51424b16/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[swift-evolution] Proposal: Package Manager Version Pinning</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>October 14, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On 14 Oct 2016, at 07:16, Daniel Duan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; 1. “honor” is mis-spelled in “weird queen’s dialect”.<br></p><p>I&#39;m sorry, but I throw an exception at this; when you say &quot;weird queen&#39;s dialect&quot; do you mean… English? I don&#39;t go around referring to the other variation as &quot;weird can&#39;t spell dialect&quot; (but maybe I should) 😛<br>The u in words like honour is what makes it pronounced like &quot;onner&quot; rather than &quot;hone-ore&quot;, same with colour being &quot;culler&quot; rather than &quot;coal-ore&quot;. Sorry but it really annoys me when people consider the English version of English to be the weird one, as the clue is literally in the name as to which version is correct. This is why it still galls me that the language in macOS is &quot;British English&quot; yet the other one is just &quot;English&quot; rather than &quot;American English&quot; or whatever, it&#39;s a hideous double standard.<br></p><p><br>That aside, I&#39;m a strong +1 for the feature 😉<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[swift-evolution] Proposal: Package Manager Version Pinning</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>October 14, 2016 at 04:00:00pm</p></header><div class="content"><p>Let&#39;s not promote this idea English has comprehensible and easy to refer to pronunciation rules ;). It needs reforming :P, but let&#39;s keep it for English-Evolution ;).<br></p><p>Sent from my iPhone<br></p><p>&gt; On 14 Oct 2016, at 13:42, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 14 Oct 2016, at 07:16, Daniel Duan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; 1. “honor” is mis-spelled in “weird queen’s dialect”.<br>&gt; <br>&gt; I&#39;m sorry, but I throw an exception at this; when you say &quot;weird queen&#39;s dialect&quot; do you mean… English? I don&#39;t go around referring to the other variation as &quot;weird can&#39;t spell dialect&quot; (but maybe I should) 😛<br>&gt; The u in words like honour is what makes it pronounced like &quot;onner&quot; rather than &quot;hone-ore&quot;, same with colour being &quot;culler&quot; rather than &quot;coal-ore&quot;. Sorry but it really annoys me when people consider the English version of English to be the weird one, as the clue is literally in the name as to which version is correct. This is why it still galls me that the language in macOS is &quot;British English&quot; yet the other one is just &quot;English&quot; rather than &quot;American English&quot; or whatever, it&#39;s a hideous double standard.<br>&gt; <br>&gt; <br>&gt; That aside, I&#39;m a strong +1 for the feature 😉<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f6b7154fd1d6a470d0b521a2e484bffc?s=50"></div><header><strong>[swift-evolution] Proposal: Package Manager Version Pinning</strong> from <string>Daniel Duan</string> &lt;daniel at duan.org&gt;<p>October 14, 2016 at 08:00:00am</p></header><div class="content"><p>Fyi, not my idea: https://github.com/apple/swift-evolution/commit/51d93875b25ba122a6417fdc5216ee94c6e7ee9e<br></p><p>Daniel Duan<br>Sent from my iPhone<br></p><p>&gt; On Oct 14, 2016, at 7:14 AM, Goffredo Marocchi &lt;panajev at gmail.com&gt; wrote:<br>&gt; <br>&gt; Let&#39;s not promote this idea English has comprehensible and easy to refer to pronunciation rules ;). It needs reforming :P, but let&#39;s keep it for English-Evolution ;).<br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt;&gt; On 14 Oct 2016, at 13:42, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 14 Oct 2016, at 07:16, Daniel Duan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. “honor” is mis-spelled in “weird queen’s dialect”.<br>&gt;&gt; <br>&gt;&gt; I&#39;m sorry, but I throw an exception at this; when you say &quot;weird queen&#39;s dialect&quot; do you mean… English? I don&#39;t go around referring to the other variation as &quot;weird can&#39;t spell dialect&quot; (but maybe I should) 😛<br>&gt;&gt; The u in words like honour is what makes it pronounced like &quot;onner&quot; rather than &quot;hone-ore&quot;, same with colour being &quot;culler&quot; rather than &quot;coal-ore&quot;. Sorry but it really annoys me when people consider the English version of English to be the weird one, as the clue is literally in the name as to which version is correct. This is why it still galls me that the language in macOS is &quot;British English&quot; yet the other one is just &quot;English&quot; rather than &quot;American English&quot; or whatever, it&#39;s a hideous double standard.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; That aside, I&#39;m a strong +1 for the feature 😉<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20161014/b5a95137/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d9baa679148bd83458d11df12327ce0?s=50"></div><header><strong>[swift-evolution] Proposal: Package Manager Version Pinning</strong> from <string>Daniel Dunbar</string> &lt;daniel_dunbar at apple.com&gt;<p>October 14, 2016 at 09:00:00am</p></header><div class="content"><p>Let&#39;s not change this thread into a discussion of English. :)<br></p><p> - Daniel<br></p><p>&gt; On Oct 14, 2016, at 8:54 AM, Daniel Duan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Fyi, not my idea: https://github.com/apple/swift-evolution/commit/51d93875b25ba122a6417fdc5216ee94c6e7ee9e &lt;https://github.com/apple/swift-evolution/commit/51d93875b25ba122a6417fdc5216ee94c6e7ee9e&gt;<br>&gt; <br>&gt; Daniel Duan<br>&gt; Sent from my iPhone<br>&gt; <br>&gt; On Oct 14, 2016, at 7:14 AM, Goffredo Marocchi &lt;panajev at gmail.com &lt;mailto:panajev at gmail.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Let&#39;s not promote this idea English has comprehensible and easy to refer to pronunciation rules ;). It needs reforming :P, but let&#39;s keep it for English-Evolution ;).<br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt;&gt; On 14 Oct 2016, at 13:42, Haravikk via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 14 Oct 2016, at 07:16, Daniel Duan via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. “honor” is mis-spelled in “weird queen’s dialect”.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m sorry, but I throw an exception at this; when you say &quot;weird queen&#39;s dialect&quot; do you mean… English? I don&#39;t go around referring to the other variation as &quot;weird can&#39;t spell dialect&quot; (but maybe I should) 😛<br>&gt;&gt;&gt; The u in words like honour is what makes it pronounced like &quot;onner&quot; rather than &quot;hone-ore&quot;, same with colour being &quot;culler&quot; rather than &quot;coal-ore&quot;. Sorry but it really annoys me when people consider the English version of English to be the weird one, as the clue is literally in the name as to which version is correct. This is why it still galls me that the language in macOS is &quot;British English&quot; yet the other one is just &quot;English&quot; rather than &quot;American English&quot; or whatever, it&#39;s a hideous double standard.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That aside, I&#39;m a strong +1 for the feature 😉<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20161014/556cef52/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7b2fdba8077c8495b3caa6f36d0928da?s=50"></div><header><strong>[swift-evolution] Proposal: Package Manager Version Pinning</strong> from <string>Marcin Krzyzanowski</string> &lt;marcin.krzyzanowski at gmail.com&gt;<p>October 14, 2016 at 07:00:00pm</p></header><div class="content"><p>Daniel, it&#39;s all right, &quot;There are only two hard things in Computer<br>Science: cache invalidation and *naming things*.&quot;<br></p><p><br>--<br>Marcin<br></p><p>On Fri, Oct 14, 2016 at 6:25 PM, Daniel Dunbar via swift-build-dev &lt;<br>swift-build-dev at swift.org&gt; wrote:<br></p><p>&gt; Let&#39;s not change this thread into a discussion of English. :)<br>&gt;<br>&gt;  - Daniel<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20161014/a0fc2e77/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eb0d0358af1f99d8dc5970844e5b8180?s=50"></div><header><strong>[swift-evolution] Proposal: Package Manager Version Pinning</strong> from <string>Martin Waitz</string> &lt;tali at admingilde.org&gt;<p>November  1, 2016 at 10:00:00am</p></header><div class="content"><p>Hi :)<br></p><p>&gt; Daniel, it&#39;s all right, &quot;There are only two hard things in Computer Science: cache invalidation and naming things.“<br></p><p>That’s true :-).<br></p><p>So I throw another name into the ring: „Package.versions“.<br></p><p>I think the file should be named after what it contains: the versions of all dependencies.<br>This is used to get reproducible builds by always using the same pinned version.<br>But that is how the file is _used_, not what the file _is_.<br></p><p>— Martin<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20161101/e7537c92/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4c198ffcf0853e6011f58fdcdd32a111?s=50"></div><header><strong>Proposal: Package Manager Version Pinning</strong> from <string>Benjamin Spratling</string> &lt;bspratling at mac.com&gt;<p>October 14, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; Let&#39;s not promote this idea English has comprehensible and easy to refer to pronunciation rules ;). It needs reforming :P, but let&#39;s keep it for English-Evolution ;).<br></p><p><br>+1<br>  Can you get me on that list?  I have a long list of bugs to report. :)<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d9baa679148bd83458d11df12327ce0?s=50"></div><header><strong>[swift-evolution] Proposal: Package Manager Version Pinning</strong> from <string>Daniel Dunbar</string> &lt;daniel_dunbar at apple.com&gt;<p>October 14, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Oct 13, 2016, at 11:16 PM, Daniel Duan via swift-build-dev &lt;swift-build-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; This is a familiar feature among package managers and has been proven useful in practice. Two points regarding the proposed text:<br>&gt; <br>&gt; 1. “honor” is mis-spelled in “weird queen’s dialect”.<br>&gt; 2. SHA/man-in-the-middle attack section needs either more detailed explanation/reference materials, or shouldn’t be included at all (assuming when the hash feature gets introduced, there’d be another proposal for it).<br></p><p>I agree this needs more discussion, but given that we aren&#39;t proposing anything here, I feel like it is just a shoutout to an area for future development. What is the harm of having it there?<br></p><p>One of the possible values of having it in is jumpstarting the actual conversation on the topic!<br></p><p> - Daniel<br></p><p>&gt; <br>&gt; Overall strong +1.<br>&gt;&gt; On Oct 13, 2016, at 11:01 PM, Ankit Aggarwal via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi,<br>&gt;&gt; <br>&gt;&gt; We&#39;re proposing version pinning feature in Swift Package Manager. The proposal is available here &lt;https://github.com/aciidb0mb3r/swift-evolution/blob/version-pinning/proposals/NNNN-Version-Pinning.md&gt; and also in this email:<br>&gt;&gt; <br>&gt;&gt; Feedback welcomed!<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; Ankit<br>&gt;&gt; <br>&gt;&gt; --------<br>&gt;&gt; <br>&gt;&gt; Package Manager Version Pinning<br>&gt;&gt; Proposal: SE-XXXX<br>&gt;&gt; Author: Daniel Dunbar &lt;https://github.com/ddunbar&gt;, Ankit Aggarwal &lt;https://github.com/aciidb0mb3r&gt;<br>&gt;&gt; Review Manager: TBD<br>&gt;&gt; Status: Discussion<br>&gt;&gt; Introduction<br>&gt;&gt; This is a proposal for adding package manager features to &quot;pin&quot; or &quot;lock&quot; package dependencies to particular versions.<br>&gt;&gt; <br>&gt;&gt; Motivation<br>&gt;&gt; As used in this proposal, version pinning refers to the practice of controlling exactly which specific version of a dependency is selected by the dependency resolution algorithm, independent from the semantic versioning specification. Thus, it is a way of instructing the package manager to select a particular version from among all of the versions of a package which could be chosen while honoring the dependency constraints.<br>&gt;&gt; <br>&gt;&gt; Terminology<br>&gt;&gt; <br>&gt;&gt; We have chosen to use &quot;pinning&quot; to refer to this feature, over &quot;lockfiles&quot;, since the term &quot;lock&quot; is already overloaded between POSIX file locks and locks in concurrent programming.<br>&gt;&gt; <br>&gt;&gt; Philosophy<br>&gt;&gt; <br>&gt;&gt; Our philosophy with regard to pinning is that we actively want to encourage packages to develop against the latest semantically appropriate versions of their dependencies, in order to foster rapid development amongst the ecosystem and strong reliance on the semantic versioning concept. Our design for version pinning is thus intended to be a feature for package authors and users to use in crafting specific workflows, not be a mechanism by which most of the packages in the ecosystem pin themselves to specific versions of each other.<br>&gt;&gt; <br>&gt;&gt; Use Cases<br>&gt;&gt; <br>&gt;&gt; Our proposal is designed to satisfy several different use cases for such a behavior:<br>&gt;&gt; <br>&gt;&gt; Standardizing team workflows<br>&gt;&gt; <br>&gt;&gt; When collaborating on a package, it can be valuable for team members (and continuous integration) to all know they are using the same exact version of dependencies, to avoid &quot;works for me&quot; situations.<br>&gt;&gt; <br>&gt;&gt; This can be particularly important for certain kinds of open source projects which are actively being cloned by new users, and which want to have some measure of control around exactly which available version of a dependency is selected.<br>&gt;&gt; <br>&gt;&gt; Difficult to test packages or dependencies<br>&gt;&gt; <br>&gt;&gt; Complex packages which have dependencies which may be hard to test, or hard to analyze when they break, may choose to maintain careful control over what versions of their upstream dependencies they recommend -- even if conceptually they regularly update those recommendations following the true semantic version specification of the dependency.<br>&gt;&gt; <br>&gt;&gt; Dependency locking w.r.t. deployment<br>&gt;&gt; <br>&gt;&gt; When stabilizing a release for deployment, or building a version of a package for deployment, it is important to be able to lock down the exact versions of dependencies in use, so that the resulting product can be exactly recreated later if necessary.<br>&gt;&gt; <br>&gt;&gt; Proposed solution<br>&gt;&gt; We will introduce support for an optional new file Package.pins adjacent to the Package.swift manifest, called the &quot;pins file&quot;. We will also introduce a number of new commands (see below) for maintaining the pins file.<br>&gt;&gt; <br>&gt;&gt; This file will record the active version pin information for the package, including data such as the package identifier, the pinned version, and explicit information on the pinned version (e.g., the commit hash/SHA for the resolved tag).<br>&gt;&gt; <br>&gt;&gt; The exact file format is unspecified/implementation defined, however, in practice it will be a JSON data file.<br>&gt;&gt; <br>&gt;&gt; This file may be checked into SCM by the user, so that its effects apply to all users of the package. However, it may also be maintained only locally (e.g., placed in the .gitignore file). We intend to leave it to package authors to decide which use case is best for their project.<br>&gt;&gt; <br>&gt;&gt; In the presence of a Package.pins file, the package manager will respect the pinned dependencies recorded in the file whenever it needs to do dependency resolution (e.g., on the initial checkout or when updating).<br>&gt;&gt; <br>&gt;&gt; The pins file will not override Manifest specified version requirements and it will be an error (with proper diagnostics) if there is a conflict between the pins and the manifest specification.<br>&gt;&gt; <br>&gt;&gt; Detailed Design<br>&gt;&gt; We will add a new command pin to swift package tool with following semantics:<br>&gt;&gt; <br>&gt;&gt; $ swift package pin ( [--all] | [&lt;package-name&gt;] [&lt;version&gt;] ) [--message &lt;message&gt;]<br>&gt;&gt; The package-name refers to the name of the package as specified in its manifest.<br>&gt;&gt; <br>&gt;&gt; This command pins one or all dependencies. The command which pins a single version can optionally take a specific version to pin to, if unspecified (or with --all) the behaviour is to pin to the current package version in use. Examples: <br>&gt;&gt; <br>&gt;&gt; $ swift package pin --all - pins all the dependencies.<br>&gt;&gt; $ swift package pin Foo - pins Foo at current resolved version.<br>&gt;&gt; $ swift package pin Foo 1.2.3 - pins Foo at 1.2.3. The specified version should be valid and resolvable.<br>&gt;&gt; The --reason option is an optional argument to document the reason for pinning a dependency. This could be helpful for user to later remember why a dependency was pinned. Example: <br>&gt;&gt; <br>&gt;&gt; $ swift package pin Foo --reason &quot;The patch updates for Foo are really unstable and need screening.&quot;<br>&gt;&gt; Dependencies are never automatically pinned, pinning is only ever taken as a result of an explicit user action.<br>&gt;&gt; <br>&gt;&gt; We will add a new command unpin:<br>&gt;&gt; <br>&gt;&gt; $ swift package unpin ( [--all] | [&lt;package-name&gt;] )<br>&gt;&gt; This is the counterpart to the pin command, and unpins one or all packages.<br>&gt;&gt; <br>&gt;&gt; We will fetch and resolve the dependencies when running the pin commands, in case we don&#39;t have the complete dependency graph yet.<br>&gt;&gt; <br>&gt;&gt; We will extend the workflow for update to honour version pinning, that is, it will only update packages which are unpinned, and it will only update to versions which can satisfy the existing pins. The update command will, however, also take an optional argument --repin:<br>&gt;&gt; <br>&gt;&gt; $ swift package update [--repin]<br>&gt;&gt; Update command errors if there are no unpinned packages which can be updated.<br>&gt;&gt; <br>&gt;&gt; Otherwise, the behaviour is to update all unpinned packages to the latest possible versions which can be resolved while respecting the existing pins.<br>&gt;&gt; <br>&gt;&gt; The [--repin] argument can be used to lift the version pinning restrictions. In this case, the behaviour is that all packages are updated, and packages which were previously pinned are then repinned to the latest resolved versions.<br>&gt;&gt; <br>&gt;&gt; The update and checkout will both emit logs, notifying the user that pinning is in effect.<br>&gt;&gt; <br>&gt;&gt; The swift package show-dependencies subcommand will be updated to indicate if a dependency is pinned.<br>&gt;&gt; <br>&gt;&gt; As a future extension, we anticipate using the SHA information recorded in a pins file as a security feature, to prevent man-in-the-middle attacks on parts of the package graph.<br>&gt;&gt; <br>&gt;&gt; Impact on existing code<br>&gt;&gt; There will be change in the behaviours of swift build and swift package update in presence of the pins file, as noted in the proposal however the existing package will continue to build without any modifications.<br>&gt;&gt; <br>&gt;&gt; Alternative considered<br>&gt;&gt; We considered making the pinning behavior default on running swift build, however we think that pinning by default is likely to make the package graph more constrained than it should be. It drives the user away from taking full advantage of semantic versioning. We think it will be good for the package ecosystem if such a restriction is not the default behavior and that this design will lead to faster discovery of bugs and fixes in the upstream.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-build-dev mailing list<br>&gt; swift-build-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20161014/7230dc28/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f6b7154fd1d6a470d0b521a2e484bffc?s=50"></div><header><strong>[swift-evolution] Proposal: Package Manager Version Pinning</strong> from <string>Daniel Duan</string> &lt;daniel at duan.org&gt;<p>October 14, 2016 at 09:00:00am</p></header><div class="content"><p>The spelling nitpick should have been on GitHub in retrospect. I wrongly assumed everyone know of our preference for dialect :)<br></p><p>Point 1-7 are all concrete descriptions of features. That&#39;s probably why the SHA point feels out-of-place. Perhaps it deserves its own section.<br></p><p>&gt; On Oct 14, 2016, at 9:26 AM, Daniel Dunbar &lt;daniel_dunbar at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 13, 2016, at 11:16 PM, Daniel Duan via swift-build-dev &lt;swift-build-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This is a familiar feature among package managers and has been proven useful in practice. Two points regarding the proposed text:<br>&gt;&gt; <br>&gt;&gt; 1. “honor” is mis-spelled in “weird queen’s dialect”.<br>&gt;&gt; 2. SHA/man-in-the-middle attack section needs either more detailed explanation/reference materials, or shouldn’t be included at all (assuming when the hash feature gets introduced, there’d be another proposal for it).<br>&gt; <br>&gt; I agree this needs more discussion, but given that we aren&#39;t proposing anything here, I feel like it is just a shoutout to an area for future development. What is the harm of having it there?<br>&gt; <br>&gt; One of the possible values of having it in is jumpstarting the actual conversation on the topic!<br>&gt; <br>&gt;  - Daniel<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Overall strong +1.<br>&gt;&gt;&gt; On Oct 13, 2016, at 11:01 PM, Ankit Aggarwal via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We&#39;re proposing version pinning feature in Swift Package Manager. The proposal is available here and also in this email:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Feedback welcomed!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt; Ankit<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; --------<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Package Manager Version Pinning<br>&gt;&gt;&gt; Proposal: SE-XXXX<br>&gt;&gt;&gt; Author: Daniel Dunbar, Ankit Aggarwal<br>&gt;&gt;&gt; Review Manager: TBD<br>&gt;&gt;&gt; Status: Discussion<br>&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt; This is a proposal for adding package manager features to &quot;pin&quot; or &quot;lock&quot; package dependencies to particular versions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt; As used in this proposal, version pinning refers to the practice of controlling exactly which specific version of a dependency is selected by the dependency resolution algorithm, independent from the semantic versioning specification. Thus, it is a way of instructing the package manager to select a particular version from among all of the versions of a package which could be chosen while honoring the dependency constraints.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Terminology<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We have chosen to use &quot;pinning&quot; to refer to this feature, over &quot;lockfiles&quot;, since the term &quot;lock&quot; is already overloaded between POSIX file locks and locks in concurrent programming.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Philosophy<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Our philosophy with regard to pinning is that we actively want to encourage packages to develop against the latest semantically appropriate versions of their dependencies, in order to foster rapid development amongst the ecosystem and strong reliance on the semantic versioning concept. Our design for version pinning is thus intended to be a feature for package authors and users to use in crafting specific workflows, not be a mechanism by which most of the packages in the ecosystem pin themselves to specific versions of each other.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Use Cases<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Our proposal is designed to satisfy several different use cases for such a behavior:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Standardizing team workflows<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When collaborating on a package, it can be valuable for team members (and continuous integration) to all know they are using the same exact version of dependencies, to avoid &quot;works for me&quot; situations.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This can be particularly important for certain kinds of open source projects which are actively being cloned by new users, and which want to have some measure of control around exactly which available version of a dependency is selected.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Difficult to test packages or dependencies<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Complex packages which have dependencies which may be hard to test, or hard to analyze when they break, may choose to maintain careful control over what versions of their upstream dependencies they recommend -- even if conceptually they regularly update those recommendations following the true semantic version specification of the dependency.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Dependency locking w.r.t. deployment<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When stabilizing a release for deployment, or building a version of a package for deployment, it is important to be able to lock down the exact versions of dependencies in use, so that the resulting product can be exactly recreated later if necessary.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt; We will introduce support for an optional new file Package.pins adjacent to the Package.swift manifest, called the &quot;pins file&quot;. We will also introduce a number of new commands (see below) for maintaining the pins file.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This file will record the active version pin information for the package, including data such as the package identifier, the pinned version, and explicit information on the pinned version (e.g., the commit hash/SHA for the resolved tag).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The exact file format is unspecified/implementation defined, however, in practice it will be a JSON data file.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This file may be checked into SCM by the user, so that its effects apply to all users of the package. However, it may also be maintained only locally (e.g., placed in the .gitignore file). We intend to leave it to package authors to decide which use case is best for their project.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In the presence of a Package.pins file, the package manager will respect the pinned dependencies recorded in the file whenever it needs to do dependency resolution (e.g., on the initial checkout or when updating).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The pins file will not override Manifest specified version requirements and it will be an error (with proper diagnostics) if there is a conflict between the pins and the manifest specification.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Detailed Design<br>&gt;&gt;&gt; We will add a new command pin to swift package tool with following semantics:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; $ swift package pin ( [--all] | [&lt;package-name&gt;] [&lt;version&gt;] ) [--message &lt;message&gt;]<br>&gt;&gt;&gt; The package-name refers to the name of the package as specified in its manifest.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This command pins one or all dependencies. The command which pins a single version can optionally take a specific version to pin to, if unspecified (or with --all) the behaviour is to pin to the current package version in use. Examples: <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; $ swift package pin --all - pins all the dependencies.<br>&gt;&gt;&gt; $ swift package pin Foo - pins Foo at current resolved version.<br>&gt;&gt;&gt; $ swift package pin Foo 1.2.3 - pins Foo at 1.2.3. The specified version should be valid and resolvable.<br>&gt;&gt;&gt; The --reason option is an optional argument to document the reason for pinning a dependency. This could be helpful for user to later remember why a dependency was pinned. Example: <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; $ swift package pin Foo --reason &quot;The patch updates for Foo are really unstable and need screening.&quot;<br>&gt;&gt;&gt; Dependencies are never automatically pinned, pinning is only ever taken as a result of an explicit user action.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We will add a new command unpin:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; $ swift package unpin ( [--all] | [&lt;package-name&gt;] )<br>&gt;&gt;&gt; This is the counterpart to the pin command, and unpins one or all packages.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We will fetch and resolve the dependencies when running the pin commands, in case we don&#39;t have the complete dependency graph yet.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We will extend the workflow for update to honour version pinning, that is, it will only update packages which are unpinned, and it will only update to versions which can satisfy the existing pins. The update command will, however, also take an optional argument --repin:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; $ swift package update [--repin]<br>&gt;&gt;&gt; Update command errors if there are no unpinned packages which can be updated.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Otherwise, the behaviour is to update all unpinned packages to the latest possible versions which can be resolved while respecting the existing pins.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The [--repin] argument can be used to lift the version pinning restrictions. In this case, the behaviour is that all packages are updated, and packages which were previously pinned are then repinned to the latest resolved versions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The update and checkout will both emit logs, notifying the user that pinning is in effect.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The swift package show-dependencies subcommand will be updated to indicate if a dependency is pinned.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As a future extension, we anticipate using the SHA information recorded in a pins file as a security feature, to prevent man-in-the-middle attacks on parts of the package graph.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt; There will be change in the behaviours of swift build and swift package update in presence of the pins file, as noted in the proposal however the existing package will continue to build without any modifications.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alternative considered<br>&gt;&gt;&gt; We considered making the pinning behavior default on running swift build, however we think that pinning by default is likely to make the package graph more constrained than it should be. It drives the user away from taking full advantage of semantic versioning. We think it will be good for the package ecosystem if such a restriction is not the default behavior and that this design will lead to faster discovery of bugs and fixes in the upstream.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-build-dev mailing list<br>&gt;&gt; swift-build-dev at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20161014/b55d7a62/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d9baa679148bd83458d11df12327ce0?s=50"></div><header><strong>[swift-evolution] Proposal: Package Manager Version Pinning</strong> from <string>Daniel Dunbar</string> &lt;daniel_dunbar at apple.com&gt;<p>October 14, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Oct 14, 2016, at 9:35 AM, Daniel Duan &lt;daniel at duan.org&gt; wrote:<br>&gt; <br>&gt; The spelling nitpick should have been on GitHub in retrospect. I wrongly assumed everyone know of our preference for dialect :)<br>&gt; <br>&gt; Point 1-7 are all concrete descriptions of features. That&#39;s probably why the SHA point feels out-of-place. Perhaps it deserves its own section.<br></p><p>Good point, let&#39;s move it to a future directions section or something.<br></p><p> - Daniel<br></p><p>&gt; <br>&gt; On Oct 14, 2016, at 9:26 AM, Daniel Dunbar &lt;daniel_dunbar at apple.com &lt;mailto:daniel_dunbar at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 13, 2016, at 11:16 PM, Daniel Duan via swift-build-dev &lt;swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a familiar feature among package managers and has been proven useful in practice. Two points regarding the proposed text:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. “honor” is mis-spelled in “weird queen’s dialect”.<br>&gt;&gt;&gt; 2. SHA/man-in-the-middle attack section needs either more detailed explanation/reference materials, or shouldn’t be included at all (assuming when the hash feature gets introduced, there’d be another proposal for it).<br>&gt;&gt; <br>&gt;&gt; I agree this needs more discussion, but given that we aren&#39;t proposing anything here, I feel like it is just a shoutout to an area for future development. What is the harm of having it there?<br>&gt;&gt; <br>&gt;&gt; One of the possible values of having it in is jumpstarting the actual conversation on the topic!<br>&gt;&gt; <br>&gt;&gt;  - Daniel<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Overall strong +1.<br>&gt;&gt;&gt;&gt; On Oct 13, 2016, at 11:01 PM, Ankit Aggarwal via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We&#39;re proposing version pinning feature in Swift Package Manager. The proposal is available here &lt;https://github.com/aciidb0mb3r/swift-evolution/blob/version-pinning/proposals/NNNN-Version-Pinning.md&gt; and also in this email:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Feedback welcomed!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt; Ankit<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; --------<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Package Manager Version Pinning<br>&gt;&gt;&gt;&gt; Proposal: SE-XXXX<br>&gt;&gt;&gt;&gt; Author: Daniel Dunbar &lt;https://github.com/ddunbar&gt;, Ankit Aggarwal &lt;https://github.com/aciidb0mb3r&gt;<br>&gt;&gt;&gt;&gt; Review Manager: TBD<br>&gt;&gt;&gt;&gt; Status: Discussion<br>&gt;&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;&gt; This is a proposal for adding package manager features to &quot;pin&quot; or &quot;lock&quot; package dependencies to particular versions.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;&gt; As used in this proposal, version pinning refers to the practice of controlling exactly which specific version of a dependency is selected by the dependency resolution algorithm, independent from the semantic versioning specification. Thus, it is a way of instructing the package manager to select a particular version from among all of the versions of a package which could be chosen while honoring the dependency constraints.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Terminology<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We have chosen to use &quot;pinning&quot; to refer to this feature, over &quot;lockfiles&quot;, since the term &quot;lock&quot; is already overloaded between POSIX file locks and locks in concurrent programming.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Philosophy<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Our philosophy with regard to pinning is that we actively want to encourage packages to develop against the latest semantically appropriate versions of their dependencies, in order to foster rapid development amongst the ecosystem and strong reliance on the semantic versioning concept. Our design for version pinning is thus intended to be a feature for package authors and users to use in crafting specific workflows, not be a mechanism by which most of the packages in the ecosystem pin themselves to specific versions of each other.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Use Cases<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Our proposal is designed to satisfy several different use cases for such a behavior:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Standardizing team workflows<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; When collaborating on a package, it can be valuable for team members (and continuous integration) to all know they are using the same exact version of dependencies, to avoid &quot;works for me&quot; situations.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This can be particularly important for certain kinds of open source projects which are actively being cloned by new users, and which want to have some measure of control around exactly which available version of a dependency is selected.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Difficult to test packages or dependencies<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Complex packages which have dependencies which may be hard to test, or hard to analyze when they break, may choose to maintain careful control over what versions of their upstream dependencies they recommend -- even if conceptually they regularly update those recommendations following the true semantic version specification of the dependency.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Dependency locking w.r.t. deployment<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; When stabilizing a release for deployment, or building a version of a package for deployment, it is important to be able to lock down the exact versions of dependencies in use, so that the resulting product can be exactly recreated later if necessary.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt;&gt; We will introduce support for an optional new file Package.pins adjacent to the Package.swift manifest, called the &quot;pins file&quot;. We will also introduce a number of new commands (see below) for maintaining the pins file.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This file will record the active version pin information for the package, including data such as the package identifier, the pinned version, and explicit information on the pinned version (e.g., the commit hash/SHA for the resolved tag).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The exact file format is unspecified/implementation defined, however, in practice it will be a JSON data file.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This file may be checked into SCM by the user, so that its effects apply to all users of the package. However, it may also be maintained only locally (e.g., placed in the .gitignore file). We intend to leave it to package authors to decide which use case is best for their project.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In the presence of a Package.pins file, the package manager will respect the pinned dependencies recorded in the file whenever it needs to do dependency resolution (e.g., on the initial checkout or when updating).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The pins file will not override Manifest specified version requirements and it will be an error (with proper diagnostics) if there is a conflict between the pins and the manifest specification.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Detailed Design<br>&gt;&gt;&gt;&gt; We will add a new command pin to swift package tool with following semantics:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; $ swift package pin ( [--all] | [&lt;package-name&gt;] [&lt;version&gt;] ) [--message &lt;message&gt;]<br>&gt;&gt;&gt;&gt; The package-name refers to the name of the package as specified in its manifest.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This command pins one or all dependencies. The command which pins a single version can optionally take a specific version to pin to, if unspecified (or with --all) the behaviour is to pin to the current package version in use. Examples: <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; $ swift package pin --all - pins all the dependencies.<br>&gt;&gt;&gt;&gt; $ swift package pin Foo - pins Foo at current resolved version.<br>&gt;&gt;&gt;&gt; $ swift package pin Foo 1.2.3 - pins Foo at 1.2.3. The specified version should be valid and resolvable.<br>&gt;&gt;&gt;&gt; The --reason option is an optional argument to document the reason for pinning a dependency. This could be helpful for user to later remember why a dependency was pinned. Example: <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; $ swift package pin Foo --reason &quot;The patch updates for Foo are really unstable and need screening.&quot;<br>&gt;&gt;&gt;&gt; Dependencies are never automatically pinned, pinning is only ever taken as a result of an explicit user action.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We will add a new command unpin:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; $ swift package unpin ( [--all] | [&lt;package-name&gt;] )<br>&gt;&gt;&gt;&gt; This is the counterpart to the pin command, and unpins one or all packages.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We will fetch and resolve the dependencies when running the pin commands, in case we don&#39;t have the complete dependency graph yet.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We will extend the workflow for update to honour version pinning, that is, it will only update packages which are unpinned, and it will only update to versions which can satisfy the existing pins. The update command will, however, also take an optional argument --repin:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; $ swift package update [--repin]<br>&gt;&gt;&gt;&gt; Update command errors if there are no unpinned packages which can be updated.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Otherwise, the behaviour is to update all unpinned packages to the latest possible versions which can be resolved while respecting the existing pins.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The [--repin] argument can be used to lift the version pinning restrictions. In this case, the behaviour is that all packages are updated, and packages which were previously pinned are then repinned to the latest resolved versions.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The update and checkout will both emit logs, notifying the user that pinning is in effect.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The swift package show-dependencies subcommand will be updated to indicate if a dependency is pinned.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As a future extension, we anticipate using the SHA information recorded in a pins file as a security feature, to prevent man-in-the-middle attacks on parts of the package graph.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt;&gt; There will be change in the behaviours of swift build and swift package update in presence of the pins file, as noted in the proposal however the existing package will continue to build without any modifications.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Alternative considered<br>&gt;&gt;&gt;&gt; We considered making the pinning behavior default on running swift build, however we think that pinning by default is likely to make the package graph more constrained than it should be. It drives the user away from taking full advantage of semantic versioning. We think it will be good for the package ecosystem if such a restriction is not the default behavior and that this design will lead to faster discovery of bugs and fixes in the upstream.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-build-dev mailing list<br>&gt;&gt;&gt; swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev &lt;https://lists.swift.org/mailman/listinfo/swift-build-dev&gt;<br>&gt;&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20161014/1e8e7c58/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6b81089e81d6bb1e14b5adb746725de1?s=50"></div><header><strong>[swift-evolution] Proposal: Package Manager Version Pinning</strong> from <string>Alexis</string> &lt;abeingessner at apple.com&gt;<p>October 14, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Oct 14, 2016, at 2:01 AM, Ankit Aggarwal via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi,<br>&gt; <br>&gt; We&#39;re proposing version pinning feature in Swift Package Manager. The proposal is available here &lt;https://github.com/aciidb0mb3r/swift-evolution/blob/version-pinning/proposals/NNNN-Version-Pinning.md&gt; and also in this email:<br>&gt; <br>&gt; Feedback welcomed!<br>&gt; <br>&gt; Thanks,<br>&gt; Ankit<br>&gt; <br>&gt; --------<br>&gt; <br>&gt; Package Manager Version Pinning<br>&gt; Proposal: SE-XXXX<br>&gt; Author: Daniel Dunbar &lt;https://github.com/ddunbar&gt;, Ankit Aggarwal &lt;https://github.com/aciidb0mb3r&gt;<br>&gt; Review Manager: TBD<br>&gt; Status: Discussion<br>&gt; Introduction<br>&gt; This is a proposal for adding package manager features to &quot;pin&quot; or &quot;lock&quot; package dependencies to particular versions.<br>&gt; <br>&gt; Motivation<br>&gt; As used in this proposal, version pinning refers to the practice of controlling exactly which specific version of a dependency is selected by the dependency resolution algorithm, independent from the semantic versioning specification. Thus, it is a way of instructing the package manager to select a particular version from among all of the versions of a package which could be chosen while honoring the dependency constraints.<br>&gt; <br>&gt; Terminology<br>&gt; <br>&gt; We have chosen to use &quot;pinning&quot; to refer to this feature, over &quot;lockfiles&quot;, since the term &quot;lock&quot; is already overloaded between POSIX file locks and locks in concurrent programming.<br>&gt; <br>I’ve never seen this cause any actual confusion, nor has anyone I know who teaches/develops these sorts of tools. As far as I can tell, the broader programming community is rapidly converging on this as standard terminology:<br></p><p>* Gemfile.lock (Ruby)<br>* Cargo.lock (Rust)<br>* Composer.lock (PHP)<br>* yarn.lock (JS)<br>* pubspec.lock (Dart)<br>* Podfile.lock (Swift/Objc!)<br></p><p>Diverging from this seems counter-productive.<br>&gt; Philosophy<br>&gt; <br>&gt; Our philosophy with regard to pinning is that we actively want to encourage packages to develop against the latest semantically appropriate versions of their dependencies, in order to foster rapid development amongst the ecosystem and strong reliance on the semantic versioning concept. Our design for version pinning is thus intended to be a feature for package authors and users to use in crafting specific workflows, not be a mechanism by which most of the packages in the ecosystem pin themselves to specific versions of each other.<br>&gt; <br>&gt; Use Cases<br>&gt; <br>&gt; Our proposal is designed to satisfy several different use cases for such a behavior:<br>&gt; <br>&gt; Standardizing team workflows<br>&gt; <br>&gt; When collaborating on a package, it can be valuable for team members (and continuous integration) to all know they are using the same exact version of dependencies, to avoid &quot;works for me&quot; situations.<br>&gt; <br>&gt; This can be particularly important for certain kinds of open source projects which are actively being cloned by new users, and which want to have some measure of control around exactly which available version of a dependency is selected.<br>&gt; <br>&gt; Difficult to test packages or dependencies<br>&gt; <br>&gt; Complex packages which have dependencies which may be hard to test, or hard to analyze when they break, may choose to maintain careful control over what versions of their upstream dependencies they recommend -- even if conceptually they regularly update those recommendations following the true semantic version specification of the dependency.<br>&gt; <br>&gt; Dependency locking w.r.t. deployment<br>&gt; <br>&gt; When stabilizing a release for deployment, or building a version of a package for deployment, it is important to be able to lock down the exact versions of dependencies in use, so that the resulting product can be exactly recreated later if necessary.<br>&gt; <br>&gt; Proposed solution<br>&gt; We will introduce support for an optional new file Package.pins adjacent to the Package.swift manifest, called the &quot;pins file&quot;. We will also introduce a number of new commands (see below) for maintaining the pins file.<br>&gt; <br>&gt; This file will record the active version pin information for the package, including data such as the package identifier, the pinned version, and explicit information on the pinned version (e.g., the commit hash/SHA for the resolved tag).<br>&gt; <br>&gt; The exact file format is unspecified/implementation defined, however, in practice it will be a JSON data file.<br>&gt; <br>&gt; This file may be checked into SCM by the user, so that its effects apply to all users of the package. However, it may also be maintained only locally (e.g., placed in the .gitignore file). We intend to leave it to package authors to decide which use case is best for their project.<br>&gt; <br>&gt; In the presence of a Package.pins file, the package manager will respect the pinned dependencies recorded in the file whenever it needs to do dependency resolution (e.g., on the initial checkout or when updating).<br>&gt; <br>&gt; The pins file will not override Manifest specified version requirements and it will be an error (with proper diagnostics) if there is a conflict between the pins and the manifest specification.<br>&gt; <br>&gt; Detailed Design<br>&gt; We will add a new command pin to swift package tool with following semantics:<br>&gt; <br>&gt; $ swift package pin ( [--all] | [&lt;package-name&gt;] [&lt;version&gt;] ) [--message &lt;message&gt;]<br>&gt; The package-name refers to the name of the package as specified in its manifest.<br>&gt; <br>&gt; This command pins one or all dependencies. The command which pins a single version can optionally take a specific version to pin to, if unspecified (or with --all) the behaviour is to pin to the current package version in use. Examples: <br>&gt; <br>&gt; $ swift package pin --all - pins all the dependencies.<br>&gt; $ swift package pin Foo - pins Foo at current resolved version.<br>&gt; $ swift package pin Foo 1.2.3 - pins Foo at 1.2.3. The specified version should be valid and resolvable.<br>&gt; The --reason option is an optional argument to document the reason for pinning a dependency. This could be helpful for user to later remember why a dependency was pinned. Example: <br>&gt; <br>&gt; $ swift package pin Foo --reason &quot;The patch updates for Foo are really unstable and need screening.&quot;<br>&gt; Dependencies are never automatically pinned, pinning is only ever taken as a result of an explicit user action.<br>&gt; <br>&gt; We will add a new command unpin:<br>&gt; <br>&gt; $ swift package unpin ( [--all] | [&lt;package-name&gt;] )<br>&gt; This is the counterpart to the pin command, and unpins one or all packages.<br>&gt; <br>&gt; We will fetch and resolve the dependencies when running the pin commands, in case we don&#39;t have the complete dependency graph yet.<br>&gt; <br>&gt; We will extend the workflow for update to honour version pinning, that is, it will only update packages which are unpinned, and it will only update to versions which can satisfy the existing pins. The update command will, however, also take an optional argument --repin:<br>&gt; <br>&gt; $ swift package update [--repin]<br>&gt; Update command errors if there are no unpinned packages which can be updated.<br>&gt; <br>&gt; Otherwise, the behaviour is to update all unpinned packages to the latest possible versions which can be resolved while respecting the existing pins.<br>&gt; <br>&gt; The [--repin] argument can be used to lift the version pinning restrictions. In this case, the behaviour is that all packages are updated, and packages which were previously pinned are then repinned to the latest resolved versions.<br>&gt; <br>&gt; The update and checkout will both emit logs, notifying the user that pinning is in effect.<br>&gt; <br>&gt; The swift package show-dependencies subcommand will be updated to indicate if a dependency is pinned.<br>&gt; <br>&gt; As a future extension, we anticipate using the SHA information recorded in a pins file as a security feature, to prevent man-in-the-middle attacks on parts of the package graph.<br>&gt; <br>&gt; Impact on existing code<br>&gt; There will be change in the behaviours of swift build and swift package update in presence of the pins file, as noted in the proposal however the existing package will continue to build without any modifications.<br>&gt; <br>&gt; Alternative considered<br>&gt; We considered making the pinning behavior default on running swift build, however we think that pinning by default is likely to make the package graph more constrained than it should be. It drives the user away from taking full advantage of semantic versioning. We think it will be good for the package ecosystem if such a restriction is not the default behavior and that this design will lead to faster discovery of bugs and fixes in the upstream.<br>&gt; <br></p><p>I agree with the others that this is the better solution.<br></p><p>With regards to the constraining problem, the key insight adopted by Cargo/Yarn/Bundler is to distinguish libraries from applications. A library shouldn’t pin its dependencies, while an application should. This ensures that the ecosystem itself is maximally unconstrained, while ensuring actual applications continue to reliably build, regardless of ecosystem changes and the computer that it was built on. If a version of a library has trouble building with different versions, it should ideally specify that with its dependency constraints, not a lockfile.<br></p><p>This also ensures that there’s diverse testing of versions: CI for applications will verify particular configurations, while CI for libraries will verify the latest-and-greatest works.<br></p><p><br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20161014/b3b7fabf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ad5d998258bab37d23bc9555b0d6c237?s=50"></div><header><strong>[swift-evolution] Proposal: Package Manager Version Pinning</strong> from <string>Max Desiatov</string> &lt;max.desiatov at gmail.com&gt;<p>October 14, 2016 at 05:00:00pm</p></header><div class="content"><p>I also agree with the point that .lock extension better suits here and adheres to a convention already established in other languages. I personally would prefer the file to be named Package.lock, not Package.pins and also think that it would help newcomers who already used other package managers, especially CocoaPods.<br></p><p>With best regards, Max.<br></p><p>&gt; On 14 Oct 2016, at 17:43, Alexis via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Oct 14, 2016, at 2:01 AM, Ankit Aggarwal via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi,<br>&gt;&gt; <br>&gt;&gt; We&#39;re proposing version pinning feature in Swift Package Manager. The proposal is available here &lt;https://github.com/aciidb0mb3r/swift-evolution/blob/version-pinning/proposals/NNNN-Version-Pinning.md&gt; and also in this email:<br>&gt;&gt; <br>&gt;&gt; Feedback welcomed!<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; Ankit<br>&gt;&gt; <br>&gt;&gt; --------<br>&gt;&gt; <br>&gt;&gt; Package Manager Version Pinning<br>&gt;&gt; Proposal: SE-XXXX<br>&gt;&gt; Author: Daniel Dunbar &lt;https://github.com/ddunbar&gt;, Ankit Aggarwal &lt;https://github.com/aciidb0mb3r&gt;<br>&gt;&gt; Review Manager: TBD<br>&gt;&gt; Status: Discussion<br>&gt;&gt; Introduction<br>&gt;&gt; This is a proposal for adding package manager features to &quot;pin&quot; or &quot;lock&quot; package dependencies to particular versions.<br>&gt;&gt; <br>&gt;&gt; Motivation<br>&gt;&gt; As used in this proposal, version pinning refers to the practice of controlling exactly which specific version of a dependency is selected by the dependency resolution algorithm, independent from the semantic versioning specification. Thus, it is a way of instructing the package manager to select a particular version from among all of the versions of a package which could be chosen while honoring the dependency constraints.<br>&gt;&gt; <br>&gt;&gt; Terminology<br>&gt;&gt; <br>&gt;&gt; We have chosen to use &quot;pinning&quot; to refer to this feature, over &quot;lockfiles&quot;, since the term &quot;lock&quot; is already overloaded between POSIX file locks and locks in concurrent programming.<br>&gt;&gt; <br>&gt; I’ve never seen this cause any actual confusion, nor has anyone I know who teaches/develops these sorts of tools. As far as I can tell, the broader programming community is rapidly converging on this as standard terminology:<br>&gt; <br>&gt; * Gemfile.lock (Ruby)<br>&gt; * Cargo.lock (Rust)<br>&gt; * Composer.lock (PHP)<br>&gt; * yarn.lock (JS)<br>&gt; * pubspec.lock (Dart)<br>&gt; * Podfile.lock (Swift/Objc!)<br>&gt; <br>&gt; Diverging from this seems counter-productive.<br>&gt;&gt; Philosophy<br>&gt;&gt; <br>&gt;&gt; Our philosophy with regard to pinning is that we actively want to encourage packages to develop against the latest semantically appropriate versions of their dependencies, in order to foster rapid development amongst the ecosystem and strong reliance on the semantic versioning concept. Our design for version pinning is thus intended to be a feature for package authors and users to use in crafting specific workflows, not be a mechanism by which most of the packages in the ecosystem pin themselves to specific versions of each other.<br>&gt;&gt; <br>&gt;&gt; Use Cases<br>&gt;&gt; <br>&gt;&gt; Our proposal is designed to satisfy several different use cases for such a behavior:<br>&gt;&gt; <br>&gt;&gt; Standardizing team workflows<br>&gt;&gt; <br>&gt;&gt; When collaborating on a package, it can be valuable for team members (and continuous integration) to all know they are using the same exact version of dependencies, to avoid &quot;works for me&quot; situations.<br>&gt;&gt; <br>&gt;&gt; This can be particularly important for certain kinds of open source projects which are actively being cloned by new users, and which want to have some measure of control around exactly which available version of a dependency is selected.<br>&gt;&gt; <br>&gt;&gt; Difficult to test packages or dependencies<br>&gt;&gt; <br>&gt;&gt; Complex packages which have dependencies which may be hard to test, or hard to analyze when they break, may choose to maintain careful control over what versions of their upstream dependencies they recommend -- even if conceptually they regularly update those recommendations following the true semantic version specification of the dependency.<br>&gt;&gt; <br>&gt;&gt; Dependency locking w.r.t. deployment<br>&gt;&gt; <br>&gt;&gt; When stabilizing a release for deployment, or building a version of a package for deployment, it is important to be able to lock down the exact versions of dependencies in use, so that the resulting product can be exactly recreated later if necessary.<br>&gt;&gt; <br>&gt;&gt; Proposed solution<br>&gt;&gt; We will introduce support for an optional new file Package.pins adjacent to the Package.swift manifest, called the &quot;pins file&quot;. We will also introduce a number of new commands (see below) for maintaining the pins file.<br>&gt;&gt; <br>&gt;&gt; This file will record the active version pin information for the package, including data such as the package identifier, the pinned version, and explicit information on the pinned version (e.g., the commit hash/SHA for the resolved tag).<br>&gt;&gt; <br>&gt;&gt; The exact file format is unspecified/implementation defined, however, in practice it will be a JSON data file.<br>&gt;&gt; <br>&gt;&gt; This file may be checked into SCM by the user, so that its effects apply to all users of the package. However, it may also be maintained only locally (e.g., placed in the .gitignore file). We intend to leave it to package authors to decide which use case is best for their project.<br>&gt;&gt; <br>&gt;&gt; In the presence of a Package.pins file, the package manager will respect the pinned dependencies recorded in the file whenever it needs to do dependency resolution (e.g., on the initial checkout or when updating).<br>&gt;&gt; <br>&gt;&gt; The pins file will not override Manifest specified version requirements and it will be an error (with proper diagnostics) if there is a conflict between the pins and the manifest specification.<br>&gt;&gt; <br>&gt;&gt; Detailed Design<br>&gt;&gt; We will add a new command pin to swift package tool with following semantics:<br>&gt;&gt; <br>&gt;&gt; $ swift package pin ( [--all] | [&lt;package-name&gt;] [&lt;version&gt;] ) [--message &lt;message&gt;]<br>&gt;&gt; The package-name refers to the name of the package as specified in its manifest.<br>&gt;&gt; <br>&gt;&gt; This command pins one or all dependencies. The command which pins a single version can optionally take a specific version to pin to, if unspecified (or with --all) the behaviour is to pin to the current package version in use. Examples: <br>&gt;&gt; <br>&gt;&gt; $ swift package pin --all - pins all the dependencies.<br>&gt;&gt; $ swift package pin Foo - pins Foo at current resolved version.<br>&gt;&gt; $ swift package pin Foo 1.2.3 - pins Foo at 1.2.3. The specified version should be valid and resolvable.<br>&gt;&gt; The --reason option is an optional argument to document the reason for pinning a dependency. This could be helpful for user to later remember why a dependency was pinned. Example: <br>&gt;&gt; <br>&gt;&gt; $ swift package pin Foo --reason &quot;The patch updates for Foo are really unstable and need screening.&quot;<br>&gt;&gt; Dependencies are never automatically pinned, pinning is only ever taken as a result of an explicit user action.<br>&gt;&gt; <br>&gt;&gt; We will add a new command unpin:<br>&gt;&gt; <br>&gt;&gt; $ swift package unpin ( [--all] | [&lt;package-name&gt;] )<br>&gt;&gt; This is the counterpart to the pin command, and unpins one or all packages.<br>&gt;&gt; <br>&gt;&gt; We will fetch and resolve the dependencies when running the pin commands, in case we don&#39;t have the complete dependency graph yet.<br>&gt;&gt; <br>&gt;&gt; We will extend the workflow for update to honour version pinning, that is, it will only update packages which are unpinned, and it will only update to versions which can satisfy the existing pins. The update command will, however, also take an optional argument --repin:<br>&gt;&gt; <br>&gt;&gt; $ swift package update [--repin]<br>&gt;&gt; Update command errors if there are no unpinned packages which can be updated.<br>&gt;&gt; <br>&gt;&gt; Otherwise, the behaviour is to update all unpinned packages to the latest possible versions which can be resolved while respecting the existing pins.<br>&gt;&gt; <br>&gt;&gt; The [--repin] argument can be used to lift the version pinning restrictions. In this case, the behaviour is that all packages are updated, and packages which were previously pinned are then repinned to the latest resolved versions.<br>&gt;&gt; <br>&gt;&gt; The update and checkout will both emit logs, notifying the user that pinning is in effect.<br>&gt;&gt; <br>&gt;&gt; The swift package show-dependencies subcommand will be updated to indicate if a dependency is pinned.<br>&gt;&gt; <br>&gt;&gt; As a future extension, we anticipate using the SHA information recorded in a pins file as a security feature, to prevent man-in-the-middle attacks on parts of the package graph.<br>&gt;&gt; <br>&gt;&gt; Impact on existing code<br>&gt;&gt; There will be change in the behaviours of swift build and swift package update in presence of the pins file, as noted in the proposal however the existing package will continue to build without any modifications.<br>&gt;&gt; <br>&gt;&gt; Alternative considered<br>&gt;&gt; We considered making the pinning behavior default on running swift build, however we think that pinning by default is likely to make the package graph more constrained than it should be. It drives the user away from taking full advantage of semantic versioning. We think it will be good for the package ecosystem if such a restriction is not the default behavior and that this design will lead to faster discovery of bugs and fixes in the upstream.<br>&gt;&gt; <br>&gt; <br>&gt; I agree with the others that this is the better solution.<br>&gt; <br>&gt; With regards to the constraining problem, the key insight adopted by Cargo/Yarn/Bundler is to distinguish libraries from applications. A library shouldn’t pin its dependencies, while an application should. This ensures that the ecosystem itself is maximally unconstrained, while ensuring actual applications continue to reliably build, regardless of ecosystem changes and the computer that it was built on. If a version of a library has trouble building with different versions, it should ideally specify that with its dependency constraints, not a lockfile.<br>&gt; <br>&gt; This also ensures that there’s diverse testing of versions: CI for applications will verify particular configurations, while CI for libraries will verify the latest-and-greatest works.<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20161014/5d6f797b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ad5d998258bab37d23bc9555b0d6c237?s=50"></div><header><strong>[swift-evolution] Proposal: Package Manager Version Pinning</strong> from <string>Max Desiatov</string> &lt;max.desiatov at gmail.com&gt;<p>October 14, 2016 at 06:00:00pm</p></header><div class="content"><p>The other point is that when working in a multi-language environment, having conventions such as this broken causes additional mental burden. That is, after working with JavaScript/Rust/iOS with CocoaPods and then switching to Swift, would require a lot of unneeded context switching, as in: &quot;Where&#39;s that lockfile? I can&#39;t find it. Oh great, turns out it&#39;s not a lockfile, it&#39;s something else&quot;.<br></p><p>With best regards, Max.<br></p><p>&gt; On 14 Oct 2016, at 17:59, Max Desiatov &lt;max.desiatov at gmail.com&gt; wrote:<br>&gt; <br>&gt; I also agree with the point that .lock extension better suits here and adheres to a convention already established in other languages. I personally would prefer the file to be named Package.lock, not Package.pins and also think that it would help newcomers who already used other package managers, especially CocoaPods.<br>&gt; <br>&gt; With best regards, Max.<br>&gt; <br>&gt;&gt; On 14 Oct 2016, at 17:43, Alexis via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 14, 2016, at 2:01 AM, Ankit Aggarwal via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We&#39;re proposing version pinning feature in Swift Package Manager. The proposal is available here &lt;https://github.com/aciidb0mb3r/swift-evolution/blob/version-pinning/proposals/NNNN-Version-Pinning.md&gt; and also in this email:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Feedback welcomed!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt; Ankit<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; --------<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Package Manager Version Pinning<br>&gt;&gt;&gt; Proposal: SE-XXXX<br>&gt;&gt;&gt; Author: Daniel Dunbar &lt;https://github.com/ddunbar&gt;, Ankit Aggarwal &lt;https://github.com/aciidb0mb3r&gt;<br>&gt;&gt;&gt; Review Manager: TBD<br>&gt;&gt;&gt; Status: Discussion<br>&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt; This is a proposal for adding package manager features to &quot;pin&quot; or &quot;lock&quot; package dependencies to particular versions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt; As used in this proposal, version pinning refers to the practice of controlling exactly which specific version of a dependency is selected by the dependency resolution algorithm, independent from the semantic versioning specification. Thus, it is a way of instructing the package manager to select a particular version from among all of the versions of a package which could be chosen while honoring the dependency constraints.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Terminology<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We have chosen to use &quot;pinning&quot; to refer to this feature, over &quot;lockfiles&quot;, since the term &quot;lock&quot; is already overloaded between POSIX file locks and locks in concurrent programming.<br>&gt;&gt;&gt; <br>&gt;&gt; I’ve never seen this cause any actual confusion, nor has anyone I know who teaches/develops these sorts of tools. As far as I can tell, the broader programming community is rapidly converging on this as standard terminology:<br>&gt;&gt; <br>&gt;&gt; * Gemfile.lock (Ruby)<br>&gt;&gt; * Cargo.lock (Rust)<br>&gt;&gt; * Composer.lock (PHP)<br>&gt;&gt; * yarn.lock (JS)<br>&gt;&gt; * pubspec.lock (Dart)<br>&gt;&gt; * Podfile.lock (Swift/Objc!)<br>&gt;&gt; <br>&gt;&gt; Diverging from this seems counter-productive.<br>&gt;&gt;&gt; Philosophy<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Our philosophy with regard to pinning is that we actively want to encourage packages to develop against the latest semantically appropriate versions of their dependencies, in order to foster rapid development amongst the ecosystem and strong reliance on the semantic versioning concept. Our design for version pinning is thus intended to be a feature for package authors and users to use in crafting specific workflows, not be a mechanism by which most of the packages in the ecosystem pin themselves to specific versions of each other.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Use Cases<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Our proposal is designed to satisfy several different use cases for such a behavior:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Standardizing team workflows<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When collaborating on a package, it can be valuable for team members (and continuous integration) to all know they are using the same exact version of dependencies, to avoid &quot;works for me&quot; situations.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This can be particularly important for certain kinds of open source projects which are actively being cloned by new users, and which want to have some measure of control around exactly which available version of a dependency is selected.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Difficult to test packages or dependencies<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Complex packages which have dependencies which may be hard to test, or hard to analyze when they break, may choose to maintain careful control over what versions of their upstream dependencies they recommend -- even if conceptually they regularly update those recommendations following the true semantic version specification of the dependency.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Dependency locking w.r.t. deployment<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When stabilizing a release for deployment, or building a version of a package for deployment, it is important to be able to lock down the exact versions of dependencies in use, so that the resulting product can be exactly recreated later if necessary.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt; We will introduce support for an optional new file Package.pins adjacent to the Package.swift manifest, called the &quot;pins file&quot;. We will also introduce a number of new commands (see below) for maintaining the pins file.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This file will record the active version pin information for the package, including data such as the package identifier, the pinned version, and explicit information on the pinned version (e.g., the commit hash/SHA for the resolved tag).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The exact file format is unspecified/implementation defined, however, in practice it will be a JSON data file.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This file may be checked into SCM by the user, so that its effects apply to all users of the package. However, it may also be maintained only locally (e.g., placed in the .gitignore file). We intend to leave it to package authors to decide which use case is best for their project.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In the presence of a Package.pins file, the package manager will respect the pinned dependencies recorded in the file whenever it needs to do dependency resolution (e.g., on the initial checkout or when updating).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The pins file will not override Manifest specified version requirements and it will be an error (with proper diagnostics) if there is a conflict between the pins and the manifest specification.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Detailed Design<br>&gt;&gt;&gt; We will add a new command pin to swift package tool with following semantics:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; $ swift package pin ( [--all] | [&lt;package-name&gt;] [&lt;version&gt;] ) [--message &lt;message&gt;]<br>&gt;&gt;&gt; The package-name refers to the name of the package as specified in its manifest.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This command pins one or all dependencies. The command which pins a single version can optionally take a specific version to pin to, if unspecified (or with --all) the behaviour is to pin to the current package version in use. Examples: <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; $ swift package pin --all - pins all the dependencies.<br>&gt;&gt;&gt; $ swift package pin Foo - pins Foo at current resolved version.<br>&gt;&gt;&gt; $ swift package pin Foo 1.2.3 - pins Foo at 1.2.3. The specified version should be valid and resolvable.<br>&gt;&gt;&gt; The --reason option is an optional argument to document the reason for pinning a dependency. This could be helpful for user to later remember why a dependency was pinned. Example: <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; $ swift package pin Foo --reason &quot;The patch updates for Foo are really unstable and need screening.&quot;<br>&gt;&gt;&gt; Dependencies are never automatically pinned, pinning is only ever taken as a result of an explicit user action.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We will add a new command unpin:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; $ swift package unpin ( [--all] | [&lt;package-name&gt;] )<br>&gt;&gt;&gt; This is the counterpart to the pin command, and unpins one or all packages.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We will fetch and resolve the dependencies when running the pin commands, in case we don&#39;t have the complete dependency graph yet.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We will extend the workflow for update to honour version pinning, that is, it will only update packages which are unpinned, and it will only update to versions which can satisfy the existing pins. The update command will, however, also take an optional argument --repin:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; $ swift package update [--repin]<br>&gt;&gt;&gt; Update command errors if there are no unpinned packages which can be updated.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Otherwise, the behaviour is to update all unpinned packages to the latest possible versions which can be resolved while respecting the existing pins.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The [--repin] argument can be used to lift the version pinning restrictions. In this case, the behaviour is that all packages are updated, and packages which were previously pinned are then repinned to the latest resolved versions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The update and checkout will both emit logs, notifying the user that pinning is in effect.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The swift package show-dependencies subcommand will be updated to indicate if a dependency is pinned.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As a future extension, we anticipate using the SHA information recorded in a pins file as a security feature, to prevent man-in-the-middle attacks on parts of the package graph.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt; There will be change in the behaviours of swift build and swift package update in presence of the pins file, as noted in the proposal however the existing package will continue to build without any modifications.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alternative considered<br>&gt;&gt;&gt; We considered making the pinning behavior default on running swift build, however we think that pinning by default is likely to make the package graph more constrained than it should be. It drives the user away from taking full advantage of semantic versioning. We think it will be good for the package ecosystem if such a restriction is not the default behavior and that this design will lead to faster discovery of bugs and fixes in the upstream.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I agree with the others that this is the better solution.<br>&gt;&gt; <br>&gt;&gt; With regards to the constraining problem, the key insight adopted by Cargo/Yarn/Bundler is to distinguish libraries from applications. A library shouldn’t pin its dependencies, while an application should. This ensures that the ecosystem itself is maximally unconstrained, while ensuring actual applications continue to reliably build, regardless of ecosystem changes and the computer that it was built on. If a version of a library has trouble building with different versions, it should ideally specify that with its dependency constraints, not a lockfile.<br>&gt;&gt; <br>&gt;&gt; This also ensures that there’s diverse testing of versions: CI for applications will verify particular configurations, while CI for libraries will verify the latest-and-greatest works.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20161014/68447e0d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d9baa679148bd83458d11df12327ce0?s=50"></div><header><strong>[swift-evolution] Proposal: Package Manager Version Pinning</strong> from <string>Daniel Dunbar</string> &lt;daniel_dunbar at apple.com&gt;<p>October 14, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Oct 14, 2016, at 10:03 AM, Max Desiatov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The other point is that when working in a multi-language environment, having conventions such as this broken causes additional mental burden. That is, after working with JavaScript/Rust/iOS with CocoaPods and then switching to Swift, would require a lot of unneeded context switching, as in: &quot;Where&#39;s that lockfile? I can&#39;t find it. Oh great, turns out it&#39;s not a lockfile, it&#39;s something else&quot;.<br></p><p>In Swift, we have pretty consistently tried to choose the &quot;right&quot; answer to make the resulting language consistent and beautiful.<br></p><p>I&#39;m perfectly happy to have a discussion about the naming, but I would like it to be driven by what we believe the &quot;right&quot; answer is, not simply by deference to existing solutions. I do sympathize with wanting to be consistent where there is little value in diverging, but most people I have discussed this with agree that &quot;lock&quot; is actually the *wrong* word to use for this operation.<br></p><p>Also, please be mindful that your perspective is biased by the tools you are familiar with. Python&#39;s pip tool, for example, uses &quot;freeze&quot; for this, and Heroku expects &quot;requirements.txt&quot;, so someone coming from that ecosystem could make the same argument in another direction. I find arguments about &quot;A does X so we should do X&quot; most compelling when it comes with a relatively complete survey of existing tools. not just a particular slice of possible tools.<br></p><p>Whether &quot;pinning&quot; is the right word is a different debate, but when we view pinning as a workflow-focused feature, versus the specification in the manifest (which is the &quot;requirement&quot;), then I think the connotation actually works fairly well (e.g., a pinboard is something you pin to while working, or pinning a dress while you stitch it). I also wasn&#39;t a huge fan of pin initially, but as it bounced around in my head for a while I really started to like it, for exactly this connotation reason.<br></p><p> - Daniel<br></p><p>&gt; <br>&gt; With best regards, Max.<br>&gt; <br>&gt;&gt; On 14 Oct 2016, at 17:59, Max Desiatov &lt;max.desiatov at gmail.com &lt;mailto:max.desiatov at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I also agree with the point that .lock extension better suits here and adheres to a convention already established in other languages. I personally would prefer the file to be named Package.lock, not Package.pins and also think that it would help newcomers who already used other package managers, especially CocoaPods.<br>&gt;&gt; <br>&gt;&gt; With best regards, Max.<br>&gt;&gt; <br>&gt;&gt;&gt; On 14 Oct 2016, at 17:43, Alexis via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 14, 2016, at 2:01 AM, Ankit Aggarwal via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We&#39;re proposing version pinning feature in Swift Package Manager. The proposal is available here &lt;https://github.com/aciidb0mb3r/swift-evolution/blob/version-pinning/proposals/NNNN-Version-Pinning.md&gt; and also in this email:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Feedback welcomed!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt; Ankit<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; --------<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Package Manager Version Pinning<br>&gt;&gt;&gt;&gt; Proposal: SE-XXXX<br>&gt;&gt;&gt;&gt; Author: Daniel Dunbar &lt;https://github.com/ddunbar&gt;, Ankit Aggarwal &lt;https://github.com/aciidb0mb3r&gt;<br>&gt;&gt;&gt;&gt; Review Manager: TBD<br>&gt;&gt;&gt;&gt; Status: Discussion<br>&gt;&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;&gt; This is a proposal for adding package manager features to &quot;pin&quot; or &quot;lock&quot; package dependencies to particular versions.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;&gt; As used in this proposal, version pinning refers to the practice of controlling exactly which specific version of a dependency is selected by the dependency resolution algorithm, independent from the semantic versioning specification. Thus, it is a way of instructing the package manager to select a particular version from among all of the versions of a package which could be chosen while honoring the dependency constraints.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Terminology<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We have chosen to use &quot;pinning&quot; to refer to this feature, over &quot;lockfiles&quot;, since the term &quot;lock&quot; is already overloaded between POSIX file locks and locks in concurrent programming.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; I’ve never seen this cause any actual confusion, nor has anyone I know who teaches/develops these sorts of tools. As far as I can tell, the broader programming community is rapidly converging on this as standard terminology:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * Gemfile.lock (Ruby)<br>&gt;&gt;&gt; * Cargo.lock (Rust)<br>&gt;&gt;&gt; * Composer.lock (PHP)<br>&gt;&gt;&gt; * yarn.lock (JS)<br>&gt;&gt;&gt; * pubspec.lock (Dart)<br>&gt;&gt;&gt; * Podfile.lock (Swift/Objc!)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Diverging from this seems counter-productive.<br>&gt;&gt;&gt;&gt; Philosophy<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Our philosophy with regard to pinning is that we actively want to encourage packages to develop against the latest semantically appropriate versions of their dependencies, in order to foster rapid development amongst the ecosystem and strong reliance on the semantic versioning concept. Our design for version pinning is thus intended to be a feature for package authors and users to use in crafting specific workflows, not be a mechanism by which most of the packages in the ecosystem pin themselves to specific versions of each other.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Use Cases<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Our proposal is designed to satisfy several different use cases for such a behavior:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Standardizing team workflows<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; When collaborating on a package, it can be valuable for team members (and continuous integration) to all know they are using the same exact version of dependencies, to avoid &quot;works for me&quot; situations.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This can be particularly important for certain kinds of open source projects which are actively being cloned by new users, and which want to have some measure of control around exactly which available version of a dependency is selected.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Difficult to test packages or dependencies<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Complex packages which have dependencies which may be hard to test, or hard to analyze when they break, may choose to maintain careful control over what versions of their upstream dependencies they recommend -- even if conceptually they regularly update those recommendations following the true semantic version specification of the dependency.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Dependency locking w.r.t. deployment<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; When stabilizing a release for deployment, or building a version of a package for deployment, it is important to be able to lock down the exact versions of dependencies in use, so that the resulting product can be exactly recreated later if necessary.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt;&gt; We will introduce support for an optional new file Package.pins adjacent to the Package.swift manifest, called the &quot;pins file&quot;. We will also introduce a number of new commands (see below) for maintaining the pins file.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This file will record the active version pin information for the package, including data such as the package identifier, the pinned version, and explicit information on the pinned version (e.g., the commit hash/SHA for the resolved tag).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The exact file format is unspecified/implementation defined, however, in practice it will be a JSON data file.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This file may be checked into SCM by the user, so that its effects apply to all users of the package. However, it may also be maintained only locally (e.g., placed in the .gitignore file). We intend to leave it to package authors to decide which use case is best for their project.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In the presence of a Package.pins file, the package manager will respect the pinned dependencies recorded in the file whenever it needs to do dependency resolution (e.g., on the initial checkout or when updating).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The pins file will not override Manifest specified version requirements and it will be an error (with proper diagnostics) if there is a conflict between the pins and the manifest specification.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Detailed Design<br>&gt;&gt;&gt;&gt; We will add a new command pin to swift package tool with following semantics:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; $ swift package pin ( [--all] | [&lt;package-name&gt;] [&lt;version&gt;] ) [--message &lt;message&gt;]<br>&gt;&gt;&gt;&gt; The package-name refers to the name of the package as specified in its manifest.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This command pins one or all dependencies. The command which pins a single version can optionally take a specific version to pin to, if unspecified (or with --all) the behaviour is to pin to the current package version in use. Examples: <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; $ swift package pin --all - pins all the dependencies.<br>&gt;&gt;&gt;&gt; $ swift package pin Foo - pins Foo at current resolved version.<br>&gt;&gt;&gt;&gt; $ swift package pin Foo 1.2.3 - pins Foo at 1.2.3. The specified version should be valid and resolvable.<br>&gt;&gt;&gt;&gt; The --reason option is an optional argument to document the reason for pinning a dependency. This could be helpful for user to later remember why a dependency was pinned. Example: <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; $ swift package pin Foo --reason &quot;The patch updates for Foo are really unstable and need screening.&quot;<br>&gt;&gt;&gt;&gt; Dependencies are never automatically pinned, pinning is only ever taken as a result of an explicit user action.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We will add a new command unpin:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; $ swift package unpin ( [--all] | [&lt;package-name&gt;] )<br>&gt;&gt;&gt;&gt; This is the counterpart to the pin command, and unpins one or all packages.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We will fetch and resolve the dependencies when running the pin commands, in case we don&#39;t have the complete dependency graph yet.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We will extend the workflow for update to honour version pinning, that is, it will only update packages which are unpinned, and it will only update to versions which can satisfy the existing pins. The update command will, however, also take an optional argument --repin:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; $ swift package update [--repin]<br>&gt;&gt;&gt;&gt; Update command errors if there are no unpinned packages which can be updated.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Otherwise, the behaviour is to update all unpinned packages to the latest possible versions which can be resolved while respecting the existing pins.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The [--repin] argument can be used to lift the version pinning restrictions. In this case, the behaviour is that all packages are updated, and packages which were previously pinned are then repinned to the latest resolved versions.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The update and checkout will both emit logs, notifying the user that pinning is in effect.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The swift package show-dependencies subcommand will be updated to indicate if a dependency is pinned.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As a future extension, we anticipate using the SHA information recorded in a pins file as a security feature, to prevent man-in-the-middle attacks on parts of the package graph.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt;&gt; There will be change in the behaviours of swift build and swift package update in presence of the pins file, as noted in the proposal however the existing package will continue to build without any modifications.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Alternative considered<br>&gt;&gt;&gt;&gt; We considered making the pinning behavior default on running swift build, however we think that pinning by default is likely to make the package graph more constrained than it should be. It drives the user away from taking full advantage of semantic versioning. We think it will be good for the package ecosystem if such a restriction is not the default behavior and that this design will lead to faster discovery of bugs and fixes in the upstream.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree with the others that this is the better solution.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; With regards to the constraining problem, the key insight adopted by Cargo/Yarn/Bundler is to distinguish libraries from applications. A library shouldn’t pin its dependencies, while an application should. This ensures that the ecosystem itself is maximally unconstrained, while ensuring actual applications continue to reliably build, regardless of ecosystem changes and the computer that it was built on. If a version of a library has trouble building with different versions, it should ideally specify that with its dependency constraints, not a lockfile.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This also ensures that there’s diverse testing of versions: CI for applications will verify particular configurations, while CI for libraries will verify the latest-and-greatest works.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20161014/3713212e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/14477c366d6ee4e41adf14837bc4f2f9?s=50"></div><header><strong>[swift-evolution] Proposal: Package Manager Version Pinning</strong> from <string>Ryan Lovelett</string> &lt;swift-dev at ryan.lovelett.me&gt;<p>October 14, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; Whether &quot;pinning&quot; is the right word is a different debate, but when we<br>&gt; view pinning as a workflow-focused feature, versus the specification<br>&gt; in the manifest (which is the &quot;requirement&quot;), then I think the<br>&gt; connotation actually works fairly well (e.g., a pinboard is something<br>&gt; you pin to while working, or pinning a dress while you stitch it). I<br>&gt; also wasn&#39;t a huge fan of pin initially, but as it bounced around in<br>&gt; my head for a while I really started to like it, for exactly this<br>&gt; connotation reason.<br></p><p>I think this comment drives at the core of the difference between this<br>proposal and what Orta, Alexis and others are saying. (At least for me)<br></p><p>The description you&#39;ve provided here, specifically the word &quot;workflow&quot;,<br>and the concept of operations described by the proprosal are meant to be<br>a transient. They are meant as a temporary description of how these<br>dependencies should be kept in order.  To my mind one &quot;puts a pin&quot; in<br>something temporarily. To comeback to it later to do something with it<br>at that time. Thus the pin probably does work with this concept.<br></p><p>Conversely, the concept of &quot;locking&quot; something feels less transient. It<br>feels more permanent. More like the concept of operations described by<br>Orta, Alexis and others. Idle speculation: might be why those other<br>managers selected the word lock.<br></p><p>Not sure where I come down on the whole thing yet. Just wanted to say<br>that if the propsal goes another way than what was first propsed  a new<br>word likely should be investigated.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20161014/6348d48a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d9baa679148bd83458d11df12327ce0?s=50"></div><header><strong>[swift-evolution] Proposal: Package Manager Version Pinning</strong> from <string>Daniel Dunbar</string> &lt;daniel_dunbar at apple.com&gt;<p>October 14, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Oct 14, 2016, at 12:04 PM, Ryan Lovelett &lt;swift-dev at ryan.lovelett.me&gt; wrote:<br>&gt; <br>&gt;&gt; Whether &quot;pinning&quot; is the right word is a different debate, but when we view pinning as a workflow-focused feature, versus the specification in the manifest (which is the &quot;requirement&quot;), then I think the connotation actually works fairly well (e.g., a pinboard is something you pin to while working, or pinning a dress while you stitch it). I also wasn&#39;t a huge fan of pin initially, but as it bounced around in my head for a while I really started to like it, for exactly this connotation reason.<br>&gt; <br>&gt; I think this comment drives at the core of the difference between this proposal and what Orta, Alexis and others are saying. (At least for me)<br>&gt; <br>&gt; The description you&#39;ve provided here, specifically the word &quot;workflow&quot;, and the concept of operations described by the proprosal are meant to be a transient. They are meant as a temporary description of how these dependencies should be kept in order.  To my mind one &quot;puts a pin&quot; in something temporarily. To comeback to it later to do something with it at that time. Thus the pin probably does work with this concept.<br>&gt; <br>&gt; Conversely, the concept of &quot;locking&quot; something feels less transient. It feels more permanent. More like the concept of operations described by Orta, Alexis and others. Idle speculation: might be why those other managers selected the word lock.<br>&gt; <br>&gt; Not sure where I come down on the whole thing yet. Just wanted to say that if the propsal goes another way than what was first propsed a new word likely should be investigated.<br></p><p>I agree with everything here. :)<br></p><p> - Daniel<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d9baa679148bd83458d11df12327ce0?s=50"></div><header><strong>[swift-evolution] Proposal: Package Manager Version Pinning</strong> from <string>Daniel Dunbar</string> &lt;daniel_dunbar at apple.com&gt;<p>October 14, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Oct 14, 2016, at 9:43 AM, Alexis via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Oct 14, 2016, at 2:01 AM, Ankit Aggarwal via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi,<br>&gt;&gt; <br>&gt;&gt; We&#39;re proposing version pinning feature in Swift Package Manager. The proposal is available here &lt;https://github.com/aciidb0mb3r/swift-evolution/blob/version-pinning/proposals/NNNN-Version-Pinning.md&gt; and also in this email:<br>&gt;&gt; <br>&gt;&gt; Feedback welcomed!<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; Ankit<br>&gt;&gt; <br>&gt;&gt; --------<br>&gt;&gt; <br>&gt;&gt; Package Manager Version Pinning<br>&gt;&gt; Proposal: SE-XXXX<br>&gt;&gt; Author: Daniel Dunbar &lt;https://github.com/ddunbar&gt;, Ankit Aggarwal &lt;https://github.com/aciidb0mb3r&gt;<br>&gt;&gt; Review Manager: TBD<br>&gt;&gt; Status: Discussion<br>&gt;&gt; Introduction<br>&gt;&gt; This is a proposal for adding package manager features to &quot;pin&quot; or &quot;lock&quot; package dependencies to particular versions.<br>&gt;&gt; <br>&gt;&gt; Motivation<br>&gt;&gt; As used in this proposal, version pinning refers to the practice of controlling exactly which specific version of a dependency is selected by the dependency resolution algorithm, independent from the semantic versioning specification. Thus, it is a way of instructing the package manager to select a particular version from among all of the versions of a package which could be chosen while honoring the dependency constraints.<br>&gt;&gt; <br>&gt;&gt; Terminology<br>&gt;&gt; <br>&gt;&gt; We have chosen to use &quot;pinning&quot; to refer to this feature, over &quot;lockfiles&quot;, since the term &quot;lock&quot; is already overloaded between POSIX file locks and locks in concurrent programming.<br>&gt;&gt; <br>&gt; I’ve never seen this cause any actual confusion, nor has anyone I know who teaches/develops these sorts of tools. As far as I can tell, the broader programming community is rapidly converging on this as standard terminology:<br>&gt; <br>&gt; * Gemfile.lock (Ruby)<br>&gt; * Cargo.lock (Rust)<br>&gt; * Composer.lock (PHP)<br>&gt; * yarn.lock (JS)<br>&gt; * pubspec.lock (Dart)<br>&gt; * Podfile.lock (Swift/Objc!)<br>&gt; <br>&gt; Diverging from this seems counter-productive.<br></p><p>I replied to Max on this point, can you check that?<br></p><p>I will add that I am completely open to being compelled by &quot;this is becoming standard, we should follow&quot;.<br></p><p>Also, let&#39;s break this into its own fork of the thread rather than mix with the behavior.<br>&gt;&gt; Philosophy<br>&gt;&gt; <br>&gt;&gt; Our philosophy with regard to pinning is that we actively want to encourage packages to develop against the latest semantically appropriate versions of their dependencies, in order to foster rapid development amongst the ecosystem and strong reliance on the semantic versioning concept. Our design for version pinning is thus intended to be a feature for package authors and users to use in crafting specific workflows, not be a mechanism by which most of the packages in the ecosystem pin themselves to specific versions of each other.<br>&gt;&gt; <br>&gt;&gt; Use Cases<br>&gt;&gt; <br>&gt;&gt; Our proposal is designed to satisfy several different use cases for such a behavior:<br>&gt;&gt; <br>&gt;&gt; Standardizing team workflows<br>&gt;&gt; <br>&gt;&gt; When collaborating on a package, it can be valuable for team members (and continuous integration) to all know they are using the same exact version of dependencies, to avoid &quot;works for me&quot; situations.<br>&gt;&gt; <br>&gt;&gt; This can be particularly important for certain kinds of open source projects which are actively being cloned by new users, and which want to have some measure of control around exactly which available version of a dependency is selected.<br>&gt;&gt; <br>&gt;&gt; Difficult to test packages or dependencies<br>&gt;&gt; <br>&gt;&gt; Complex packages which have dependencies which may be hard to test, or hard to analyze when they break, may choose to maintain careful control over what versions of their upstream dependencies they recommend -- even if conceptually they regularly update those recommendations following the true semantic version specification of the dependency.<br>&gt;&gt; <br>&gt;&gt; Dependency locking w.r.t. deployment<br>&gt;&gt; <br>&gt;&gt; When stabilizing a release for deployment, or building a version of a package for deployment, it is important to be able to lock down the exact versions of dependencies in use, so that the resulting product can be exactly recreated later if necessary.<br>&gt;&gt; <br>&gt;&gt; Proposed solution<br>&gt;&gt; We will introduce support for an optional new file Package.pins adjacent to the Package.swift manifest, called the &quot;pins file&quot;. We will also introduce a number of new commands (see below) for maintaining the pins file.<br>&gt;&gt; <br>&gt;&gt; This file will record the active version pin information for the package, including data such as the package identifier, the pinned version, and explicit information on the pinned version (e.g., the commit hash/SHA for the resolved tag).<br>&gt;&gt; <br>&gt;&gt; The exact file format is unspecified/implementation defined, however, in practice it will be a JSON data file.<br>&gt;&gt; <br>&gt;&gt; This file may be checked into SCM by the user, so that its effects apply to all users of the package. However, it may also be maintained only locally (e.g., placed in the .gitignore file). We intend to leave it to package authors to decide which use case is best for their project.<br>&gt;&gt; <br>&gt;&gt; In the presence of a Package.pins file, the package manager will respect the pinned dependencies recorded in the file whenever it needs to do dependency resolution (e.g., on the initial checkout or when updating).<br>&gt;&gt; <br>&gt;&gt; The pins file will not override Manifest specified version requirements and it will be an error (with proper diagnostics) if there is a conflict between the pins and the manifest specification.<br>&gt;&gt; <br>&gt;&gt; Detailed Design<br>&gt;&gt; We will add a new command pin to swift package tool with following semantics:<br>&gt;&gt; <br>&gt;&gt; $ swift package pin ( [--all] | [&lt;package-name&gt;] [&lt;version&gt;] ) [--message &lt;message&gt;]<br>&gt;&gt; The package-name refers to the name of the package as specified in its manifest.<br>&gt;&gt; <br>&gt;&gt; This command pins one or all dependencies. The command which pins a single version can optionally take a specific version to pin to, if unspecified (or with --all) the behaviour is to pin to the current package version in use. Examples: <br>&gt;&gt; <br>&gt;&gt; $ swift package pin --all - pins all the dependencies.<br>&gt;&gt; $ swift package pin Foo - pins Foo at current resolved version.<br>&gt;&gt; $ swift package pin Foo 1.2.3 - pins Foo at 1.2.3. The specified version should be valid and resolvable.<br>&gt;&gt; The --reason option is an optional argument to document the reason for pinning a dependency. This could be helpful for user to later remember why a dependency was pinned. Example: <br>&gt;&gt; <br>&gt;&gt; $ swift package pin Foo --reason &quot;The patch updates for Foo are really unstable and need screening.&quot;<br>&gt;&gt; Dependencies are never automatically pinned, pinning is only ever taken as a result of an explicit user action.<br>&gt;&gt; <br>&gt;&gt; We will add a new command unpin:<br>&gt;&gt; <br>&gt;&gt; $ swift package unpin ( [--all] | [&lt;package-name&gt;] )<br>&gt;&gt; This is the counterpart to the pin command, and unpins one or all packages.<br>&gt;&gt; <br>&gt;&gt; We will fetch and resolve the dependencies when running the pin commands, in case we don&#39;t have the complete dependency graph yet.<br>&gt;&gt; <br>&gt;&gt; We will extend the workflow for update to honour version pinning, that is, it will only update packages which are unpinned, and it will only update to versions which can satisfy the existing pins. The update command will, however, also take an optional argument --repin:<br>&gt;&gt; <br>&gt;&gt; $ swift package update [--repin]<br>&gt;&gt; Update command errors if there are no unpinned packages which can be updated.<br>&gt;&gt; <br>&gt;&gt; Otherwise, the behaviour is to update all unpinned packages to the latest possible versions which can be resolved while respecting the existing pins.<br>&gt;&gt; <br>&gt;&gt; The [--repin] argument can be used to lift the version pinning restrictions. In this case, the behaviour is that all packages are updated, and packages which were previously pinned are then repinned to the latest resolved versions.<br>&gt;&gt; <br>&gt;&gt; The update and checkout will both emit logs, notifying the user that pinning is in effect.<br>&gt;&gt; <br>&gt;&gt; The swift package show-dependencies subcommand will be updated to indicate if a dependency is pinned.<br>&gt;&gt; <br>&gt;&gt; As a future extension, we anticipate using the SHA information recorded in a pins file as a security feature, to prevent man-in-the-middle attacks on parts of the package graph.<br>&gt;&gt; <br>&gt;&gt; Impact on existing code<br>&gt;&gt; There will be change in the behaviours of swift build and swift package update in presence of the pins file, as noted in the proposal however the existing package will continue to build without any modifications.<br>&gt;&gt; <br>&gt;&gt; Alternative considered<br>&gt;&gt; We considered making the pinning behavior default on running swift build, however we think that pinning by default is likely to make the package graph more constrained than it should be. It drives the user away from taking full advantage of semantic versioning. We think it will be good for the package ecosystem if such a restriction is not the default behavior and that this design will lead to faster discovery of bugs and fixes in the upstream.<br>&gt;&gt; <br>&gt; <br>&gt; I agree with the others that this is the better solution.<br>&gt; <br>&gt; With regards to the constraining problem, the key insight adopted by Cargo/Yarn/Bundler is to distinguish libraries from applications. A library shouldn’t pin its dependencies, while an application should. This ensures that the ecosystem itself is maximally unconstrained, while ensuring actual applications continue to reliably build, regardless of ecosystem changes and the computer that it was built on. If a version of a library has trouble building with different versions, it should ideally specify that with its dependency constraints, not a lock file.<br></p><p>This I think is one big crux of the current discussion, and one of the things not in the proposal was my expectation that most packages right now are going to be shared (I personally wouldn&#39;t say libraries vs applications, since applications can also be shared as build tools, I think it comes down to whether it is shared or not).<br></p><p>If we agree that a library shouldn&#39;t pin its dependencies, how would you surface this feature? What exact behavior would you prefer?<br></p><p> - Daniel<br></p><p>&gt; <br>&gt; This also ensures that there’s diverse testing of versions: CI for applications will verify particular configurations, while CI for libraries will verify the latest-and-greatest works.<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20161014/d2fa7200/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/79d9ba388d6b6cf4ec7310cad9fa8c8a?s=50"></div><header><strong>[swift-evolution] Proposal: Package Manager Version Pinning</strong> from <string>Rob Allen</string> &lt;rob at akrabat.com&gt;<p>October 14, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On 14 Oct 2016, at 18:55, Daniel Dunbar via swift-build-dev &lt;swift-build-dev at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Oct 14, 2016, at 9:43 AM, Alexis via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 14, 2016, at 2:01 AM, Ankit Aggarwal via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We considered making the pinning behavior default on running swift build, however we think that pinning by default is likely to make the package graph more constrained than it should be. It drives the user away from taking full advantage of semantic versioning. We think it will be good for the package ecosystem if such a restriction is not the default behavior and that this design will lead to faster discovery of bugs and fixes in the upstream.<br>&gt;&gt; <br>&gt;&gt; I agree with the others that this is the better solution.<br>&gt;&gt; <br>&gt;&gt; With regards to the constraining problem, the key insight adopted by Cargo/Yarn/Bundler is to distinguish libraries from applications. A library shouldn’t pin its dependencies, while an application should. This ensures that the ecosystem itself is maximally unconstrained, while ensuring actual applications continue to reliably build, regardless of ecosystem changes and the computer that it was built on. If a version of a library has trouble building with different versions, it should ideally specify that with its dependency constraints, not a lock file.<br>&gt; <br>&gt; This I think is one big crux of the current discussion, and one of the things not in the proposal was my expectation that most packages right now are going to be shared (I personally wouldn&#39;t say libraries vs applications, since applications can also be shared as build tools, I think it comes down to whether it is shared or not).<br>&gt; <br>&gt; If we agree that a library shouldn&#39;t pin its dependencies, how would you surface this feature? What exact behavior would you prefer?<br>&gt; <br></p><p>Bundler, Composer, Cargo &amp; Yarn all ignore the lock file on dependencies and only use the one on the main build target so that they can solve the constraining problem. The final build target lock file does have the list of all exact version required for all the dependencies and sub-dependencies though for deterministic building of the final product. <br></p><p>This only works because they all take full advantage of semantic versioning anyway.<br></p><p>I particularly like Yehuda Katz&#39;s explanation on why it works this way: https://github.com/yarnpkg/yarn/issues/838#issuecomment-253362537 <br></p><p>Regards,<br></p><p>Rob...<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20161014/967c48f0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/14477c366d6ee4e41adf14837bc4f2f9?s=50"></div><header><strong>[swift-evolution] Proposal: Package Manager Version Pinning</strong> from <string>Ryan Lovelett</string> &lt;swift-dev at ryan.lovelett.me&gt;<p>October 14, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; I particularly like Yehuda Katz&#39;s explanation on why it works this<br>&gt; way: https://github.com/yarnpkg/yarn/issues/838#issuecomment-253362537<br></p><p>This was a powerful description for me. @Rob thank you for<br>providing that!<br></p><p> 1. The articulation of the purpose/philosophy behind the whole thing<br>    was really clear and made sense to me. Even though I&#39;ve never<br>    used Rust or Cargo. Nor have I ever run into any problems with<br>    npm such that I would prefer yarn over it. I&#39;ve used Bundler for<br>    years and love it.<br> 2. Yehuda Katz has been involved in making 3 different package managers<br>    for 3 different communities/languages over at least a 6-year span.<br>    It feels trite but it seems likely he has knowledge/experience we<br>    might not. It might be wise to seriously consider the wisdom of<br>    others with experience.<br></p><p>I will say that like others on this thread prefer determinism in<br>my builds.<br></p><p>Whatever path leads me there is the path I want to walk. I&#39;m not smart<br>enough to say if this proposal will preclude that or not. I am moved by<br>the notion that there are successful package managers out there as<br>examples which today achieve that goal.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20161014/93f69667/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d9baa679148bd83458d11df12327ce0?s=50"></div><header><strong>[swift-evolution] Proposal: Package Manager Version Pinning</strong> from <string>Daniel Dunbar</string> &lt;daniel_dunbar at apple.com&gt;<p>October 14, 2016 at 01:00:00pm</p></header><div class="content"><p>I&#39;m replying here as a proxy for a bunch of other messages, since it is the latest one when I started typing. :)<br></p><p>&gt; On Oct 14, 2016, at 12:40 PM, Ryan Lovelett &lt;swift-dev at ryan.lovelett.me&gt; wrote:<br>&gt; <br>&gt;&gt; I particularly like Yehuda Katz&#39;s explanation on why it works this way: https://github.com/yarnpkg/yarn/issues/838#issuecomment-253362537 &lt;https://github.com/yarnpkg/yarn/issues/838#issuecomment-253362537&gt; <br>&gt; <br>&gt; This was a powerful description for me. @Rob thank you for providing that!<br>&gt; <br>&gt; The articulation of the purpose/philosophy behind the whole thing was really clear and made sense to me. Even though I&#39;ve never used Rust or Cargo. Nor have I ever run into any problems with npm such that I would prefer yarn over it. I&#39;ve used Bundler for years and love it.<br>&gt; Yehuda Katz has been involved in making 3 different package managers for 3 different communities/languages over at least a 6-year span. It feels trite but it seems likely he has knowledge/experience we might not. It might be wise to seriously consider the wisdom of others with experience.<br>&gt; <br>&gt; I will say that like others on this thread prefer determinism in my builds.<br>&gt; <br>&gt; Whatever path leads me there is the path I want to walk. I&#39;m not smart enough to say if this proposal will preclude that or not. I am moved by the notion that there are successful package managers out there as examples which today achieve that goal. <br></p><p>Alexis, Huon and I just had an in person conversation about this thread, and I wanted to post a summary:<br></p><p>1. I think there is some confusion in the thread based on us not describing in the proposal exactly how the package manager *behaves today*, and the parts which we expected to be unchanged.<br></p><p>We effectively &quot;pin locally&quot; today, in the sense that we *never* update a dependency without the users involvement, and we all agree we should never ever ever ever do this. I don&#39;t personally understand how any tool would ever not do this, so I may have skipped over clarifying this. I&#39;m not sure if there was confusion on this point, but if so, hopefully that helps.<br></p><p>We also give you a way to &quot;see&quot; what you are pinned at with `swift package show-dependencies`.<br></p><p>What this proposal about is in one sense being able to export and share those pins.<br></p><p>2. Huon, Alexis, and I all agree we should never *inherit* pins by default.<br></p><p>3. Huon pointed out using &quot;shared&quot; to mean &quot;package intended to be used as a dependency&quot; isn&#39;t correct, since one might often share a package intended to just be built and used as a command line tool. OTOH, I personally don&#39;t care for library vs executable since executables can often be used as dependencies for server-side stuff, or as build tools.<br></p><p>4. We also all agree that there are effectively two very different workflows based on whether a package is intended to be a dependency.<br></p><p>We have three very interesting ecosystems:<br>	A. Using packages as macOS/iOS/etc app dependencies.<br>	B. Using packages for server-side Swift code.<br>	C. Using packages to directly build command line tools and applications you can install.<br></p><p>In (A), all packages are dependencies, so our emphasis is on workflows oriented towards that.<br></p><p>In (B), we expect somewhat more sophistication around management of the pin file (w.r.t. PaaS deployment, continuous delivery, etc.), and so Huon and I at least agreed it was somewhat irrelevant. Also, we expect that more people developing in this space will simultaneously be factoring out packages which are intended to be dependencies.<br></p><p>In (C), by definition the most interesting and heavily used (as in installed) packages are *not* generally dependencies.<br></p><p>Today, (A) is a huge focus, and (B) is the main current consumer of SwiftPM. (C) is very interesting, and many of us would love to us it, but the reality is I don&#39;t see many people doing development in this space versus simply publishing via Homebrew, etc. Given that, my position is that *most* of the ecosystem is oriented towards packages which are intended to be dependencies, and we should choose our defaults accordingly.<br></p><p>5. Given that many people agree there are two workflows (we ourselves had talked about this a lot when writing the proposal, but didn&#39;t put it in), we felt it makes sense to consider adding that as an explicit declaration *somewhere*.<br></p><p>@Eloy, @Orta: Suppose we had a semantic notion of which packages were intended to be &quot;top-level&quot; versus used as a dependency, and we chose our defaults accordingly (in this case, we would orient workflows towards pinning by default in the top-level case, in the used as a dependency case we would orient away from it, e.g. warning you if you checked it in). What would you think of such a design?<br></p><p> - Daniel<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20161014/cb96dcb7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/424a9ce662b059c35063b405e160461d?s=50"></div><header><strong>[swift-evolution] Proposal: Package Manager Version Pinning</strong> from <string>Eloy Durán</string> &lt;eloy.de.enige at gmail.com&gt;<p>October 14, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; 5. Given that many people agree there are two workflows (we ourselves had talked about this a lot when writing the proposal, but didn&#39;t put it in), we felt it makes sense to consider adding that as an explicit declaration *somewhere*.<br>&gt; <br>&gt; @Eloy, @Orta: Suppose we had a semantic notion of which packages were intended to be &quot;top-level&quot; versus used as a dependency, and we chose our defaults accordingly (in this case, we would orient workflows towards pinning by default in the top-level case, in the used as a dependency case we would orient away from it, e.g. warning you if you checked it in). What would you think of such a design?<br></p><p>Oooooooh, I like it.<br></p><p>Even though I would probably still pin/lock personally, I think this default combined with the explicit declaration strikes a perfect balance in trade-offs 👍<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f116cb3be23153ec08b94e8bd4dbcfeb?s=50"></div><header><strong>[swift-evolution] Proposal: Package Manager Version Pinning</strong> from <string>orta therox</string> &lt;orta.therox at gmail.com&gt;<p>October 14, 2016 at 10:00:00pm</p></header><div class="content"><p>Same, yeah 👍<br></p><p>&gt; On 14 Oct 2016, at 21:21, Eloy Durán via swift-build-dev &lt;swift-build-dev at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; 5. Given that many people agree there are two workflows (we ourselves had talked about this a lot when writing the proposal, but didn&#39;t put it in), we felt it makes sense to consider adding that as an explicit declaration *somewhere*.<br>&gt;&gt; <br>&gt;&gt; @Eloy, @Orta: Suppose we had a semantic notion of which packages were intended to be &quot;top-level&quot; versus used as a dependency, and we chose our defaults accordingly (in this case, we would orient workflows towards pinning by default in the top-level case, in the used as a dependency case we would orient away from it, e.g. warning you if you checked it in). What would you think of such a design?<br>&gt; <br>&gt; Oooooooh, I like it.<br>&gt; <br>&gt; Even though I would probably still pin/lock personally, I think this default combined with the explicit declaration strikes a perfect balance in trade-offs 👍<br>&gt; _______________________________________________<br>&gt; swift-build-dev mailing list<br>&gt; swift-build-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d9baa679148bd83458d11df12327ce0?s=50"></div><header><strong>[swift-evolution] Proposal: Package Manager Version Pinning</strong> from <string>Daniel Dunbar</string> &lt;daniel_dunbar at apple.com&gt;<p>October 14, 2016 at 02:00:00pm</p></header><div class="content"><p>Ok, great! We will discuss this some more and see what we can come up with.<br></p><p> - Daniel<br></p><p>&gt; On Oct 14, 2016, at 2:18 PM, orta therox &lt;orta.therox at gmail.com&gt; wrote:<br>&gt; <br>&gt; Same, yeah 👍<br>&gt; <br>&gt;&gt; On 14 Oct 2016, at 21:21, Eloy Durán via swift-build-dev &lt;swift-build-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; 5. Given that many people agree there are two workflows (we ourselves had talked about this a lot when writing the proposal, but didn&#39;t put it in), we felt it makes sense to consider adding that as an explicit declaration *somewhere*.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; @Eloy, @Orta: Suppose we had a semantic notion of which packages were intended to be &quot;top-level&quot; versus used as a dependency, and we chose our defaults accordingly (in this case, we would orient workflows towards pinning by default in the top-level case, in the used as a dependency case we would orient away from it, e.g. warning you if you checked it in). What would you think of such a design?<br>&gt;&gt; <br>&gt;&gt; Oooooooh, I like it.<br>&gt;&gt; <br>&gt;&gt; Even though I would probably still pin/lock personally, I think this default combined with the explicit declaration strikes a perfect balance in trade-offs 👍<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-build-dev mailing list<br>&gt;&gt; swift-build-dev at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br>&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>[swift-evolution] Proposal: Package Manager Version Pinning</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>October 14, 2016 at 06:00:00pm</p></header><div class="content"><p>Sorry for the late arrival to this thread. Comments below…<br></p><p>&gt; On Oct 14, 2016, at 3:09 PM, Daniel Dunbar via swift-build-dev &lt;swift-build-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; What this proposal about is in one sense being able to export and share those pins.<br></p><p>This is a crucial and clarifying insight. It should be in the proposal! Near the top.<br></p><p>&gt; 2. Huon, Alexis, and I all agree we should never *inherit* pins by default.<br></p><p>Indeed. Pins should be only be about sharing specific versions within a development team — not with client packages / apps. What’s pinned in Vegas stays in Vegas. Publishing pins to other projects would be nonsensical.<br></p><p>&gt; 5. Given that many people agree there are two workflows (we ourselves had talked about this a lot when writing the proposal, but didn&#39;t put it in), we felt it makes sense to consider adding that as an explicit declaration *somewhere*.<br>&gt; <br>&gt; @Eloy, @Orta: Suppose we had a semantic notion of which packages were intended to be &quot;top-level&quot; versus used as a dependency, and we chose our defaults accordingly (in this case, we would orient workflows towards pinning by default in the top-level case, in the used as a dependency case we would orient away from it, e.g. warning you if you checked it in). What would you think of such a design?<br></p><p>I’m puzzled. If a package’s pinning does not affect any other package that uses it, why should the defaults be different? A library will still suffer from all the “works for me” problems an app might.<br></p><p>Is the rationale that not pinning libraries encourages accidental testing of new versions of a library’s dependencies as they arrive? Or is there another rationale for having different defaults?<br></p><p>Cheers, P<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/424a9ce662b059c35063b405e160461d?s=50"></div><header><strong>[swift-evolution] Proposal: Package Manager Version Pinning</strong> from <string>Eloy Durán</string> &lt;eloy.de.enige at gmail.com&gt;<p>October 15, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; I’m puzzled. If a package’s pinning does not affect any other package that uses it, why should the defaults be different? A library will still suffer from all the “works for me” problems an app might.<br>&gt; <br>&gt; Is the rationale that not pinning libraries encourages accidental testing of new versions of a library’s dependencies as they arrive?<br></p><p>Yep.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20161015/2591f28e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>[swift-evolution] Proposal: Package Manager Version Pinning</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>October 14, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Oct 14, 2016, at 6:34 PM, Eloy Durán &lt;eloy.de.enige at gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; I’m puzzled. If a package’s pinning does not affect any other package that uses it, why should the defaults be different? A library will still suffer from all the “works for me” problems an app might.<br>&gt;&gt; <br>&gt;&gt; Is the rationale that not pinning libraries encourages accidental testing of new versions of a library’s dependencies as they arrive?<br>&gt; <br>&gt; Yep.<br></p><p>I’m skeptical of whether disabling pinning by default is the right answer. It seems … haphazard and incomplete, likely to confuse those who don’t understand this reasoning, and only incidentally helpful to those who do.<br></p><p>I’d prefer an approach that is more mindful, more intentional.<br></p><p>Emitting warnings when newer versions of packages are available would help address the same issue. This would also encourage apps to get security patches promptly.<br></p><p>A more ambitious approach might be to provide a utility that installs and tests various combinations of all the semantically allowed versions of a lib’s dependencies — at the very least, all the lowest and highest allowed versions. This would ignore any existing pinfile. Library devs would run this prior to release, and on a CI server if they have one.<br></p><p>This would have the advantage of catching incompatibilities with _past_ versions of libraries as well as _new_ ones. In particular, it would catch too-permissive version specifications, e.g. if your library asks for foolib 3.x but relies on a bugfix in 3.4.2, this approach would catch that problem.<br></p><p>That’s clearly a bigger, separate idea, not necessary to hash out right now. I mean it just to illustrate what better approaches might look like. I’m skeptical that simply disabling pinning does a good job of solving the intended problem, and don’t think it should weigh quite so heavily on the proposal at hand.<br></p><p>Cheers,<br></p><p>Paul<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d9baa679148bd83458d11df12327ce0?s=50"></div><header><strong>[swift-evolution] Proposal: Package Manager Version Pinning</strong> from <string>Daniel Dunbar</string> &lt;daniel_dunbar at apple.com&gt;<p>October 14, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Oct 14, 2016, at 4:51 PM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Oct 14, 2016, at 6:34 PM, Eloy Durán &lt;eloy.de.enige at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; I’m puzzled. If a package’s pinning does not affect any other package that uses it, why should the defaults be different? A library will still suffer from all the “works for me” problems an app might.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Is the rationale that not pinning libraries encourages accidental testing of new versions of a library’s dependencies as they arrive?<br>&gt;&gt; <br>&gt;&gt; Yep.<br>&gt; <br>&gt; I’m skeptical of whether disabling pinning by default is the right answer. It seems … haphazard and incomplete, likely to confuse those who don’t understand this reasoning, and only incidentally helpful to those who do.<br>&gt; <br>&gt; I’d prefer an approach that is more mindful, more intentional.<br>&gt; <br>&gt; Emitting warnings when newer versions of packages are available would help address the same issue. This would also encourage apps to get security patches promptly.<br>&gt; <br>&gt; A more ambitious approach might be to provide a utility that installs and tests various combinations of all the semantically allowed versions of a lib’s dependencies — at the very least, all the lowest and highest allowed versions. This would ignore any existing pinfile. Library devs would run this prior to release, and on a CI server if they have one.<br>&gt; <br>&gt; This would have the advantage of catching incompatibilities with _past_ versions of libraries as well as _new_ ones. In particular, it would catch too-permissive version specifications, e.g. if your library asks for foolib 3.x but relies on a bugfix in 3.4.2, this approach would catch that problem.<br>&gt; <br>&gt; That’s clearly a bigger, separate idea, not necessary to hash out right now. I mean it just to illustrate what better approaches might look like. I’m skeptical that simply disabling pinning does a good job of solving the intended problem, and don’t think it should weigh quite so heavily on the proposal at hand.<br></p><p>The current idea wouldn&#39;t &quot;disable it&quot;, it would discourage you from checking it in for a library (it really comes down to you have to run two commands, not one). I agree all the other things you outline are useful, and that not checking it in doesn&#39;t magically solve the problem here.<br></p><p> - Daniel<br></p><p>&gt; <br>&gt; Cheers,<br>&gt; <br>&gt; Paul<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://urldefense.proofpoint.com/v2/url?u=https-3A__lists.swift.org_mailman_listinfo_swift-2Devolution&amp;d=CwIGaQ&amp;c=Hw-EJUFt2_D9PK5csBJ29kRV40HqSDXWTLPyZ6W8u84&amp;r=teZCCTj9bCvNJ4SX_xKQ4SOVlaMWK9IXMlx_HMapKUU&amp;m=wl9y8ecLDwSW83LjsOje4Jz1_TjqamVYnv-lTnVooiI&amp;s=ICIfe-G4A6ZgJyiYYtMnHpq6JKQpHA5nhxc8nG4GxhY&amp;e=<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>[swift-evolution] Proposal: Package Manager Version Pinning</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>October 14, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Oct 14, 2016, at 7:18 PM, Daniel Dunbar &lt;daniel_dunbar at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Oct 14, 2016, at 4:51 PM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; That’s clearly a bigger, separate idea, not necessary to hash out right now. I mean it just to illustrate what better approaches might look like. I’m skeptical that simply disabling pinning does a good job of solving the intended problem, and don’t think it should weigh quite so heavily on the proposal at hand.<br>&gt; <br>&gt; The current idea wouldn&#39;t &quot;disable it”<br></p><p>Right, my bad wording. Is “turn off / discourage pinfiles by default for libraries but not apps” a better description of the general idea?<br></p><p>&gt; it would discourage you from checking it in for a library (it really comes down to you have to run two commands, not one). I agree all the other things you outline are useful, and that not checking it in doesn&#39;t magically solve the problem here.<br></p><p><br>If the difference were only what’s in .gitignore, I’d be completely comfortable with that. Enthusiastic.<br></p><p>And if there’s some distinction between libs and top-level packages that only affects a generated .gitignore and/or emitted warnings, I’d be completely comfortable with that.<br></p><p>I’m skeptical of deeper special-casing for libs vs. top-level, but it sounds like the special-casing may not actually be that deep. If so, I’m just fussing over nothing!<br></p><p>&gt; On Oct 14, 2016, at 7:17 PM, Alexis Beingessner &lt;abeingessner at apple.com&gt; wrote:<br>&gt; <br>&gt; A few comments down, Yehuda even provides an example of him doing just that with Bundler:<br>&gt; <br>&gt; https://github.com/yarnpkg/yarn/issues/838#issuecomment-253366352 &lt;https://github.com/yarnpkg/yarn/issues/838#issuecomment-253366352&gt;<br>Yeah, I’d love to see SwiftPM or a companion tool automate that. Totally tractable problem, and I’ll bet we see quality payoffs in the lib ecosystem.<br></p><p>Cheers,<br></p><p>Paul<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20161014/727cda08/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d9baa679148bd83458d11df12327ce0?s=50"></div><header><strong>[swift-evolution] Proposal: Package Manager Version Pinning</strong> from <string>Daniel Dunbar</string> &lt;daniel_dunbar at apple.com&gt;<p>October 14, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Oct 14, 2016, at 4:02 PM, Paul Cantrell &lt;cantrell at pobox.com&gt; wrote:<br>&gt; <br>&gt; Sorry for the late arrival to this thread. Comments below…<br>&gt; <br>&gt;&gt; On Oct 14, 2016, at 3:09 PM, Daniel Dunbar via swift-build-dev &lt;swift-build-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; What this proposal about is in one sense being able to export and share those pins.<br>&gt; <br>&gt; This is a crucial and clarifying insight. It should be in the proposal! Near the top.<br></p><p>Good idea, will incorporate it.<br></p><p>&gt;&gt; 2. Huon, Alexis, and I all agree we should never *inherit* pins by default.<br>&gt; <br>&gt; Indeed. Pins should be only be about sharing specific versions within a development team — not with client packages / apps. What’s pinned in Vegas stays in Vegas. Publishing pins to other projects would be nonsensical.<br>&gt; <br>&gt;&gt; 5. Given that many people agree there are two workflows (we ourselves had talked about this a lot when writing the proposal, but didn&#39;t put it in), we felt it makes sense to consider adding that as an explicit declaration *somewhere*.<br>&gt;&gt; <br>&gt;&gt; @Eloy, @Orta: Suppose we had a semantic notion of which packages were intended to be &quot;top-level&quot; versus used as a dependency, and we chose our defaults accordingly (in this case, we would orient workflows towards pinning by default in the top-level case, in the used as a dependency case we would orient away from it, e.g. warning you if you checked it in). What would you think of such a design?<br>&gt; <br>&gt; I’m puzzled. If a package’s pinning does not affect any other package that uses it, why should the defaults be different? A library will still suffer from all the “works for me” problems an app might.<br>&gt; <br>&gt; Is the rationale that not pinning libraries encourages accidental testing of new versions of a library’s dependencies as they arrive? Or is there another rationale for having different defaults?<br></p><p>I&#39;ll defer to this comment (linked from someone else earlier in the thread), which happens to match up with my perspective:<br>  https://github.com/yarnpkg/yarn/issues/838#issuecomment-253362537<br></p><p> - Daniel<br></p><p>&gt; <br>&gt; Cheers, P<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>[swift-evolution] Proposal: Package Manager Version Pinning</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>October 14, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Oct 14, 2016, at 6:42 PM, Daniel Dunbar &lt;daniel_dunbar at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Oct 14, 2016, at 4:02 PM, Paul Cantrell &lt;cantrell at pobox.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I’m puzzled. If a package’s pinning does not affect any other package that uses it, why should the defaults be different? A library will still suffer from all the “works for me” problems an app might.<br>&gt;&gt; <br>&gt;&gt; Is the rationale that not pinning libraries encourages accidental testing of new versions of a library’s dependencies as they arrive? Or is there another rationale for having different defaults?<br>&gt; <br>&gt; I&#39;ll defer to this comment (linked from someone else earlier in the thread), which happens to match up with my perspective:<br>&gt;  https://github.com/yarnpkg/yarn/issues/838#issuecomment-253362537<br></p><p>I took that comment to be an explanation of why a library&#39;s lockfile/pinfile should not propagate to other packages that use it. That is clearly the case; such pin propagation would be nonsensical.<br></p><p>My question was not about that, but about why libraries shouldn’t use a pinfile at all, even for their own _internal_ development. All the same “last know good build” concerns apply.<br></p><p>The difference is that testing against that single last known good version set is sufficient for a top-level package, whereas a library should (1) ideally test against multiple valid dependency versions and (2) test often against new versions of its dependencies. I don’t see, however, that this implies that libraries should not have pinfiles at all — just that their release / CI process should not be limited to what’s pinned.<br></p><p>Cheers, P<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6b81089e81d6bb1e14b5adb746725de1?s=50"></div><header><strong>[swift-evolution] Proposal: Package Manager Version Pinning</strong> from <string>Alexis</string> &lt;abeingessner at apple.com&gt;<p>October 14, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Oct 14, 2016, at 8:00 PM, Paul Cantrell &lt;cantrell at pobox.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Oct 14, 2016, at 6:42 PM, Daniel Dunbar &lt;daniel_dunbar at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Oct 14, 2016, at 4:02 PM, Paul Cantrell &lt;cantrell at pobox.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m puzzled. If a package’s pinning does not affect any other package that uses it, why should the defaults be different? A library will still suffer from all the “works for me” problems an app might.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Is the rationale that not pinning libraries encourages accidental testing of new versions of a library’s dependencies as they arrive? Or is there another rationale for having different defaults?<br>&gt;&gt; <br>&gt;&gt; I&#39;ll defer to this comment (linked from someone else earlier in the thread), which happens to match up with my perspective:<br>&gt;&gt; https://github.com/yarnpkg/yarn/issues/838#issuecomment-253362537<br>&gt; <br>&gt; I took that comment to be an explanation of why a library&#39;s lockfile/pinfile should not propagate to other packages that use it. That is clearly the case; such pin propagation would be nonsensical.<br>&gt; <br>&gt; My question was not about that, but about why libraries shouldn’t use a pinfile at all, even for their own _internal_ development. All the same “last know good build” concerns apply.<br>&gt; <br>&gt; The difference is that testing against that single last known good version set is sufficient for a top-level package, whereas a library should (1) ideally test against multiple valid dependency versions and (2) test often against new versions of its dependencies. I don’t see, however, that this implies that libraries should not have pinfiles at all — just that their release / CI process should not be limited to what’s pinned.<br></p><p>A few comments down, Yehuda even provides an example of him doing just that with Bundler:<br></p><p>https://github.com/yarnpkg/yarn/issues/838#issuecomment-253366352<br></p><p>But in this case you actually want to maintain *many* lock files, and so it seems fine to require a bit of extra work (passing some flags) to do this. Drifting tests are the better default here. It makes library CI into an alpha-tester, empowering binaries to be more confident in upgrading frequently.<br></p><p>&gt; <br>&gt; Cheers, P<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20161014/26718222/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d9baa679148bd83458d11df12327ce0?s=50"></div><header><strong>[swift-evolution] Proposal: Package Manager Version Pinning</strong> from <string>Daniel Dunbar</string> &lt;daniel_dunbar at apple.com&gt;<p>October 31, 2016 at 02:00:00pm</p></header><div class="content"><p>Thanks everyone who participated in this discussion.<br></p><p>We took the feedback on this thread and went back and created a revised proposal, here:<br>  https://github.com/apple/swift-evolution/blob/master/proposals/0145-package-manager-version-pinning.md<br>which we are putting up for review today:<br>  https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20161031/028579.html<br></p><p>Ultimately, we decided to not actually change any of the proposed behavior, *for now*, because we couldn&#39;t come to a consensus about how that should look.<br></p><p>What we *did* do is try and write up much more about (a) the current behavior, and (b) the motivation behind the decisions (for example, the implications of not being able to include multiple versions of the same package in one build).<br></p><p>What we also agreed on was that the main thing we need right now is to implement the *mechanisms* in the proposal, and we didn&#39;t want the debate over the policy decision (to create the pin file by default) to side track that. So we decided to continue with the proposal as is, but to also reevaluate the impact of the policy decision in the proposal, in time to adjust it for Swift 4 if we decide the way it has played out in the ecosystem so far isn&#39;t as intended.<br></p><p>We also agreed there was room for a workflow component around specifying the &quot;style&quot; of package being developed (final application versus something being primarily developed for use as a dependency), but we didn&#39;t want to block implementation of the mechanism on figuring out the right design for that. If we get a design for that, we will also probably use that to change the default policy here.<br></p><p>Please take a look at the new proposal, and see what you think.<br></p><p>Thanks,<br> - Daniel<br></p><p>&gt; On Oct 14, 2016, at 4:42 PM, Daniel Dunbar via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 14, 2016, at 4:02 PM, Paul Cantrell &lt;cantrell at pobox.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Sorry for the late arrival to this thread. Comments below…<br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 14, 2016, at 3:09 PM, Daniel Dunbar via swift-build-dev &lt;swift-build-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What this proposal about is in one sense being able to export and share those pins.<br>&gt;&gt; <br>&gt;&gt; This is a crucial and clarifying insight. It should be in the proposal! Near the top.<br>&gt; <br>&gt; Good idea, will incorporate it.<br>&gt; <br>&gt;&gt;&gt; 2. Huon, Alexis, and I all agree we should never *inherit* pins by default.<br>&gt;&gt; <br>&gt;&gt; Indeed. Pins should be only be about sharing specific versions within a development team — not with client packages / apps. What’s pinned in Vegas stays in Vegas. Publishing pins to other projects would be nonsensical.<br>&gt;&gt; <br>&gt;&gt;&gt; 5. Given that many people agree there are two workflows (we ourselves had talked about this a lot when writing the proposal, but didn&#39;t put it in), we felt it makes sense to consider adding that as an explicit declaration *somewhere*.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; @Eloy, @Orta: Suppose we had a semantic notion of which packages were intended to be &quot;top-level&quot; versus used as a dependency, and we chose our defaults accordingly (in this case, we would orient workflows towards pinning by default in the top-level case, in the used as a dependency case we would orient away from it, e.g. warning you if you checked it in). What would you think of such a design?<br>&gt;&gt; <br>&gt;&gt; I’m puzzled. If a package’s pinning does not affect any other package that uses it, why should the defaults be different? A library will still suffer from all the “works for me” problems an app might.<br>&gt;&gt; <br>&gt;&gt; Is the rationale that not pinning libraries encourages accidental testing of new versions of a library’s dependencies as they arrive? Or is there another rationale for having different defaults?<br>&gt; <br>&gt; I&#39;ll defer to this comment (linked from someone else earlier in the thread), which happens to match up with my perspective:<br>&gt;  https://github.com/yarnpkg/yarn/issues/838#issuecomment-253362537<br>&gt; <br>&gt; - Daniel<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Cheers, P<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eb0d0358af1f99d8dc5970844e5b8180?s=50"></div><header><strong>[swift-evolution] Proposal: Package Manager Version Pinning</strong> from <string>Martin Waitz</string> &lt;tali at admingilde.org&gt;<p>November  1, 2016 at 10:00:00am</p></header><div class="content"><p>Hi,<br></p><p>&gt; Suppose we had a semantic notion of which packages were intended to be &quot;top-level&quot; versus used as a dependency, and we chose our defaults accordingly (in this case, we would orient workflows towards pinning by default in the top-level case, in the used as a dependency case we would orient away from it, e.g. warning you if you checked it in). What would you think of such a design?<br></p><p>What is wrong with checking in the versions of your dependencies even if you are not a top-level package?<br>That’s a great way to document which versions do work together and may be helpful for the maintainer of the top-level package which is depending on you (he can easily compare the version files to find problems).<br></p><p>I think we agree that `swift package` within the top-level project should not look at the Package version files of its dependencies.<br>So these files will not change anything for the top-level builds.<br></p><p>I really think that the easiest solution is to always store the versions of all dependencies in SCM.<br>Then have some `swift package update` to move all versions to the latest consistent set and we have everything we need.<br>Each package can be built reproducibly and can be managed independently.<br></p><p>If packages want to track their dependencies closely, then simply set up some CI which does the update automatically.<br>You could automatically create create ‚update‘-commits, test them and automatically merge them if you really want to.<br>But every update is documented and you can even bisect bugs which were introduced by the updates.<br>This is helpful both for top-level as well as for library projects.<br></p><p>— Martin<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6a744f8bdd4a2b48c2cdde04d9bacc0b?s=50"></div><header><strong>[swift-evolution] Proposal: Package Manager Version Pinning</strong> from <string>Huon Wilson</string> &lt;huon_wilson at apple.com&gt;<p>October 14, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Oct 14, 2016, at 09:43, Alexis via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; A library shouldn’t pin its dependencies, while an application should.<br></p><p>Not only “shouldn’t” but can’t: Rust’s cargo (I don’t know for sure about Bundler and Yarn, but they’re all in the same vein, and pretty much from the same person) will just ignore any non-top-level lock files, i.e. the package that user is working on has a record of the exact versions of everything in their dependency graph, and the user can update all or just parts of that graph fairly precisely, as desired.<br></p><p>My impression is that other ecosystems without pinning-by-default have seriously suffered from the lack of reliable reproducible builds. For instance, a major complaint I have seen about &quot;go get” is that one can come back to some code after a few months to fix a minor bug and have no chance of getting the code to compile, basically just requiring a full rewrite, because dependencies&#39; code has changed (or disappeared entirely) and there’s no record of what the original was, despite your code being completely untouched in all that time. Of course, a hard push towards API-level semantic versioning may allay the worst of the code-changing problems, but unless there’s going to be some seriously fancy static analysis (something something halting problem), there will be a lot of breaking changes that can’t be picked up.<br></p><p>---<br></p><p>To reframe the discussion slightly, not pinning dependencies effectively means that the tools are making “random&quot; changes to your code outside your control. Sure, those changes were transitively made by possibly-computer-assisted humans and may fix bugs, but those pesky meat-bags can still make mistakes, and, they don’t see the interactions between all the different packages in your specific application.<br></p><p>IME having the predictability of “never changing code under my feet” combined with pervasive semantic versioning hits an empowering middle ground of being able to depend on many &amp; varied packages and update them to the latest versions without fear (for one, it’s easy to revert the lock file if something breaks during an update). Feedback from others about cargo is the same, often along the lines of “it’s the best package manager I’ve ever used”.<br></p><p>Also, more on the side of implementation details, having a lock file by default probably mean one can (get closer to) never hitting the network unless the user asks for it, making working offline or on a low-speed/high-latency connection easier, i.e. no need to check for new versions of the whole dependency graph on O(every) build, which aggressively keeping everything up to date would seemingly have to do? (I don’t know swift-pm’s current behavior here, so maybe there’s some tricks that avoid it.)<br></p><p>Huon<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20161014/6aa6fb77/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
