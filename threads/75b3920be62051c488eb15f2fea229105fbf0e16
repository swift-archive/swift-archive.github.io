<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4882618e75f402b2726bf3ac5d0a31c5?s=50"></div><header><strong>Provide native Decimal data type</strong> from <string>Teej .</string> &lt;tjg42work at yahoo.com&gt;<p>September 12, 2016 at 10:00:00am</p></header><div class="content"><p>Please forgive me if this have already been hashed out.  Google and DuckDuckGo have not been helpful in my research, and the archives do not have a search functionality.<br></p><p>	I am new to Swift, and starting from 3.0 beta.  I am aware that the language is not stabilized, so I feel this is an opportunity to introduce a native data type.<br></p><p>	Over history, data types typically follows what the CPU supports, so hence the int/float datatypes.  char/String is technically an integer/array of integers under the hood (and unicode-supported Strings are a bit more complicated than that).  Among customers I work with, data accuracy is very important.  So when the only option for a value with a fractional portion does not guarantee data accuracy, such as:<br></p><p>return 3.0 * sideLength - 9.300000000001<br></p><p>	It gives us pause, as floating point numbers are always understood to be inaccurate, and the whole song and dance required to truncate/round the number to ensure accurate results make our financial customers very nervous.  They want accuracy from the start and whenever they audit the results in the middle of the process, they expect to see a 9.3 on the dot.  <br></p><p>	Having a native Decimal datatype would ensure that we have a consistent handling option for pulling and putting data to databases.  Having worked with APT_Decimal within Orchestrate/PX Engine, I know we can do a better job if we could leverage the speed of float, but somehow ensure that even with that speed, we preserve the accuracy of the actual data in spite of the CPU’s quirks in handling floating point numbers in a maddening inaccurate manner.<br></p><p>	Is there any particular reason why we do not have a native Decimal data type for Swift?  <br></p><p>-T.J.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160912/75b30e16/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>Provide native Decimal data type</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>September 12, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Sep 12, 2016, at 10:10 AM, Teej . via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; 	…in spite of the CPU’s quirks in handling floating point numbers in a maddening inaccurate manner.<br></p><p>Well, in the CPU’s defense, it’s only inaccurate because the puny humans insist on dividing their currency into fractions of 1/10, which has no exact representation in binary. (Apparently this is an ancient tradition commemorating the number of bony outgrowths on certain extremities of their grotesque meat-bodies.) I could — I mean, the computers could — point out that if we divided our currency units into 7 pieces, our precious decimal numbers would quickly become inaccurate too. :)<br></p><p>&gt; 	Is there any particular reason why we do not have a native Decimal data type for Swift?  <br></p><p>Cocoa’s Foundation framework has an NSDecimalNumber class that provides decimal numbers and arithmetic. The class docs for that include a note that &quot;The Swift overlay to the Foundation framework provides the Decimal structure, which bridges to the NSDecimalNumber class. The Decimalvalue type offers the same functionality as the NSDecimalNumberreference type, and the two can be used interchangeably in Swift code that interacts with Objective-C APIs.&quot;<br></p><p>The question is whether this has been ported to the in-progress native Swift foundation library yet. I haven’t checked.<br></p><p>—Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160912/f03a0779/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4882618e75f402b2726bf3ac5d0a31c5?s=50"></div><header><strong>Provide native Decimal data type</strong> from <string>Teej .</string> &lt;tjg42work at yahoo.com&gt;<p>September 12, 2016 at 10:00:00am</p></header><div class="content"><p>I agree on your point — base-10 notation is not compatible with a base-2 infrastructure.  However, that is just exposing the reality of the floating point data type.  It still does not answer my question on why we can’t just provide a decimal data type.  <br></p><p>I am aware of the NSDecimalNumber class.  But that is a layer on top of the core language, and not very performant relatively speaking - at least I would presume?  Please correct me if I am wrong.<br></p><p>-T.J.<br></p><p><br>&gt; On Sep 12, 2016, at 10:26, Jens Alfke &lt;jens at mooseyard.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Sep 12, 2016, at 10:10 AM, Teej . via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; 	…in spite of the CPU’s quirks in handling floating point numbers in a maddening inaccurate manner.<br>&gt; <br>&gt; Well, in the CPU’s defense, it’s only inaccurate because the puny humans insist on dividing their currency into fractions of 1/10, which has no exact representation in binary. (Apparently this is an ancient tradition commemorating the number of bony outgrowths on certain extremities of their grotesque meat-bodies.) I could — I mean, the computers could — point out that if we divided our currency units into 7 pieces, our precious decimal numbers would quickly become inaccurate too. :)<br>&gt; <br>&gt;&gt; 	Is there any particular reason why we do not have a native Decimal data type for Swift?  <br>&gt; <br>&gt; Cocoa’s Foundation framework has an NSDecimalNumber class that provides decimal numbers and arithmetic. The class docs for that include a note that &quot;The Swift overlay to the Foundation framework provides the Decimal structure, which bridges to the NSDecimalNumber class. The Decimalvalue type offers the same functionality as the NSDecimalNumberreference type, and the two can be used interchangeably in Swift code that interacts with Objective-C APIs.&quot;<br>&gt; <br>&gt; The question is whether this has been ported to the in-progress native Swift foundation library yet. I haven’t checked.<br>&gt; <br>&gt; —Jens<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160912/516acd95/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>Provide native Decimal data type</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>September 12, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Sep 12, 2016, at 1:26 PM, Jens Alfke via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Sep 12, 2016, at 10:10 AM, Teej . via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; 	…in spite of the CPU’s quirks in handling floating point numbers in a maddening inaccurate manner.<br>&gt; <br>&gt; Well, in the CPU’s defense, it’s only inaccurate because the puny humans insist on dividing their currency into fractions of 1/10, which has no exact representation in binary. (Apparently this is an ancient tradition commemorating the number of bony outgrowths on certain extremities of their grotesque meat-bodies.) I could — I mean, the computers could — point out that if we divided our currency units into 7 pieces, our precious decimal numbers would quickly become inaccurate too. :)<br></p><p>Expanding a bit on what Jens wrote here: decimal (unlike friendship) is not magic.  All computer models of real-number arithmetic are necessarily inexact, because (almost all) real numbers are not computable.  There are a bunch of reasonable choices that one can make, however (this is not an exhaustive list, just a sampling of the design space):<br></p><p>Binary floating point<br>Pro: represents modest integers exactly, extremely fast hardware implementations, fixed memory size, and rounding errors are extremely uniform—they don’t vary much with the number being represented.<br>Con: almost no decimal fractions have exact representations.<br></p><p>Decimal floating point<br>Pro: represents modest integers and decimal fractions exactly, slower than binary but still faster than almost anything else, fixed memory size.<br>Con: at least an order of magnitude slower than binary floating-point, and rounding error is significantly less scale-invariant.<br></p><p>Fixed-size rationals<br>Pro: represents all modestly-sized integers and fractions exactly, fixed memory size, four basic operations are exact until you hit the limits of representation.<br>Con: denominators quickly grow too quickly to be used for non-trivial computations (this is usually a deal-breaker).<br></p><p>Arbitrary-precision rationals<br>Pro: closed under four basic operations, represents most numbers most people will use exactly.<br>Con: representations get extremely large extremely quickly, large memory footprint if you have more than a few numbers.<br></p><p>Computable real numbers<br>Pro: any number you can describe, you can work with.<br>Con: your numbers are now computer programs, and you arithmetic system is Turing-complete.  Testing for equality is equivalent to solving the halting problem.<br></p><p>&gt; Teej . via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt; <br></p><p>&gt; It still does not answer my question on why we can’t just provide a decimal data type.<br></p><p>The only problem here is the “just”.  We can and will provide a decimal data type.  Like many other language changes, that we can and will do, it requires engineering time, and there are finite engineering resources available to work on it.<br></p><p>Keep in mind that decimal will not magically solve all accuracy problems, however.  1/3 is just as inaccurate in decimal as it is in binary floating-point (actually, it’s less accurate in decimal than in a comparable binary format due to the aforementioned non-uniformity of decimal rounding error).<br></p><p>– Steve<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160912/92d110b6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4c60436f08b7b107f0bb0848c31297fa?s=50"></div><header><strong>Provide native Decimal data type</strong> from <string>Alex Blewitt</string> &lt;alblue at apple.com&gt;<p>September 13, 2016 at 09:00:00am</p></header><div class="content"><p>Regarding Decimal - it&#39;s not yet implemented on Linux, but it&#39;s a work in progress.<br></p><p>Alex<br></p><p>&gt; On 12 Sep 2016, at 18:49, Stephen Canon via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Sep 12, 2016, at 1:26 PM, Jens Alfke via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Sep 12, 2016, at 10:10 AM, Teej . via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	…in spite of the CPU’s quirks in handling floating point numbers in a maddening inaccurate manner.<br>&gt;&gt; <br>&gt;&gt; Well, in the CPU’s defense, it’s only inaccurate because the puny humans insist on dividing their currency into fractions of 1/10, which has no exact representation in binary. (Apparently this is an ancient tradition commemorating the number of bony outgrowths on certain extremities of their grotesque meat-bodies.) I could — I mean, the computers could — point out that if we divided our currency units into 7 pieces, our precious decimal numbers would quickly become inaccurate too. :)<br>&gt; <br>&gt; Expanding a bit on what Jens wrote here: decimal (unlike friendship) is not magic.  All computer models of real-number arithmetic are necessarily inexact, because (almost all) real numbers are not computable.  There are a bunch of reasonable choices that one can make, however (this is not an exhaustive list, just a sampling of the design space):<br>&gt; <br>&gt; Binary floating point<br>&gt; Pro: represents modest integers exactly, extremely fast hardware implementations, fixed memory size, and rounding errors are extremely uniform—they don’t vary much with the number being represented.<br>&gt; Con: almost no decimal fractions have exact representations.<br>&gt; <br>&gt; Decimal floating point<br>&gt; Pro: represents modest integers and decimal fractions exactly, slower than binary but still faster than almost anything else, fixed memory size.<br>&gt; Con: at least an order of magnitude slower than binary floating-point, and rounding error is significantly less scale-invariant.<br>&gt; <br>&gt; Fixed-size rationals<br>&gt; Pro: represents all modestly-sized integers and fractions exactly, fixed memory size, four basic operations are exact until you hit the limits of representation.<br>&gt; Con: denominators quickly grow too quickly to be used for non-trivial computations (this is usually a deal-breaker).<br>&gt; <br>&gt; Arbitrary-precision rationals<br>&gt; Pro: closed under four basic operations, represents most numbers most people will use exactly.<br>&gt; Con: representations get extremely large extremely quickly, large memory footprint if you have more than a few numbers.<br>&gt; <br>&gt; Computable real numbers<br>&gt; Pro: any number you can describe, you can work with.<br>&gt; Con: your numbers are now computer programs, and you arithmetic system is Turing-complete.  Testing for equality is equivalent to solving the halting problem.<br>&gt; <br>&gt;&gt; Teej . via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt; <br>&gt;&gt; It still does not answer my question on why we can’t just provide a decimal data type.<br>&gt; <br>&gt; The only problem here is the “just”.  We can and will provide a decimal data type.  Like many other language changes, that we can and will do, it requires engineering time, and there are finite engineering resources available to work on it.<br>&gt; <br>&gt; Keep in mind that decimal will not magically solve all accuracy problems, however.  1/3 is just as inaccurate in decimal as it is in binary floating-point (actually, it’s less accurate in decimal than in a comparable binary format due to the aforementioned non-uniformity of decimal rounding error).<br>&gt; <br>&gt; – Steve<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160913/16cf2ac0/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
