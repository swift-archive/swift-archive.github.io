<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>Trial balloon: Ensure that String always contains valid Unicode</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>December 18, 2015 at 03:00:00pm</p></header><div class="content"><p>I was quite surprised to learn that it’s possible to create Swift strings that do not contain things other than valid Unicode characters. Is it feasible to guarantee that this cannot happen?<br></p><p>String.init(bytes:encoding:) is failable, and does in fact validate that the given bytes are decodable with the given encoding in most circumstances:<br></p><p>    // Returns nil<br>    String(<br>        bytes: [0xD8, 0x00] as [UInt8],<br>        encoding: NSUTF8StringEncoding)<br></p><p>However, that initializer does not reject invalid surrogate characters in UTF-16:<br></p><p>    // Succeeds (wat?!)<br>    let bogusStr = String(<br>        bytes: [0xD8, 0x00] as [UInt8],<br>        encoding: NSUTF16BigEndianStringEncoding)!<br></p><p>Ever wonder why dataWithJSONObject(…) is declared “throws?” Now you know!<br></p><p>    // Throws an error<br>    try! NSJSONSerialization.dataWithJSONObject(<br>        [&quot;foo&quot;: bogusStr], options: [])<br></p><p>And why does the URL escaping method in Foundation return an optional even though it escapes the string using UTF-8, which is a complete Unicode encoding? Same reason:<br>    // Returns nil<br>    bogusStr.stringByAddingPercentEncodingWithAllowedCharacters(<br>        NSCharacterSet.alphanumericCharacterSet())<br></p><p>AFAIK, the first method could lose its “throws” modifier and the second method would not need to return an optional if only String itself guaranteed that it would always contain valid Unicode. There are likely other APIs that would see similar benefits.<br></p><p>Are there downsides to making all String initializers guarantee that the Strings always contain valid Unicode? I can think of two possibilities:<br></p><p>Is there some circumstance where you actually want a String to contain unpaired UTF-16 surrogate characters? I can’t imagine what that would be, but perhaps someone else can.<br>Is it important to ensure that String.init(…) is O(1) when it uses UTF-16? This seems thin: I assume that the library has to copy the raw bytes regardless, and it’s O(n) for other character encodings, so…?<br></p><p>Cheers,<br></p><p>Paul<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/85d82068/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>Trial balloon: Ensure that String always contains valid Unicode</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>December 18, 2015 at 03:00:00pm</p></header><div class="content"><p>Er, typo in the first sentence! I meant to say:<br></p><p>I was quite surprised to learn that it’s possible to create Swift strings that contain things other than valid Unicode characters.<br></p><p><br>&gt; On Dec 18, 2015, at 3:47 PM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I was quite surprised to learn that it’s possible to create Swift strings that do not contain things other than valid Unicode characters. Is it feasible to guarantee that this cannot happen?<br>&gt; <br>&gt; String.init(bytes:encoding:) is failable, and does in fact validate that the given bytes are decodable with the given encoding in most circumstances:<br>&gt; <br>&gt;     // Returns nil<br>&gt;     String(<br>&gt;         bytes: [0xD8, 0x00] as [UInt8],<br>&gt;         encoding: NSUTF8StringEncoding)<br>&gt; <br>&gt; However, that initializer does not reject invalid surrogate characters in UTF-16:<br>&gt; <br>&gt;     // Succeeds (wat?!)<br>&gt;     let bogusStr = String(<br>&gt;         bytes: [0xD8, 0x00] as [UInt8],<br>&gt;         encoding: NSUTF16BigEndianStringEncoding)!<br>&gt; <br>&gt; Ever wonder why dataWithJSONObject(…) is declared “throws?” Now you know!<br>&gt; <br>&gt;     // Throws an error<br>&gt;     try! NSJSONSerialization.dataWithJSONObject(<br>&gt;         [&quot;foo&quot;: bogusStr], options: [])<br>&gt; <br>&gt; And why does the URL escaping method in Foundation return an optional even though it escapes the string using UTF-8, which is a complete Unicode encoding? Same reason:<br>&gt;     // Returns nil<br>&gt;     bogusStr.stringByAddingPercentEncodingWithAllowedCharacters(<br>&gt;         NSCharacterSet.alphanumericCharacterSet())<br>&gt; <br>&gt; AFAIK, the first method could lose its “throws” modifier and the second method would not need to return an optional if only String itself guaranteed that it would always contain valid Unicode. There are likely other APIs that would see similar benefits.<br>&gt; <br>&gt; Are there downsides to making all String initializers guarantee that the Strings always contain valid Unicode? I can think of two possibilities:<br>&gt; <br>&gt; Is there some circumstance where you actually want a String to contain unpaired UTF-16 surrogate characters? I can’t imagine what that would be, but perhaps someone else can.<br>&gt; Is it important to ensure that String.init(…) is O(1) when it uses UTF-16? This seems thin: I assume that the library has to copy the raw bytes regardless, and it’s O(n) for other character encodings, so…?<br>&gt; <br>&gt; Cheers,<br>&gt; <br>&gt; Paul<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/a8215760/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7abf2ce34651dd5e97cd97b16ce21bae?s=50"></div><header><strong>Trial balloon: Ensure that String always contains valid Unicode</strong> from <string>Guillaume Lessard</string> &lt;glessard at tffenterprises.com&gt;<p>December 19, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On 18 déc. 2015, at 14:47, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I was quite surprised to learn that it’s possible to create Swift strings that do not contain things other than valid Unicode characters. Is it feasible to guarantee that this cannot happen?<br></p><p>That would be nice. I’m not sure that CFString or NSString guarantee correctness, though. If they don’t, then this could not be.<br></p><p>Guillaume Lessard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c0eafab7106ab63b8db4025e57c1a8d2?s=50"></div><header><strong>Trial balloon: Ensure that String always contains valid Unicode</strong> from <string>Javier Soto</string> &lt;javier.api at gmail.com&gt;<p>December 19, 2015 at 07:00:00pm</p></header><div class="content"><p>Right, I totally agree with you, but NSString compatibility would be<br>problematic then:<br>let s: NSString<br>let s2 = s as String // this would have to be a failable cast<br>On Sat, Dec 19, 2015 at 9:57 AM Guillaume Lessard via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On 18 déc. 2015, at 14:47, Paul Cantrell via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I was quite surprised to learn that it’s possible to create Swift<br>&gt; strings that do not contain things other than valid Unicode characters. Is<br>&gt; it feasible to guarantee that this cannot happen?<br>&gt;<br>&gt; That would be nice. I’m not sure that CFString or NSString guarantee<br>&gt; correctness, though. If they don’t, then this could not be.<br>&gt;<br>&gt; Guillaume Lessard<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-- <br>Javier Soto<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151219/f1a675c4/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Trial balloon: Ensure that String always contains valid Unicode</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December 19, 2015 at 07:00:00pm</p></header><div class="content"><p>On Fri, Dec 18, 2015 at 1:47 PM, Paul Cantrell via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I was quite surprised to learn that it’s possible to create Swift strings<br>&gt; that do not contain things other than valid Unicode characters. Is it<br>&gt; feasible to guarantee that this cannot happen?<br>&gt;<br>&gt; String.init(bytes:encoding:) is failable, and does in fact validate that<br>&gt; the given bytes are decodable with the given encoding in most circumstances:<br>&gt;<br>&gt;     // Returns nil<br>&gt;     String(<br>&gt;         bytes: [0xD8, 0x00] as [UInt8],<br>&gt;         encoding: NSUTF8StringEncoding)<br>&gt;<br>&gt; However, that initializer does *not* reject invalid surrogate characters<br>&gt; in UTF-16:<br>&gt;<br>&gt;     // Succeeds (wat?!)<br>&gt;     let bogusStr = String(<br>&gt;         bytes: [0xD8, 0x00] as [UInt8],<br>&gt;         encoding: NSUTF16BigEndianStringEncoding)!<br>&gt;<br></p><p>Adding this would be a useful guarantee, I support this.  The current<br>behavior looks inconsistent to me.  OTOH, the current behavior of<br>String(bytes:encoding:) mirrors the behavior of the NSString method, so<br>this would create inconsistency.  But I think the extra guarantee is worth<br>it.<br></p><p>Tony, what do you think?<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151219/2630d6c8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be4c3c3b76631a155e1358db48066692?s=50"></div><header><strong>Trial balloon: Ensure that String always contains valid Unicode</strong> from <string>Tony Parker</string> &lt;anthony.parker at apple.com&gt;<p>January  4, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Dec 19, 2015, at 7:59 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Fri, Dec 18, 2015 at 1:47 PM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; I was quite surprised to learn that it’s possible to create Swift strings that do not contain things other than valid Unicode characters. Is it feasible to guarantee that this cannot happen?<br>&gt; <br>&gt; String.init(bytes:encoding:) is failable, and does in fact validate that the given bytes are decodable with the given encoding in most circumstances:<br>&gt; <br>&gt;     // Returns nil<br>&gt;     String(<br>&gt;         bytes: [0xD8, 0x00] as [UInt8],<br>&gt;         encoding: NSUTF8StringEncoding)<br>&gt; <br>&gt; However, that initializer does not reject invalid surrogate characters in UTF-16:<br>&gt; <br>&gt;     // Succeeds (wat?!)<br>&gt;     let bogusStr = String(<br>&gt;         bytes: [0xD8, 0x00] as [UInt8],<br>&gt;         encoding: NSUTF16BigEndianStringEncoding)!<br>&gt; <br>&gt; Adding this would be a useful guarantee, I support this.  The current behavior looks inconsistent to me.  OTOH, the current behavior of String(bytes:encoding:) mirrors the behavior of the NSString method, so this would create inconsistency.  But I think the extra guarantee is worth it.<br>&gt; <br>&gt; Tony, what do you think?<br>&gt; <br></p><p>NSString deals with this issue more on the ‘get’ side. For example, CFStringGetBytes has a ‘lossByte’ for use in replacement when the requested encoding cannot represent something stored by the receiver string. Also, the abstract NSString interface can be extended to add additional encodings (which is why the string encoding values are not an enumeration).<br></p><p>- Tony<br></p><p>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt;*/<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160104/44f96a9f/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Trial balloon: Ensure that String always contains valid Unicode</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>January  4, 2016 at 11:00:00am</p></header><div class="content"><p>I agree in principle that it would be great if String could enforce that<br>it&#39;s always valid.<br></p><p>But unfortunately, in practice, there&#39;s no way to do that without making<br>it expensive to bridge from Obj-C. Because, as you&#39;ve demonstrated, you<br>can create NSStrings that contain things that aren&#39;t actually valid<br>unicode sequences, every single bridge from an NSString to a String<br>would have to be checked for validity. Not only that, but it&#39;s not clear<br>what the behavior would be if an invalid string is found, since these<br>bridges are unconditional - would Swift panic? Would it silently replace<br>the invalid sequence with U+FFFD? Or something else entirely? But the<br>question doesn&#39;t really matter, because turning these bridges from O(1)<br>into O(N) would be an unacceptable performance penalty anyway.<br></p><p>-Kevin Ballard<br></p><p>On Fri, Dec 18, 2015, at 01:47 PM, Paul Cantrell via swift-evolution wrote:<br>&gt; I was quite surprised to learn that it’s possible to create Swift<br>&gt; strings that do not contain things other than valid Unicode<br>&gt; characters. Is it feasible to guarantee that this cannot happen?<br>&gt;<br>&gt; String.init(bytes:encoding:) is failable, and does in fact validate<br>&gt; that the given bytes are decodable with the given encoding in most<br>&gt; circumstances:<br>&gt;<br>&gt; // Returns nil String(        bytes: [0xD8, 0x00] as [UInt8],<br>&gt; encoding: NSUTF8StringEncoding)<br>&gt;<br>&gt; However, that initializer does *not* reject invalid surrogate<br>&gt; characters in UTF-16:<br>&gt;<br>&gt; // Succeeds (wat?!) let bogusStr = String(        bytes: [0xD8, 0x00]<br>&gt; as [UInt8],        encoding: NSUTF16BigEndianStringEncoding)!<br>&gt;<br>&gt; Ever wonder why dataWithJSONObject(…) is declared “throws?” Now<br>&gt; you know!<br>&gt;<br>&gt; // Throws an error try! NSJSONSerialization.dataWithJSONObject(<br>&gt; [&quot;foo&quot;: bogusStr], options: [])<br>&gt;<br>&gt; And why does the URL escaping method in Foundation return an optional<br>&gt; even though it escapes the string using UTF-8, which is a complete<br>&gt; Unicode encoding? Same reason:<br>&gt;<br>&gt; // Returns nil<br>&gt; bogusStr.stringByAddingPercentEncodingWithAllowedCharacters(<br>&gt; NSCharacterSet.alphanumericCharacterSet())<br>&gt;<br>&gt; AFAIK, the first method could lose its “throws” modifier and the<br>&gt; second method would not need to return an optional if only String<br>&gt; itself guaranteed that it would always contain valid Unicode. There<br>&gt; are likely other APIs that would see similar benefits.<br>&gt;<br>&gt; Are there downsides to making all String initializers guarantee that<br>&gt; the Strings always contain valid Unicode? I can think of two<br>&gt; possibilities:<br>&gt;<br>&gt;  * Is there some circumstance where you actually want a String to<br>&gt;    contain unpaired UTF-16 surrogate characters? I can’t imagine what<br>&gt;    that would be, but perhaps someone else can.<br>&gt;  * Is it important to ensure that String.init(…) is O(1) when it<br>&gt;    uses UTF-16? This seems thin: I assume that the library has to<br>&gt;    copy the raw bytes regardless, and it’s O(n) for other character<br>&gt;    encodings, so…?<br>&gt;<br>&gt; Cheers,<br>&gt;<br>&gt; Paul<br>&gt;<br>&gt;<br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160104/531b1621/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Trial balloon: Ensure that String always contains valid Unicode</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>January  4, 2016 at 09:00:00pm</p></header><div class="content"><p>On Mon, Jan 4, 2016 at 9:37 PM, Kevin Ballard via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I agree in principle that it would be great if String could enforce that<br>&gt; it&#39;s always valid.<br>&gt;<br>&gt; But unfortunately, in practice, there&#39;s no way to do that without making<br>&gt; it expensive to bridge from Obj-C. Because, as you&#39;ve demonstrated, you can<br>&gt; create NSStrings that contain things that aren&#39;t actually valid unicode<br>&gt; sequences, every single bridge from an NSString to a String would have to<br>&gt; be checked for validity. Not only that, but it&#39;s not clear what the<br>&gt; behavior would be if an invalid string is found, since these bridges are<br>&gt; unconditional - would Swift panic? Would it silently replace the invalid<br>&gt; sequence with U+FFFD? Or something else entirely? But the question doesn&#39;t<br>&gt; really matter, because turning these bridges from O(1) into O(N) would be<br>&gt; an unacceptable performance penalty anyway.<br>&gt;<br></p><p>Currently String replaces invalid sequences with U+FFFD lazily during<br>access, but there are corner cases related to Objective-C bridging that can<br>still leak invalid Unicode.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160104/198c6aa4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Trial balloon: Ensure that String always contains valid Unicode</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>January  4, 2016 at 05:00:00pm</p></header><div class="content"><p>There are precedents for lazily checking for validity after bridging. Using `array as! [T]` on a NSArray without generics  fails lazily if you access an object that&#39;s not a T.<br></p><p>Félix<br></p><p>&gt; Le 4 janv. 2016 à 14:59:47, Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; On Mon, Jan 4, 2016 at 9:37 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; I agree in principle that it would be great if String could enforce that it&#39;s always valid.<br>&gt;  <br>&gt; But unfortunately, in practice, there&#39;s no way to do that without making it expensive to bridge from Obj-C. Because, as you&#39;ve demonstrated, you can create NSStrings that contain things that aren&#39;t actually valid unicode sequences, every single bridge from an NSString to a String would have to be checked for validity. Not only that, but it&#39;s not clear what the behavior would be if an invalid string is found, since these bridges are unconditional - would Swift panic? Would it silently replace the invalid sequence with U+FFFD? Or something else entirely? But the question doesn&#39;t really matter, because turning these bridges from O(1) into O(N) would be an unacceptable performance penalty anyway.<br>&gt; <br>&gt; Currently String replaces invalid sequences with U+FFFD lazily during access, but there are corner cases related to Objective-C bridging that can still leak invalid Unicode.<br>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt;*/<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160104/635ad471/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Trial balloon: Ensure that String always contains valid Unicode</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>January  4, 2016 at 02:00:00pm</p></header><div class="content"><p>That kind of lazy checking of arrays is used pretty rarely (since, as<br>you say, it only occurs with an `as!` expression). But doing lazy<br>checking of strings would end up having to check *every* string that<br>comes from ObjC (which, in a Swift app that uses Cocoa frameworks, is<br>likely to be most strings the app works with).<br></p><p>-Kevin Ballard<br></p><p>On Mon, Jan 4, 2016, at 02:41 PM, Félix Cloutier wrote:<br>&gt; There are precedents for lazily checking for validity after bridging.<br>&gt; Using `array as! [T]` on a NSArray without generics  fails lazily if<br>&gt; you access an object that&#39;s not a T.<br>&gt;<br>&gt; Félix<br>&gt;<br>&gt;&gt; Le 4 janv. 2016 à 14:59:47, Dmitri Gribenko via swift-evolution &lt;swift-<br>&gt;&gt; evolution at swift.org&gt; a écrit :<br>&gt;&gt;<br>&gt;&gt; On Mon, Jan 4, 2016 at 9:37 PM, Kevin Ballard via swift-evolution &lt;swift-<br>&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; __<br>&gt;&gt;&gt; I agree in principle that it would be great if String could enforce<br>&gt;&gt;&gt; that it&#39;s always valid.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; But unfortunately, in practice, there&#39;s no way to do that without<br>&gt;&gt;&gt; making it expensive to bridge from Obj-C. Because, as you&#39;ve<br>&gt;&gt;&gt; demonstrated, you can create NSStrings that contain things that<br>&gt;&gt;&gt; aren&#39;t actually valid unicode sequences, every single bridge from an<br>&gt;&gt;&gt; NSString to a String would have to be checked for validity. Not only<br>&gt;&gt;&gt; that, but it&#39;s not clear what the behavior would be if an invalid<br>&gt;&gt;&gt; string is found, since these bridges are unconditional - would Swift<br>&gt;&gt;&gt; panic? Would it silently replace the invalid sequence with U+FFFD?<br>&gt;&gt;&gt; Or something else entirely? But the question doesn&#39;t really matter,<br>&gt;&gt;&gt; because turning these bridges from O(1) into O(N) would be an<br>&gt;&gt;&gt; unacceptable performance penalty anyway.<br>&gt;&gt;<br>&gt;&gt; Currently String replaces invalid sequences with U+FFFD lazily during<br>&gt;&gt; access, but there are corner cases related to Objective-C bridging<br>&gt;&gt; that can still leak invalid Unicode.<br>&gt;&gt;<br>&gt;&gt; Dmitri<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt;&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;&gt;<br>_______________________________________________<br>&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160104/fd0f36a8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>Trial balloon: Ensure that String always contains valid Unicode</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>January  4, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt;&gt; But doing lazy checking of strings would end up having to check every string that comes from ObjC<br></p><p><br>I don’t think that’s necessarily true. There’s a limited set of places where invalid Unicode can creep into an NSString, and so the lazy check could probably bypass quite a few common cases — an ASCII string for example. Without digging into it, I suspect any NSString created from UTF-8 data can be safely bridged, since unpaired surrogate chars can’t make it through UTF-8.<br></p><p>Cheers, P<br></p><p><br>&gt; On Jan 4, 2016, at 4:43 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; That kind of lazy checking of arrays is used pretty rarely (since, as you say, it only occurs with an `as!` expression). But doing lazy checking of strings would end up having to check every string that comes from ObjC (which, in a Swift app that uses Cocoa frameworks, is likely to be most strings the app works with).<br>&gt;  <br>&gt; -Kevin Ballard<br>&gt;  <br>&gt; On Mon, Jan 4, 2016, at 02:41 PM, Félix Cloutier wrote:<br>&gt;&gt; There are precedents for lazily checking for validity after bridging. Using `array as! [T]` on a NSArray without generics  fails lazily if you access an object that&#39;s not a T.<br>&gt;&gt;  <br>&gt;&gt; Félix<br>&gt;&gt;  <br>&gt;&gt;&gt; Le 4 janv. 2016 à 14:59:47, Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; On Mon, Jan 4, 2016 at 9:37 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree in principle that it would be great if String could enforce that it&#39;s always valid.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; But unfortunately, in practice, there&#39;s no way to do that without making it expensive to bridge from Obj-C. Because, as you&#39;ve demonstrated, you can create NSStrings that contain things that aren&#39;t actually valid unicode sequences, every single bridge from an NSString to a String would have to be checked for validity. Not only that, but it&#39;s not clear what the behavior would be if an invalid string is found, since these bridges are unconditional - would Swift panic? Would it silently replace the invalid sequence with U+FFFD? Or something else entirely? But the question doesn&#39;t really matter, because turning these bridges from O(1) into O(N) would be an unacceptable performance penalty anyway.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Currently String replaces invalid sequences with U+FFFD lazily during access, but there are corner cases related to Objective-C bridging that can still leak invalid Unicode.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Dmitri<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt;&gt;&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt;*/<br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;  <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160104/5a333f75/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Trial balloon: Ensure that String always contains valid Unicode</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>January  4, 2016 at 03:00:00pm</p></header><div class="content"><p>On Mon, Jan 4, 2016, at 03:08 PM, Paul Cantrell wrote:<br>&gt;&gt;&gt; But doing lazy checking of strings would end up having to check<br>&gt;&gt;&gt; *every* string that comes from ObjC<br>&gt;<br>&gt; I don’t think that’s necessarily true. There’s a limited set of places<br>&gt; where invalid Unicode can creep into an NSString, and so the lazy<br>&gt; check could probably bypass quite a few common cases — an ASCII string<br>&gt; for example. Without digging into it, I suspect any NSString created<br>&gt; from UTF-8 data can be safely bridged, since unpaired surrogate chars<br>&gt; can’t make it through UTF-8.<br></p><p>Every single method you implement that takes a `String` property and is<br>either exposed to Obj-C or is overriding an Obj-C declaration will have<br>to check the String parameter every single time the function is called.<br></p><p>Every time you call an Obj-C method that returns a String, you&#39;ll have<br>to check that String result.<br></p><p>Basically, any time a String object is backed by an NSString, which is<br>going to be very common in most apps, that backing NSString will have to<br>be checked.<br></p><p>-Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160104/70237bc7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>Trial balloon: Ensure that String always contains valid Unicode</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>January  4, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jan 4, 2016, at 5:11 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; <br>&gt; On Mon, Jan 4, 2016, at 03:08 PM, Paul Cantrell wrote:<br>&gt;&gt;&gt;&gt; But doing lazy checking of strings would end up having to check every string that comes from ObjC<br>&gt;&gt; <br>&gt;&gt;  <br>&gt;&gt; I don’t think that’s necessarily true. There’s a limited set of places where invalid Unicode can creep into an NSString, and so the lazy check could probably bypass quite a few common cases — an ASCII string for example. Without digging into it, I suspect any NSString created from UTF-8 data can be safely bridged, since unpaired surrogate chars can’t make it through UTF-8.<br>&gt;  <br>&gt; Every single method you implement that takes a `String` property and is either exposed to Obj-C or is overriding an Obj-C declaration will have to check the String parameter every single time the function is called.<br>&gt;  <br>&gt; Every time you call an Obj-C method that returns a String, you&#39;ll have to check that String result.<br></p><p>Not necessarily. While it’s true that an NSString is represented as UTF-16 internally (right?), there’s a limited set of operations that can introduce invalid Unicode. In theory, at least, an NSString could keep a flag that tracks whether it could potentially contain be invalid.<br></p><p>This is much better than the doomsday scenario you lay out in two respects:<br></p><p>(1) That flag would start out false in many common situations (including NSStrings decoded from UTF-8, Latin-1, and ASCII), and could stay false with O(1) effort for substring operations. My guess is that this covers the vast majority of strings floating around in a typical app.<br></p><p>(2) Once a string is verified, the flag can be flipped true. No need to keep revalidating. Yes, there are threading concerns with that, but I trust the team that made the dark magic of Swift’s weak work may have some bright ideas on this.<br></p><p>The bottom line is that not every NSString → String bridge need to be O(n). At least in theory. Someone with more intimate knowledge of NSString can correct me if I’m wrong.<br></p><p>&gt;  Basically, any time a String object is backed by an NSString, which is going to be very common in most apps, that backing NSString will have to be checked.<br></p><p>Keep in mind that we’re already incurring that O(n) expense right now for every Swift operation that turns an NSString-backed string into characters — that plus the API burden of having that check deferred, which is what originally motivated this thread.<br></p><p>Cheers,<br></p><p>Paul<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160104/11f59afc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Trial balloon: Ensure that String always contains valid Unicode</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>January  4, 2016 at 03:00:00pm</p></header><div class="content"><p>On Mon, Jan 4, 2016, at 03:22 PM, Paul Cantrell wrote:<br>&gt;<br>&gt;&gt; On Jan 4, 2016, at 5:11 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Mon, Jan 4, 2016, at 03:08 PM, Paul Cantrell wrote:<br>&gt;&gt;&gt;&gt;&gt; But doing lazy checking of strings would end up having to check<br>&gt;&gt;&gt;&gt;&gt; *every* string that comes from ObjC<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I don’t think that’s necessarily true. There’s a limited set of<br>&gt;&gt;&gt; places where invalid Unicode can creep into an NSString, and so the<br>&gt;&gt;&gt; lazy check could probably bypass quite a few common cases — an ASCII<br>&gt;&gt;&gt; string for example. Without digging into it, I suspect any NSString<br>&gt;&gt;&gt; created from UTF-8 data can be safely bridged, since unpaired<br>&gt;&gt;&gt; surrogate chars can’t make it through UTF-8.<br>&gt;&gt;<br>&gt;&gt; Every single method you implement that takes a `String` property and<br>&gt;&gt; is either exposed to Obj-C or is overriding an Obj-C declaration will<br>&gt;&gt; have to check the String parameter every single time the function is<br>&gt;&gt; called.<br>&gt;&gt;<br>&gt;&gt; Every time you call an Obj-C method that returns a String, you&#39;ll<br>&gt;&gt; have to check that String result.<br>&gt;<br>&gt; Not necessarily. While it’s true that an NSString is represented as<br>&gt; UTF-16 internally (right?), there’s a limited set of operations that<br>&gt; can introduce invalid Unicode. In theory, at least, an NSString could<br>&gt; keep a flag that tracks whether it could potentially contain be<br>&gt; invalid.<br>&gt;<br>&gt; This is much better than the doomsday scenario you lay out in two<br>&gt; respects:<br>&gt;<br>&gt; (1) That flag would start out false in many common situations<br>&gt;     (including NSStrings decoded from UTF-8, Latin-1, and ASCII), and<br>&gt;     could stay false with O(1) effort for substring operations. My<br>&gt;     guess is that this covers the vast majority of strings floating<br>&gt;     around in a typical app.<br>&gt;<br>&gt; (2) Once a string is verified, the flag can be flipped true. No need<br>&gt;     to keep revalidating. Yes, there are threading concerns with that,<br>&gt;     but I trust the team that made the dark magic of Swift’s weak work<br>&gt;     may have some bright ideas on this.<br>&gt;<br>&gt; The bottom line is that not every NSString → String bridge need to be<br>&gt; O(n). At least in theory. Someone with more intimate knowledge of<br>&gt; NSString can correct me if I’m wrong.<br></p><p>I thought it was a given that we can&#39;t modify NSString. If we can modify<br>it, all bets are off; heck, if we can modify it, why not just make<br>NSString reject invalid sequences to begin with?<br></p><p>Besides the fact that NSString is provided by the OS instead of the<br>Swift stdlib, relying on a modification to NSString also means that the<br>logic will only work on a new version of the OS that contains the<br>modified NSString.<br></p><p>&gt;&gt; Basically, any time a String object is backed by an NSString, which<br>&gt;&gt; is going to be very common in most apps, that backing NSString will<br>&gt;&gt; have to be checked.<br>&gt; Keep in mind that we’re *already* incurring that O(n) expense right<br>&gt; now for every Swift operation that turns an NSString-backed string<br>&gt; into characters — that plus the API burden of having that check<br>&gt; deferred, which is what originally motivated this thread.<br></p><p>That&#39;s true for native Strings as well. The native String storage is<br>actually a sequence of UTF-16 code units, it&#39;s not a sequence of<br>characters. Any time you iterate over the CharacterView, it has to<br>calculate the grapheme cluster boundaries. But that&#39;s ok, because unless<br>you call `count` on it, you&#39;re typically doing an O(N) operation<br>_anyway_. But there&#39;s plenty of things you can do with strings that<br>don&#39;t require iterating over the CharacterView.<br></p><p>-Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160104/b01af69f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>Trial balloon: Ensure that String always contains valid Unicode</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>January  5, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jan 4, 2016, at 5:39 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; <br>&gt; On Mon, Jan 4, 2016, at 03:22 PM, Paul Cantrell wrote:<br>&gt;&gt;  <br>&gt;&gt; The bottom line is that not every NSString → String bridge need to be O(n). At least in theory. Someone with more intimate knowledge of NSString can correct me if I’m wrong.<br>&gt;  <br>&gt; I thought it was a given that we can&#39;t modify NSString. If we can modify it, all bets are off; heck, if we can modify it, why not just make NSString reject invalid sequences to begin with?<br></p><p>Good question. And if we can’t modify NSString, then yes, we’re up against a tough problem.<br></p><p>But should NSString legacy constraints really compromise the design of Swift’s native String type?<br></p><p>Félix and Dmitri’s comments suggest that there are ways to prevent that, and that there’s precedent for placing any distasteful behavior necessary for compatibility in the bridging, not in the core type.<br></p><p>&gt;&gt; Keep in mind that we’re already incurring that O(n) expense right now for every Swift operation that turns an NSString-backed string into characters — that plus the API burden of having that check deferred, which is what originally motivated this thread.<br>&gt;  <br>&gt; That&#39;s true for native Strings as well. The native String storage is actually a sequence of UTF-16 code units, it&#39;s not a sequence of characters. Any time you iterate over the CharacterView, it has to calculate the grapheme cluster boundaries.<br></p><p>Aren’t Swift strings encoded as UTF-8, —or at least designed to behave as if they are, however they might be stored under the hood?<br></p><p>https://github.com/apple/swift/blob/master/docs/StringDesign.rst#strings-are-encoded-as-utf-8 &lt;https://github.com/apple/swift/blob/master/docs/StringDesign.rst#strings-are-encoded-as-utf-8&gt;<br>https://github.com/apple/swift/blob/master/docs/StringDesign.rst#how-would-you-design-it &lt;https://github.com/apple/swift/blob/master/docs/StringDesign.rst#how-would-you-design-it&gt;<br></p><p>Given the warning at the top about this having been a planning document, I see that this may no longer be true. But at least the original design rationale strongly suggests that String’s failable initializers should fail when given invalid Unicode.<br></p><p>&gt; But that&#39;s ok, because unless you call `count` on it, you&#39;re typically doing an O(N) operation _anyway_. But there&#39;s plenty of things you can do with strings that don&#39;t require iterating over the CharacterView.<br></p><p><br>Indeed, but per my earlier message, those things could all still be O(1) except in the case when you’re transcoding a string from something other than ASCII or UTF-8 — and those transcoding cases are O(n) already. That certainly seems like a better design for the core lib.<br></p><p>Really hoping a core team member can weigh in on this….<br></p><p>Cheers,<br></p><p>Paul<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/94bb520b/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e01e37acbfad671da1b94a61cf819d82?s=50"></div><header><strong>Trial balloon: Ensure that String always contains valid Unicode</strong> from <string>Kenny Leung</string> &lt;kenny_leung at pobox.com&gt;<p>January  9, 2016 at 02:00:00pm</p></header><div class="content"><p>Could we not push NSString to adopt this behavior? I think it should be fair to push for changes in the other direction instead of having Swift be a slave to bridging.<br></p><p>-Kenny<br></p><p><br>&gt; On Jan 4, 2016, at 11:37 AM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I agree in principle that it would be great if String could enforce that it&#39;s always valid.<br>&gt;  <br>&gt; But unfortunately, in practice, there&#39;s no way to do that without making it expensive to bridge from Obj-C. Because, as you&#39;ve demonstrated, you can create NSStrings that contain things that aren&#39;t actually valid unicode sequences, every single bridge from an NSString to a String would have to be checked for validity. Not only that, but it&#39;s not clear what the behavior would be if an invalid string is found, since these bridges are unconditional - would Swift panic? Would it silently replace the invalid sequence with U+FFFD? Or something else entirely? But the question doesn&#39;t really matter, because turning these bridges from O(1) into O(N) would be an unacceptable performance penalty anyway.<br>&gt;  <br>&gt; -Kevin Ballard<br>&gt;  <br>&gt; On Fri, Dec 18, 2015, at 01:47 PM, Paul Cantrell via swift-evolution wrote:<br>&gt;&gt; I was quite surprised to learn that it’s possible to create Swift strings that do not contain things other than valid Unicode characters. Is it feasible to guarantee that this cannot happen?<br>&gt;&gt;  <br>&gt;&gt; String.init(bytes:encoding:) is failable, and does in fact validate that the given bytes are decodable with the given encoding in most circumstances:<br>&gt;&gt;  <br>&gt;&gt; // Returns nil<br>&gt;&gt; String(<br>&gt;&gt;         bytes: [0xD8, 0x00] as [UInt8],<br>&gt;&gt;         encoding: NSUTF8StringEncoding)<br>&gt;&gt;  <br>&gt;&gt; However, that initializer does not reject invalid surrogate characters in UTF-16:<br>&gt;&gt;  <br>&gt;&gt; // Succeeds (wat?!)<br>&gt;&gt; let bogusStr = String(<br>&gt;&gt;         bytes: [0xD8, 0x00] as [UInt8],<br>&gt;&gt;         encoding: NSUTF16BigEndianStringEncoding)!<br>&gt;&gt;  <br>&gt;&gt; Ever wonder why dataWithJSONObject(…) is declared “throws?” Now you know!<br>&gt;&gt;  <br>&gt;&gt; // Throws an error<br>&gt;&gt; try! NSJSONSerialization.dataWithJSONObject(<br>&gt;&gt;         [&quot;foo&quot;: bogusStr], options: [])<br>&gt;&gt;  <br>&gt;&gt; And why does the URL escaping method in Foundation return an optional even though it escapes the string using UTF-8, which is a complete Unicode encoding? Same reason:<br>&gt;&gt;  <br>&gt;&gt; // Returns nil<br>&gt;&gt; bogusStr.stringByAddingPercentEncodingWithAllowedCharacters(<br>&gt;&gt; NSCharacterSet.alphanumericCharacterSet())<br>&gt;&gt;  <br>&gt;&gt; AFAIK, the first method could lose its “throws” modifier and the second method would not need to return an optional if only String itself guaranteed that it would always contain valid Unicode. There are likely other APIs that would see similar benefits.<br>&gt;&gt;  <br>&gt;&gt; Are there downsides to making all String initializers guarantee that the Strings always contain valid Unicode? I can think of two possibilities:<br>&gt;&gt;  <br>&gt;&gt; 	• Is there some circumstance where you actually want a String to contain unpaired UTF-16 surrogate characters? I can’t imagine what that would be, but perhaps someone else can.<br>&gt;&gt; 	• Is it important to ensure that String.init(…) is O(1) when it uses UTF-16? This seems thin: I assume that the library has to copy the raw bytes regardless, and it’s O(n) for other character encodings, so…?<br>&gt;&gt;  <br>&gt;&gt; Cheers,<br>&gt;&gt;  <br>&gt;&gt; Paul<br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;  <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
