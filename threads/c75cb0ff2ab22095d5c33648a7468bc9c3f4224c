<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Require use of override keyword to override dynamically dispatched methods defined in a protocol with a default implementation</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January  6, 2016 at 09:00:00am</p></header><div class="content"><p>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160106/c75c224c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Require use of override keyword to override dynamically dispatched methods defined in a protocol with a default implementation</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>January  6, 2016 at 03:00:00am</p></header><div class="content"><p>You&#39;re quite right: in the worst case, the number of protocols you<br>would need would be linear to the number of methods. It&#39;s not the<br>best, I will concede. It does seem to be rather the &quot;Swifty&quot; way,<br>though. At least, if we follow the example of the Swift standard<br>library, it&#39;s not discouraged. Consider that the protocol hierarchy<br>for Int already has 26 protocols<br>(http://blog.krzyzanowskim.com/2015/03/01/swift_madness_of_generic_integer/).<br>What harm is there in another 3 or 4, or even 10--provided that each<br>is clearly named, serves a defined purpose, and is composed together<br>in something of a logical way?<br></p><p>I don&#39;t understand your point about controlling the protocol. Perhaps<br>you could explain? As far as I can tell, in my example BooType doesn&#39;t<br>need to be under your control or modified. If you extend Bar with<br>DefaultBooType, then (Bar is BooType == true).<br></p><p><br>On Wed, Jan 6, 2016 at 3:32 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; That&#39;s a good argument, but I&#39;m not convinced: not only do I have to define<br>&gt; additional protocols (&quot;DefaultXXX&quot;) but in the worst case I have to do this<br>&gt; for each method declared in my protocol (which makes naming these default<br>&gt; protocols even worse, because XXX now has to represent the method), i.e.<br>&gt;<br>&gt; protocol BooType {<br>&gt;    func someBoo()<br>&gt;    func anotherBoo()<br>&gt;    func yetAnotherBoo()<br>&gt; }<br>&gt;<br>&gt; when given:<br>&gt;<br>&gt; struct Foo {<br>&gt;    func someBoo() { print(&quot;foo boo&quot;) }<br>&gt; }<br>&gt; struct Bar {<br>&gt;    func anotherBoo() { print(&quot;bar boo&quot;) }<br>&gt; }<br>&gt; struct Baz {<br>&gt;    func anotherBoo() { print(&quot;baz boo&quot;) }<br>&gt; }<br>&gt;<br>&gt; I would have to define all of the following:<br>&gt;<br>&gt; protocol DefaultBooTypeSomeBoo : BooType { }<br>&gt; extension DefaultBooTypeSomeBoo {<br>&gt;    func someBoo() { print(&quot;some boo&quot;) }<br>&gt; }<br>&gt; protocol DefaultBooTypeAnotherBoo : BooType { }<br>&gt; extension DefaultBooTypeAnotherBoo {<br>&gt;    func anotherBoo() { print(&quot;another boo&quot;) }<br>&gt; }<br>&gt; protocol DefaultBooTypeYetAnotherBoo : BooType { }<br>&gt; extension DefaultBooTypeYetAnotherBoo {<br>&gt;    func yetAnotherBoo() { print(&quot;yet another boo&quot;) }<br>&gt; }<br>&gt;<br>&gt;<br>&gt;<br>&gt; Even worse: if the protocol itself is not under my control I cannot even do<br>&gt; this (not even for the simple case you demonstrated)!<br>&gt;<br>&gt; -Thorsten<br>&gt;<br>&gt;<br>&gt;<br>&gt; Am 06. Januar 2016 um 09:36 schrieb Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt;:<br>&gt;<br>&gt; The pattern might exist for some existing classes or structs but it might<br>&gt; still be useful for new classes or even for some existing ones to provide a<br>&gt; default implementation.<br>&gt;<br>&gt;<br>&gt; I agree. It could be very useful in certain circumstances, and I agree<br>&gt; that any proposal that made this no longer possible would be a<br>&gt; non-starter. I had to think about this point for a bit; I hope I can<br>&gt; convince you that it would remain possible if overriding methods had<br>&gt; to use a keyword. The way it would be done would be valid code today,<br>&gt; and I think after some reflection that it&#39;s a superior way of doing<br>&gt; things even in today&#39;s Swift syntax because it&#39;s more explicit about<br>&gt; what&#39;s going on.<br>&gt;<br>&gt; Example:<br>&gt; Given three existing struct types--<br>&gt;<br>&gt; struct Foo {<br>&gt; func boo() { print(&quot;foo boo&quot;) }<br>&gt; }<br>&gt; struct Bar { }<br>&gt; struct Baz { }<br>&gt;<br>&gt; We wish to formalize after the fact, giving each type a method boo()<br>&gt; with a default implementation. Currently, this is valid Swift code--<br>&gt;<br>&gt; protocol BooType {<br>&gt; func boo()<br>&gt; }<br>&gt; extension BooType {<br>&gt; func boo() { print(&quot;default boo&quot;) }<br>&gt; }<br>&gt; extension Foo: BooType { }<br>&gt; extension Bar: BooType { }<br>&gt; extension Baz: BooType { }<br>&gt;<br>&gt; As you point out rightly, this would be invalid if we had to write<br>&gt; &quot;override func boo()&quot; in the body of struct Foo. However, this is<br>&gt; valid Swift code both in today&#39;s syntax and if my proposal were to be<br>&gt; implemented, and it is only one line longer--<br>&gt;<br>&gt; protocol BooType {<br>&gt; func boo()<br>&gt; }<br>&gt; protocol DefaultBooType: BooType { }<br>&gt; extension DefaultBooType {<br>&gt; func boo() { print(&quot;default boo&quot;) }<br>&gt; }<br>&gt; extension Foo: BooType { }<br>&gt; extension Bar: DefaultBooType { }<br>&gt; extension Baz: DefaultBooType { }<br>&gt;<br>&gt; I&#39;d like to promote the second option as being superior even in<br>&gt; today&#39;s syntax. It is immediately clear to the reader that Foo().boo()<br>&gt; invokes a different method than Bar().boo(), even if the reader does<br>&gt; not have access to the original code for structs Foo, Bar, and Baz.<br>&gt; Suppose those structs were supplied in a third-party library that&#39;s<br>&gt; not well documented. It&#39;s plausible that a non-expert coder could try<br>&gt; to formalize after the fact and write an extension BooType<br>&gt; implementing boo() unaware that there is an overriding method in Foo.<br>&gt; In today&#39;s Swift syntax, the code would compile and behave subtly<br>&gt; differently from the author&#39;s expectations; as proposed, that code<br>&gt; would lead to a compile-time error. However, an expert coder who<br>&gt; intended to supply a default function but invoke any overriding<br>&gt; methods could write code that is almost as succinct but also<br>&gt; self-documenting, and in fact could do so today.<br>&gt;<br>&gt;<br>&gt; On Wed, Jan 6, 2016 at 12:45 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt;<br>&gt;&gt; Am 06.01.2016 um 06:23 schrieb Xiaodi Wu via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt;:<br>&gt;<br>&gt;&gt;<br>&gt;<br>&gt;&gt; It would remain very much possible to formalize an existing pattern<br>&gt;&gt; because, in the case of your example (unless I&#39;m misunderstanding?), you are<br>&gt;&gt; not also providing a default implementation of the &quot;min&quot; and &quot;max&quot; getters,<br>&gt;&gt; and the IntXX structs would have nothing to override. Indeed, you&#39;d hardly<br>&gt;&gt; be formalizing an existing pattern if you had to supply de novo<br>&gt;&gt; implementations!<br>&gt;<br>&gt;<br>&gt; The pattern might exist for some existing classes or structs but it might<br>&gt; still be useful for new classes or even for some existing ones to provide a<br>&gt; default implementation.<br>&gt;<br>&gt;<br>&gt; -Thorsten<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
