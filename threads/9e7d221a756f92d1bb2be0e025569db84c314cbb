<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/aeab22e60ba7b7e2bd445775850448d1?s=50"></div><header><strong>A shortcut for weakly referencing functions</strong> from <string>Radosław Pietruszewski</string> &lt;radexpl at gmail.com&gt;<p>April  1, 2016 at 05:00:00pm</p></header><div class="content"><p>Here’s a pattern I find myself doing quite often:<br></p><p>  1&gt; class Child {<br>  2.     var onSomeEvent: () -&gt; Void = { }<br>  3. }<br>  4&gt; class Parent {<br>  5.     let child = Child()<br>  6.     init() {<br>  7.         child.onSomeEvent = doSomething<br>  8.     }<br>  9.     func doSomething() {<br> 10.     }<br> 11. }<br></p><p>I have some ownership hierarchy of classes (often controllers — view controllers — views), where I pass information from children up to parents using closures set by the parent.<br></p><p>I like this pattern because children classes don’t have to be tied to knowledge about their parents, and I don’t have to define delegate protocols. It’s very clean, and also very easy to set up.<br></p><p>The only problem is that there’s a strong danger of introducing reference cycles.<br></p><p>With class properties, you can quite easily see the potential for a reference cycle and mark references to parents with weak/unowned. And with `self` captures in closures, you’re reminded of memory management by having to be explicit about `self`. But when passing references from parents to children, there’s no way to mark the closure property as `weak` (and there’s no reminder of the danger).<br></p><p>* * *<br></p><p>Right now, every time I pass a closure down to children, I have to wrap my references like so:<br></p><p>	{ [unowned self] self.doSomething($0) }<br></p><p>instead of a neat and simple function reference:<br></p><p>	doSomething<br></p><p>I think it would be useful to have a shortcut syntax for creating weak and unowned references to functions, like so:<br></p><p>	@unowned(doSomething)<br></p><p>or perhaps:<br></p><p>	#unowned(self.doSomething)<br></p><p>* * *<br></p><p>An alternative would be the ability to mark closure properties as weak or unowned. Then I could, at the *child* level, say:<br></p><p>	unowned let onSomeEvent: () -&gt; Void<br></p><p>* * *<br></p><p>Does this make sense? What do you think?<br></p><p>— Radek<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76eb9711d45c1c9a71c0f24004072a22?s=50"></div><header><strong>A shortcut for weakly referencing functions</strong> from <string>Zach Waldowski</string> &lt;zach at waldowski.me&gt;<p>April  1, 2016 at 11:00:00am</p></header><div class="content"><p>Responses inline!<br></p><p>Sincerely,<br>  Zachary Waldowski<br>  zach at waldowski.me<br></p><p>On Fri, Apr 1, 2016, at 11:09 AM, Radosław Pietruszewski via<br>swift-evolution wrote:<br>&gt; Here’s a pattern I find myself doing quite often:<br>&gt; <br>&gt;   1&gt; class Child {<br>&gt;   2.     var onSomeEvent: () -&gt; Void = { }<br>&gt;   3. }<br>&gt;   4&gt; class Parent {<br>&gt;   5.     let child = Child()<br>&gt;   6.     init() {<br>&gt;   7.         child.onSomeEvent = doSomething<br>&gt;   8.     }<br>&gt;   9.     func doSomething() {<br>&gt;  10.     }<br>&gt;  11. }<br>&gt; <br>&gt; I have some ownership hierarchy of classes (often controllers — view<br>&gt; controllers — views), where I pass information from children up to<br>&gt; parents using closures set by the parent.<br>&gt; <br>&gt; I like this pattern because children classes don’t have to be tied to<br>&gt; knowledge about their parents, and I don’t have to define delegate<br>&gt; protocols. It’s very clean, and also very easy to set up.<br>&gt; <br>&gt; The only problem is that there’s a strong danger of introducing reference<br>&gt; cycles.<br>&gt; <br>&gt; With class properties, you can quite easily see the potential for a<br>&gt; reference cycle and mark references to parents with weak/unowned. And<br>&gt; with `self` captures in closures, you’re reminded of memory management by<br>&gt; having to be explicit about `self`. But when passing references from<br>&gt; parents to children, there’s no way to mark the closure property as<br>&gt; `weak` (and there’s no reminder of the danger).<br></p><p>I will go ahead and note, at least in terms of writing the proposal, I<br>don&#39;t find this argument very strong. The proposed syntax still requires<br>you to know about the cycles involved.<br></p><p>&gt; <br>&gt; * * *<br>&gt; <br>&gt; Right now, every time I pass a closure down to children, I have to wrap<br>&gt; my references like so:<br>&gt; <br>&gt; 	{ [unowned self] self.doSomething($0) }<br>&gt; <br>&gt; instead of a neat and simple function reference:<br>&gt; <br>&gt; 	doSomething<br>&gt; <br>&gt; I think it would be useful to have a shortcut syntax for creating weak<br>&gt; and unowned references to functions, like so:<br>&gt; <br>&gt; 	@unowned(doSomething)<br>&gt; <br>&gt; or perhaps:<br>&gt; <br>&gt; 	#unowned(self.doSomething)<br>&gt; <br>&gt; * * *<br></p><p>I really like the #unowned syntax! It&#39;s expressive and in line with<br>other pieces of Swift sugar. Would +1 if it came to a proposal!<br></p><p>The @ version doesn&#39;t make as much sense as it&#39;s not an attribute.<br></p><p>&gt; <br>&gt; An alternative would be the ability to mark closure properties as weak or<br>&gt; unowned. Then I could, at the *child* level, say:<br>&gt; <br>&gt; 	unowned let onSomeEvent: () -&gt; Void<br></p><p>I don&#39;t particularly think it makes sense, because it is prescriptive.<br>If some other user in your codebase wanted the cycle, they couldn&#39;t get<br>it. Plus, what would it mean when the closure isn&#39;t capturing anything?<br></p><p>&gt; <br>&gt; * * *<br>&gt; <br>&gt; Does this make sense? What do you think?<br>&gt; <br>&gt; — Radek<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/aeab22e60ba7b7e2bd445775850448d1?s=50"></div><header><strong>A shortcut for weakly referencing functions</strong> from <string>Radosław Pietruszewski</string> &lt;radexpl at gmail.com&gt;<p>April  1, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt;&gt; Here’s a pattern I find myself doing quite often:<br>&gt;&gt; <br>&gt;&gt;  1&gt; class Child {<br>&gt;&gt;  2.     var onSomeEvent: () -&gt; Void = { }<br>&gt;&gt;  3. }<br>&gt;&gt;  4&gt; class Parent {<br>&gt;&gt;  5.     let child = Child()<br>&gt;&gt;  6.     init() {<br>&gt;&gt;  7.         child.onSomeEvent = doSomething<br>&gt;&gt;  8.     }<br>&gt;&gt;  9.     func doSomething() {<br>&gt;&gt; 10.     }<br>&gt;&gt; 11. }<br>&gt;&gt; <br>&gt;&gt; I have some ownership hierarchy of classes (often controllers — view<br>&gt;&gt; controllers — views), where I pass information from children up to<br>&gt;&gt; parents using closures set by the parent.<br>&gt;&gt; <br>&gt;&gt; I like this pattern because children classes don’t have to be tied to<br>&gt;&gt; knowledge about their parents, and I don’t have to define delegate<br>&gt;&gt; protocols. It’s very clean, and also very easy to set up.<br>&gt;&gt; <br>&gt;&gt; The only problem is that there’s a strong danger of introducing reference<br>&gt;&gt; cycles.<br>&gt;&gt; <br>&gt;&gt; With class properties, you can quite easily see the potential for a<br>&gt;&gt; reference cycle and mark references to parents with weak/unowned. And<br>&gt;&gt; with `self` captures in closures, you’re reminded of memory management by<br>&gt;&gt; having to be explicit about `self`. But when passing references from<br>&gt;&gt; parents to children, there’s no way to mark the closure property as<br>&gt;&gt; `weak` (and there’s no reminder of the danger).<br>&gt; <br>&gt; I will go ahead and note, at least in terms of writing the proposal, I<br>&gt; don&#39;t find this argument very strong. The proposed syntax still requires<br>&gt; you to know about the cycles involved.<br></p><p>Oh, I agree. The proposal doesn’t fix the relative undiscoverability (is that a word?) of the potential for reference cycles when passing function references.<br></p><p>Still — I think, maybe, when you can say in tutorials and programming guides that you avoid reference cycles when passing functions down the ownership hierarchy by wrapping those function references in #weak(…) / #unowned(…), it might be easier to grasp and remember than `{ [unowned self] in self.foo($0) }`.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; * * *<br>&gt;&gt; <br>&gt;&gt; Right now, every time I pass a closure down to children, I have to wrap<br>&gt;&gt; my references like so:<br>&gt;&gt; <br>&gt;&gt; 	{ [unowned self] self.doSomething($0) }<br>&gt;&gt; <br>&gt;&gt; instead of a neat and simple function reference:<br>&gt;&gt; <br>&gt;&gt; 	doSomething<br>&gt;&gt; <br>&gt;&gt; I think it would be useful to have a shortcut syntax for creating weak<br>&gt;&gt; and unowned references to functions, like so:<br>&gt;&gt; <br>&gt;&gt; 	@unowned(doSomething)<br>&gt;&gt; <br>&gt;&gt; or perhaps:<br>&gt;&gt; <br>&gt;&gt; 	#unowned(self.doSomething)<br>&gt;&gt; <br>&gt;&gt; * * *<br>&gt; <br>&gt; I really like the #unowned syntax! It&#39;s expressive and in line with<br>&gt; other pieces of Swift sugar. Would +1 if it came to a proposal!<br>&gt; <br>&gt; The @ version doesn&#39;t make as much sense as it&#39;s not an attribute.<br></p><p>Thank you. You’re probably right about #unowned(…) vs @unowned(…). I thought of at-syntax because it feels like applying an attribute to the function reference. (IIRC, weak and unowned were @weak and @unowned in Swift β1)<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; An alternative would be the ability to mark closure properties as weak or<br>&gt;&gt; unowned. Then I could, at the *child* level, say:<br>&gt;&gt; <br>&gt;&gt; 	unowned let onSomeEvent: () -&gt; Void<br>&gt; <br>&gt; I don&#39;t particularly think it makes sense, because it is prescriptive.<br>&gt; If some other user in your codebase wanted the cycle, they couldn&#39;t get<br>&gt; it. Plus, what would it mean when the closure isn&#39;t capturing anything?<br></p><p>Rright. Because it’s not really about assigning literal closures to such a parameter, rather assigning method references, where the method’s receiver (self in my example) is implicitly captured… So it seems like it should be a responsibility of the code assigning the reference.<br></p><p>— Radek<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160401/7e3fd70a/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>A shortcut for weakly referencing functions</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>April  1, 2016 at 10:00:00am</p></header><div class="content"><p>As we briefly discussed on Twitter, I feel like Swift already has too much closure syntax as it is. { [unowned self] self.doSomething($0) } is definitely more text than self.doSomething, but it&#39;s clear what it&#39;s doing. &quot;self.doSomething&quot; method applications are also the only place where we directly capture an object into a closure without explicit closure syntax, which is where much of the surprise about memory leaks comes from. Even when strong references are desired, it&#39;s arguable that { self.doSomething($0) } is still preferable, since it&#39;s more obviously capturing `self`, and that the &#39;self.doSomething&#39; shorthand is a misfeature.<br></p><p>-Joe<br></p><p>&gt; On Apr 1, 2016, at 8:09 AM, Radosław Pietruszewski via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Here’s a pattern I find myself doing quite often:<br>&gt; <br>&gt;  1&gt; class Child {<br>&gt;  2.     var onSomeEvent: () -&gt; Void = { }<br>&gt;  3. }<br>&gt;  4&gt; class Parent {<br>&gt;  5.     let child = Child()<br>&gt;  6.     init() {<br>&gt;  7.         child.onSomeEvent = doSomething<br>&gt;  8.     }<br>&gt;  9.     func doSomething() {<br>&gt; 10.     }<br>&gt; 11. }<br>&gt; <br>&gt; I have some ownership hierarchy of classes (often controllers — view controllers — views), where I pass information from children up to parents using closures set by the parent.<br>&gt; <br>&gt; I like this pattern because children classes don’t have to be tied to knowledge about their parents, and I don’t have to define delegate protocols. It’s very clean, and also very easy to set up.<br>&gt; <br>&gt; The only problem is that there’s a strong danger of introducing reference cycles.<br>&gt; <br>&gt; With class properties, you can quite easily see the potential for a reference cycle and mark references to parents with weak/unowned. And with `self` captures in closures, you’re reminded of memory management by having to be explicit about `self`. But when passing references from parents to children, there’s no way to mark the closure property as `weak` (and there’s no reminder of the danger).<br>&gt; <br>&gt; * * *<br>&gt; <br>&gt; Right now, every time I pass a closure down to children, I have to wrap my references like so:<br>&gt; <br>&gt; 	{ [unowned self] self.doSomething($0) }<br>&gt; <br>&gt; instead of a neat and simple function reference:<br>&gt; <br>&gt; 	doSomething<br>&gt; <br>&gt; I think it would be useful to have a shortcut syntax for creating weak and unowned references to functions, like so:<br>&gt; <br>&gt; 	@unowned(doSomething)<br>&gt; <br>&gt; or perhaps:<br>&gt; <br>&gt; 	#unowned(self.doSomething)<br>&gt; <br>&gt; * * *<br>&gt; <br>&gt; An alternative would be the ability to mark closure properties as weak or unowned. Then I could, at the *child* level, say:<br>&gt; <br>&gt; 	unowned let onSomeEvent: () -&gt; Void<br>&gt; <br>&gt; * * *<br>&gt; <br>&gt; Does this make sense? What do you think?<br>&gt; <br>&gt; — Radek<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/aeab22e60ba7b7e2bd445775850448d1?s=50"></div><header><strong>A shortcut for weakly referencing functions</strong> from <string>Radosław Pietruszewski</string> &lt;radexpl at gmail.com&gt;<p>April 10, 2016 at 07:00:00pm</p></header><div class="content"><p>Thanks for chiming in, Joe, and apologies for not replying promptly!<br></p><p>&gt; &quot;self.doSomething&quot; method applications are also the only place where we directly capture an object into a closure without explicit closure syntax, which is where much of the surprise about memory leaks comes from.<br></p><p>Ohhh. So that’s interesting. Makes total sense, but from a programmer’s perspective I just thought of `self.doSomething` as nothing more than a function reference. But, if I understand correctly, it’s actually equivalent to `{ [self] in Foo.doSomething(self)($0) }`, correct?<br></p><p>&gt; Even when strong references are desired, it&#39;s arguable that { self.doSomething($0) } is still preferable, since it&#39;s more obviously capturing `self`, and that the &#39;self.doSomething&#39; shorthand is a misfeature.<br></p><p>Hm. Not having the shortcut would suck a bit, but it’s hard to argue with the fact that it’s much clearer you’re doing something potentially dangerous.<br></p><p>What about this, then: rip out the `self.doSomething` method applications, but have a shortcut, like the ones I proposed, that’s more explicit about the method capture:<br></p><p>#strong(self.doSomething) // &lt;— currently just self.doSomething<br>#weak(self.doSomething)<br>#unowned(self.doSomething)<br></p><p>The balance of closure syntaxes is zero ;) but the Misfeature Shorthand is now clearer, and forming weak/unowned-self is easier and less noisy.<br></p><p>— Radek<br></p><p>&gt; On 01 Apr 2016, at 19:35, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; As we briefly discussed on Twitter, I feel like Swift already has too much closure syntax as it is. { [unowned self] self.doSomething($0) } is definitely more text than self.doSomething, but it&#39;s clear what it&#39;s doing. &quot;self.doSomething&quot; method applications are also the only place where we directly capture an object into a closure without explicit closure syntax, which is where much of the surprise about memory leaks comes from. Even when strong references are desired, it&#39;s arguable that { self.doSomething($0) } is still preferable, since it&#39;s more obviously capturing `self`, and that the &#39;self.doSomething&#39; shorthand is a misfeature.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; On Apr 1, 2016, at 8:09 AM, Radosław Pietruszewski via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Here’s a pattern I find myself doing quite often:<br>&gt;&gt; <br>&gt;&gt; 1&gt; class Child {<br>&gt;&gt; 2.     var onSomeEvent: () -&gt; Void = { }<br>&gt;&gt; 3. }<br>&gt;&gt; 4&gt; class Parent {<br>&gt;&gt; 5.     let child = Child()<br>&gt;&gt; 6.     init() {<br>&gt;&gt; 7.         child.onSomeEvent = doSomething<br>&gt;&gt; 8.     }<br>&gt;&gt; 9.     func doSomething() {<br>&gt;&gt; 10.     }<br>&gt;&gt; 11. }<br>&gt;&gt; <br>&gt;&gt; I have some ownership hierarchy of classes (often controllers — view controllers — views), where I pass information from children up to parents using closures set by the parent.<br>&gt;&gt; <br>&gt;&gt; I like this pattern because children classes don’t have to be tied to knowledge about their parents, and I don’t have to define delegate protocols. It’s very clean, and also very easy to set up.<br>&gt;&gt; <br>&gt;&gt; The only problem is that there’s a strong danger of introducing reference cycles.<br>&gt;&gt; <br>&gt;&gt; With class properties, you can quite easily see the potential for a reference cycle and mark references to parents with weak/unowned. And with `self` captures in closures, you’re reminded of memory management by having to be explicit about `self`. But when passing references from parents to children, there’s no way to mark the closure property as `weak` (and there’s no reminder of the danger).<br>&gt;&gt; <br>&gt;&gt; * * *<br>&gt;&gt; <br>&gt;&gt; Right now, every time I pass a closure down to children, I have to wrap my references like so:<br>&gt;&gt; <br>&gt;&gt; 	{ [unowned self] self.doSomething($0) }<br>&gt;&gt; <br>&gt;&gt; instead of a neat and simple function reference:<br>&gt;&gt; <br>&gt;&gt; 	doSomething<br>&gt;&gt; <br>&gt;&gt; I think it would be useful to have a shortcut syntax for creating weak and unowned references to functions, like so:<br>&gt;&gt; <br>&gt;&gt; 	@unowned(doSomething)<br>&gt;&gt; <br>&gt;&gt; or perhaps:<br>&gt;&gt; <br>&gt;&gt; 	#unowned(self.doSomething)<br>&gt;&gt; <br>&gt;&gt; * * *<br>&gt;&gt; <br>&gt;&gt; An alternative would be the ability to mark closure properties as weak or unowned. Then I could, at the *child* level, say:<br>&gt;&gt; <br>&gt;&gt; 	unowned let onSomeEvent: () -&gt; Void<br>&gt;&gt; <br>&gt;&gt; * * *<br>&gt;&gt; <br>&gt;&gt; Does this make sense? What do you think?<br>&gt;&gt; <br>&gt;&gt; — Radek<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b2fa5f52f699e07a98fefcf30fb95354?s=50"></div><header><strong>A shortcut for weakly referencing functions</strong> from <string>James Richard</string> &lt;ketzu at me.com&gt;<p>April 12, 2016 at 09:00:00am</p></header><div class="content"><p>I run into this a lot and love this idea.<br></p><p>&gt; On Apr 1, 2016, at 8:09 AM, Radosław Pietruszewski via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Here’s a pattern I find myself doing quite often:<br>&gt; <br>&gt;  1&gt; class Child {<br>&gt;  2.     var onSomeEvent: () -&gt; Void = { }<br>&gt;  3. }<br>&gt;  4&gt; class Parent {<br>&gt;  5.     let child = Child()<br>&gt;  6.     init() {<br>&gt;  7.         child.onSomeEvent = doSomething<br>&gt;  8.     }<br>&gt;  9.     func doSomething() {<br>&gt; 10.     }<br>&gt; 11. }<br>&gt; <br>&gt; I have some ownership hierarchy of classes (often controllers — view controllers — views), where I pass information from children up to parents using closures set by the parent.<br>&gt; <br>&gt; I like this pattern because children classes don’t have to be tied to knowledge about their parents, and I don’t have to define delegate protocols. It’s very clean, and also very easy to set up.<br>&gt; <br>&gt; The only problem is that there’s a strong danger of introducing reference cycles.<br>&gt; <br>&gt; With class properties, you can quite easily see the potential for a reference cycle and mark references to parents with weak/unowned. And with `self` captures in closures, you’re reminded of memory management by having to be explicit about `self`. But when passing references from parents to children, there’s no way to mark the closure property as `weak` (and there’s no reminder of the danger).<br>&gt; <br>&gt; * * *<br>&gt; <br>&gt; Right now, every time I pass a closure down to children, I have to wrap my references like so:<br>&gt; <br>&gt; 	{ [unowned self] self.doSomething($0) }<br>&gt; <br>&gt; instead of a neat and simple function reference:<br>&gt; <br>&gt; 	doSomething<br>&gt; <br>&gt; I think it would be useful to have a shortcut syntax for creating weak and unowned references to functions, like so:<br>&gt; <br>&gt; 	@unowned(doSomething)<br>&gt; <br>&gt; or perhaps:<br>&gt; <br>&gt; 	#unowned(self.doSomething)<br>&gt; <br>&gt; * * *<br>&gt; <br>&gt; An alternative would be the ability to mark closure properties as weak or unowned. Then I could, at the *child* level, say:<br>&gt; <br>&gt; 	unowned let onSomeEvent: () -&gt; Void<br>&gt; <br>&gt; * * *<br>&gt; <br>&gt; Does this make sense? What do you think?<br>&gt; <br>&gt; — Radek<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
