<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1e83fc5a49e9f8a7596a4d06cb781bf7?s=50"></div><header><strong>Type inference of functions with more than one statement</strong> from <string>Ross LeBeau</string> &lt;ross.lebeau at gmail.com&gt;<p>July  8, 2016 at 01:00:00pm</p></header><div class="content"><p>It seems that the compiler fails to infer the type of an anonymous function<br>if the function contains more than one statement. For example, this works:<br></p><p>let a = [[1,2],[3],[4,5,6]]<br>var b: [Int]<br>b = a.flatMap { elem in<br>  return elem<br>}<br></p><p>But this fails with an error &quot;cannot convert return expression of type<br>&#39;[Int]&#39; to return type &#39;Int?&#39;&quot;:<br></p><p>b = a.flatMap { elem in<br>  print(elem)<br>  return elem<br>}<br></p><p>And, of course, if you explicitly type the function, it works again:<br></p><p>b = a.flatMap { (elem: [Int]) -&gt; [Int] in<br>  print(elem)<br>  return elem<br>}<br></p><p>Greg Titus informed me that this is due to a heuristic in the compiler<br>where it only imports the outer context when type-checking anonymous<br>functions with a single statement. Before we knew this, I and others, found<br>it perplexing that out of two functions that return the same value, one<br>will compile and the other will not.<br></p><p>Are there any plans to extend the context of type-checking in the case of a<br>failure like this? If not, is it something to consider? It seems like a<br>difficult problem to solve without rather advanced knowledge of what&#39;s<br>going on.<br></p><p>Also if this has already been brought up, forgive me, I just subscribed to<br>this list and a quick search of the archives didn&#39;t get any hits :)<br></p><p>-- <br>Ross<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160708/49390951/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>Type inference of functions with more than one statement</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>July  8, 2016 at 11:00:00am</p></header><div class="content"><p>Hi Ross,<br></p><p>Swift&#39;s type inference operates at the level of a single statement. This is why we can infer parameter and return types for single-expression closures. While conceptually, it would not be a huge change to the type checker algorithm to support global type inference for closures and other functions consisting of multiple statements, we feel that philosophically, this is not a direction the language should take. Global type inference will further exacerbate performance problems with type checking, as well as make it harder to produce good diagnostics.<br></p><p>So really, this has less to do with closures per se, and more with just the general design and philosophy of the type checker.<br></p><p>(Please correct me if I&#39;ve mis-represented anything here -- this is my recollection of listening in on various discussions in the past).<br></p><p>&gt; On Jul 8, 2016, at 10:00 AM, Ross LeBeau via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; It seems that the compiler fails to infer the type of an anonymous function if the function contains more than one statement. For example, this works:<br>&gt; <br>&gt; let a = [[1,2],[3],[4,5,6]]<br>&gt; var b: [Int]<br>&gt; b = a.flatMap { elem in<br>&gt;   return elem<br>&gt; }<br>&gt; <br>&gt; But this fails with an error &quot;cannot convert return expression of type &#39;[Int]&#39; to return type &#39;Int?&#39;&quot;:<br>&gt; <br>&gt; b = a.flatMap { elem in<br>&gt;   print(elem)<br>&gt;   return elem<br>&gt; }<br>&gt; <br>&gt; And, of course, if you explicitly type the function, it works again:<br>&gt; <br>&gt; b = a.flatMap { (elem: [Int]) -&gt; [Int] in<br>&gt;   print(elem)<br>&gt;   return elem<br>&gt; }<br>&gt; <br>&gt; Greg Titus informed me that this is due to a heuristic in the compiler where it only imports the outer context when type-checking anonymous functions with a single statement. Before we knew this, I and others, found it perplexing that out of two functions that return the same value, one will compile and the other will not.<br>&gt; <br>&gt; Are there any plans to extend the context of type-checking in the case of a failure like this? If not, is it something to consider? It seems like a difficult problem to solve without rather advanced knowledge of what&#39;s going on.<br>&gt; <br>&gt; Also if this has already been brought up, forgive me, I just subscribed to this list and a quick search of the archives didn&#39;t get any hits :)<br>&gt; <br>&gt; -- <br>&gt; Ross<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1e83fc5a49e9f8a7596a4d06cb781bf7?s=50"></div><header><strong>Type inference of functions with more than one statement</strong> from <string>Ross LeBeau</string> &lt;ross.lebeau at gmail.com&gt;<p>July  8, 2016 at 11:00:00am</p></header><div class="content"><p>Hi Slava,<br></p><p>Thanks for the insight. This is what I suspected, but I wasn&#39;t sure about<br>how set the team was on this concept. Currently, it seems that if the types<br>cannot be inferred, the type checker picks an implementation and checks<br>against that.<br></p><p>E.g., the following code works because it conforms to the signature of the<br>flatMap that the type checker decided to use:<br></p><p>b = a.flatMap { elem in<br>  print(elem)<br>  return 1<br>}<br></p><p>Given that adding multi-statement type inference is off the table, perhaps<br>you could consider adding a helpful message when this situation arises?<br>Like if type inference of a closure fails, and the closure doesn&#39;t type<br>check with the assumed context, maybe tell the user &quot;Did not infer types,<br>try explicitly declaring them&quot;?<br></p><p>Just trying to think of a way to guide a less advanced user, since this<br>error could arise from many functions and also from genuine errors, so it<br>may be hard to google/ask for help with.<br></p><p>-- <br>Ross LeBeau<br></p><p>On July 8, 2016 at 2:31:46 PM, Slava Pestov (spestov at apple.com) wrote:<br></p><p>Hi Ross,<br></p><p>Swift&#39;s type inference operates at the level of a single statement. This is<br>why we can infer parameter and return types for single-expression closures.<br>While conceptually, it would not be a huge change to the type checker<br>algorithm to support global type inference for closures and other functions<br>consisting of multiple statements, we feel that philosophically, this is<br>not a direction the language should take. Global type inference will<br>further exacerbate performance problems with type checking, as well as make<br>it harder to produce good diagnostics.<br></p><p>So really, this has less to do with closures per se, and more with just the<br>general design and philosophy of the type checker.<br></p><p>(Please correct me if I&#39;ve mis-represented anything here -- this is my<br>recollection of listening in on various discussions in the past).<br></p><p>&gt; On Jul 8, 2016, at 10:00 AM, Ross LeBeau via swift-dev &lt;<br>swift-dev at swift.org&gt; wrote:<br>&gt;<br>&gt; It seems that the compiler fails to infer the type of an anonymous<br>function if the function contains more than one statement. For example,<br>this works:<br>&gt;<br>&gt; let a = [[1,2],[3],[4,5,6]]<br>&gt; var b: [Int]<br>&gt; b = a.flatMap { elem in<br>&gt; return elem<br>&gt; }<br>&gt;<br>&gt; But this fails with an error &quot;cannot convert return expression of type<br>&#39;[Int]&#39; to return type &#39;Int?&#39;&quot;:<br>&gt;<br>&gt; b = a.flatMap { elem in<br>&gt; print(elem)<br>&gt; return elem<br>&gt; }<br>&gt;<br>&gt; And, of course, if you explicitly type the function, it works again:<br>&gt;<br>&gt; b = a.flatMap { (elem: [Int]) -&gt; [Int] in<br>&gt; print(elem)<br>&gt; return elem<br>&gt; }<br>&gt;<br>&gt; Greg Titus informed me that this is due to a heuristic in the compiler<br>where it only imports the outer context when type-checking anonymous<br>functions with a single statement. Before we knew this, I and others, found<br>it perplexing that out of two functions that return the same value, one<br>will compile and the other will not.<br>&gt;<br>&gt; Are there any plans to extend the context of type-checking in the case of<br>a failure like this? If not, is it something to consider? It seems like a<br>difficult problem to solve without rather advanced knowledge of what&#39;s<br>going on.<br>&gt;<br>&gt; Also if this has already been brought up, forgive me, I just subscribed<br>to this list and a quick search of the archives didn&#39;t get any hits :)<br>&gt;<br>&gt; --<br>&gt; Ross<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160708/018360ed/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>Type inference of functions with more than one statement</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>July  8, 2016 at 11:00:00am</p></header><div class="content"><p>Hi Ross,<br></p><p>That&#39;s a good point. Do you mind filing a JIRA issue for this?<br></p><p>Slava<br></p><p>&gt; On Jul 8, 2016, at 11:56 AM, Ross LeBeau &lt;ross.lebeau at gmail.com&gt; wrote:<br>&gt; <br>&gt; Hi Slava,<br>&gt; <br>&gt; Thanks for the insight. This is what I suspected, but I wasn&#39;t sure about how set the team was on this concept. Currently, it seems that if the types cannot be inferred, the type checker picks an implementation and checks against that.<br>&gt; <br>&gt; E.g., the following code works because it conforms to the signature of the flatMap that the type checker decided to use:<br>&gt; <br>&gt; b = a.flatMap { elem in<br>&gt;   print(elem)<br>&gt;   return 1<br>&gt; }<br>&gt; <br>&gt; Given that adding multi-statement type inference is off the table, perhaps you could consider adding a helpful message when this situation arises? Like if type inference of a closure fails, and the closure doesn&#39;t type check with the assumed context, maybe tell the user &quot;Did not infer types, try explicitly declaring them&quot;?<br>&gt; <br>&gt; Just trying to think of a way to guide a less advanced user, since this error could arise from many functions and also from genuine errors, so it may be hard to google/ask for help with.<br>&gt; <br>&gt; -- <br>&gt; Ross LeBeau<br>&gt; <br>&gt; On July 8, 2016 at 2:31:46 PM, Slava Pestov (spestov at apple.com &lt;mailto:spestov at apple.com&gt;) wrote:<br>&gt; <br>&gt;&gt; Hi Ross, <br>&gt;&gt; <br>&gt;&gt; Swift&#39;s type inference operates at the level of a single statement. This is why we can infer parameter and return types for single-expression closures. While conceptually, it would not be a huge change to the type checker algorithm to support global type inference for closures and other functions consisting of multiple statements, we feel that philosophically, this is not a direction the language should take. Global type inference will further exacerbate performance problems with type checking, as well as make it harder to produce good diagnostics. <br>&gt;&gt; <br>&gt;&gt; So really, this has less to do with closures per se, and more with just the general design and philosophy of the type checker. <br>&gt;&gt; <br>&gt;&gt; (Please correct me if I&#39;ve mis-represented anything here -- this is my recollection of listening in on various discussions in the past). <br>&gt;&gt; <br>&gt;&gt; &gt; On Jul 8, 2016, at 10:00 AM, Ross LeBeau via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote: <br>&gt;&gt; &gt;  <br>&gt;&gt; &gt; It seems that the compiler fails to infer the type of an anonymous function if the function contains more than one statement. For example, this works: <br>&gt;&gt; &gt;  <br>&gt;&gt; &gt; let a = [[1,2],[3],[4,5,6]] <br>&gt;&gt; &gt; var b: [Int] <br>&gt;&gt; &gt; b = a.flatMap { elem in <br>&gt;&gt; &gt; return elem <br>&gt;&gt; &gt; } <br>&gt;&gt; &gt;  <br>&gt;&gt; &gt; But this fails with an error &quot;cannot convert return expression of type &#39;[Int]&#39; to return type &#39;Int?&#39;&quot;: <br>&gt;&gt; &gt;  <br>&gt;&gt; &gt; b = a.flatMap { elem in <br>&gt;&gt; &gt; print(elem) <br>&gt;&gt; &gt; return elem <br>&gt;&gt; &gt; } <br>&gt;&gt; &gt;  <br>&gt;&gt; &gt; And, of course, if you explicitly type the function, it works again: <br>&gt;&gt; &gt;  <br>&gt;&gt; &gt; b = a.flatMap { (elem: [Int]) -&gt; [Int] in <br>&gt;&gt; &gt; print(elem) <br>&gt;&gt; &gt; return elem <br>&gt;&gt; &gt; } <br>&gt;&gt; &gt;  <br>&gt;&gt; &gt; Greg Titus informed me that this is due to a heuristic in the compiler where it only imports the outer context when type-checking anonymous functions with a single statement. Before we knew this, I and others, found it perplexing that out of two functions that return the same value, one will compile and the other will not. <br>&gt;&gt; &gt;  <br>&gt;&gt; &gt; Are there any plans to extend the context of type-checking in the case of a failure like this? If not, is it something to consider? It seems like a difficult problem to solve without rather advanced knowledge of what&#39;s going on. <br>&gt;&gt; &gt;  <br>&gt;&gt; &gt; Also if this has already been brought up, forgive me, I just subscribed to this list and a quick search of the archives didn&#39;t get any hits :) <br>&gt;&gt; &gt;  <br>&gt;&gt; &gt; --  <br>&gt;&gt; &gt; Ross <br>&gt;&gt; &gt; _______________________________________________ <br>&gt;&gt; &gt; swift-dev mailing list <br>&gt;&gt; &gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt; <br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160708/b8c32ecf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1e83fc5a49e9f8a7596a4d06cb781bf7?s=50"></div><header><strong>Type inference of functions with more than one statement</strong> from <string>Ross LeBeau</string> &lt;ross.lebeau at gmail.com&gt;<p>July  8, 2016 at 01:00:00pm</p></header><div class="content"><p>Filed here: https://bugs.swift.org/browse/SR-2033<br></p><p>Thanks for the help! Cool to learn a new thing about Swift today :)<br></p><p>-- <br>Ross LeBeau<br></p><p>On July 8, 2016 at 2:57:55 PM, Slava Pestov (spestov at apple.com) wrote:<br></p><p>&quot;Did not infer types, try explicitly declaring them&quot;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160708/cc963e1e/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
