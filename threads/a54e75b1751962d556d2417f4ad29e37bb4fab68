<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/30e4ca9ef73f6a84d52c26952c180bcd?s=50"></div><header><strong>[Discussion] Binary search, lower bound, upper bound, equal range</strong> from <string>Jeff Hajewski</string> &lt;jeff.hajewski at gmail.com&gt;<p>February 15, 2016 at 03:00:00pm</p></header><div class="content"><p>Hello,<br></p><p>I am working on SR-368 &lt;https://bugs.swift.org/browse/SR-368&gt; and am hoping to get some feedback from the community.<br></p><p>Description<br>Implement analogs to C++’s binary_search, lower_bound, upper_bound, and equal_range algorithms.<br></p><p>Initial Proposal<br>I propose adding four methods for generic Array and adding four methods for Arrays that conform to Comparable:<br></p><p><br>Array<br>@warn_unused_result<br>func lowerBound(value: Array.Element, @noescape isOrderedBefore: (lhs: Array.Element, rhs: Array.Element) -&gt; Bool) -&gt; Int?<br></p><p>@warn_unused_result<br>func upperBound(value: Array.Element, @noescape isOrderedBefore: (lhs: Array.Element, rhs: Array.Element) -&gt; Bool) -&gt; Int?<br></p><p>@warn_unused_result<br>func binarySearch(value: Array.Element, @noescape isOrderedBefore:(lhs: Array.Element, rhs: Array.Element) -&gt; Bool) -&gt; Bool<br></p><p>@warn_unused_result<br>func equalRange(value: Array.Element, @noescape isOrderedBefore: (lhs: Array.Element, rhs: Array.Element) -&gt; Bool) -&gt; Range&lt;Int&gt;?<br></p><p><br>Array: Comparable<br>@warn_unused_result<br>func lowerBound(value: Array.Element) -&gt; Int?<br></p><p>@warn_unused_result<br>func upperBound(value: Array.Element) -&gt; Int?<br></p><p>@warn_unused_result<br>func binarySearch(value: Array.Element) -&gt; Bool<br></p><p>@warn_unused_result<br>func equalRange(value: Array.Element) -&gt; Range&lt;Int&gt;?<br></p><p>Discussion<br>The main issue I’d like to discuss is how do we want to add these to Swift? My thoughts are as follows:<br></p><p>These should be as generic as possible. I initially started at the CollectionType level but it seemed that the problem was ultimately reduced to an Array (through the use of various protocols, etc.). For example, suppose we implemented these methods as an extension to CollectionType, if we were to try and call binarySearch on a set, we would first need to sort the set, which would return an array, and then we would call binarySearch on that array. Similarly, it seems at the SequenceType level the problem ultimately reduces to using Array.<br>Does it make sense to handle these as public functions? I tend to think not as it seems less idiomatic.<br>I suggest eight implementations similar to how sort() is handled. If the calling array’s elements conform to Comparable, then no isOrderedBefore closure is required since we can use “&lt;“, otherwise the user should supply a closure to allow the algorithm determine how the array elements are ordered.<br>Similar to the C++ implementations, I avoid recursion and favor while-loops<br>These methods should be preconditioned on the calling array be partitioned with respect to the passed value. As far as I’m aware, there is no “isPartitioned(value:)” method currently available. Should we add this as well? We could use this functionality and not add a isPartitioned method but if we are adding this functionality is there a good reason not to give the public access? The alternative is to not set a precondition and document that the results may not be valid if the calling array is not partitioned with respect to value. I favor the preconditioning approach.<br></p><p>Any and all feedback is greatly appreciated!<br></p><p>Thanks<br>Jeff<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160215/a54eab68/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a6a2eebe83a60a4b42395145484cda15?s=50"></div><header><strong>[Discussion] Binary search, lower bound, upper bound, equal range</strong> from <string>Daniel Vollmer</string> &lt;lists at maven.de&gt;<p>February 15, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On 15 Feb 2016, at 21:35, Jeff Hajewski via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello,<br>&gt; <br>&gt; Description<br>&gt; Implement analogs to C++’s binary_search, lower_bound, upper_bound, and equal_range algorithms.<br>&gt; <br>&gt; Initial Proposal<br>&gt; I propose adding four methods for generic Array and adding four methods for Arrays that conform to Comparable:<br></p><p>Over the weekend, I looked at what I would require for porting a simple kd-tree from C++ to Swift, and other than stable sort I was also lacking equal_range. But I think that defining the interface for these methods on Array would be a mistake: One thing the STL got very right is that the caller gets to pick the iterators (ranges) for the algorithm. For the kd-tree, I would want to stable_sort and apply equal_range to recursively smaller segments (slices?) of an Array, and not always the complete one.<br></p><p>	Daniel.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/30e4ca9ef73f6a84d52c26952c180bcd?s=50"></div><header><strong>[Discussion] Binary search, lower bound, upper bound, equal range</strong> from <string>Jeff Hajewski</string> &lt;jeff.hajewski at gmail.com&gt;<p>February 15, 2016 at 08:00:00pm</p></header><div class="content"><p>Thanks Daniel - comments regarding Array vs CollectionType are duly noted. Stable sort is next on my list unless someone else tackles it before I finish this work. I suppose I’ll be adding isPartitioned as well at some point.<br></p><p>Thanks again for the comments<br>Jeff<br></p><p>&gt; On Feb 15, 2016, at 5:45 PM, Daniel Vollmer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 15 Feb 2016, at 21:35, Jeff Hajewski via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello,<br>&gt;&gt; <br>&gt;&gt; Description<br>&gt;&gt; Implement analogs to C++’s binary_search, lower_bound, upper_bound, and equal_range algorithms.<br>&gt;&gt; <br>&gt;&gt; Initial Proposal<br>&gt;&gt; I propose adding four methods for generic Array and adding four methods for Arrays that conform to Comparable:<br>&gt; <br>&gt; Over the weekend, I looked at what I would require for porting a simple kd-tree from C++ to Swift, and other than stable sort I was also lacking equal_range. But I think that defining the interface for these methods on Array would be a mistake: One thing the STL got very right is that the caller gets to pick the iterators (ranges) for the algorithm. For the kd-tree, I would want to stable_sort and apply equal_range to recursively smaller segments (slices?) of an Array, and not always the complete one.<br>&gt; <br>&gt; 	Daniel.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160215/6e498e2f/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
