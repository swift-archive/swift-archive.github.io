<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/abab8a25de5c943e3481fd3f95f3d89a?s=50"></div><header><strong>Another way of designing server side</strong> from <string>Антон Миронов</string> &lt;antonvmironov at gmail.com&gt;<p>November  7, 2016 at 12:00:00am</p></header><div class="content"><p>Hi everyone,<br></p><p>The first goals for server side are building networking, security, and HTTP/WebSocket parsing. Core components are super important but they are just components. Adding those up will not guarantee success. So I just want to suggest to make the design in another way. It is a little bit trickier but is much more efficient.<br></p><p>I consider multiple levels of design:<br></p><p>1. Swift ideology: safe, fast, expressive.<br>2. A basic set of designing rules on top of an ideology. For example (you might completely disagree with all of them, but these are just an example):<br>    - prefer a functional approach (purity, lambdas, monads and etc)<br>    - prefer a reactive approach<br>    - carefully consider use of class inheritance<br>    - mutability only when you need it<br>    - build APIs that are hard to break or use in a not intended way<br>    - TODO<br></p><p>    I really miss these. On my opinion, the basic set of rules must be well discussed, written down, made public.<br>    <br>3. System architecture (of server side or anything else) on top of the basic set of designing rules. I assume that there is one for server side somewhere. I suggest making it more visible.<br>4. Design of components and tools. I think that networking, security, and HTTP/WebSocket parsing are on this level.<br></p><p>Each level may not be engraved in concrete and must be reconsidered iteratively (maybe except for the first one).<br>So what do you think?<br></p><p>Thanks,<br>Anton Mironov<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Another way of designing server side</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>November  7, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On Nov 6, 2016, at 2:10 PM, Anton Mironov via swift-server-dev &lt;swift-server-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; 2. A basic set of designing rules on top of an ideology. For example (you might completely disagree with all of them, but these are just an example):<br>&gt;    - prefer a functional approach (purity, lambdas, monads and etc)<br>&gt;    - prefer a reactive approach<br>&gt;    - carefully consider use of class inheritance<br>&gt;    - mutability only when you need it<br>&gt;    - build APIs that are hard to break or use in a not intended way<br>&gt;    - TODO<br>&gt; <br>&gt;    I really miss these. On my opinion, the basic set of rules must be well discussed, written down, made public.<br></p><p>I disagree with this.<br></p><p>A web framework ought to be opinionated and consistent, and thus should have a strong, single-paradigm design. But the working group is not designing a web framework; it&#39;s designing the *infrastructure* for web frameworks. Designers should be able to take the output of this group and use it to make a framework that matches their vision of web programmer. One developer might design a traditionally functional framework; another might design a functional reactive one; a third might design a class-based MVC framework; a fourth might design a highly dynamic &quot;convention over configuration&quot; framework; a fifth might be very careful to file all the edges off. All of them should be able to use the networking, security, protocol, etc. primitives this group designs.<br></p><p>Obviously we should make sure the primitives are well-designed and flexible enough to accommodate many paradigms. But that&#39;s different from engineering paradigm opinions into them.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/db5e2fe903111a67076e0a6b97e635dd?s=50"></div><header><strong>Another way of designing server side</strong> from <string>Tyler Cloutier</string> &lt;cloutiertyler at aol.com&gt;<p>November  7, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On Nov 7, 2016, at 12:27 AM, Brent Royal-Gordon via swift-server-dev &lt;swift-server-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; A web framework ought to be opinionated and consistent, and thus should have a strong, single-paradigm design. But the working group is not designing a web framework; it&#39;s designing the *infrastructure* for web frameworks. Designers should be able to take the output of this group and use it to make a framework that matches their vision of web programmer. One developer might design a traditionally functional framework; another might design a functional reactive one; a third might design a class-based MVC framework; a fourth might design a highly dynamic &quot;convention over configuration&quot; framework; a fifth might be very careful to file all the edges off. All of them should be able to use the networking, security, protocol, etc. primitives this group designs.<br></p><p>+1<br></p><p>The infrastructure needs to be able to support each type of web framework, while still providing Swifty APIs for networking. Handling (or explicitly not handling) asynchrony will be an interesting part of this I think.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-server-dev/attachments/20161107/846bf62c/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/abab8a25de5c943e3481fd3f95f3d89a?s=50"></div><header><strong>Another way of designing server side</strong> from <string>Антон Миронов</string> &lt;antonvmironov at gmail.com&gt;<p>November  7, 2016 at 10:00:00am</p></header><div class="content"><p>As you say, those primitives must be well-designed: criterion A, criterion B, criterion C.  Primitives must be flexible to accommodate: paradigm  A, paradigm B, paradigm C. That still looks like design guidelines to me.<br></p><p>&gt; 7 лист. 2016 р. о 10:27 Brent Royal-Gordon &lt;brent at architechies.com&gt; написав(ла):<br>&gt; <br>&gt;&gt; On Nov 6, 2016, at 2:10 PM, Anton Mironov via swift-server-dev &lt;swift-server-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; 2. A basic set of designing rules on top of an ideology. For example (you might completely disagree with all of them, but these are just an example):<br>&gt;&gt;   - prefer a functional approach (purity, lambdas, monads and etc)<br>&gt;&gt;   - prefer a reactive approach<br>&gt;&gt;   - carefully consider use of class inheritance<br>&gt;&gt;   - mutability only when you need it<br>&gt;&gt;   - build APIs that are hard to break or use in a not intended way<br>&gt;&gt;   - TODO<br>&gt;&gt; <br>&gt;&gt;   I really miss these. On my opinion, the basic set of rules must be well discussed, written down, made public.<br>&gt; <br>&gt; I disagree with this.<br>&gt; <br>&gt; A web framework ought to be opinionated and consistent, and thus should have a strong, single-paradigm design. But the working group is not designing a web framework; it&#39;s designing the *infrastructure* for web frameworks. Designers should be able to take the output of this group and use it to make a framework that matches their vision of web programmer. One developer might design a traditionally functional framework; another might design a functional reactive one; a third might design a class-based MVC framework; a fourth might design a highly dynamic &quot;convention over configuration&quot; framework; a fifth might be very careful to file all the edges off. All of them should be able to use the networking, security, protocol, etc. primitives this group designs.<br>&gt; <br>&gt; Obviously we should make sure the primitives are well-designed and flexible enough to accommodate many paradigms. But that&#39;s different from engineering paradigm opinions into them.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
