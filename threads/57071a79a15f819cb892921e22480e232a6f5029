<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>mutating/non-mutating suggestion from a Rubyist</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April 22, 2016 at 02:00:00pm</p></header><div class="content"><p>on Thu Apr 21 2016, Daniel Steinberg &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Pardon me if this has been raised before.<br>&gt;<br>&gt; I gave a short presentation at our Cleveland CocoaHeads this week on<br>&gt; what is coming in Swift 3. One of the attendees stayed behind to ask<br>&gt; about the naming guidelines for mutating vs non-mutating. He is fairly<br>&gt; new to Swift - coming from Ruby. I have no Ruby experience but am<br>&gt; passing his thoughts on to this list.<br>&gt;<br>&gt; He said that in Ruby they decorate the name with a symbol (I believe<br>&gt; in their case it is “!”) to distinguish between the two. Although<br>&gt; usually I’m not a fan of such naming conventions, we do something<br>&gt; similar with inout parameters.<br>&gt;<br>&gt; For example, if we have<br>&gt;<br>&gt; func myFunc(param: inout String) { …}<br>&gt;<br>&gt; we call it like this (using the Swift 3 first label convention)<br>&gt;<br>&gt; myFunc(param: &amp;aName)<br>&gt;<br>&gt; We use the &amp; to signal that the value of aName might be changed by the call to myFunc().<br>&gt;<br>&gt; Similarly, instead of settling on a naming convention for verb vs<br>&gt; verbed/verbing we could name the methods descriptively and require a<br>&gt; symbol (here I use &amp; but only for illustration) to distinguish between<br>&gt; mutating and non-mutating<br>&gt;<br>&gt; so we would have <br>&gt;<br>&gt; myArray.sort&amp;()<br>&gt;<br>&gt; and<br>&gt;<br>&gt; sortedArray = myArray.sort()<br>&gt;<br>&gt; Xcode and other tools could enforce this naming pattern and warn us<br>&gt; that a mutating method must end in “&amp;” and that a non-mutating method<br>&gt; is not allowed to.<br></p><p>This is not a new idea.  Something almost identical to this has been<br>explored and discussed quite thoroughly already:<br>&lt;https://github.com/apple/swift/blob/master/docs/proposals/Inplace.rst&gt;.<br>In fact, it was implmented and later reverted because it raised<br>language-design questions for which we had no good answers.  I don&#39;t<br>believe the choice of glyph (&amp; vs =) affects any of the fundamental<br>issues:<br></p><p>* Should the x.=f() syntax be required for *every* mutating method<br>  invocation?<br></p><p>* Are assignment methods a redundant way to spell mutating methods?<br>  Should we really have both mechanisms?<br></p><p>* Can we really introduce this feature without having a way to apply it<br>  to class types?<br></p><p>I should also point out that under the assignment method paradigm one<br>would probably need to re-evalutate rules for naming.  Under the current<br>API guidelines&#39; approach, we&#39;d write:<br></p><p>    x.=sorted()      // sort x in-place<br></p><p>and I am not sure how easy that would be for people to swallow<br>considering how much more straightforward<br></p><p>    x.sort()         // current way to sort x in-place<br></p><p>is, and because the language now contains explicit notation for<br>mutation, it becomes harder to argue against theis pair:<br></p><p>    y = x.sort()<br>    x.=sort()      // sort x in place<br></p><p>Lastly, I should point out that the proposal does nothing to solve the<br>problem of `c.formSuccessor(&amp;i)`, since that doesn&#39;t mutate the<br>receiver.<br></p><p>I still like the proposal&#39;s basic approach and would love to see it used<br>to address these naming problems, but I want to be clear that it&#39;s by no<br>means a panacea and there are real obstacles between here and actually<br>being able to apply it.  If you want to move forward with something like<br>this, you need to solve the problems described above.<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5af07e950f10c7c1df1c44bed055c1eb?s=50"></div><header><strong>mutating/non-mutating suggestion from a Rubyist</strong> from <string>Daniel Steinberg</string> &lt;daniel at dimsumthinking.com&gt;<p>April 23, 2016 at 07:00:00am</p></header><div class="content"><p>Thank you Dave.<br></p><p>I appreciate your thoughtful and complete response and will think further on this.<br></p><p>Daniel<br>&gt; On Apr 22, 2016, at 11:24 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; on Thu Apr 21 2016, Daniel Steinberg &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Pardon me if this has been raised before.<br>&gt;&gt; <br>&gt;&gt; I gave a short presentation at our Cleveland CocoaHeads this week on<br>&gt;&gt; what is coming in Swift 3. One of the attendees stayed behind to ask<br>&gt;&gt; about the naming guidelines for mutating vs non-mutating. He is fairly<br>&gt;&gt; new to Swift - coming from Ruby. I have no Ruby experience but am<br>&gt;&gt; passing his thoughts on to this list.<br>&gt;&gt; <br>&gt;&gt; He said that in Ruby they decorate the name with a symbol (I believe<br>&gt;&gt; in their case it is “!”) to distinguish between the two. Although<br>&gt;&gt; usually I’m not a fan of such naming conventions, we do something<br>&gt;&gt; similar with inout parameters.<br>&gt;&gt; <br>&gt;&gt; For example, if we have<br>&gt;&gt; <br>&gt;&gt; func myFunc(param: inout String) { …}<br>&gt;&gt; <br>&gt;&gt; we call it like this (using the Swift 3 first label convention)<br>&gt;&gt; <br>&gt;&gt; myFunc(param: &amp;aName)<br>&gt;&gt; <br>&gt;&gt; We use the &amp; to signal that the value of aName might be changed by the call to myFunc().<br>&gt;&gt; <br>&gt;&gt; Similarly, instead of settling on a naming convention for verb vs<br>&gt;&gt; verbed/verbing we could name the methods descriptively and require a<br>&gt;&gt; symbol (here I use &amp; but only for illustration) to distinguish between<br>&gt;&gt; mutating and non-mutating<br>&gt;&gt; <br>&gt;&gt; so we would have <br>&gt;&gt; <br>&gt;&gt; myArray.sort&amp;()<br>&gt;&gt; <br>&gt;&gt; and<br>&gt;&gt; <br>&gt;&gt; sortedArray = myArray.sort()<br>&gt;&gt; <br>&gt;&gt; Xcode and other tools could enforce this naming pattern and warn us<br>&gt;&gt; that a mutating method must end in “&amp;” and that a non-mutating method<br>&gt;&gt; is not allowed to.<br>&gt; <br>&gt; This is not a new idea.  Something almost identical to this has been<br>&gt; explored and discussed quite thoroughly already:<br>&gt; &lt;https://github.com/apple/swift/blob/master/docs/proposals/Inplace.rst&gt;.<br>&gt; In fact, it was implmented and later reverted because it raised<br>&gt; language-design questions for which we had no good answers.  I don&#39;t<br>&gt; believe the choice of glyph (&amp; vs =) affects any of the fundamental<br>&gt; issues:<br>&gt; <br>&gt; * Should the x.=f() syntax be required for *every* mutating method<br>&gt;  invocation?<br>&gt; <br>&gt; * Are assignment methods a redundant way to spell mutating methods?<br>&gt;  Should we really have both mechanisms?<br>&gt; <br>&gt; * Can we really introduce this feature without having a way to apply it<br>&gt;  to class types?<br>&gt; <br>&gt; I should also point out that under the assignment method paradigm one<br>&gt; would probably need to re-evalutate rules for naming.  Under the current<br>&gt; API guidelines&#39; approach, we&#39;d write:<br>&gt; <br>&gt;    x.=sorted()      // sort x in-place<br>&gt; <br>&gt; and I am not sure how easy that would be for people to swallow<br>&gt; considering how much more straightforward<br>&gt; <br>&gt;    x.sort()         // current way to sort x in-place<br>&gt; <br>&gt; is, and because the language now contains explicit notation for<br>&gt; mutation, it becomes harder to argue against theis pair:<br>&gt; <br>&gt;    y = x.sort()<br>&gt;    x.=sort()      // sort x in place<br>&gt; <br>&gt; Lastly, I should point out that the proposal does nothing to solve the<br>&gt; problem of `c.formSuccessor(&amp;i)`, since that doesn&#39;t mutate the<br>&gt; receiver.<br>&gt; <br>&gt; I still like the proposal&#39;s basic approach and would love to see it used<br>&gt; to address these naming problems, but I want to be clear that it&#39;s by no<br>&gt; means a panacea and there are real obstacles between here and actually<br>&gt; being able to apply it.  If you want to move forward with something like<br>&gt; this, you need to solve the problems described above.<br>&gt; <br>&gt; -- <br>&gt; Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>mutating/non-mutating suggestion from a Rubyist</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>April 23, 2016 at 11:00:00am</p></header><div class="content"><p>I&#39;d like to second James Campbell&#39;s suggestion of a `mutate` keyword. Clarifying comments inline below:<br></p><p>&gt; On 23 Apr 2016, at 00:24, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This is not a new idea.  Something almost identical to this has been<br>&gt; explored and discussed quite thoroughly already:<br>&gt; &lt;https://github.com/apple/swift/blob/master/docs/proposals/Inplace.rst &lt;https://github.com/apple/swift/blob/master/docs/proposals/Inplace.rst&gt;&gt;.<br>&gt; In fact, it was implmented and later reverted because it raised<br>&gt; language-design questions for which we had no good answers.<br></p><p>I don&#39;t know if the following are particularly good answers, but I&#39;ll try anyway:<br></p><p>&gt; I don&#39;t believe the choice of glyph (&amp; vs =) affects any of the<br>&gt; fundamental issues:<br>&gt; <br>&gt; * Should the x.=f() syntax be required for *every* mutating method<br>&gt;  invocation?<br></p><p>Allow me to ask it differently: Should some specific syntax be required for every mutating method? — Yes.<br></p><p>Should the syntax be `x.=f()`? — Not necessarily. I kinda like James Campbell&#39;s idea of a `mutate` keyword. Consider the following:<br></p><p>    var numbers = [5, 12, 6, 2]<br>    mutate numbers.append(10)<br>    mutate numbers.sort()<br>    if let biggest = mutate numbers.popLast() {<br>        print(&quot;The biggest number was:&quot;, biggest)<br>    }<br></p><p>So `mutate` would work much like `try` but—unlike `try` which can move further to the left—`mutate` would have to always prefix the mutating receiver. Here&#39;s a contrived example of a corner case:<br></p><p>    enum Error : ErrorType { case BadNumber }<br></p><p>    func demo() throws -&gt; Int {<br>        <br>    }<br></p><p>&gt; * Are assignment methods a redundant way to spell mutating methods?<br>&gt;  Should we really have both mechanisms?<br></p><p>(I had to look up the definition of an assignment method. For the uninitiated, Dave is talking about what&#39;s written here: https://github.com/apple/swift/blob/master/docs/proposals/Inplace.rst#use-one-simple-name &lt;https://github.com/apple/swift/blob/master/docs/proposals/Inplace.rst#use-one-simple-name&gt;.)<br></p><p>— Yes they are redundant, and no, we should not have both.<br></p><p>With `mutate` required at the call site, we could simply allow both overloads `func sort()` and `mutating func sort()` to coexist, because the call sites become unambiguous:<br></p><p>    let originals = [2, 1, 3, 0, 4, 2]<br>    var copies = originals<br></p><p>    originals.sort()           // warning: result of call to &#39;sort()&#39; is unused<br>    mutate originals.sort()    // compiler error<br>    let xs = originals.sort()  // ok<br></p><p>    copies.sort()                 // warning: result of call to &#39;sort()&#39; is unused<br>    mutate copies.sort()          // ok<br>    let ys = copies.sort()        // ok<br>    let zs = mutate copies.sort() // warning: constant &#39;x&#39; inferred to have type &#39;()&#39;, which may be unexpected<br></p><p>The language could also allow the use of<br></p><p>    mutate x.next()<br></p><p>as shorthand for<br></p><p>    x = x.next()<br></p><p>when only the non-mutating variant `func next() -&gt; Self` exists with compatible return type.<br></p><p>&gt; * Can we really introduce this feature without having a way to apply it<br>&gt;  to class types?<br></p><p>Yes we can. Why complicate the naming of value type members with the complexities of reference semantics? The current API naming conventions are good for reference types which sometimes come with unobvious to obscure behaviour (i.e. anything from bumping an internal counter to firing missiles and wiping hard drives).<br></p><p>But value types ought to have no side effects (besides memory allocation and logging maybe), and so we don&#39;t necessarily need that strong a naming convention to limit their collateral damage.<br></p><p>If the `mutate` keyword became required for calling `mutating` methods, then operators would remain the only place where naming convention were needed to distinguish mutation:<br></p><p>Mutating assignment is explicit: `xs = [1, 2] + xs + [2, 1]` (i.e. `=` without `let` or `var` means mutation)<br>Mutating method call becomes explicit: `mutate xs.sort()` and `let x = mutate xs.removeAtIndex(2)`<br>Mutating function arguments are explicit with the `&amp;` prefix: `swap(&amp;xs, &amp;ys)`<br>Mutating operators are implicit and by convention, should end with the `=` symbol: `xs += [8, 9]`<br>Reference types have no notion of `mutating` members (and probably ought to remain that way) so they mutate implicitly.<br></p><p>&gt; I should also point out that under the assignment method paradigm one<br>&gt; would probably need to re-evalutate rules for naming.  Under the current<br>&gt; API guidelines&#39; approach, we&#39;d write:<br>&gt; <br>&gt;    x.=sorted()      // sort x in-place<br>&gt; <br>&gt; and I am not sure how easy that would be for people to swallow<br>&gt; considering how much more straightforward<br>&gt; <br>&gt;    x.sort()         // current way to sort x in-place<br>&gt; <br>&gt; is, and because the language now contains explicit notation for<br>&gt; mutation, it becomes harder to argue against theis pair:<br>&gt; <br>&gt;    y = x.sort()<br>&gt;    x.=sort()      // sort x in place<br></p><p>I agree that the current API guidelines wouldn&#39;t work for value types anymore. Both `sort` and `sorted` would be called `sort`.<br></p><p>&gt; Lastly, I should point out that the proposal does nothing to solve the<br>&gt; problem of `c.formSuccessor(&amp;i)`, since that doesn&#39;t mutate the<br>&gt; receiver.<br></p><p>This proposal does address the problem of `c.formSuccessor(&amp;i)`. Given that it&#39;s value types at play here, what mutates in the following is unambiguous even to non-native English speakers:<br></p><p>    c.frobnicate(&amp;i)                // cannot possibly mutate c but mutates i<br>    let j = c.frobnicate(i)         // cannot possibly mutate either<br>    mutate c.frobnicate(i)          // mutates c<br>    let k = mutate c.frobnicate(&amp;i) // mutates both<br></p><p>&gt; I still like the proposal&#39;s basic approach and would love to see it used<br>&gt; to address these naming problems, but I want to be clear that it&#39;s by no<br>&gt; means a panacea and there are real obstacles between here and actually<br>&gt; being able to apply it.  If you want to move forward with something like<br>&gt; this, you need to solve the problems described above.<br></p><p>I think this proposal would simplify all code handling value types. Yes, it adds one keyword of boilerplate but wins clarity in return. I think reference types should stay separate from this discussion, as their mutation has always been implicit anyway. The API guidelines set a good convention for them.<br></p><p>— Pyry<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160423/b05dd86d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>mutating/non-mutating suggestion from a Rubyist</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April 25, 2016 at 11:00:00am</p></header><div class="content"><p>on Sat Apr 23 2016, Pyry Jahkola &lt;pyry.jahkola-AT-iki.fi&gt; wrote:<br></p><p>&gt; I&#39;d like to second James Campbell&#39;s suggestion of a `mutate` keyword. Clarifying<br>&gt; comments inline below:<br>&gt;<br>&gt;     On 23 Apr 2016, at 00:24, Dave Abrahams via swift-evolution<br>&gt;     &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;     This is not a new idea. Something almost identical to this has been<br>&gt;     explored and discussed quite thoroughly already:<br>&gt;     &lt;https://github.com/apple/swift/blob/master/docs/proposals/Inplace.rst&gt;.<br>&gt;     In fact, it was implmented and later reverted because it raised<br>&gt;     language-design questions for which we had no good answers.<br>&gt;<br>&gt; I don&#39;t know if the following are particularly good answers, but I&#39;ll try<br>&gt; anyway:<br>&gt;<br>&gt;     I don&#39;t believe the choice of glyph (&amp; vs =) affects any of the<br>&gt;<br>&gt;     fundamental issues:<br>&gt;<br>&gt;     * Should the x.=f() syntax be required for *every* mutating method<br>&gt;     invocation?<br>&gt;<br>&gt; Allow me to ask it differently: Should some specific syntax be required for<br>&gt; every mutating method? — Yes.<br>&gt;<br>&gt; Should the syntax be `x.=f()`? — Not necessarily. I kinda like James Campbell&#39;s<br>&gt; idea of a `mutate` keyword. Consider the following:<br>&gt;<br>&gt; var numbers = [5, 12, 6, 2]<br>&gt; mutate numbers.append(10)<br>&gt; mutate numbers.sort()<br>&gt; if let biggest = mutate numbers.popLast() {<br>&gt; print(&quot;The biggest number was:&quot;, biggest)<br>&gt; }<br></p><p>Not that syntax is the most important question here, but that syntax is<br>super-heavyweight by comparison and unlikely to fly with many people<br>(including me) for that reason.<br></p><p>&gt; So `mutate` would work much like `try` but—unlike `try` which can move<br>&gt; further to the left—`mutate` would have to always prefix the mutating<br>&gt; receiver. Here&#39;s a contrived example of a corner case:<br>&gt;<br>&gt; enum Error : ErrorType { case BadNumber }<br>&gt;<br>&gt; func demo() throws -&gt; Int {<br>&gt; }<br>&gt;<br>&gt;     * Are assignment methods a redundant way to spell mutating methods?<br>&gt;     Should we really have both mechanisms?<br>&gt;<br>&gt; (I had to look up the definition of an assignment method. For the uninitiated,<br>&gt; Dave is talking about what&#39;s written here:<br>&gt; https://github.com/apple/swift/blob/master/docs/proposals/Inplace.rst#use-one-simple-name.)<br>&gt;<br>&gt; — Yes they are redundant, and no, we should not have both.<br>&gt;<br>&gt; With `mutate` required at the call site, we could simply allow both overloads<br>&gt; `func sort()` and `mutating func sort()` to coexist, because the call sites<br>&gt; become unambiguous:<br>&gt;<br>&gt; let originals = [2, 1, 3, 0, 4, 2]<br>&gt; var copies = originals<br>&gt;<br>&gt; originals.sort() // warning: result of call to &#39;sort()&#39; is unused<br>&gt; mutate originals.sort() // compiler error<br>&gt; let xs = originals.sort() // ok<br>&gt;<br>&gt; copies.sort() // warning: result of call to &#39;sort()&#39; is unused<br>&gt; mutate copies.sort() // ok<br>&gt; let ys = copies.sort() // ok<br>&gt; let zs = mutate copies.sort() // warning: constant &#39;x&#39; inferred to have type &#39;<br>&gt; ()&#39;, which may be unexpected<br>&gt;<br>&gt; The language could also allow the use of<br>&gt;<br>&gt; mutate x.next()<br>&gt;<br>&gt; as shorthand for<br>&gt;<br>&gt; x = x.next()<br>&gt;<br>&gt; when only the non-mutating variant `func next() -&gt; Self` exists with<br>&gt; compatible return type.<br>&gt;<br>&gt;     * Can we really introduce this feature without having a way to apply it<br>&gt;     to class types?<br>&gt;<br>&gt; Yes we can. Why complicate the naming of value type members with the<br>&gt; complexities of reference semantics? <br></p><p>Because some people still imagine that classes should have all the same<br>basic capabilities as value types, and that protocols should unify them.<br>That makes these people suspicious of language features that could<br>threaten to make classes “second-class citizens.”<br></p><p>Maybe the Foundation value types effort will begin to change that; I&#39;m<br>not sure.<br></p><p>&gt; The current API naming conventions are good for reference types which<br>&gt; sometimes come with unobvious to obscure behaviour (i.e. anything from<br>&gt; bumping an internal counter to firing missiles and wiping hard<br>&gt; drives).<br>&gt;<br>&gt; But value types ought to have no side effects (besides memory allocation and<br>&gt; logging maybe), and so we don&#39;t necessarily need that strong a naming convention<br>&gt; to limit their collateral damage.<br>&gt;<br>&gt; If the `mutate` keyword became required for calling `mutating` methods, then<br>&gt; operators would remain the only place where naming convention were needed to<br>&gt; distinguish mutation:<br>&gt;<br>&gt; * Mutating assignment is explicit: `xs = [1, 2] + xs + [2, 1]` (i.e. `=` without<br>&gt;   `let` or `var` means mutation)<br>&gt; * Mutating method call becomes explicit: `mutate xs.sort()` and `let x = mutate<br>&gt;   xs.removeAtIndex(2)`<br>&gt; * Mutating function arguments are explicit with the `&amp;` prefix: `swap(&amp;xs, &amp;ys)`<br>&gt; * Mutating operators are implicit and by convention, should end with the `=`<br>&gt;   symbol: `xs += [8, 9]`<br>&gt; * Reference types have no notion of `mutating` members (and probably ought to<br>&gt;   remain that way) so they mutate implicitly.<br>&gt;<br>&gt;     I should also point out that under the assignment method paradigm one<br>&gt;     would probably need to re-evalutate rules for naming. Under the current<br>&gt;     API guidelines&#39; approach, we&#39;d write:<br>&gt;<br>&gt;     x.=sorted() // sort x in-place<br>&gt;<br>&gt;     and I am not sure how easy that would be for people to swallow<br>&gt;     considering how much more straightforward<br>&gt;<br>&gt;     x.sort() // current way to sort x in-place<br>&gt;<br>&gt;     is, and because the language now contains explicit notation for<br>&gt;     mutation, it becomes harder to argue against theis pair:<br>&gt;<br>&gt;     y = x.sort()<br>&gt;     x.=sort() // sort x in place<br>&gt;<br>&gt; I agree that the current API guidelines wouldn&#39;t work for value types anymore.<br>&gt; Both `sort` and `sorted` would be called `sort`.<br>&gt;<br>&gt;     Lastly, I should point out that the proposal does nothing to solve the<br>&gt;     problem of `c.formSuccessor(&amp;i)`, since that doesn&#39;t mutate the<br>&gt;     receiver.<br>&gt;<br>&gt; This proposal does address the problem of `c.formSuccessor(&amp;i)`. Given that it&#39;s<br>&gt; value types at play here, what mutates in the following is unambiguous even to<br>&gt; non-native English speakers:<br>&gt;<br>&gt; c.frobnicate(&amp;i) // cannot possibly mutate c but mutates i<br>&gt; let j = c.frobnicate(i) // cannot possibly mutate either<br>&gt; mutate c.frobnicate(i) // mutates c<br>&gt; let k = mutate c.frobnicate(&amp;i) // mutates both<br></p><p>That&#39;s one possible answer.  <br></p><p>&gt;     I still like the proposal&#39;s basic approach and would love to see it used<br>&gt;     to address these naming problems, but I want to be clear that it&#39;s by no<br>&gt;     means a panacea and there are real obstacles between here and actually<br>&gt;     being able to apply it. If you want to move forward with something like<br>&gt;     this, you need to solve the problems described above.<br>&gt;<br>&gt; I think this proposal would simplify all code handling value types. Yes, it adds<br>&gt; one keyword of boilerplate but wins clarity in return. I think reference types<br>&gt; should stay separate from this discussion, as their mutation has always been<br>&gt; implicit anyway. The API guidelines set a good convention for them.<br></p><p>Interesting.  When you say it, it all sounds so reasonable… yet, I was<br>making the same arguments when the feature was pulled out of Swift.<br>Maybe someone other than me needs to lay out the issues more clearly.<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>mutating/non-mutating suggestion from a Rubyist</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>April 25, 2016 at 08:00:00pm</p></header><div class="content"><p>Hello Dave,<br></p><p>&gt; That makes these people suspicious of language features that could<br>&gt; threaten to make classes “second-class citizens.”<br></p><p><br>...and that is unfortunate when emotions and resistance to positive change worsen the discussion, but if you take a look at discussion related to abstract classes and methods, there is not a lack of &quot;POP is the new way, why dedicate time on this at all, let&#39;s invest in protocols alone...&quot; kind of comments fearing that protocols did not receive deserved preferential treatment.<br></p><p>[[iOS messageWithData:ideas] broadcast]<br></p><p>&gt; On 25 Apr 2016, at 19:48, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; That makes these people suspicious of language features that could<br>&gt; threaten to make classes “second-class citizens.”<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>mutating/non-mutating suggestion from a Rubyist</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>April 26, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; Am 23.04.2016 um 10:27 schrieb Pyry Jahkola via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; I&#39;d like to second James Campbell&#39;s suggestion of a `mutate` keyword. Clarifying comments inline below:<br>&gt; <br>&gt;&gt; On 23 Apr 2016, at 00:24, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This is not a new idea.  Something almost identical to this has been<br>&gt;&gt; explored and discussed quite thoroughly already:<br>&gt;&gt; &lt;https://github.com/apple/swift/blob/master/docs/proposals/Inplace.rst&gt;.<br>&gt;&gt; In fact, it was implmented and later reverted because it raised<br>&gt;&gt; language-design questions for which we had no good answers.<br>&gt; <br>&gt; I don&#39;t know if the following are particularly good answers, but I&#39;ll try anyway:<br>&gt; <br>&gt;&gt; I don&#39;t believe the choice of glyph (&amp; vs =) affects any of the<br>&gt;&gt; fundamental issues:<br>&gt;&gt; <br>&gt;&gt; * Should the x.=f() syntax be required for *every* mutating method<br>&gt;&gt;  invocation?<br>&gt; <br>&gt; Allow me to ask it differently: Should some specific syntax be required for every mutating method? — Yes.<br></p><p>I think I like that idea.<br></p><p><br>&gt; Should the syntax be `x.=f()`? — Not necessarily. I kinda like James Campbell&#39;s idea of a `mutate` keyword. Consider the following:<br>&gt; <br>&gt;     var numbers = [5, 12, 6, 2]<br>&gt;     mutate numbers.append(10)<br>&gt;     mutate numbers.sort()<br>&gt;     if let biggest = mutate numbers.popLast() {<br>&gt;         print(&quot;The biggest number was:&quot;, biggest)<br>&gt;     }<br>&gt; <br>&gt; So `mutate` would work much like `try` but—unlike `try` which can move further to the left—`mutate` would have to always prefix the mutating receiver.<br></p><p>That doesn&#39;t look so bad (we might shorten &#39;mutate&#39; to &#39;mut&#39;, though I don&#39;t think that would be really necessary).<br>I&#39;m wondering how to deal with fluent interfaces which do mutate the receiver and return &#39;self&#39;, i.e. the builder pattern. I think we can simply require that such a chained expression is required to consist of only mutating calls (or only non-mutating calls), so that one &#39;mutate&#39; for the whole expression would be sufficient.<br>Expressions combining mutating calls to different receivers which have return values would simply be prohibited. This would probably be bad style anyway (contrary to the fluent example), or does anyone have a good counter example?<br></p><p><br>&gt; Here&#39;s a contrived example of a corner case:<br>&gt; <br>&gt;     enum Error : ErrorType { case BadNumber }<br>&gt; <br>&gt;     func demo() throws -&gt; Int {<br>&gt;         <br>&gt;     }<br>&gt; <br>&gt;&gt; * Are assignment methods a redundant way to spell mutating methods?<br>&gt;&gt;  Should we really have both mechanisms?<br>&gt; <br>&gt; (I had to look up the definition of an assignment method. For the uninitiated, Dave is talking about what&#39;s written here: https://github.com/apple/swift/blob/master/docs/proposals/Inplace.rst#use-one-simple-name.)<br>&gt; <br>&gt; — Yes they are redundant, and no, we should not have both.<br>&gt; <br>&gt; With `mutate` required at the call site, we could simply allow both overloads `func sort()` and `mutating func sort()` to coexist, because the call sites become unambiguous:<br>&gt; <br>&gt;     let originals = [2, 1, 3, 0, 4, 2]<br>&gt;     var copies = originals<br>&gt; <br>&gt;     originals.sort()           // warning: result of call to &#39;sort()&#39; is unused<br>&gt;     mutate originals.sort()    // compiler error<br>&gt;     let xs = originals.sort()  // ok<br>&gt; <br>&gt;     copies.sort()                 // warning: result of call to &#39;sort()&#39; is unused<br>&gt;     mutate copies.sort()          // ok<br>&gt;     let ys = copies.sort()        // ok<br>&gt;     let zs = mutate copies.sort() // warning: constant &#39;x&#39; inferred to have type &#39;()&#39;, which may be unexpected<br>&gt; <br>&gt; The language could also allow the use of<br>&gt; <br>&gt;     mutate x.next()<br>&gt; <br>&gt; as shorthand for<br>&gt; <br>&gt;     x = x.next()<br>&gt; <br>&gt; when only the non-mutating variant `func next() -&gt; Self` exists with compatible return type.<br>&gt; <br>&gt;&gt; * Can we really introduce this feature without having a way to apply it<br>&gt;&gt;  to class types?<br>&gt; <br>&gt; Yes we can. Why complicate the naming of value type members with the complexities of reference semantics? The current API naming conventions are good for reference types which sometimes come with unobvious to obscure behaviour (i.e. anything from bumping an internal counter to firing missiles and wiping hard drives).<br>&gt; <br>&gt; But value types ought to have no side effects (besides memory allocation and logging maybe), and so we don&#39;t necessarily need that strong a naming convention to limit their collateral damage.<br>&gt; <br>&gt; If the `mutate` keyword became required for calling `mutating` methods, then operators would remain the only place where naming convention were needed to distinguish mutation:<br>&gt; <br>&gt; Mutating assignment is explicit: `xs = [1, 2] + xs + [2, 1]` (i.e. `=` without `let` or `var` means mutation)<br>&gt; Mutating method call becomes explicit: `mutate xs.sort()` and `let x = mutate xs.removeAtIndex(2)`<br>&gt; Mutating function arguments are explicit with the `&amp;` prefix: `swap(&amp;xs, &amp;ys)`<br>&gt; Mutating operators are implicit and by convention, should end with the `=` symbol: `xs += [8, 9]`<br>&gt; Reference types have no notion of `mutating` members (and probably ought to remain that way) so they mutate implicitly.<br>&gt; <br>&gt;&gt; I should also point out that under the assignment method paradigm one<br>&gt;&gt; would probably need to re-evalutate rules for naming.  Under the current<br>&gt;&gt; API guidelines&#39; approach, we&#39;d write:<br>&gt;&gt; <br>&gt;&gt;    x.=sorted()      // sort x in-place<br>&gt;&gt; <br>&gt;&gt; and I am not sure how easy that would be for people to swallow<br>&gt;&gt; considering how much more straightforward<br>&gt;&gt; <br>&gt;&gt;    x.sort()         // current way to sort x in-place<br>&gt;&gt; <br>&gt;&gt; is, and because the language now contains explicit notation for<br>&gt;&gt; mutation, it becomes harder to argue against theis pair:<br>&gt;&gt; <br>&gt;&gt;    y = x.sort()<br>&gt;&gt;    x.=sort()      // sort x in place<br>&gt; <br>&gt; I agree that the current API guidelines wouldn&#39;t work for value types anymore. Both `sort` and `sorted` would be called `sort`.<br>&gt; <br>&gt;&gt; Lastly, I should point out that the proposal does nothing to solve the<br>&gt;&gt; problem of `c.formSuccessor(&amp;i)`, since that doesn&#39;t mutate the<br>&gt;&gt; receiver.<br>&gt; <br>&gt; This proposal does address the problem of `c.formSuccessor(&amp;i)`. Given that it&#39;s value types at play here, what mutates in the following is unambiguous even to non-native English speakers:<br>&gt; <br>&gt;     c.frobnicate(&amp;i)                // cannot possibly mutate c but mutates i<br>&gt;     let j = c.frobnicate(i)         // cannot possibly mutate either<br>&gt;     mutate c.frobnicate(i)          // mutates c<br>&gt;     let k = mutate c.frobnicate(&amp;i) // mutates both<br></p><p>That&#39;s really very straightforward.<br></p><p>As an alternative to the mutate keyword I rather like using &#39;&amp;&#39; because it already means &#39;inout&#39;. Using &#39;&amp;.&#39; as mutating method call would therefore be quite understandable.<br></p><p>c&amp;.frobnicate(i)<br>let k = c&amp;.frobnicate(&amp;i)<br></p><p>Or marking the method like suggested elsewhere:<br></p><p>c.frobnicate&amp;(i)<br>let k = c.frobnicate&amp;(&amp;i)<br></p><p>-Thorsten <br></p><p><br>&gt; <br>&gt;&gt; I still like the proposal&#39;s basic approach and would love to see it used<br>&gt;&gt; to address these naming problems, but I want to be clear that it&#39;s by no<br>&gt;&gt; means a panacea and there are real obstacles between here and actually<br>&gt;&gt; being able to apply it.  If you want to move forward with something like<br>&gt;&gt; this, you need to solve the problems described above.<br>&gt; <br>&gt; I think this proposal would simplify all code handling value types. Yes, it adds one keyword of boilerplate but wins clarity in return. I think reference types should stay separate from this discussion, as their mutation has always been implicit anyway. The API guidelines set a good convention for them.<br>&gt; <br>&gt; — Pyry<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160426/fcc1f397/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>mutating/non-mutating suggestion from a Rubyist</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>April 26, 2016 at 05:00:00pm</p></header><div class="content"><p>I like this idea very much. I believe &#39;&amp;&#39; should belong to instance <br>variable, as it will be mutated, just like for inout parameter, so<br></p><p>c&amp;.frobnicate(i)<br>let k = c&amp;.frobnicate(&amp;i)<br></p><p>very clear and explicit. Don&#39;t like the &#39;mutation&#39; or even &#39;mut&#39; as we&#39;ll <br>have heavy code, as it is a word just like functions/methods/variable names <br>and IMO harder to parse visually. &#39;&amp;&#39; is a &#39;marker&#39;, that clearly parsed.<br></p><p>On 26.04.2016 16:48, Thorsten Seitz via swift-evolution wrote:<br>&gt;<br>&gt; As an alternative to the mutate keyword I rather like using &#39;&amp;&#39; because it<br>&gt; already means &#39;inout&#39;. Using &#39;&amp;.&#39; as mutating method call would therefore<br>&gt; be quite understandable.<br>&gt;<br>&gt; c&amp;.frobnicate(i)<br>&gt; let k = c&amp;.frobnicate(&amp;i)<br>&gt;<br>&gt; Or marking the method like suggested elsewhere:<br>&gt;<br>&gt; c.frobnicate&amp;(i)<br>&gt; let k = c.frobnicate&amp;(&amp;i)<br>&gt;<br>&gt; -Thorsten<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>mutating/non-mutating suggestion from a Rubyist</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>April 26, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On 26 Apr 2016, at 14:48, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Should the syntax be `x.=f()`? — Not necessarily. I kinda like James Campbell&#39;s idea of a `mutate` keyword. Consider the following:<br>&gt;&gt; <br>&gt;&gt;     var numbers = [5, 12, 6, 2]<br>&gt;&gt;     mutate numbers.append(10)<br>&gt;&gt;     mutate numbers.sort()<br>&gt;&gt;     if let biggest = mutate numbers.popLast() {<br>&gt;&gt;         print(&quot;The biggest number was:&quot;, biggest)<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; So `mutate` would work much like `try` but—unlike `try` which can move further to the left—`mutate` would have to always prefix the mutating receiver. <br>&gt; <br>&gt; That doesn&#39;t look so bad (we might shorten &#39;mutate&#39; to &#39;mut&#39;, though I don&#39;t think that would be really necessary).<br>&gt; I&#39;m wondering how to deal with fluent interfaces which do mutate the receiver and return &#39;self&#39;, i.e. the builder pattern. I think we can simply require that such a chained expression is required to consist of only mutating calls (or only non-mutating calls), so that one &#39;mutate&#39; for the whole expression would be sufficient.<br>&gt; Expressions combining mutating calls to different receivers which have return values would simply be prohibited. This would probably be bad style anyway (contrary to the fluent example), or does anyone have a good counter example?<br></p><p>If we do go ahead with this then put me in the “mutate” camp, as I’d actually prefer to see &amp; on inout variables be replaced by the inout keyword at the call-site for consistency. That said, the reason I want that is because inout variables are fairly uncommon (though with indexing changes that will change), but it also looks fairly ugly IMO.<br></p><p><br>Still, for the feature itself I’m of two minds; the naming convention was just changed to enable clear distinctions between mutating and non-mutating methods, but if we had this feature that distinction wouldn’t actually be necessary, we can just call all forms of sorting .sort() and the mutate keyword (or lack of) would distinguish which one is meant, and failure to use a return value would pick up on mistakes. I’d hate to go through the whole naming debate again, but at the same time that would be simpler in a way.<br></p><p><br>So I’m a +1 if we can also use it to roll mutating and non-mutating methods under the same name, even though I don’t want to go through the naming transition all over again ;)<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160426/90683a7f/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>mutating/non-mutating suggestion from a Rubyist</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April 26, 2016 at 01:00:00pm</p></header><div class="content"><p>on Tue Apr 26 2016, Thorsten Seitz &lt;tseitz42-AT-icloud.com&gt; wrote:<br></p><p>&gt; Am 23.04.2016 um 10:27 schrieb Pyry Jahkola via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt;:<br>&gt;<br>&gt;     I&#39;d like to second James Campbell&#39;s suggestion of a `mutate` keyword.<br>&gt;     Clarifying comments inline below:<br>&gt;<br>&gt;         On 23 Apr 2016, at 00:24, Dave Abrahams via swift-evolution<br>&gt;         &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;         This is not a new idea. Something almost identical to this has been<br>&gt;         explored and discussed quite thoroughly already:<br>&gt;         &lt;https://github.com/apple/swift/blob/master/docs/proposals/Inplace.rst&gt;.<br>&gt;         In fact, it was implmented and later reverted because it raised<br>&gt;         language-design questions for which we had no good answers.<br>&gt;<br>&gt;     I don&#39;t know if the following are particularly good answers, but I&#39;ll try<br>&gt;     anyway:<br>&gt;<br>&gt;         I don&#39;t believe the choice of glyph (&amp; vs =) affects any of the<br>&gt;<br>&gt;         fundamental issues:<br>&gt;<br>&gt;         * Should the x.=f() syntax be required for *every* mutating method<br>&gt;         invocation?<br>&gt;<br>&gt;     Allow me to ask it differently: Should some specific syntax be required for<br>&gt;     every mutating method? — Yes.<br>&gt;<br>&gt; I think I like that idea.<br>&gt;<br>&gt;     Should the syntax be `x.=f()`? — Not necessarily. I kinda like James<br>&gt;     Campbell&#39;s idea of a `mutate` keyword. Consider the following:<br>&gt;<br>&gt;     var numbers = [5, 12, 6, 2]<br>&gt;     mutate numbers.append(10)<br>&gt;     mutate numbers.sort()<br>&gt;     if let biggest = mutate numbers.popLast() {<br>&gt;     print(&quot;The biggest number was:&quot;, biggest)<br>&gt;     }<br>&gt;<br>&gt;     So `mutate` would work much like `try` but—unlike `try` which can move<br>&gt;     further to the left—`mutate` would have to always prefix the mutating<br>&gt;     receiver. <br>&gt;<br>&gt; That doesn&#39;t look so bad (we might shorten &#39;mutate&#39; to &#39;mut&#39;, though I don&#39;t<br>&gt; think that would be really necessary).<br></p><p>We&#39;ve already discussed this whole question length, specifically<br>considered the direction of an almost-identical language feature, and<br>ended up settling on the “form/ed/ing” naming conventions.  If there is<br>some new information since then, it would be possible to handle<br>something like this via a new evolution proposal.  However, anything<br>like that is way out of scope for Swift 3, and in the absence of new<br>information, it isn’t a productive use of time to rehash it at all.<br></p><p>-- <br>Dave<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/db5e2fe903111a67076e0a6b97e635dd?s=50"></div><header><strong>mutating/non-mutating suggestion from a Rubyist</strong> from <string>Tyler Cloutier</string> &lt;cloutiertyler at aol.com&gt;<p>April 27, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Apr 23, 2016, at 1:27 AM, Pyry Jahkola via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;d like to second James Campbell&#39;s suggestion of a `mutate` keyword. Clarifying comments inline below:<br>&gt; <br>&gt;&gt; On 23 Apr 2016, at 00:24, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This is not a new idea.  Something almost identical to this has been<br>&gt;&gt; explored and discussed quite thoroughly already:<br>&gt;&gt; &lt;https://github.com/apple/swift/blob/master/docs/proposals/Inplace.rst &lt;https://github.com/apple/swift/blob/master/docs/proposals/Inplace.rst&gt;&gt;.<br>&gt;&gt; In fact, it was implmented and later reverted because it raised<br>&gt;&gt; language-design questions for which we had no good answers.<br>&gt; <br>&gt; I don&#39;t know if the following are particularly good answers, but I&#39;ll try anyway:<br>&gt; <br>&gt;&gt; I don&#39;t believe the choice of glyph (&amp; vs =) affects any of the<br>&gt;&gt; fundamental issues:<br>&gt;&gt; <br>&gt;&gt; * Should the x.=f() syntax be required for *every* mutating method<br>&gt;&gt;  invocation?<br>&gt; <br>&gt; Allow me to ask it differently: Should some specific syntax be required for every mutating method? — Yes.<br>&gt; <br>&gt; Should the syntax be `x.=f()`? — Not necessarily. I kinda like James Campbell&#39;s idea of a `mutate` keyword. Consider the following:<br>&gt; <br>&gt;     var numbers = [5, 12, 6, 2]<br>&gt;     mutate numbers.append(10)<br>&gt;     mutate numbers.sort()<br>&gt;     if let biggest = mutate numbers.popLast() {<br>&gt;         print(&quot;The biggest number was:&quot;, biggest)<br>&gt;     }<br>&gt; <br>&gt; So `mutate` would work much like `try` but—unlike `try` which can move further to the left—`mutate` would have to always prefix the mutating receiver. Here&#39;s a contrived example of a corner case:<br>&gt; <br>&gt;     enum Error : ErrorType { case BadNumber }<br>&gt; <br>&gt;     func demo() throws -&gt; Int {<br>&gt;         <br>&gt;     }<br>&gt; <br>&gt;&gt; * Are assignment methods a redundant way to spell mutating methods?<br>&gt;&gt;  Should we really have both mechanisms?<br>&gt; <br>&gt; (I had to look up the definition of an assignment method. For the uninitiated, Dave is talking about what&#39;s written here: https://github.com/apple/swift/blob/master/docs/proposals/Inplace.rst#use-one-simple-name &lt;https://github.com/apple/swift/blob/master/docs/proposals/Inplace.rst#use-one-simple-name&gt;.)<br>&gt; <br>&gt; — Yes they are redundant, and no, we should not have both.<br>&gt; <br>&gt; With `mutate` required at the call site, we could simply allow both overloads `func sort()` and `mutating func sort()` to coexist, because the call sites become unambiguous:<br>&gt; <br>&gt;     let originals = [2, 1, 3, 0, 4, 2]<br>&gt;     var copies = originals<br>&gt; <br>&gt;     originals.sort()           // warning: result of call to &#39;sort()&#39; is unused<br>&gt;     mutate originals.sort()    // compiler error<br>&gt;     let xs = originals.sort()  // ok<br>&gt; <br>&gt;     copies.sort()                 // warning: result of call to &#39;sort()&#39; is unused<br>&gt;     mutate copies.sort()          // ok<br>&gt;     let ys = copies.sort()        // ok<br>&gt;     let zs = mutate copies.sort() // warning: constant &#39;x&#39; inferred to have type &#39;()&#39;, which may be unexpected<br>&gt; <br>&gt; The language could also allow the use of<br>&gt; <br>&gt;     mutate x.next()<br>&gt; <br>&gt; as shorthand for<br>&gt; <br>&gt;     x = x.next()<br>&gt; <br>&gt; when only the non-mutating variant `func next() -&gt; Self` exists with compatible return type.<br>&gt; <br>&gt;&gt; * Can we really introduce this feature without having a way to apply it<br>&gt;&gt;  to class types?<br>&gt; <br>&gt; Yes we can. Why complicate the naming of value type members with the complexities of reference semantics? The current API naming conventions are good for reference types which sometimes come with unobvious to obscure behaviour (i.e. anything from bumping an internal counter to firing missiles and wiping hard drives).<br>&gt; <br>&gt; But value types ought to have no side effects (besides memory allocation and logging maybe), and so we don&#39;t necessarily need that strong a naming convention to limit their collateral damage.<br>&gt; <br>&gt; If the `mutate` keyword became required for calling `mutating` methods, then operators would remain the only place where naming convention were needed to distinguish mutation:<br>&gt; <br>&gt; Mutating assignment is explicit: `xs = [1, 2] + xs + [2, 1]` (i.e. `=` without `let` or `var` means mutation)<br>&gt; Mutating method call becomes explicit: `mutate xs.sort()` and `let x = mutate xs.removeAtIndex(2)`<br>&gt; Mutating function arguments are explicit with the `&amp;` prefix: `swap(&amp;xs, &amp;ys)`<br>&gt; Mutating operators are implicit and by convention, should end with the `=` symbol: `xs += [8, 9]`<br>&gt; Reference types have no notion of `mutating` members (and probably ought to remain that way) so they mutate implicitly.<br>&gt; <br>&gt;&gt; I should also point out that under the assignment method paradigm one<br>&gt;&gt; would probably need to re-evalutate rules for naming.  Under the current<br>&gt;&gt; API guidelines&#39; approach, we&#39;d write:<br>&gt;&gt; <br>&gt;&gt;    x.=sorted()      // sort x in-place<br>&gt;&gt; <br>&gt;&gt; and I am not sure how easy that would be for people to swallow<br>&gt;&gt; considering how much more straightforward<br>&gt;&gt; <br>&gt;&gt;    x.sort()         // current way to sort x in-place<br>&gt;&gt; <br>&gt;&gt; is, and because the language now contains explicit notation for<br>&gt;&gt; mutation, it becomes harder to argue against theis pair:<br>&gt;&gt; <br>&gt;&gt;    y = x.sort()<br>&gt;&gt;    x.=sort()      // sort x in place<br>&gt; <br>&gt; I agree that the current API guidelines wouldn&#39;t work for value types anymore. Both `sort` and `sorted` would be called `sort`.<br>&gt; <br>&gt;&gt; Lastly, I should point out that the proposal does nothing to solve the<br>&gt;&gt; problem of `c.formSuccessor(&amp;i)`, since that doesn&#39;t mutate the<br>&gt;&gt; receiver.<br>&gt; <br>&gt; This proposal does address the problem of `c.formSuccessor(&amp;i)`. Given that it&#39;s value types at play here, what mutates in the following is unambiguous even to non-native English speakers:<br>&gt; <br>&gt;     c.frobnicate(&amp;i)                // cannot possibly mutate c but mutates i<br>&gt;     let j = c.frobnicate(i)         // cannot possibly mutate either<br>&gt;     mutate c.frobnicate(i)          // mutates c<br>&gt;     let k = mutate c.frobnicate(&amp;i) // mutates both<br></p><p>How would this chain if I wanted to do something like:<br></p><p>let median = foo.calculateBigHugeArray().sort().medianValue()<br></p><p>and I want the sort to be done in place. Or will this type of thing just be disallowed in favor of.<br></p><p>let array = foo.calculateBigHugeArray()<br>mutate array.sort()<br>let median = array.medianValue() <br></p><p><br>Alternately you could replace the method invocation operator with &amp;<br></p><p>let median = foo.calculateBigHugeArray()&amp;sort().medianValue()<br></p><p><br>Or depending how sacrilegious you’re feeling you could use the only character on the keyboard that isn’t currently used and doesn’t require the shift key and is easily distinguished from a ‘.’<br></p><p>let median = foo.calculateBigHugeArray()&#39;sort().medianValue()<br></p><p>This is definitely more confusing than the &amp; and mutate, since &amp; is used to indicate mutation elsewhere.<br></p><p><br></p><p>Also, if you wanted to stick with consistent &amp; syntax, you could do:<br></p><p>&amp;c.frobnicate(i)<br>and <br>let k = &amp;c.frobnicate(&amp;i)<br></p><p><br>Dave, to your point about classes, there is currently already special syntax for value types with the &amp; as parameters. Reference semantics is the wild west there anyway.<br></p><p><br>&gt; <br>&gt;&gt; I still like the proposal&#39;s basic approach and would love to see it used<br>&gt;&gt; to address these naming problems, but I want to be clear that it&#39;s by no<br>&gt;&gt; means a panacea and there are real obstacles between here and actually<br>&gt;&gt; being able to apply it.  If you want to move forward with something like<br>&gt;&gt; this, you need to solve the problems described above.<br>&gt; <br>&gt; I think this proposal would simplify all code handling value types. Yes, it adds one keyword of boilerplate but wins clarity in return. I think reference types should stay separate from this discussion, as their mutation has always been implicit anyway. The API guidelines set a good convention for them.<br>&gt; <br>&gt; — Pyry<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160427/413da0d7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>mutating/non-mutating suggestion from a Rubyist</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>April 28, 2016 at 11:00:00am</p></header><div class="content"><p>@Tyler,<br></p><p>Excellent summary of concerns which has made me revise my preferences!<br></p><p>I would suggest a few differences from your suggestions (primarily based on<br>the interpretation of `mutating &lt;name&gt;` as the name of the method, i.e. the<br>method name includes `mutating`). The couple of areas I suggest are:<br></p><p>    1. Use `mutating` after `func` in declarations: `func mutating<br>sort(...)`.<br>    2. Use mutating after `.` in calls: `array.mutating sort(&lt;)`<br>    3. Allow mutating for classes:<br></p><p>        protocol P { func mutating p() }<br>        class AP: P { func mutating p() { ... }<br>        let aP = AP()<br>        aP.mutating p() // Mutates what `aP` points to<br></p><p>    2. Treat mutating as part of name when chaining:<br></p><p>        let median = foo.calculateBigHugeArray().mutating<br>sort().medianValue()<br></p><p><br>  -- Howard.<br></p><p>On 28 April 2016 at 10:44, Tyler Cloutier via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Apr 23, 2016, at 1:27 AM, Pyry Jahkola via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I&#39;d like to second James Campbell&#39;s suggestion of a `mutate` keyword.<br>&gt; Clarifying comments inline below:<br>&gt;<br>&gt; On 23 Apr 2016, at 00:24, Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; This is not a new idea.  Something almost identical to this has been<br>&gt; explored and discussed quite thoroughly already:<br>&gt; &lt;https://github.com/apple/swift/blob/master/docs/proposals/Inplace.rst&gt;.<br>&gt; In fact, it was implmented and later reverted because it raised<br>&gt; language-design questions for which we had no good answers.<br>&gt;<br>&gt;<br>&gt; I don&#39;t know if the following are particularly good answers, but I&#39;ll try<br>&gt; anyway:<br>&gt;<br>&gt; I don&#39;t believe the choice of glyph (&amp; vs =) affects any of the<br>&gt;<br>&gt; fundamental issues:<br>&gt;<br>&gt; * Should the x.=f() syntax be required for *every* mutating method<br>&gt;  invocation?<br>&gt;<br>&gt;<br>&gt; Allow me to ask it differently: Should *some* specific syntax be required<br>&gt; for every mutating method? — Yes.<br>&gt;<br>&gt; Should the syntax be `x.=f()`? — Not necessarily. I kinda like James<br>&gt; Campbell&#39;s idea of a `mutate` keyword. Consider the following:<br>&gt;<br>&gt;     *var* numbers = [5, 12, 6, 2]<br>&gt;     *mutate* numbers.append(10)<br>&gt;     *mutate* numbers.sort()<br>&gt;     *if let* biggest = *mutate* numbers.popLast() {<br>&gt;         print(&quot;The biggest number was:&quot;, biggest)<br>&gt;     }<br>&gt;<br>&gt; So `mutate` would work much like `try` but—unlike `try` which can move<br>&gt; further to the left—`mutate` would have to always prefix the mutating<br>&gt; receiver. Here&#39;s a contrived example of a corner case:<br>&gt;<br>&gt;     *enum* Error : ErrorType { *case* BadNumber }<br>&gt;<br>&gt;     *func* demo() *throws* -&gt; Int {<br>&gt;<br>&gt;     }<br>&gt;<br>&gt; * Are assignment methods a redundant way to spell mutating methods?<br>&gt;  Should we really have both mechanisms?<br>&gt;<br>&gt;<br>&gt; (I had to look up the definition of an *assignment method*. For the<br>&gt; uninitiated, Dave is talking about what&#39;s written here:<br>&gt; https://github.com/apple/swift/blob/master/docs/proposals/Inplace.rst#use-one-simple-name<br>&gt; .)<br>&gt;<br>&gt; — Yes they are redundant, and no, we should not have both.<br>&gt;<br>&gt; With `mutate` required at the call site, we could simply allow both<br>&gt; overloads `*func* sort()` and `*mutating func* sort()` to coexist,<br>&gt; because the call sites become unambiguous:<br>&gt;<br>&gt;     *let* originals = [2, 1, 3, 0, 4, 2]<br>&gt;     *var* copies = originals<br>&gt;<br>&gt;     originals.sort()           // *warning:* result of call to &#39;sort()&#39;<br>&gt; is unused<br>&gt;     *mutate* originals.sort()    // *compiler error*<br>&gt;     *let* xs = originals.sort()  // ok<br>&gt;<br>&gt;     copies.sort()                 // *warning:* result of call to<br>&gt; &#39;sort()&#39; is unused<br>&gt;     *mutate* copies.sort()          // ok<br>&gt;     *let* ys = copies.sort()        // ok<br>&gt;     *let* zs = mutate copies.sort() // *warning:* constant &#39;x&#39; inferred<br>&gt; to have type &#39;()&#39;, which may be unexpected<br>&gt;<br>&gt; The language could also allow the use of<br>&gt;<br>&gt; *    mutate* x.next()<br>&gt;<br>&gt; as shorthand for<br>&gt;<br>&gt;     x = x.next()<br>&gt;<br>&gt; when only the non-mutating variant `*func* next() -&gt; *Self*` exists with<br>&gt; compatible return type.<br>&gt;<br>&gt; * Can we really introduce this feature without having a way to apply it<br>&gt;  to class types?<br>&gt;<br>&gt;<br>&gt; Yes we can. Why complicate the naming of value type members with the<br>&gt; complexities of reference semantics? The current API naming conventions are<br>&gt; *good* for reference types which sometimes come with unobvious to obscure<br>&gt; behaviour (i.e. anything from bumping an internal counter to firing<br>&gt; missiles and wiping hard drives).<br>&gt;<br>&gt; But value types ought to have no side effects (besides memory allocation<br>&gt; and logging maybe), and so we don&#39;t necessarily need that strong a naming<br>&gt; convention to limit their collateral damage.<br>&gt;<br>&gt; If the `mutate` keyword became required for calling `mutating` methods,<br>&gt; then operators would remain the only place where naming convention were<br>&gt; needed to distinguish mutation:<br>&gt;<br>&gt;<br>&gt;    - Mutating assignment is *explicit*: `xs = [1, 2] + xs + [2, 1]` (i.e.<br>&gt;    `=` without `let` or `var` means mutation)<br>&gt;    - Mutating method call becomes *explicit*: `*mutate* xs.sort()` and `<br>&gt;    *let* x = *mutate* xs.removeAtIndex(2)`<br>&gt;    - Mutating function arguments are *explicit* with the `&amp;` prefix: `swap(&amp;xs,<br>&gt;    &amp;ys)`<br>&gt;    - Mutating operators are *implicit* and *by convention,* should end<br>&gt;    with the `=` symbol: `xs += [8, 9]`<br>&gt;    - Reference types have no notion of `mutating` members (and probably<br>&gt;    ought to remain that way) so they mutate *implicitly*.<br>&gt;<br>&gt;<br>&gt; I should also point out that under the assignment method paradigm one<br>&gt; would probably need to re-evalutate rules for naming.  Under the current<br>&gt; API guidelines&#39; approach, we&#39;d write:<br>&gt;<br>&gt;    x.=sorted()      // sort x in-place<br>&gt;<br>&gt; and I am not sure how easy that would be for people to swallow<br>&gt; considering how much more straightforward<br>&gt;<br>&gt;    x.sort()         // current way to sort x in-place<br>&gt;<br>&gt; is, and because the language now contains explicit notation for<br>&gt; mutation, it becomes harder to argue against theis pair:<br>&gt;<br>&gt;    y = x.sort()<br>&gt;    x.=sort()      // sort x in place<br>&gt;<br>&gt;<br>&gt; I agree that the current API guidelines wouldn&#39;t work for value types<br>&gt; anymore. Both `sort` and `sorted` would be called `sort`.<br>&gt;<br>&gt; Lastly, I should point out that the proposal does nothing to solve the<br>&gt; problem of `c.formSuccessor(&amp;i)`, since that doesn&#39;t mutate the<br>&gt; receiver.<br>&gt;<br>&gt;<br>&gt; This proposal does address the problem of `c.formSuccessor(&amp;i)`. Given<br>&gt; that it&#39;s value types at play here, what mutates in the following is<br>&gt; unambiguous even to non-native English speakers:<br>&gt;<br>&gt;     c.frobnicate(&amp;i)                // cannot possibly mutate c but<br>&gt; mutates i<br>&gt;     *let* j = c.frobnicate(i)         // cannot possibly mutate either<br>&gt;     *mutate* c.frobnicate(i)          // mutates c<br>&gt;     *let* k = *mutate* c.frobnicate(&amp;i) // mutates both<br>&gt;<br>&gt;<br>&gt; How would this chain if I wanted to do something like:<br>&gt;<br>&gt; let median = foo.calculateBigHugeArray().sort().medianValue()<br>&gt;<br>&gt; and I want the sort to be done in place. Or will this type of thing just<br>&gt; be disallowed in favor of.<br>&gt;<br>&gt; let array = foo.calculateBigHugeArray()<br>&gt; mutate array.sort()<br>&gt; let median = array.medianValue()<br>&gt;<br>&gt;<br>&gt; Alternately you could replace the method invocation operator with &amp;<br>&gt;<br>&gt; let median = foo.calculateBigHugeArray()&amp;sort().medianValue()<br>&gt;<br>&gt;<br>&gt; Or depending how sacrilegious you’re feeling you could use the only<br>&gt; character on the keyboard that isn’t currently used and doesn’t require the<br>&gt; shift key and is easily distinguished from a ‘.’<br>&gt;<br>&gt; let median = foo.calculateBigHugeArray()&#39;sort().medianValue()<br>&gt;<br>&gt; This is definitely more confusing than the &amp; and mutate, since &amp; is used<br>&gt; to indicate mutation elsewhere.<br>&gt;<br>&gt;<br>&gt;<br>&gt; Also, if you wanted to stick with consistent &amp; syntax, you could do:<br>&gt;<br>&gt; &amp;c.frobnicate(i)<br>&gt; and<br>&gt; let k = &amp;c.frobnicate(&amp;i)<br>&gt;<br>&gt;<br>&gt; Dave, to your point about classes, there is currently already special<br>&gt; syntax for value types with the &amp; as parameters. Reference semantics is the<br>&gt; wild west there anyway.<br>&gt;<br>&gt;<br>&gt;<br>&gt; I still like the proposal&#39;s basic approach and would love to see it used<br>&gt; to address these naming problems, but I want to be clear that it&#39;s by no<br>&gt; means a panacea and there are real obstacles between here and actually<br>&gt; being able to apply it.  If you want to move forward with something like<br>&gt; this, you need to solve the problems described above.<br>&gt;<br>&gt;<br>&gt; I think this proposal would simplify all code handling value types. Yes,<br>&gt; it adds one keyword of boilerplate but wins clarity in return. I think<br>&gt; reference types should stay separate from this discussion, as their<br>&gt; mutation has always been implicit anyway. The API guidelines set a good<br>&gt; convention for them.<br>&gt;<br>&gt; — Pyry<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160428/de82e14b/attachment-0001.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>mutating/non-mutating suggestion from a Rubyist</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>April 28, 2016 at 10:00:00am</p></header><div class="content"><p>Good that you brought the topic of &quot;fluent&quot; interfaces up. I don&#39;t see any problem with explicit value type mutation and method chaining because fluent interfaces are constrained to reference types by the language. Details below:<br></p><p>&gt; On 28 Apr 2016, at 03:44, Tyler Cloutier &lt;cloutiertyler at aol.com&gt; wrote:<br>&gt; <br>&gt; How would this chain if I wanted to do something like:<br>&gt; <br>&gt; let median = foo.calculateBigHugeArray().sort().medianValue()<br>&gt; <br>&gt; and I want the sort to be done in place.<br></p><p>I think I can guess what you wanted the above to mean but, mind you, the in-place sort returns `()` so you wouldn&#39;t chain its result like that. On the other hand, the above code already works using the non-mutating `.sort()` (to be known as `.sorted()` in Swift 3), and—correct me if I&#39;m wrong—the compiler probably optimises the copy away using copy-on-write anyway.<br></p><p>&gt; Or will this type of thing just be disallowed in favor of.<br>&gt; <br>&gt; let array = foo.calculateBigHugeArray()<br>&gt; mutate array.sort()<br>&gt; let median = array.medianValue() <br></p><p>Yes, I think mutating code should be written in many statements rather than squeezing everything into one long expression.<br></p><p>Indeed, no currently working method chaining would be disallowed in my proposal. Let&#39;s consider the example of &quot;fluent API&quot; for value types, i.e. one where you&#39;d extensively `return self` in `mutating` methods. Firstly, the stdlib doesn&#39;t practice that at all. And I failed to find any popular Swift libraries that would do so on Github either. The reason is simple: fluent mutating APIs on value types don&#39;t work.<br></p><p>Consider the following silly example that shortens an array in half (but demonstrates the use of `return self` in a `mutating` method):<br></p><p>    extension Array {<br>        mutating func halve() -&gt; Array {<br>            self = self[0 ..&lt; count / 2]<br>            return self<br>        }<br>    }<br></p><p>Suppose I want to get the result of halving an array twice. What happens?<br></p><p>    var xs = [1,2,3,4,5,6,7,8]<br>    xs.halve().halve()<br>    // error: cannot use mutating member on immutable value: function call returns immutable value<br></p><p>So no, fluent APIs on value types are not a thing in Swift. Not now at least. Making mutation explicit along this proposal has nothing to do with fluent APIs.<br></p><p>&gt; Alternately you could replace the method invocation operator with &amp;<br>&gt; <br>&gt; let median = foo.calculateBigHugeArray()&amp;sort().medianValue()<br></p><p>Don&#39;t you think that&#39;s too prone to getting mixed up with the binary `&amp;` operator?<br></p><p>&gt; Also, if you wanted to stick with consistent &amp; syntax, you could do:<br>&gt; <br>&gt; &amp;c.frobnicate(i)<br>&gt; and <br>&gt; let k = &amp;c.frobnicate(&amp;i)<br></p><p><br>Yeah, probably. However, one place where that notation falls short compared to a prefixing keyword like `mutate` is when mutating `self`:<br></p><p>    extension Array {<br>        // Apologies for not having the time to think of a less contrived example than this!<br>        mutating func quarter() {<br>            mutate self.halve() // Ever since SE-0009 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0009-require-self-for-accessing-instance-members.md&gt;, it&#39;s unusual to use `self` here.<br>            mutate halve()      // Where would you put the `&amp;` prefix in this?<br>        }<br>    }<br></p><p>— Pyry<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160428/28983255/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/db5e2fe903111a67076e0a6b97e635dd?s=50"></div><header><strong>mutating/non-mutating suggestion from a Rubyist</strong> from <string>Tyler Cloutier</string> &lt;cloutiertyler at aol.com&gt;<p>April 28, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On Apr 28, 2016, at 12:34 AM, Pyry Jahkola &lt;pyry.jahkola at iki.fi&gt; wrote:<br>&gt; <br>&gt; Good that you brought the topic of &quot;fluent&quot; interfaces up. I don&#39;t see any problem with explicit value type mutation and method chaining because fluent interfaces are constrained to reference types by the language. Details below:<br>&gt; <br>&gt;&gt; On 28 Apr 2016, at 03:44, Tyler Cloutier &lt;cloutiertyler at aol.com &lt;mailto:cloutiertyler at aol.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; How would this chain if I wanted to do something like:<br>&gt;&gt; <br>&gt;&gt; let median = foo.calculateBigHugeArray().sort().medianValue()<br>&gt;&gt; <br>&gt;&gt; and I want the sort to be done in place.<br>&gt; <br>&gt; I think I can guess what you wanted the above to mean but, mind you, the in-place sort returns `()` so you wouldn&#39;t chain its result like that. On the other hand, the above code already works using the non-mutating `.sort()` (to be known as `.sorted()` in Swift 3), and—correct me if I&#39;m wrong—the compiler probably optimises the copy away using copy-on-write anyway.<br>&gt; <br>&gt;&gt; Or will this type of thing just be disallowed in favor of.<br>&gt;&gt; <br>&gt;&gt; let array = foo.calculateBigHugeArray()<br>&gt;&gt; mutate array.sort()<br>&gt;&gt; let median = array.medianValue() <br>&gt; <br>&gt; Yes, I think mutating code should be written in many statements rather than squeezing everything into one long expression.<br>&gt; <br>&gt; Indeed, no currently working method chaining would be disallowed in my proposal. Let&#39;s consider the example of &quot;fluent API&quot; for value types, i.e. one where you&#39;d extensively `return self` in `mutating` methods. Firstly, the stdlib doesn&#39;t practice that at all. And I failed to find any popular Swift libraries that would do so on Github either. The reason is simple: fluent mutating APIs on value types don&#39;t work.<br>&gt; <br>&gt; Consider the following silly example that shortens an array in half (but demonstrates the use of `return self` in a `mutating` method):<br>&gt; <br>&gt;     extension Array {<br>&gt;         mutating func halve() -&gt; Array {<br>&gt;             self = self[0 ..&lt; count / 2]<br>&gt;             return self<br>&gt;         }<br>&gt;     }<br>&gt; <br>&gt; Suppose I want to get the result of halving an array twice. What happens?<br>&gt; <br>&gt;     var xs = [1,2,3,4,5,6,7,8]<br>&gt;     xs.halve().halve()<br>&gt;     // error: cannot use mutating member on immutable value: function call returns immutable value<br>&gt; <br>&gt; So no, fluent APIs on value types are not a thing in Swift. Not now at least. Making mutation explicit along this proposal has nothing to do with fluent APIs.<br>&gt; <br>&gt;&gt; Alternately you could replace the method invocation operator with &amp;<br>&gt;&gt; <br>&gt;&gt; let median = foo.calculateBigHugeArray()&amp;sort().medianValue()<br>&gt; <br>&gt; Don&#39;t you think that&#39;s too prone to getting mixed up with the binary `&amp;` operator?<br>&gt; <br>&gt;&gt; Also, if you wanted to stick with consistent &amp; syntax, you could do:<br>&gt;&gt; <br>&gt;&gt; &amp;c.frobnicate(i)<br>&gt;&gt; and <br>&gt;&gt; let k = &amp;c.frobnicate(&amp;i)<br>&gt; <br>&gt; <br>&gt; Yeah, probably. However, one place where that notation falls short compared to a prefixing keyword like `mutate` is when mutating `self`:<br>&gt; <br>&gt;     extension Array {<br>&gt;         // Apologies for not having the time to think of a less contrived example than this!<br>&gt;         mutating func quarter() {<br>&gt;             mutate self.halve() // Ever since SE-0009 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0009-require-self-for-accessing-instance-members.md&gt;, it&#39;s unusual to use `self` here.<br>&gt;             mutate halve()      // Where would you put the `&amp;` prefix in this?<br>&gt;         }<br>&gt;     }<br>&gt; <br>&gt; — Pyry<br>&gt; <br></p><p>You are very correct. Yup, that pretty much addresses all of my concerns. So count me amongst the fans. <br></p><p>I had something like popLast in mind, but as you point out, return values are immutable in Swift.<br></p><p>struct Foo {<br>    var y = [5, 6]<br>    func foo() -&gt; [Int] {<br>        return y<br>    }<br>}<br>var x = Foo()<br>x.foo().popLast()?.advanced(by: 1) // error: Cannot use mutating member on immutable value: function call returns immutable value<br></p><p><br>Thanks! <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160428/dd288a77/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>mutating/non-mutating suggestion from a Rubyist</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>April 28, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On 28 Apr 2016, at 10:59, Tyler Fleming Cloutier &lt;cloutiertyler at aol.com&gt; wrote:<br>&gt; <br>&gt; Yup, that pretty much addresses all of my concerns. So count me amongst the fans. <br></p><p>By the way,<br></p><p>I can be counted as +1 on reusing the keyword `mutating` here.<br></p><p>However, for the reasons stated in my previous email, I maintain that the keyword should go before the value being mutated rather than next to the function&#39;s name.<br></p><p>— Pyry<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160428/ea65ccdb/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>mutating/non-mutating suggestion from a Rubyist</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>April 28, 2016 at 11:00:00am</p></header><div class="content"><p>On 28.04.2016 10:34, Pyry Jahkola via swift-evolution wrote:<br>&gt;<br>&gt; *    extension* Array {<br>&gt;         // Apologies for not having the time to think of a less contrived<br>&gt; example than this!<br>&gt;         *mutating* *func* quarter() {<br>&gt;             *mutate* *self*.halve() // Ever since SE-0009<br>&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0009-require-self-for-accessing-instance-members.md&gt;,<br>&gt; it&#39;s unusual to use `self` here.<br>&gt;             *mutate*halve()      // Where would you put the `&amp;` prefix in this?<br>&gt;         }<br>&gt;     }<br></p><p>How about &#39;&amp;&#39; as allowed prefix/suffix for method name as a marker of <br>mutating method? I.e.<br></p><p>self.&amp;halve()<br>&amp;halve()<br></p><p>or<br></p><p>self.halve&amp;()<br>halve&amp;()<br></p><p><br>Actually, IMO &amp;halve() is not a variant as it probably could be used in <br>function like<br></p><p>something( &amp;halve )  - confused<br></p><p>so, the suggestion is to have &#39;&amp;&#39; suffix as marker of mutating methid:<br></p><p>self.halve&amp;()<br>halve&amp;()<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ab486d7597af4cfe0be33a762150848?s=50"></div><header><strong>mutating/non-mutating suggestion from a Rubyist</strong> from <string>Dany St-Amant</string> &lt;dsa.mls at icloud.com&gt;<p>April 28, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; Le 28 avr. 2016 à 03:34, Pyry Jahkola via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Good that you brought the topic of &quot;fluent&quot; interfaces up. I don&#39;t see any problem with explicit value type mutation and method chaining because fluent interfaces are constrained to reference types by the language. Details below:<br>&gt; <br>&gt;&gt; On 28 Apr 2016, at 03:44, Tyler Cloutier &lt;cloutiertyler at aol.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; How would this chain if I wanted to do something like:<br>&gt;&gt; <br>&gt;&gt; let median = foo.calculateBigHugeArray().sort().medianValue()<br>&gt;&gt; <br>&gt;&gt; and I want the sort to be done in place.<br>&gt; <br>&gt; I think I can guess what you wanted the above to mean but, mind you, the in-place sort returns `()` so you wouldn&#39;t chain its result like that. On the other hand, the above code already works using the non-mutating `.sort()` (to be known as `.sorted()` in Swift 3), and—correct me if I&#39;m wrong—the compiler probably optimises the copy away using copy-on-write anyway.<br>&gt; <br>&gt;&gt; Or will this type of thing just be disallowed in favor of.<br>&gt;&gt; <br>&gt;&gt; let array = foo.calculateBigHugeArray()<br>&gt;&gt; mutate array.sort()<br>&gt;&gt; let median = array.medianValue() <br>&gt; <br>&gt; Yes, I think mutating code should be written in many statements rather than squeezing everything into one long expression.<br>&gt; <br>&gt; Indeed, no currently working method chaining would be disallowed in my proposal. Let&#39;s consider the example of &quot;fluent API&quot; for value types, i.e. one where you&#39;d extensively `return self` in `mutating` methods. Firstly, the stdlib doesn&#39;t practice that at all. And I failed to find any popular Swift libraries that would do so on Github either. The reason is simple: fluent mutating APIs on value types don&#39;t work.<br>&gt; <br>&gt; Consider the following silly example that shortens an array in half (but demonstrates the use of `return self` in a `mutating` method):<br>&gt; <br>&gt;     extension Array {<br>&gt;         mutating func halve() -&gt; Array {<br>&gt;             self = self[0 ..&lt; count / 2]<br>&gt;             return self<br>&gt;         }<br>&gt;     }<br>&gt; <br>&gt; Suppose I want to get the result of halving an array twice. What happens?<br>&gt; <br>&gt;     var xs = [1,2,3,4,5,6,7,8]<br>&gt;     xs.halve().halve()<br>&gt;     // error: cannot use mutating member on immutable value: function call returns immutable value<br>&gt; <br>&gt; So no, fluent APIs on value types are not a thing in Swift. Not now at least. Making mutation explicit along this proposal has nothing to do with fluent APIs.<br></p><p>But is this limitation as per design, or just something that no one reported as a bug yet? When acting on large piece of data and simple operations one might want to chain mutable version (to avoid large allocation) of the operations as a single stream (à la functional programming)  instead of having to use multiple line of:<br>  mutate largeData.operation()<br></p><p>On a side note, this &quot;long&quot; explicit &#39;mutate&#39; keyword could be seen by some as a way to impose the use immutability by making it harder (more to type) to use mutability.<br></p><p>Also, this &#39;mutate&#39; could maybe help to differentiate between sort() 2.2-style and sort() 3.0-style, and avoid endless discussion on InPlace/form/ed/ing. But for language uniformity, would this new &#39;mutate&#39; keyword be required on nearly every single standard OOP methods?<br></p><p>mutate graph.pencil.changeColor(Red) // the color properties of pencil is mutated<br>mutate graph.pencil.changeWidth(wide)<br>mutate graph.drawFrame() // the graphic is altered/mutated<br></p><p>Not proposing, just asking.<br></p><p>Dany<br></p><p>&gt; <br>&gt;&gt; Alternately you could replace the method invocation operator with &amp;<br>&gt;&gt; <br>&gt;&gt; let median = foo.calculateBigHugeArray()&amp;sort().medianValue()<br>&gt; <br>&gt; Don&#39;t you think that&#39;s too prone to getting mixed up with the binary `&amp;` operator?<br>&gt; <br>&gt;&gt; Also, if you wanted to stick with consistent &amp; syntax, you could do:<br>&gt;&gt; <br>&gt;&gt; &amp;c.frobnicate(i)<br>&gt;&gt; and <br>&gt;&gt; let k = &amp;c.frobnicate(&amp;i)<br>&gt; <br>&gt; <br>&gt; Yeah, probably. However, one place where that notation falls short compared to a prefixing keyword like `mutate` is when mutating `self`:<br>&gt; <br>&gt;     extension Array {<br>&gt;         // Apologies for not having the time to think of a less contrived example than this!<br>&gt;         mutating func quarter() {<br>&gt;             mutate self.halve() // Ever since SE-0009, it&#39;s unusual to use `self` here.<br>&gt;             mutate halve()      // Where would you put the `&amp;` prefix in this?<br>&gt;         }<br>&gt;     }<br>&gt; <br>&gt; — Pyry<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160428/10e0541a/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/aeab22e60ba7b7e2bd445775850448d1?s=50"></div><header><strong>mutating/non-mutating suggestion from a Rubyist</strong> from <string>Radosław Pietruszewski</string> &lt;radexpl at gmail.com&gt;<p>April 25, 2016 at 04:00:00pm</p></header><div class="content"><p>Q: Would it be possible to allow some sigil in method names (say, prefix/postfix `=`) without any automatic/magic treatment of these methods?<br></p><p>In Ruby, after all, postfix `!` is just allowed in names. It doesn’t have any semantic meaning for the interpreter, it’s just the (strong, well agreed upon) convention to use it to mark mutating methods in mutating/non-mutating pairs, like `foo.map(…)` vs `foo.map!(…)`.<br></p><p>It works out well for Ruby. Would it be out of question to allow the same thing in Swift? A naming convention (`foo.sort()` vs `foo.sort=()`), not an automatic language feature?<br></p><p>— Radek<br></p><p>&gt; On 22 Apr 2016, at 23:24, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; on Thu Apr 21 2016, Daniel Steinberg &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Pardon me if this has been raised before.<br>&gt;&gt; <br>&gt;&gt; I gave a short presentation at our Cleveland CocoaHeads this week on<br>&gt;&gt; what is coming in Swift 3. One of the attendees stayed behind to ask<br>&gt;&gt; about the naming guidelines for mutating vs non-mutating. He is fairly<br>&gt;&gt; new to Swift - coming from Ruby. I have no Ruby experience but am<br>&gt;&gt; passing his thoughts on to this list.<br>&gt;&gt; <br>&gt;&gt; He said that in Ruby they decorate the name with a symbol (I believe<br>&gt;&gt; in their case it is “!”) to distinguish between the two. Although<br>&gt;&gt; usually I’m not a fan of such naming conventions, we do something<br>&gt;&gt; similar with inout parameters.<br>&gt;&gt; <br>&gt;&gt; For example, if we have<br>&gt;&gt; <br>&gt;&gt; func myFunc(param: inout String) { …}<br>&gt;&gt; <br>&gt;&gt; we call it like this (using the Swift 3 first label convention)<br>&gt;&gt; <br>&gt;&gt; myFunc(param: &amp;aName)<br>&gt;&gt; <br>&gt;&gt; We use the &amp; to signal that the value of aName might be changed by the call to myFunc().<br>&gt;&gt; <br>&gt;&gt; Similarly, instead of settling on a naming convention for verb vs<br>&gt;&gt; verbed/verbing we could name the methods descriptively and require a<br>&gt;&gt; symbol (here I use &amp; but only for illustration) to distinguish between<br>&gt;&gt; mutating and non-mutating<br>&gt;&gt; <br>&gt;&gt; so we would have <br>&gt;&gt; <br>&gt;&gt; myArray.sort&amp;()<br>&gt;&gt; <br>&gt;&gt; and<br>&gt;&gt; <br>&gt;&gt; sortedArray = myArray.sort()<br>&gt;&gt; <br>&gt;&gt; Xcode and other tools could enforce this naming pattern and warn us<br>&gt;&gt; that a mutating method must end in “&amp;” and that a non-mutating method<br>&gt;&gt; is not allowed to.<br>&gt; <br>&gt; This is not a new idea.  Something almost identical to this has been<br>&gt; explored and discussed quite thoroughly already:<br>&gt; &lt;https://github.com/apple/swift/blob/master/docs/proposals/Inplace.rst &lt;https://github.com/apple/swift/blob/master/docs/proposals/Inplace.rst&gt;&gt;.<br>&gt; In fact, it was implmented and later reverted because it raised<br>&gt; language-design questions for which we had no good answers.  I don&#39;t<br>&gt; believe the choice of glyph (&amp; vs =) affects any of the fundamental<br>&gt; issues:<br>&gt; <br>&gt; * Should the x.=f() syntax be required for *every* mutating method<br>&gt;  invocation?<br>&gt; <br>&gt; * Are assignment methods a redundant way to spell mutating methods?<br>&gt;  Should we really have both mechanisms?<br>&gt; <br>&gt; * Can we really introduce this feature without having a way to apply it<br>&gt;  to class types?<br>&gt; <br>&gt; I should also point out that under the assignment method paradigm one<br>&gt; would probably need to re-evalutate rules for naming.  Under the current<br>&gt; API guidelines&#39; approach, we&#39;d write:<br>&gt; <br>&gt;    x.=sorted()      // sort x in-place<br>&gt; <br>&gt; and I am not sure how easy that would be for people to swallow<br>&gt; considering how much more straightforward<br>&gt; <br>&gt;    x.sort()         // current way to sort x in-place<br>&gt; <br>&gt; is, and because the language now contains explicit notation for<br>&gt; mutation, it becomes harder to argue against theis pair:<br>&gt; <br>&gt;    y = x.sort()<br>&gt;    x.=sort()      // sort x in place<br>&gt; <br>&gt; Lastly, I should point out that the proposal does nothing to solve the<br>&gt; problem of `c.formSuccessor(&amp;i)`, since that doesn&#39;t mutate the<br>&gt; receiver.<br>&gt; <br>&gt; I still like the proposal&#39;s basic approach and would love to see it used<br>&gt; to address these naming problems, but I want to be clear that it&#39;s by no<br>&gt; means a panacea and there are real obstacles between here and actually<br>&gt; being able to apply it.  If you want to move forward with something like<br>&gt; this, you need to solve the problems described above.<br>&gt; <br>&gt; -- <br>&gt; Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160425/c64c7a30/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>mutating/non-mutating suggestion from a Rubyist</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April 25, 2016 at 11:00:00am</p></header><div class="content"><p>on Mon Apr 25 2016, Radosław Pietruszewski &lt;radexpl-AT-gmail.com&gt; wrote:<br></p><p>&gt; Q: Would it be possible to allow some sigil in method names (say, prefix/postfix<br>&gt; `=`) without any automatic/magic treatment of these methods?<br></p><p>Almost anything is possible ;-).<br></p><p>&gt; In Ruby, after all, postfix `!` is just allowed in names. It doesn’t have any<br>&gt; semantic meaning for the interpreter, it’s just the (strong, well agreed upon)<br>&gt; convention to use it to mark mutating methods in mutating/non-mutating pairs,<br>&gt; like `foo.map(…)` vs `foo.map!(…)`.<br>&gt;<br>&gt; It works out well for Ruby. Would it be out of question to allow the same thing<br>&gt; in Swift? A naming convention (`foo.sort()` vs `foo.sort=()`), not an automatic<br>&gt; language feature?<br></p><p>I don&#39;t think we&#39;d want to allow this without tying it to mutation; just IMO.<br></p><p>-- <br>Dave<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
