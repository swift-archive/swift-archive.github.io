<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>May 27, 2016 at 12:00:00pm</p></header><div class="content"><p>Hello Swift community,<br></p><p>The review of SE-0099 “Restructuring Condition Clauses” begins now and runs through June 3, 2016. The proposal is available here:<br></p><p>	https://github.com/apple/swift-evolution/blob/master/proposals/0099-conditionclauses.md<br></p><p>Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br></p><p>	https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br></p><p>	Proposal link:<br></p><p>		https://github.com/apple/swift-evolution/blob/master/proposals/0099-conditionclauses.md<br></p><p>	Reply text<br></p><p>	Other replies<br></p><p>What goes into a review?<br></p><p>The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br></p><p>	• What is your evaluation of the proposal?<br>	• Is the problem being addressed significant enough to warrant a change to Swift?<br>	• Does this proposal fit well with the feel and direction of Swift?<br>	• If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>	• How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>More information about the Swift evolution process is available at<br></p><p>	https://github.com/apple/swift-evolution/blob/master/process.md<br></p><p>Thank you,<br></p><p>-Joe<br></p><p>Review Manager<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution-announce/attachments/20160527/2e6a6d11/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 27, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; 	• What is your evaluation of the proposal?<br></p><p>+1.  I believe it improves the clarity of condition clauses and as the proposal suggests, I think it will make it easier for programmers to learn and understand what is possible with them.<br></p><p>Did you consider allowing the semicolon to be omitted when a newline separates conditions?  Something like this:<br></p><p>condition-separator → ; | \n<br>‌condition-list → condition | condition condition-separator condition-list <br>‌condition → expression | availability-condition | case-condition | optional-binding-condition<br></p><p>If so, what is the reason for requiring semicolons here when they can be omitted elsewhere in Swift?<br></p><p>&gt; 	• Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes.  <br>&gt; 	• Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes.<br></p><p>&gt; 	• If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>No.<br></p><p>&gt; 	• How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>Participated in the discussion and offered feedback along the way, as well as reading the final proposal.<br></p><p>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt; Review Manager<br>&gt; _______________________________________________<br>&gt; swift-evolution-announce mailing list<br>&gt; swift-evolution-announce at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution-announce<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>May 27, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On May 27, 2016, at 1:28 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; 	• What is your evaluation of the proposal?<br>&gt; <br>&gt; +1.  I believe it improves the clarity of condition clauses and as the proposal suggests, I think it will make it easier for programmers to learn and understand what is possible with them.<br>&gt; <br>&gt; Did you consider allowing the semicolon to be omitted when a newline separates conditions?  Something like this:<br></p><p>Given the whole newline groundswell that has emerged on SE, I did consider it but when I mocked up examples, it felt less readable and I suspect it would negatively affect the clarity of parsing this proposal aims to introduce.<br></p><p>I&#39;d really like to see a separate newline-as-separator proposal brought forward and formally reviewed. It&#39;s garnered a few very vocal supporters but it really doesn&#39;t fall under the umbrella of this proposal. I&#39;d like the matter to be settled one way or the other for the sake of closure.<br></p><p>-- Erica<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 27, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On May 27, 2016, at 2:37 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 27, 2016, at 1:28 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; 	• What is your evaluation of the proposal?<br>&gt;&gt; <br>&gt;&gt; +1.  I believe it improves the clarity of condition clauses and as the proposal suggests, I think it will make it easier for programmers to learn and understand what is possible with them.<br>&gt;&gt; <br>&gt;&gt; Did you consider allowing the semicolon to be omitted when a newline separates conditions?  Something like this:<br>&gt; <br>&gt; Given the whole newline groundswell that has emerged on SE, I did consider it but when I mocked up examples, it felt less readable and I suspect it would negatively affect the clarity of parsing this proposal aims to introduce.<br></p><p>Maybe Joe can comment on the parsing question.<br></p><p>What kinds of examples did you look at where you felt that way?  IMO the example in the proposal reads better without the semicolons:<br></p><p>guard<br>    x == 0;<br>    let y = optional;<br>    z == 2 <br>    else { ... }<br></p><p>vs<br></p><p>guard<br>    x == 0<br>    let y = optional<br>    z == 2 <br>    else { ... }<br></p><p><br>&gt; <br>&gt; I&#39;d really like to see a separate newline-as-separator proposal brought forward and formally reviewed. It&#39;s garnered a few very vocal supporters but it really doesn&#39;t fall under the umbrella of this proposal. I&#39;d like the matter to be settled one way or the other for the sake of closure.<br></p><p>The other discussion has been about introducing newline-as-separator for comma separated lists.  <br></p><p>I raised the question in my review because Swift already uses newline-as-separator for semicolon separated lists (statements).<br></p><p>-Matthew<br></p><p>&gt; <br>&gt; -- Erica<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/8aa35fe2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>May 27, 2016 at 01:00:00pm</p></header><div class="content"><p>On May 27, 2016, at 1:47 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On May 27, 2016, at 2:37 PM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt; Given the whole newline groundswell that has emerged on SE, I did consider it but when I mocked up examples, it felt less readable and I suspect it would negatively affect the clarity of parsing this proposal aims to introduce.<br>&gt; <br>&gt; Maybe Joe can comment on the parsing question.<br>&gt; <br>&gt; What kinds of examples did you look at where you felt that way?  IMO the example in the proposal reads better without the semicolons:<br>&gt; <br>&gt; guard<br>&gt;     x == 0;<br>&gt;     let y = optional;<br>&gt;     z == 2 <br>&gt;     else { ... }<br>&gt; <br>&gt; vs<br>&gt; <br>&gt; guard<br>&gt;     x == 0<br>&gt;     let y = optional<br>&gt;     z == 2 <br>&gt;     else { ... }<br>&gt; <br>&gt; <br></p><p>I think this is going to be a matter of taste. I do not prefer the second example.<br></p><p>&gt;&gt; <br>&gt;&gt; I&#39;d really like to see a separate newline-as-separator proposal brought forward and formally reviewed. It&#39;s garnered a few very vocal supporters but it really doesn&#39;t fall under the umbrella of this proposal. I&#39;d like the matter to be settled one way or the other for the sake of closure.<br>&gt; <br>&gt; The other discussion has been about introducing newline-as-separator for comma separated lists.  <br>&gt; <br>&gt; I raised the question in my review because Swift already uses newline-as-separator for semicolon separated lists (statements).<br></p><p>If the guard elements were in a braced scope, I might feel differently. I prefer the form that is presented. <br></p><p>-- E<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/31fc345b/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 28, 2016 at 10:00:00am</p></header><div class="content"><p>On May 27, 2016, at 12:37 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; On May 27, 2016, at 1:28 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; 	• What is your evaluation of the proposal?<br>&gt;&gt; <br>&gt;&gt; +1.  I believe it improves the clarity of condition clauses and as the proposal suggests, I think it will make it easier for programmers to learn and understand what is possible with them.<br>&gt;&gt; <br>&gt;&gt; Did you consider allowing the semicolon to be omitted when a newline separates conditions?  Something like this:<br></p><p>No I didn’t think about or consider it.  I agree with you that this seems like it would be consistent with the rest of the language and can use the same mechanics we use for disambiguating two expressions on consecutive lines in a brace statement.  It also seems like it would lead to more pretty code in general as well.<br></p><p>&gt; Given the whole newline groundswell that has emerged on SE, I did consider it but when I mocked up examples, it felt less readable and I suspect it would negatively affect the clarity of parsing this proposal aims to introduce.<br>&gt; <br>&gt; I&#39;d really like to see a separate newline-as-separator proposal brought forward and formally reviewed. It&#39;s garnered a few very vocal supporters but it really doesn&#39;t fall under the umbrella of this proposal. I&#39;d like the matter to be settled one way or the other for the sake of closure.<br></p><p><br>I agree that this could be positioned as a subsequent additional proposal.  I’d personally be fine with looping this into the original proposal, but I’m also happy to split it out if you&#39;d prefer Erica,<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 28, 2016 at 12:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 28, 2016, at 12:11 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; On May 27, 2016, at 12:37 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; On May 27, 2016, at 1:28 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;    • What is your evaluation of the proposal?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +1.  I believe it improves the clarity of condition clauses and as the proposal suggests, I think it will make it easier for programmers to learn and understand what is possible with them.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Did you consider allowing the semicolon to be omitted when a newline separates conditions?  Something like this:<br>&gt; <br>&gt; No I didn’t think about or consider it.  I agree with you that this seems like it would be consistent with the rest of the language and can use the same mechanics we use for disambiguating two expressions on consecutive lines in a brace statement.  It also seems like it would lead to more pretty code in general as well.<br></p><p>Glad to hear this!<br></p><p>&gt; <br>&gt;&gt; Given the whole newline groundswell that has emerged on SE, I did consider it but when I mocked up examples, it felt less readable and I suspect it would negatively affect the clarity of parsing this proposal aims to introduce.<br>&gt;&gt; <br>&gt;&gt; I&#39;d really like to see a separate newline-as-separator proposal brought forward and formally reviewed. It&#39;s garnered a few very vocal supporters but it really doesn&#39;t fall under the umbrella of this proposal. I&#39;d like the matter to be settled one way or the other for the sake of closure.<br>&gt; <br>&gt; <br>&gt; I agree that this could be positioned as a subsequent additional proposal.  I’d personally be fine with looping this into the original proposal, but I’m also happy to split it out if you&#39;d prefer Erica,<br></p><p>If Erica isn&#39;t comfortable including it in this proposal I will be happy to drive a follow-up proposal.  <br></p><p>If we go that direction, would you want to see it focused exclusively on condition clauses or generalized to include comma separators in collection literals (and maybe argument lists?).<br></p><p>&gt; <br>&gt; -Chris<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 28, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On May 28, 2016, at 10:18 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Given the whole newline groundswell that has emerged on SE, I did consider it but when I mocked up examples, it felt less readable and I suspect it would negatively affect the clarity of parsing this proposal aims to introduce.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;d really like to see a separate newline-as-separator proposal brought forward and formally reviewed. It&#39;s garnered a few very vocal supporters but it really doesn&#39;t fall under the umbrella of this proposal. I&#39;d like the matter to be settled one way or the other for the sake of closure.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I agree that this could be positioned as a subsequent additional proposal.  I’d personally be fine with looping this into the original proposal, but I’m also happy to split it out if you&#39;d prefer Erica,<br>&gt; <br>&gt; If Erica isn&#39;t comfortable including it in this proposal I will be happy to drive a follow-up proposal.  <br>&gt; <br>&gt; If we go that direction, would you want to see it focused exclusively on condition clauses or generalized to include comma separators in collection literals (and maybe argument lists?).<br></p><p>I’d prefer to keep it focused on guard conditions, since they seem precedented by our handling of brace statements (which is already a sequence of expressions, statements, and let decls mixed together).  Collection literals seem like a separable discussion.<br></p><p>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160528/4f6c7abd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 28, 2016 at 02:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 28, 2016, at 12:33 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 28, 2016, at 10:18 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Given the whole newline groundswell that has emerged on SE, I did consider it but when I mocked up examples, it felt less readable and I suspect it would negatively affect the clarity of parsing this proposal aims to introduce.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;d really like to see a separate newline-as-separator proposal brought forward and formally reviewed. It&#39;s garnered a few very vocal supporters but it really doesn&#39;t fall under the umbrella of this proposal. I&#39;d like the matter to be settled one way or the other for the sake of closure.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree that this could be positioned as a subsequent additional proposal.  I’d personally be fine with looping this into the original proposal, but I’m also happy to split it out if you&#39;d prefer Erica,<br>&gt;&gt; <br>&gt;&gt; If Erica isn&#39;t comfortable including it in this proposal I will be happy to drive a follow-up proposal.  <br>&gt;&gt; <br>&gt;&gt; If we go that direction, would you want to see it focused exclusively on condition clauses or generalized to include comma separators in collection literals (and maybe argument lists?).<br>&gt; <br>&gt; I’d prefer to keep it focused on guard conditions, since they seem precedented by our handling of brace statements (which is already a sequence of expressions, statements, and let decls mixed together).  Collection literals seem like a separable discussion.<br></p><p>Sounds good.  Let&#39;s see what Erica says.  If she doesn&#39;t want to roll it in I&#39;ll get a draft of a proposal together right away.<br></p><p>&gt; <br>&gt; -Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160528/ba7b5c96/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Review] SE-0099: Restructuring Condition Clauses</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 27, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On May 27, 2016, at 9:11 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of SE-0099 “Restructuring Condition Clauses” begins now and runs through June 3, 2016. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0099-conditionclauses.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0099-conditionclauses.md&gt;<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br>&gt; <br>&gt; 	Proposal link:<br>&gt; <br>&gt; 		https://github.com/apple/swift-evolution/blob/master/proposals/0099-conditionclauses.md<br>&gt; <br>&gt; 	Reply text<br>&gt; <br>&gt; 	Other replies<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	• What is your evaluation of the proposal?<br></p><p>+1<br></p><p><br>&gt; 	• Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>yes. anything to avoid series of cascading guard statements will help push people in the direction of before/after where the safety is verified before proceeding further into a function<br></p><p>&gt; 	• Does this proposal fit well with the feel and direction of Swift?<br></p><p>guard is an essential tool of idiomatic Swift. making it more fluid feels like it removes the right road-blocks<br></p><p>&gt; 	• If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p><br>using a “;” between successive conditions lists bares a resemblance with how conditions are structured in the Golang IF statement <br>if err := dec.Decode(&amp;val); err != nil {<br>    // ERR has been bound and validated to be NOT nil<br>    <br>}<br>this is one of my favorite features of the language<br></p><p><br>&gt; 	• How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>followed the discussions and understanding the pre-existing limitations this change will lift<br></p><p>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt; Review Manager<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/7864292f/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9ce70a6cb7175e7a5e5db5658186a31?s=50"></div><header><strong>[Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Brandon Knope</string> &lt;bknope at me.com&gt;<p>May 27, 2016 at 05:00:00pm</p></header><div class="content"><p>I am giving a -1 for this proposal.<br></p><p>While I am sure it has merit, I am finding it to be a really technical change (meaning it makes the language look more technical at the expense of some of its beauty)<br></p><p>First, I do not find this example very compelling:<br>guard <br>    x == 0,<br>    let y = optional where z == 2 <br>    else { ... }<br></p><p>…in fact I did not know you could even do something like this: putting an unrelated variable in the where clause. Why not just require that variables in the where clause must have been bound from a previous statement in the conditional. This would make the where clause related to the clause that proceeds it<br></p><p>For example:<br>guard <br>    x == 0,<br>    let y = optional where y == 2 //y was just bound from an optional<br>    else { ... }<br></p><p>This I believe is more in spirit with what was intended with where clauses. To me, it should be an error to begin a where clause with a variable that does not proceed it anywhere in the conditional.<br></p><p>Second, I have really gotten use to not needing to use semicolons, and this proposal seems to use/require them in very common situations.<br></p><p>After shedding the requirement of semicolons from ObjC…now we will have to use them a lot again?<br></p><p><br>Third, the format will look like this in most people’s code:<br>guard x == 0; let y = optional; y == 2 else {  //can the third bool condition even refer to y? Is it still in scope?<br>	... <br>}<br>(in the above example, y == 2 is related to the optional that precedes it. Now it looks like a distinct statement)<br></p><p>compared to<br></p><p>guard x == 0, let y = someOptional where y == 2 else { <br>	... <br>}<br></p><p><br>To my eyes: the old way reads more naturally and looks less heavy. I think it keeps its expressiveness and also keeps it somewhat poetic.<br></p><p>Also, can someone refer me to an example of this statement: &quot;This proposal resolves this problem by retaining commas as separators within clauses (as used elsewhere in Swift) and introducing semicolons to separate distinct kinds of clauses (which aligns with the rest of the Swift language)”<br></p><p>I rarely see any semicolons after the removal of C loops. So if someone could put me to where this is used elsewhere in Swift, please do!<br></p><p>Thanks,<br>Brandon<br></p><p>&gt; On May 27, 2016, at 3:11 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of SE-0099 “Restructuring Condition Clauses” begins now and runs through June 3, 2016. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0099-conditionclauses.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0099-conditionclauses.md&gt;<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br>&gt; <br>&gt; 	Proposal link:<br>&gt; <br>&gt; 		https://github.com/apple/swift-evolution/blob/master/proposals/0099-conditionclauses.md<br>&gt; <br>&gt; 	Reply text<br>&gt; <br>&gt; 	Other replies<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	• What is your evaluation of the proposal?<br>&gt; 	• Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	• Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	• If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	• How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt; Review Manager<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/3a0ff647/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>May 27, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On May 27, 2016, at 3:06 PM, Brandon Knope via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Second, I have really gotten use to not needing to use semicolons, and this proposal seems to use/require them in very common situations.<br>&gt; <br>&gt; After shedding the requirement of semicolons from ObjC…now we will have to use them a lot again?<br>&gt; <br>&gt; <br>&gt; Third, the format will look like this in most people’s code:<br>&gt; guard x == 0; let y = optional; y == 2 else {  //can the third bool condition even refer to y? Is it still in scope?<br>&gt; 	... <br>&gt; }<br>&gt; (in the above example, y == 2 is related to the optional that precedes it. Now it looks like a distinct statement)<br>&gt; <br>&gt; compared to<br>&gt; <br>&gt; guard x == 0, let y = someOptional where y == 2 else { <br>&gt; 	... <br>&gt; }<br>&gt; <br>&gt; <br>&gt; To my eyes: the old way reads more naturally and looks less heavy. I think it keeps its expressiveness and also keeps it somewhat poetic.<br></p><p>This proposal serves the grammar, enabling it to simplify,  the compiler to avoid errors, and the developer to intermingle tests more naturally, as you would in processing JSON without having to nest or sequence separate guard statements. A main goal is differentiating the commas between conditions and in binding conditions, as you ask about below<br></p><p>I don&#39;t think it&#39;s practical to use a second braced scope:<br></p><p>guard {<br>   condition<br>   condition<br>   condition<br>} else {<br>   leave scope<br>}<br></p><p>This would be confusing to anyone doing conditional binding for use in the top level scope; the bindings would &quot;escape&quot; the braces. Using semicolons establishes a balance between separating different kinds of conditions and allowing comma-delineated multiple bindings.<br></p><p>Current state:<br></p><p>* Confusing, complicated, organically grown grammar<br>* Inability to use independently standing Boolean assertions after the first (except for one outlier availability case)<br></p><p>Proposed state:<br></p><p>* Very simple grammar<br>* Developer-directed ordering of binding, availability, Boolean assertions, cases, used in the order they&#39;re consumed<br>* Slightly uglier<br></p><p>The cost for this is a separator between conditions<br></p><p>&gt; Also, can someone refer me to an example of this statement: &quot;This proposal resolves this problem by retaining commas as separators within clauses (as used elsewhere in Swift) and introducing semicolons to separate distinct kinds of clauses (which aligns with the rest of the Swift language)”<br></p><p>guard let x = opt1, y = opt2, z = opt3; booleanAssertion else { }<br></p><p>&gt; <br>&gt; I rarely see any semicolons after the removal of C loops. So if someone could put me to where this is used elsewhere in Swift, please do!<br></p><p>Using semicolons brings conditions in-line with how semicolons are used as separators elsewhere in the Swift grammar.<br></p><p>-- Erica<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/2d47e302/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 27, 2016 at 07:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 27, 2016, at 7:13 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 27, 2016, at 3:06 PM, Brandon Knope via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Second, I have really gotten use to not needing to use semicolons, and this proposal seems to use/require them in very common situations.<br>&gt;&gt; <br>&gt;&gt; After shedding the requirement of semicolons from ObjC…now we will have to use them a lot again?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Third, the format will look like this in most people’s code:<br>&gt;&gt; guard x == 0; let y = optional; y == 2 else {  //can the third bool condition even refer to y? Is it still in scope?<br>&gt;&gt; 	... <br>&gt;&gt; }<br>&gt;&gt; (in the above example, y == 2 is related to the optional that precedes it. Now it looks like a distinct statement)<br>&gt;&gt; <br>&gt;&gt; compared to<br>&gt;&gt; <br>&gt;&gt; guard x == 0, let y = someOptional where y == 2 else { <br>&gt;&gt; 	... <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; To my eyes: the old way reads more naturally and looks less heavy. I think it keeps its expressiveness and also keeps it somewhat poetic.<br>&gt; <br>&gt; This proposal serves the grammar, enabling it to simplify,  the compiler to avoid errors, and the developer to intermingle tests more naturally, as you would in processing JSON without having to nest or sequence separate guard statements. A main goal is differentiating the commas between conditions and in binding conditions, as you ask about below<br>&gt; <br>&gt; I don&#39;t think it&#39;s practical to use a second braced scope:<br>&gt; <br>&gt; guard {<br>&gt;    condition<br>&gt;    condition<br>&gt;    condition<br>&gt; } else {<br>&gt;    leave scope<br>&gt; }<br>&gt; <br>&gt; This would be confusing to anyone doing conditional binding for use in the top level scope; the bindings would &quot;escape&quot; the braces. Using semicolons establishes a balance between separating different kinds of conditions and allowing comma-delineated multiple bindings.<br>&gt; <br>&gt; Current state:<br>&gt; <br>&gt; * Confusing, complicated, organically grown grammar<br>&gt; * Inability to use independently standing Boolean assertions after the first (except for one outlier availability case)<br>&gt; <br>&gt; Proposed state:<br>&gt; <br>&gt; * Very simple grammar<br>&gt; * Developer-directed ordering of binding, availability, Boolean assertions, cases, used in the order they&#39;re consumed<br>&gt; * Slightly uglier<br>&gt; <br>&gt; The cost for this is a separator between conditions<br></p><p>But we don&#39;t *have* to pay that cost if we handle them the same as other semicolons in the language.<br></p><p>&gt; <br>&gt;&gt; Also, can someone refer me to an example of this statement: &quot;This proposal resolves this problem by retaining commas as separators within clauses (as used elsewhere in Swift) and introducing semicolons to separate distinct kinds of clauses (which aligns with the rest of the Swift language)”<br>&gt; <br>&gt; guard let x = opt1, y = opt2, z = opt3; booleanAssertion else { }<br>&gt; <br>&gt;&gt; <br>&gt;&gt; I rarely see any semicolons after the removal of C loops. So if someone could put me to where this is used elsewhere in Swift, please do!<br>&gt; <br>&gt; Using semicolons brings conditions in-line with how semicolons are used as separators elsewhere in the Swift grammar.<br></p><p>Not really.  We can use a newline instead of the semicolon elsewhere.<br></p><p>&gt; <br>&gt; -- Erica<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/34d32714/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>May 27, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On May 27, 2016, at 6:19 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt; Also, can someone refer me to an example of this statement: &quot;This proposal resolves this problem by retaining commas as separators within clauses (as used elsewhere in Swift) and introducing semicolons to separate distinct kinds of clauses (which aligns with the rest of the Swift language)”<br>&gt;&gt; <br>&gt;&gt; guard let x = opt1, y = opt2, z = opt3; booleanAssertion else { }<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I rarely see any semicolons after the removal of C loops. So if someone could put me to where this is used elsewhere in Swift, please do!<br>&gt;&gt; <br>&gt;&gt; Using semicolons brings conditions in-line with how semicolons are used as separators elsewhere in the Swift grammar.<br>&gt; <br>&gt; Not really.  We can use a newline instead of the semicolon elsewhere.<br></p><p>Outside of braces? Think of the guard/if/while creating a new miniscope that has no braces, and whose value assignments escape to the surrounding scope. I defer to Chris for better technical answers.<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/13c1731d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 27, 2016 at 07:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 27, 2016, at 7:22 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 27, 2016, at 6:19 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt; Also, can someone refer me to an example of this statement: &quot;This proposal resolves this problem by retaining commas as separators within clauses (as used elsewhere in Swift) and introducing semicolons to separate distinct kinds of clauses (which aligns with the rest of the Swift language)”<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; guard let x = opt1, y = opt2, z = opt3; booleanAssertion else { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I rarely see any semicolons after the removal of C loops. So if someone could put me to where this is used elsewhere in Swift, please do!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Using semicolons brings conditions in-line with how semicolons are used as separators elsewhere in the Swift grammar.<br>&gt;&gt; <br>&gt;&gt; Not really.  We can use a newline instead of the semicolon elsewhere.<br>&gt; <br>&gt; Outside of braces? Think of the guard/if/while creating a new miniscope that has no braces, and whose value assignments escape to the surrounding scope. I defer to Chris for better technical answers.<br></p><p>They are only used for statement separators as far as I know.  Statements only happen inside code blocks, which are always surrounded by braces.  So no, not outside braces as far as I know.  <br></p><p>But I don&#39;t know what that has to do with the fact that newline can be used as an alternative.  It&#39;s just an alternate separator.  As far as I know, everywhere semicolons are used as separators newlines are accepted as an alternate separator.<br></p><p>&gt; <br>&gt; -- E<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/94650c83/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May 28, 2016 at 12:00:00am</p></header><div class="content"><p>I don&#39;t believe that was the case with the semicolons in the original for;;<br>loop, was it?<br>On Fri, May 27, 2016 at 20:37 Matthew Johnson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; On May 27, 2016, at 7:22 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On May 27, 2016, at 6:19 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; Also, can someone refer me to an example of this statement: &quot;This<br>&gt; proposal resolves this problem by retaining commas as separators within<br>&gt; clauses (as used elsewhere in Swift) and introducing semicolons to separate<br>&gt; distinct kinds of clauses (which aligns with the rest of the Swift language)<br>&gt; ”<br>&gt;<br>&gt;<br>&gt; guard let x = opt1, y = opt2, z = opt3; booleanAssertion else { }<br>&gt;<br>&gt;<br>&gt;<br>&gt; I rarely see any semicolons after the removal of C loops. So if someone<br>&gt; could put me to where this is used elsewhere in Swift, please do!<br>&gt;<br>&gt;<br>&gt; Using semicolons brings conditions in-line with how semicolons are used as<br>&gt; separators elsewhere in the Swift grammar.<br>&gt;<br>&gt;<br>&gt; Not really.  We can use a newline instead of the semicolon elsewhere.<br>&gt;<br>&gt;<br>&gt; Outside of braces? Think of the guard/if/while creating a new miniscope<br>&gt; that has no braces, and whose value assignments escape to the surrounding<br>&gt; scope. I defer to Chris for better technical answers.<br>&gt;<br>&gt;<br>&gt; They are only used for statement separators as far as I know.  Statements<br>&gt; only happen inside code blocks, which are always surrounded by braces.  So<br>&gt; no, not outside braces as far as I know.<br>&gt;<br>&gt; But I don&#39;t know what that has to do with the fact that newline can be<br>&gt; used as an alternative.  It&#39;s just an alternate separator.  As far as I<br>&gt; know, everywhere semicolons are used as separators newlines are accepted as<br>&gt; an alternate separator.<br>&gt;<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160528/31fa8fe0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 27, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On May 27, 2016, at 7:50 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; I don&#39;t believe that was the case with the semicolons in the original for;; loop, was it?<br></p><p>No, I don’t believe so, but that’s gone now.  And it is pretty uncommon to see `for` loop clauses on multiple lines.  Not so with `guard`.<br></p><p>&gt; On Fri, May 27, 2016 at 20:37 Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On May 27, 2016, at 7:22 PM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 27, 2016, at 6:19 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; Also, can someone refer me to an example of this statement: &quot;This proposal resolves this problem by retaining commas as separators within clauses (as used elsewhere in Swift) and introducing semicolons to separate distinct kinds of clauses (which aligns with the rest of the Swift language)”<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; guard let x = opt1, y = opt2, z = opt3; booleanAssertion else { }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I rarely see any semicolons after the removal of C loops. So if someone could put me to where this is used elsewhere in Swift, please do!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Using semicolons brings conditions in-line with how semicolons are used as separators elsewhere in the Swift grammar.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Not really.  We can use a newline instead of the semicolon elsewhere.<br>&gt;&gt; <br>&gt;&gt; Outside of braces? Think of the guard/if/while creating a new miniscope that has no braces, and whose value assignments escape to the surrounding scope. I defer to Chris for better technical answers.<br>&gt; <br>&gt; They are only used for statement separators as far as I know.  Statements only happen inside code blocks, which are always surrounded by braces.  So no, not outside braces as far as I know.  <br>&gt; <br>&gt; But I don&#39;t know what that has to do with the fact that newline can be used as an alternative.  It&#39;s just an alternate separator.  As far as I know, everywhere semicolons are used as separators newlines are accepted as an alternate separator.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/168180d1/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>May 28, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On 28 May 2016, at 10:37 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; But I don&#39;t know what that has to do with the fact that newline can be used as an alternative.  It&#39;s just an alternate separator.  As far as I know, everywhere semicolons are used as separators newlines are accepted as an alternate separator.<br></p><p><br></p><p>Looks like an interesting proposal. I agree that the use of semicolons being interchangeable with newline separators should be consistent in their usage.<br></p><p>Otherwise there’s one approach to learn for members of a type, one for arrays and dictionaries, one for generic parameters, one for a list of clauses, one for pattern matching, one for tuples. Each of these have different rules it seems?<br></p><p>Not sure what the best rule and separator to use is, but it would be nice to have something consistent, even if it was more strict in places than today’s rules. Even if when different hierarchies that are used together, such as pattern matching with multiple parts and multiple boolean expressions, then it would be nice for these to have a different separator so they can never clash and step on each others’ toes. Maybe this is the comma and semicolon (/newline).<br></p><p><br>A different train of thought: could semicolons allow the closure ambiguity to be resolved that Chris brought up a couple of months ago? e.g.<br></p><p>if numbers.contains { $0 &gt; 7 }; {<br>  // ...<br>}<br></p><p>// Or newlines<br></p><p>if<br>  numbers.contains { $0 &gt; 7 }<br>{<br>  // ...<br>}<br></p><p>I imagine it wouldn’t, as the parser would always catch that first ‘{‘ as an opening brace? Would be nice to solve this if possible too.<br></p><p>Patrick<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160528/5d360c7b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 28, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On May 28, 2016, at 12:13 AM, Patrick Smith via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; A different train of thought: could semicolons allow the closure ambiguity to be resolved that Chris brought up a couple of months ago? e.g.<br>&gt; I imagine it wouldn’t, as the parser would always catch that first ‘{‘ as an opening brace? Would be nice to solve this if possible too.<br></p><p>No, it doesn’t help.  To solve that, we would need to introduce a separator between the condition and the body of the loop (like guard has).<br></p><p>I’m optimistic that, in time, we can just make the parser smart enough to handle the existing syntax for the trailing closure case by using lookahead.<br></p><p>-Chris<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9ce70a6cb7175e7a5e5db5658186a31?s=50"></div><header><strong>[Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Brandon Knope</string> &lt;bknope at me.com&gt;<p>May 27, 2016 at 10:00:00pm</p></header><div class="content"><p>As a *user* of the language, I find it a little disconcerting that we would make the syntax uglier just to serve the grammar. Where is the benefit to the user with this? Especially at the cost of making it slightly uglier?<br></p><p>And sorry, but what is a boolean assertion? :embarrassed face:<br></p><p>Brandon <br></p><p>Sent from my iPad<br></p><p>&gt; On May 27, 2016, at 8:13 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 27, 2016, at 3:06 PM, Brandon Knope via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Second, I have really gotten use to not needing to use semicolons, and this proposal seems to use/require them in very common situations.<br>&gt;&gt; <br>&gt;&gt; After shedding the requirement of semicolons from ObjC…now we will have to use them a lot again?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Third, the format will look like this in most people’s code:<br>&gt;&gt; guard x == 0; let y = optional; y == 2 else {  //can the third bool condition even refer to y? Is it still in scope?<br>&gt;&gt; 	... <br>&gt;&gt; }<br>&gt;&gt; (in the above example, y == 2 is related to the optional that precedes it. Now it looks like a distinct statement)<br>&gt;&gt; <br>&gt;&gt; compared to<br>&gt;&gt; <br>&gt;&gt; guard x == 0, let y = someOptional where y == 2 else { <br>&gt;&gt; 	... <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; To my eyes: the old way reads more naturally and looks less heavy. I think it keeps its expressiveness and also keeps it somewhat poetic.<br>&gt; <br>&gt; This proposal serves the grammar, enabling it to simplify,  the compiler to avoid errors, and the developer to intermingle tests more naturally, as you would in processing JSON without having to nest or sequence separate guard statements. A main goal is differentiating the commas between conditions and in binding conditions, as you ask about below<br>&gt; <br>&gt; I don&#39;t think it&#39;s practical to use a second braced scope:<br>&gt; <br>&gt; guard {<br>&gt;    condition<br>&gt;    condition<br>&gt;    condition<br>&gt; } else {<br>&gt;    leave scope<br>&gt; }<br>&gt; <br>&gt; This would be confusing to anyone doing conditional binding for use in the top level scope; the bindings would &quot;escape&quot; the braces. Using semicolons establishes a balance between separating different kinds of conditions and allowing comma-delineated multiple bindings.<br>&gt; <br>&gt; Current state:<br>&gt; <br>&gt; * Confusing, complicated, organically grown grammar<br>&gt; * Inability to use independently standing Boolean assertions after the first (except for one outlier availability case)<br>&gt; <br>&gt; Proposed state:<br>&gt; <br>&gt; * Very simple grammar<br>&gt; * Developer-directed ordering of binding, availability, Boolean assertions, cases, used in the order they&#39;re consumed<br>&gt; * Slightly uglier<br>&gt; <br>&gt; The cost for this is a separator between conditions<br>&gt; <br>&gt;&gt; Also, can someone refer me to an example of this statement: &quot;This proposal resolves this problem by retaining commas as separators within clauses (as used elsewhere in Swift) and introducing semicolons to separate distinct kinds of clauses (which aligns with the rest of the Swift language)”<br>&gt; <br>&gt; guard let x = opt1, y = opt2, z = opt3; booleanAssertion else { }<br>&gt; <br>&gt;&gt; <br>&gt;&gt; I rarely see any semicolons after the removal of C loops. So if someone could put me to where this is used elsewhere in Swift, please do!<br>&gt; <br>&gt; Using semicolons brings conditions in-line with how semicolons are used as separators elsewhere in the Swift grammar.<br>&gt; <br>&gt; -- Erica<br>&gt; <br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/ec0a50f3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>[Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>May 27, 2016 at 07:00:00pm</p></header><div class="content"><p>I haven&#39;t had time to carefully read this whole thread, but I don&#39;t think I<br>agree that this syntax is &quot;uglier&quot;.<br></p><p>Isn&#39;t it true that semicolons are used regularly in English; that they<br>delimit separate clauses, boolean or otherwise; and that the proposed<br>syntax mirrors English grammar pretty well (perhaps depending on which<br>manual of style you choose)?<br></p><p>Jacob<br></p><p>On Fri, May 27, 2016 at 7:28 PM, Brandon Knope via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; As a *user* of the language, I find it a little disconcerting that we<br>&gt; would make the syntax uglier just to serve the grammar. Where is the<br>&gt; benefit to the user with this? Especially at the cost of making it slightly<br>&gt; uglier?<br>&gt;<br>&gt; And sorry, but what is a boolean assertion? :embarrassed face:<br>&gt;<br>&gt; Brandon<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; On May 27, 2016, at 8:13 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On May 27, 2016, at 3:06 PM, Brandon Knope via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; Second, I have really gotten use to not needing to use semicolons, and<br>&gt; this proposal seems to use/require them in very common situations.<br>&gt;<br>&gt; After shedding the requirement of semicolons from ObjC…now we will have to<br>&gt; use them a lot again?<br>&gt;<br>&gt;<br>&gt; Third, the format will look like this in most people’s code:<br>&gt;<br>&gt; guard x == 0; let y = optional; y == 2 else {  //can the third bool condition even refer to y? Is it still in scope?	... }<br>&gt;<br>&gt; (in the above example, *y == 2* is related to the optional that precedes<br>&gt; it. Now it looks like a distinct statement)<br>&gt;<br>&gt; compared to<br>&gt;<br>&gt; guard x == 0, let y = someOptional where y == 2 else { 	...<br>&gt; }<br>&gt;<br>&gt;<br>&gt;<br>&gt; To my eyes: the old way reads more naturally and looks less heavy. I think<br>&gt; it keeps its expressiveness and also keeps it somewhat poetic.<br>&gt;<br>&gt;<br>&gt; This proposal serves the grammar, enabling it to simplify,  the compiler<br>&gt; to avoid errors, and the developer to intermingle tests more naturally, as<br>&gt; you would in processing JSON without having to nest or sequence separate<br>&gt; guard statements. A main goal is differentiating the commas between<br>&gt; conditions and in binding conditions, as you ask about below<br>&gt;<br>&gt; I don&#39;t think it&#39;s practical to use a second braced scope:<br>&gt;<br>&gt; guard {<br>&gt;    condition<br>&gt;    condition<br>&gt;    condition<br>&gt; } else {<br>&gt;    leave scope<br>&gt; }<br>&gt;<br>&gt; This would be confusing to anyone doing conditional binding for use in the<br>&gt; top level scope; the bindings would &quot;escape&quot; the braces. Using semicolons<br>&gt; establishes a balance between separating different kinds of conditions and<br>&gt; allowing comma-delineated multiple bindings.<br>&gt;<br>&gt; Current state:<br>&gt;<br>&gt; * Confusing, complicated, organically grown grammar<br>&gt; * Inability to use independently standing Boolean assertions after the<br>&gt; first (except for one outlier availability case)<br>&gt;<br>&gt; Proposed state:<br>&gt;<br>&gt; * Very simple grammar<br>&gt; * Developer-directed ordering of binding, availability, Boolean<br>&gt; assertions, cases, used in the order they&#39;re consumed<br>&gt; * Slightly uglier<br>&gt;<br>&gt; The cost for this is a separator between conditions<br>&gt;<br>&gt; Also, can someone refer me to an example of this statement: &quot;This<br>&gt; proposal resolves this problem by retaining commas as separators within<br>&gt; clauses (as used elsewhere in Swift) and introducing semicolons to separate<br>&gt; distinct kinds of clauses (which aligns with the rest of the Swift language)<br>&gt; ”<br>&gt;<br>&gt;<br>&gt; guard let x = opt1, y = opt2, z = opt3; booleanAssertion else { }<br>&gt;<br>&gt;<br>&gt;<br>&gt; I rarely see any semicolons after the removal of C loops. So if someone<br>&gt; could put me to where this is used elsewhere in Swift, please do!<br>&gt;<br>&gt;<br>&gt; Using semicolons brings conditions in-line with how semicolons are used as<br>&gt; separators elsewhere in the Swift grammar.<br>&gt;<br>&gt; -- Erica<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/68b173a4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9ce70a6cb7175e7a5e5db5658186a31?s=50"></div><header><strong>[Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Brandon Knope</string> &lt;bknope at me.com&gt;<p>May 27, 2016 at 11:00:00pm</p></header><div class="content"><p>I was using the word that the proposal author even used!<br></p><p>Couldn&#39;t the same be said for the comma though?<br></p><p>Sent from my iPad<br></p><p>&gt; On May 27, 2016, at 10:48 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt; <br>&gt; I haven&#39;t had time to carefully read this whole thread, but I don&#39;t think I agree that this syntax is &quot;uglier&quot;.<br>&gt; <br>&gt; Isn&#39;t it true that semicolons are used regularly in English; that they delimit separate clauses, boolean or otherwise; and that the proposed syntax mirrors English grammar pretty well (perhaps depending on which manual of style you choose)?<br>&gt; <br>&gt; Jacob<br>&gt; <br>&gt;&gt; On Fri, May 27, 2016 at 7:28 PM, Brandon Knope via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; As a *user* of the language, I find it a little disconcerting that we would make the syntax uglier just to serve the grammar. Where is the benefit to the user with this? Especially at the cost of making it slightly uglier?<br>&gt;&gt; <br>&gt;&gt; And sorry, but what is a boolean assertion? :embarrassed face:<br>&gt;&gt; <br>&gt;&gt; Brandon <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt;&gt; On May 27, 2016, at 8:13 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 27, 2016, at 3:06 PM, Brandon Knope via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Second, I have really gotten use to not needing to use semicolons, and this proposal seems to use/require them in very common situations.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; After shedding the requirement of semicolons from ObjC…now we will have to use them a lot again?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Third, the format will look like this in most people’s code:<br>&gt;&gt;&gt;&gt; guard x == 0; let y = optional; y == 2 else {  //can the third bool condition even refer to y? Is it still in scope?<br>&gt;&gt;&gt;&gt; 	... <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; (in the above example, y == 2 is related to the optional that precedes it. Now it looks like a distinct statement)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; compared to<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; guard x == 0, let y = someOptional where y == 2 else { <br>&gt;&gt;&gt;&gt; 	... <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; To my eyes: the old way reads more naturally and looks less heavy. I think it keeps its expressiveness and also keeps it somewhat poetic.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This proposal serves the grammar, enabling it to simplify,  the compiler to avoid errors, and the developer to intermingle tests more naturally, as you would in processing JSON without having to nest or sequence separate guard statements. A main goal is differentiating the commas between conditions and in binding conditions, as you ask about below<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t think it&#39;s practical to use a second braced scope:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; guard {<br>&gt;&gt;&gt;    condition<br>&gt;&gt;&gt;    condition<br>&gt;&gt;&gt;    condition<br>&gt;&gt;&gt; } else {<br>&gt;&gt;&gt;    leave scope<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This would be confusing to anyone doing conditional binding for use in the top level scope; the bindings would &quot;escape&quot; the braces. Using semicolons establishes a balance between separating different kinds of conditions and allowing comma-delineated multiple bindings.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Current state:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * Confusing, complicated, organically grown grammar<br>&gt;&gt;&gt; * Inability to use independently standing Boolean assertions after the first (except for one outlier availability case)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposed state:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * Very simple grammar<br>&gt;&gt;&gt; * Developer-directed ordering of binding, availability, Boolean assertions, cases, used in the order they&#39;re consumed<br>&gt;&gt;&gt; * Slightly uglier<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The cost for this is a separator between conditions<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Also, can someone refer me to an example of this statement: &quot;This proposal resolves this problem by retaining commas as separators within clauses (as used elsewhere in Swift) and introducing semicolons to separate distinct kinds of clauses (which aligns with the rest of the Swift language)”<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; guard let x = opt1, y = opt2, z = opt3; booleanAssertion else { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I rarely see any semicolons after the removal of C loops. So if someone could put me to where this is used elsewhere in Swift, please do!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Using semicolons brings conditions in-line with how semicolons are used as separators elsewhere in the Swift grammar.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- Erica<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/e2d92a40/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 27, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; 		https://github.com/apple/swift-evolution/blob/master/proposals/0099-conditionclauses.md<br></p><p>&gt; 	• What is your evaluation of the proposal?<br></p><p>Oof.<br></p><p>I am not a fan of this syntax. `;` reads very strongly as a statement ender to me, and yet at the same time, it&#39;s still visually quite close to `,`. My first impression was that the proposal had an embarrassing typo in the very first example.<br></p><p>My suggestion would be to reuse our normal &amp;&amp; operator:<br></p><p>	guard<br>		x == 0 &amp;&amp;<br>		let y = optional &amp;&amp;<br>		z == 2<br>		else { ... }<br></p><p>This would obviously be a built-in `&amp;&amp;` separate from our existing, infix operator `&amp;&amp;`. (Well, unless we make `let` and `case` clauses return Bools in an `if` statement, and somehow teach the compiler that `&amp;&amp;` will return `false` if a binding fails.) But there is no ambiguity about the meaning of this code. It is obvious that both conditions have to succeed, and it is obvious that `z == 2` was not meant to be another optional binding. Honestly, in some ways it&#39;s more understandable than the status quo.<br></p><p>&gt; 	• Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Maybe, if we have a good enough solution. I don&#39;t think this is it.<br></p><p>&gt; 	• Does this proposal fit well with the feel and direction of Swift?<br></p><p>I think it&#39;s kind of neutral, honestly.<br></p><p>&gt; 	• If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>Most languages I&#39;ve used have `if` statements which take a simple boolean expression, so they don&#39;t face this problem.<br></p><p>&gt; 	• How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>Pretty much a glance.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>May 27, 2016 at 06:00:00pm</p></header><div class="content"><p>On May 27, 2016, at 5:35 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; 		https://github.com/apple/swift-evolution/blob/master/proposals/0099-conditionclauses.md<br>&gt; <br>&gt;&gt; 	• What is your evaluation of the proposal?<br>&gt; <br>&gt; Oof.<br>&gt; <br>&gt; I am not a fan of this syntax. `;` reads very strongly as a statement ender to me, and yet at the same time, it&#39;s still visually quite close to `,`. My first impression was that the proposal had an embarrassing typo in the very first example.<br>&gt; <br>&gt; My suggestion would be to reuse our normal &amp;&amp; operator:<br>&gt; <br>&gt; 	guard<br>&gt; 		x == 0 &amp;&amp;<br>&gt; 		let y = optional &amp;&amp;<br>&gt; 		z == 2<br>&gt; 		else { ... }<br></p><p><br>In theory because if/guard/when create a mini scope, this might be possible to use in this context but I&#39;ll defer to Chris to reply to the issue of whether it&#39;s a better separator. Keep in mind that the proposal doesn&#39;t update the grammar for each of the conditions so the following is possible<br></p><p>guard<br>  x == 0 &amp;&amp; a == b &amp;&amp; c == d &amp;&amp;<br>  let y = optional, w = optional2, v = optional 3 &amp;&amp;<br>   z == 2<br>else { ... }<br></p><p>Figuring out where to break the first line into expression and into condition (after the `d`) could be very challenging to the compiler.<br></p><p>-- Erica<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 27, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; guard<br>&gt;  x == 0 &amp;&amp; a == b &amp;&amp; c == d &amp;&amp;<br>&gt;  let y = optional, w = optional2, v = optional 3 &amp;&amp;<br>&gt;   z == 2<br>&gt; else { ... }<br>&gt; <br>&gt; Figuring out where to break the first line into expression and into condition (after the `d`) could be very challenging to the compiler.<br></p><p>I&#39;m not sure it is. `let` and `case` are not valid in an expression, so an `&amp;&amp;` followed by `let` or `case` must be joining clauses. On the other side of things, Swift&#39;s `&amp;&amp;` doesn&#39;t ever produce an optional, so if we&#39;re parsing an expression at the top level of an if-let, an `&amp;&amp;` must indicate the end of the clause. An if-case *could* theoretically include an `&amp;&amp;`, but pattern matching against a boolean value seems like a fairly useless thing to do in a context that&#39;s specifically intended to test booleans.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>May 27, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On May 27, 2016, at 6:26 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; guard<br>&gt;&gt; x == 0 &amp;&amp; a == b &amp;&amp; c == d &amp;&amp;<br>&gt;&gt; let y = optional, w = optional2, v = optional 3 &amp;&amp;<br>&gt;&gt;  z == 2<br>&gt;&gt; else { ... }<br>&gt;&gt; <br>&gt;&gt; Figuring out where to break the first line into expression and into condition (after the `d`) could be very challenging to the compiler.<br>&gt; <br>&gt; I&#39;m not sure it is. `let` and `case` are not valid in an expression, so an `&amp;&amp;` followed by `let` or `case` must be joining clauses. On the other side of things, Swift&#39;s `&amp;&amp;` doesn&#39;t ever produce an optional, so if we&#39;re parsing an expression at the top level of an if-let, an `&amp;&amp;` must indicate the end of the clause. An if-case *could* theoretically include an `&amp;&amp;`, but pattern matching against a boolean value seems like a fairly useless thing to do in a context that&#39;s specifically intended to test booleans.<br></p><p>Let me answer in another way that speaks to my background which isn&#39;t in compiler theory: The use of &amp;&amp; may produce cognitive overload between the use in Boolean assertions and the use in separating condition clauses.<br></p><p>-- E<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 27, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; Let me answer in another way that speaks to my background which isn&#39;t in compiler theory: The use of &amp;&amp; may produce cognitive overload between the use in Boolean assertions and the use in separating condition clauses.<br></p><p>Yes, which is quite intentional on my part. The `if` statement requires that all of its clauses succeed; if pattern matching and optional testing were boolean expressions, you would use `&amp;&amp;` to link them with each other and with boolean tests. The fact that these are *not* boolean expressions is a mere artifact of Swift&#39;s implementation.<br></p><p>I think our best solution is to make Swift act as though these *are* boolean expressions, but ones that can only be used in a limited way: they can only be `&amp;&amp;`ed, because they bind variables that have to be made available in specific blocks. In other words, I think we should paper over the compiler limitations preventing these things from working as expected.<br></p><p>(Actually, it might be interesting to allow `!let` and `!case` statements which are available in the `else` branches of the control structures they&#39;re used in, but that&#39;s a different story...)<br></p><p>***<br></p><p>If you&#39;ll permit me to go sort of &quot;mad dream&quot; here for a moment, I can actually sort of see a way to do a lot of this in the standard library. Imagine if the `let` and `case` clauses in a conditional produced a type like this:<br></p><p>	enum PatternMatchingResult&lt;BoundValues&gt; {<br>		case failed<br>		case succeeded (BoundValues)<br>	}<br></p><p>`BoundValues` would be the values, if any, extracted through the pattern matching operation. Then you could define operators like these:<br></p><p>	func &amp;&amp; &lt;T, U&gt;(lhs: PatternMatchingResult&lt;T&gt;, rhs: @autoclosure () -&gt; PatternMatchingResult&lt;U&gt;) -&gt; PatternMatchingResult&lt;(T, U)&gt; {<br>		guard case .succeeded (let lhsValue) = lhs else {<br>			return .failed<br>		}<br>		guard case .succeeded (let rhsValue) = rhs() else {<br>			return .failed<br>		}<br>		return .succeeded (lhsValue, rhsValue)<br>	}<br></p><p>	func &amp;&amp; &lt;T&gt;(lhs: PatternMatchingResult&lt;T&gt;, rhs: @autoclosure () -&gt; Boolean) -&gt; PatternMatchingResult&lt;T&gt; {<br>		guard case .succeeded = lhs else {<br>			return .failed<br>		}<br>		guard rhs() else {<br>			return .failed<br>		}<br>		return lhs<br>	}<br>	<br>	func &amp;&amp; &lt;U&gt;(lhs: Boolean, rhs: @autoclosure () -&gt; PatternMatchingResult&lt;U&gt;) -&gt; PatternMatchingResult&lt;U&gt; {<br>		guard lhs else {<br>			return .failed<br>		}<br>		return rhs()<br>	}<br></p><p>And then transform this:<br></p><p>	guard<br>		x == 0 &amp;&amp; a == b &amp;&amp; c == d &amp;&amp;<br>		let y = optional, w = optional2, v = optional 3 &amp;&amp;<br>		z == 2<br>	else { ... }<br></p><p>Into something like this (where `?` is a sort of &quot;anonymous capture slot&quot;):<br></p><p>	guard case let .success (y, w, v) = (<br>		x == 0 &amp;&amp; a == b &amp;&amp; c == d &amp;&amp;<br>		Pattern(.some(?), .some(?), .some(?)).result(ofMatchingAgainst: (optional, optional2, optional3)) &amp;&amp;<br>		z == 2<br>	)<br>	else { ... }<br></p><p>Resolving to:<br></p><p>	guard case let PatternMatchingResult.success (y, w, v) = (<br>		(&amp;&amp;)(	// (Boolean, PatternMatchingResult) -&gt; PatternMatchingResult<br>			x == 0,<br>			(&amp;&amp;)( 	// (Boolean, PatternMatchingResult) -&gt; PatternMatchingResult<br>				a == b,<br>				(&amp;&amp;)(	// (Boolean, PatternMatchingResult) -&gt; PatternMatchingResult<br>					c == d,<br>					(&amp;&amp;)(	// (PatternMatchingResult, Boolean) -&gt; PatternMatchingResult<br>						Pattern(.some(?), .some(?), .some(?)).result(ofMatchingAgainst: (optional, optional2, optional3)),<br>						z == 2<br>					)<br>				)<br>			)<br>		)<br>	)<br>	else { ... }<br></p><p>The `Pattern` type shown here is notional, not an actual thing that would exist as a first-class entity—although that *would* be rather nice to have eventually...<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>May 28, 2016 at 10:00:00am</p></header><div class="content"><p>Yet another alternative: would it be possible to disallow commas as variable declaration separators and use them for condition clause separators again:<br></p><p>let a = 4, b = 8 // becomes illegal and requires to separate them on two lines<br></p><p>if a &gt; 4, let c = foo(), let d = bar(), c != d { // now comma is not ambiguous anymore<br>}<br></p><p>David.<br></p><p>&gt; On 28 May 2016, at 08:25, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Let me answer in another way that speaks to my background which isn&#39;t in compiler theory: The use of &amp;&amp; may produce cognitive overload between the use in Boolean assertions and the use in separating condition clauses.<br>&gt; <br>&gt; Yes, which is quite intentional on my part. The `if` statement requires that all of its clauses succeed; if pattern matching and optional testing were boolean expressions, you would use `&amp;&amp;` to link them with each other and with boolean tests. The fact that these are *not* boolean expressions is a mere artifact of Swift&#39;s implementation.<br>&gt; <br>&gt; I think our best solution is to make Swift act as though these *are* boolean expressions, but ones that can only be used in a limited way: they can only be `&amp;&amp;`ed, because they bind variables that have to be made available in specific blocks. In other words, I think we should paper over the compiler limitations preventing these things from working as expected.<br>&gt; <br>&gt; (Actually, it might be interesting to allow `!let` and `!case` statements which are available in the `else` branches of the control structures they&#39;re used in, but that&#39;s a different story...)<br>&gt; <br>&gt; ***<br>&gt; <br>&gt; If you&#39;ll permit me to go sort of &quot;mad dream&quot; here for a moment, I can actually sort of see a way to do a lot of this in the standard library. Imagine if the `let` and `case` clauses in a conditional produced a type like this:<br>&gt; <br>&gt; 	enum PatternMatchingResult&lt;BoundValues&gt; {<br>&gt; 		case failed<br>&gt; 		case succeeded (BoundValues)<br>&gt; 	}<br>&gt; <br>&gt; `BoundValues` would be the values, if any, extracted through the pattern matching operation. Then you could define operators like these:<br>&gt; <br>&gt; 	func &amp;&amp; &lt;T, U&gt;(lhs: PatternMatchingResult&lt;T&gt;, rhs: @autoclosure () -&gt; PatternMatchingResult&lt;U&gt;) -&gt; PatternMatchingResult&lt;(T, U)&gt; {<br>&gt; 		guard case .succeeded (let lhsValue) = lhs else {<br>&gt; 			return .failed<br>&gt; 		}<br>&gt; 		guard case .succeeded (let rhsValue) = rhs() else {<br>&gt; 			return .failed<br>&gt; 		}<br>&gt; 		return .succeeded (lhsValue, rhsValue)<br>&gt; 	}<br>&gt; <br>&gt; 	func &amp;&amp; &lt;T&gt;(lhs: PatternMatchingResult&lt;T&gt;, rhs: @autoclosure () -&gt; Boolean) -&gt; PatternMatchingResult&lt;T&gt; {<br>&gt; 		guard case .succeeded = lhs else {<br>&gt; 			return .failed<br>&gt; 		}<br>&gt; 		guard rhs() else {<br>&gt; 			return .failed<br>&gt; 		}<br>&gt; 		return lhs<br>&gt; 	}<br>&gt; 	<br>&gt; 	func &amp;&amp; &lt;U&gt;(lhs: Boolean, rhs: @autoclosure () -&gt; PatternMatchingResult&lt;U&gt;) -&gt; PatternMatchingResult&lt;U&gt; {<br>&gt; 		guard lhs else {<br>&gt; 			return .failed<br>&gt; 		}<br>&gt; 		return rhs()<br>&gt; 	}<br>&gt; <br>&gt; And then transform this:<br>&gt; <br>&gt; 	guard<br>&gt; 		x == 0 &amp;&amp; a == b &amp;&amp; c == d &amp;&amp;<br>&gt; 		let y = optional, w = optional2, v = optional 3 &amp;&amp;<br>&gt; 		z == 2<br>&gt; 	else { ... }<br>&gt; <br>&gt; Into something like this (where `?` is a sort of &quot;anonymous capture slot&quot;):<br>&gt; <br>&gt; 	guard case let .success (y, w, v) = (<br>&gt; 		x == 0 &amp;&amp; a == b &amp;&amp; c == d &amp;&amp;<br>&gt; 		Pattern(.some(?), .some(?), .some(?)).result(ofMatchingAgainst: (optional, optional2, optional3)) &amp;&amp;<br>&gt; 		z == 2<br>&gt; 	)<br>&gt; 	else { ... }<br>&gt; <br>&gt; Resolving to:<br>&gt; <br>&gt; 	guard case let PatternMatchingResult.success (y, w, v) = (<br>&gt; 		(&amp;&amp;)(	// (Boolean, PatternMatchingResult) -&gt; PatternMatchingResult<br>&gt; 			x == 0,<br>&gt; 			(&amp;&amp;)( 	// (Boolean, PatternMatchingResult) -&gt; PatternMatchingResult<br>&gt; 				a == b,<br>&gt; 				(&amp;&amp;)(	// (Boolean, PatternMatchingResult) -&gt; PatternMatchingResult<br>&gt; 					c == d,<br>&gt; 					(&amp;&amp;)(	// (PatternMatchingResult, Boolean) -&gt; PatternMatchingResult<br>&gt; 						Pattern(.some(?), .some(?), .some(?)).result(ofMatchingAgainst: (optional, optional2, optional3)),<br>&gt; 						z == 2<br>&gt; 					)<br>&gt; 				)<br>&gt; 			)<br>&gt; 		)<br>&gt; 	)<br>&gt; 	else { ... }<br>&gt; <br>&gt; The `Pattern` type shown here is notional, not an actual thing that would exist as a first-class entity—although that *would* be rather nice to have eventually...<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>May 28, 2016 at 09:00:00am</p></header><div class="content"><p>This I would not cry about. In other languages they are more of a source of pain than anything else.<br></p><p>Sent from my iPhone<br></p><p>&gt; On 28 May 2016, at 09:10, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Yet another alternative: would it be possible to disallow commas as variable declaration separators and use them for condition clause separators again:<br>&gt; <br>&gt; let a = 4, b = 8 // becomes illegal and requires to separate them on two lines<br>&gt; <br>&gt; if a &gt; 4, let c = foo(), let d = bar(), c != d { // now comma is not ambiguous anymore<br>&gt; }<br>&gt; <br>&gt; David.<br>&gt; <br>&gt;&gt;&gt; On 28 May 2016, at 08:25, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Let me answer in another way that speaks to my background which isn&#39;t in compiler theory: The use of &amp;&amp; may produce cognitive overload between the use in Boolean assertions and the use in separating condition clauses.<br>&gt;&gt; <br>&gt;&gt; Yes, which is quite intentional on my part. The `if` statement requires that all of its clauses succeed; if pattern matching and optional testing were boolean expressions, you would use `&amp;&amp;` to link them with each other and with boolean tests. The fact that these are *not* boolean expressions is a mere artifact of Swift&#39;s implementation.<br>&gt;&gt; <br>&gt;&gt; I think our best solution is to make Swift act as though these *are* boolean expressions, but ones that can only be used in a limited way: they can only be `&amp;&amp;`ed, because they bind variables that have to be made available in specific blocks. In other words, I think we should paper over the compiler limitations preventing these things from working as expected.<br>&gt;&gt; <br>&gt;&gt; (Actually, it might be interesting to allow `!let` and `!case` statements which are available in the `else` branches of the control structures they&#39;re used in, but that&#39;s a different story...)<br>&gt;&gt; <br>&gt;&gt; ***<br>&gt;&gt; <br>&gt;&gt; If you&#39;ll permit me to go sort of &quot;mad dream&quot; here for a moment, I can actually sort of see a way to do a lot of this in the standard library. Imagine if the `let` and `case` clauses in a conditional produced a type like this:<br>&gt;&gt; <br>&gt;&gt;    enum PatternMatchingResult&lt;BoundValues&gt; {<br>&gt;&gt;        case failed<br>&gt;&gt;        case succeeded (BoundValues)<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; `BoundValues` would be the values, if any, extracted through the pattern matching operation. Then you could define operators like these:<br>&gt;&gt; <br>&gt;&gt;    func &amp;&amp; &lt;T, U&gt;(lhs: PatternMatchingResult&lt;T&gt;, rhs: @autoclosure () -&gt; PatternMatchingResult&lt;U&gt;) -&gt; PatternMatchingResult&lt;(T, U)&gt; {<br>&gt;&gt;        guard case .succeeded (let lhsValue) = lhs else {<br>&gt;&gt;            return .failed<br>&gt;&gt;        }<br>&gt;&gt;        guard case .succeeded (let rhsValue) = rhs() else {<br>&gt;&gt;            return .failed<br>&gt;&gt;        }<br>&gt;&gt;        return .succeeded (lhsValue, rhsValue)<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;    func &amp;&amp; &lt;T&gt;(lhs: PatternMatchingResult&lt;T&gt;, rhs: @autoclosure () -&gt; Boolean) -&gt; PatternMatchingResult&lt;T&gt; {<br>&gt;&gt;        guard case .succeeded = lhs else {<br>&gt;&gt;            return .failed<br>&gt;&gt;        }<br>&gt;&gt;        guard rhs() else {<br>&gt;&gt;            return .failed<br>&gt;&gt;        }<br>&gt;&gt;        return lhs<br>&gt;&gt;    }<br>&gt;&gt;    <br>&gt;&gt;    func &amp;&amp; &lt;U&gt;(lhs: Boolean, rhs: @autoclosure () -&gt; PatternMatchingResult&lt;U&gt;) -&gt; PatternMatchingResult&lt;U&gt; {<br>&gt;&gt;        guard lhs else {<br>&gt;&gt;            return .failed<br>&gt;&gt;        }<br>&gt;&gt;        return rhs()<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; And then transform this:<br>&gt;&gt; <br>&gt;&gt;    guard<br>&gt;&gt;        x == 0 &amp;&amp; a == b &amp;&amp; c == d &amp;&amp;<br>&gt;&gt;        let y = optional, w = optional2, v = optional 3 &amp;&amp;<br>&gt;&gt;        z == 2<br>&gt;&gt;    else { ... }<br>&gt;&gt; <br>&gt;&gt; Into something like this (where `?` is a sort of &quot;anonymous capture slot&quot;):<br>&gt;&gt; <br>&gt;&gt;    guard case let .success (y, w, v) = (<br>&gt;&gt;        x == 0 &amp;&amp; a == b &amp;&amp; c == d &amp;&amp;<br>&gt;&gt;        Pattern(.some(?), .some(?), .some(?)).result(ofMatchingAgainst: (optional, optional2, optional3)) &amp;&amp;<br>&gt;&gt;        z == 2<br>&gt;&gt;    )<br>&gt;&gt;    else { ... }<br>&gt;&gt; <br>&gt;&gt; Resolving to:<br>&gt;&gt; <br>&gt;&gt;    guard case let PatternMatchingResult.success (y, w, v) = (<br>&gt;&gt;        (&amp;&amp;)(    // (Boolean, PatternMatchingResult) -&gt; PatternMatchingResult<br>&gt;&gt;            x == 0,<br>&gt;&gt;            (&amp;&amp;)(    // (Boolean, PatternMatchingResult) -&gt; PatternMatchingResult<br>&gt;&gt;                a == b,<br>&gt;&gt;                (&amp;&amp;)(    // (Boolean, PatternMatchingResult) -&gt; PatternMatchingResult<br>&gt;&gt;                    c == d,<br>&gt;&gt;                    (&amp;&amp;)(    // (PatternMatchingResult, Boolean) -&gt; PatternMatchingResult<br>&gt;&gt;                        Pattern(.some(?), .some(?), .some(?)).result(ofMatchingAgainst: (optional, optional2, optional3)),<br>&gt;&gt;                        z == 2<br>&gt;&gt;                    )<br>&gt;&gt;                )<br>&gt;&gt;            )<br>&gt;&gt;        )<br>&gt;&gt;    )<br>&gt;&gt;    else { ... }<br>&gt;&gt; <br>&gt;&gt; The `Pattern` type shown here is notional, not an actual thing that would exist as a first-class entity—although that *would* be rather nice to have eventually...<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May 28, 2016 at 01:00:00pm</p></header><div class="content"><p>Perhaps, but it is a much bigger change and a different proposal topic<br>entirely. Given how variable declarations work now, Erica&#39;s proposed syntax<br>to replace where clauses is the most elegant solution, IMO.<br></p><p>On Sat, May 28, 2016 at 04:15 Goffredo Marocchi via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; This I would not cry about. In other languages they are more of a source<br>&gt; of pain than anything else.<br>&gt;<br>&gt; Sent from my iPhone<br>&gt;<br>&gt; &gt; On 28 May 2016, at 09:10, David Hart via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Yet another alternative: would it be possible to disallow commas as<br>&gt; variable declaration separators and use them for condition clause<br>&gt; separators again:<br>&gt; &gt;<br>&gt; &gt; let a = 4, b = 8 // becomes illegal and requires to separate them on two<br>&gt; lines<br>&gt; &gt;<br>&gt; &gt; if a &gt; 4, let c = foo(), let d = bar(), c != d { // now comma is not<br>&gt; ambiguous anymore<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; David.<br>&gt; &gt;<br>&gt; &gt;&gt;&gt; On 28 May 2016, at 08:25, Brent Royal-Gordon via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Let me answer in another way that speaks to my background which isn&#39;t<br>&gt; in compiler theory: The use of &amp;&amp; may produce cognitive overload between<br>&gt; the use in Boolean assertions and the use in separating condition clauses.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Yes, which is quite intentional on my part. The `if` statement requires<br>&gt; that all of its clauses succeed; if pattern matching and optional testing<br>&gt; were boolean expressions, you would use `&amp;&amp;` to link them with each other<br>&gt; and with boolean tests. The fact that these are *not* boolean expressions<br>&gt; is a mere artifact of Swift&#39;s implementation.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I think our best solution is to make Swift act as though these *are*<br>&gt; boolean expressions, but ones that can only be used in a limited way: they<br>&gt; can only be `&amp;&amp;`ed, because they bind variables that have to be made<br>&gt; available in specific blocks. In other words, I think we should paper over<br>&gt; the compiler limitations preventing these things from working as expected.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; (Actually, it might be interesting to allow `!let` and `!case`<br>&gt; statements which are available in the `else` branches of the control<br>&gt; structures they&#39;re used in, but that&#39;s a different story...)<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; ***<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; If you&#39;ll permit me to go sort of &quot;mad dream&quot; here for a moment, I can<br>&gt; actually sort of see a way to do a lot of this in the standard library.<br>&gt; Imagine if the `let` and `case` clauses in a conditional produced a type<br>&gt; like this:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;    enum PatternMatchingResult&lt;BoundValues&gt; {<br>&gt; &gt;&gt;        case failed<br>&gt; &gt;&gt;        case succeeded (BoundValues)<br>&gt; &gt;&gt;    }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; `BoundValues` would be the values, if any, extracted through the<br>&gt; pattern matching operation. Then you could define operators like these:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;    func &amp;&amp; &lt;T, U&gt;(lhs: PatternMatchingResult&lt;T&gt;, rhs: @autoclosure ()<br>&gt; -&gt; PatternMatchingResult&lt;U&gt;) -&gt; PatternMatchingResult&lt;(T, U)&gt; {<br>&gt; &gt;&gt;        guard case .succeeded (let lhsValue) = lhs else {<br>&gt; &gt;&gt;            return .failed<br>&gt; &gt;&gt;        }<br>&gt; &gt;&gt;        guard case .succeeded (let rhsValue) = rhs() else {<br>&gt; &gt;&gt;            return .failed<br>&gt; &gt;&gt;        }<br>&gt; &gt;&gt;        return .succeeded (lhsValue, rhsValue)<br>&gt; &gt;&gt;    }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;    func &amp;&amp; &lt;T&gt;(lhs: PatternMatchingResult&lt;T&gt;, rhs: @autoclosure () -&gt;<br>&gt; Boolean) -&gt; PatternMatchingResult&lt;T&gt; {<br>&gt; &gt;&gt;        guard case .succeeded = lhs else {<br>&gt; &gt;&gt;            return .failed<br>&gt; &gt;&gt;        }<br>&gt; &gt;&gt;        guard rhs() else {<br>&gt; &gt;&gt;            return .failed<br>&gt; &gt;&gt;        }<br>&gt; &gt;&gt;        return lhs<br>&gt; &gt;&gt;    }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;    func &amp;&amp; &lt;U&gt;(lhs: Boolean, rhs: @autoclosure () -&gt;<br>&gt; PatternMatchingResult&lt;U&gt;) -&gt; PatternMatchingResult&lt;U&gt; {<br>&gt; &gt;&gt;        guard lhs else {<br>&gt; &gt;&gt;            return .failed<br>&gt; &gt;&gt;        }<br>&gt; &gt;&gt;        return rhs()<br>&gt; &gt;&gt;    }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; And then transform this:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;    guard<br>&gt; &gt;&gt;        x == 0 &amp;&amp; a == b &amp;&amp; c == d &amp;&amp;<br>&gt; &gt;&gt;        let y = optional, w = optional2, v = optional 3 &amp;&amp;<br>&gt; &gt;&gt;        z == 2<br>&gt; &gt;&gt;    else { ... }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Into something like this (where `?` is a sort of &quot;anonymous capture<br>&gt; slot&quot;):<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;    guard case let .success (y, w, v) = (<br>&gt; &gt;&gt;        x == 0 &amp;&amp; a == b &amp;&amp; c == d &amp;&amp;<br>&gt; &gt;&gt;        Pattern(.some(?), .some(?), .some(?)).result(ofMatchingAgainst:<br>&gt; (optional, optional2, optional3)) &amp;&amp;<br>&gt; &gt;&gt;        z == 2<br>&gt; &gt;&gt;    )<br>&gt; &gt;&gt;    else { ... }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Resolving to:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;    guard case let PatternMatchingResult.success (y, w, v) = (<br>&gt; &gt;&gt;        (&amp;&amp;)(    // (Boolean, PatternMatchingResult) -&gt;<br>&gt; PatternMatchingResult<br>&gt; &gt;&gt;            x == 0,<br>&gt; &gt;&gt;            (&amp;&amp;)(    // (Boolean, PatternMatchingResult) -&gt;<br>&gt; PatternMatchingResult<br>&gt; &gt;&gt;                a == b,<br>&gt; &gt;&gt;                (&amp;&amp;)(    // (Boolean, PatternMatchingResult) -&gt;<br>&gt; PatternMatchingResult<br>&gt; &gt;&gt;                    c == d,<br>&gt; &gt;&gt;                    (&amp;&amp;)(    // (PatternMatchingResult, Boolean) -&gt;<br>&gt; PatternMatchingResult<br>&gt; &gt;&gt;                        Pattern(.some(?), .some(?),<br>&gt; .some(?)).result(ofMatchingAgainst: (optional, optional2, optional3)),<br>&gt; &gt;&gt;                        z == 2<br>&gt; &gt;&gt;                    )<br>&gt; &gt;&gt;                )<br>&gt; &gt;&gt;            )<br>&gt; &gt;&gt;        )<br>&gt; &gt;&gt;    )<br>&gt; &gt;&gt;    else { ... }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; The `Pattern` type shown here is notional, not an actual thing that<br>&gt; would exist as a first-class entity—although that *would* be rather nice to<br>&gt; have eventually...<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; --<br>&gt; &gt;&gt; Brent Royal-Gordon<br>&gt; &gt;&gt; Architechies<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160528/27da2b40/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 28, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On May 28, 2016, at 1:10 AM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Yet another alternative: would it be possible to disallow commas as variable declaration separators and use them for condition clause separators again:<br>&gt; <br>&gt; let a = 4, b = 8 // becomes illegal and requires to separate them on two lines<br>&gt; <br>&gt; if a &gt; 4, let c = foo(), let d = bar(), c != d { // now comma is not ambiguous anymore<br>&gt; }<br></p><p>The ambiguity is between “case” and “let” conditions, specifically because “case” takes a pattern, and “let” is a valid pattern:<br></p><p>guard (pattern1) = expr1, let x = expr2 else<br></p><p>can be:<br></p><p>guard (pattern1) = expr1, let (x) = expr2 else<br></p><p>or:<br></p><p>guard (pattern1) = expr1, (let x) = expr2 else<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 28, 2016 at 09:00:00pm</p></header><div class="content"><p>What about requiring `let` before each binding and `case` before each pattern?<br></p><p>guard case let x = a, case let y = b, let z = c, x == y else { … }<br></p><p>Now `let z = c` can only be a let-binding and not a pattern matching clause.<br></p><p>-Thorsten<br></p><p><br>&gt; Am 28.05.2016 um 19:32 schrieb Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; On May 28, 2016, at 1:10 AM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Yet another alternative: would it be possible to disallow commas as variable declaration separators and use them for condition clause separators again:<br>&gt;&gt; <br>&gt;&gt; let a = 4, b = 8 // becomes illegal and requires to separate them on two lines<br>&gt;&gt; <br>&gt;&gt; if a &gt; 4, let c = foo(), let d = bar(), c != d { // now comma is not ambiguous anymore<br>&gt;&gt; }<br>&gt; <br>&gt; The ambiguity is between “case” and “let” conditions, specifically because “case” takes a pattern, and “let” is a valid pattern:<br>&gt; <br>&gt; guard (pattern1) = expr1, let x = expr2 else<br>&gt; <br>&gt; can be:<br>&gt; <br>&gt; guard (pattern1) = expr1, let (x) = expr2 else<br>&gt; <br>&gt; or:<br>&gt; <br>&gt; guard (pattern1) = expr1, (let x) = expr2 else<br>&gt; <br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 28, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On May 28, 2016, at 12:07 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; What about requiring `let` before each binding and `case` before each pattern?<br>&gt; <br>&gt; guard case let x = a, case let y = b, let z = c, x == y else { … }<br>&gt; <br>&gt; Now `let z = c` can only be a let-binding and not a pattern matching clause.<br></p><p>Yes, that would be enough to solve the ambiguity.  The problem with that is that it eliminates a commonality with var/let declarations, which can declare multiple variables.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 29, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; Am 28.05.2016 um 22:35 schrieb Chris Lattner &lt;clattner at apple.com&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; On May 28, 2016, at 12:07 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; What about requiring `let` before each binding and `case` before each pattern?<br>&gt;&gt; <br>&gt;&gt; guard case let x = a, case let y = b, let z = c, x == y else { … }<br>&gt;&gt; <br>&gt;&gt; Now `let z = c` can only be a let-binding and not a pattern matching clause.<br>&gt; <br>&gt; Yes, that would be enough to solve the ambiguity.  The problem with that is that it eliminates a commonality with var/let declarations, which can declare multiple variables.<br></p><p>var/let declarations are sufficiently different from let-bindings IMO that this commonality could be dropped.<br></p><p>-Thorsten<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 31, 2016 at 06:00:00am</p></header><div class="content"><p>&gt; Am 29.05.2016 um 17:11 schrieb Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; Am 28.05.2016 um 22:35 schrieb Chris Lattner &lt;clattner at apple.com&gt;:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 28, 2016, at 12:07 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What about requiring `let` before each binding and `case` before each pattern?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; guard case let x = a, case let y = b, let z = c, x == y else { … }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Now `let z = c` can only be a let-binding and not a pattern matching clause.<br>&gt;&gt; <br>&gt;&gt; Yes, that would be enough to solve the ambiguity.  The problem with that is that it eliminates a commonality with var/let declarations, which can declare multiple variables.<br>&gt; <br>&gt; var/let declarations are sufficiently different from let-bindings IMO that this commonality could be dropped.<br></p><p>In addition the proposal would result in eliminating a commonality of `case` clauses allowing a `where` clause everywhere except in conditional clauses which is worse.<br>I&#39;d much rather prefer to drop the commonality with var/let declarations!<br></p><p>-Thorsten<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May 31, 2016 at 05:00:00am</p></header><div class="content"><p>Of course, an alternative is to eliminate `where` for all uses of `case` as<br>well.<br>On Mon, May 30, 2016 at 11:55 PM Thorsten Seitz via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; Am 29.05.2016 um 17:11 schrieb Thorsten Seitz via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; Am 28.05.2016 um 22:35 schrieb Chris Lattner &lt;clattner at apple.com&gt;:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On May 28, 2016, at 12:07 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt;<br>&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; What about requiring `let` before each binding and `case` before each<br>&gt; pattern?<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; guard case let x = a, case let y = b, let z = c, x == y else { … }<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Now `let z = c` can only be a let-binding and not a pattern matching<br>&gt; clause.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Yes, that would be enough to solve the ambiguity.  The problem with<br>&gt; that is that it eliminates a commonality with var/let declarations, which<br>&gt; can declare multiple variables.<br>&gt; &gt;<br>&gt; &gt; var/let declarations are sufficiently different from let-bindings IMO<br>&gt; that this commonality could be dropped.<br>&gt;<br>&gt; In addition the proposal would result in eliminating a commonality of<br>&gt; `case` clauses allowing a `where` clause everywhere except in conditional<br>&gt; clauses which is worse.<br>&gt; I&#39;d much rather prefer to drop the commonality with var/let declarations!<br>&gt;<br>&gt; -Thorsten<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/ea030049/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 31, 2016 at 05:00:00pm</p></header><div class="content"><p>Like some others on this list I prefer the `where` because it stands out and therefore increases readability by visually separating semantically different clauses.<br></p><p>-Thorsten <br></p><p>&gt; Am 31.05.2016 um 07:10 schrieb Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt;:<br>&gt; <br>&gt; Of course, an alternative is to eliminate `where` for all uses of `case` as well.<br>&gt;&gt; On Mon, May 30, 2016 at 11:55 PM Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt; Am 29.05.2016 um 17:11 schrieb Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; Am 28.05.2016 um 22:35 schrieb Chris Lattner &lt;clattner at apple.com&gt;:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; On May 28, 2016, at 12:07 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; What about requiring `let` before each binding and `case` before each pattern?<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; guard case let x = a, case let y = b, let z = c, x == y else { … }<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Now `let z = c` can only be a let-binding and not a pattern matching clause.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Yes, that would be enough to solve the ambiguity.  The problem with that is that it eliminates a commonality with var/let declarations, which can declare multiple variables.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; var/let declarations are sufficiently different from let-bindings IMO that this commonality could be dropped.<br>&gt;&gt; <br>&gt;&gt; In addition the proposal would result in eliminating a commonality of `case` clauses allowing a `where` clause everywhere except in conditional clauses which is worse.<br>&gt;&gt; I&#39;d much rather prefer to drop the commonality with var/let declarations!<br>&gt;&gt; <br>&gt;&gt; -Thorsten<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/d855bbef/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>May 31, 2016 at 04:00:00pm</p></header><div class="content"><p>Returning to the list after a brutally busy spring, a demi-review:<br></p><p>I vote…<br></p><p>+1 on addressing this problem,<br>+1 on the proposal’s structural approach (list of items which may be either boolean tests or bindings, in any order), and<br>+1 on eliminating “where” in the presence of a better approach,<br></p><p>…but am ambivalent about the semicolon. Hereafter follows a slushy reflection on my deepest inner thoughts and feelings about syntax.<br></p><p>The logic behind the semicolon makes perfect sense, but my initial gut reaction agrees with others who say it just isn’t pleasant to read. I spent some time fiddling with places in my code where I’ve used “if … where” and tried the proposed syntax instead. It feels … off.<br></p><p>Commas in the same spots feel better somehow. I spent some time reflecting on why this might be, and I think it’s just that my brain is so strongly trained to parse the semicolon as a statement separator. IOW, my mental hierarchy is this:<br></p><p>	expression<br>	comma<br>	statement<br>	semicolon ←<br></p><p>…(and this is intuitively true for me despite the C-style for loop), but the proposal asks us to read this way instead:<br></p><p>	expression<br>	comma<br>	semicolon ←<br>	statement<br></p><p>In particular, my years of C trained me to spot this mistake:<br></p><p>	if(foo &lt; bar);<br>	    oopsThisAlwaysExecutes();<br></p><p>…and seeing that semicolon on the same line as the “if” in Swift triggers that deeply conditioned alarm bell. Then again, “if let” and “if case” have always felt weirdly wrong to me as well, and I eventually got used to them. I’d probably get used to this proposed syntax as well.<br></p><p>The line breaks look better than semicolons, but suffer a bit from the same “statement boundary” brain retraining problem.<br></p><p>Somebody proposed &amp;&amp; (Brent maybe?). I tried it out too. It’s surprisingly pleasant to read, but makes it look like I should be able to arbitrarily embed bindings deep in expressions in ways that would open hideous cans of worms:<br></p><p>    if let foo = bar &amp;&amp; barTest(foo) || let foo = baz &amp;&amp; bazTest(foo) {<br>        // Is foo defined here? What is its type? Yikes!<br>    }<br></p><p>Communicating that the top-level separator in a condition clause is not just another boolean operator does seem important.<br></p><p>Bottom line: the proposal addresses a real problem, and the proposed solution is an improvement. If the choice is either current syntax or SE-0099, I vote for SE-0099. I have a nagging feeling there’s a better third choice out there somewhere. If there isn’t, then I’ll take SE-0099.<br></p><p>Cheers,<br></p><p>Paul<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e7e554db1f80d7d6041d92edd5145698?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Hooman Mehr</string> &lt;hooman at mac.com&gt;<p>May 31, 2016 at 03:00:00pm</p></header><div class="content"><p>Exactly what I feel about this. <br></p><p>I am prepared to go as far as disallowing:<br></p><p>let x = optionalX, y = optionalY <br></p><p>syntax to free up comma for use instead of semicolon. Then the above becomes:<br></p><p>let x = optionalX, let y = optionalY<br></p><p>In this case we will keep the comma at the end of the line as well.<br></p><p><br>&gt; On May 31, 2016, at 2:25 PM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Returning to the list after a brutally busy spring, a demi-review:<br>&gt; <br>&gt; I vote…<br>&gt; <br>&gt; +1 on addressing this problem,<br>&gt; +1 on the proposal’s structural approach (list of items which may be either boolean tests or bindings, in any order), and<br>&gt; +1 on eliminating “where” in the presence of a better approach,<br>&gt; <br>&gt; …but am ambivalent about the semicolon. Hereafter follows a slushy reflection on my deepest inner thoughts and feelings about syntax.<br>&gt; <br>&gt; The logic behind the semicolon makes perfect sense, but my initial gut reaction agrees with others who say it just isn’t pleasant to read. I spent some time fiddling with places in my code where I’ve used “if … where” and tried the proposed syntax instead. It feels … off.<br>&gt; <br>&gt; Commas in the same spots feel better somehow. I spent some time reflecting on why this might be, and I think it’s just that my brain is so strongly trained to parse the semicolon as a statement separator. IOW, my mental hierarchy is this:<br>&gt; <br>&gt; 	expression<br>&gt; 	comma<br>&gt; 	statement<br>&gt; 	semicolon ←<br>&gt; <br>&gt; …(and this is intuitively true for me despite the C-style for loop), but the proposal asks us to read this way instead:<br>&gt; <br>&gt; 	expression<br>&gt; 	comma<br>&gt; 	semicolon ←<br>&gt; 	statement<br>&gt; <br>&gt; In particular, my years of C trained me to spot this mistake:<br>&gt; <br>&gt; 	if(foo &lt; bar);<br>&gt; 	    oopsThisAlwaysExecutes();<br>&gt; <br>&gt; …and seeing that semicolon on the same line as the “if” in Swift triggers that deeply conditioned alarm bell. Then again, “if let” and “if case” have always felt weirdly wrong to me as well, and I eventually got used to them. I’d probably get used to this proposed syntax as well.<br>&gt; <br>&gt; The line breaks look better than semicolons, but suffer a bit from the same “statement boundary” brain retraining problem.<br>&gt; <br>&gt; Somebody proposed &amp;&amp; (Brent maybe?). I tried it out too. It’s surprisingly pleasant to read, but makes it look like I should be able to arbitrarily embed bindings deep in expressions in ways that would open hideous cans of worms:<br>&gt; <br>&gt;    if let foo = bar &amp;&amp; barTest(foo) || let foo = baz &amp;&amp; bazTest(foo) {<br>&gt;        // Is foo defined here? What is its type? Yikes!<br>&gt;    }<br>&gt; <br>&gt; Communicating that the top-level separator in a condition clause is not just another boolean operator does seem important.<br>&gt; <br>&gt; Bottom line: the proposal addresses a real problem, and the proposed solution is an improvement. If the choice is either current syntax or SE-0099, I vote for SE-0099. I have a nagging feeling there’s a better third choice out there somewhere. If there isn’t, then I’ll take SE-0099.<br>&gt; <br>&gt; Cheers,<br>&gt; <br>&gt; Paul<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/81382f2a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>May 31, 2016 at 05:00:00pm</p></header><div class="content"><p>I certainly am warm to that myself, although I’m also sympathetic to what Chris wrote about the inconsistency it introduces:<br></p><p>    let x = optionalX!, y = optionalY!  // Works!<br>    doStuff(x, y)<br></p><p>    if let x = optionalX, y = optionalY {  // Doesn’t work. Confusion!<br>        doStuff(x, y)<br>    }<br></p><p>Also, eliminating the repeated “let” in a big list of conditional bindings is a common practice:<br></p><p>    if let firstName = json[&quot;first_name&quot;],<br>           lastName = json[&quot;last_name&quot;],<br>           street = json[&quot;street&quot;],<br>           state = json[&quot;state&quot;],<br>           zip = json[&quot;zip_code&quot;] {<br>        ...       <br>    }<br></p><p>…and some style guides even go out of their way to recommend this over the repeated “let.” Popular feature, so I’d be hesitant to nix it.<br></p><p>P<br></p><p>&gt; On May 31, 2016, at 5:04 PM, Hooman Mehr &lt;hooman at mac.com&gt; wrote:<br>&gt; <br>&gt; Exactly what I feel about this. <br>&gt; <br>&gt; I am prepared to go as far as disallowing:<br>&gt; <br>&gt; let x = optionalX, y = optionalY <br>&gt; <br>&gt; syntax to free up comma for use instead of semicolon. Then the above becomes:<br>&gt; <br>&gt; let x = optionalX, let y = optionalY<br>&gt; <br>&gt; In this case we will keep the comma at the end of the line as well.<br>&gt; <br>&gt; <br>&gt;&gt; On May 31, 2016, at 2:25 PM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Returning to the list after a brutally busy spring, a demi-review:<br>&gt;&gt; <br>&gt;&gt; I vote…<br>&gt;&gt; <br>&gt;&gt; +1 on addressing this problem,<br>&gt;&gt; +1 on the proposal’s structural approach (list of items which may be either boolean tests or bindings, in any order), and<br>&gt;&gt; +1 on eliminating “where” in the presence of a better approach,<br>&gt;&gt; <br>&gt;&gt; …but am ambivalent about the semicolon. Hereafter follows a slushy reflection on my deepest inner thoughts and feelings about syntax.<br>&gt;&gt; <br>&gt;&gt; The logic behind the semicolon makes perfect sense, but my initial gut reaction agrees with others who say it just isn’t pleasant to read. I spent some time fiddling with places in my code where I’ve used “if … where” and tried the proposed syntax instead. It feels … off.<br>&gt;&gt; <br>&gt;&gt; Commas in the same spots feel better somehow. I spent some time reflecting on why this might be, and I think it’s just that my brain is so strongly trained to parse the semicolon as a statement separator. IOW, my mental hierarchy is this:<br>&gt;&gt; <br>&gt;&gt; 	expression<br>&gt;&gt; 	comma<br>&gt;&gt; 	statement<br>&gt;&gt; 	semicolon ←<br>&gt;&gt; <br>&gt;&gt; …(and this is intuitively true for me despite the C-style for loop), but the proposal asks us to read this way instead:<br>&gt;&gt; <br>&gt;&gt; 	expression<br>&gt;&gt; 	comma<br>&gt;&gt; 	semicolon ←<br>&gt;&gt; 	statement<br>&gt;&gt; <br>&gt;&gt; In particular, my years of C trained me to spot this mistake:<br>&gt;&gt; <br>&gt;&gt; 	if(foo &lt; bar);<br>&gt;&gt; 	    oopsThisAlwaysExecutes();<br>&gt;&gt; <br>&gt;&gt; …and seeing that semicolon on the same line as the “if” in Swift triggers that deeply conditioned alarm bell. Then again, “if let” and “if case” have always felt weirdly wrong to me as well, and I eventually got used to them. I’d probably get used to this proposed syntax as well.<br>&gt;&gt; <br>&gt;&gt; The line breaks look better than semicolons, but suffer a bit from the same “statement boundary” brain retraining problem.<br>&gt;&gt; <br>&gt;&gt; Somebody proposed &amp;&amp; (Brent maybe?). I tried it out too. It’s surprisingly pleasant to read, but makes it look like I should be able to arbitrarily embed bindings deep in expressions in ways that would open hideous cans of worms:<br>&gt;&gt; <br>&gt;&gt;    if let foo = bar &amp;&amp; barTest(foo) || let foo = baz &amp;&amp; bazTest(foo) {<br>&gt;&gt;        // Is foo defined here? What is its type? Yikes!<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; Communicating that the top-level separator in a condition clause is not just another boolean operator does seem important.<br>&gt;&gt; <br>&gt;&gt; Bottom line: the proposal addresses a real problem, and the proposed solution is an improvement. If the choice is either current syntax or SE-0099, I vote for SE-0099. I have a nagging feeling there’s a better third choice out there somewhere. If there isn’t, then I’ll take SE-0099.<br>&gt;&gt; <br>&gt;&gt; Cheers,<br>&gt;&gt; <br>&gt;&gt; Paul<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/2a0da207/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>June  1, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; Am 01.06.2016 um 00:26 schrieb Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; I certainly am warm to that myself, although I’m also sympathetic to what Chris wrote about the inconsistency it introduces:<br>&gt; <br>&gt;     let x = optionalX!, y = optionalY!  // Works!<br>&gt;     doStuff(x, y)<br>&gt; <br>&gt;     if let x = optionalX, y = optionalY {  // Doesn’t work. Confusion!<br>&gt;         doStuff(x, y)<br>&gt;     }<br></p><p>I don&#39;t think that is so confusing. Much more confusing is that the let binding within the `if` statement is conditional!<br>So, in essence we are already looking at very different clauses and I&#39;d actually prefer if the conditional let binding would require explicit `let` for each binding just to emphasize that a conditional let binding is happening!<br>To fix any confusion between these I&#39;d rather change the syntax of the conditional let binding to something like `let x ?= x` or similar (which has been proposed quite a few times on this list already).<br>Worsening the syntax of conditionals instead is no option IMHO.<br></p><p>-Thorsten <br></p><p><br></p><p>&gt; <br>&gt; Also, eliminating the repeated “let” in a big list of conditional bindings is a common practice:<br>&gt; <br>&gt;     if let firstName = json[&quot;first_name&quot;],<br>&gt;            lastName = json[&quot;last_name&quot;],<br>&gt;            street = json[&quot;street&quot;],<br>&gt;            state = json[&quot;state&quot;],<br>&gt;            zip = json[&quot;zip_code&quot;] {<br>&gt;         ...       <br>&gt;     }<br>&gt; <br>&gt; …and some style guides even go out of their way to recommend this over the repeated “let.” Popular feature, so I’d be hesitant to nix it.<br>&gt; <br>&gt; P<br>&gt; <br>&gt;&gt; On May 31, 2016, at 5:04 PM, Hooman Mehr &lt;hooman at mac.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Exactly what I feel about this. <br>&gt;&gt; <br>&gt;&gt; I am prepared to go as far as disallowing:<br>&gt;&gt; <br>&gt;&gt; let x = optionalX, y = optionalY <br>&gt;&gt; <br>&gt;&gt; syntax to free up comma for use instead of semicolon. Then the above becomes:<br>&gt;&gt; <br>&gt;&gt; let x = optionalX, let y = optionalY<br>&gt;&gt; <br>&gt;&gt; In this case we will keep the comma at the end of the line as well.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 31, 2016, at 2:25 PM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Returning to the list after a brutally busy spring, a demi-review:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I vote…<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +1 on addressing this problem,<br>&gt;&gt;&gt; +1 on the proposal’s structural approach (list of items which may be either boolean tests or bindings, in any order), and<br>&gt;&gt;&gt; +1 on eliminating “where” in the presence of a better approach,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; …but am ambivalent about the semicolon. Hereafter follows a slushy reflection on my deepest inner thoughts and feelings about syntax.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The logic behind the semicolon makes perfect sense, but my initial gut reaction agrees with others who say it just isn’t pleasant to read. I spent some time fiddling with places in my code where I’ve used “if … where” and tried the proposed syntax instead. It feels … off.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Commas in the same spots feel better somehow. I spent some time reflecting on why this might be, and I think it’s just that my brain is so strongly trained to parse the semicolon as a statement separator. IOW, my mental hierarchy is this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	expression<br>&gt;&gt;&gt; 	comma<br>&gt;&gt;&gt; 	statement<br>&gt;&gt;&gt; 	semicolon ←<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; …(and this is intuitively true for me despite the C-style for loop), but the proposal asks us to read this way instead:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	expression<br>&gt;&gt;&gt; 	comma<br>&gt;&gt;&gt; 	semicolon ←<br>&gt;&gt;&gt; 	statement<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In particular, my years of C trained me to spot this mistake:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	if(foo &lt; bar);<br>&gt;&gt;&gt; 	    oopsThisAlwaysExecutes();<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; …and seeing that semicolon on the same line as the “if” in Swift triggers that deeply conditioned alarm bell. Then again, “if let” and “if case” have always felt weirdly wrong to me as well, and I eventually got used to them. I’d probably get used to this proposed syntax as well.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The line breaks look better than semicolons, but suffer a bit from the same “statement boundary” brain retraining problem.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Somebody proposed &amp;&amp; (Brent maybe?). I tried it out too. It’s surprisingly pleasant to read, but makes it look like I should be able to arbitrarily embed bindings deep in expressions in ways that would open hideous cans of worms:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    if let foo = bar &amp;&amp; barTest(foo) || let foo = baz &amp;&amp; bazTest(foo) {<br>&gt;&gt;&gt;        // Is foo defined here? What is its type? Yikes!<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Communicating that the top-level separator in a condition clause is not just another boolean operator does seem important.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Bottom line: the proposal addresses a real problem, and the proposed solution is an improvement. If the choice is either current syntax or SE-0099, I vote for SE-0099. I have a nagging feeling there’s a better third choice out there somewhere. If there isn’t, then I’ll take SE-0099.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Paul<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160601/0926ad00/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>June  1, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; To fix any confusion between these I&#39;d rather change the syntax of the<br> &gt; conditional let binding to something like `let x ?= x` or similar (which<br> &gt; has been proposed quite a few times on this list already).<br></p><p>FWIW, I also think `if let one = two` is not descriptive enough about what <br>is going here.. `if let one ?= two` or even `if let one = two!` will be <br>more clear for me : we are trying to unwrap and assign.<br></p><p>On 01.06.2016 19:46, Thorsten Seitz via swift-evolution wrote:<br>&gt;<br>&gt;<br>&gt; Am 01.06.2016 um 00:26 schrieb Paul Cantrell via swift-evolution<br>&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;<br>&gt;&gt; I certainly am warm to that myself, although I’m also sympathetic to what<br>&gt;&gt; Chris wrote about the inconsistency it introduces:<br>&gt;&gt;<br>&gt;&gt;     let x = optionalX!, y = optionalY!  // Works!<br>&gt;&gt;     doStuff(x, y)<br>&gt;&gt;<br>&gt;&gt;     if let x = optionalX, y = optionalY {  // Doesn’t work. Confusion!<br>&gt;&gt;         doStuff(x, y)<br>&gt;&gt;     }<br>&gt;<br>&gt; I don&#39;t think that is so confusing. Much more confusing is that the let<br>&gt; binding within the `if` statement is conditional!<br>&gt; So, in essence we are already looking at very different clauses and I&#39;d<br>&gt; actually prefer if the conditional let binding would require explicit `let`<br>&gt; for each binding just to emphasize that a conditional let binding is happening!<br>&gt; To fix any confusion between these I&#39;d rather change the syntax of the<br>&gt; conditional let binding to something like `let x ?= x` or similar (which<br>&gt; has been proposed quite a few times on this list already).<br>&gt; Worsening the syntax of conditionals instead is no option IMHO.<br>&gt;<br>&gt; -Thorsten<br>&gt;<br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt; Also, eliminating the repeated “let” in a big list of conditional<br>&gt;&gt; bindings is a common practice:<br>&gt;&gt;<br>&gt;&gt;     if let firstName = json[&quot;first_name&quot;],<br>&gt;&gt;            lastName = json[&quot;last_name&quot;],<br>&gt;&gt;            street = json[&quot;street&quot;],<br>&gt;&gt;            state = json[&quot;state&quot;],<br>&gt;&gt;            zip = json[&quot;zip_code&quot;] {<br>&gt;&gt;         ...<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt; …and some style guides even go out of their way to recommend this over<br>&gt;&gt; the repeated “let.” Popular feature, so I’d be hesitant to nix it.<br>&gt;&gt;<br>&gt;&gt; P<br>&gt;&gt;<br>&gt;&gt;&gt; On May 31, 2016, at 5:04 PM, Hooman Mehr &lt;hooman at mac.com<br>&gt;&gt;&gt; &lt;mailto:hooman at mac.com&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Exactly what I feel about this.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I am prepared to go as far as disallowing:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let x = optionalX, y = optionalY<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; syntax to free up comma for use instead of semicolon. Then the above<br>&gt;&gt;&gt; becomes:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let x = optionalX, *let* y = optionalY<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In this case we will keep the comma at the end of the line as well.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On May 31, 2016, at 2:25 PM, Paul Cantrell via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Returning to the list after a brutally busy spring, a demi-review:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I vote…<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; +1 on addressing this problem,<br>&gt;&gt;&gt;&gt; +1 on the proposal’s structural approach (list of items which may be<br>&gt;&gt;&gt;&gt; either boolean tests or bindings, in any order), and<br>&gt;&gt;&gt;&gt; +1 on eliminating “where” in the presence of a better approach,<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; …but am ambivalent about the semicolon. Hereafter follows a slushy<br>&gt;&gt;&gt;&gt; reflection on my deepest inner thoughts and feelings about syntax.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The logic behind the semicolon makes perfect sense, but my initial gut<br>&gt;&gt;&gt;&gt; reaction agrees with others who say it just isn’t pleasant to read. I<br>&gt;&gt;&gt;&gt; spent some time fiddling with places in my code where I’ve used “if …<br>&gt;&gt;&gt;&gt; where” and tried the proposed syntax instead. It feels … off.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Commas in the same spots feel better somehow. I spent some time<br>&gt;&gt;&gt;&gt; reflecting on why this might be, and I think it’s just that my brain is<br>&gt;&gt;&gt;&gt; so strongly trained to parse the semicolon as a statement separator.<br>&gt;&gt;&gt;&gt; IOW, my mental hierarchy is this:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; expression<br>&gt;&gt;&gt;&gt; comma<br>&gt;&gt;&gt;&gt; statement<br>&gt;&gt;&gt;&gt; semicolon ←<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; …(and this is intuitively true for me despite the C-style for loop),<br>&gt;&gt;&gt;&gt; but the proposal asks us to read this way instead:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; expression<br>&gt;&gt;&gt;&gt; comma<br>&gt;&gt;&gt;&gt; semicolon ←<br>&gt;&gt;&gt;&gt; statement<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; In particular, my years of C trained me to spot this mistake:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; if(foo &lt; bar);<br>&gt;&gt;&gt;&gt;    oopsThisAlwaysExecutes();<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; …and seeing that semicolon on the same line as the “if” in Swift<br>&gt;&gt;&gt;&gt; triggers that deeply conditioned alarm bell. Then again, “if let” and<br>&gt;&gt;&gt;&gt; “if case” have always felt weirdly wrong to me as well, and I<br>&gt;&gt;&gt;&gt; eventually got used to them. I’d probably get used to this proposed<br>&gt;&gt;&gt;&gt; syntax as well.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The line breaks look better than semicolons, but suffer a bit from the<br>&gt;&gt;&gt;&gt; same “statement boundary” brain retraining problem.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Somebody proposed &amp;&amp; (Brent maybe?). I tried it out too. It’s<br>&gt;&gt;&gt;&gt; surprisingly pleasant to read, but makes it look like I should be able<br>&gt;&gt;&gt;&gt; to arbitrarily embed bindings deep in expressions in ways that would<br>&gt;&gt;&gt;&gt; open hideous cans of worms:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;    if let foo = bar &amp;&amp; barTest(foo) || let foo = baz &amp;&amp; bazTest(foo) {<br>&gt;&gt;&gt;&gt;        // Is foo defined here? What is its type? Yikes!<br>&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Communicating that the top-level separator in a condition clause is not<br>&gt;&gt;&gt;&gt; just another boolean operator does seem important.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Bottom line: the proposal addresses a real problem, and the proposed<br>&gt;&gt;&gt;&gt; solution is an improvement. If the choice is either current syntax or<br>&gt;&gt;&gt;&gt; SE-0099, I vote for SE-0099. I have a nagging feeling there’s a better<br>&gt;&gt;&gt;&gt; third choice out there somewhere. If there isn’t, then I’ll take SE-0099.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Paul<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9ce70a6cb7175e7a5e5db5658186a31?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Brandon Knope</string> &lt;bknope at me.com&gt;<p>May 28, 2016 at 04:00:00pm</p></header><div class="content"><p>I&#39;m not sure how feasible this is...but why not remove the conditional case to remove the ambiguity?<br></p><p>Conditional case seems somewhat esoteric compared to the current behavior that many people are used to. (I.e. How many know of and use a conditional case?)<br></p><p>Is it worth de-beautifying the syntax to accommodate conditional case? If it is (and some have argued it&#39;s not de-beautifying anything but that&#39;s just IMO) then I stand corrected.<br></p><p>To me, this is a very far reaching change. And I hope it is being seen and considered by more than just the few of us because I would hate for a few to decide on something that will affect many. <br></p><p>And this *would* affect many people (unless I am being too dramatic here) and significantly change the &quot;look&quot; of their code. <br></p><p>My slightly dramatic .02,<br>Brandon <br></p><p>&gt; On May 28, 2016, at 1:32 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 28, 2016, at 1:10 AM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Yet another alternative: would it be possible to disallow commas as variable declaration separators and use them for condition clause separators again:<br>&gt;&gt; <br>&gt;&gt; let a = 4, b = 8 // becomes illegal and requires to separate them on two lines<br>&gt;&gt; <br>&gt;&gt; if a &gt; 4, let c = foo(), let d = bar(), c != d { // now comma is not ambiguous anymore<br>&gt;&gt; }<br>&gt; <br>&gt; The ambiguity is between “case” and “let” conditions, specifically because “case” takes a pattern, and “let” is a valid pattern:<br>&gt; <br>&gt; guard (pattern1) = expr1, let x = expr2 else<br>&gt; <br>&gt; can be:<br>&gt; <br>&gt; guard (pattern1) = expr1, let (x) = expr2 else<br>&gt; <br>&gt; or:<br>&gt; <br>&gt; guard (pattern1) = expr1, (let x) = expr2 else<br>&gt; <br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>May 29, 2016 at 02:00:00pm</p></header><div class="content"><p>I would be fine with this! Ambiguity like this not only makes it hard for the compiler, but for the reader too.<br></p><p><br>&gt; On 28 May 2016, at 6:10 PM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Yet another alternative: would it be possible to disallow commas as variable declaration separators and use them for condition clause separators again:<br>&gt; <br>&gt; let a = 4, b = 8 // becomes illegal and requires to separate them on two lines<br>&gt; <br>&gt; if a &gt; 4, let c = foo(), let d = bar(), c != d { // now comma is not ambiguous anymore<br>&gt; }<br>&gt; <br>&gt; David.<br>&gt; <br>&gt;&gt; On 28 May 2016, at 08:25, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Let me answer in another way that speaks to my background which isn&#39;t in compiler theory: The use of &amp;&amp; may produce cognitive overload between the use in Boolean assertions and the use in separating condition clauses.<br>&gt;&gt; <br>&gt;&gt; Yes, which is quite intentional on my part. The `if` statement requires that all of its clauses succeed; if pattern matching and optional testing were boolean expressions, you would use `&amp;&amp;` to link them with each other and with boolean tests. The fact that these are *not* boolean expressions is a mere artifact of Swift&#39;s implementation.<br>&gt;&gt; <br>&gt;&gt; I think our best solution is to make Swift act as though these *are* boolean expressions, but ones that can only be used in a limited way: they can only be `&amp;&amp;`ed, because they bind variables that have to be made available in specific blocks. In other words, I think we should paper over the compiler limitations preventing these things from working as expected.<br>&gt;&gt; <br>&gt;&gt; (Actually, it might be interesting to allow `!let` and `!case` statements which are available in the `else` branches of the control structures they&#39;re used in, but that&#39;s a different story...)<br>&gt;&gt; <br>&gt;&gt; ***<br>&gt;&gt; <br>&gt;&gt; If you&#39;ll permit me to go sort of &quot;mad dream&quot; here for a moment, I can actually sort of see a way to do a lot of this in the standard library. Imagine if the `let` and `case` clauses in a conditional produced a type like this:<br>&gt;&gt; <br>&gt;&gt; 	enum PatternMatchingResult&lt;BoundValues&gt; {<br>&gt;&gt; 		case failed<br>&gt;&gt; 		case succeeded (BoundValues)<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; `BoundValues` would be the values, if any, extracted through the pattern matching operation. Then you could define operators like these:<br>&gt;&gt; <br>&gt;&gt; 	func &amp;&amp; &lt;T, U&gt;(lhs: PatternMatchingResult&lt;T&gt;, rhs: @autoclosure () -&gt; PatternMatchingResult&lt;U&gt;) -&gt; PatternMatchingResult&lt;(T, U)&gt; {<br>&gt;&gt; 		guard case .succeeded (let lhsValue) = lhs else {<br>&gt;&gt; 			return .failed<br>&gt;&gt; 		}<br>&gt;&gt; 		guard case .succeeded (let rhsValue) = rhs() else {<br>&gt;&gt; 			return .failed<br>&gt;&gt; 		}<br>&gt;&gt; 		return .succeeded (lhsValue, rhsValue)<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; 	func &amp;&amp; &lt;T&gt;(lhs: PatternMatchingResult&lt;T&gt;, rhs: @autoclosure () -&gt; Boolean) -&gt; PatternMatchingResult&lt;T&gt; {<br>&gt;&gt; 		guard case .succeeded = lhs else {<br>&gt;&gt; 			return .failed<br>&gt;&gt; 		}<br>&gt;&gt; 		guard rhs() else {<br>&gt;&gt; 			return .failed<br>&gt;&gt; 		}<br>&gt;&gt; 		return lhs<br>&gt;&gt; 	}<br>&gt;&gt; 	<br>&gt;&gt; 	func &amp;&amp; &lt;U&gt;(lhs: Boolean, rhs: @autoclosure () -&gt; PatternMatchingResult&lt;U&gt;) -&gt; PatternMatchingResult&lt;U&gt; {<br>&gt;&gt; 		guard lhs else {<br>&gt;&gt; 			return .failed<br>&gt;&gt; 		}<br>&gt;&gt; 		return rhs()<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; And then transform this:<br>&gt;&gt; <br>&gt;&gt; 	guard<br>&gt;&gt; 		x == 0 &amp;&amp; a == b &amp;&amp; c == d &amp;&amp;<br>&gt;&gt; 		let y = optional, w = optional2, v = optional 3 &amp;&amp;<br>&gt;&gt; 		z == 2<br>&gt;&gt; 	else { ... }<br>&gt;&gt; <br>&gt;&gt; Into something like this (where `?` is a sort of &quot;anonymous capture slot&quot;):<br>&gt;&gt; <br>&gt;&gt; 	guard case let .success (y, w, v) = (<br>&gt;&gt; 		x == 0 &amp;&amp; a == b &amp;&amp; c == d &amp;&amp;<br>&gt;&gt; 		Pattern(.some(?), .some(?), .some(?)).result(ofMatchingAgainst: (optional, optional2, optional3)) &amp;&amp;<br>&gt;&gt; 		z == 2<br>&gt;&gt; 	)<br>&gt;&gt; 	else { ... }<br>&gt;&gt; <br>&gt;&gt; Resolving to:<br>&gt;&gt; <br>&gt;&gt; 	guard case let PatternMatchingResult.success (y, w, v) = (<br>&gt;&gt; 		(&amp;&amp;)(	// (Boolean, PatternMatchingResult) -&gt; PatternMatchingResult<br>&gt;&gt; 			x == 0,<br>&gt;&gt; 			(&amp;&amp;)( 	// (Boolean, PatternMatchingResult) -&gt; PatternMatchingResult<br>&gt;&gt; 				a == b,<br>&gt;&gt; 				(&amp;&amp;)(	// (Boolean, PatternMatchingResult) -&gt; PatternMatchingResult<br>&gt;&gt; 					c == d,<br>&gt;&gt; 					(&amp;&amp;)(	// (PatternMatchingResult, Boolean) -&gt; PatternMatchingResult<br>&gt;&gt; 						Pattern(.some(?), .some(?), .some(?)).result(ofMatchingAgainst: (optional, optional2, optional3)),<br>&gt;&gt; 						z == 2<br>&gt;&gt; 					)<br>&gt;&gt; 				)<br>&gt;&gt; 			)<br>&gt;&gt; 		)<br>&gt;&gt; 	)<br>&gt;&gt; 	else { ... }<br>&gt;&gt; <br>&gt;&gt; The `Pattern` type shown here is notional, not an actual thing that would exist as a first-class entity—although that *would* be rather nice to have eventually...<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 28, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On May 28, 2016, at 2:30 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On May 27, 2016, at 6:26 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; guard<br>&gt;&gt;&gt; x == 0 &amp;&amp; a == b &amp;&amp; c == d &amp;&amp;<br>&gt;&gt;&gt; let y = optional, w = optional2, v = optional 3 &amp;&amp;<br>&gt;&gt;&gt; z == 2<br>&gt;&gt;&gt; else { ... }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Figuring out where to break the first line into expression and into condition (after the `d`) could be very challenging to the compiler.<br>&gt;&gt; <br>&gt;&gt; I&#39;m not sure it is. `let` and `case` are not valid in an expression, so an `&amp;&amp;` followed by `let` or `case` must be joining clauses. On the other side of things, Swift&#39;s `&amp;&amp;` doesn&#39;t ever produce an optional, so if we&#39;re parsing an expression at the top level of an if-let, an `&amp;&amp;` must indicate the end of the clause. An if-case *could* theoretically include an `&amp;&amp;`, but pattern matching against a boolean value seems like a fairly useless thing to do in a context that&#39;s specifically intended to test booleans.<br>&gt; <br>&gt; Let me answer in another way that speaks to my background which isn&#39;t in compiler theory: The use of &amp;&amp; may produce cognitive overload between the use in Boolean assertions and the use in separating condition clauses.<br>&gt; <br></p><p>+1  the focus is should not transfer from the conditions to the separator which happens to me with &amp;&amp;<br></p><p>I hope the core team pulls rank, even recasting this as adressing a bug in the original grammar, to push it in. Worst case scenario is people ignore it until they start needing it.<br></p><p><br>&gt; -- E<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>May 28, 2016 at 08:00:00am</p></header><div class="content"><p>Agreed!<br></p><p>Sent from my iPhone<br></p><p>&gt; On 28 May 2016, at 08:10, L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 28, 2016, at 2:30 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 27, 2016, at 6:26 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; guard<br>&gt;&gt;&gt;&gt; x == 0 &amp;&amp; a == b &amp;&amp; c == d &amp;&amp;<br>&gt;&gt;&gt;&gt; let y = optional, w = optional2, v = optional 3 &amp;&amp;<br>&gt;&gt;&gt;&gt; z == 2<br>&gt;&gt;&gt;&gt; else { ... }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Figuring out where to break the first line into expression and into condition (after the `d`) could be very challenging to the compiler.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m not sure it is. `let` and `case` are not valid in an expression, so an `&amp;&amp;` followed by `let` or `case` must be joining clauses. On the other side of things, Swift&#39;s `&amp;&amp;` doesn&#39;t ever produce an optional, so if we&#39;re parsing an expression at the top level of an if-let, an `&amp;&amp;` must indicate the end of the clause. An if-case *could* theoretically include an `&amp;&amp;`, but pattern matching against a boolean value seems like a fairly useless thing to do in a context that&#39;s specifically intended to test booleans.<br>&gt;&gt; <br>&gt;&gt; Let me answer in another way that speaks to my background which isn&#39;t in compiler theory: The use of &amp;&amp; may produce cognitive overload between the use in Boolean assertions and the use in separating condition clauses.<br>&gt;&gt; <br>&gt; <br>&gt; +1  the focus is should not transfer from the conditions to the separator which happens to me with &amp;&amp;<br>&gt; <br>&gt; I hope the core team pulls rank, even recasting this as adressing a bug in the original grammar, to push it in. Worst case scenario is people ignore it until they start needing it.<br>&gt; <br>&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b18f20abb65f7760305797669c5bc77d?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>David Hart</string> &lt;davidhart at fastmail.com&gt;<p>May 28, 2016 at 10:00:00am</p></header><div class="content"><p>Yet another alternative: would it be possible to disallow commas as variable declaration separators and use them for condition clause separators again:<br></p><p>let a = 4, b = 8 // becomes illegal and requires to separate them on two lines<br></p><p>if a &gt; 4, let c = foo(), let d = bar(), c != d { // now comma is not ambiguous anymore<br>}<br></p><p>David.<br></p><p>&gt; On 28 May 2016, at 02:30, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On May 27, 2016, at 6:26 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; guard<br>&gt;&gt;&gt; x == 0 &amp;&amp; a == b &amp;&amp; c == d &amp;&amp;<br>&gt;&gt;&gt; let y = optional, w = optional2, v = optional 3 &amp;&amp;<br>&gt;&gt;&gt; z == 2<br>&gt;&gt;&gt; else { ... }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Figuring out where to break the first line into expression and into condition (after the `d`) could be very challenging to the compiler.<br>&gt;&gt; <br>&gt;&gt; I&#39;m not sure it is. `let` and `case` are not valid in an expression, so an `&amp;&amp;` followed by `let` or `case` must be joining clauses. On the other side of things, Swift&#39;s `&amp;&amp;` doesn&#39;t ever produce an optional, so if we&#39;re parsing an expression at the top level of an if-let, an `&amp;&amp;` must indicate the end of the clause. An if-case *could* theoretically include an `&amp;&amp;`, but pattern matching against a boolean value seems like a fairly useless thing to do in a context that&#39;s specifically intended to test booleans.<br>&gt; <br>&gt; Let me answer in another way that speaks to my background which isn&#39;t in compiler theory: The use of &amp;&amp; may produce cognitive overload between the use in Boolean assertions and the use in separating condition clauses.<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160528/193d6174/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May 31, 2016 at 04:00:00pm</p></header><div class="content"><p>In English (and, I&#39;m guessing, many other languages), semicolons are used<br>as a second &#39;tier&#39; of separators when commas become ambiguous. I&#39;m puzzled<br>that a proposal to bring this longstanding convention to Swift is raising<br>so many objections, even going so far as to prompt alternatives such as<br>this that break clearly useful shorthands.<br></p><p>On Tue, May 31, 2016 at 10:44 David Hart via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Yet another alternative: would it be possible to disallow commas as<br>&gt; variable declaration separators and use them for condition clause<br>&gt; separators again:<br>&gt;<br>&gt; let a = 4, b = 8 // becomes illegal and requires to separate them on two<br>&gt; lines<br>&gt;<br>&gt; if a &gt; 4, let c = foo(), let d = bar(), c != d { // now comma is not<br>&gt; ambiguous anymore<br>&gt; }<br>&gt;<br>&gt; David.<br>&gt;<br>&gt; On 28 May 2016, at 02:30, Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On May 27, 2016, at 6:26 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; guard<br>&gt; x == 0 &amp;&amp; a == b &amp;&amp; c == d &amp;&amp;<br>&gt; let y = optional, w = optional2, v = optional 3 &amp;&amp;<br>&gt; z == 2<br>&gt; else { ... }<br>&gt;<br>&gt; Figuring out where to break the first line into expression and into<br>&gt; condition (after the `d`) could be very challenging to the compiler.<br>&gt;<br>&gt;<br>&gt; I&#39;m not sure it is. `let` and `case` are not valid in an expression, so an<br>&gt; `&amp;&amp;` followed by `let` or `case` must be joining clauses. On the other side<br>&gt; of things, Swift&#39;s `&amp;&amp;` doesn&#39;t ever produce an optional, so if we&#39;re<br>&gt; parsing an expression at the top level of an if-let, an `&amp;&amp;` must indicate<br>&gt; the end of the clause. An if-case *could* theoretically include an `&amp;&amp;`,<br>&gt; but pattern matching against a boolean value seems like a fairly useless<br>&gt; thing to do in a context that&#39;s specifically intended to test booleans.<br>&gt;<br>&gt;<br>&gt; Let me answer in another way that speaks to my background which isn&#39;t in<br>&gt; compiler theory: The use of &amp;&amp; may produce cognitive overload between the<br>&gt; use in Boolean assertions and the use in separating condition clauses.<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/a844938b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9ce70a6cb7175e7a5e5db5658186a31?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Brandon Knope</string> &lt;bknope at me.com&gt;<p>May 31, 2016 at 12:00:00pm</p></header><div class="content"><p>To be frank, I just find the proposed syntax to be more ugly and less expressive. <br></p><p>I just don&#39;t find the proposal compelling enough to take away one of the truly &quot;Swifty&quot; syntaxes that I have used and loved. <br></p><p>If there are other ways to keep &quot;where&quot; while fixing the ambiguity I would rather explore that than require semicolons everywhere. <br></p><p>I have a feeling that more would object but just aren&#39;t perusing the mailing lists. I think we will see much more activity come WWDC<br></p><p>Brandon<br></p><p>&gt; On May 31, 2016, at 12:25 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; In English (and, I&#39;m guessing, many other languages), semicolons are used as a second &#39;tier&#39; of separators when commas become ambiguous. I&#39;m puzzled that a proposal to bring this longstanding convention to Swift is raising so many objections, even going so far as to prompt alternatives such as this that break clearly useful shorthands.<br>&gt; <br>&gt;&gt; On Tue, May 31, 2016 at 10:44 David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Yet another alternative: would it be possible to disallow commas as variable declaration separators and use them for condition clause separators again:<br>&gt;&gt; <br>&gt;&gt; let a = 4, b = 8 // becomes illegal and requires to separate them on two lines<br>&gt;&gt; <br>&gt;&gt; if a &gt; 4, let c = foo(), let d = bar(), c != d { // now comma is not ambiguous anymore<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; David.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On 28 May 2016, at 02:30, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 27, 2016, at 6:26 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; guard<br>&gt;&gt;&gt;&gt;&gt; x == 0 &amp;&amp; a == b &amp;&amp; c == d &amp;&amp;<br>&gt;&gt;&gt;&gt;&gt; let y = optional, w = optional2, v = optional 3 &amp;&amp;<br>&gt;&gt;&gt;&gt;&gt; z == 2<br>&gt;&gt;&gt;&gt;&gt; else { ... }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Figuring out where to break the first line into expression and into condition (after the `d`) could be very challenging to the compiler.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m not sure it is. `let` and `case` are not valid in an expression, so an `&amp;&amp;` followed by `let` or `case` must be joining clauses. On the other side of things, Swift&#39;s `&amp;&amp;` doesn&#39;t ever produce an optional, so if we&#39;re parsing an expression at the top level of an if-let, an `&amp;&amp;` must indicate the end of the clause. An if-case *could* theoretically include an `&amp;&amp;`, but pattern matching against a boolean value seems like a fairly useless thing to do in a context that&#39;s specifically intended to test booleans.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Let me answer in another way that speaks to my background which isn&#39;t in compiler theory: The use of &amp;&amp; may produce cognitive overload between the use in Boolean assertions and the use in separating condition clauses.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- E<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/d61f7777/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May 31, 2016 at 05:00:00pm</p></header><div class="content"><p>The motivating example is a compelling illustration of a problem with the<br>current grammar. I don&#39;t think anyone would disagree that `if let y = y<br>where x &lt; z` is an abomination.<br></p><p>Now, I see no principled criteria, and none have been proposed here, that<br>would be useful to restrict what can come after `where`. Moreover, I see no<br>contention with the argument that arbitrary Boolean assertions should be<br>possible after a let binding.<br></p><p>Finally, it is a stated goal of the core team that there shouldn&#39;t be<br>multiple &#39;dialects&#39; of Swift, and that where possible there should be one<br>general solution rather than two options.<br></p><p>Given these premises, I have to conclude that *if* the motivating issue is<br>to be fixed, we must get rid of `where`.<br></p><p><br>On Tue, May 31, 2016 at 11:53 Brandon Knope &lt;bknope at me.com&gt; wrote:<br></p><p>&gt; To be frank, I just find the proposed syntax to be more ugly and less<br>&gt; expressive.<br>&gt;<br>&gt; I just don&#39;t find the proposal compelling enough to take away one of the<br>&gt; truly &quot;Swifty&quot; syntaxes that I have used and loved.<br>&gt;<br>&gt; If there are other ways to keep &quot;where&quot; while fixing the ambiguity I would<br>&gt; rather explore that than require semicolons everywhere.<br>&gt;<br>&gt; I have a feeling that more would object but just aren&#39;t perusing the<br>&gt; mailing lists. I think we will see much more activity come WWDC<br>&gt;<br>&gt; Brandon<br>&gt;<br>&gt; On May 31, 2016, at 12:25 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; In English (and, I&#39;m guessing, many other languages), semicolons are used<br>&gt; as a second &#39;tier&#39; of separators when commas become ambiguous. I&#39;m puzzled<br>&gt; that a proposal to bring this longstanding convention to Swift is raising<br>&gt; so many objections, even going so far as to prompt alternatives such as<br>&gt; this that break clearly useful shorthands.<br>&gt;<br>&gt; On Tue, May 31, 2016 at 10:44 David Hart via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Yet another alternative: would it be possible to disallow commas as<br>&gt;&gt; variable declaration separators and use them for condition clause<br>&gt;&gt; separators again:<br>&gt;&gt;<br>&gt;&gt; let a = 4, b = 8 // becomes illegal and requires to separate them on two<br>&gt;&gt; lines<br>&gt;&gt;<br>&gt;&gt; if a &gt; 4, let c = foo(), let d = bar(), c != d { // now comma is not<br>&gt;&gt; ambiguous anymore<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; David.<br>&gt;&gt;<br>&gt;&gt; On 28 May 2016, at 02:30, Erica Sadun via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On May 27, 2016, at 6:26 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; guard<br>&gt;&gt; x == 0 &amp;&amp; a == b &amp;&amp; c == d &amp;&amp;<br>&gt;&gt; let y = optional, w = optional2, v = optional 3 &amp;&amp;<br>&gt;&gt; z == 2<br>&gt;&gt; else { ... }<br>&gt;&gt;<br>&gt;&gt; Figuring out where to break the first line into expression and into<br>&gt;&gt; condition (after the `d`) could be very challenging to the compiler.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I&#39;m not sure it is. `let` and `case` are not valid in an expression, so<br>&gt;&gt; an `&amp;&amp;` followed by `let` or `case` must be joining clauses. On the other<br>&gt;&gt; side of things, Swift&#39;s `&amp;&amp;` doesn&#39;t ever produce an optional, so if we&#39;re<br>&gt;&gt; parsing an expression at the top level of an if-let, an `&amp;&amp;` must indicate<br>&gt;&gt; the end of the clause. An if-case *could* theoretically include an `&amp;&amp;`,<br>&gt;&gt; but pattern matching against a boolean value seems like a fairly useless<br>&gt;&gt; thing to do in a context that&#39;s specifically intended to test booleans.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Let me answer in another way that speaks to my background which isn&#39;t in<br>&gt;&gt; compiler theory: The use of &amp;&amp; may produce cognitive overload between the<br>&gt;&gt; use in Boolean assertions and the use in separating condition clauses.<br>&gt;&gt;<br>&gt;&gt; -- E<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/eaa83e7d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>May 31, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On May 31, 2016, at 11:16 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; The motivating example is a compelling illustration of a problem with the current grammar. I don&#39;t think anyone would disagree that `if let y = y where x &lt; z` is an abomination.<br>&gt; <br>&gt; Now, I see no principled criteria, and none have been proposed here, that would be useful to restrict what can come after `where`. Moreover, I see no contention with the argument that arbitrary Boolean assertions should be possible after a let binding.<br>&gt; <br>&gt; Finally, it is a stated goal of the core team that there shouldn&#39;t be multiple &#39;dialects&#39; of Swift, and that where possible there should be one general solution rather than two options.<br>&gt; <br>&gt; Given these premises, I have to conclude that *if* the motivating issue is to be fixed, we must get rid of `where`.<br></p><p><br>This proposal does affect where clauses in:<br>case conditions (case pattern initializer where-clause?)<br>optional binding conditions (optional-binding-head optional-binding-continuation-list? where-clause?)<br>This proposal does not affect where clauses in:<br>for-in statements (for case? pattern in expression where-clause? code-block)<br>case item lists (case-item-list → pattern where-clause? | pattern where-clause? , case-item-list)<br>catch clauses (catch pattern? where-clause? code-block)<br>generic parameter clause&#39;s requirement clause<br>What I&#39;m hearing is that at least some developers would like to retain where clauses in case conditions and optional binding conditions but still allow the more controllable logic introduced by differentiating condition types with semicolons or newlines. Is that a fair summary? <br></p><p>Here is the where clause grammar:<br></p><p>where_clause = where where_expression<br>where_expression = expression<br></p><p>I think technically, by adding the new separators, the `where` need not be disallowed. That leaves the following questions:<br></p><p>* Should `where` clauses be allowed where the contents of the where clause have no connection to the condition that precedes it?<br>* Is there a technical way to to check for such conformance?<br>* Should the `where` clause be left unconstrained, as it currently is in switch statements and for loops, etc, which is consistent with the rest of the language but contrary to the spirit of safety in Swift?<br>* Should `where` clauses be re-evaluated throughout the language?<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/1f809a05/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 31, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; What I&#39;m hearing is that at least some developers would like to retain<br> &gt; where clauses in case conditions and optional binding conditions but still<br> &gt; allow the more controllable logic introduced by differentiating condition<br> &gt; types with semicolons or newlines. Is that a fair summary?<br></p><p>I believe so. Personally I&#39;m +1 for leaving `where` as-is and &quot;allow the <br>more controllable logic&quot; from the proposal.<br></p><p> &gt; * Should `where` clauses be allowed where the contents of the where clause<br> &gt; have no connection to the condition that precedes it?<br> &gt; * Is there a technical way to to check for such conformance?<br> &gt; * Should the `where` clause be left unconstrained, as it currently is in<br> &gt; switch statements and for loops, etc, which is consistent with the rest of<br> &gt; the language but contrary to the spirit of safety in Swift?<br> &gt; * Should `where` clauses be re-evaluated throughout the language?<br></p><p>I suggest to not introduce any rules for `where` at least in this proposal. <br>Probably we can discuss all related to `where` in separate proposal.<br></p><p><br>On 31.05.2016 20:57, Erica Sadun via swift-evolution wrote:<br>&gt;<br>&gt;&gt; On May 31, 2016, at 11:16 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com<br>&gt;&gt; &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; The motivating example is a compelling illustration of a problem with the<br>&gt;&gt; current grammar. I don&#39;t think anyone would disagree that `if let y = y<br>&gt;&gt; where x &lt; z` is an abomination.<br>&gt;&gt;<br>&gt;&gt; Now, I see no principled criteria, and none have been proposed here, that<br>&gt;&gt; would be useful to restrict what can come after `where`. Moreover, I see<br>&gt;&gt; no contention with the argument that arbitrary Boolean assertions should<br>&gt;&gt; be possible after a let binding.<br>&gt;&gt;<br>&gt;&gt; Finally, it is a stated goal of the core team that there shouldn&#39;t be<br>&gt;&gt; multiple &#39;dialects&#39; of Swift, and that where possible there should be one<br>&gt;&gt; general solution rather than two options.<br>&gt;&gt;<br>&gt;&gt; Given these premises, I have to conclude that *if* the motivating issue<br>&gt;&gt; is to be fixed, we must get rid of `where`.<br>&gt;<br>&gt;<br>&gt; This proposal does affect where clauses in:<br>&gt;<br>&gt;   * case conditions (case pattern initializer where-clause?)<br>&gt;   * optional binding conditions (optional-binding-head<br>&gt;     optional-binding-continuation-list? where-clause?)<br>&gt;<br>&gt; This proposal does not affect where clauses in:<br>&gt;<br>&gt;   * for-in statements (for case? pattern in expression where-clause?<br>&gt;     code-block)<br>&gt;   * case item lists (case-item-list → pattern where-clause? | pattern<br>&gt;     where-clause? , case-item-list)<br>&gt;   * catch clauses (catch pattern? where-clause? code-block)<br>&gt;   * generic parameter clause&#39;s requirement clause<br>&gt;<br>&gt; What I&#39;m hearing is that at least some developers would like to retain<br>&gt; where clauses in case conditions and optional binding conditions but still<br>&gt; allow the more controllable logic introduced by differentiating condition<br>&gt; types with semicolons or newlines. Is that a fair summary?<br>&gt;<br>&gt; Here is the where clause grammar:<br>&gt;<br>&gt; where_clause = where where_expression<br>&gt; where_expression = expression<br>&gt;<br>&gt; I think technically, by adding the new separators, the `where` need not be<br>&gt; disallowed. That leaves the following questions:<br>&gt;<br>&gt; * Should `where` clauses be allowed where the contents of the where clause<br>&gt; have no connection to the condition that precedes it?<br>&gt; * Is there a technical way to to check for such conformance?<br>&gt; * Should the `where` clause be left unconstrained, as it currently is in<br>&gt; switch statements and for loops, etc, which is consistent with the rest of<br>&gt; the language but contrary to the spirit of safety in Swift?<br>&gt; * Should `where` clauses be re-evaluated throughout the language?<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>May 31, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On 31 May 2016, at 18:57, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; * Should `where` clauses be allowed where the contents of the where clause have no connection to the condition that precedes it?<br>&gt; * Is there a technical way to to check for such conformance?<br>&gt; * Should the `where` clause be left unconstrained, as it currently is in switch statements and for loops, etc, which is consistent with the rest of the language but contrary to the spirit of safety in Swift?<br>&gt; * Should `where` clauses be re-evaluated throughout the language?<br></p><p>Personally I’m not sure that where should need to be constrained, in fact one of the examples given as “incorrect” is arguably not so:<br></p><p>	if let foo = x where y &lt; z { … }<br></p><p>In this case y &lt; z doesn’t appear strictly related to the optional binding, but it may still be a condition of it, in essence it’s saying “bind foo if this is true”. This is interesting because the compiler is actually free to evaluate y &lt; z first, and only perform the binding afterwards. Actually this is also true in the following case:<br></p><p>	if let foo = x where foo &gt; 5 { … }<br></p><p>To evaluate foo &gt; 5 the compiler doesn’t actually need to unwrap x, it just needs to know if x is .Some, in which case it can compare the value and only if the comparison succeeds actually copy it into a variable and continue.<br></p><p>Of course statements separated by semi-colons can be reordered behind the scenes if the compiler wants to do-so, so long as the logic doesn’t change, but I find that where reads better with that implication in mind. It reads visually like “bind this if this test is true” rather than “bind this, then test this”.<br></p><p>Plus it just looks nicer (to me); sometimes aesthetics are important, and the majority of cases don’t need the complexity of lots of conditionals that need separating, sometimes a pattern and a condition, or a binding and a condition is enough, and the where clause has this covered, and keeps these forms of conditional visually distinct. Much more complex cases will benefit from semi-colons, which in turn will make them visually distinct too, even if a lot of the building blocks are the same.<br></p><p>Put another way, I tend to think of pattern matching, conditional binding and regular logic as three completely different forms of conditional (I suppose they are in fact at present), the separators as proposed will let you mix and match these cleanly, which has the potential for some overlap sure, but I think developers can be left to resolve that for themselves by choosing whether to group a conditional with where, or separate it.<br></p><p><br>Anyway, it doesn’t really matter overall, as the addition of semi-colons/new-lines as separators isn’t dependent upon the removal of where clauses, so they can be removed later if it’s deemed useful. In fact, doing it this way would be a better way to do it as it gives us a period in which both features will be available, and we can just wait and see what people actually use. If where clauses are ignored in favour of semi-colons/new-lines, then at this point it will be trivial to replace them, as you can non-destructively remove the feature by simply swapping the where keyword from these types of conditionals for a semi-colon, or provide a fixit to do this, as functionally they will be identical.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/ae82d7e5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>June  1, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; Am 31.05.2016 um 23:01 schrieb Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; On 31 May 2016, at 18:57, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; * Should `where` clauses be allowed where the contents of the where clause have no connection to the condition that precedes it?<br>&gt;&gt; * Is there a technical way to to check for such conformance?<br>&gt;&gt; * Should the `where` clause be left unconstrained, as it currently is in switch statements and for loops, etc, which is consistent with the rest of the language but contrary to the spirit of safety in Swift?<br>&gt;&gt; * Should `where` clauses be re-evaluated throughout the language?<br>&gt; <br>&gt; Personally I’m not sure that where should need to be constrained, in fact one of the examples given as “incorrect” is arguably not so:<br>&gt; <br>&gt; 	if let foo = x where y &lt; z { … }<br>&gt; <br>&gt; In this case y &lt; z doesn’t appear strictly related to the optional binding, but it may still be a condition of it, in essence it’s saying “bind foo if this is true”.<br></p><p>This is a very good point!! I totally agree with that!<br></p><p>-Thorsten <br></p><p><br></p><p>&gt; This is interesting because the compiler is actually free to evaluate y &lt; z first, and only perform the binding afterwards. Actually this is also true in the following case:<br>&gt; <br>&gt; 	if let foo = x where foo &gt; 5 { … }<br>&gt; <br>&gt; To evaluate foo &gt; 5 the compiler doesn’t actually need to unwrap x, it just needs to know if x is .Some, in which case it can compare the value and only if the comparison succeeds actually copy it into a variable and continue.<br>&gt; <br>&gt; Of course statements separated by semi-colons can be reordered behind the scenes if the compiler wants to do-so, so long as the logic doesn’t change, but I find that where reads better with that implication in mind. It reads visually like “bind this if this test is true” rather than “bind this, then test this”.<br>&gt; <br>&gt; Plus it just looks nicer (to me); sometimes aesthetics are important, and the majority of cases don’t need the complexity of lots of conditionals that need separating, sometimes a pattern and a condition, or a binding and a condition is enough, and the where clause has this covered, and keeps these forms of conditional visually distinct. Much more complex cases will benefit from semi-colons, which in turn will make them visually distinct too, even if a lot of the building blocks are the same.<br>&gt; <br>&gt; Put another way, I tend to think of pattern matching, conditional binding and regular logic as three completely different forms of conditional (I suppose they are in fact at present), the separators as proposed will let you mix and match these cleanly, which has the potential for some overlap sure, but I think developers can be left to resolve that for themselves by choosing whether to group a conditional with where, or separate it.<br>&gt; <br>&gt; <br>&gt; Anyway, it doesn’t really matter overall, as the addition of semi-colons/new-lines as separators isn’t dependent upon the removal of where clauses, so they can be removed later if it’s deemed useful. In fact, doing it this way would be a better way to do it as it gives us a period in which both features will be available, and we can just wait and see what people actually use. If where clauses are ignored in favour of semi-colons/new-lines, then at this point it will be trivial to replace them, as you can non-destructively remove the feature by simply swapping the where keyword from these types of conditionals for a semi-colon, or provide a fixit to do this, as functionally they will be identical.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160601/5b1dfe5a/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9ce70a6cb7175e7a5e5db5658186a31?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Brandon Knope</string> &lt;bknope at me.com&gt;<p>May 31, 2016 at 02:00:00pm</p></header><div class="content"><p>Except some of us have proposed only allowing unwrapped or newly bound variables in the where clause:<br></p><p>if let y = y where y &lt; z should work<br></p><p>If let y = y where x &lt; z should be an error because it doesn&#39;t need to be in a where clause and doesn&#39;t make sense contextually. <br></p><p>I understand the rationale about why it should be removed...but I find it a little extreme and a little &quot;technical&quot; to the point that some of the personality of the language will be lost...all for the sake being &quot;technically&quot; correct. <br></p><p>This may be why some of us are against the proposal. <br></p><p>Brandon <br></p><p><br>&gt; On May 31, 2016, at 1:16 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; The motivating example is a compelling illustration of a problem with the current grammar. I don&#39;t think anyone would disagree that `if let y = y where x &lt; z` is an abomination.<br>&gt; <br>&gt; Now, I see no principled criteria, and none have been proposed here, that would be useful to restrict what can come after `where`. Moreover, I see no contention with the argument that arbitrary Boolean assertions should be possible after a let binding.<br>&gt; <br>&gt; Finally, it is a stated goal of the core team that there shouldn&#39;t be multiple &#39;dialects&#39; of Swift, and that where possible there should be one general solution rather than two options.<br>&gt; <br>&gt; Given these premises, I have to conclude that *if* the motivating issue is to be fixed, we must get rid of `where`.<br>&gt; <br>&gt; <br>&gt;&gt; On Tue, May 31, 2016 at 11:53 Brandon Knope &lt;bknope at me.com&gt; wrote:<br>&gt;&gt; To be frank, I just find the proposed syntax to be more ugly and less expressive. <br>&gt;&gt; <br>&gt;&gt; I just don&#39;t find the proposal compelling enough to take away one of the truly &quot;Swifty&quot; syntaxes that I have used and loved. <br>&gt;&gt; <br>&gt;&gt; If there are other ways to keep &quot;where&quot; while fixing the ambiguity I would rather explore that than require semicolons everywhere. <br>&gt;&gt; <br>&gt;&gt; I have a feeling that more would object but just aren&#39;t perusing the mailing lists. I think we will see much more activity come WWDC<br>&gt;&gt; <br>&gt;&gt; Brandon<br>&gt;&gt; <br>&gt;&gt;&gt; On May 31, 2016, at 12:25 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In English (and, I&#39;m guessing, many other languages), semicolons are used as a second &#39;tier&#39; of separators when commas become ambiguous. I&#39;m puzzled that a proposal to bring this longstanding convention to Swift is raising so many objections, even going so far as to prompt alternatives such as this that break clearly useful shorthands.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Tue, May 31, 2016 at 10:44 David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; Yet another alternative: would it be possible to disallow commas as variable declaration separators and use them for condition clause separators again:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let a = 4, b = 8 // becomes illegal and requires to separate them on two lines<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; if a &gt; 4, let c = foo(), let d = bar(), c != d { // now comma is not ambiguous anymore<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; David.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 28 May 2016, at 02:30, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 27, 2016, at 6:26 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; guard<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; x == 0 &amp;&amp; a == b &amp;&amp; c == d &amp;&amp;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let y = optional, w = optional2, v = optional 3 &amp;&amp;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; z == 2<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; else { ... }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Figuring out where to break the first line into expression and into condition (after the `d`) could be very challenging to the compiler.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I&#39;m not sure it is. `let` and `case` are not valid in an expression, so an `&amp;&amp;` followed by `let` or `case` must be joining clauses. On the other side of things, Swift&#39;s `&amp;&amp;` doesn&#39;t ever produce an optional, so if we&#39;re parsing an expression at the top level of an if-let, an `&amp;&amp;` must indicate the end of the clause. An if-case *could* theoretically include an `&amp;&amp;`, but pattern matching against a boolean value seems like a fairly useless thing to do in a context that&#39;s specifically intended to test booleans.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Let me answer in another way that speaks to my background which isn&#39;t in compiler theory: The use of &amp;&amp; may produce cognitive overload between the use in Boolean assertions and the use in separating condition clauses.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -- E<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/c5b4bf2b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May 31, 2016 at 06:00:00pm</p></header><div class="content"><p>See, I&#39;d wondered about that early on. But it didn&#39;t sound like this was a<br>restriction that could be formalized straightforwardly in the grammar.<br></p><p>Even if it could, it is too restrictive. Consider:<br></p><p>```<br>var previousInterestingFoo = 0<br></p><p>while let foo = sequence.next() where previousInterestingFoo &lt; 42 {<br>// determine if foo is interesting<br>// ...<br>if interesting {<br>previousInterestingFoo = foo<br>}<br>}<br>```<br></p><p>If we enforce a rule like you propose, then this example above, which<br>arguably does &quot;make sense contextually,&quot; would no longer be acceptable.<br></p><p>Switching gears to a different argument: this proposal aims (among other<br>things) to provide a way to make arbitrary Boolean assertions after a let<br>binding in situations where the use of `where` is currently required but<br>reads absurdly. Whatever alternative grammar is proposed for these<br>arbitrary Boolean assertions will, by construction, *always* be useful<br>regardless of the variables used in the assertion.<br></p><p>Thus, if we keep `where` and enforce your proposed rule, you end up with<br>two ways to express the same thing; `where` clauses would permit a strict<br>subset of assertions that can be expressed using the alternative syntax.<br>And, the compiler is conscripted to be an opinionated arbiter of style.<br>That&#39;s a huge no-go.<br></p><p>Or, you might say, &quot;I don&#39;t want to support arbitrary Boolean assertions<br>after let bindings at all!&quot; Well then, if we try to enforce your proposed<br>rule, then a user who wants to write `let y = y where x &lt; z` would be<br>driven to this gem of a workaround: `let y = y where (y == y &amp;&amp; x &lt; z)`.<br></p><p>These lines of reasoning are what have compelled me to conclude that<br>`where` might not be salvageable.<br></p><p>On Tue, May 31, 2016 at 13:04 Brandon Knope &lt;bknope at me.com&gt; wrote:<br></p><p>&gt; Except some of us have proposed only allowing unwrapped or newly bound<br>&gt; variables in the where clause:<br>&gt;<br>&gt; if let y = y where y &lt; z should work<br>&gt;<br>&gt; If let y = y where x &lt; z should be an error because it doesn&#39;t need to be<br>&gt; in a where clause and doesn&#39;t make sense contextually.<br>&gt;<br>&gt; I understand the rationale about why it should be removed...but I find it<br>&gt; a little extreme and a little &quot;technical&quot; to the point that some of the<br>&gt; personality of the language will be lost...all for the sake being<br>&gt; &quot;technically&quot; correct.<br>&gt;<br>&gt; This may be why some of us are against the proposal.<br>&gt;<br>&gt; Brandon<br>&gt;<br>&gt;<br>&gt; On May 31, 2016, at 1:16 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; The motivating example is a compelling illustration of a problem with the<br>&gt; current grammar. I don&#39;t think anyone would disagree that `if let y = y<br>&gt; where x &lt; z` is an abomination.<br>&gt;<br>&gt; Now, I see no principled criteria, and none have been proposed here, that<br>&gt; would be useful to restrict what can come after `where`. Moreover, I see no<br>&gt; contention with the argument that arbitrary Boolean assertions should be<br>&gt; possible after a let binding.<br>&gt;<br>&gt; Finally, it is a stated goal of the core team that there shouldn&#39;t be<br>&gt; multiple &#39;dialects&#39; of Swift, and that where possible there should be one<br>&gt; general solution rather than two options.<br>&gt;<br>&gt; Given these premises, I have to conclude that *if* the motivating issue is<br>&gt; to be fixed, we must get rid of `where`.<br>&gt;<br>&gt;<br>&gt; On Tue, May 31, 2016 at 11:53 Brandon Knope &lt;bknope at me.com&gt; wrote:<br>&gt;<br>&gt;&gt; To be frank, I just find the proposed syntax to be more ugly and less<br>&gt;&gt; expressive.<br>&gt;&gt;<br>&gt;&gt; I just don&#39;t find the proposal compelling enough to take away one of the<br>&gt;&gt; truly &quot;Swifty&quot; syntaxes that I have used and loved.<br>&gt;&gt;<br>&gt;&gt; If there are other ways to keep &quot;where&quot; while fixing the ambiguity I<br>&gt;&gt; would rather explore that than require semicolons everywhere.<br>&gt;&gt;<br>&gt;&gt; I have a feeling that more would object but just aren&#39;t perusing the<br>&gt;&gt; mailing lists. I think we will see much more activity come WWDC<br>&gt;&gt;<br>&gt;&gt; Brandon<br>&gt;&gt;<br>&gt;&gt; On May 31, 2016, at 12:25 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; In English (and, I&#39;m guessing, many other languages), semicolons are used<br>&gt;&gt; as a second &#39;tier&#39; of separators when commas become ambiguous. I&#39;m puzzled<br>&gt;&gt; that a proposal to bring this longstanding convention to Swift is raising<br>&gt;&gt; so many objections, even going so far as to prompt alternatives such as<br>&gt;&gt; this that break clearly useful shorthands.<br>&gt;&gt;<br>&gt;&gt; On Tue, May 31, 2016 at 10:44 David Hart via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Yet another alternative: would it be possible to disallow commas as<br>&gt;&gt;&gt; variable declaration separators and use them for condition clause<br>&gt;&gt;&gt; separators again:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let a = 4, b = 8 // becomes illegal and requires to separate them on two<br>&gt;&gt;&gt; lines<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; if a &gt; 4, let c = foo(), let d = bar(), c != d { // now comma is not<br>&gt;&gt;&gt; ambiguous anymore<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; David.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On 28 May 2016, at 02:30, Erica Sadun via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On May 27, 2016, at 6:26 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; guard<br>&gt;&gt;&gt; x == 0 &amp;&amp; a == b &amp;&amp; c == d &amp;&amp;<br>&gt;&gt;&gt; let y = optional, w = optional2, v = optional 3 &amp;&amp;<br>&gt;&gt;&gt; z == 2<br>&gt;&gt;&gt; else { ... }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Figuring out where to break the first line into expression and into<br>&gt;&gt;&gt; condition (after the `d`) could be very challenging to the compiler.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;m not sure it is. `let` and `case` are not valid in an expression, so<br>&gt;&gt;&gt; an `&amp;&amp;` followed by `let` or `case` must be joining clauses. On the other<br>&gt;&gt;&gt; side of things, Swift&#39;s `&amp;&amp;` doesn&#39;t ever produce an optional, so if we&#39;re<br>&gt;&gt;&gt; parsing an expression at the top level of an if-let, an `&amp;&amp;` must indicate<br>&gt;&gt;&gt; the end of the clause. An if-case *could* theoretically include an `&amp;&amp;`,<br>&gt;&gt;&gt; but pattern matching against a boolean value seems like a fairly useless<br>&gt;&gt;&gt; thing to do in a context that&#39;s specifically intended to test booleans.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Let me answer in another way that speaks to my background which isn&#39;t in<br>&gt;&gt;&gt; compiler theory: The use of &amp;&amp; may produce cognitive overload between the<br>&gt;&gt;&gt; use in Boolean assertions and the use in separating condition clauses.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -- E<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/a857d7b4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>May 31, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On May 31, 2016, at 12:52 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; These lines of reasoning are what have compelled me to conclude that `where` might not be salvageable.<br></p><p>To which, I&#39;d add: `where` suggests there&#39;s a subordinate and semantic relationship between the primary condition and the clause. There&#39;s no way as far as I know this to enforce it in the grammar and the proposal allows both clauses to be stated even without the connecting word. You could make a vague argument, I suppose, for renaming `where` to `when` but all in all, even killing `where` we benefit with better expressive capabilities and a simpler grammar.<br></p><p>-- E<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/de0d5be6d0a7b6ccb5f061ab3d9fa25f?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Christopher Kornher</string> &lt;ckornher at mac.com&gt;<p>May 31, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On May 31, 2016, at 1:00 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 31, 2016, at 12:52 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt; These lines of reasoning are what have compelled me to conclude that `where` might not be salvageable.<br>&gt; <br>&gt; To which, I&#39;d add: `where` suggests there&#39;s a subordinate and semantic relationship between the primary condition and the clause. There&#39;s no way as far as I know this to enforce it in the grammar and the proposal allows both clauses to be stated even without the connecting word.<br></p><p>OK. I am naive enough to try to informally define a rule that would make “where” required and cover all (?) cases in the proposal:<br></p><p>‘where’ is required after an if-let for any clause involving a variable or constant defined in that &#39;if let. All boolean expressions after the ‘where’ must reference at least one of constants defined by the ‘if let&#39;<br></p><p>Allowed:<br></p><p>let a = a, b=b where b &gt; 10 &amp;&amp; a &gt; 5 &amp;&amp; b&gt; a<br></p><p><br>Not allowed:<br>…<br>let a = a<br>let b = b where b &gt; 10 &amp;&amp; a &gt; 5<br>b &gt; a<br>...<br></p><p>…<br>let a = a<br>let b = b where b &gt; 10<br>a &gt; 5<br>b &gt; a<br>…<br></p><p>This requires the use of commas because all inter-related ‘if let’ constants must be associated with a single ‘where&#39;<br></p><p>This makes the use of ‘&amp;&amp;’ more natural, since everything to the right of “where” is a boolean expression<br></p><p>The formal grammar is left as an exercise :)<br></p><p>The downside:<br></p><p>	I would not have to answer all the ‘Why won’t this compile?’ questions on stack overflow. Of course, I would not want to do that for the current syntax, either.<br></p><p><br>&gt; You could make a vague argument, I suppose, for renaming `where` to `when` but all in all, even killing `where` we benefit with better expressive capabilities and a simpler grammar.<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May 31, 2016 at 02:00:00pm</p></header><div class="content"><p>On Tue, May 31, 2016 at 2:32 PM, Christopher Kornher via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On May 31, 2016, at 1:00 PM, Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On May 31, 2016, at 12:52 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; &gt;&gt; These lines of reasoning are what have compelled me to conclude that<br>&gt; `where` might not be salvageable.<br>&gt; &gt;<br>&gt; &gt; To which, I&#39;d add: `where` suggests there&#39;s a subordinate and semantic<br>&gt; relationship between the primary condition and the clause. There&#39;s no way<br>&gt; as far as I know this to enforce it in the grammar and the proposal allows<br>&gt; both clauses to be stated even without the connecting word.<br>&gt;<br>&gt; OK. I am naive enough to try to informally define a rule that would make<br>&gt; “where” required and cover all (?) cases in the proposal:<br>&gt;<br>&gt; ‘where’ is required after an if-let for any clause involving a variable or<br>&gt; constant defined in that &#39;if let. All boolean expressions after the ‘where’<br>&gt; must reference at least one of constants defined by the ‘if let&#39;<br>&gt;<br>&gt; Allowed:<br>&gt;<br>&gt; let a = a, b=b where b &gt; 10 &amp;&amp; a &gt; 5 &amp;&amp; b&gt; a<br>&gt;<br>&gt;<br>&gt; Not allowed:<br>&gt; …<br>&gt; let a = a<br>&gt; let b = b where b &gt; 10 &amp;&amp; a &gt; 5<br>&gt;<br></p><p>Why would this not be allowed by your rule? You&#39;re making use of `b` in<br>your where clause. As I demonstrated above, essentially any assertion can<br>be rewritten to work around your rule. In general:<br></p><p>```<br>let y = y where x &lt; z<br>```<br></p><p>can be trivially (and awfully) rewritten as<br></p><p>```<br>let y = y where (y.dynamicType == y.dynamicType &amp;&amp; x &lt; z)<br>```<br></p><p><br></p><p>&gt; b &gt; a<br>&gt; ...<br>&gt;<br>&gt; …<br>&gt; let a = a<br>&gt; let b = b where b &gt; 10<br>&gt; a &gt; 5<br>&gt; b &gt; a<br>&gt; …<br>&gt;<br>&gt; This requires the use of commas because all inter-related ‘if let’<br>&gt; constants must be associated with a single ‘where&#39;<br>&gt;<br>&gt; This makes the use of ‘&amp;&amp;’ more natural, since everything to the right of<br>&gt; “where” is a boolean expression<br>&gt;<br>&gt; The formal grammar is left as an exercise :)<br>&gt;<br>&gt; The downside:<br>&gt;<br>&gt;         I would not have to answer all the ‘Why won’t this compile?’<br>&gt; questions on stack overflow. Of course, I would not want to do that for the<br>&gt; current syntax, either.<br>&gt;<br>&gt;<br>&gt; &gt; You could make a vague argument, I suppose, for renaming `where` to<br>&gt; `when` but all in all, even killing `where` we benefit with better<br>&gt; expressive capabilities and a simpler grammar.<br>&gt; &gt;<br>&gt; &gt; -- E<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/ecace298/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/de0d5be6d0a7b6ccb5f061ab3d9fa25f?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Christopher Kornher</string> &lt;ckornher at mac.com&gt;<p>May 31, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; <br>&gt; Not allowed:<br>&gt; …<br>&gt; let a = a<br>&gt; let b = b where b &gt; 10 &amp;&amp; a &gt; 5<br>&gt; <br>&gt; Why would this not be allowed by your rule? You&#39;re making use of `b` in your where clause. As I demonstrated above, essentially any assertion can be rewritten to work around your rule. In general:<br></p><p>It is not allowed because  ‘a’ is defined in the line above. It must be defined in the ‘if let’ associated with the where in which it is mentioned.<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/8986cccb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May 31, 2016 at 02:00:00pm</p></header><div class="content"><p>On Tue, May 31, 2016 at 2:45 PM, Christopher Kornher via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt;&gt; Not allowed:<br>&gt;&gt; …<br>&gt;&gt; let a = a<br>&gt;&gt; let b = b where b &gt; 10 &amp;&amp; a &gt; 5<br>&gt;&gt;<br>&gt;<br>&gt; Why would this not be allowed by your rule? You&#39;re making use of `b` in<br>&gt; your where clause. As I demonstrated above, essentially any assertion can<br>&gt; be rewritten to work around your rule. In general:<br>&gt;<br>&gt;<br>&gt; It is not allowed because  ‘a’ is defined in the line above. It must be<br>&gt; defined in the ‘if let’ associated with the where in which it is mentioned.<br>&gt;<br></p><p>That&#39;s a much more restrictive where clause than you proposed earlier.<br>You&#39;d not be able to write:<br></p><p>```<br>let b = b where b &gt; anyOtherVariable<br>```<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/8afed4b1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/de0d5be6d0a7b6ccb5f061ab3d9fa25f?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Christopher Kornher</string> &lt;ckornher at mac.com&gt;<p>May 31, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On May 31, 2016, at 1:47 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Tue, May 31, 2016 at 2:45 PM, Christopher Kornher via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Not allowed:<br>&gt;&gt; …<br>&gt;&gt; let a = a<br>&gt;&gt; let b = b where b &gt; 10 &amp;&amp; a &gt; 5<br>&gt;&gt; <br>&gt;&gt; Why would this not be allowed by your rule? You&#39;re making use of `b` in your where clause. As I demonstrated above, essentially any assertion can be rewritten to work around your rule. In general:<br>&gt; <br>&gt; It is not allowed because  ‘a’ is defined in the line above. It must be defined in the ‘if let’ associated with the where in which it is mentioned.<br>&gt; <br>&gt; That&#39;s a much more restrictive where clause than you proposed earlier. You&#39;d not be able to write:<br>&gt; <br>&gt; ```<br>&gt; let b = b where b &gt; anyOtherVariable<br>&gt; ```<br></p><p><br>The definition is not a formal one, but that was the intent.<br></p><p>```<br>let b = b where b &gt; anyOtherVariable<br>```<br>is legal as long as `anyOtherVariable` is not defined within the entire condition clause<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/cdab275e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May 31, 2016 at 02:00:00pm</p></header><div class="content"><p>On Tue, May 31, 2016 at 2:51 PM, Christopher Kornher via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On May 31, 2016, at 1:47 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Tue, May 31, 2016 at 2:45 PM, Christopher Kornher via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; Not allowed:<br>&gt;&gt;&gt; …<br>&gt;&gt;&gt; let a = a<br>&gt;&gt;&gt; let b = b where b &gt; 10 &amp;&amp; a &gt; 5<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Why would this not be allowed by your rule? You&#39;re making use of `b` in<br>&gt;&gt; your where clause. As I demonstrated above, essentially any assertion can<br>&gt;&gt; be rewritten to work around your rule. In general:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; It is not allowed because  ‘a’ is defined in the line above. It must be<br>&gt;&gt; defined in the ‘if let’ associated with the where in which it is mentioned.<br>&gt;&gt;<br>&gt;<br>&gt; That&#39;s a much more restrictive where clause than you proposed earlier.<br>&gt; You&#39;d not be able to write:<br>&gt;<br>&gt; ```<br>&gt; let b = b where b &gt; anyOtherVariable<br>&gt; ```<br>&gt;<br>&gt;<br>&gt; The definition is not a formal one, but that was the intent.<br>&gt;<br>&gt; ```<br>&gt; let b = b where b &gt; anyOtherVariable<br>&gt; ```<br>&gt;<br>&gt; is legal as long as `anyOtherVariable` is not defined within the entire<br>&gt; condition clause<br>&gt;<br></p><p><br>You can propose that rule, but it doesn&#39;t solve the issue. If, today, I&#39;ve<br>got<br></p><p>```<br>let x = 1<br>let y: Int? = 2<br>let z = 3<br></p><p>if let y = y where x &lt; z {<br>  // do stuff<br>}<br>```<br></p><p>your rule simply forces<br></p><p>```<br>if let y = y where y == y &amp;&amp; x &lt; z {<br>  // do stuff<br>}<br>```<br></p><p>The point is, the semantic relationship between what comes before and after<br>`where` exists in the mind of the human reader only.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/6011a8b6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/de0d5be6d0a7b6ccb5f061ab3d9fa25f?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Christopher Kornher</string> &lt;ckornher at mac.com&gt;<p>May 31, 2016 at 02:00:00pm</p></header><div class="content"><p>I should have left the entire context in my reply.<br></p><p><br>&gt; On May 31, 2016, at 1:59 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Tue, May 31, 2016 at 2:51 PM, Christopher Kornher via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On May 31, 2016, at 1:47 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Tue, May 31, 2016 at 2:45 PM, Christopher Kornher via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Not allowed:<br>&gt;&gt;&gt; …<br>&gt;&gt;&gt; let a = a<br>&gt;&gt;&gt; let b = b where b &gt; 10 &amp;&amp; a &gt; 5<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Why would this not be allowed by your rule? You&#39;re making use of `b` in your where clause. As I demonstrated above, essentially any assertion can be rewritten to work around your rule. In general:<br>&gt;&gt; <br>&gt;&gt; It is not allowed because  ‘a’ is defined in the line above. It must be defined in the ‘if let’ associated with the where in which it is mentioned.<br>&gt;&gt; <br>&gt;&gt; That&#39;s a much more restrictive where clause than you proposed earlier. You&#39;d not be able to write:<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; let b = b where b &gt; anyOtherVariable<br>&gt;&gt; ```<br>&gt; <br>&gt; <br>&gt; The definition is not a formal one, but that was the intent.<br>&gt; <br>&gt; ```<br>&gt; let b = b where b &gt; anyOtherVariable<br>&gt; ```<br>&gt; is legal as long as `anyOtherVariable` is not defined within the entire condition clause<br>&gt; <br>&gt; <br>&gt; You can propose that rule, but it doesn&#39;t solve the issue. If, today, I&#39;ve got<br>&gt; <br>&gt; ```<br>&gt; let x = 1<br>&gt; let y: Int? = 2<br>&gt; let z = 3<br>&gt; <br>&gt; if let y = y where x &lt; z {<br>&gt;   // do stuff<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; your rule simply forces<br>&gt; <br>&gt; ```<br>&gt; if let y = y where y == y &amp;&amp; x &lt; z {<br>&gt;   // do stuff<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; The point is, the semantic relationship between what comes before and after `where` exists in the mind of the human reader only.<br></p><p>I meant to add that all boolean expressions after the where must use one of the constants defined in the associated `if let` so the `&amp;&amp; x &lt; z` would not be allowed.<br></p><p>I don’t understand the &#39;y == y’ in your example<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/f0532b1d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9ce70a6cb7175e7a5e5db5658186a31?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Brandon Knope</string> &lt;bknope at me.com&gt;<p>May 31, 2016 at 04:00:00pm</p></header><div class="content"><p>The y == y I presume is to get around this requirement by reintroducing a variable in the previous part of the conditional to be able to refer to other variables. <br></p><p>x &gt; z isn&#39;t allowed, but y == y &amp;&amp; x &gt; z would be because it&#39;s using y. <br></p><p>I&#39;m not convinced anyone would do this when they could just &amp;&amp; x &gt; z anyways <br></p><p>Brandon <br></p><p>&gt; On May 31, 2016, at 4:06 PM, Christopher Kornher via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I should have left the entire context in my reply.<br>&gt; <br>&gt; <br>&gt;&gt; On May 31, 2016, at 1:59 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Tue, May 31, 2016 at 2:51 PM, Christopher Kornher via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 31, 2016, at 1:47 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Tue, May 31, 2016 at 2:45 PM, Christopher Kornher via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Not allowed:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; …<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let a = a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let b = b where b &gt; 10 &amp;&amp; a &gt; 5<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Why would this not be allowed by your rule? You&#39;re making use of `b` in your where clause. As I demonstrated above, essentially any assertion can be rewritten to work around your rule. In general:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It is not allowed because  ‘a’ is defined in the line above. It must be defined in the ‘if let’ associated with the where in which it is mentioned.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That&#39;s a much more restrictive where clause than you proposed earlier. You&#39;d not be able to write:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; let b = b where b &gt; anyOtherVariable<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The definition is not a formal one, but that was the intent.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; let b = b where b &gt; anyOtherVariable<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; is legal as long as `anyOtherVariable` is not defined within the entire condition clause<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; You can propose that rule, but it doesn&#39;t solve the issue. If, today, I&#39;ve got<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; let x = 1<br>&gt;&gt; let y: Int? = 2<br>&gt;&gt; let z = 3<br>&gt;&gt; <br>&gt;&gt; if let y = y where x &lt; z {<br>&gt;&gt;   // do stuff<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; your rule simply forces<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; if let y = y where y == y &amp;&amp; x &lt; z {<br>&gt;&gt;   // do stuff<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; The point is, the semantic relationship between what comes before and after `where` exists in the mind of the human reader only.<br>&gt; <br>&gt; I meant to add that all boolean expressions after the where must use one of the constants defined in the associated `if let` so the `&amp;&amp; x &lt; z` would not be allowed.<br>&gt; <br>&gt; I don’t understand the &#39;y == y’ in your example<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/e9b63138/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9ce70a6cb7175e7a5e5db5658186a31?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Brandon Knope</string> &lt;bknope at me.com&gt;<p>May 31, 2016 at 04:00:00pm</p></header><div class="content"><p>What is wrong with:<br></p><p>if let y = y &amp;&amp; x &lt; z<br></p><p>They are, after all, independent from each other. <br></p><p>Brandon <br></p><p>&gt; On May 31, 2016, at 3:59 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Tue, May 31, 2016 at 2:51 PM, Christopher Kornher via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 31, 2016, at 1:47 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Tue, May 31, 2016 at 2:45 PM, Christopher Kornher via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Not allowed:<br>&gt;&gt;&gt;&gt;&gt;&gt; …<br>&gt;&gt;&gt;&gt;&gt;&gt; let a = a<br>&gt;&gt;&gt;&gt;&gt;&gt; let b = b where b &gt; 10 &amp;&amp; a &gt; 5<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Why would this not be allowed by your rule? You&#39;re making use of `b` in your where clause. As I demonstrated above, essentially any assertion can be rewritten to work around your rule. In general:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It is not allowed because  ‘a’ is defined in the line above. It must be defined in the ‘if let’ associated with the where in which it is mentioned.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That&#39;s a much more restrictive where clause than you proposed earlier. You&#39;d not be able to write:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; let b = b where b &gt; anyOtherVariable<br>&gt;&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; The definition is not a formal one, but that was the intent.<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; let b = b where b &gt; anyOtherVariable<br>&gt;&gt; ```<br>&gt;&gt; is legal as long as `anyOtherVariable` is not defined within the entire condition clause<br>&gt; <br>&gt; <br>&gt; You can propose that rule, but it doesn&#39;t solve the issue. If, today, I&#39;ve got<br>&gt; <br>&gt; ```<br>&gt; let x = 1<br>&gt; let y: Int? = 2<br>&gt; let z = 3<br>&gt; <br>&gt; if let y = y where x &lt; z {<br>&gt;   // do stuff<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; your rule simply forces<br>&gt; <br>&gt; ```<br>&gt; if let y = y where y == y &amp;&amp; x &lt; z {<br>&gt;   // do stuff<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; The point is, the semantic relationship between what comes before and after `where` exists in the mind of the human reader only.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/1fffe6e2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May 31, 2016 at 03:00:00pm</p></header><div class="content"><p>On Tue, May 31, 2016 at 3:08 PM, Brandon Knope &lt;bknope at me.com&gt; wrote:<br></p><p>&gt; What is wrong with:<br>&gt;<br>&gt; if let y = y &amp;&amp; x &lt; z<br>&gt;<br>&gt; They are, after all, independent from each other.<br>&gt;<br></p><p>That won&#39;t compile.<br></p><p><br>Brandon<br>&gt;<br>&gt; On May 31, 2016, at 3:59 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Tue, May 31, 2016 at 2:51 PM, Christopher Kornher via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On May 31, 2016, at 1:47 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Tue, May 31, 2016 at 2:45 PM, Christopher Kornher via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Not allowed:<br>&gt;&gt;&gt;&gt; …<br>&gt;&gt;&gt;&gt; let a = a<br>&gt;&gt;&gt;&gt; let b = b where b &gt; 10 &amp;&amp; a &gt; 5<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Why would this not be allowed by your rule? You&#39;re making use of `b` in<br>&gt;&gt;&gt; your where clause. As I demonstrated above, essentially any assertion can<br>&gt;&gt;&gt; be rewritten to work around your rule. In general:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It is not allowed because  ‘a’ is defined in the line above. It must be<br>&gt;&gt;&gt; defined in the ‘if let’ associated with the where in which it is mentioned.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; That&#39;s a much more restrictive where clause than you proposed earlier.<br>&gt;&gt; You&#39;d not be able to write:<br>&gt;&gt;<br>&gt;&gt; ```<br>&gt;&gt; let b = b where b &gt; anyOtherVariable<br>&gt;&gt; ```<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; The definition is not a formal one, but that was the intent.<br>&gt;&gt;<br>&gt;&gt; ```<br>&gt;&gt; let b = b where b &gt; anyOtherVariable<br>&gt;&gt; ```<br>&gt;&gt;<br>&gt;&gt; is legal as long as `anyOtherVariable` is not defined within the entire<br>&gt;&gt; condition clause<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; You can propose that rule, but it doesn&#39;t solve the issue. If, today, I&#39;ve<br>&gt; got<br>&gt;<br>&gt; ```<br>&gt; let x = 1<br>&gt; let y: Int? = 2<br>&gt; let z = 3<br>&gt;<br>&gt; if let y = y where x &lt; z {<br>&gt;   // do stuff<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; your rule simply forces<br>&gt;<br>&gt; ```<br>&gt; if let y = y where y == y &amp;&amp; x &lt; z {<br>&gt;   // do stuff<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; The point is, the semantic relationship between what comes before and<br>&gt; after `where` exists in the mind of the human reader only.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/f08e138d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9ce70a6cb7175e7a5e5db5658186a31?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Brandon Knope</string> &lt;bknope at me.com&gt;<p>May 31, 2016 at 04:00:00pm</p></header><div class="content"><p>And why couldn&#39;t we propose that it should?<br></p><p>Brandon <br></p><p>&gt; On May 31, 2016, at 4:14 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Tue, May 31, 2016 at 3:08 PM, Brandon Knope &lt;bknope at me.com&gt; wrote:<br>&gt;&gt; What is wrong with:<br>&gt;&gt; <br>&gt;&gt; if let y = y &amp;&amp; x &lt; z<br>&gt;&gt; <br>&gt;&gt; They are, after all, independent from each other.<br>&gt; <br>&gt; That won&#39;t compile.<br>&gt;  <br>&gt; <br>&gt;&gt; Brandon <br>&gt;&gt; <br>&gt;&gt;&gt; On May 31, 2016, at 3:59 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Tue, May 31, 2016 at 2:51 PM, Christopher Kornher via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 31, 2016, at 1:47 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Tue, May 31, 2016 at 2:45 PM, Christopher Kornher via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Not allowed:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; …<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let a = a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let b = b where b &gt; 10 &amp;&amp; a &gt; 5<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Why would this not be allowed by your rule? You&#39;re making use of `b` in your where clause. As I demonstrated above, essentially any assertion can be rewritten to work around your rule. In general:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It is not allowed because  ‘a’ is defined in the line above. It must be defined in the ‘if let’ associated with the where in which it is mentioned.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That&#39;s a much more restrictive where clause than you proposed earlier. You&#39;d not be able to write:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt; let b = b where b &gt; anyOtherVariable<br>&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The definition is not a formal one, but that was the intent.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; let b = b where b &gt; anyOtherVariable<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; is legal as long as `anyOtherVariable` is not defined within the entire condition clause<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You can propose that rule, but it doesn&#39;t solve the issue. If, today, I&#39;ve got<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; let x = 1<br>&gt;&gt;&gt; let y: Int? = 2<br>&gt;&gt;&gt; let z = 3<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; if let y = y where x &lt; z {<br>&gt;&gt;&gt;   // do stuff<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; your rule simply forces<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; if let y = y where y == y &amp;&amp; x &lt; z {<br>&gt;&gt;&gt;   // do stuff<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The point is, the semantic relationship between what comes before and after `where` exists in the mind of the human reader only.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/77455ccd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May 31, 2016 at 03:00:00pm</p></header><div class="content"><p>On Tue, May 31, 2016 at 3:16 PM, Brandon Knope &lt;bknope at me.com&gt; wrote:<br></p><p>&gt; And why couldn&#39;t we propose that it should?<br>&gt;<br></p><p>And that is this proposal; the options considered for the spelling are<br>comma, semicolon, and `&amp;&amp;`.<br></p><p>Now we circle back to my earlier point. The introduction of any of these<br>would argue for the elimination of `where`, for the reasons I&#39;ve stated<br>above. Briefly, everything that can be expressed using `where` could be<br>expressed using the comma, semicolon, or `&amp;&amp;`. Since there is no good way<br>to enforce the semantic relationship requirement for `where`, only a proxy<br>rule about variable names can be contemplated, which as I&#39;ve demonstrated<br>is ineffective.<br></p><p>If you&#39;re asking why commas or semicolons have been proposed instead of<br>`&amp;&amp;`, that argument has been made above by others.<br></p><p><br>Brandon<br>&gt;<br>&gt; On May 31, 2016, at 4:14 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Tue, May 31, 2016 at 3:08 PM, Brandon Knope &lt;bknope at me.com&gt; wrote:<br>&gt;<br>&gt;&gt; What is wrong with:<br>&gt;&gt;<br>&gt;&gt; if let y = y &amp;&amp; x &lt; z<br>&gt;&gt;<br>&gt;&gt; They are, after all, independent from each other.<br>&gt;&gt;<br>&gt;<br>&gt; That won&#39;t compile.<br>&gt;<br>&gt;<br>&gt; Brandon<br>&gt;&gt;<br>&gt;&gt; On May 31, 2016, at 3:59 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Tue, May 31, 2016 at 2:51 PM, Christopher Kornher via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On May 31, 2016, at 1:47 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Tue, May 31, 2016 at 2:45 PM, Christopher Kornher via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Not allowed:<br>&gt;&gt;&gt;&gt;&gt; …<br>&gt;&gt;&gt;&gt;&gt; let a = a<br>&gt;&gt;&gt;&gt;&gt; let b = b where b &gt; 10 &amp;&amp; a &gt; 5<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Why would this not be allowed by your rule? You&#39;re making use of `b` in<br>&gt;&gt;&gt;&gt; your where clause. As I demonstrated above, essentially any assertion can<br>&gt;&gt;&gt;&gt; be rewritten to work around your rule. In general:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; It is not allowed because  ‘a’ is defined in the line above. It must be<br>&gt;&gt;&gt;&gt; defined in the ‘if let’ associated with the where in which it is mentioned.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; That&#39;s a much more restrictive where clause than you proposed earlier.<br>&gt;&gt;&gt; You&#39;d not be able to write:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; let b = b where b &gt; anyOtherVariable<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The definition is not a formal one, but that was the intent.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; let b = b where b &gt; anyOtherVariable<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; is legal as long as `anyOtherVariable` is not defined within the entire<br>&gt;&gt;&gt; condition clause<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; You can propose that rule, but it doesn&#39;t solve the issue. If, today,<br>&gt;&gt; I&#39;ve got<br>&gt;&gt;<br>&gt;&gt; ```<br>&gt;&gt; let x = 1<br>&gt;&gt; let y: Int? = 2<br>&gt;&gt; let z = 3<br>&gt;&gt;<br>&gt;&gt; if let y = y where x &lt; z {<br>&gt;&gt;   // do stuff<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt;<br>&gt;&gt; your rule simply forces<br>&gt;&gt;<br>&gt;&gt; ```<br>&gt;&gt; if let y = y where y == y &amp;&amp; x &lt; z {<br>&gt;&gt;   // do stuff<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt;<br>&gt;&gt; The point is, the semantic relationship between what comes before and<br>&gt;&gt; after `where` exists in the mind of the human reader only.<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/42bd0a3f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9ce70a6cb7175e7a5e5db5658186a31?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Brandon Knope</string> &lt;bknope at me.com&gt;<p>May 31, 2016 at 04:00:00pm</p></header><div class="content"><p>Why would that argue for the removal of where<br></p><p>if let y = y where y != 5 &amp;&amp; x &lt; z<br></p><p>I would still prefer:<br>if let y = y where y != 5, x &lt; z, let z = someOptional where z == 10<br></p><p>To me, where still has a place. And that place is saying &quot;hey this is a recently introduced or shadowed variable, so don&#39;t go looking very far for what is referring to&quot;. <br></p><p>If I understand correctly, this would be rewritten in the proposed syntax as:<br></p><p>if let y = y; y != 5; x &lt; z; let z = someOptional; z == 10 { }<br></p><p>Which technically could be written as:<br></p><p>if let y = y; x &lt; z; let z = someOptional; z == 10; y != 5 { } // y != 5 arbitrarily moved to the end <br></p><p>Now y != 5 is at the end and a quick glimpse of this line could be confusing:<br>1. Is this y a previous variable like x is?<br>2. Is it a shadowed variable?<br></p><p>This kind of information is lost while glancing the line (and people do glance especially with long conditional clauses). This makes having where relevant in my opinion. It aids in readability and expressiveness. <br></p><p>Brandon <br></p><p><br></p><p><br>&gt; On May 31, 2016, at 4:25 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Tue, May 31, 2016 at 3:16 PM, Brandon Knope &lt;bknope at me.com&gt; wrote:<br>&gt;&gt; And why couldn&#39;t we propose that it should?<br>&gt; <br>&gt; And that is this proposal; the options considered for the spelling are comma, semicolon, and `&amp;&amp;`.<br>&gt; <br>&gt; Now we circle back to my earlier point. The introduction of any of these would argue for the elimination of `where`, for the reasons I&#39;ve stated above. Briefly, everything that can be expressed using `where` could be expressed using the comma, semicolon, or `&amp;&amp;`. Since there is no good way to enforce the semantic relationship requirement for `where`, only a proxy rule about variable names can be contemplated, which as I&#39;ve demonstrated is ineffective.<br>&gt; <br>&gt; If you&#39;re asking why commas or semicolons have been proposed instead of `&amp;&amp;`, that argument has been made above by others.<br>&gt; <br>&gt; <br>&gt;&gt; Brandon <br>&gt;&gt; <br>&gt;&gt;&gt; On May 31, 2016, at 4:14 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Tue, May 31, 2016 at 3:08 PM, Brandon Knope &lt;bknope at me.com&gt; wrote:<br>&gt;&gt;&gt;&gt; What is wrong with:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; if let y = y &amp;&amp; x &lt; z<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; They are, after all, independent from each other.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That won&#39;t compile.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Brandon <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 31, 2016, at 3:59 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Tue, May 31, 2016 at 2:51 PM, Christopher Kornher via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 31, 2016, at 1:47 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Tue, May 31, 2016 at 2:45 PM, Christopher Kornher via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Not allowed:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; …<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let a = a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let b = b where b &gt; 10 &amp;&amp; a &gt; 5<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Why would this not be allowed by your rule? You&#39;re making use of `b` in your where clause. As I demonstrated above, essentially any assertion can be rewritten to work around your rule. In general:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It is not allowed because  ‘a’ is defined in the line above. It must be defined in the ‘if let’ associated with the where in which it is mentioned.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; That&#39;s a much more restrictive where clause than you proposed earlier. You&#39;d not be able to write:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let b = b where b &gt; anyOtherVariable<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The definition is not a formal one, but that was the intent.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt; let b = b where b &gt; anyOtherVariable<br>&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt; is legal as long as `anyOtherVariable` is not defined within the entire condition clause<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; You can propose that rule, but it doesn&#39;t solve the issue. If, today, I&#39;ve got<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt; let x = 1<br>&gt;&gt;&gt;&gt;&gt; let y: Int? = 2<br>&gt;&gt;&gt;&gt;&gt; let z = 3<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; if let y = y where x &lt; z {<br>&gt;&gt;&gt;&gt;&gt;   // do stuff<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; your rule simply forces<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt; if let y = y where y == y &amp;&amp; x &lt; z {<br>&gt;&gt;&gt;&gt;&gt;   // do stuff<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The point is, the semantic relationship between what comes before and after `where` exists in the mind of the human reader only.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/6c41c624/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May 31, 2016 at 03:00:00pm</p></header><div class="content"><p>On Tue, May 31, 2016 at 3:43 PM, Brandon Knope &lt;bknope at me.com&gt; wrote:<br></p><p>&gt; Why would that argue for the removal of where<br>&gt;<br>&gt; if let y = y where y != 5 &amp;&amp; x &lt; z<br>&gt;<br>&gt; I would still prefer:<br>&gt; if let y = y where y != 5, x &lt; z, let z = someOptional where z == 10<br>&gt;<br>&gt; To me, where still has a place. And that place is saying &quot;hey this is a<br>&gt; recently introduced or shadowed variable, so don&#39;t go looking very far for<br>&gt; what is referring to&quot;.<br>&gt;<br>&gt; If I understand correctly, this would be rewritten in the proposed syntax<br>&gt; as:<br>&gt;<br>&gt; if let y = y; y != 5; x &lt; z; let z = someOptional; z == 10 { }<br>&gt;<br>&gt; Which technically could be written as:<br>&gt;<br>&gt; if let y = y; x &lt; z; let z = someOptional; z == 10; y != 5 { } // y != 5<br>&gt; arbitrarily moved to the end<br>&gt;<br>&gt; Now y != 5 is at the end and a quick glimpse of this line could be<br>&gt; confusing:<br>&gt; 1. Is this y a previous variable like x is?<br>&gt; 2. Is it a shadowed variable?<br>&gt;<br></p><p><br>Sure; but as has been mentioned on this list before, these concerns about<br>style are what linters are for, not the compiler.<br></p><p><br>&gt;<br>&gt; This kind of information is lost while glancing the line (and people do<br>&gt; glance especially with long conditional clauses). This makes having where<br>&gt; relevant in my opinion. It aids in readability and expressiveness.<br>&gt;<br>&gt; Brandon<br>&gt;<br>&gt;<br>&gt; On May 31, 2016, at 4:25 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Tue, May 31, 2016 at 3:16 PM, Brandon Knope &lt;bknope at me.com&gt; wrote:<br>&gt;<br>&gt;&gt; And why couldn&#39;t we propose that it should?<br>&gt;&gt;<br>&gt;<br>&gt; And that is this proposal; the options considered for the spelling are<br>&gt; comma, semicolon, and `&amp;&amp;`.<br>&gt;<br>&gt; Now we circle back to my earlier point. The introduction of any of these<br>&gt; would argue for the elimination of `where`, for the reasons I&#39;ve stated<br>&gt; above. Briefly, everything that can be expressed using `where` could be<br>&gt; expressed using the comma, semicolon, or `&amp;&amp;`. Since there is no good way<br>&gt; to enforce the semantic relationship requirement for `where`, only a proxy<br>&gt; rule about variable names can be contemplated, which as I&#39;ve demonstrated<br>&gt; is ineffective.<br>&gt;<br>&gt; If you&#39;re asking why commas or semicolons have been proposed instead of<br>&gt; `&amp;&amp;`, that argument has been made above by others.<br>&gt;<br>&gt;<br>&gt; Brandon<br>&gt;&gt;<br>&gt;&gt; On May 31, 2016, at 4:14 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Tue, May 31, 2016 at 3:08 PM, Brandon Knope &lt;bknope at me.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; What is wrong with:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; if let y = y &amp;&amp; x &lt; z<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; They are, after all, independent from each other.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; That won&#39;t compile.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Brandon<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On May 31, 2016, at 3:59 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Tue, May 31, 2016 at 2:51 PM, Christopher Kornher via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On May 31, 2016, at 1:47 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Tue, May 31, 2016 at 2:45 PM, Christopher Kornher via<br>&gt;&gt;&gt;&gt; swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Not allowed:<br>&gt;&gt;&gt;&gt;&gt;&gt; …<br>&gt;&gt;&gt;&gt;&gt;&gt; let a = a<br>&gt;&gt;&gt;&gt;&gt;&gt; let b = b where b &gt; 10 &amp;&amp; a &gt; 5<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Why would this not be allowed by your rule? You&#39;re making use of `b`<br>&gt;&gt;&gt;&gt;&gt; in your where clause. As I demonstrated above, essentially any assertion<br>&gt;&gt;&gt;&gt;&gt; can be rewritten to work around your rule. In general:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; It is not allowed because  ‘a’ is defined in the line above. It must<br>&gt;&gt;&gt;&gt;&gt; be defined in the ‘if let’ associated with the where in which it is<br>&gt;&gt;&gt;&gt;&gt; mentioned.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; That&#39;s a much more restrictive where clause than you proposed earlier.<br>&gt;&gt;&gt;&gt; You&#39;d not be able to write:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; let b = b where b &gt; anyOtherVariable<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The definition is not a formal one, but that was the intent.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; let b = b where b &gt; anyOtherVariable<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; is legal as long as `anyOtherVariable` is not defined within the entire<br>&gt;&gt;&gt;&gt; condition clause<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; You can propose that rule, but it doesn&#39;t solve the issue. If, today,<br>&gt;&gt;&gt; I&#39;ve got<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; let x = 1<br>&gt;&gt;&gt; let y: Int? = 2<br>&gt;&gt;&gt; let z = 3<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; if let y = y where x &lt; z {<br>&gt;&gt;&gt;   // do stuff<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; your rule simply forces<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; if let y = y where y == y &amp;&amp; x &lt; z {<br>&gt;&gt;&gt;   // do stuff<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The point is, the semantic relationship between what comes before and<br>&gt;&gt;&gt; after `where` exists in the mind of the human reader only.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/cfd4dcfb/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9ce70a6cb7175e7a5e5db5658186a31?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Brandon Knope</string> &lt;bknope at me.com&gt;<p>May 31, 2016 at 03:00:00pm</p></header><div class="content"><p>Except &quot;b&quot; is the main focus of the where clause and b was just in the preceding if condition. <br></p><p>I feel like we are trying to find ways to break the current where clause even though we&#39;ve enjoyed it for almost a year now. I had no idea it was problematic and restrictive. I thought it made its intent very clear...leading to very readable code. <br></p><p>Pretty soon almost every construct but conditionals will be allowed to have where clauses, and THAT seems inconsistent to me. <br></p><p>...what exactly is the current problem? Can someone show me a real world example?? I&#39;ve already forgotten it in all of this discussion -_-<br></p><p>Brandon <br></p><p>&gt; On May 31, 2016, at 3:47 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Tue, May 31, 2016 at 2:45 PM, Christopher Kornher via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Not allowed:<br>&gt;&gt;&gt;&gt; …<br>&gt;&gt;&gt;&gt; let a = a<br>&gt;&gt;&gt;&gt; let b = b where b &gt; 10 &amp;&amp; a &gt; 5<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Why would this not be allowed by your rule? You&#39;re making use of `b` in your where clause. As I demonstrated above, essentially any assertion can be rewritten to work around your rule. In general:<br>&gt;&gt; <br>&gt;&gt; It is not allowed because  ‘a’ is defined in the line above. It must be defined in the ‘if let’ associated with the where in which it is mentioned.<br>&gt; <br>&gt; That&#39;s a much more restrictive where clause than you proposed earlier. You&#39;d not be able to write:<br>&gt; <br>&gt; ```<br>&gt; let b = b where b &gt; anyOtherVariable<br>&gt; ``` <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/69af70c5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May 31, 2016 at 03:00:00pm</p></header><div class="content"><p>On Tue, May 31, 2016 at 2:59 PM, Brandon Knope &lt;bknope at me.com&gt; wrote:<br></p><p>&gt; Except &quot;b&quot; is the main focus of the where clause and b was just in the<br>&gt; preceding if condition.<br>&gt;<br>&gt; I feel like we are trying to find ways to break the current where clause<br>&gt; even though we&#39;ve enjoyed it for almost a year now. I had no idea it was<br>&gt; problematic and restrictive. I thought it made its intent very<br>&gt; clear...leading to very readable code.<br>&gt;<br>&gt; Pretty soon almost every construct but conditionals will be allowed to<br>&gt; have where clauses, and THAT seems inconsistent to me.<br>&gt;<br>&gt; ...what exactly is the current problem? Can someone show me a real world<br>&gt; example?? I&#39;ve already forgotten it in all of this discussion -_-<br>&gt;<br>&gt;<br>The origin of the problem is a simple question: how does one test for<br>something unrelated to the variable that&#39;s bound in an `if let` statement?<br>The answer is: in today&#39;s Swift, any such test after the first `let` must<br>come after `where`. This is problematic and restrictive because one is<br>forced to imply a semantic relationship that doesn&#39;t exist.<br></p><p><br>&gt; Brandon<br>&gt;<br>&gt; On May 31, 2016, at 3:47 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Tue, May 31, 2016 at 2:45 PM, Christopher Kornher via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; Not allowed:<br>&gt;&gt;&gt; …<br>&gt;&gt;&gt; let a = a<br>&gt;&gt;&gt; let b = b where b &gt; 10 &amp;&amp; a &gt; 5<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Why would this not be allowed by your rule? You&#39;re making use of `b` in<br>&gt;&gt; your where clause. As I demonstrated above, essentially any assertion can<br>&gt;&gt; be rewritten to work around your rule. In general:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; It is not allowed because  ‘a’ is defined in the line above. It must be<br>&gt;&gt; defined in the ‘if let’ associated with the where in which it is mentioned.<br>&gt;&gt;<br>&gt;<br>&gt; That&#39;s a much more restrictive where clause than you proposed earlier.<br>&gt; You&#39;d not be able to write:<br>&gt;<br>&gt; ```<br>&gt; let b = b where b &gt; anyOtherVariable<br>&gt; ```<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/bfef2c40/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9ce70a6cb7175e7a5e5db5658186a31?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Brandon Knope</string> &lt;bknope at me.com&gt;<p>May 31, 2016 at 04:00:00pm</p></header><div class="content"><p>What is wrong with:<br></p><p>if let x = x where x &gt; 10, y != 5, let z = z where z != x<br></p><p>Just as a contrived example?<br></p><p>Brandon <br></p><p>&gt; On May 31, 2016, at 4:03 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Tue, May 31, 2016 at 2:59 PM, Brandon Knope &lt;bknope at me.com&gt; wrote:<br>&gt;&gt; Except &quot;b&quot; is the main focus of the where clause and b was just in the preceding if condition. <br>&gt;&gt; <br>&gt;&gt; I feel like we are trying to find ways to break the current where clause even though we&#39;ve enjoyed it for almost a year now. I had no idea it was problematic and restrictive. I thought it made its intent very clear...leading to very readable code. <br>&gt;&gt; <br>&gt;&gt; Pretty soon almost every construct but conditionals will be allowed to have where clauses, and THAT seems inconsistent to me. <br>&gt;&gt; <br>&gt;&gt; ...what exactly is the current problem? Can someone show me a real world example?? I&#39;ve already forgotten it in all of this discussion -_-<br>&gt; <br>&gt; The origin of the problem is a simple question: how does one test for something unrelated to the variable that&#39;s bound in an `if let` statement? The answer is: in today&#39;s Swift, any such test after the first `let` must come after `where`. This is problematic and restrictive because one is forced to imply a semantic relationship that doesn&#39;t exist.<br>&gt;  <br>&gt;&gt; Brandon <br>&gt;&gt; <br>&gt;&gt;&gt; On May 31, 2016, at 3:47 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Tue, May 31, 2016 at 2:45 PM, Christopher Kornher via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Not allowed:<br>&gt;&gt;&gt;&gt;&gt;&gt; …<br>&gt;&gt;&gt;&gt;&gt;&gt; let a = a<br>&gt;&gt;&gt;&gt;&gt;&gt; let b = b where b &gt; 10 &amp;&amp; a &gt; 5<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Why would this not be allowed by your rule? You&#39;re making use of `b` in your where clause. As I demonstrated above, essentially any assertion can be rewritten to work around your rule. In general:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It is not allowed because  ‘a’ is defined in the line above. It must be defined in the ‘if let’ associated with the where in which it is mentioned.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That&#39;s a much more restrictive where clause than you proposed earlier. You&#39;d not be able to write:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; let b = b where b &gt; anyOtherVariable<br>&gt;&gt;&gt; ``` <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/67db7941/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May 31, 2016 at 03:00:00pm</p></header><div class="content"><p>On Tue, May 31, 2016 at 3:16 PM, Brandon Knope &lt;bknope at me.com&gt; wrote:<br></p><p>&gt; What is wrong with:<br>&gt;<br>&gt; if let x = x where x &gt; 10, y != 5, let z = z where z != x<br>&gt;<br>&gt; Just as a contrived example?<br>&gt;<br></p><p>Because any grammar that permits what you propose would necessarily permit:<br></p><p>```<br>if let x = x, x &gt; 10, y != 5, let z = z, z != x<br>```<br></p><p>Thus, `where` becomes redundant, a vestigial stylistic flourish.<br></p><p><br>&gt; Brandon<br>&gt;<br>&gt; On May 31, 2016, at 4:03 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Tue, May 31, 2016 at 2:59 PM, Brandon Knope &lt;bknope at me.com&gt; wrote:<br>&gt;<br>&gt;&gt; Except &quot;b&quot; is the main focus of the where clause and b was just in the<br>&gt;&gt; preceding if condition.<br>&gt;&gt;<br>&gt;&gt; I feel like we are trying to find ways to break the current where clause<br>&gt;&gt; even though we&#39;ve enjoyed it for almost a year now. I had no idea it was<br>&gt;&gt; problematic and restrictive. I thought it made its intent very<br>&gt;&gt; clear...leading to very readable code.<br>&gt;&gt;<br>&gt;&gt; Pretty soon almost every construct but conditionals will be allowed to<br>&gt;&gt; have where clauses, and THAT seems inconsistent to me.<br>&gt;&gt;<br>&gt;&gt; ...what exactly is the current problem? Can someone show me a real world<br>&gt;&gt; example?? I&#39;ve already forgotten it in all of this discussion -_-<br>&gt;&gt;<br>&gt;&gt;<br>&gt; The origin of the problem is a simple question: how does one test for<br>&gt; something unrelated to the variable that&#39;s bound in an `if let` statement?<br>&gt; The answer is: in today&#39;s Swift, any such test after the first `let` must<br>&gt; come after `where`. This is problematic and restrictive because one is<br>&gt; forced to imply a semantic relationship that doesn&#39;t exist.<br>&gt;<br>&gt;<br>&gt;&gt; Brandon<br>&gt;&gt;<br>&gt;&gt; On May 31, 2016, at 3:47 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Tue, May 31, 2016 at 2:45 PM, Christopher Kornher via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Not allowed:<br>&gt;&gt;&gt;&gt; …<br>&gt;&gt;&gt;&gt; let a = a<br>&gt;&gt;&gt;&gt; let b = b where b &gt; 10 &amp;&amp; a &gt; 5<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Why would this not be allowed by your rule? You&#39;re making use of `b` in<br>&gt;&gt;&gt; your where clause. As I demonstrated above, essentially any assertion can<br>&gt;&gt;&gt; be rewritten to work around your rule. In general:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It is not allowed because  ‘a’ is defined in the line above. It must be<br>&gt;&gt;&gt; defined in the ‘if let’ associated with the where in which it is mentioned.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; That&#39;s a much more restrictive where clause than you proposed earlier.<br>&gt;&gt; You&#39;d not be able to write:<br>&gt;&gt;<br>&gt;&gt; ```<br>&gt;&gt; let b = b where b &gt; anyOtherVariable<br>&gt;&gt; ```<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/42a10e2a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9ce70a6cb7175e7a5e5db5658186a31?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Brandon Knope</string> &lt;bknope at me.com&gt;<p>May 31, 2016 at 04:00:00pm</p></header><div class="content"><p>Except I disagree. <br></p><p>It might seem like a stylistic flourish, but it can be more expressive in informing the reader that the variable after the where clause was recently introduced somewhere in the preceding clause. <br></p><p>Without it, you&#39;d have to scan the entire conditional clause and around the conditional statement to find a variable. <br></p><p>let x = 5<br></p><p>.... 6 lines later ....<br></p><p>let y = y where y == 10, x == 5<br></p><p>having the where here makes it clear that x was introduced elsewhere. You might not have known that because x was introduced several lines up. <br></p><p>It&#39;s contrived, but imagine a very long conditional or guard statement and I think where still has a place especially in aiding readability. <br></p><p>B<br></p><p>&gt; On May 31, 2016, at 4:31 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Tue, May 31, 2016 at 3:16 PM, Brandon Knope &lt;bknope at me.com&gt; wrote:<br>&gt;&gt; What is wrong with:<br>&gt;&gt; <br>&gt;&gt; if let x = x where x &gt; 10, y != 5, let z = z where z != x<br>&gt;&gt; <br>&gt;&gt; Just as a contrived example?<br>&gt; <br>&gt; Because any grammar that permits what you propose would necessarily permit:<br>&gt; <br>&gt; ```<br>&gt; if let x = x, x &gt; 10, y != 5, let z = z, z != x<br>&gt; ```<br>&gt; <br>&gt; Thus, `where` becomes redundant, a vestigial stylistic flourish.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Brandon <br>&gt;&gt; <br>&gt;&gt;&gt; On May 31, 2016, at 4:03 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Tue, May 31, 2016 at 2:59 PM, Brandon Knope &lt;bknope at me.com&gt; wrote:<br>&gt;&gt;&gt;&gt; Except &quot;b&quot; is the main focus of the where clause and b was just in the preceding if condition. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I feel like we are trying to find ways to break the current where clause even though we&#39;ve enjoyed it for almost a year now. I had no idea it was problematic and restrictive. I thought it made its intent very clear...leading to very readable code. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Pretty soon almost every construct but conditionals will be allowed to have where clauses, and THAT seems inconsistent to me. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ...what exactly is the current problem? Can someone show me a real world example?? I&#39;ve already forgotten it in all of this discussion -_-<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The origin of the problem is a simple question: how does one test for something unrelated to the variable that&#39;s bound in an `if let` statement? The answer is: in today&#39;s Swift, any such test after the first `let` must come after `where`. This is problematic and restrictive because one is forced to imply a semantic relationship that doesn&#39;t exist.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Brandon <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 31, 2016, at 3:47 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Tue, May 31, 2016 at 2:45 PM, Christopher Kornher via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Not allowed:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; …<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let a = a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let b = b where b &gt; 10 &amp;&amp; a &gt; 5<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Why would this not be allowed by your rule? You&#39;re making use of `b` in your where clause. As I demonstrated above, essentially any assertion can be rewritten to work around your rule. In general:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It is not allowed because  ‘a’ is defined in the line above. It must be defined in the ‘if let’ associated with the where in which it is mentioned.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That&#39;s a much more restrictive where clause than you proposed earlier. You&#39;d not be able to write:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt; let b = b where b &gt; anyOtherVariable<br>&gt;&gt;&gt;&gt;&gt; ``` <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/83c0c009/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/de0d5be6d0a7b6ccb5f061ab3d9fa25f?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Christopher Kornher</string> &lt;ckornher at mac.com&gt;<p>May 31, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On May 31, 2016, at 1:59 PM, Brandon Knope &lt;bknope at me.com&gt; wrote:<br>&gt; <br>&gt; Except &quot;b&quot; is the main focus of the where clause and b was just in the preceding if condition. <br>&gt; <br>&gt; I feel like we are trying to find ways to break the current where clause even though we&#39;ve enjoyed it for almost a year now. I had no idea it was problematic and restrictive. I thought it made its intent very clear...leading to very readable code. <br>&gt; <br>&gt; Pretty soon almost every construct but conditionals will be allowed to have where clauses, and THAT seems inconsistent to me. <br>&gt; <br>&gt; ...what exactly is the current problem? Can someone show me a real world example?? I&#39;ve already forgotten it in all of this discussion -_-<br>&gt; <br>&gt; Brandon <br>&gt; <br></p><p>I did this to explore why many people are reluctant to give-up ‘where’. The use of ‘where&#39; seems intuitive to mess well, and I did not understand why. It seems to natural group all logic concerning a constant with its definition and this seems to be a way to do that.<br></p><p>These rules add restrictions, but it does group related elements.  I am not convinced that this improves the language, but I though that it was worth exploring.  <br></p><p><br>&gt; On May 31, 2016, at 3:47 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Tue, May 31, 2016 at 2:45 PM, Christopher Kornher via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Not allowed:<br>&gt;&gt;&gt; …<br>&gt;&gt;&gt; let a = a<br>&gt;&gt;&gt; let b = b where b &gt; 10 &amp;&amp; a &gt; 5<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Why would this not be allowed by your rule? You&#39;re making use of `b` in your where clause. As I demonstrated above, essentially any assertion can be rewritten to work around your rule. In general:<br>&gt;&gt; <br>&gt;&gt; It is not allowed because  ‘a’ is defined in the line above. It must be defined in the ‘if let’ associated with the where in which it is mentioned.<br>&gt;&gt; <br>&gt;&gt; That&#39;s a much more restrictive where clause than you proposed earlier. You&#39;d not be able to write:<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; let b = b where b &gt; anyOtherVariable<br>&gt;&gt; ``` <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/aca616a9/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May 31, 2016 at 08:00:00pm</p></header><div class="content"><p>Revisiting this conversation, it seems that most of the design space has<br>been thoroughly explored. I think all suggestions presented so far boil<br>down to these:<br></p><p>Q: How is an arbitrary boolean assertion introduced after `if let`?<br></p><p>Option 1 (present scenario)--using `where`<br>Advantages: expressive when it means exactly the right thing<br>Drawbacks: makes obligatory the suggestion of a semantic relationship<br>between what comes before and after even when there is no such relationship<br></p><p>Option 2--using a symbol sometimes encountered in conditional statements<br>(e.g. `&amp;&amp;` or comma)<br>Advantages: doesn&#39;t look out of place<br>Drawbacks: needs to be disambiguated from existing uses, necessitating<br>other changes in syntax<br></p><p>Option 3--using a symbol never encountered in conditional statements (e.g.<br>semicolon)<br>Advantages: doesn&#39;t need to be disambiguated from any existing uses<br>Drawbacks: looks out of place<br></p><p>For me, options 1 and 2 have permanent and objective drawbacks. By<br>contrast, familiarity increases with time, and beauty is in the eye of the<br>beholder.<br></p><p>* * *<br></p><p>It does occur to me that there is one more option. I don&#39;t know that I like<br>it, but it&#39;s an option no one has put forward before: recite the opening<br>keyword when beginning a new boolean expression:<br></p><p>`if let x = x where x &lt; 3 { ... }` becomes<br>`if let x = x if x &lt; 3 { ... }`<br></p><p>`while let item = sequence.next() where item &gt; 0 { ... }` becomes<br>`while let item = sequence.next() while item &gt; 0 { ... }`<br></p><p>etc.<br></p><p><br>On Tue, May 31, 2016 at 2:00 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On May 31, 2016, at 12:52 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; &gt; These lines of reasoning are what have compelled me to conclude that<br>&gt; `where` might not be salvageable.<br>&gt;<br>&gt; To which, I&#39;d add: `where` suggests there&#39;s a subordinate and semantic<br>&gt; relationship between the primary condition and the clause. There&#39;s no way<br>&gt; as far as I know this to enforce it in the grammar and the proposal allows<br>&gt; both clauses to be stated even without the connecting word. You could make<br>&gt; a vague argument, I suppose, for renaming `where` to `when` but all in all,<br>&gt; even killing `where` we benefit with better expressive capabilities and a<br>&gt; simpler grammar.<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/575f3029/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>June  1, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On 1 Jun 2016, at 02:47, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Q: How is an arbitrary boolean assertion introduced after `if let`?<br>&gt; <br>&gt; Option 1 (present scenario)--using `where`<br>&gt; Advantages: expressive when it means exactly the right thing<br>&gt; Drawbacks: makes obligatory the suggestion of a semantic relationship between what comes before and after even when there is no such relationship<br></p><p>Like I said a little earlier, this drawback is not strictly true. No matter how unrelated to the binding a where clause may seemingly be, the binding is still dependent upon it; i.e- no value is bound if the condition fails, so regardless of what the condition is actually testing for it is very much related to the binding, like-so:<br></p><p>	if let value = foo where somethingUnrelatedIsTrue() { … }<br></p><p>The variable named “value” doesn’t exist outside of this condition if somethingUnrelatedIsTrue() fails, so I’d say there is still very much a relationship between these two things. A lot of the time you probably do want to test the unwrapped value, but it’s not a requirement for the condition to be related, because one cannot succeed without the other.<br></p><p>&gt; Option 3--using a symbol never encountered in conditional statements (e.g. semicolon)<br>&gt; Advantages: doesn&#39;t need to be disambiguated from any existing uses<br>&gt; Drawbacks: looks out of place<br></p><p>How out of place does it really look? It’s no different from semi-colons for separating statements in code, and if where remains supported you’ll only need to use it in a handful of cases anyway (much like semi-colons for statement separation).<br></p><p>&gt; It does occur to me that there is one more option. I don&#39;t know that I like it, but it&#39;s an option no one has put forward before: recite the opening keyword when beginning a new boolean expression:<br>&gt; <br>&gt; `if let x = x where x &lt; 3 { ... }` becomes<br>&gt; `if let x = x if x &lt; 3 { ... }`<br>&gt; <br>&gt; `while let item = sequence.next() where item &gt; 0 { ... }` becomes<br>&gt; `while let item = sequence.next() while item &gt; 0 { ... }`<br></p><p>I’m not sure what the difference is here; it doesn’t seem to have any capability that where doesn’t, surely it’s just changing the name of the keyword or is the point to have the full range of capabilities on both sides of the keyword? This could be done with where just as easily, no need for renaming, like so:<br></p><p>	if let value = foo where case .Some(let value2) = bar { … }<br></p><p>Bad example I know, but I don’t use pattern matching much. This currently doesn’t compile, but where could be extended to include all conditional types, so you could chain it to do pattern matching, conditional binding and a conditional all in one, is that the kind of thing you mean?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160601/6659d5a4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>June  1, 2016 at 11:00:00pm</p></header><div class="content"><p>I’ve always had a funny feeling about the `where` keyword in `if` statements. It feels like it adds structure, but it’s not the most flexible of keywords. I sometimes find myself writing to match the structure it wants rather than the other way around. I rather like this proposal.<br></p><p>What if `where` could be used to constrain the unwrapping of the optional rather than being an independent boolean expression? You could possibly use it normally outside of `if` like so:<br></p><p>let a: Optional&lt;String&gt; = &quot;hello&quot;<br></p><p>…<br></p><p>let b = a where a?.count &gt; 4  // .some(“hello”)<br>let c = a where a?.count &gt; 10  // .none<br></p><p><br>That way when used in an `if` statement, the `where` is actually part of the optional unwrap rather than a separate sibling.<br></p><p>if let x = x where x &lt; 3 {<br>  …<br>}<br></p><p>So people keep their ability to group related things together, with the simple elegance of this proposal. Just an idea, and I’m sure it can be improved.<br></p><p><br>Another idea is a .filter() method added to Optional.<br></p><p>if let x = x.filter({ $0 &lt; 3 }) {<br>  …<br>}<br></p><p><br>Patrick<br></p><p><br>&gt; On 1 Jun 2016, at 8:38 PM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 1 Jun 2016, at 02:47, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Q: How is an arbitrary boolean assertion introduced after `if let`?<br>&gt;&gt; <br>&gt;&gt; Option 1 (present scenario)--using `where`<br>&gt;&gt; Advantages: expressive when it means exactly the right thing<br>&gt;&gt; Drawbacks: makes obligatory the suggestion of a semantic relationship between what comes before and after even when there is no such relationship<br>&gt; <br>&gt; Like I said a little earlier, this drawback is not strictly true. No matter how unrelated to the binding a where clause may seemingly be, the binding is still dependent upon it; i.e- no value is bound if the condition fails, so regardless of what the condition is actually testing for it is very much related to the binding, like-so:<br>&gt; <br>&gt; 	if let value = foo where somethingUnrelatedIsTrue() { … }<br>&gt; <br>&gt; The variable named “value” doesn’t exist outside of this condition if somethingUnrelatedIsTrue() fails, so I’d say there is still very much a relationship between these two things. A lot of the time you probably do want to test the unwrapped value, but it’s not a requirement for the condition to be related, because one cannot succeed without the other.<br>&gt; <br>&gt;&gt; Option 3--using a symbol never encountered in conditional statements (e.g. semicolon)<br>&gt;&gt; Advantages: doesn&#39;t need to be disambiguated from any existing uses<br>&gt;&gt; Drawbacks: looks out of place<br>&gt; <br>&gt; How out of place does it really look? It’s no different from semi-colons for separating statements in code, and if where remains supported you’ll only need to use it in a handful of cases anyway (much like semi-colons for statement separation).<br>&gt; <br>&gt;&gt; It does occur to me that there is one more option. I don&#39;t know that I like it, but it&#39;s an option no one has put forward before: recite the opening keyword when beginning a new boolean expression:<br>&gt;&gt; <br>&gt;&gt; `if let x = x where x &lt; 3 { ... }` becomes<br>&gt;&gt; `if let x = x if x &lt; 3 { ... }`<br>&gt;&gt; <br>&gt;&gt; `while let item = sequence.next() where item &gt; 0 { ... }` becomes<br>&gt;&gt; `while let item = sequence.next() while item &gt; 0 { ... }`<br>&gt; <br>&gt; I’m not sure what the difference is here; it doesn’t seem to have any capability that where doesn’t, surely it’s just changing the name of the keyword or is the point to have the full range of capabilities on both sides of the keyword? This could be done with where just as easily, no need for renaming, like so:<br>&gt; <br>&gt; 	if let value = foo where case .Some(let value2) = bar { … }<br>&gt; <br>&gt; Bad example I know, but I don’t use pattern matching much. This currently doesn’t compile, but where could be extended to include all conditional types, so you could chain it to do pattern matching, conditional binding and a conditional all in one, is that the kind of thing you mean?<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160601/ad8623bb/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4a9841be165fb834d08296761b4a32e3?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Christopher Kornher</string> &lt;ckornher at me.com&gt;<p>June  1, 2016 at 06:00:00am</p></header><div class="content"><p>Apologies for going off that tangent earlier.<br></p><p>&gt; On May 31, 2016, at 7:47 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Revisiting this conversation, it seems that most of the design space has been thoroughly explored. I think all suggestions presented so far boil down to these:<br>&gt; <br>&gt; Q: How is an arbitrary boolean assertion introduced after `if let`?<br></p><p>Perhaps it is better to think in terms of starting  with the boolean expression and then figure out where the case conditions and let clauses should fit-in.<br></p><p>Starting with the simplest form: <br></p><p>	if &lt;boolean expression&gt; <br></p><p>add that it can be preceded by a single let clause:<br></p><p>	if let &lt;let list&gt; where &lt;boolean expression&gt; <br></p><p>where &lt;let list&gt; the comma separated list of assignments following a let<br></p><p>finishing up adding cases:<br></p><p>	if let &lt;let list&gt; where &lt;boolean expression&gt; case &lt;case expression&gt;<br></p><p>In this final form,   &#39;&lt;boolean expression&gt;’,  &#39;let &lt;let list&gt; where’,  and case &lt;case expression&gt; are all optional. One has to exist, of course.<br></p><p>This standardizes the form in a sensible way, I think. So: a single ‘let’ and a single ‘case” are allowed, in the position shown.<br></p><p>An example:<br></p><p>	&#39;if let a=a, b=b, where (x==3 &amp;&amp; y=x) || (x==2 &amp;&amp; y!-=x) {…}&#39;<br>	<br></p><p>&gt; Option 1 (present scenario)--using `where`<br>&gt; Advantages: expressive when it means exactly the right thing<br>&gt; Drawbacks: makes obligatory the suggestion of a semantic relationship between what comes before and after even when there is no such relationship<br>&gt; <br>&gt; Option 2--using a symbol sometimes encountered in conditional statements (e.g. `&amp;&amp;` or comma)<br>&gt; Advantages: doesn&#39;t look out of place<br>&gt; Drawbacks: needs to be disambiguated from existing uses, necessitating other changes in syntax<br>&gt; <br>&gt; Option 3--using a symbol never encountered in conditional statements (e.g. semicolon)<br>&gt; Advantages: doesn&#39;t need to be disambiguated from any existing uses<br>&gt; Drawbacks: looks out of place<br></p><p>and it is equivalent to `&amp;&amp;` <br></p><p>	`if let a=a; x==3; y==4`<br></p><p>is equivalent to<br></p><p>	`if let a=a; x==3 &amp;&amp; y==4`<br></p><p><br>&gt; <br>&gt; For me, options 1 and 2 have permanent and objective drawbacks. By contrast, familiarity increases with time, and beauty is in the eye of the beholder.<br>&gt; <br>&gt; * * *<br>&gt; <br>&gt; It does occur to me that there is one more option. I don&#39;t know that I like it, but it&#39;s an option no one has put forward before: recite the opening keyword when beginning a new boolean expression:<br>&gt; <br>&gt; `if let x = x where x &lt; 3 { ... }` becomes<br>&gt; `if let x = x if x &lt; 3 { ... }`<br>&gt; <br>&gt; `while let item = sequence.next() where item &gt; 0 { ... }` becomes<br>&gt; `while let item = sequence.next() while item &gt; 0 { ... }`<br>&gt; <br>&gt; etc.<br>&gt; <br>&gt; <br>&gt; On Tue, May 31, 2016 at 2:00 PM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt; <br>&gt; &gt; On May 31, 2016, at 12:52 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt; &gt; These lines of reasoning are what have compelled me to conclude that `where` might not be salvageable.<br>&gt; <br>&gt; To which, I&#39;d add: `where` suggests there&#39;s a subordinate and semantic relationship between the primary condition and the clause. There&#39;s no way as far as I know this to enforce it in the grammar and the proposal allows both clauses to be stated even without the connecting word. You could make a vague argument, I suppose, for renaming `where` to `when` but all in all, even killing `where` we benefit with better expressive capabilities and a simpler grammar.<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160601/365f0622/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>June  1, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; Am 01.06.2016 um 03:47 schrieb Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Revisiting this conversation, it seems that most of the design space has been thoroughly explored. I think all suggestions presented so far boil down to these:<br>&gt; <br>&gt; Q: How is an arbitrary boolean assertion introduced after `if let`?<br>&gt; <br>&gt; Option 1 (present scenario)--using `where`<br>&gt; Advantages: expressive when it means exactly the right thing<br>&gt; Drawbacks: makes obligatory the suggestion of a semantic relationship between what comes before and after even when there is no such relationship<br></p><p>Haravikk already demonstrated that a semantic relationship always exists in the sense of &quot;bind this variable for all caes where the following condition holds&quot;.<br></p><p>So, the perceived problem with the `where` clause does not exist.<br></p><p>-Thorsten <br></p><p><br>&gt; <br>&gt; Option 2--using a symbol sometimes encountered in conditional statements (e.g. `&amp;&amp;` or comma)<br>&gt; Advantages: doesn&#39;t look out of place<br>&gt; Drawbacks: needs to be disambiguated from existing uses, necessitating other changes in syntax<br>&gt; <br>&gt; Option 3--using a symbol never encountered in conditional statements (e.g. semicolon)<br>&gt; Advantages: doesn&#39;t need to be disambiguated from any existing uses<br>&gt; Drawbacks: looks out of place<br>&gt; <br>&gt; For me, options 1 and 2 have permanent and objective drawbacks. By contrast, familiarity increases with time, and beauty is in the eye of the beholder.<br>&gt; <br>&gt; * * *<br>&gt; <br>&gt; It does occur to me that there is one more option. I don&#39;t know that I like it, but it&#39;s an option no one has put forward before: recite the opening keyword when beginning a new boolean expression:<br>&gt; <br>&gt; `if let x = x where x &lt; 3 { ... }` becomes<br>&gt; `if let x = x if x &lt; 3 { ... }`<br>&gt; <br>&gt; `while let item = sequence.next() where item &gt; 0 { ... }` becomes<br>&gt; `while let item = sequence.next() while item &gt; 0 { ... }`<br>&gt; <br>&gt; etc.<br>&gt; <br>&gt; <br>&gt; On Tue, May 31, 2016 at 2:00 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt; On May 31, 2016, at 12:52 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt; &gt; These lines of reasoning are what have compelled me to conclude that `where` might not be salvageable.<br>&gt;&gt; <br>&gt;&gt; To which, I&#39;d add: `where` suggests there&#39;s a subordinate and semantic relationship between the primary condition and the clause. There&#39;s no way as far as I know this to enforce it in the grammar and the proposal allows both clauses to be stated even without the connecting word. You could make a vague argument, I suppose, for renaming `where` to `when` but all in all, even killing `where` we benefit with better expressive capabilities and a simpler grammar.<br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160601/c77b9950/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June  1, 2016 at 05:00:00pm</p></header><div class="content"><p>It is of course true that all parts of a conditional statement have<br>something in common with each other, namely that they are part of the same<br>conditional statement.<br></p><p>A problem definitely exists with the current syntax, which is that the de<br>minimis semantic relationship you are showing is not the relationship<br>implied by the meaning of the word &quot;where.&quot;<br></p><p>It is acceptable to say, &quot;I will buy all the apples that are on sale, where<br>the sale is 5% off or better.&quot; It is not acceptable to say, &quot;I will buy all<br>the apples that are on sale, where my bike is large,&quot; even if it is true<br>that you would only buy all the apples if you had a large bike to transport<br>them home.<br></p><p>On Wed, Jun 1, 2016 at 11:50 Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br></p><p>&gt;<br>&gt;<br>&gt; Am 01.06.2016 um 03:47 schrieb Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt;<br>&gt; Revisiting this conversation, it seems that most of the design space has<br>&gt; been thoroughly explored. I think all suggestions presented so far boil<br>&gt; down to these:<br>&gt;<br>&gt; Q: How is an arbitrary boolean assertion introduced after `if let`?<br>&gt;<br>&gt; Option 1 (present scenario)--using `where`<br>&gt; Advantages: expressive when it means exactly the right thing<br>&gt; Drawbacks: makes obligatory the suggestion of a semantic relationship<br>&gt; between what comes before and after even when there is no such relationship<br>&gt;<br>&gt;<br>&gt; Haravikk already demonstrated that a semantic relationship always exists<br>&gt; in the sense of &quot;bind this variable for all caes where the following<br>&gt; condition holds&quot;.<br>&gt;<br>&gt; So, the perceived problem with the `where` clause does not exist.<br>&gt;<br>&gt; -Thorsten<br>&gt;<br>&gt;<br>&gt;<br>&gt; Option 2--using a symbol sometimes encountered in conditional statements<br>&gt; (e.g. `&amp;&amp;` or comma)<br>&gt; Advantages: doesn&#39;t look out of place<br>&gt; Drawbacks: needs to be disambiguated from existing uses, necessitating<br>&gt; other changes in syntax<br>&gt;<br>&gt; Option 3--using a symbol never encountered in conditional statements (e.g.<br>&gt; semicolon)<br>&gt; Advantages: doesn&#39;t need to be disambiguated from any existing uses<br>&gt; Drawbacks: looks out of place<br>&gt;<br>&gt; For me, options 1 and 2 have permanent and objective drawbacks. By<br>&gt; contrast, familiarity increases with time, and beauty is in the eye of the<br>&gt; beholder.<br>&gt;<br>&gt; * * *<br>&gt;<br>&gt; It does occur to me that there is one more option. I don&#39;t know that I<br>&gt; like it, but it&#39;s an option no one has put forward before: recite the<br>&gt; opening keyword when beginning a new boolean expression:<br>&gt;<br>&gt; `if let x = x where x &lt; 3 { ... }` becomes<br>&gt; `if let x = x if x &lt; 3 { ... }`<br>&gt;<br>&gt; `while let item = sequence.next() where item &gt; 0 { ... }` becomes<br>&gt; `while let item = sequence.next() while item &gt; 0 { ... }`<br>&gt;<br>&gt; etc.<br>&gt;<br>&gt;<br>&gt; On Tue, May 31, 2016 at 2:00 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; On May 31, 2016, at 12:52 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt; &gt; These lines of reasoning are what have compelled me to conclude that<br>&gt;&gt; `where` might not be salvageable.<br>&gt;&gt;<br>&gt;&gt; To which, I&#39;d add: `where` suggests there&#39;s a subordinate and semantic<br>&gt;&gt; relationship between the primary condition and the clause. There&#39;s no way<br>&gt;&gt; as far as I know this to enforce it in the grammar and the proposal allows<br>&gt;&gt; both clauses to be stated even without the connecting word. You could make<br>&gt;&gt; a vague argument, I suppose, for renaming `where` to `when` but all in all,<br>&gt;&gt; even killing `where` we benefit with better expressive capabilities and a<br>&gt;&gt; simpler grammar.<br>&gt;&gt;<br>&gt;&gt; -- E<br>&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160601/93cde8d2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/44b9c3e92a40313850fdbc2cb0abdef7?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Jon Shier</string> &lt;jon at jonshier.com&gt;<p>June  4, 2016 at 03:00:00am</p></header><div class="content"><p>The suitability of “where” as the keyword in these clauses is a completely separate issue. Frankly, it just comes down to English not having a good, single word to describe an if-and-only-if relationship. So “where&quot; was chosen (some explanation from the original designers has been sorely missing in this thread). The fact that it doesn’t make sense in all cases of conversational English is largely irrelevant, since pretty much all English words in programming languages have that problem. <br>	As for the actual proposal:<br></p><p>&gt; 	• What is your evaluation of the proposal?<br>-1 <br></p><p>I don’t believe any of the proposed advantages outweigh the rather jarring change in syntax.<br></p><p>&gt; 	• Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>No. There has been enough discussion in this thread to convince me that the issues with “where” are vastly overwrought and “where” is actually quite useful as a condition for binding variables. Some improvement may be possible here, especially with the error messages generated, but I think the current syntax is quite good, from a user’s perspective.<br></p><p>&gt; 	• Does this proposal fit well with the feel and direction of Swift?<br></p><p>It feels like a regression in style. Introducing semicolons or newlines as important conditional separators feels like a throwback to C in many ways. Eliminating “where” also feels like the elimination of a unique and useful bit of Swift styling.<br></p><p>&gt; 	• If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>Swift is unique in this regard among the languages I’ve used, to its benefit.<br></p><p>&gt; 	• How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>Read multiple drafts of the proposal and the entire discussion thread.<br></p><p>&gt; On Jun 1, 2016, at 1:35 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; It is of course true that all parts of a conditional statement have something in common with each other, namely that they are part of the same conditional statement.<br>&gt; <br>&gt; A problem definitely exists with the current syntax, which is that the de minimis semantic relationship you are showing is not the relationship implied by the meaning of the word &quot;where.&quot;<br>&gt; <br>&gt; It is acceptable to say, &quot;I will buy all the apples that are on sale, where the sale is 5% off or better.&quot; It is not acceptable to say, &quot;I will buy all the apples that are on sale, where my bike is large,&quot; even if it is true that you would only buy all the apples if you had a large bike to transport them home.<br>&gt; <br>&gt; On Wed, Jun 1, 2016 at 11:50 Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Am 01.06.2016 um 03:47 schrieb Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; <br>&gt;&gt; Revisiting this conversation, it seems that most of the design space has been thoroughly explored. I think all suggestions presented so far boil down to these:<br>&gt;&gt; <br>&gt;&gt; Q: How is an arbitrary boolean assertion introduced after `if let`?<br>&gt;&gt; <br>&gt;&gt; Option 1 (present scenario)--using `where`<br>&gt;&gt; Advantages: expressive when it means exactly the right thing<br>&gt;&gt; Drawbacks: makes obligatory the suggestion of a semantic relationship between what comes before and after even when there is no such relationship<br>&gt; <br>&gt; Haravikk already demonstrated that a semantic relationship always exists in the sense of &quot;bind this variable for all caes where the following condition holds&quot;.<br>&gt; <br>&gt; So, the perceived problem with the `where` clause does not exist.<br>&gt; <br>&gt; -Thorsten <br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; Option 2--using a symbol sometimes encountered in conditional statements (e.g. `&amp;&amp;` or comma)<br>&gt;&gt; Advantages: doesn&#39;t look out of place<br>&gt;&gt; Drawbacks: needs to be disambiguated from existing uses, necessitating other changes in syntax<br>&gt;&gt; <br>&gt;&gt; Option 3--using a symbol never encountered in conditional statements (e.g. semicolon)<br>&gt;&gt; Advantages: doesn&#39;t need to be disambiguated from any existing uses<br>&gt;&gt; Drawbacks: looks out of place<br>&gt;&gt; <br>&gt;&gt; For me, options 1 and 2 have permanent and objective drawbacks. By contrast, familiarity increases with time, and beauty is in the eye of the beholder.<br>&gt;&gt; <br>&gt;&gt; * * *<br>&gt;&gt; <br>&gt;&gt; It does occur to me that there is one more option. I don&#39;t know that I like it, but it&#39;s an option no one has put forward before: recite the opening keyword when beginning a new boolean expression:<br>&gt;&gt; <br>&gt;&gt; `if let x = x where x &lt; 3 { ... }` becomes<br>&gt;&gt; `if let x = x if x &lt; 3 { ... }`<br>&gt;&gt; <br>&gt;&gt; `while let item = sequence.next() where item &gt; 0 { ... }` becomes<br>&gt;&gt; `while let item = sequence.next() while item &gt; 0 { ... }`<br>&gt;&gt; <br>&gt;&gt; etc.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Tue, May 31, 2016 at 2:00 PM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt; On May 31, 2016, at 12:52 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; &gt; These lines of reasoning are what have compelled me to conclude that `where` might not be salvageable.<br>&gt;&gt; <br>&gt;&gt; To which, I&#39;d add: `where` suggests there&#39;s a subordinate and semantic relationship between the primary condition and the clause. There&#39;s no way as far as I know this to enforce it in the grammar and the proposal allows both clauses to be stated even without the connecting word. You could make a vague argument, I suppose, for renaming `where` to `when` but all in all, even killing `where` we benefit with better expressive capabilities and a simpler grammar.<br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160604/77270930/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/caa7226ca750e974668243476ffbafd5?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Greg Titus</string> &lt;greg at omnigroup.com&gt;<p>June  4, 2016 at 07:00:00pm</p></header><div class="content"><p>I think that Jon has exactly described my view on this proposal. Thanks, Jon.<br></p><p>-1.<br></p><p>  -- Greg <br></p><p>&gt; On Jun 4, 2016, at 12:17 AM, Jon Shier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; 	The suitability of “where” as the keyword in these clauses is a completely separate issue. Frankly, it just comes down to English not having a good, single word to describe an if-and-only-if relationship. So “where&quot; was chosen (some explanation from the original designers has been sorely missing in this thread). The fact that it doesn’t make sense in all cases of conversational English is largely irrelevant, since pretty much all English words in programming languages have that problem. <br>&gt; 	As for the actual proposal:<br>&gt; <br>&gt;&gt; 	• What is your evaluation of the proposal?<br>&gt; -1 <br>&gt; <br>&gt; I don’t believe any of the proposed advantages outweigh the rather jarring change in syntax.<br>&gt; <br>&gt;&gt; 	• Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; <br>&gt; No. There has been enough discussion in this thread to convince me that the issues with “where” are vastly overwrought and “where” is actually quite useful as a condition for binding variables. Some improvement may be possible here, especially with the error messages generated, but I think the current syntax is quite good, from a user’s perspective.<br>&gt; <br>&gt;&gt; 	• Does this proposal fit well with the feel and direction of Swift?<br>&gt; <br>&gt; It feels like a regression in style. Introducing semicolons or newlines as important conditional separators feels like a throwback to C in many ways. Eliminating “where” also feels like the elimination of a unique and useful bit of Swift styling.<br>&gt; <br>&gt;&gt; 	• If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; <br>&gt; Swift is unique in this regard among the languages I’ve used, to its benefit.<br>&gt; <br>&gt;&gt; 	• How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; Read multiple drafts of the proposal and the entire discussion thread.<br>&gt; <br>&gt;&gt; On Jun 1, 2016, at 1:35 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; It is of course true that all parts of a conditional statement have something in common with each other, namely that they are part of the same conditional statement.<br>&gt;&gt; <br>&gt;&gt; A problem definitely exists with the current syntax, which is that the de minimis semantic relationship you are showing is not the relationship implied by the meaning of the word &quot;where.&quot;<br>&gt;&gt; <br>&gt;&gt; It is acceptable to say, &quot;I will buy all the apples that are on sale, where the sale is 5% off or better.&quot; It is not acceptable to say, &quot;I will buy all the apples that are on sale, where my bike is large,&quot; even if it is true that you would only buy all the apples if you had a large bike to transport them home.<br>&gt;&gt; <br>&gt;&gt;&gt; On Wed, Jun 1, 2016 at 11:50 Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 01.06.2016 um 03:47 schrieb Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Revisiting this conversation, it seems that most of the design space has been thoroughly explored. I think all suggestions presented so far boil down to these:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Q: How is an arbitrary boolean assertion introduced after `if let`?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Option 1 (present scenario)--using `where`<br>&gt;&gt;&gt;&gt; Advantages: expressive when it means exactly the right thing<br>&gt;&gt;&gt;&gt; Drawbacks: makes obligatory the suggestion of a semantic relationship between what comes before and after even when there is no such relationship<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Haravikk already demonstrated that a semantic relationship always exists in the sense of &quot;bind this variable for all caes where the following condition holds&quot;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So, the perceived problem with the `where` clause does not exist.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Thorsten <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Option 2--using a symbol sometimes encountered in conditional statements (e.g. `&amp;&amp;` or comma)<br>&gt;&gt;&gt;&gt; Advantages: doesn&#39;t look out of place<br>&gt;&gt;&gt;&gt; Drawbacks: needs to be disambiguated from existing uses, necessitating other changes in syntax<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Option 3--using a symbol never encountered in conditional statements (e.g. semicolon)<br>&gt;&gt;&gt;&gt; Advantages: doesn&#39;t need to be disambiguated from any existing uses<br>&gt;&gt;&gt;&gt; Drawbacks: looks out of place<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For me, options 1 and 2 have permanent and objective drawbacks. By contrast, familiarity increases with time, and beauty is in the eye of the beholder.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * * *<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It does occur to me that there is one more option. I don&#39;t know that I like it, but it&#39;s an option no one has put forward before: recite the opening keyword when beginning a new boolean expression:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; `if let x = x where x &lt; 3 { ... }` becomes<br>&gt;&gt;&gt;&gt; `if let x = x if x &lt; 3 { ... }`<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; `while let item = sequence.next() where item &gt; 0 { ... }` becomes<br>&gt;&gt;&gt;&gt; `while let item = sequence.next() while item &gt; 0 { ... }`<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; etc.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Tue, May 31, 2016 at 2:00 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt; On May 31, 2016, at 12:52 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt; These lines of reasoning are what have compelled me to conclude that `where` might not be salvageable.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; To which, I&#39;d add: `where` suggests there&#39;s a subordinate and semantic relationship between the primary condition and the clause. There&#39;s no way as far as I know this to enforce it in the grammar and the proposal allows both clauses to be stated even without the connecting word. You could make a vague argument, I suppose, for renaming `where` to `when` but all in all, even killing `where` we benefit with better expressive capabilities and a simpler grammar.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -- E<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160604/0dd3d581/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>June  4, 2016 at 10:00:00pm</p></header><div class="content"><p>+1<br>I think that it is an improvement overall and the work for consistency is<br>appreciated.<br></p><p><br>On Sat, Jun 4, 2016 at 10:03 PM, Greg Titus via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; I think that Jon has exactly described my view on this proposal. Thanks,<br>&gt; Jon.<br>&gt;<br>&gt; -1.<br>&gt;<br>&gt;   -- Greg<br>&gt;<br>&gt; On Jun 4, 2016, at 12:17 AM, Jon Shier via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; The suitability of “where” as the keyword in these clauses is a completely<br>&gt; separate issue. Frankly, it just comes down to English not having a good,<br>&gt; single word to describe an if-and-only-if relationship. So “where&quot; was<br>&gt; chosen (some explanation from the original designers has been sorely<br>&gt; missing in this thread). The fact that it doesn’t make sense in all cases<br>&gt; of conversational English is largely irrelevant, since pretty much all<br>&gt; English words in programming languages have that problem.<br>&gt; As for the actual proposal:<br>&gt;<br>&gt; • What is your evaluation of the proposal?<br>&gt;<br>&gt; -1<br>&gt;<br>&gt; I don’t believe any of the proposed advantages outweigh the rather jarring<br>&gt; change in syntax.<br>&gt;<br>&gt; • Is the problem being addressed significant enough to warrant a change to<br>&gt; Swift?<br>&gt;<br>&gt;<br>&gt; No. There has been enough discussion in this thread to convince me that<br>&gt; the issues with “where” are vastly overwrought and “where” is actually<br>&gt; quite useful as a condition for binding variables. Some improvement may be<br>&gt; possible here, especially with the error messages generated, but I think<br>&gt; the current syntax is quite good, from a user’s perspective.<br>&gt;<br>&gt; • Does this proposal fit well with the feel and direction of Swift?<br>&gt;<br>&gt;<br>&gt; It feels like a regression in style. Introducing semicolons or newlines as<br>&gt; important conditional separators feels like a throwback to C in many ways.<br>&gt; Eliminating “where” also feels like the elimination of a unique and useful<br>&gt; bit of Swift styling.<br>&gt;<br>&gt; • If you have used other languages or libraries with a similar feature,<br>&gt; how do you feel that this proposal compares to those?<br>&gt;<br>&gt;<br>&gt; Swift is unique in this regard among the languages I’ve used, to its<br>&gt; benefit.<br>&gt;<br>&gt; • How much effort did you put into your review? A glance, a quick reading,<br>&gt; or an in-depth study?<br>&gt;<br>&gt;<br>&gt; Read multiple drafts of the proposal and the entire discussion thread.<br>&gt;<br>&gt; On Jun 1, 2016, at 1:35 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; It is of course true that all parts of a conditional statement have<br>&gt; something in common with each other, namely that they are part of the same<br>&gt; conditional statement.<br>&gt;<br>&gt; A problem definitely exists with the current syntax, which is that the de<br>&gt; minimis semantic relationship you are showing is not the relationship<br>&gt; implied by the meaning of the word &quot;where.&quot;<br>&gt;<br>&gt; It is acceptable to say, &quot;I will buy all the apples that are on sale,<br>&gt; where the sale is 5% off or better.&quot; It is not acceptable to say, &quot;I will<br>&gt; buy all the apples that are on sale, where my bike is large,&quot; even if it is<br>&gt; true that you would only buy all the apples if you had a large bike to<br>&gt; transport them home.<br>&gt;<br>&gt; On Wed, Jun 1, 2016 at 11:50 Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Am 01.06.2016 um 03:47 schrieb Xiaodi Wu via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt;:<br>&gt;&gt;<br>&gt;&gt; Revisiting this conversation, it seems that most of the design space has<br>&gt;&gt; been thoroughly explored. I think all suggestions presented so far boil<br>&gt;&gt; down to these:<br>&gt;&gt;<br>&gt;&gt; Q: How is an arbitrary boolean assertion introduced after `if let`?<br>&gt;&gt;<br>&gt;&gt; Option 1 (present scenario)--using `where`<br>&gt;&gt; Advantages: expressive when it means exactly the right thing<br>&gt;&gt; Drawbacks: makes obligatory the suggestion of a semantic relationship<br>&gt;&gt; between what comes before and after even when there is no such relationship<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Haravikk already demonstrated that a semantic relationship always exists<br>&gt;&gt; in the sense of &quot;bind this variable for all caes where the following<br>&gt;&gt; condition holds&quot;.<br>&gt;&gt;<br>&gt;&gt; So, the perceived problem with the `where` clause does not exist.<br>&gt;&gt;<br>&gt;&gt; -Thorsten<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Option 2--using a symbol sometimes encountered in conditional statements<br>&gt;&gt; (e.g. `&amp;&amp;` or comma)<br>&gt;&gt; Advantages: doesn&#39;t look out of place<br>&gt;&gt; Drawbacks: needs to be disambiguated from existing uses, necessitating<br>&gt;&gt; other changes in syntax<br>&gt;&gt;<br>&gt;&gt; Option 3--using a symbol never encountered in conditional statements<br>&gt;&gt; (e.g. semicolon)<br>&gt;&gt; Advantages: doesn&#39;t need to be disambiguated from any existing uses<br>&gt;&gt; Drawbacks: looks out of place<br>&gt;&gt;<br>&gt;&gt; For me, options 1 and 2 have permanent and objective drawbacks. By<br>&gt;&gt; contrast, familiarity increases with time, and beauty is in the eye of the<br>&gt;&gt; beholder.<br>&gt;&gt;<br>&gt;&gt; * * *<br>&gt;&gt;<br>&gt;&gt; It does occur to me that there is one more option. I don&#39;t know that I<br>&gt;&gt; like it, but it&#39;s an option no one has put forward before: recite the<br>&gt;&gt; opening keyword when beginning a new boolean expression:<br>&gt;&gt;<br>&gt;&gt; `if let x = x where x &lt; 3 { ... }` becomes<br>&gt;&gt; `if let x = x if x &lt; 3 { ... }`<br>&gt;&gt;<br>&gt;&gt; `while let item = sequence.next() where item &gt; 0 { ... }` becomes<br>&gt;&gt; `while let item = sequence.next() while item &gt; 0 { ... }`<br>&gt;&gt;<br>&gt;&gt; etc.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Tue, May 31, 2016 at 2:00 PM, Erica Sadun &lt;erica at ericasadun.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; On May 31, 2016, at 12:52 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt; &gt; These lines of reasoning are what have compelled me to conclude that<br>&gt;&gt;&gt; `where` might not be salvageable.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; To which, I&#39;d add: `where` suggests there&#39;s a subordinate and semantic<br>&gt;&gt;&gt; relationship between the primary condition and the clause. There&#39;s no way<br>&gt;&gt;&gt; as far as I know this to enforce it in the grammar and the proposal allows<br>&gt;&gt;&gt; both clauses to be stated even without the connecting word. You could make<br>&gt;&gt;&gt; a vague argument, I suppose, for renaming `where` to `when` but all in all,<br>&gt;&gt;&gt; even killing `where` we benefit with better expressive capabilities and a<br>&gt;&gt;&gt; simpler grammar.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -- E<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160604/2ed4726a/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ab486d7597af4cfe0be33a762150848?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Dany St-Amant</string> &lt;dsa.mls at icloud.com&gt;<p>June  7, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; Le 31 mai 2016 à 21:47, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Revisiting this conversation, it seems that most of the design space has been thoroughly explored. I think all suggestions presented so far boil down to these:<br>&gt; <br>&gt; Q: How is an arbitrary boolean assertion introduced after `if let`?<br>&gt; <br>&gt; Option 1 (present scenario)--using `where`<br>&gt; Advantages: expressive when it means exactly the right thing<br>&gt; Drawbacks: makes obligatory the suggestion of a semantic relationship between what comes before and after even when there is no such relationship<br></p><p>On some occasion the relation may be obscure: buy junk of the road where junk is cheap and my trunk is empty. And as mentioned many times can be worked around by evil coder. So the relationship of the where clause may be better left to the code reviewers.<br></p><p>&gt; Option 2--using a symbol sometimes encountered in conditional statements (e.g. `&amp;&amp;` or comma)<br>&gt; Advantages: doesn&#39;t look out of place<br>&gt; Drawbacks: needs to be disambiguated from existing uses, necessitating other changes in syntax<br></p><p>One issue with using &amp;&amp; which have not been discussed so far is that it may force the uses of extra parenthesis when the where clause did contain ||<br></p><p>How can one represent something like:<br></p><p>if let x = optionalX where x &lt; 10 || x &gt; 90 &quot;and&quot; y &lt; 10 || y &gt; 90 { }<br></p><p>With the removal of the where and the use of &amp;&amp; as to be expressed as:<br></p><p>if let x = optionalX &amp;&amp; ( x &lt; 10 || x &gt; 90 ) &amp;&amp; ( y &lt; 10 || y &gt; 90 ) { }<br></p><p>While using a comma (and line feed) it can be<br></p><p>if let x = optionalX,<br>    x &lt; 10 || x &gt; 90,<br>    y &lt; 10 || y &gt; 90<br>{ }<br></p><p>This option are two different options, the &amp;&amp; which impact condition already uses || and the use of comma which would require disallowing multiple binding within a single let. Some said it would be weird to allow:<br></p><p>let x = optionalX, y = optionalY<br></p><p>While disallowing:<br></p><p>if let x = optionalX, y = optionalY { }<br></p><p>But these are already two different syntax; one allows where clause and the other not.<br></p><p>One possible good thing of disallowing the multiple binding in such construct is that it make some refactoring less puzzling.<br></p><p>Starting with:<br></p><p>if let x = expensiveOptionalX(), y = expensiveOptionalY() { }<br></p><p>If one want to add a &#39;where x &lt; 10&#39; there is currently two choices:<br></p><p>if let x = expensiveOptionalX(), y = expensiveOptionalY() where x &lt; 10 { }<br>if let x = expensiveOptionalX() where x &lt; 10, let y = expensiveOptionalY() { }<br></p><p>For performance and proper relation the &#39;where&#39; should be against the variable &#39;x&#39;, but this forces the addition of a new &#39;let&#39; which most coder will add only after seeing the compile error and possibly after the use of some foul language.<br></p><p><br>Dany<br></p><p>&gt; <br>&gt; Option 3--using a symbol never encountered in conditional statements (e.g. semicolon)<br>&gt; Advantages: doesn&#39;t need to be disambiguated from any existing uses<br>&gt; Drawbacks: looks out of place<br>&gt; <br>&gt; For me, options 1 and 2 have permanent and objective drawbacks. By contrast, familiarity increases with time, and beauty is in the eye of the beholder.<br>&gt; <br>&gt; * * *<br>&gt; <br>&gt; It does occur to me that there is one more option. I don&#39;t know that I like it, but it&#39;s an option no one has put forward before: recite the opening keyword when beginning a new boolean expression:<br>&gt; <br>&gt; `if let x = x where x &lt; 3 { ... }` becomes<br>&gt; `if let x = x if x &lt; 3 { ... }`<br>&gt; <br>&gt; `while let item = sequence.next() where item &gt; 0 { ... }` becomes<br>&gt; `while let item = sequence.next() while item &gt; 0 { ... }`<br>&gt; <br>&gt; etc.<br>&gt; <br>&gt; <br>&gt; On Tue, May 31, 2016 at 2:00 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt; On May 31, 2016, at 12:52 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt; &gt; These lines of reasoning are what have compelled me to conclude that `where` might not be salvageable.<br>&gt;&gt; <br>&gt;&gt; To which, I&#39;d add: `where` suggests there&#39;s a subordinate and semantic relationship between the primary condition and the clause. There&#39;s no way as far as I know this to enforce it in the grammar and the proposal allows both clauses to be stated even without the connecting word. You could make a vague argument, I suppose, for renaming `where` to `when` but all in all, even killing `where` we benefit with better expressive capabilities and a simpler grammar.<br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160607/6c7e7dbf/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>June  7, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; Am 01.06.2016 um 03:47 schrieb Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; &lt;snip&gt;<br>&gt; <br>&gt; It does occur to me that there is one more option. I don&#39;t know that I like it, but it&#39;s an option no one has put forward before: recite the opening keyword when beginning a new boolean expression:<br>&gt; <br>&gt; `if let x = x where x &lt; 3 { ... }` becomes<br>&gt; `if let x = x if x &lt; 3 { ... }`<br>&gt; <br>&gt; `while let item = sequence.next() where item &gt; 0 { ... }` becomes<br>&gt; `while let item = sequence.next() while item &gt; 0 { ... }`<br>&gt; <br>&gt; etc.<br>&gt; <br></p><p>I&#39;ve almost had the same idea... However I would not replace &quot;where&quot; rather than using if/while/guard as delimiters for new optional bindings/case-conditions:<br></p><p>// if ----------------------<br>if let x = y where x &lt; 4 if case let .Some(a) = b where a &gt; 42 {<br>    ...<br>}<br></p><p>// Is equivalent to:<br></p><p>if let x = y where x &lt; 4 {<br>    if case let .Some(a) = b where a &gt; 42 {<br>        ...<br>    }<br>}<br></p><p><br>// guard ----------------------<br>guard let x = y where x &lt; 4 guard case let .Some(a) = b where a &gt; 42 else { ... }<br></p><p>// Is equivalent to:<br></p><p>guard let x = y where x &lt; 4 else { ... }<br>guard case let .Some(a) = b where a &gt; 42 else { ... }<br></p><p><br></p><p>// while ----------------------<br></p><p>// &quot;guard&quot; or &quot;if&quot; should probably be used as delimiter instead of &quot;while&quot;<br>// since it is not a nested loop (discussable...)<br>while let x = y where x &lt; 4 while case let .Some(a) = b where a &gt; 42 {<br>   ...<br>}<br></p><p>// Is equivalent to:<br></p><p>while let x = y where x &lt; 4 {<br>    guard case let .Some(a) = b where a &gt; 42 else {<br>        break<br>    }<br>    do { ... }<br>}<br></p><p>// or with if<br></p><p>while let x = y where x &lt; 4 {<br>    if case let .Some(a) = b where a &gt; 42 {<br>        ...<br>    } else { break }<br>}<br></p><p><br></p><p>Note that all these statements have a nice symmetry to their &quot;long form&quot;. These statements can also be similarly written without introducing a new scope and code duplication in else branches:<br></p><p>if ...<br>if ... {<br>    ...<br>} else { ... }<br></p><p>vs<br></p><p>if ... {<br>    if ... {<br>        ...<br>    } else { ... }<br>} else { ... }<br></p><p>Best regards<br>Maximilian<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9ce70a6cb7175e7a5e5db5658186a31?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Brandon Knope</string> &lt;bknope at me.com&gt;<p>May 31, 2016 at 03:00:00pm</p></header><div class="content"><p>I could be pedantic and say that &quot;previousInterestingFoo&quot; now relies on the newly bound &quot;foo&quot; on assignment in the while loop keeping it relevant contextually. <br></p><p>Ultimately, my responsibility as a user of the language is not to try to figure out the inner workings of the grammar or the compiler. It&#39;s not where my interests are or should be really.<br></p><p>My interests are the readability and expressiveness of using the language as I use the language. This is not a problem I have a solution for. But as a user of the language, dropping where and introducing semicolons in a lot of places will lead to much less readable code in my opinion, no matter what you say the compiler or grammar can or cannot do. <br></p><p>This may seem harsh, but as a user and advocate for the users, it&#39;s hard for me to recommend a feature that makes the language less readable just to fix the grammar. Am I suppose to care about the compiler or the grammar? Or is the usability of the language more important to me?<br></p><p>At the end of the day it&#39;s not up to me or the other dissenters, but we can at least voice our (rather strong) opinions and that&#39;s okay. <br></p><p>Compiler/grammar folks may strongly disagree with us but this is why we have community reviews: to bring together all users of all backgrounds to the discussion whether that be in compilers, grammar, teachers, etc. <br></p><p>Will this push me to stop programming in Swift if approved? No. <br></p><p>Will it make it a little less enjoyable for me to use? A little. <br></p><p>Brandon <br></p><p>&gt; On May 31, 2016, at 2:52 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; See, I&#39;d wondered about that early on. But it didn&#39;t sound like this was a restriction that could be formalized straightforwardly in the grammar.<br>&gt; <br>&gt; Even if it could, it is too restrictive. Consider:<br>&gt; <br>&gt; ```<br>&gt; var previousInterestingFoo = 0<br>&gt; <br>&gt; while let foo = sequence.next() where previousInterestingFoo &lt; 42 {<br>&gt;   // determine if foo is interesting<br>&gt;   // ...<br>&gt;   if interesting {<br>&gt;     previousInterestingFoo = foo<br>&gt;   }<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; If we enforce a rule like you propose, then this example above, which arguably does &quot;make sense contextually,&quot; would no longer be acceptable.<br>&gt; <br>&gt; Switching gears to a different argument: this proposal aims (among other things) to provide a way to make arbitrary Boolean assertions after a let binding in situations where the use of `where` is currently required but reads absurdly. Whatever alternative grammar is proposed for these arbitrary Boolean assertions will, by construction, *always* be useful regardless of the variables used in the assertion.<br>&gt; <br>&gt; Thus, if we keep `where` and enforce your proposed rule, you end up with two ways to express the same thing; `where` clauses would permit a strict subset of assertions that can be expressed using the alternative syntax. And, the compiler is conscripted to be an opinionated arbiter of style. That&#39;s a huge no-go.<br>&gt; <br>&gt; Or, you might say, &quot;I don&#39;t want to support arbitrary Boolean assertions after let bindings at all!&quot; Well then, if we try to enforce your proposed rule, then a user who wants to write `let y = y where x &lt; z` would be driven to this gem of a workaround: `let y = y where (y == y &amp;&amp; x &lt; z)`.<br>&gt; <br>&gt; These lines of reasoning are what have compelled me to conclude that `where` might not be salvageable.<br>&gt; <br>&gt;&gt; On Tue, May 31, 2016 at 13:04 Brandon Knope &lt;bknope at me.com&gt; wrote:<br>&gt;&gt; Except some of us have proposed only allowing unwrapped or newly bound variables in the where clause:<br>&gt;&gt; <br>&gt;&gt; if let y = y where y &lt; z should work<br>&gt;&gt; <br>&gt;&gt; If let y = y where x &lt; z should be an error because it doesn&#39;t need to be in a where clause and doesn&#39;t make sense contextually. <br>&gt;&gt; <br>&gt;&gt; I understand the rationale about why it should be removed...but I find it a little extreme and a little &quot;technical&quot; to the point that some of the personality of the language will be lost...all for the sake being &quot;technically&quot; correct. <br>&gt;&gt; <br>&gt;&gt; This may be why some of us are against the proposal. <br>&gt;&gt; <br>&gt;&gt; Brandon <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 31, 2016, at 1:16 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The motivating example is a compelling illustration of a problem with the current grammar. I don&#39;t think anyone would disagree that `if let y = y where x &lt; z` is an abomination.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Now, I see no principled criteria, and none have been proposed here, that would be useful to restrict what can come after `where`. Moreover, I see no contention with the argument that arbitrary Boolean assertions should be possible after a let binding.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Finally, it is a stated goal of the core team that there shouldn&#39;t be multiple &#39;dialects&#39; of Swift, and that where possible there should be one general solution rather than two options.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Given these premises, I have to conclude that *if* the motivating issue is to be fixed, we must get rid of `where`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Tue, May 31, 2016 at 11:53 Brandon Knope &lt;bknope at me.com&gt; wrote:<br>&gt;&gt;&gt;&gt; To be frank, I just find the proposed syntax to be more ugly and less expressive. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I just don&#39;t find the proposal compelling enough to take away one of the truly &quot;Swifty&quot; syntaxes that I have used and loved. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If there are other ways to keep &quot;where&quot; while fixing the ambiguity I would rather explore that than require semicolons everywhere. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I have a feeling that more would object but just aren&#39;t perusing the mailing lists. I think we will see much more activity come WWDC<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Brandon<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 31, 2016, at 12:25 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In English (and, I&#39;m guessing, many other languages), semicolons are used as a second &#39;tier&#39; of separators when commas become ambiguous. I&#39;m puzzled that a proposal to bring this longstanding convention to Swift is raising so many objections, even going so far as to prompt alternatives such as this that break clearly useful shorthands.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Tue, May 31, 2016 at 10:44 David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; Yet another alternative: would it be possible to disallow commas as variable declaration separators and use them for condition clause separators again:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let a = 4, b = 8 // becomes illegal and requires to separate them on two lines<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; if a &gt; 4, let c = foo(), let d = bar(), c != d { // now comma is not ambiguous anymore<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; David.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 28 May 2016, at 02:30, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 27, 2016, at 6:26 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; guard<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; x == 0 &amp;&amp; a == b &amp;&amp; c == d &amp;&amp;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let y = optional, w = optional2, v = optional 3 &amp;&amp;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; z == 2<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; else { ... }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Figuring out where to break the first line into expression and into condition (after the `d`) could be very challenging to the compiler.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I&#39;m not sure it is. `let` and `case` are not valid in an expression, so an `&amp;&amp;` followed by `let` or `case` must be joining clauses. On the other side of things, Swift&#39;s `&amp;&amp;` doesn&#39;t ever produce an optional, so if we&#39;re parsing an expression at the top level of an if-let, an `&amp;&amp;` must indicate the end of the clause. An if-case *could* theoretically include an `&amp;&amp;`, but pattern matching against a boolean value seems like a fairly useless thing to do in a context that&#39;s specifically intended to test booleans.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Let me answer in another way that speaks to my background which isn&#39;t in compiler theory: The use of &amp;&amp; may produce cognitive overload between the use in Boolean assertions and the use in separating condition clauses.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -- E<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/49c8fd61/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>May 31, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt;&gt; On May 27, 2016, at 5:30 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 27, 2016, at 6:26 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; guard<br>&gt;&gt;&gt;&gt; x == 0 &amp;&amp; a == b &amp;&amp; c == d &amp;&amp;<br>&gt;&gt;&gt;&gt; let y = optional, w = optional2, v = optional 3 &amp;&amp;<br>&gt;&gt;&gt;&gt; z == 2<br>&gt;&gt;&gt;&gt; else { ... }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Figuring out where to break the first line into expression and into condition (after the `d`) could be very challenging to the compiler.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m not sure it is. `let` and `case` are not valid in an expression, so an `&amp;&amp;` followed by `let` or `case` must be joining clauses. On the other side of things, Swift&#39;s `&amp;&amp;` doesn&#39;t ever produce an optional, so if we&#39;re parsing an expression at the top level of an if-let, an `&amp;&amp;` must indicate the end of the clause. An if-case *could* theoretically include an `&amp;&amp;`, but pattern matching against a boolean value seems like a fairly useless thing to do in a context that&#39;s specifically intended to test booleans.<br>&gt;&gt; <br>&gt;&gt; Let me answer in another way that speaks to my background which isn&#39;t in compiler theory: The use of &amp;&amp; may produce cognitive overload between the use in Boolean assertions and the use in separating condition clauses.<br>&gt;&gt; <br>&gt;&gt; -- E<br></p><p>In reality I often write if/guard statements using &amp;&amp; exactly the way Brent proposes, only to go back and rework it for syntax correctness. I started this message intending to argue for Brent’s proposal but I think I’ve talked myself out of it :)<br></p><p><br>&gt; On May 28, 2016, at 10:26 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; My suggestion would be to reuse our normal &amp;&amp; operator:<br>&gt;&gt; <br>&gt;&gt; 	guard<br>&gt;&gt; 		x == 0 &amp;&amp;<br>&gt;&gt; 		let y = optional &amp;&amp;<br>&gt;&gt; 		z == 2<br>&gt;&gt; 		else { ... }<br>&gt;&gt; <br>&gt;&gt; This would obviously be a built-in `&amp;&amp;` separate from our existing, infix operator `&amp;&amp;`. <br>&gt; <br>&gt; Yes, this is technically feasible, but it has the opposite problem from the above: &amp;&amp; is very closely associated (in terms of programmer mindspace) with boolean conditionals, and the let/case clauses are *not* boolean conditions.<br></p><p><br>I initially didn&#39;t think &amp;&amp; represents a problem, but I realized as I was working on this message there definitely is a serious issue: ||. I don’t see how you can work around it either and that seems to kill the idea of using &amp;&amp; no matter how you slice it.<br></p><p>	guard<br>		x == 0 &amp;&amp;<br>		let y = optional ||<br>		z == 2 &amp;&amp; y == 5 //is y optional or not?!?<br>		else { … }<br></p><p>You can’t have the optional let binding shortcut and use boolean values this way. You’d have to figure out if the expression always requires “y = optional” to succeed, then y’s type would be non-optional, otherwise y would be optional. That seems surprising and confusing.<br></p><p><br></p><p>What I really want is commas to separate different kinds of clauses because many cases read cleaner as a single line and C ruined semicolons for me, especially their use in for statements.<br></p><p><br>&gt; <br>&gt; The ambiguity is between “case” and “let” conditions, specifically because “case” takes a pattern, and “let” is a valid pattern:<br>&gt; <br>&gt; guard (pattern1) = expr1, let x = expr2 else<br>&gt; <br>&gt; can be:<br>&gt; <br>&gt; guard (pattern1) = expr1, let (x) = expr2 else<br>&gt; <br>&gt; or:<br>&gt; <br>&gt; guard (pattern1) = expr1, (let x) = expr2 else<br></p><p><br>I am probably missing something but why is this the case? In all of these forms the let is unambiguous; it either precedes the enum case or pattern (itself enclosed in parens), or the let is contained in the parens.<br></p><p>    if case let .Point(x, y) = value, let z = optional { }<br>    if case let (x, y) = value, let z = optional { }<br>    if case .Point(let x, _) = value, let z = optional { }<br>    if case (let x, 1.0) = value where x != 0.0, let z = optional { }<br></p><p><br></p><p>Russ<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 28, 2016 at 08:00:00am</p></header><div class="content"><p>Golang has IMO successfully used this in their IF statement. Coming from a recent imersion into the language, it is not as distracting in real life code on a day to day basis, as it might seem to be when first seen in a spec. Considering the parallel with the swift guard, this is IMO a nice advancement.<br></p><p>On May 28, 2016, at 1:35 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt;        https://github.com/apple/swift-evolution/blob/master/proposals/0099-conditionclauses.md<br>&gt; <br>&gt;&gt;    • What is your evaluation of the proposal?<br>&gt; <br>&gt; Oof.<br>&gt; <br>&gt; I am not a fan of this syntax. `;` reads very strongly as a statement ender to me, and yet at the same time, it&#39;s still visually quite close to `,`. My first impression was that the proposal had an embarrassing typo in the very first example.<br>&gt; <br>&gt; My suggestion would be to reuse our normal &amp;&amp; operator:<br>&gt; <br>&gt;    guard<br>&gt;        x == 0 &amp;&amp;<br>&gt;        let y = optional &amp;&amp;<br>&gt;        z == 2<br>&gt;        else { ... }<br>&gt; <br>&gt; This would obviously be a built-in `&amp;&amp;` separate from our existing, infix operator `&amp;&amp;`. (Well, unless we make `let` and `case` clauses return Bools in an `if` statement, and somehow teach the compiler that `&amp;&amp;` will return `false` if a binding fails.) But there is no ambiguity about the meaning of this code. It is obvious that both conditions have to succeed, and it is obvious that `z == 2` was not meant to be another optional binding. Honestly, in some ways it&#39;s more understandable than the status quo.<br>&gt; <br>&gt;&gt;    • Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; <br>&gt; Maybe, if we have a good enough solution. I don&#39;t think this is it.<br>&gt; <br>&gt;&gt;    • Does this proposal fit well with the feel and direction of Swift?<br>&gt; <br>&gt; I think it&#39;s kind of neutral, honestly.<br>&gt; <br>&gt;&gt;    • If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; <br>&gt; Most languages I&#39;ve used have `if` statements which take a simple boolean expression, so they don&#39;t face this problem.<br>&gt; <br>&gt;&gt;    • How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; Pretty much a glance.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 28, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On May 27, 2016, at 4:35 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; I am not a fan of this syntax. `;` reads very strongly as a statement ender to me,<br></p><p>Technically speaking, Swift uses semicolon as a separator, not a line ender.  We already use it to separate multiple expressions on the same line, typically when those expressions are side effecting:<br></p><p>   print(“foo”); print(“bar”)   // silly example<br></p><p>The proposal is consistent with this usage.<br></p><p>&gt; and yet at the same time, it&#39;s still visually quite close to `,`. My first impression was that the proposal had an embarrassing typo in the very first example.<br></p><p>Particularly if we end up with Matthew’s proposal to allow omitting the semicolon when it is at the end of the line, I think we’d end up with much nicer looking code in practice.  Here are a couple of random example conditions I pulled from AlamoFire (feel free to pick some of your own):<br></p><p>Now:<br>     if let<br>         path = fileURL.path,<br>         fileSize = try NSFileManager.defaultManager().attributesOfItemAtPath(path)[NSFileSize] as? NSNumber<br>     {<br>      <br></p><p>     guard let<br>            path = fileURL.path<br>            where NSFileManager.defaultManager().fileExistsAtPath(path, isDirectory: &amp;isDirectory) &amp;&amp; !isDirectory else<br>        {<br></p><p>        if let path = fileURL.path where NSFileManager.defaultManager().fileExistsAtPath(path) {<br></p><p><br>With SE-0099 + Matthew’s extension, this could be written more nicely as:<br></p><p>     if let path = fileURL.path<br>        let fileSize = try NSFileManager.defaultManager().attributesOfItemAtPath(path)[NSFileSize] as? NSNumber<br>     {<br></p><p>     guard let path = fileURL.path<br>           NSFileManager.defaultManager().fileExistsAtPath(path, isDirectory: &amp;isDirectory)<br>           !isDirectory else<br>        {<br></p><p>     if let path = fileURL.path; NSFileManager.defaultManager().fileExistsAtPath(path) {<br></p><p>To be clear, I’m not saying I prefer alamofire’s indentation style :-)<br></p><p><br>&gt; My suggestion would be to reuse our normal &amp;&amp; operator:<br>&gt; <br>&gt; 	guard<br>&gt; 		x == 0 &amp;&amp;<br>&gt; 		let y = optional &amp;&amp;<br>&gt; 		z == 2<br>&gt; 		else { ... }<br>&gt; <br>&gt; This would obviously be a built-in `&amp;&amp;` separate from our existing, infix operator `&amp;&amp;`.<br></p><p>Yes, this is technically feasible, but it has the opposite problem from the above: &amp;&amp; is very closely associated (in terms of programmer mindspace) with boolean conditionals, and the let/case clauses are *not* boolean conditions.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160528/3aa40665/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>May 28, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On 27 May 2016, at 20:11, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; 	• What is your evaluation of the proposal?<br></p><p>Uncertain. I understand the intent behind it, but personally I really like the where clause as it covers most cases where I need to mix and match, and I feel that it’s very clean, clear, reads well and encourages best practice. I definitely prefer the first of these two options:<br></p><p>	if let foo = maybeFoo where foo &gt; 5 { … }<br>	if let foo = maybeFoo; foo &gt; 5 { … }<br></p><p>I also get the intent behind semi-colon usage for avoiding ambiguity, but I’d prefer it to be optional for cases where I really need to use it. We could perhaps make the compiler more strict to encourage its use though, i.e- anywhere the comma becomes ambiguous visually a warning could appear suggesting a semi-colon?<br></p><p>&gt; 	• Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Simplification of some of the features of conditionals would certainly be nice, and easier to maintain. I wouldn’t say it’s critical though as personally I don’t encounter many issues with the current syntax.<br></p><p>&gt; 	• Does this proposal fit well with the feel and direction of Swift?<br></p><p>Hard to say, I like the consistency of having the where clause in regular conditionals rather than just loops, so I’m not in favour of that change. Semi-colon use kind of fits with how they’re used for multiple statements on a line, but I prefer how commas look within conditionals.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160528/462b0480/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 28, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; Am 28.05.2016 um 20:28 schrieb Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt;&gt; On 27 May 2016, at 20:11, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; 	• What is your evaluation of the proposal?<br>&gt; <br>&gt; Uncertain. I understand the intent behind it, but personally I really like the where clause as it covers most cases where I need to mix and match, and I feel that it’s very clean, clear, reads well and encourages best practice. I definitely prefer the first of these two options:<br>&gt; <br>&gt; 	if let foo = maybeFoo where foo &gt; 5 { … }<br>&gt; 	if let foo = maybeFoo; foo &gt; 5 { … }<br></p><p>I also prefer `where` iff the condition references a variable bound in the let-binding.<br></p><p>-Thorsten<br></p><p><br>&gt; <br>&gt; I also get the intent behind semi-colon usage for avoiding ambiguity, but I’d prefer it to be optional for cases where I really need to use it. We could perhaps make the compiler more strict to encourage its use though, i.e- anywhere the comma becomes ambiguous visually a warning could appear suggesting a semi-colon?<br>&gt; <br>&gt;&gt; 	• Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; <br>&gt; Simplification of some of the features of conditionals would certainly be nice, and easier to maintain. I wouldn’t say it’s critical though as personally I don’t encounter many issues with the current syntax.<br>&gt; <br>&gt;&gt; 	• Does this proposal fit well with the feel and direction of Swift?<br>&gt; <br>&gt; Hard to say, I like the consistency of having the where clause in regular conditionals rather than just loops, so I’m not in favour of that change. Semi-colon use kind of fits with how they’re used for multiple statements on a line, but I prefer how commas look within conditionals.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160528/c74f5dcd/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May 28, 2016 at 07:00:00pm</p></header><div class="content"><p>There&#39;s already an inconsistency in where clause behavior for `if` and<br>`while` versus `for` loops. It&#39;s nice IMO that the former uses are<br>eliminated in this proposal.<br></p><p>Again, whether declaring multiple variables after a single let is a good<br>idea or not is, I think, out of scope for this proposal. If it&#39;s changed<br>here, it should be changed everywhere, and that&#39;s another discussion<br>altogether.<br></p><p>On Sat, May 28, 2016 at 14:28 Haravikk via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On 27 May 2016, at 20:11, Joe Groff via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; • What is your evaluation of the proposal?<br>&gt;<br>&gt;<br>&gt; Uncertain. I understand the intent behind it, but personally I really like<br>&gt; the where clause as it covers most cases where I need to mix and match, and<br>&gt; I feel that it’s very clean, clear, reads well and encourages best<br>&gt; practice. I definitely prefer the first of these two options:<br>&gt;<br>&gt; if let foo = maybeFoo where foo &gt; 5 { … }<br>&gt; if let foo = maybeFoo; foo &gt; 5 { … }<br>&gt;<br>&gt; I also get the intent behind semi-colon usage for avoiding ambiguity, but<br>&gt; I’d prefer it to be optional for cases where I really need to use it. We<br>&gt; could perhaps make the compiler more strict to encourage its use though,<br>&gt; i.e- anywhere the comma becomes ambiguous visually a warning could appear<br>&gt; suggesting a semi-colon?<br>&gt;<br>&gt; • Is the problem being addressed significant enough to warrant a change to<br>&gt; Swift?<br>&gt;<br>&gt;<br>&gt; Simplification of some of the features of conditionals would certainly be<br>&gt; nice, and easier to maintain. I wouldn’t say it’s critical though as<br>&gt; personally I don’t encounter many issues with the current syntax.<br>&gt;<br>&gt; • Does this proposal fit well with the feel and direction of Swift?<br>&gt;<br>&gt;<br>&gt; Hard to say, I like the consistency of having the where clause in regular<br>&gt; conditionals rather than just loops, so I’m not in favour of that change.<br>&gt; Semi-colon use kind of fits with how they’re used for multiple statements<br>&gt; on a line, but I prefer how commas look within conditionals.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160528/ed2d0165/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>May 28, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On 28 May 2016, at 20:21, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; There&#39;s already an inconsistency in where clause behavior for `if` and `while` versus `for` loops. It&#39;s nice IMO that the former uses are eliminated in this proposal.<br></p><p>Can you give an example? That sounds like something that should be addressed separately rather than just dropping it.<br>Like I say I really like using it for basic bind + condition cases, so I’m very much opposed to just tossing where clauses.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May 28, 2016 at 08:00:00pm</p></header><div class="content"><p>I&#39;m just gotta quote from Advanced Swift:<br></p><p>Note that the where clause [in a for loop] does not work like the where<br>clause in a while loop. In a while loop, iteration stops once the value is<br>false, whereas in a for<br>loop, it functions like filter.<br></p><p>On Sat, May 28, 2016 at 16:00 Haravikk &lt;swift-evolution at haravikk.me&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On 28 May 2016, at 20:21, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; There&#39;s already an inconsistency in where clause behavior for `if` and<br>&gt; `while` versus `for` loops. It&#39;s nice IMO that the former uses are<br>&gt; eliminated in this proposal.<br>&gt;<br>&gt; Can you give an example? That sounds like something that should be<br>&gt; addressed separately rather than just dropping it.<br>&gt; Like I say I really like using it for basic bind + condition cases, so I’m<br>&gt; very much opposed to just tossing where clauses.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160528/69eb6d88/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9ce70a6cb7175e7a5e5db5658186a31?s=50"></div><header><strong>[Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Brandon Knope</string> &lt;bknope at me.com&gt;<p>May 28, 2016 at 04:00:00pm</p></header><div class="content"><p>Doesn&#39;t this contextually make sense though?<br></p><p>for, when read:<br>&quot;for each value in collection where some condition is met&quot; do this loop<br></p><p>while, when read:<br>&quot;while some condition where this constraint is met&quot; do this loop <br></p><p>It could just be because I know the behavior and am use to it, but I think it makes sense contextually when used. <br></p><p>Brandon <br></p><p>&gt; On May 28, 2016, at 4:06 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;m just gotta quote from Advanced Swift:<br>&gt; <br>&gt; Note that the where clause [in a for loop] does not work like the where clause in a while loop. In a while loop, iteration stops once the value is false, whereas in a for <br>&gt; loop, it functions like filter. <br>&gt; <br>&gt;&gt; On Sat, May 28, 2016 at 16:00 Haravikk &lt;swift-evolution at haravikk.me&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt; On 28 May 2016, at 20:21, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; There&#39;s already an inconsistency in where clause behavior for `if` and `while` versus `for` loops. It&#39;s nice IMO that the former uses are eliminated in this proposal.<br>&gt;&gt; <br>&gt;&gt; Can you give an example? That sounds like something that should be addressed separately rather than just dropping it.<br>&gt;&gt; Like I say I really like using it for basic bind + condition cases, so I’m very much opposed to just tossing where clauses.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160528/8dfd8ef4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 29, 2016 at 05:00:00pm</p></header><div class="content"><p>Totally agree with Brandon. I don’t think that behavior is inconsistent.<br></p><p>-Thorsten<br></p><p><br>&gt; Am 28.05.2016 um 22:18 schrieb Brandon Knope via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Doesn&#39;t this contextually make sense though?<br>&gt; <br>&gt; for, when read:<br>&gt; &quot;for each value in collection where some condition is met&quot; do this loop<br>&gt; <br>&gt; while, when read:<br>&gt; &quot;while some condition where this constraint is met&quot; do this loop <br>&gt; <br>&gt; It could just be because I know the behavior and am use to it, but I think it makes sense contextually when used. <br>&gt; <br>&gt; Brandon <br>&gt; <br>&gt; On May 28, 2016, at 4:06 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; I&#39;m just gotta quote from Advanced Swift:<br>&gt;&gt; <br>&gt;&gt; Note that the where clause [in a for loop] does not work like the where clause in a while loop. In a while loop, iteration stops once the value is false, whereas in a for <br>&gt;&gt; loop, it functions like filter. <br>&gt;&gt; <br>&gt;&gt; On Sat, May 28, 2016 at 16:00 Haravikk &lt;swift-evolution at haravikk.me &lt;mailto:swift-evolution at haravikk.me&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt; On 28 May 2016, at 20:21, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; There&#39;s already an inconsistency in where clause behavior for `if` and `while` versus `for` loops. It&#39;s nice IMO that the former uses are eliminated in this proposal.<br>&gt;&gt; <br>&gt;&gt; Can you give an example? That sounds like something that should be addressed separately rather than just dropping it.<br>&gt;&gt; Like I say I really like using it for basic bind + condition cases, so I’m very much opposed to just tossing where clauses.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160529/875644b2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May 29, 2016 at 03:00:00pm</p></header><div class="content"><p>I totally agree with Brandon that it makes sense in the context. But I<br>disagree with you: the behavior certainly isn&#39;t consistent. Those are two<br>orthogonal evaluations.<br></p><p>Personally, I&#39;ve never been tripped up by the two different meanings of<br>where clauses and I&#39;ve used both. Yet, when it was presented to me in prose<br>form in _Advanced Swift_ (a great read, btw), it was a shocking thing to<br>realize.<br></p><p>That these very experienced authors of the book felt compelled to point it<br>out to their audience, who are ostensibly all experienced users of the<br>language, suggests that there is something about the where clause not quite<br>intuitive for all people. So I consider it a net positive to eliminate the<br>inconsistency, whether or not it can be thought of as making sense.<br></p><p>On Sun, May 29, 2016 at 11:15 Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br></p><p>&gt; Totally agree with Brandon. I don’t think that behavior is inconsistent.<br>&gt;<br>&gt; -Thorsten<br>&gt;<br>&gt;<br>&gt; Am 28.05.2016 um 22:18 schrieb Brandon Knope via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt;<br>&gt; Doesn&#39;t this contextually make sense though?<br>&gt;<br>&gt; for, when read:<br>&gt; &quot;for each value in collection where some condition is met&quot; do this loop<br>&gt;<br>&gt; while, when read:<br>&gt; &quot;while some condition where this constraint is met&quot; do this loop<br>&gt;<br>&gt; It could just be because I know the behavior and am use to it, but I think<br>&gt; it makes sense contextually when used.<br>&gt;<br>&gt; Brandon<br>&gt;<br>&gt; On May 28, 2016, at 4:06 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I&#39;m just gotta quote from Advanced Swift:<br>&gt;<br>&gt; Note that the where clause [in a for loop] does not work like the where<br>&gt; clause in a while loop. In a while loop, iteration stops once the value is<br>&gt; false, whereas in a for<br>&gt; loop, it functions like filter.<br>&gt;<br>&gt; On Sat, May 28, 2016 at 16:00 Haravikk &lt;swift-evolution at haravikk.me&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; On 28 May 2016, at 20:21, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; There&#39;s already an inconsistency in where clause behavior for `if` and<br>&gt;&gt; `while` versus `for` loops. It&#39;s nice IMO that the former uses are<br>&gt;&gt; eliminated in this proposal.<br>&gt;&gt;<br>&gt;&gt; Can you give an example? That sounds like something that should be<br>&gt;&gt; addressed separately rather than just dropping it.<br>&gt;&gt; Like I say I really like using it for basic bind + condition cases, so<br>&gt;&gt; I’m very much opposed to just tossing where clauses.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160529/43321276/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9ce70a6cb7175e7a5e5db5658186a31?s=50"></div><header><strong>[Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Brandon Knope</string> &lt;bknope at me.com&gt;<p>May 29, 2016 at 03:00:00pm</p></header><div class="content"><p>What chapter is this in? I own this great book and would like to see what you are referring to!<br></p><p>Thanks,<br>Brandon <br></p><p>&gt; On May 29, 2016, at 11:32 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; I totally agree with Brandon that it makes sense in the context. But I disagree with you: the behavior certainly isn&#39;t consistent. Those are two orthogonal evaluations.<br>&gt; <br>&gt; Personally, I&#39;ve never been tripped up by the two different meanings of where clauses and I&#39;ve used both. Yet, when it was presented to me in prose form in _Advanced Swift_ (a great read, btw), it was a shocking thing to realize.<br>&gt; <br>&gt; That these very experienced authors of the book felt compelled to point it out to their audience, who are ostensibly all experienced users of the language, suggests that there is something about the where clause not quite intuitive for all people. So I consider it a net positive to eliminate the inconsistency, whether or not it can be thought of as making sense.<br>&gt; <br>&gt;&gt; On Sun, May 29, 2016 at 11:15 Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt; Totally agree with Brandon. I don’t think that behavior is inconsistent.<br>&gt;&gt; <br>&gt;&gt; -Thorsten<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Am 28.05.2016 um 22:18 schrieb Brandon Knope via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Doesn&#39;t this contextually make sense though?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; for, when read:<br>&gt;&gt;&gt; &quot;for each value in collection where some condition is met&quot; do this loop<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; while, when read:<br>&gt;&gt;&gt; &quot;while some condition where this constraint is met&quot; do this loop <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It could just be because I know the behavior and am use to it, but I think it makes sense contextually when used. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Brandon <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 28, 2016, at 4:06 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m just gotta quote from Advanced Swift:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Note that the where clause [in a for loop] does not work like the where clause in a while loop. In a while loop, iteration stops once the value is false, whereas in a for <br>&gt;&gt;&gt;&gt; loop, it functions like filter. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Sat, May 28, 2016 at 16:00 Haravikk &lt;swift-evolution at haravikk.me&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt; On 28 May 2016, at 20:21, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; There&#39;s already an inconsistency in where clause behavior for `if` and `while` versus `for` loops. It&#39;s nice IMO that the former uses are eliminated in this proposal.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Can you give an example? That sounds like something that should be addressed separately rather than just dropping it.<br>&gt;&gt;&gt;&gt;&gt; Like I say I really like using it for basic bind + condition cases, so I’m very much opposed to just tossing where clauses.<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160529/cab952e0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May 29, 2016 at 07:00:00pm</p></header><div class="content"><p>The chapter on optionals. Right in the thick of things about if let<br>binding, pattern matching, etc. It&#39;s a bit of a digression from the main<br>flow of things. In the PDF version it&#39;s p. 87 (at least, by Acrobat&#39;s<br>reckoning).<br></p><p>On Sun, May 29, 2016 at 15:28 Brandon Knope &lt;bknope at me.com&gt; wrote:<br></p><p>&gt; What chapter is this in? I own this great book and would like to see what<br>&gt; you are referring to!<br>&gt;<br>&gt; Thanks,<br>&gt; Brandon<br>&gt;<br>&gt; On May 29, 2016, at 11:32 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; I totally agree with Brandon that it makes sense in the context. But I<br>&gt; disagree with you: the behavior certainly isn&#39;t consistent. Those are two<br>&gt; orthogonal evaluations.<br>&gt;<br>&gt; Personally, I&#39;ve never been tripped up by the two different meanings of<br>&gt; where clauses and I&#39;ve used both. Yet, when it was presented to me in prose<br>&gt; form in _Advanced Swift_ (a great read, btw), it was a shocking thing to<br>&gt; realize.<br>&gt;<br>&gt; That these very experienced authors of the book felt compelled to point it<br>&gt; out to their audience, who are ostensibly all experienced users of the<br>&gt; language, suggests that there is something about the where clause not quite<br>&gt; intuitive for all people. So I consider it a net positive to eliminate the<br>&gt; inconsistency, whether or not it can be thought of as making sense.<br>&gt;<br>&gt; On Sun, May 29, 2016 at 11:15 Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;<br>&gt;&gt; Totally agree with Brandon. I don’t think that behavior is inconsistent.<br>&gt;&gt;<br>&gt;&gt; -Thorsten<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Am 28.05.2016 um 22:18 schrieb Brandon Knope via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt;:<br>&gt;&gt;<br>&gt;&gt; Doesn&#39;t this contextually make sense though?<br>&gt;&gt;<br>&gt;&gt; for, when read:<br>&gt;&gt; &quot;for each value in collection where some condition is met&quot; do this loop<br>&gt;&gt;<br>&gt;&gt; while, when read:<br>&gt;&gt; &quot;while some condition where this constraint is met&quot; do this loop<br>&gt;&gt;<br>&gt;&gt; It could just be because I know the behavior and am use to it, but I<br>&gt;&gt; think it makes sense contextually when used.<br>&gt;&gt;<br>&gt;&gt; Brandon<br>&gt;&gt;<br>&gt;&gt; On May 28, 2016, at 4:06 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I&#39;m just gotta quote from Advanced Swift:<br>&gt;&gt;<br>&gt;&gt; Note that the where clause [in a for loop] does not work like the where<br>&gt;&gt; clause in a while loop. In a while loop, iteration stops once the value is<br>&gt;&gt; false, whereas in a for<br>&gt;&gt; loop, it functions like filter.<br>&gt;&gt;<br>&gt;&gt; On Sat, May 28, 2016 at 16:00 Haravikk &lt;swift-evolution at haravikk.me&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; On 28 May 2016, at 20:21, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; There&#39;s already an inconsistency in where clause behavior for `if` and<br>&gt;&gt;&gt; `while` versus `for` loops. It&#39;s nice IMO that the former uses are<br>&gt;&gt;&gt; eliminated in this proposal.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Can you give an example? That sounds like something that should be<br>&gt;&gt;&gt; addressed separately rather than just dropping it.<br>&gt;&gt;&gt; Like I say I really like using it for basic bind + condition cases, so<br>&gt;&gt;&gt; I’m very much opposed to just tossing where clauses.<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160529/96d0071e/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>May 28, 2016 at 01:00:00pm</p></header><div class="content"><p>• What is your evaluation of the proposal?<br>+1<br>• Is the problem being addressed significant enough to warrant a change to<br>Swift?<br>Yes. I have often been frustrated by needing to break up conditions to make<br>complex checks. I am not completely sure that this proposal addresses that<br>issue but it is certainly a step in the direction of resolving it.<br>• Does this proposal fit well with the feel and direction of Swift?<br>Yes<br>• If you have used other languages or libraries with a similar feature, how<br>do you feel that this proposal compares to those?<br>Yes. I think that this compares well. It also helps stabilize coding style<br>decisions.<br>• How much effort did you put into your review? A glance, a quick reading,<br>or an in-depth study?<br>A couple quick readings.<br></p><p>On Fri, May 27, 2016 at 1:11 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br></p><p>&gt; Hello Swift community,<br>&gt;<br>&gt; The review of SE-0099 “Restructuring Condition Clauses” begins now and<br>&gt; runs through June 3, 2016. The proposal is available here:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0099-conditionclauses.md<br>&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt; should be sent to the swift-evolution mailing list at<br>&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the<br>&gt; review manager. When replying, please try to keep the proposal link at<br>&gt; the top of the message:<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; * Proposal link:<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0099-conditionclauses.md<br>&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0099-conditionclauses.md&gt;<br>&gt; Reply text Other replies*<br>&gt;<br>&gt; *What goes into a review?*<br>&gt; The goal of the review process is to improve the proposal under review<br>&gt; through constructive criticism and, eventually, determine the direction of<br>&gt; Swift. When writing your review, here are some questions you might want to<br>&gt; answer in your review:<br>&gt;<br>&gt; • What is your evaluation of the proposal?<br>&gt; • Is the problem being addressed significant enough to warrant a change to<br>&gt; Swift?<br>&gt; • Does this proposal fit well with the feel and direction of Swift?<br>&gt; • If you have used other languages or libraries with a similar feature,<br>&gt; how do you feel that this proposal compares to those?<br>&gt; • How much effort did you put into your review? A glance, a quick reading,<br>&gt; or an in-depth study?<br>&gt;<br>&gt; More information about the Swift evolution process is available at<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;<br>&gt; Thank you,<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt; Review Manager<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution-announce mailing list<br>&gt; swift-evolution-announce at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution-announce<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160528/bfa1bf80/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 28, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On May 27, 2016, at 12:11 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of SE-0099 “Restructuring Condition Clauses” begins now and runs through June 3, 2016. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0099-conditionclauses.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0099-conditionclauses.md&gt;<br>Thanks everyone.  FYI, Erica and I discussed it offlist and agreed to amend the proposal: now you can use semicolons or a newline to separate clauses of different types.<br></p><p>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160528/ec3edc1e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>May 29, 2016 at 03:00:00pm</p></header><div class="content"><p>New proposal looks great. I love how this brings more consistency with how normal statements are written.<br></p><p>It would be nice to see in the proposal examples of before &amp; afters for `while` too. Especially as it says &quot;where clauses are no longer used to conjoin Boolean expressions with conditional binding. This fixes user confusion issues and addresses a problem where Boolean conditions need to be attached to arbitrary bindings.” An example of this?<br></p><p><br>&gt; On 29 May 2016, at 8:48 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 27, 2016, at 12:11 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello Swift community,<br>&gt;&gt; <br>&gt;&gt; The review of SE-0099 “Restructuring Condition Clauses” begins now and runs through June 3, 2016. The proposal is available here:<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0099-conditionclauses.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0099-conditionclauses.md&gt;<br>&gt; Thanks everyone.  FYI, Erica and I discussed it offlist and agreed to amend the proposal: now you can use semicolons or a newline to separate clauses of different types.<br>&gt; <br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160529/8773bcbb/attachment-0001.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>May 29, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On 28 May 2016, at 23:48, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 27, 2016, at 12:11 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello Swift community,<br>&gt;&gt; <br>&gt;&gt; The review of SE-0099 “Restructuring Condition Clauses” begins now and runs through June 3, 2016. The proposal is available here:<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0099-conditionclauses.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0099-conditionclauses.md&gt;<br>&gt; Thanks everyone.  FYI, Erica and I discussed it offlist and agreed to amend the proposal: now you can use semicolons or a newline to separate clauses of different types.<br></p><p>While I like the improvements made to the proposal, I’m still not in favour of removing the where clause; the introduction of semi-colons and new-lines as separators eliminates the need to use it if you don’t want to, so developers will be free to drop it if they wish, but I don’t see any real reason to remove it from the syntax, as it feels inconsistent if I can use it elsewhere, and I prefer to do so, particularly on if/guard.<br></p><p>I get that there’s some inconsistency between the use of where on while and for loops, but actually the behaviour on while loops can be desirable, and I feel the ambiguity could be addressed in other ways. I feel like removing or changing the where clause should be its own issue, and this one should be focused on removing the ambiguity caused by the use of commas, as anyone that wants semi-colons but also likes to use where is forced to oppose the whole proposal as they’re not mutually exclusive.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160529/5fce532c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>May 29, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On 28 May 2016, at 23:48, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 27, 2016, at 12:11 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello Swift community,<br>&gt;&gt; <br>&gt;&gt; The review of SE-0099 “Restructuring Condition Clauses” begins now and runs through June 3, 2016. The proposal is available here:<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0099-conditionclauses.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0099-conditionclauses.md&gt;<br>&gt; Thanks everyone.  FYI, Erica and I discussed it offlist and agreed to amend the proposal: now you can use semicolons or a newline to separate clauses of different types.<br></p><p><br>I just don&#39;t understand why there are large fractions of the community, fighting to have a uniform syntax without any dialects, not being in favor of e.g. an optional warning to enforce explicit self, which could prevent people from bugs, yet then a proposal with three (!) allowed syntax variations is introduced.<br></p><p>The `where` clause improved readability - it might not have had anything to do syntactically with the optional binding, but it usually made some kind of sense:<br></p><p>guard let myPoint = view.calculateSomePoint() where view.isVisible else { ... }<br></p><p>Seems perfectly reasonable and much more readable than<br></p><p>guard let myPoint = view.calculateSomePoint(); view.isVisible else { ... }<br></p><p>-1 for me.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160529/35e180f6/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May 29, 2016 at 02:00:00pm</p></header><div class="content"><p>Haravikk, this *is* the proposal for removing where clauses; changing the<br>rules about commas was the later addition to the discussion.<br></p><p>On Sun, May 29, 2016 at 06:55 Haravikk via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On 28 May 2016, at 23:48, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On May 27, 2016, at 12:11 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;<br>&gt; Hello Swift community,<br>&gt;<br>&gt; The review of SE-0099 “Restructuring Condition Clauses” begins now and<br>&gt; runs through June 3, 2016. The proposal is available here:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0099-conditionclauses.md<br>&gt;<br>&gt;<br>&gt; Thanks everyone.  FYI, Erica and I discussed it offlist and agreed to<br>&gt; amend the proposal: now you can use semicolons or a newline to separate<br>&gt; clauses of different types.<br>&gt;<br>&gt;<br>&gt; While I like the improvements made to the proposal, I’m still not in<br>&gt; favour of removing the where clause; the introduction of semi-colons and<br>&gt; new-lines as separators eliminates the need to use it if you don’t want to,<br>&gt; so developers will be free to drop it if they wish, but I don’t see any<br>&gt; real reason to remove it from the syntax, as it feels inconsistent if I can<br>&gt; use it elsewhere, and I prefer to do so, particularly on if/guard.<br>&gt;<br>&gt; I get that there’s some inconsistency between the use of where on while<br>&gt; and for loops, but actually the behaviour on while loops can be desirable,<br>&gt; and I feel the ambiguity could be addressed in other ways. I feel like<br>&gt; removing or changing the where clause should be its own issue, and this one<br>&gt; should be focused on removing the ambiguity caused by the use of commas, as<br>&gt; anyone that wants semi-colons but also likes to use where is forced to<br>&gt; oppose the whole proposal as they’re not mutually exclusive.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160529/b4c6f0c1/attachment-0001.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 29, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On May 29, 2016, at 3:55 AM, Haravikk &lt;swift-evolution at haravikk.me&gt; wrote:<br>&gt;&gt;&gt; On May 27, 2016, at 12:11 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The review of SE-0099 “Restructuring Condition Clauses” begins now and runs through June 3, 2016. The proposal is available here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0099-conditionclauses.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0099-conditionclauses.md&gt;<br>&gt;&gt; Thanks everyone.  FYI, Erica and I discussed it offlist and agreed to amend the proposal: now you can use semicolons or a newline to separate clauses of different types.<br>&gt; <br>&gt; While I like the improvements made to the proposal, I’m still not in favour of removing the where clause; the introduction of semi-colons and new-lines as separators eliminates the need to use it if you don’t want to, so developers will be free to drop it if they wish, but I don’t see any real reason to remove it from the syntax, as it feels inconsistent if I can use it elsewhere, and I prefer to do so, particularly on if/guard.<br></p><p>I can definitely respect the position that “where” feels more readable than a semicolon, it certainly provides a more “fluent” style.<br></p><p>That said, the existing Swift 2 syntax was inconsistent about this too: if you started a condition with an availability check, you comma separate it from a boolean with a comma:<br></p><p>	if #available(iOS 52, *), x == y {} <br></p><p>While we could have used “where” here, it was counterproductive because it didn’t increase clarity of code.<br></p><p>&gt; I get that there’s some inconsistency between the use of where on while and for loops, but actually the behaviour on while loops can be desirable, and I feel the ambiguity could be addressed in other ways. I feel like removing or changing the where clause should be its own issue, and this one should be focused on removing the ambiguity caused by the use of commas, as anyone that wants semi-colons but also likes to use where is forced to oppose the whole proposal as they’re not mutually exclusive.<br></p><p>It would certainly be possible to allow a developer to write either a semicolon or a where clause, but that would just encourage divergent styles.  My problem with “where” is that it cannot be used uniformly and consistently.  I’d rather go with something that can be used uniformly, particularly given its use for the same thing elsewhere in the language (reducing complexity of the language by a tiny bit).<br></p><p>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160529/b566f027/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>May 30, 2016 at 12:00:00am</p></header><div class="content"><p>+1 again.<br></p><p>&gt; On 29 May 2016, at 21:39, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On May 29, 2016, at 3:55 AM, Haravikk &lt;swift-evolution at haravikk.me&gt; wrote:<br>&gt;&gt;&gt;&gt; On May 27, 2016, at 12:11 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The review of SE-0099 “Restructuring Condition Clauses” begins now and runs through June 3, 2016. The proposal is available here:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0099-conditionclauses.md<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks everyone.  FYI, Erica and I discussed it offlist and agreed to amend the proposal: now you can use semicolons or a newline to separate clauses of different types.<br>&gt;&gt; <br>&gt;&gt; While I like the improvements made to the proposal, I’m still not in favour of removing the where clause; the introduction of semi-colons and new-lines as separators eliminates the need to use it if you don’t want to, so developers will be free to drop it if they wish, but I don’t see any real reason to remove it from the syntax, as it feels inconsistent if I can use it elsewhere, and I prefer to do so, particularly on if/guard.<br>&gt; <br>&gt; I can definitely respect the position that “where” feels more readable than a semicolon, it certainly provides a more “fluent” style.<br>&gt; <br>&gt; That said, the existing Swift 2 syntax was inconsistent about this too: if you started a condition with an availability check, you comma separate it from a boolean with a comma:<br>&gt; <br>&gt; 	if #available(iOS 52, *), x == y {} <br>&gt; <br>&gt; While we could have used “where” here, it was counterproductive because it didn’t increase clarity of code.<br>&gt; <br>&gt;&gt; I get that there’s some inconsistency between the use of where on while and for loops, but actually the behaviour on while loops can be desirable, and I feel the ambiguity could be addressed in other ways. I feel like removing or changing the where clause should be its own issue, and this one should be focused on removing the ambiguity caused by the use of commas, as anyone that wants semi-colons but also likes to use where is forced to oppose the whole proposal as they’re not mutually exclusive.<br>&gt; <br>&gt; It would certainly be possible to allow a developer to write either a semicolon or a where clause, but that would just encourage divergent styles.  My problem with “where” is that it cannot be used uniformly and consistently.  I’d rather go with something that can be used uniformly, particularly given its use for the same thing elsewhere in the language (reducing complexity of the language by a tiny bit).<br>&gt; <br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160530/7feaf8f7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May 30, 2016 at 01:00:00am</p></header><div class="content"><p>+1 from me as well.<br></p><p>On Sun, May 29, 2016 at 18:39 David Hart via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; +1 again.<br>&gt;<br>&gt; On 29 May 2016, at 21:39, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On May 29, 2016, at 3:55 AM, Haravikk &lt;swift-evolution at haravikk.me&gt; wrote:<br>&gt;<br>&gt; On May 27, 2016, at 12:11 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;<br>&gt; Hello Swift community,<br>&gt;<br>&gt; The review of SE-0099 “Restructuring Condition Clauses” begins now and<br>&gt; runs through June 3, 2016. The proposal is available here:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0099-conditionclauses.md<br>&gt;<br>&gt;<br>&gt; Thanks everyone.  FYI, Erica and I discussed it offlist and agreed to<br>&gt; amend the proposal: now you can use semicolons or a newline to separate<br>&gt; clauses of different types.<br>&gt;<br>&gt;<br>&gt; While I like the improvements made to the proposal, I’m still not in<br>&gt; favour of removing the where clause; the introduction of semi-colons and<br>&gt; new-lines as separators eliminates the need to use it if you don’t want to,<br>&gt; so developers will be free to drop it if they wish, but I don’t see any<br>&gt; real reason to remove it from the syntax, as it feels inconsistent if I can<br>&gt; use it elsewhere, and I prefer to do so, particularly on if/guard.<br>&gt;<br>&gt;<br>&gt; I can definitely respect the position that “where” feels more readable<br>&gt; than a semicolon, it certainly provides a more “fluent” style.<br>&gt;<br>&gt; That said, the existing Swift 2 syntax was inconsistent about this too: if<br>&gt; you started a condition with an availability check, you comma separate it<br>&gt; from a boolean with a comma:<br>&gt;<br>&gt; if #available(iOS 52, *), x == y {}<br>&gt;<br>&gt; While we could have used “where” here, it was counterproductive because it<br>&gt; didn’t increase clarity of code.<br>&gt;<br>&gt; I get that there’s some inconsistency between the use of where on while<br>&gt; and for loops, but actually the behaviour on while loops can be desirable,<br>&gt; and I feel the ambiguity could be addressed in other ways. I feel like<br>&gt; removing or changing the where clause should be its own issue, and this one<br>&gt; should be focused on removing the ambiguity caused by the use of commas, as<br>&gt; anyone that wants semi-colons but also likes to use where is forced to<br>&gt; oppose the whole proposal as they’re not mutually exclusive.<br>&gt;<br>&gt;<br>&gt; It would certainly be possible to allow a developer to write either a<br>&gt; semicolon or a where clause, but that would just encourage divergent<br>&gt; styles.  My problem with “where” is that it cannot be used uniformly and<br>&gt; consistently.  I’d rather go with something that can be used uniformly,<br>&gt; particularly given its use for the same thing elsewhere in the language<br>&gt; (reducing complexity of the language by a tiny bit).<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160530/32cafaf3/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9ce70a6cb7175e7a5e5db5658186a31?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Brandon Knope</string> &lt;bknope at me.com&gt;<p>May 29, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On May 29, 2016, at 3:39 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I can definitely respect the position that “where” feels more readable than a semicolon, it certainly provides a more “fluent” style.<br>&gt; <br>&gt; That said, the existing Swift 2 syntax was inconsistent about this too: if you started a condition with an availability check, you comma separate it from a boolean with a comma:<br>&gt; <br>&gt; 	if #available(iOS 52, *), x == y {} <br>&gt; <br>&gt; While we could have used “where” here, it was counterproductive because it didn’t increase clarity of code.<br></p><p>iOS 10 is actually iOS 52! Confirmed!<br></p><p>Two things: see here I don&#39;t think where makes sense. I think &quot;where&quot; should only be allowed on a newly introduced variable, such as optional binding or for or while loops:<br></p><p>if let x = someCondition where x == y { } //x is a newly introduced variable, making the where clause make sense <br></p><p>for x in someArray where x == y { }<br></p><p>etc...<br></p><p>Doing:<br>if #available(iOS 52, *) where x == y {}<br></p><p>Should be an error in my opinion.<br></p><p>Second: I have gotten use to this awesome fluent readable style and reverting to a somewhat &quot;cold&quot; and not as readable style is going to be rough for some of us at first. But I will of course defer to the greater community. <br></p><p>I *do* think we should wait for WWDC where we can get more opinions on this however. I have a feeling if we change this before WWDC it will catch a lot of people off guard (pun intended?) and will probably bring up the discussion again. <br></p><p>---<br></p><p>Is there any way that we can keep &quot;where&quot; while remaining consistent? (I.e. My suggestion above)?  If not I can drop the argument. <br></p><p>Until then, still a -1 from me<br></p><p>Brandon<br></p><p><br></p><p><br></p><p>&gt; <br>&gt;&gt; I get that there’s some inconsistency between the use of where on while and for loops, but actually the behaviour on while loops can be desirable, and I feel the ambiguity could be addressed in other ways. I feel like removing or changing the where clause should be its own issue, and this one should be focused on removing the ambiguity caused by the use of commas, as anyone that wants semi-colons but also likes to use where is forced to oppose the whole proposal as they’re not mutually exclusive.<br>&gt; <br>&gt; It would certainly be possible to allow a developer to write either a semicolon or a where clause, but that would just encourage divergent styles.  My problem with “where” is that it cannot be used uniformly and consistently.  I’d rather go with something that can be used uniformly, particularly given its use for the same thing elsewhere in the language (reducing complexity of the language by a tiny bit).<br>&gt; <br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>May 30, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On 29 May 2016, at 20:39, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On May 29, 2016, at 3:55 AM, Haravikk &lt;swift-evolution at haravikk.me &lt;mailto:swift-evolution at haravikk.me&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; On May 27, 2016, at 12:11 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The review of SE-0099 “Restructuring Condition Clauses” begins now and runs through June 3, 2016. The proposal is available here:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0099-conditionclauses.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0099-conditionclauses.md&gt;<br>&gt;&gt;&gt; Thanks everyone.  FYI, Erica and I discussed it offlist and agreed to amend the proposal: now you can use semicolons or a newline to separate clauses of different types.<br>&gt;&gt; <br>&gt;&gt; While I like the improvements made to the proposal, I’m still not in favour of removing the where clause; the introduction of semi-colons and new-lines as separators eliminates the need to use it if you don’t want to, so developers will be free to drop it if they wish, but I don’t see any real reason to remove it from the syntax, as it feels inconsistent if I can use it elsewhere, and I prefer to do so, particularly on if/guard.<br>&gt; <br>&gt; I can definitely respect the position that “where” feels more readable than a semicolon, it certainly provides a more “fluent” style.<br>&gt; <br>&gt; That said, the existing Swift 2 syntax was inconsistent about this too: if you started a condition with an availability check, you comma separate it from a boolean with a comma:<br>&gt; <br>&gt; 	if #available(iOS 52, *), x == y {} <br>&gt; <br>&gt; While we could have used “where” here, it was counterproductive because it didn’t increase clarity of code.<br></p><p>See I never write statements like these. In fact, I almost never write conditionals that aren’t something like the following:<br></p><p>	if foo &amp;&amp; (bar == “bar”) { … }<br>	if let value = foo { … }<br>	if let value = foo where value &gt; 5 { … }<br>	if #available(iOS 52, *) { … }<br></p><p>I’m starting to use pattern matching more, but I only found out about the existence of that feature relatively recently as a result of subscribing to this list ;)<br></p><p>Point being that the third case is the only one where I ever do any real mixing and matching. Of course I can’t guarantee that I’ll never need something more complex some day, but I’ve managed pretty well so far without running into problems.<br></p><p>&gt; On 29 May 2016, at 15:15, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; Haravikk, this *is* the proposal for removing where clauses; changing the rules about commas was the later addition to the discussion.<br></p><p>Still, I feel like these are two different issues, as I’m generally in favour of the switch to semi-colon separators (though I do prefer how commas look, but that’s minor as I almost never use them, and mostly for binding multiple values which looks like it will still be able to use commas anyway), but I’m very fond of using where for the mixing and matching.<br></p><p>I understand that the need for semi-colon separators probably arose as a requirement of removing where, but I think it makes more sense to cover semi-colons first as a result, and come back to removing where clauses afterwards.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160530/fce0bb2d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 30, 2016 at 02:00:00pm</p></header><div class="content"><p>On 30.05.2016 13:40, Haravikk via swift-evolution wrote:<br> &gt;...<br>&gt; I understand that the need for semi-colon separators probably arose as a<br>&gt; requirement of removing where, but I think it makes more sense to cover<br>&gt; semi-colons first as a result, and come back to removing where clauses<br>&gt; afterwards.<br></p><p>Totally agree with Haravikk&#39;s opinion. For me also, the removing of `where` <br>should be a separate proposal not connected with this &#39;semi-colon&#39; <br>proposal. IMO they shouldn&#39;t be tight coupled into the same proposal so we <br>have to choose now all-or-nothing.<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>May 30, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On May 28, 2016, at 4:48 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 27, 2016, at 12:11 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello Swift community,<br>&gt;&gt; <br>&gt;&gt; The review of SE-0099 “Restructuring Condition Clauses” begins now and runs through June 3, 2016. The proposal is available here:<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0099-conditionclauses.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0099-conditionclauses.md&gt;<br>&gt; Thanks everyone.  FYI, Erica and I discussed it offlist and agreed to amend the proposal: now you can use semicolons or a newline to separate clauses of different types.<br>&gt; <br>&gt; -Chris<br></p><p>Also, I updated the proposal to make clear that `where` clauses are being removed from both binding conditions and case conditions. This will not affect the use of where clauses elsewhere, such as in for-in loops and switch statements.<br></p><p>-- E<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160530/dcc5dd1e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 31, 2016 at 03:00:00am</p></header><div class="content"><p>&gt; On May 30, 2016, at 10:54 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On May 28, 2016, at 4:48 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On May 27, 2016, at 12:11 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The review of SE-0099 “Restructuring Condition Clauses” begins now and runs through June 3, 2016. The proposal is available here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0099-conditionclauses.md<br>&gt;&gt; <br>&gt;&gt; Thanks everyone.  FYI, Erica and I discussed it offlist and agreed to amend the proposal: now you can use semicolons or a newline to separate clauses of different types.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt; <br>&gt; Also, I updated the proposal to make clear that `where` clauses are being removed from both binding conditions and case conditions. This will not affect the use of where clauses elsewhere, such as in for-in loops and switch statements.<br>&gt; <br></p><p>+1  nice and simple<br></p><p><br>&gt; -- E<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/88b41d64/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 30, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; Thanks everyone.  FYI, Erica and I discussed it offlist and agreed to amend the proposal: now you can use semicolons or a newline to separate clauses of different types.<br></p><p>This change does not alter my concern about the overloading of the semicolon as a statement separator, and in fact, it introduces new ones about code formatting. Putting newlines in the middle of a compound conditional has always led to awkward questions about how deeply you should indent the conditions, the curly bracket or `else` keyword, and the contents of the block. Syntactically encouraging *every* compound conditional to use newlines, as you propose, only makes this issue worse.<br></p><p>I continue to believe that, however complicated it may be for the compiler, the right answer is to use `&amp;&amp;`, which expresses the desired semantic. Barring that, I prefer the current situation, messy as it may be, to this proposal. I simply cannot support overloading something as fundamental to the language as its statement separators (`;` and newline), even if the compiler can tell the difference. It was a mistake in the C-style for loop and it would be a mistake here as well.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0099: Restructuring Condition Clauses</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 31, 2016 at 03:00:00am</p></header><div class="content"><p>On May 31, 2016, at 12:54 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; Thanks everyone.  FYI, Erica and I discussed it offlist and agreed to amend the proposal: now you can use semicolons or a newline to separate clauses of different types.<br>&gt; <br>&gt; This change does not alter my concern about the overloading of the semicolon as a statement separator, and in fact, it introduces new ones about code formatting. Putting newlines in the middle of a compound conditional has always led to awkward questions about how deeply you should indent the conditions, the curly bracket or `else` keyword, and the contents of the block. Syntactically encouraging *every* compound conditional to use newlines, as you propose, only makes this issue worse.<br>&gt; <br>&gt; I continue to believe that, however complicated it may be for the compiler, the right answer is to use `&amp;&amp;`,<br></p><p>-1  visual clutter<br></p><p>&gt; which expresses the desired semantic. Barring that, I prefer the current situation, messy as it may be, to this proposal. I simply cannot support overloading something as fundamental to the language as its statement separators (`;` and newline), even if the compiler can tell the difference. It was a mistake in the C-style for loop and it would be a mistake here as well.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76eb9711d45c1c9a71c0f24004072a22?s=50"></div><header><strong>[Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Zach Waldowski</string> &lt;zach at waldowski.me&gt;<p>May 30, 2016 at 09:00:00am</p></header><div class="content"><p>I have  concerns. Responses inline.<br> <br>Sincerely,<br>Zachary Waldowski<br>zach at waldowski.me<br> <br> <br>On Fri, May 27, 2016, at 12:11 PM, Joe Groff via swift-evolution wrote:<br>&gt; • What is your evaluation of the proposal?<br> <br>-1. Neither semicolon-based nor newline-based conditionals strike me as<br>sufficiently better, and I do not feel it achieves its overall goal of<br>being easier to read.<br> <br>The &quot;;&quot; did not pass my initial sniff test of readability. Though its<br>rationale is convincing, I found it difficult to parse a &quot;;&quot;-based<br>conditional as something being capable of short-circuiting and<br>binding. I personally would prefer resolving the ambiguities around<br>the &quot;,&quot;, though I cannot speak to the feasibility of that relative to<br>the compiler.<br> <br>The newline-based version gives me particular heartburn. I do not agree<br>with the notion that conditional lists and multi-line statements are<br>long-lost twins. The proposed syntax damages the context-awareness of<br>an element in a conditional list; conditionals must be read and<br>executed holistically, but, with the new syntax, an isolated line is<br>not clearly a part.<br> <br>Consider, for example, a transposition of a few lines; regular<br>statements enjoy a low rate of accidental behavioral change  without<br>comparable syntax change (because of optional bindings, guard, etc). My<br>current project team has a hard time resolving merge conflicts (ironic -<br>it causes a lot of them too). I don&#39;t have to work hard to imagine a<br>scenario like &quot;goto fail;&quot; with one of these newline-based conditionals,<br>which would be an unfortunate backslide for Swift.<br> <br>&gt; • Is the problem being addressed significant enough to warrant a<br>&gt; change to Swift?<br> <br>Yes. The current syntax(es) are often surprising as to what kinds of<br>checks, bindings, and pattern matches can be achieved in a single<br>conditional. If one member of a team is more fluent in the available<br>combinations of Swift conditionals than another, it&#39;s not uncommon<br>for the other member to review code and say, &quot;Wow, are you sure you<br>can do that?&quot;<br> <br>&gt; • Does this proposal fit well with the feel and direction of Swift?<br> <br>It is strongly in line with Swift&#39;s direction to combine many organically-<br>added syntax variations into a single overarching vision.<br> <br>I have misgivings about a change like this coming to a head so close to<br>Swift 3&#39;s coming-out party.<br> <br>&gt; • If you have used other languages or libraries with a similar<br>&gt; feature, how do you feel that this proposal compares to those?<br> <br>I haven&#39;t seen the semicolon syntax before (except maybe in C-<br>style for loops), making it a fairly novel and surprising addition<br>to the language.<br> <br>Both forms of the new syntax give me concerns, but the Pythonic quality<br>of the newline-based version does in particular.<br> <br>&gt; • How much effort did you put into your review? A glance, a quick<br>&gt; reading, or an in-depth study?<br> <br>I read through the revised proposal in detail.<br> <br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br> <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160530/f816ea8c/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/15ed660cd9d971062f9dd5084932a698?s=50"></div><header><strong>[Review] SE-0099: Restructuring Condition Clauses</strong> from <string>David Rönnqvist</string> &lt;david.ronnqvist at gmail.com&gt;<p>May 30, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; 	• What is your evaluation of the proposal?<br></p><p>Mixed. But I think it leans towards the negative. <br></p><p>At first I thought it was a big improvement, but after looking at how our team currently writes guard statements, the where clause is almost always using the unwrapped value (as opposed to an arbitrary boolean condition). The way we’ve been using it makes it feels like the optional unwrapping and the where clause belongs together, and I find that the where keyword is easy to skim for at the end of the line to look for other criteria on the unwrapped value.<br></p><p>Also, in most of our cases (although that may be because of the current syntax) there is only one where clause and no further unwrapping after that. In such cases, I find the current syntax very readable. More so than I find the semicolon syntax. <br></p><p>guard let x = someOptional where x &gt; 0 <br>    else { }<br></p><p>I acknowledge that the semicolon (or newline) versions are &quot;simpler&quot; and probably more suited for complex guard statements with many conditions and possibly also a mix of conditions that aren’t directly related to the optional unwrapping before them. However, I would not want to trade for that for what I feel is the more readable syntax in the more common cases.<br></p><p>Also, if I read the proposal correctly it would be possible to combine different boolean conditions using a “;”. Meaning this:<br></p><p>if x == 0 &amp;&amp; y &gt; x { }<br></p><p>would be the same as this:<br></p><p>if x == 0; y &gt; x { }<br></p><p>which is more consistent in combining conditions but introduces two different ways of AND-ing two boolean conditions. <br>It’s currently not possible to combine boolean conditions with a comma like this, and if that remains the case with semicolons, then this isn’t an issue.<br></p><p><br>&gt; 	• Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>I&#39;m not sure about that. <br></p><p>&gt; 	• Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes<br></p><p>&gt; 	• If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>No<br></p><p>&gt; 	• How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>Read the proposal in detail.<br></p><p>- David<br></p><p>27 maj 2016 kl. 21:11 skrev Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br></p><p>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of SE-0099 “Restructuring Condition Clauses” begins now and runs through June 3, 2016. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0099-conditionclauses.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0099-conditionclauses.md&gt;<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br>&gt; <br>&gt; 	Proposal link:<br>&gt; <br>&gt; 		https://github.com/apple/swift-evolution/blob/master/proposals/0099-conditionclauses.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0099-conditionclauses.md&gt;<br>&gt; <br>&gt; 	Reply text<br>&gt; <br>&gt; 	Other replies<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	• What is your evaluation of the proposal?<br>&gt; 	• Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	• Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	• If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	• How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt; Review Manager<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160530/8c0c2dae/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b2fc174169a3054f2e9bcb366884b02b?s=50"></div><header><strong>[Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Fabian Ehrentraud</string> &lt;Fabian.Ehrentraud at willhaben.at&gt;<p>June  6, 2016 at 06:00:00am</p></header><div class="content"><p>• What is your evaluation of the proposal?<br>-1 for the current proposal, +1 for being able to mix regular boolean expressions and `let` expressions.<br></p><p>• Is the problem being addressed significant enough to warrant a change to Swift?<br>Yes, not being able to mix different clause types feels artificial in current Swift.<br></p><p>• Does this proposal fit well with the feel and direction of Swift?<br>No, semicolons don&#39;t read very Swifty.<br></p><p>• If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>-<br></p><p>• How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>10 minutes<br></p><p><br>On 27.05.2016, at 21:11, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br></p><p>Hello Swift community,<br></p><p>The review of SE-0099 “Restructuring Condition Clauses” begins now and runs through June 3, 2016. The proposal is available here:<br></p><p>https://github.com/apple/swift-evolution/blob/master/proposals/0099-conditionclauses.md<br></p><p>Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br></p><p>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br></p><p>Proposal link:<br></p><p>https://github.com/apple/swift-evolution/blob/master/proposals/0099-conditionclauses.md<br></p><p>Reply text<br></p><p>Other replies<br></p><p>What goes into a review?<br></p><p>The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br></p><p>• What is your evaluation of the proposal?<br>• Is the problem being addressed significant enough to warrant a change to Swift?<br>• Does this proposal fit well with the feel and direction of Swift?<br>• If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>• How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>More information about the Swift evolution process is available at<br></p><p>https://github.com/apple/swift-evolution/blob/master/process.md<br></p><p>Thank you,<br></p><p>-Joe<br></p><p>Review Manager<br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160606/eaa314d3/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Review] SE-0099: Restructuring Condition Clauses</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>June  6, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; 	• What is your evaluation of the proposal?<br></p><p>+1 I’ve always been annoyed by the complicated grammar of condition clauses. This proposal simplifies them and makes them easier to understand and teach.<br></p><p>Especially, I regret that the syntax for A &amp;&amp; B is different than B &amp;&amp; A when A is a boolean expression and B is an optional unwrapping clause. It breaks a nice visual symmetry:<br></p><p>if a, let b = b {}<br>if let b = b where a {}<br></p><p>This proposal brings back the symmetry.<br></p><p>&gt; 	• Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>It is.<br></p><p>&gt; 	• Does this proposal fit well with the feel and direction of Swift?<br></p><p>It brings more consistency, and it breaks the syntax. So it should be introduced for Swift 3.<br></p><p>&gt; 	• If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>I haven’t used languages which had anything else than boolean expressions in their condition clauses, but I’ve always expected the syntax of A &amp;&amp; B to be symmetrical to B &amp;&amp; A.<br></p><p>&gt; 	• How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>A long read of the original discussion and the review discussion.<br></p><p>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt; Review Manager<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[Review] SE-0099: Restructuring Condition Clauses</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>June  6, 2016 at 09:00:00am</p></header><div class="content"><p>Loved the insight about the positive net effect on language symmetry, quite important yet sometimes the unsung hero of such discussions :).<br></p><p>Sent from my iPhone<br></p><p>&gt; On 6 Jun 2016, at 08:26, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;    • What is your evaluation of the proposal?<br>&gt; <br>&gt; +1 I’ve always been annoyed by the complicated grammar of condition clauses. This proposal simplifies them and makes them easier to understand and teach.<br>&gt; <br>&gt; Especially, I regret that the syntax for A &amp;&amp; B is different than B &amp;&amp; A when A is a boolean expression and B is an optional unwrapping clause. It breaks a nice visual symmetry:<br>&gt; <br>&gt; if a, let b = b {}<br>&gt; if let b = b where a {}<br>&gt; <br>&gt; This proposal brings back the symmetry.<br>&gt; <br>&gt;&gt;    • Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; <br>&gt; It is.<br>&gt; <br>&gt;&gt;    • Does this proposal fit well with the feel and direction of Swift?<br>&gt; <br>&gt; It brings more consistency, and it breaks the syntax. So it should be introduced for Swift 3.<br>&gt; <br>&gt;&gt;    • If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; <br>&gt; I haven’t used languages which had anything else than boolean expressions in their condition clauses, but I’ve always expected the syntax of A &amp;&amp; B to be symmetrical to B &amp;&amp; A.<br>&gt; <br>&gt;&gt;    • How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; A long read of the original discussion and the review discussion.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt; <br>&gt;&gt;    https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt; <br>&gt;&gt; Thank you,<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt; Review Manager<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
