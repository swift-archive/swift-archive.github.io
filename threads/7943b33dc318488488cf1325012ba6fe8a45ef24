<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>Compiler directive for current closure reference</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>February 22, 2016 at 07:00:00pm</p></header><div class="content"><p>Dear all, <br></p><p>I apologise in advance if this has already been suggested (or maybe even implemented), but its very difficult to keep track of the swift evolution list :) <br></p><p>We already have compiler directives like #line, #function. I would like to suggest a new directive #closure (name preliminary) that expands to the reference to the closure, function or method in whose body the directive occurs. Motivation: this will allow one to conveniently use design patterns like these:<br></p><p>addHandler({<br>	guard stillRelevant() else {<br>          removeHandler(#closure)<br>	}<br>      <br>       doSomething()<br>})<br></p><p><br>I am sure there are also other cases where such directive would come in handy.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Compiler directive for current closure reference</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>February 22, 2016 at 10:00:00am</p></header><div class="content"><p>Closures don&#39;t have identity (i.e. you can&#39;t use === on them). ObjC blocks do, so if you really need it you can pass things around as @convention(objc_block), but closures don&#39;t. So I think you&#39;d have to start there if you want to do anything like this.<br></p><p>Jordan<br></p><p><br></p><p><br>&gt; On Feb 22, 2016, at 10:20, Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Dear all, <br>&gt; <br>&gt; I apologise in advance if this has already been suggested (or maybe even implemented), but its very difficult to keep track of the swift evolution list :) <br>&gt; <br>&gt; We already have compiler directives like #line, #function. I would like to suggest a new directive #closure (name preliminary) that expands to the reference to the closure, function or method in whose body the directive occurs. Motivation: this will allow one to conveniently use design patterns like these:<br>&gt; <br>&gt; addHandler({<br>&gt; 	guard stillRelevant() else {<br>&gt;          removeHandler(#closure)<br>&gt; 	}<br>&gt; <br>&gt;       doSomething()<br>&gt; })<br>&gt; <br>&gt; <br>&gt; I am sure there are also other cases where such directive would come in handy. <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Closure identity (was Re: Compiler directive for current closure reference)</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February 22, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; Closures don&#39;t have identity (i.e. you can&#39;t use === on them). ObjC blocks do, so if you really need it you can pass things around as @convention(objc_block), but closures don&#39;t. So I think you&#39;d have to start there if you want to do anything like this.<br></p><p>Actually, I&#39;ve wondered about this for a while.<br></p><p>Closures are pretty weird in that they&#39;re a reference type, but they don&#39;t have a stable identity. I asked about this once before Swift was open sourced (I think on Twitter), and I believe I was told that it was due to certain optimizations. What are these optimizations, and can we give closures stable identities despite them?<br></p><p>In a few minutes of research, my guess is that it has to do with thick vs. thin closures: thick closures carry a context object, while thin ones don&#39;t. &lt;https://github.com/apple/swift/blob/master/docs/CallingConvention.rst#closures&gt; Is that the issue here? If so…<br></p><p>- Leaving aside thin closures for the moment, is a thick closure&#39;s context object unique enough to be used as its identity? Is function pointer + context unique enough, or does the function pointer change too?<br></p><p>- Now, for thin closures, obviously we don&#39;t want to allocate an entire unnecessary object to carry an empty context around. But what would the costs be if, instead of omitting the context pointer, we replaced it with a unique integer (presumably with the low bit set to avoid colliding with valid context pointers)? Perhaps keep a thread-local counter and combine it with the thread ID so we don&#39;t need any locking?<br></p><p>(As for motivation: besides just being kind of a weird asymmetry, there are certain classes of APIs which are made more convoluted by the lack of closure identity. Basically any API where you can register and unregister multiple handlers with a single object is affected: the &quot;add&quot; operation has to return some kind of token to be used for the &quot;remove&quot; operation, which may now have a different lifetime from the registration itself. It seems simpler to add and remove the closure itself, but the lack of identity prevents that.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>Closure identity (was Re: Compiler directive for current closure reference)</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>February 23, 2016 at 02:00:00pm</p></header><div class="content"><p>Oh, true, I have completely forgot about this litte detail. The truth is, I haven’t tried any pattern like this in Swift yet — it just occurred to my mind because I do use it quite often in a tool I work on now (Python). <br></p><p>I would also be curious to the reason why closures can’t be compared. I can imagine a bunch of optimisations which make it impossible (e.g. inlining  closure body into another function), but I think this can be solved with some effort. Ideally, I’d like to see something like a Callable/Closure protocol that all closures (including functions and bound methods) adhere to, and which also allows identity comparison. This also opens up a formalism for argument and return type introspection as well as a way to reintroduce the tuple splat operation, e.g. by using an explicit .call() method of the Callable. Of course, details of such a proposal need to be fleshed up. Can someone do that? :)<br></p><p>— Taras<br></p><p>&gt; On 23 Feb 2016, at 05:00, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; Closures don&#39;t have identity (i.e. you can&#39;t use === on them). ObjC blocks do, so if you really need it you can pass things around as @convention(objc_block), but closures don&#39;t. So I think you&#39;d have to start there if you want to do anything like this.<br>&gt; <br>&gt; Actually, I&#39;ve wondered about this for a while.<br>&gt; <br>&gt; Closures are pretty weird in that they&#39;re a reference type, but they don&#39;t have a stable identity. I asked about this once before Swift was open sourced (I think on Twitter), and I believe I was told that it was due to certain optimizations. What are these optimizations, and can we give closures stable identities despite them?<br>&gt; <br>&gt; In a few minutes of research, my guess is that it has to do with thick vs. thin closures: thick closures carry a context object, while thin ones don&#39;t. &lt;https://github.com/apple/swift/blob/master/docs/CallingConvention.rst#closures&gt; Is that the issue here? If so…<br>&gt; <br>&gt; - Leaving aside thin closures for the moment, is a thick closure&#39;s context object unique enough to be used as its identity? Is function pointer + context unique enough, or does the function pointer change too?<br>&gt; <br>&gt; - Now, for thin closures, obviously we don&#39;t want to allocate an entire unnecessary object to carry an empty context around. But what would the costs be if, instead of omitting the context pointer, we replaced it with a unique integer (presumably with the low bit set to avoid colliding with valid context pointers)? Perhaps keep a thread-local counter and combine it with the thread ID so we don&#39;t need any locking?<br>&gt; <br>&gt; (As for motivation: besides just being kind of a weird asymmetry, there are certain classes of APIs which are made more convoluted by the lack of closure identity. Basically any API where you can register and unregister multiple handlers with a single object is affected: the &quot;add&quot; operation has to return some kind of token to be used for the &quot;remove&quot; operation, which may now have a different lifetime from the registration itself. It seems simpler to add and remove the closure itself, but the lack of identity prevents that.)<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Closure identity (was Re: Compiler directive for current closure reference)</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February 23, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Feb 22, 2016, at 8:00 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Closures don&#39;t have identity (i.e. you can&#39;t use === on them). ObjC blocks do, so if you really need it you can pass things around as @convention(objc_block), but closures don&#39;t. So I think you&#39;d have to start there if you want to do anything like this.<br>&gt; <br>&gt; Actually, I&#39;ve wondered about this for a while.<br>&gt; <br>&gt; Closures are pretty weird in that they&#39;re a reference type, but they don&#39;t have a stable identity. I asked about this once before Swift was open sourced (I think on Twitter), and I believe I was told that it was due to certain optimizations. What are these optimizations, and can we give closures stable identities despite them?<br></p><p>I think it&#39;s more proper to think of closures as *immutable*—they&#39;re above either reference or value semantics. Closures can capture references to shared mutable state, either by closing over class references or `var` boxes, but that state is shared with code in the same lexical scope, not part of the closure itself. Swift will mess with the underlying identity of closures for a couple of reasons today:<br></p><p>- When functions are passed into contexts with different genericity, we may &quot;reabstract&quot; them, thunking to get a better calling convention for the destination&#39;s generic abstraction level. If we weren&#39;t allowed to reabstract, function objects would always need to use an inefficient indirect calling convention to be usable from generic contexts.<br>- We defer closure formation in some cases, particularly when using local `func` decls:<br></p><p>func foo(x: Int, asynchronously: Bool) {<br>  func bar() { print(x) }<br></p><p>  if !asynchronously {<br>    bar() // We don&#39;t form a closure on this branch<br>  } else {<br>    async(bar) // We do on this branch<br>  }<br>}<br></p><p>If every reference to `bar` needed to form an equivalent function object, it would be harder to do this.<br></p><p>Future potential optimizations include replacing a function literal that&#39;s equivalent with a function or method call with a direct reference to that function (e.g. { $0.method($1, $2) }), or stack-allocating closures to be lazily copied to the heap on escape, the same way ObjC blocks are explicitly heap-promoted with _Block_copy.<br></p><p>Even without these optimization considerations, relying on the identity of specific block objects is fraught with problems, and in practice there&#39;s usually a better discriminator available to you somewhere to key on. We could possibly support identity of function or method *declarations*, similar to selectors in ObjC, but those would have to be at best a subtype of all function values.<br></p><p>-Joe<br></p><p>&gt; <br>&gt; In a few minutes of research, my guess is that it has to do with thick vs. thin closures: thick closures carry a context object, while thin ones don&#39;t. &lt;https://github.com/apple/swift/blob/master/docs/CallingConvention.rst#closures&gt; Is that the issue here? If so…<br>&gt; <br>&gt; - Leaving aside thin closures for the moment, is a thick closure&#39;s context object unique enough to be used as its identity? Is function pointer + context unique enough, or does the function pointer change too?<br>&gt; <br>&gt; - Now, for thin closures, obviously we don&#39;t want to allocate an entire unnecessary object to carry an empty context around. But what would the costs be if, instead of omitting the context pointer, we replaced it with a unique integer (presumably with the low bit set to avoid colliding with valid context pointers)? Perhaps keep a thread-local counter and combine it with the thread ID so we don&#39;t need any locking?<br>&gt; <br>&gt; (As for motivation: besides just being kind of a weird asymmetry, there are certain classes of APIs which are made more convoluted by the lack of closure identity. Basically any API where you can register and unregister multiple handlers with a single object is affected: the &quot;add&quot; operation has to return some kind of token to be used for the &quot;remove&quot; operation, which may now have a different lifetime from the registration itself. It seems simpler to add and remove the closure itself, but the lack of identity prevents that.)<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160223/26995b3b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Closure identity (was Re: Compiler directive for current closure reference)</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February 23, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; Even without these optimization considerations, relying on the identity of specific block objects is fraught with problems, and in practice there&#39;s usually a better discriminator available to you somewhere to key on.<br></p><p>I&#39;m sorry, but I&#39;m really having trouble understanding this point of view. Consider this:<br></p><p>	behavior var observable&lt;Value where Self: class&gt;: Value {<br>		typealias Observer = (observed: Self, oldValue: Value, newValue: Value) -&gt; Void<br></p><p>		initialValue<br>		<br>		private var value: Value = initialValue<br>		<br>		// This would be better as a Set by making functions Hashable, but I understand<br>		// that compound types currently can&#39;t be conformed to protocols.<br>		private var observers: [ObjectIdentifier: Observer]<br>		<br>		func addObserver(observer: Observer) {<br>			observers[ObjectIdentifier(observer)] = observer<br>		}<br>		func removeObserver(observer: Observer) {<br>			observers[ObjectIdentifier(observer)] = nil<br>		}<br>		<br>		get { return value }<br>		set {<br>			let oldValue = value<br>			value = newValue<br>			for observer in observers.values {<br>				observer(observed: self, oldValue: oldValue, newValue: newValue)<br>			}<br>		}<br>	}<br></p><p>What is the better discriminator here? Sure, you could make Observer into a class that contains a closure, but how does that make anything better? It&#39;s an extra object to track and manage; it&#39;s an impediment to using trailing closure syntax with `addObserver`; it&#39;s more state you could accidentally share; it&#39;s additional memory and additional reference counting.<br></p><p>If there are implementation reasons not to support it, fine. But let&#39;s not pretend we&#39;re doing people a service by preventing this, like when we prevent enum extensions from adding cases to make code correctness more decidable, or that we&#39;re reflecting some fundamental semantic truth, like when we don&#39;t give value types identities because they get implicitly copied around and independently mutated.<br></p><p>There are perfectly sensible ways to define closure identity—a particular (source-level) function with a particular context, or a closure captured at a particular point in the program&#39;s execution—but we don&#39;t support the operation because we&#39;d have to either spend extra memory on something rarely used, or give up very useful optimizations. There&#39;s no shame in that, and no need to try to turn it into a positive instead of something negative but necessary.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
