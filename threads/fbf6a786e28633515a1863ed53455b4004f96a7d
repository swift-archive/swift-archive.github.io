<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Idea: Extend &quot;guard&quot; to try-statements, with a catch block</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>February 29, 2016 at 12:00:00pm</p></header><div class="content"><p>Guard statements interact with pattern-matching to ensure that control flow<br>cannot continue unless a pattern is matched. This is a very convenient way<br>to introduce non-optional variables from optional-valued expressions:<br></p><p>    // func foo() -&gt; T? ...<br>    guard let x = foo() *else* {<br>        // the compiler does not allow control flow to escape this block<br>    }<br>    // control flow cannot reach here if foo() returned nil<br></p><p>Guard statements can be used with the optional form &quot;*try?*&quot; to provide the<br>same functionality for throwing functions:<br></p><p>    // func foo() throws -&gt; T ...<br>    guard let x = *try?* foo() *else* {<br>        // the compiler does not allow control flow to escape this block<br>        // the &quot;error&quot; parameter is not available here<br>    }<br>    // control flow cannot reach here if foo() threw an error<br></p><p>However, the error that was thrown is not recoverable inside the &quot;else&quot;<br>block. A workaround is to add extra lines of code &amp; indentation levels to<br>achieve this with do+catch:<br></p><p>    let x: T<br>    do {<br>        x = try foo()<br>    } catch {<br>        // control flow can escape this block, but the compiler won&#39;t allow<br>x to be used later if it&#39;s not initialized here<br>    }<br></p><p>*I propose extending guard-statements to handle errors* without using the<br>optional &quot;try?&quot; and without a do-block, by allowing the expression to<br>throw, and offering &quot;catch&quot; instead of &quot;else&quot;:<br></p><p>    // func foo() throws -&gt; T ...<br>    guard let x = *try* foo *catch* {<br>        print(&quot;the error was: \(*error*)&quot;)  // the &quot;error&quot; parameter is<br>available here<br>        // the compiler does not allow control flow to escape this block<br>    }<br>    // control flow cannot reach here if foo() threw an error<br></p><p>We could allow the same sorts of catch blocks as normal do-blocks:<br></p><p>    guard let x = try foo() *catch let error as MyErrorType* {<br>        // handle specific error; control flow must not escape<br>    } *catch* {<br>        // fallback error case; control flow must not escape<br>    }<br></p><p>(Of course, we&#39;d want to offer sensical error message / fix-it hints when<br>&quot;else&quot; was used with a throwing statement, or when &quot;catch&quot; was used with a<br>non-throwing statement.)<br></p><p>Thoughts?<br></p><p>Here are some discussion topics:<br></p><p>- If Swift&#39;s error-handling mechanisms evolved into a first-class Result<br>type, would this proposal be moot?<br></p><p>- Would this make sense as a feature of pattern-matching, rather than just<br>&quot;guard&quot;, so you could also do &quot;if case let x = try foo() { ... } catch {<br>... }&quot; ?<br></p><p>Jacob<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160229/fbf66a7d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d68c97e8e2f1653b54c24493caf236ae?s=50"></div><header><strong>Idea: Extend &quot;guard&quot; to try-statements, with a catch block</strong> from <string>Stephen Celis</string> &lt;stephen.celis at gmail.com&gt;<p>February 29, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Feb 29, 2016, at 3:09 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Thoughts?<br></p><p>Thanks for writing this up! I think it&#39;s a natural step to take from the current model.<br></p><p>&gt; Here are some discussion topics:<br>&gt; <br>&gt; - If Swift&#39;s error-handling mechanisms evolved into a first-class Result type, would this proposal be moot?<br></p><p>Could you clarify what you mean by this?<br></p><p>&gt; - Would this make sense as a feature of pattern-matching, rather than just &quot;guard&quot;, so you could also do &quot;if case let x = try foo() { ... } catch { ... }&quot; ?<br></p><p>This makes sense to me at first glance, though it makes things rather complicated.<br></p><p>  - Can `catch` blocks appear before `else [if]` blocks? E.g.,<br></p><p>        if try test() != nil {<br>            ...<br>        } catch {<br>            ...<br>        } else if try test2() != nil {<br>            ...<br>        } else {<br>            ...<br>        } catch {<br>            ...<br>        }<br></p><p>  - Are `if`/`else` blocks generally promoted to `do`-like state when `catch` blocks exist?<br></p><p>        if something() {<br>            try failable()<br>        } catch {<br>            ...<br>        }<br></p><p>  - Does this extend to `switch` and how?<br></p><p>--<br>Stephen<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Idea: Extend &quot;guard&quot; to try-statements, with a catch block</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>February 29, 2016 at 01:00:00pm</p></header><div class="content"><p>Thanks for the feedback, Stephen.<br></p><p>On Mon, Feb 29, 2016 at 1:03 PM, Stephen Celis &lt;stephen.celis at gmail.com&gt;<br>wrote:<br></p><p>&gt; &gt; On Feb 29, 2016, at 3:09 PM, Jacob Bandes-Storch via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; - If Swift&#39;s error-handling mechanisms evolved into a first-class Result<br>&gt; type, would this proposal be moot?<br>&gt;<br>&gt; Could you clarify what you mean by this?<br>&gt;<br></p><p>I didn&#39;t think through it very far, which is why I put it under &quot;discussion<br>topics&quot; rather than fleshing it out :-)<br></p><p>I guess I&#39;m just wondering whether the syntax for optionals/errors might<br>change significantly enough with the introduction of Result that it<br>wouldn&#39;t make sense to introduce this feature now.<br></p><p>Suppose we had &quot;enum Result&lt;T&gt; { case Some(T), Error(ErrorType) }&quot;. Then<br>&quot;throws&quot; might be syntactic sugar: &quot;foo() throws -&gt; T&quot; would be the same as<br>&quot;foo() -&gt; Result&lt;T&gt;&quot;. Using today&#39;s syntax, you could handle Results using<br>switch:<br></p><p>    switch foo() {<br>    case .Some(let x):<br>        // use x<br>    case .Error(let error):<br>        // use error<br>    }<br></p><p>But conceivably the Result would be treated with more first-class syntax:<br></p><p>    if let x = try foo() {<br>        // handle .Some<br>    } catch {<br>        // handle .Error<br>    }<br></p><p>The more I think about this, it doesn&#39;t seem too different from what I<br>proposed, so I guess it&#39;s not worth worrying about conflicts.<br></p><p><br>&gt;<br>&gt; &gt; - Would this make sense as a feature of pattern-matching, rather than<br>&gt; just &quot;guard&quot;, so you could also do &quot;if case let x = try foo() { ... } catch<br>&gt; { ... }&quot; ?<br>&gt;<br>&gt; This makes sense to me at first glance, though it makes things rather<br>&gt; complicated.<br>&gt;<br>&gt;   - Can `catch` blocks appear before `else [if]` blocks? E.g.,<br>&gt;<br>&gt;         if try test() != nil {<br>&gt;             ...<br>&gt;         } catch {<br>&gt;             ...<br>&gt;         } else if try test2() != nil {<br>&gt;             ...<br>&gt;         } else {<br>&gt;             ...<br>&gt;         } catch {<br>&gt;             ...<br>&gt;         }<br>&gt;<br></p><p>That&#39;s an interesting point. I can&#39;t see why this shouldn&#39;t be allowed.<br>Would you be able to handle all errors at the end?<br></p><p>    e.g.: if case let x = try foo() { ... } else if case let y = try bar()<br>{ ... } catch { /*handle errors from both expressions*/ }<br></p><p><br></p><p>&gt;<br>&gt;   - Are `if`/`else` blocks generally promoted to `do`-like state when<br>&gt; `catch` blocks exist?<br>&gt;<br>&gt;         if something() {<br>&gt;             try failable()<br>&gt;         } catch {<br>&gt;             ...<br>&gt;         }<br>&gt;<br></p><p>Hmm. I think I would like this, but there may have been reasons for not<br>allowing this sort of thing. I can&#39;t recall if it&#39;s been discussed before.<br>What do others think?<br></p><p><br>&gt;<br>&gt;   - Does this extend to `switch` and how?<br>&gt;<br></p><p>Maybe just the same thing: &quot;switch try foo() { ... } catch { ... }&quot; ?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160229/aa310581/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Idea: Extend &quot;guard&quot; to try-statements, with a catch block</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>February 29, 2016 at 10:00:00pm</p></header><div class="content"><p>On Feb 29, 2016, at 12:09 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; I propose extending guard-statements to handle errors without using the optional &quot;try?&quot; and without a do-block, by allowing the expression to throw, and offering &quot;catch&quot; instead of &quot;else&quot;:<br>&gt; <br>&gt;     // func foo() throws -&gt; T ...<br>&gt;     guard let x = try foo catch {<br>&gt;         print(&quot;the error was: \(error)&quot;)  // the &quot;error&quot; parameter is available here<br>&gt;         // the compiler does not allow control flow to escape this block<br>&gt;     }<br>&gt;     // control flow cannot reach here if foo() threw an error<br></p><p>I don’t think that this syntax makes sense, because you’re changing &quot;guard let x = ” to not test an optional.  The syntax you’re searching for seems more consistent as a modifier on var/let itself:<br></p><p>// func foo() throws -&gt; T ...<br>let x = try foo() catch {<br>        print(&quot;the error was: \(error)&quot;)  // the &quot;error&quot; parameter is available here<br>        // the compiler does not allow control flow to escape this block<br>}<br></p><p>The guard form of this would still make sense, but the existing “guard let” and “guard case” matching should work as it does.  For example, something like this should be allowed:<br></p><p>// func bar() throws -&gt; T?<br>guard let x = try bar() else {<br>        // this runs if ‘bar’ returns nil.<br>        // the compiler does not allow control flow to escape this block<br>} catch {<br>        print(&quot;the error was: \(error)&quot;)  // the &quot;error&quot; parameter is available here<br>        // the compiler does not allow control flow to escape this block<br>}<br></p><p>More generally, the “guard” form would be workable on anything that takes a stmt-condition.  This brings “if&quot; and “while” into the mix.<br></p><p>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160229/ef1b407f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Idea: Extend &quot;guard&quot; to try-statements, with a catch block</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>March  8, 2016 at 11:00:00am</p></header><div class="content"><p>Thanks for the feedback, Chris.<br></p><p>To clarify, are you suggesting that plain variable bindings would support<br>this too (such as &quot;let x = try foo() catch { ... }&quot;)? I like this idea. I<br>can also foresee the desire for something like this:<br></p><p>    let x = try foo() catch {<br>        print(error)<br>        x = bar()   // by some syntax, provide a fallback value for x,<br>since foo() threw<br>        // control flow *can* escape, since x has a value<br>    }<br></p><p>Of course, you can achieve this today with &quot;let x; do { x = try foo() }<br>catch { x = bar() }&quot;, or with &quot;let x = try? foo() ?? bar()&quot;. I just wonder<br>if it&#39;s worth considering the possibility that this new feature would allow<br>control flow to escape in some cases. (After all, control flow can exit the<br>&quot;catch&quot; block we have today.) But it&#39;s also nice to be able to glance at<br>the code and see that, unambiguously, control flow can&#39;t escape the block.<br></p><p>The reason I originally suggested &quot;guard&quot; is readability: Seeing the word<br>&quot;guard&quot;, a reader knows that control flow can&#39;t escape the else/catch<br>block. But I understand why guard is still necessary for working with<br>optionals/patterns, and I suppose seeing &quot;try&quot; introducing the expression<br>may be enough.<br></p><p>Do you have thoughts on whether else/catch blocks should be re-orderable?<br></p><p>Another question: should it work with expressions that don&#39;t bind<br>variables? Simply &quot;try foo() catch { ... }&quot; ?  (At one point I had<br>considered &quot;*do* try ... catch ...&quot;, as a braceless analogue of &quot;*do* { try<br>... } catch ...&quot;.)<br></p><p>Jacob<br></p><p>On Mon, Feb 29, 2016 at 10:34 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br></p><p>&gt; On Feb 29, 2016, at 12:09 PM, Jacob Bandes-Storch via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; *I propose extending guard-statements to handle errors* without using the<br>&gt; optional &quot;try?&quot; and without a do-block, by allowing the expression to<br>&gt; throw, and offering &quot;catch&quot; instead of &quot;else&quot;:<br>&gt;<br>&gt;     // func foo() throws -&gt; T ...<br>&gt;     guard let x = *try* foo *catch* {<br>&gt;         print(&quot;the error was: \(*error*)&quot;)  // the &quot;error&quot; parameter is<br>&gt; available here<br>&gt;         // the compiler does not allow control flow to escape this block<br>&gt;     }<br>&gt;     // control flow cannot reach here if foo() threw an error<br>&gt;<br>&gt;<br>&gt; I don’t think that this syntax makes sense, because you’re changing &quot;guard<br>&gt; let x = ” to not test an optional.  The syntax you’re searching for seems<br>&gt; more consistent as a modifier on var/let itself:<br>&gt;<br>&gt; // func foo() throws -&gt; T ...<br>&gt; let x = try foo() catch {<br>&gt;         print(&quot;the error was: \(error)&quot;)  // the &quot;error&quot; parameter is<br>&gt; available here<br>&gt;         // the compiler does not allow control flow to escape this block<br>&gt; }<br>&gt;<br>&gt; The guard form of this would still make sense, but the existing “guard<br>&gt; let” and “guard case” matching should work as it does.  For example,<br>&gt; something like this should be allowed:<br>&gt;<br>&gt; // func bar() throws -&gt; T?<br>&gt; guard let x = try bar() else {<br>&gt;         // this runs if ‘bar’ returns nil.<br>&gt;         // the compiler does not allow control flow to escape this block<br>&gt; } catch {<br>&gt;         print(&quot;the error was: \(error)&quot;)  // the &quot;error&quot; parameter is<br>&gt; available here<br>&gt;         // the compiler does not allow control flow to escape this block<br>&gt; }<br>&gt;<br>&gt; More generally, the “guard” form would be workable on anything that takes<br>&gt; a stmt-condition.  This brings “if&quot; and “while” into the mix.<br>&gt;<br>&gt; -Chris<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160308/e63e533a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Idea: Extend &quot;guard&quot; to try-statements, with a catch block</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>March  8, 2016 at 03:00:00pm</p></header><div class="content"><p>Another possible syntax:<br></p><p>guard try let x = foo()<br>catch let error as FooError {<br>  return nil<br>}<br></p><p>Downsides:<br>- You can&#39;t limit the &#39;try&#39; to only part of the expression.<br>- Actually catching a specific error makes for a very long line, to the point where I automatically wrapped it anyway. Maybe we should just allow one catch.<br>- It still feels like it should be testing for an optional (because of the binding syntax).<br></p><p>Jordan<br></p><p><br>&gt; On Mar 8, 2016, at 11:37, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Thanks for the feedback, Chris.<br>&gt; <br>&gt; To clarify, are you suggesting that plain variable bindings would support this too (such as &quot;let x = try foo() catch { ... }&quot;)? I like this idea. I can also foresee the desire for something like this:<br>&gt; <br>&gt;     let x = try foo() catch {<br>&gt;         print(error)<br>&gt;         x = bar()   // by some syntax, provide a fallback value for x, since foo() threw<br>&gt;         // control flow *can* escape, since x has a value<br>&gt;     }<br>&gt; <br>&gt; Of course, you can achieve this today with &quot;let x; do { x = try foo() } catch { x = bar() }&quot;, or with &quot;let x = try? foo() ?? bar()&quot;. I just wonder if it&#39;s worth considering the possibility that this new feature would allow control flow to escape in some cases. (After all, control flow can exit the &quot;catch&quot; block we have today.) But it&#39;s also nice to be able to glance at the code and see that, unambiguously, control flow can&#39;t escape the block.<br>&gt; <br>&gt; The reason I originally suggested &quot;guard&quot; is readability: Seeing the word &quot;guard&quot;, a reader knows that control flow can&#39;t escape the else/catch block. But I understand why guard is still necessary for working with optionals/patterns, and I suppose seeing &quot;try&quot; introducing the expression may be enough.<br>&gt; <br>&gt; Do you have thoughts on whether else/catch blocks should be re-orderable?<br>&gt; <br>&gt; Another question: should it work with expressions that don&#39;t bind variables? Simply &quot;try foo() catch { ... }&quot; ?  (At one point I had considered &quot;do try ... catch ...&quot;, as a braceless analogue of &quot;do { try ... } catch ...&quot;.)<br>&gt; <br>&gt; Jacob<br>&gt; <br>&gt; On Mon, Feb 29, 2016 at 10:34 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt; On Feb 29, 2016, at 12:09 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; I propose extending guard-statements to handle errors without using the optional &quot;try?&quot; and without a do-block, by allowing the expression to throw, and offering &quot;catch&quot; instead of &quot;else&quot;:<br>&gt;&gt; <br>&gt;&gt;     // func foo() throws -&gt; T ...<br>&gt;&gt;     guard let x = try foo catch {<br>&gt;&gt;         print(&quot;the error was: \(error)&quot;)  // the &quot;error&quot; parameter is available here<br>&gt;&gt;         // the compiler does not allow control flow to escape this block<br>&gt;&gt;     }<br>&gt;&gt;     // control flow cannot reach here if foo() threw an error<br>&gt; <br>&gt; I don’t think that this syntax makes sense, because you’re changing &quot;guard let x = ” to not test an optional.  The syntax you’re searching for seems more consistent as a modifier on var/let itself:<br>&gt; <br>&gt; // func foo() throws -&gt; T ...<br>&gt; let x = try foo() catch {<br>&gt;         print(&quot;the error was: \(error)&quot;)  // the &quot;error&quot; parameter is available here<br>&gt;         // the compiler does not allow control flow to escape this block<br>&gt; }<br>&gt; <br>&gt; The guard form of this would still make sense, but the existing “guard let” and “guard case” matching should work as it does.  For example, something like this should be allowed:<br>&gt; <br>&gt; // func bar() throws -&gt; T?<br>&gt; guard let x = try bar() else {<br>&gt;         // this runs if ‘bar’ returns nil.<br>&gt;         // the compiler does not allow control flow to escape this block<br>&gt; } catch {<br>&gt;         print(&quot;the error was: \(error)&quot;)  // the &quot;error&quot; parameter is available here<br>&gt;         // the compiler does not allow control flow to escape this block<br>&gt; }<br>&gt; <br>&gt; More generally, the “guard” form would be workable on anything that takes a stmt-condition.  This brings “if&quot; and “while” into the mix.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160308/7fc5834b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Idea: Extend &quot;guard&quot; to try-statements, with a catch block</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>March  8, 2016 at 05:00:00pm</p></header><div class="content"><p>Regardless of syntax, I&#39;m still missing the point on this one.<br></p><p>If there&#39;s error-handling and recovery work to be done, isn&#39;t this better done without a guard statement, either using `try` to allow the calling chain to respond or using a `do`-`catch` construct. `guard` guarantees scope exit on failure, but so does `try` outside of a`do`-`catch`.<br></p><p>* If you care about just logging errors, you can use a printing form of `try?`. I brought this up on another thread.<br>* If you care about mitigating a failure, then you should give the `catch` clause the due space and ability to handle recovery that it deserves.<br>* If you don&#39;t care about printing the error, why not use normal `guard` and `try?`.<br></p><p>What is the point of only catching specific errors, or specific types of errors, or etc that deserves a language change here, where it&#39;s merged into `guard`?<br></p><p>-- E, dense<br></p><p><br>&gt; On Mar 8, 2016, at 4:56 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Another possible syntax:<br>&gt; <br>&gt; guard try let x = foo()<br>&gt; catch let error as FooError {<br>&gt;   return nil<br>&gt; }<br>&gt; <br>&gt; Downsides:<br>&gt; - You can&#39;t limit the &#39;try&#39; to only part of the expression.<br>&gt; - Actually catching a specific error makes for a very long line, to the point where I automatically wrapped it anyway. Maybe we should just allow one catch.<br>&gt; - It still feels like it should be testing for an optional (because of the binding syntax).<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 8, 2016, at 11:37, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Thanks for the feedback, Chris.<br>&gt;&gt; <br>&gt;&gt; To clarify, are you suggesting that plain variable bindings would support this too (such as &quot;let x = try foo() catch { ... }&quot;)? I like this idea. I can also foresee the desire for something like this:<br>&gt;&gt; <br>&gt;&gt;     let x = try foo() catch {<br>&gt;&gt;         print(error)<br>&gt;&gt;         x = bar()   // by some syntax, provide a fallback value for x, since foo() threw<br>&gt;&gt;         // control flow *can* escape, since x has a value<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; Of course, you can achieve this today with &quot;let x; do { x = try foo() } catch { x = bar() }&quot;, or with &quot;let x = try? foo() ?? bar()&quot;. I just wonder if it&#39;s worth considering the possibility that this new feature would allow control flow to escape in some cases. (After all, control flow can exit the &quot;catch&quot; block we have today.) But it&#39;s also nice to be able to glance at the code and see that, unambiguously, control flow can&#39;t escape the block.<br>&gt;&gt; <br>&gt;&gt; The reason I originally suggested &quot;guard&quot; is readability: Seeing the word &quot;guard&quot;, a reader knows that control flow can&#39;t escape the else/catch block. But I understand why guard is still necessary for working with optionals/patterns, and I suppose seeing &quot;try&quot; introducing the expression may be enough.<br>&gt;&gt; <br>&gt;&gt; Do you have thoughts on whether else/catch blocks should be re-orderable?<br>&gt;&gt; <br>&gt;&gt; Another question: should it work with expressions that don&#39;t bind variables? Simply &quot;try foo() catch { ... }&quot; ?  (At one point I had considered &quot;do try ... catch ...&quot;, as a braceless analogue of &quot;do { try ... } catch ...&quot;.)<br>&gt;&gt; <br>&gt;&gt; Jacob<br>&gt;&gt; <br>&gt;&gt; On Mon, Feb 29, 2016 at 10:34 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt; On Feb 29, 2016, at 12:09 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; I propose extending guard-statements to handle errors without using the optional &quot;try?&quot; and without a do-block, by allowing the expression to throw, and offering &quot;catch&quot; instead of &quot;else&quot;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     // func foo() throws -&gt; T ...<br>&gt;&gt;&gt;     guard let x = try foo catch {<br>&gt;&gt;&gt;         print(&quot;the error was: \(error)&quot;)  // the &quot;error&quot; parameter is available here<br>&gt;&gt;&gt;         // the compiler does not allow control flow to escape this block<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     // control flow cannot reach here if foo() threw an error<br>&gt;&gt; <br>&gt;&gt; I don’t think that this syntax makes sense, because you’re changing &quot;guard let x = ” to not test an optional.  The syntax you’re searching for seems more consistent as a modifier on var/let itself:<br>&gt;&gt; <br>&gt;&gt; // func foo() throws -&gt; T ...<br>&gt;&gt; let x = try foo() catch {<br>&gt;&gt;         print(&quot;the error was: \(error)&quot;)  // the &quot;error&quot; parameter is available here<br>&gt;&gt;         // the compiler does not allow control flow to escape this block<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; The guard form of this would still make sense, but the existing “guard let” and “guard case” matching should work as it does.  For example, something like this should be allowed:<br>&gt;&gt; <br>&gt;&gt; // func bar() throws -&gt; T?<br>&gt;&gt; guard let x = try bar() else {<br>&gt;&gt;         // this runs if ‘bar’ returns nil.<br>&gt;&gt;         // the compiler does not allow control flow to escape this block<br>&gt;&gt; } catch {<br>&gt;&gt;         print(&quot;the error was: \(error)&quot;)  // the &quot;error&quot; parameter is available here<br>&gt;&gt;         // the compiler does not allow control flow to escape this block<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; More generally, the “guard” form would be workable on anything that takes a stmt-condition.  This brings “if&quot; and “while” into the mix.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160308/77edf996/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Idea: Extend &quot;guard&quot; to try-statements, with a catch block</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>March  9, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Mar 8, 2016, at 11:37 AM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt; <br>&gt; Thanks for the feedback, Chris.<br>&gt; <br>&gt; To clarify, are you suggesting that plain variable bindings would support this too (such as &quot;let x = try foo() catch { ... }”)?<br></p><p>I was responding to this in your original proposal:<br></p><p>    // func foo() throws -&gt; T ...<br>    guard let x = try foo catch {<br></p><p>This is inconsistent with what we currently have, because “if let” and “guard let” match against an optional and succeed iff the optional is present.  You were seemingly saying that the presence of “catch” later in the statement would affect this very primitive behavior that we have.<br></p><p>I’m not a strong believer in this proposal, because it is adding complexity and sugar, but I haven’t seen strong motivation that it is common.  This isn’t to say that it isn’t common and worthwhile, just that I haven’t seen any evidence.<br></p><p>&gt; I like this idea. I can also foresee the desire for something like this:<br>&gt; <br>&gt;     let x = try foo() catch {<br>&gt;         print(error)<br>&gt;         x = bar()   // by some syntax, provide a fallback value for x, since foo() threw<br>&gt;         // control flow *can* escape, since x has a value<br>&gt;     }<br></p><p>We wouldn’t do that though, we’d require guard-like behavior for the same reason we require it for guard: the value of guard is that you *know* that an instance of guard doesn’t fall through, without analyzing its behavior in depth.<br></p><p>&gt; Of course, you can achieve this today<br></p><p>Yes, your proposal is a sugar proposal.<br></p><p>&gt; with &quot;let x; do { x = try foo() } catch { x = bar() }&quot;, or with &quot;let x = try? foo() ?? bar()&quot;. I just wonder if it&#39;s worth considering the possibility that this new feature would allow control flow to escape in some cases. (After all, control flow can exit the &quot;catch&quot; block we have today.) But it&#39;s also nice to be able to glance at the code and see that, unambiguously, control flow can&#39;t escape the block.<br>&gt; <br>&gt; The reason I originally suggested &quot;guard&quot; is readability: Seeing the word &quot;guard&quot;, a reader knows that control flow can&#39;t escape the else/catch block. But I understand why guard is still necessary for working with optionals/patterns, and I suppose seeing &quot;try&quot; introducing the expression may be enough.<br></p><p>This shouldn’t be tied to the presence of try, because it already means something (that the enclosed expression can throw).  This:<br></p><p>guard let x = try foo() …<br></p><p>Already means “call foo, if it throws, propagate the error.  If not, test the returned optional”.  Changing that based on a subsequent ‘catch’ seems wrong.<br></p><p>&gt; Another question: should it work with expressions that don&#39;t bind variables? Simply &quot;try foo() catch { ... }&quot; ?  (At one point I had considered &quot;do try ... catch ...&quot;, as a braceless analogue of &quot;do { try ... } catch ...”.)<br></p><p>In my opinion, this whole proposal could be better served with library functions.<br></p><p>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160309/d214701c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>Idea: Extend &quot;guard&quot; to try-statements, with a catch block</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>March 14, 2016 at 05:00:00pm</p></header><div class="content"><p>How about only allowing &quot;guard try? catch&quot;:<br></p><p>    guard let x = try? foo() catch { ... }<br></p><p>This would address both concerns of Chris:<br></p><p>• &quot;This is inconsistent with what we currently have, because “if let” and “guard let” match against an optional and succeed iff the optional is present.&quot;<br></p><p>• &quot;This shouldn’t be tied to the presence of try, because it already means something (that the enclosed expression can throw).  This:<br>        guard let x = try foo() …<br>Already means “call foo, if it throws, propagate the error.  If not, test the returned optional”.&quot;<br></p><p><br>With &quot;try?&quot; it is clear that &quot;foo()&quot; doesn&#39;t throw an error in the guard expression and guard matches against an optional. This makes it unambiguous to &quot;guard try else&quot; which throws in this case.<br></p><p>Kind regards<br>- Maximilian<br></p><p>&gt; Am 10.03.2016 um 05:32 schrieb Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 8, 2016, at 11:37 AM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Thanks for the feedback, Chris.<br>&gt;&gt; <br>&gt;&gt; To clarify, are you suggesting that plain variable bindings would support this too (such as &quot;let x = try foo() catch { ... }”)?<br>&gt; <br>&gt; I was responding to this in your original proposal:<br>&gt; <br>&gt;     // func foo() throws -&gt; T ...<br>&gt;     guard let x = try foo catch {<br>&gt; <br>&gt; This is inconsistent with what we currently have, because “if let” and “guard let” match against an optional and succeed iff the optional is present.  You were seemingly saying that the presence of “catch” later in the statement would affect this very primitive behavior that we have.<br>&gt; <br>&gt; I’m not a strong believer in this proposal, because it is adding complexity and sugar, but I haven’t seen strong motivation that it is common.  This isn’t to say that it isn’t common and worthwhile, just that I haven’t seen any evidence.<br>&gt; <br>&gt;&gt; I like this idea. I can also foresee the desire for something like this:<br>&gt;&gt; <br>&gt;&gt;     let x = try foo() catch {<br>&gt;&gt;         print(error)<br>&gt;&gt;         x = bar()   // by some syntax, provide a fallback value for x, since foo() threw<br>&gt;&gt;         // control flow *can* escape, since x has a value<br>&gt;&gt;     }<br>&gt; <br>&gt; We wouldn’t do that though, we’d require guard-like behavior for the same reason we require it for guard: the value of guard is that you *know* that an instance of guard doesn’t fall through, without analyzing its behavior in depth.<br>&gt; <br>&gt;&gt; Of course, you can achieve this today<br>&gt; <br>&gt; Yes, your proposal is a sugar proposal.<br>&gt; <br>&gt;&gt; with &quot;let x; do { x = try foo() } catch { x = bar() }&quot;, or with &quot;let x = try? foo() ?? bar()&quot;. I just wonder if it&#39;s worth considering the possibility that this new feature would allow control flow to escape in some cases. (After all, control flow can exit the &quot;catch&quot; block we have today.) But it&#39;s also nice to be able to glance at the code and see that, unambiguously, control flow can&#39;t escape the block.<br>&gt;&gt; <br>&gt;&gt; The reason I originally suggested &quot;guard&quot; is readability: Seeing the word &quot;guard&quot;, a reader knows that control flow can&#39;t escape the else/catch block. But I understand why guard is still necessary for working with optionals/patterns, and I suppose seeing &quot;try&quot; introducing the expression may be enough.<br>&gt; <br>&gt; This shouldn’t be tied to the presence of try, because it already means something (that the enclosed expression can throw).  This:<br>&gt; <br>&gt; guard let x = try foo() …<br>&gt; <br>&gt; Already means “call foo, if it throws, propagate the error.  If not, test the returned optional”.  Changing that based on a subsequent ‘catch’ seems wrong.<br>&gt; <br>&gt;&gt; Another question: should it work with expressions that don&#39;t bind variables? Simply &quot;try foo() catch { ... }&quot; ?  (At one point I had considered &quot;do try ... catch ...&quot;, as a braceless analogue of &quot;do { try ... } catch ...”.)<br>&gt; <br>&gt; In my opinion, this whole proposal could be better served with library functions.<br>&gt; <br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160314/d4508eb5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Idea: Extend &quot;guard&quot; to try-statements, with a catch block</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>March 14, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Mar 14, 2016, at 10:20 AM, Maximilian Hünenberger via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; How about only allowing &quot;guard try? catch&quot;:<br>&gt; <br>&gt;     guard let x = try? foo() catch { ... }<br>&gt; <br>&gt; This would address both concerns of Chris:<br>&gt; <br>&gt; • &quot;This is inconsistent with what we currently have, because “if let” and “guard let” match against an optional and succeed iff the optional is present.&quot;<br>&gt; <br>&gt; • &quot;This shouldn’t be tied to the presence of try, because it already means something (that the enclosed expression can throw).  This:<br>&gt;         guard let x = try foo() …<br>&gt; Already means “call foo, if it throws, propagate the error.  If not, test the returned optional”.&quot;<br>&gt; <br>&gt; <br>&gt; With &quot;try?&quot; it is clear that &quot;foo()&quot; doesn&#39;t throw an error in the guard expression and guard matches against an optional. This makes it unambiguous to &quot;guard try else&quot; which throws in this case.<br>&gt; <br>&gt; Kind regards<br>&gt; - Maximilian<br></p><p><br></p><p>I&#39;m not a fan of the notion of guard/catch. However, it occurs to me that my &quot;attempt&quot; code may address this issue.<br>I&#39;ve recently updated it to take an arbitrary error handler, which if omitted, simply prints the error. Otherwise it acts like try?<br>or if you set crashOnError, like try!. It works with guard.<br></p><p>-- E<br></p><p>github: https://github.com/erica/SwiftUtility/blob/master/Sources/CoreError.swift<br></p><p>public typealias CommonErrorHandlerType = (String, Int, ErrorType) -&gt; Void<br></p><p>/// Replacement for `try?` that introduces an error handler<br>/// The default handler prints an error before returning nil<br>///<br>/// - Parameter file: source file, derived from `__FILE__` context literal<br>/// - Parameter line: source line, derived from `__LINE__` context literal<br>/// - Parameter crashOnError: defaults to false. When set to true<br>///   will raise a fatal error, emulating try! instead of try?<br>/// - Parameter errorHandler: processes the error, returns nil<br>///<br>/// ```swift<br>/// attempt {<br>///   let mgr = NSFileManager.defaultManager()<br>///   try mgr.createDirectoryAtPath(<br>///     &quot;/Users/notarealuser&quot;,<br>///     withIntermediateDirectories: true,<br>///     attributes: nil)<br>/// }<br>/// ```<br>///<br>public func attempt&lt;T&gt;(<br>    file fileName: String = __FILE__,<br>    line lineNumber: Int = __LINE__,<br>    crashOnError: Bool = false,<br>    errorHandler: CommonErrorHandlerType = {<br>        // Default handler prints context:error and returns nil<br>        fileName, lineNumber, error in<br>        <br>        /// Retrieve last path component because #fileName is<br>        /// not yet a thing in Swift<br>        let trimmedFileName: String = (fileName as NSString).lastPathComponent<br>        <br>        /// Force print and return nil like try?<br>        print(&quot;Error \(trimmedFileName):\(lineNumber) \(error)&quot;)<br>    },<br>    closure: () throws -&gt; T) -&gt; T? {<br>        <br>        do {<br>            // Return executes only if closure succeeds, returning T<br>            return try closure()<br>            <br>        } catch {<br>            // Emulate try! by crashing<br>            if crashOnError {<br>                print(&quot;Fatal error \(fileName):\(lineNumber): \(error)&quot;)<br>                fatalError()<br>            }<br>            <br>            // Execute error handler and return nil<br>            errorHandler(fileName, lineNumber, error)<br>            return nil<br>        }<br>}<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160314/b277cde7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>Idea: Extend &quot;guard&quot; to try-statements, with a catch block</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>March 23, 2016 at 03:00:00pm</p></header><div class="content"><p>Your &quot;attempt&quot; function addresses this  issue if someone only wants to print the error:<br></p><p>guard let x = attempt({ try throwingFunction(y) }) else {<br>         return<br>}<br>// prints &quot;Error \(trimmedFileName):\(lineNumber) \(error)&quot;<br></p><p>In contrast to<br></p><p>guard let x = try? throwingFunction(y) catch {<br>        // you have to make your own print<br>        return<br>}<br></p><p>---------------------<br></p><p>However if you want to handle the error before you exit the scope it is quite inconvenient:<br></p><p>guard let x = attempt({ _, _, error in /* handle error */ }, { try throwingFunction(y) } ) else {<br>        return<br>}<br></p><p>In contrast to:<br></p><p>guard let x = try? throwingFunction(y) catch {<br>        // handle error<br>        return<br>}<br></p><p>- Maximilian<br></p><p>&gt; Am 14.03.2016 um 18:00 schrieb Erica Sadun &lt;erica at ericasadun.com&gt;:<br>&gt; <br>&gt;&gt; On Mar 14, 2016, at 10:20 AM, Maximilian Hünenberger via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; How about only allowing &quot;guard try? catch&quot;:<br>&gt;&gt; <br>&gt;&gt;     guard let x = try? foo() catch { ... }<br>&gt;&gt; <br>&gt;&gt; This would address both concerns of Chris:<br>&gt;&gt; <br>&gt;&gt; • &quot;This is inconsistent with what we currently have, because “if let” and “guard let” match against an optional and succeed iff the optional is present.&quot;<br>&gt;&gt; <br>&gt;&gt; • &quot;This shouldn’t be tied to the presence of try, because it already means something (that the enclosed expression can throw).  This:<br>&gt;&gt;         guard let x = try foo() …<br>&gt;&gt; Already means “call foo, if it throws, propagate the error.  If not, test the returned optional”.&quot;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; With &quot;try?&quot; it is clear that &quot;foo()&quot; doesn&#39;t throw an error in the guard expression and guard matches against an optional. This makes it unambiguous to &quot;guard try else&quot; which throws in this case.<br>&gt;&gt; <br>&gt;&gt; Kind regards<br>&gt;&gt; - Maximilian<br>&gt; <br>&gt; <br>&gt; <br>&gt; I&#39;m not a fan of the notion of guard/catch. However, it occurs to me that my &quot;attempt&quot; code may address this issue.<br>&gt; I&#39;ve recently updated it to take an arbitrary error handler, which if omitted, simply prints the error. Otherwise it acts like try?<br>&gt; or if you set crashOnError, like try!. It works with guard.<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; github: https://github.com/erica/SwiftUtility/blob/master/Sources/CoreError.swift<br>&gt; <br>&gt; public typealias CommonErrorHandlerType = (String, Int, ErrorType) -&gt; Void<br>&gt; <br>&gt; /// Replacement for `try?` that introduces an error handler<br>&gt; /// The default handler prints an error before returning nil<br>&gt; ///<br>&gt; /// - Parameter file: source file, derived from `__FILE__` context literal<br>&gt; /// - Parameter line: source line, derived from `__LINE__` context literal<br>&gt; /// - Parameter crashOnError: defaults to false. When set to true<br>&gt; ///   will raise a fatal error, emulating try! instead of try?<br>&gt; /// - Parameter errorHandler: processes the error, returns nil<br>&gt; ///<br>&gt; /// ```swift<br>&gt; /// attempt {<br>&gt; ///   let mgr = NSFileManager.defaultManager()<br>&gt; ///   try mgr.createDirectoryAtPath(<br>&gt; ///     &quot;/Users/notarealuser&quot;,<br>&gt; ///     withIntermediateDirectories: true,<br>&gt; ///     attributes: nil)<br>&gt; /// }<br>&gt; /// ```<br>&gt; ///<br>&gt; public func attempt&lt;T&gt;(<br>&gt;     file fileName: String = __FILE__,<br>&gt;     line lineNumber: Int = __LINE__,<br>&gt;     crashOnError: Bool = false,<br>&gt;     errorHandler: CommonErrorHandlerType = {<br>&gt;         // Default handler prints context:error and returns nil<br>&gt;         fileName, lineNumber, error in<br>&gt;         <br>&gt;         /// Retrieve last path component because #fileName is<br>&gt;         /// not yet a thing in Swift<br>&gt;         let trimmedFileName: String = (fileName as NSString).lastPathComponent<br>&gt;         <br>&gt;         /// Force print and return nil like try?<br>&gt;         print(&quot;Error \(trimmedFileName):\(lineNumber) \(error)&quot;)<br>&gt;     },<br>&gt;     closure: () throws -&gt; T) -&gt; T? {<br>&gt;         <br>&gt;         do {<br>&gt;             // Return executes only if closure succeeds, returning T<br>&gt;             return try closure()<br>&gt;             <br>&gt;         } catch {<br>&gt;             // Emulate try! by crashing<br>&gt;             if crashOnError {<br>&gt;                 print(&quot;Fatal error \(fileName):\(lineNumber): \(error)&quot;)<br>&gt;                 fatalError()<br>&gt;             }<br>&gt;             <br>&gt;             // Execute error handler and return nil<br>&gt;             errorHandler(fileName, lineNumber, error)<br>&gt;             return nil<br>&gt;         }<br>&gt; }<br>&gt; <br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160323/62d7f5df/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Idea: Extend &quot;guard&quot; to try-statements, with a catch block</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>March 23, 2016 at 10:00:00am</p></header><div class="content"><p>The error handler doesn&#39;t have to be co-linear or even defined in the same call:<br></p><p>/// consists of filename, line number, error tuple<br>public typealias CommonErrorHandlerType = (String, Int, ErrorType) -&gt; Void<br></p><p>/// Default error handler prints context and error<br>public let defaultCommonErrorHandler: CommonErrorHandlerType = {<br>    filePath, lineNumber, error in<br>    let trimmedFileName: String = (filePath as NSString).lastPathComponent<br>    print(&quot;Error \(trimmedFileName):\(lineNumber) \(error)&quot;)<br>}<br></p><p>If you&#39;re doing much more than printing or adding a line-or-two extra then <br>I don&#39;t think you should be using guard, you should be applying do-catch at the call site<br>or using try (not try? or try!) and forwarding the error handling.<br></p><p>-- E<br></p><p><br>&gt; On Mar 23, 2016, at 8:05 AM, Maximilian Hünenberger &lt;m.huenenberger at me.com&gt; wrote:<br>&gt; <br>&gt; Your &quot;attempt&quot; function addresses this  issue if someone only wants to print the error:<br>&gt; <br>&gt; guard let x = attempt({ try throwingFunction(y) }) else {<br>&gt;          return<br>&gt; }<br>&gt; // prints &quot;Error \(trimmedFileName):\(lineNumber) \(error)&quot;<br>&gt; <br>&gt; In contrast to<br>&gt; <br>&gt; guard let x = try? throwingFunction(y) catch {<br>&gt;         // you have to make your own print<br>&gt;         return<br>&gt; }<br>&gt; <br>&gt; ---------------------<br>&gt; <br>&gt; However if you want to handle the error before you exit the scope it is quite inconvenient:<br>&gt; <br>&gt; guard let x = attempt({ _, _, error in /* handle error */ }, { try throwingFunction(y) } ) else {<br>&gt;         return<br>&gt; }<br>&gt; <br>&gt; In contrast to:<br>&gt; <br>&gt; guard let x = try? throwingFunction(y) catch {<br>&gt;         // handle error<br>&gt;         return<br>&gt; }<br>&gt; <br>&gt; - Maximilian<br>&gt; <br>&gt; Am 14.03.2016 um 18:00 schrieb Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt;:<br>&gt; <br>&gt;&gt;&gt; On Mar 14, 2016, at 10:20 AM, Maximilian Hünenberger via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; How about only allowing &quot;guard try? catch&quot;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     guard let x = try? foo() catch { ... }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This would address both concerns of Chris:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; • &quot;This is inconsistent with what we currently have, because “if let” and “guard let” match against an optional and succeed iff the optional is present.&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; • &quot;This shouldn’t be tied to the presence of try, because it already means something (that the enclosed expression can throw).  This:<br>&gt;&gt;&gt;         guard let x = try foo() …<br>&gt;&gt;&gt; Already means “call foo, if it throws, propagate the error.  If not, test the returned optional”.&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; With &quot;try?&quot; it is clear that &quot;foo()&quot; doesn&#39;t throw an error in the guard expression and guard matches against an optional. This makes it unambiguous to &quot;guard try else&quot; which throws in this case.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Kind regards<br>&gt;&gt;&gt; - Maximilian<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I&#39;m not a fan of the notion of guard/catch. However, it occurs to me that my &quot;attempt&quot; code may address this issue.<br>&gt;&gt; I&#39;ve recently updated it to take an arbitrary error handler, which if omitted, simply prints the error. Otherwise it acts like try?<br>&gt;&gt; or if you set crashOnError, like try!. It works with guard.<br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt; github: https://github.com/erica/SwiftUtility/blob/master/Sources/CoreError.swift &lt;https://github.com/erica/SwiftUtility/blob/master/Sources/CoreError.swift&gt;<br>&gt;&gt; <br>&gt;&gt; public typealias CommonErrorHandlerType = (String, Int, ErrorType) -&gt; Void<br>&gt;&gt; <br>&gt;&gt; /// Replacement for `try?` that introduces an error handler<br>&gt;&gt; /// The default handler prints an error before returning nil<br>&gt;&gt; ///<br>&gt;&gt; /// - Parameter file: source file, derived from `__FILE__` context literal<br>&gt;&gt; /// - Parameter line: source line, derived from `__LINE__` context literal<br>&gt;&gt; /// - Parameter crashOnError: defaults to false. When set to true<br>&gt;&gt; ///   will raise a fatal error, emulating try! instead of try?<br>&gt;&gt; /// - Parameter errorHandler: processes the error, returns nil<br>&gt;&gt; ///<br>&gt;&gt; /// ```swift<br>&gt;&gt; /// attempt {<br>&gt;&gt; ///   let mgr = NSFileManager.defaultManager()<br>&gt;&gt; ///   try mgr.createDirectoryAtPath(<br>&gt;&gt; ///     &quot;/Users/notarealuser&quot;,<br>&gt;&gt; ///     withIntermediateDirectories: true,<br>&gt;&gt; ///     attributes: nil)<br>&gt;&gt; /// }<br>&gt;&gt; /// ```<br>&gt;&gt; ///<br>&gt;&gt; public func attempt&lt;T&gt;(<br>&gt;&gt;     file fileName: String = __FILE__,<br>&gt;&gt;     line lineNumber: Int = __LINE__,<br>&gt;&gt;     crashOnError: Bool = false,<br>&gt;&gt;     errorHandler: CommonErrorHandlerType = {<br>&gt;&gt;         // Default handler prints context:error and returns nil<br>&gt;&gt;         fileName, lineNumber, error in<br>&gt;&gt;         <br>&gt;&gt;         /// Retrieve last path component because #fileName is<br>&gt;&gt;         /// not yet a thing in Swift<br>&gt;&gt;         let trimmedFileName: String = (fileName as NSString).lastPathComponent<br>&gt;&gt;         <br>&gt;&gt;         /// Force print and return nil like try?<br>&gt;&gt;         print(&quot;Error \(trimmedFileName):\(lineNumber) \(error)&quot;)<br>&gt;&gt;     },<br>&gt;&gt;     closure: () throws -&gt; T) -&gt; T? {<br>&gt;&gt;         <br>&gt;&gt;         do {<br>&gt;&gt;             // Return executes only if closure succeeds, returning T<br>&gt;&gt;             return try closure()<br>&gt;&gt;             <br>&gt;&gt;         } catch {<br>&gt;&gt;             // Emulate try! by crashing<br>&gt;&gt;             if crashOnError {<br>&gt;&gt;                 print(&quot;Fatal error \(fileName):\(lineNumber): \(error)&quot;)<br>&gt;&gt;                 fatalError()<br>&gt;&gt;             }<br>&gt;&gt;             <br>&gt;&gt;             // Execute error handler and return nil<br>&gt;&gt;             errorHandler(fileName, lineNumber, error)<br>&gt;&gt;             return nil<br>&gt;&gt;         }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160323/409d5e24/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>Idea: Extend &quot;guard&quot; to try-statements, with a catch block</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>March 13, 2016 at 02:00:00pm</p></header><div class="content"><p>This is the exact same topic I started over a moth ago: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160201/009296.html<br></p><p>As already discussed in my topic it’s better not to use `guard` in this case, but add a new single statement `try catch` mechanism.<br></p><p>func scope() {		<br>	let foo: Int? = try throwingFuncReturns() catch { <br>		// foo can’t be available here, because its<br>		// declared on the same line  <br>		// by default you can fall through the catch block<br>	}<br>	// using foo would not be save here<br>	guard let unwrappedFoo = foo else { <br>		return<br>	}<br>	use(unwrappedFoo)<br>}<br>On way to solve this problem for throwing functions that return a value could look like this:<br>func scope() {		<br>	let foo: Int? <br>	foo = try throwingFuncReturns() catch { <br>		// foo is available here<br>		// make sure to initialize foo here if you do not return from here<br>	}<br>	// foo is save here<br>	guard let unwrappedFoo = foo else { <br>		return<br>	}<br>	use(unwrappedFoo)<br>}<br>And because we just can’t use a single `try catch` statement like we would wish, we can bring back the `do` keyword.<br>func scope() {		<br>	let foo: Int? <br>	do foo = try throwingFuncReturns() catch { <br>		// init foo (+ more optional work) or return<br>	}<br>	guard let unwrappedFoo = foo else { <br>		return<br>	}<br>	use(unwrappedFoo)<br>}<br>This is the best solution I could come up with, and it does work fine with functions that do not return a value:<br>func scope() {		<br>	let foo: Int? <br>	do try catchMeIfYouCan() catch { <br>		// do some work -&gt; fallthough or return<br>	}<br>}<br>But from my personal point of view I would remove the `do` keyword in single `try catch` statements. The `do` keyboard is only needed for the `do body` if there are more lines of code to process before catching an error.<br>A single `do catch` mechanism would be good for escaping another pyramid of doom like we had with `if` before the `guard` mechanism was introduced.<br>-- <br>Adrian Zubarev<br></p><p>Am 8. März 2016 bei 20:37:52, Jacob Bandes-Storch via swift-evolution (swift-evolution at swift.org) schrieb:<br></p><p>Thanks for the feedback, Chris.<br></p><p>To clarify, are you suggesting that plain variable bindings would support this too (such as &quot;let x = try foo() catch { ... }&quot;)? I like this idea. I can also foresee the desire for something like this:<br></p><p>    let x = try foo() catch {<br>        print(error)<br>        x = bar()   // by some syntax, provide a fallback value for x, since foo() threw<br>        // control flow *can* escape, since x has a value<br>    }<br></p><p>Of course, you can achieve this today with &quot;let x; do { x = try foo() } catch { x = bar() }&quot;, or with &quot;let x = try? foo() ?? bar()&quot;. I just wonder if it&#39;s worth considering the possibility that this new feature would allow control flow to escape in some cases. (After all, control flow can exit the &quot;catch&quot; block we have today.) But it&#39;s also nice to be able to glance at the code and see that, unambiguously, control flow can&#39;t escape the block.<br></p><p>The reason I originally suggested &quot;guard&quot; is readability: Seeing the word &quot;guard&quot;, a reader knows that control flow can&#39;t escape the else/catch block. But I understand why guard is still necessary for working with optionals/patterns, and I suppose seeing &quot;try&quot; introducing the expression may be enough.<br></p><p>Do you have thoughts on whether else/catch blocks should be re-orderable?<br></p><p>Another question: should it work with expressions that don&#39;t bind variables? Simply &quot;try foo() catch { ... }&quot; ?  (At one point I had considered &quot;do try ... catch ...&quot;, as a braceless analogue of &quot;do { try ... } catch ...&quot;.)<br></p><p>Jacob<br></p><p>On Mon, Feb 29, 2016 at 10:34 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>On Feb 29, 2016, at 12:09 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>I propose extending guard-statements to handle errors without using the optional &quot;try?&quot; and without a do-block, by allowing the expression to throw, and offering &quot;catch&quot; instead of &quot;else&quot;:<br></p><p>    // func foo() throws -&gt; T ...<br>    guard let x = try foo catch {<br>        print(&quot;the error was: \(error)&quot;)  // the &quot;error&quot; parameter is available here<br>        // the compiler does not allow control flow to escape this block<br>    }<br>    // control flow cannot reach here if foo() threw an error<br></p><p>I don’t think that this syntax makes sense, because you’re changing &quot;guard let x = ” to not test an optional.  The syntax you’re searching for seems more consistent as a modifier on var/let itself:<br></p><p>// func foo() throws -&gt; T ...<br>let x = try foo() catch {<br>        print(&quot;the error was: \(error)&quot;)  // the &quot;error&quot; parameter is available here<br>        // the compiler does not allow control flow to escape this block<br>}<br></p><p>The guard form of this would still make sense, but the existing “guard let” and “guard case” matching should work as it does.  For example, something like this should be allowed:<br></p><p>// func bar() throws -&gt; T?<br>guard let x = try bar() else {<br>        // this runs if ‘bar’ returns nil.<br>        // the compiler does not allow control flow to escape this block<br>} catch {<br>        print(&quot;the error was: \(error)&quot;)  // the &quot;error&quot; parameter is available here<br>        // the compiler does not allow control flow to escape this block<br>}<br></p><p>More generally, the “guard” form would be workable on anything that takes a stmt-condition.  This brings “if&quot; and “while” into the mix.<br></p><p>-Chris<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160313/cdb51f76/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
