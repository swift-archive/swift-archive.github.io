<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Revisiting SE-0041 Names</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June 27, 2016 at 03:00:00pm</p></header><div class="content"><p>on Thu Jun 23 2016, Xiaodi Wu &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Thu, Jun 23, 2016 at 1:26 AM, David Sweeris via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; On Jun 22, 2016, at 19:35, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; On Wed, Jun 22, 2016 at 5:15 PM, David Sweeris &lt;davesweeris at mac.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt; That&#39;s a really interesting idea. Is &quot;Syntax&quot; a placeholder, or is that<br>&gt;&gt; the intended name?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; It is the best name we could come up with, we are open to better<br>&gt;&gt; suggestions.<br>&gt;&gt;<br>&gt;&gt; I guess it depends on the intended semantics of the &quot;namespace&quot;. If the<br>&gt;&gt; purpose is to be a container for the various LiteralConvertible protocols,<br>&gt;&gt; then maybe something like `AcceptsLiteralType.Integer` might be better?<br>&gt;&gt; It&#39;s a bit wordy, though.<br>&gt;&gt;<br>&gt;<br>&gt; I get what&#39;s being aimed at here, but I think the meaning of `Syntax` in<br>&gt; this context is indecipherable. IIUC, the point to be conveyed by the term<br>&gt; is that a literal has no type until it is supplied as an argument to the<br>&gt; initializer and becomes typed. <br></p><p>No, it has no type until its type is deduced.  No initializer call<br>appears in the source.  Supplying the argument to the initializer is<br>merely the mechanism by which the compiler constructs the value once the<br>type is deduced.  <br></p><p>&gt; Maybe we could say that the type gives form to the literal or embodies<br>&gt; the literal? Thus maybe a name like `IntegerLiteralEmbodiment` or<br>&gt; `IntegerLiteralManifestation`, maybe even `IntegerLiteralModeling`.<br></p><p>The first two names are so esoteric that I can&#39;t imagine them being anything but<br>confusing, and “Modeling” is redundant; everything that conforms to a<br>protocol models that protocol.<br></p><p>If we were to add words to the name, I&#39;d go with<br></p><p>   IntegerLiteralExpressible<br></p><p>I *think* I still would want to sink this name into the Syntax<br>namespace, though.<br></p><p>&gt;&gt; &gt;&gt; Also, why an enum? Especially one without any cases...<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; It is not possible to create an instance of an enum that does not have<br>&gt;&gt; &gt; cases.  It becomes essentially a namespace.<br>&gt;&gt;<br>&gt;&gt; Oh that&#39;s a clever work-around. I like it :-)<br>&gt;&gt;<br>&gt;&gt; - Dave Sweeris<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Revisiting SE-0041 Names</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>June 27, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jun 27, 2016, at 4:47 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Maybe we could say that the type gives form to the literal or embodies<br>&gt;&gt; the literal? Thus maybe a name like `IntegerLiteralEmbodiment` or<br>&gt;&gt; `IntegerLiteralManifestation`, maybe even `IntegerLiteralModeling`.<br>&gt; <br>&gt; The first two names are so esoteric that I can&#39;t imagine them being anything but<br>&gt; confusing, and “Modeling” is redundant; everything that conforms to a<br>&gt; protocol models that protocol.<br>&gt; <br>&gt; If we were to add words to the name, I&#39;d go with<br>&gt; <br>&gt;   IntegerLiteralExpressible<br>&gt; <br>&gt; I *think* I still would want to sink this name into the Syntax<br>&gt; namespace, though.<br></p><p>You didn&#39;t respond to my earlier suggestion so I&#39;d like to pitch it again.<br></p><p>What about &quot;Syntax.IntegerLiteralConsumer&quot;, which suggests that<br>conforming types can consume integer literal syntax as native to their<br>type.<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/e9d8837a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Revisiting SE-0041 Names</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June 27, 2016 at 07:00:00pm</p></header><div class="content"><p>on Mon Jun 27 2016, Erica Sadun &lt;erica-AT-ericasadun.com&gt; wrote:<br></p><p>&gt;&gt; On Jun 27, 2016, at 4:47 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Maybe we could say that the type gives form to the literal or embodies<br>&gt;&gt;&gt; the literal? Thus maybe a name like `IntegerLiteralEmbodiment` or<br>&gt;&gt;&gt; `IntegerLiteralManifestation`, maybe even `IntegerLiteralModeling`.<br>&gt;<br>&gt;&gt; <br>&gt;&gt; The first two names are so esoteric that I can&#39;t imagine them being anything but<br>&gt;&gt; confusing, and “Modeling” is redundant; everything that conforms to a<br>&gt;&gt; protocol models that protocol.<br>&gt;&gt; <br>&gt;&gt; If we were to add words to the name, I&#39;d go with<br>&gt;&gt; <br>&gt;&gt;   IntegerLiteralExpressible<br>&gt;&gt; <br>&gt;&gt; I *think* I still would want to sink this name into the Syntax<br>&gt;&gt; namespace, though.<br>&gt;<br>&gt; You didn&#39;t respond to my earlier suggestion so I&#39;d like to pitch it again.<br>&gt;<br>&gt; What about &quot;Syntax.IntegerLiteralConsumer&quot;, which suggests that<br>&gt; conforming types can consume integer literal syntax as native to their<br>&gt; type.<br></p><p>To me, the idea of a type (other than, say, a parser) consuming syntax<br>is pretty alien.  So this one is sorta esoteric too, IMO.<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Revisiting SE-0041 Names</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>June 28, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; On Jun 27, 2016, at 8:46 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Mon Jun 27 2016, Erica Sadun &lt;erica-AT-ericasadun.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Jun 27, 2016, at 4:47 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Maybe we could say that the type gives form to the literal or embodies<br>&gt;&gt;&gt;&gt; the literal? Thus maybe a name like `IntegerLiteralEmbodiment` or<br>&gt;&gt;&gt;&gt; `IntegerLiteralManifestation`, maybe even `IntegerLiteralModeling`.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The first two names are so esoteric that I can&#39;t imagine them being anything but<br>&gt;&gt;&gt; confusing, and “Modeling” is redundant; everything that conforms to a<br>&gt;&gt;&gt; protocol models that protocol.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If we were to add words to the name, I&#39;d go with<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  IntegerLiteralExpressible<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I *think* I still would want to sink this name into the Syntax<br>&gt;&gt;&gt; namespace, though.<br>&gt;&gt; <br>&gt;&gt; You didn&#39;t respond to my earlier suggestion so I&#39;d like to pitch it again.<br>&gt;&gt; <br>&gt;&gt; What about &quot;Syntax.IntegerLiteralConsumer&quot;, which suggests that<br>&gt;&gt; conforming types can consume integer literal syntax as native to their<br>&gt;&gt; type.<br>&gt; <br>&gt; To me, the idea of a type (other than, say, a parser) consuming syntax<br>&gt; is pretty alien.  So this one is sorta esoteric too, IMO.<br>&gt; <br>&gt; -- <br>&gt; Dave<br></p><p>It may be sorta esoteric, but I&#39;d say it&#39;s a fair degree clearer to the intended<br>audience of Swift developers.<br></p><p>I ran a one-question poll last night about &quot;Syntax.IntegerLiteralExpressible&quot;.<br>I asked what Swift developers (who were not following this discussion) thought it<br>meant.<br></p><p>The results can be found here:<br>https://www.surveymonkey.com/results/SM-FGMC93JT/ &lt;https://www.surveymonkey.com/results/SM-FGMC93JT/&gt;<br>A tab at the top lets you view individual answers paired with explanations.<br></p><p>By a margin of at least like 9:1 (more if you include the freeform answers of &quot;why&quot; such as<br>answer 80, which says &quot;It reminds me of StringLiteralExpressible which behaves that way.<br>But you&#39;re right, the name sounds like the other option.&quot;) developers thought that the <br>protocol meant (or should mean) that the conforming type could express itself as an integer <br>literal, and not that an integer literal can be expressed as the conforming type.<br></p><p>I encourage you to look at the individual responses. They include the freeform answers<br>that describe why each person chose as they did.<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/8eff0dee/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Revisiting SE-0041 Names</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June 28, 2016 at 10:00:00am</p></header><div class="content"><p>on Tue Jun 28 2016, Erica Sadun &lt;erica-AT-ericasadun.com&gt; wrote:<br></p><p>&gt;&gt; On Jun 27, 2016, at 8:46 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Mon Jun 27 2016, Erica Sadun &lt;erica-AT-ericasadun.com&gt; wrote:<br>&gt;&gt; <br>&gt;<br>&gt;&gt;&gt;&gt; On Jun 27, 2016, at 4:47 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Maybe we could say that the type gives form to the literal or embodies<br>&gt;&gt;&gt;&gt;&gt; the literal? Thus maybe a name like `IntegerLiteralEmbodiment` or<br>&gt;&gt;&gt;&gt;&gt; `IntegerLiteralManifestation`, maybe even `IntegerLiteralModeling`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The first two names are so esoteric that I can&#39;t imagine them being anything but<br>&gt;&gt;&gt;&gt; confusing, and “Modeling” is redundant; everything that conforms to a<br>&gt;&gt;&gt;&gt; protocol models that protocol.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If we were to add words to the name, I&#39;d go with<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  IntegerLiteralExpressible<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I *think* I still would want to sink this name into the Syntax<br>&gt;&gt;&gt;&gt; namespace, though.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You didn&#39;t respond to my earlier suggestion so I&#39;d like to pitch it again.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What about &quot;Syntax.IntegerLiteralConsumer&quot;, which suggests that<br>&gt;&gt;&gt; conforming types can consume integer literal syntax as native to their<br>&gt;&gt;&gt; type.<br>&gt;&gt; <br>&gt;&gt; To me, the idea of a type (other than, say, a parser) consuming syntax<br>&gt;&gt; is pretty alien.  So this one is sorta esoteric too, IMO.<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Dave<br>&gt;<br>&gt; It may be sorta esoteric, but I&#39;d say it&#39;s a fair degree clearer to the intended<br>&gt; audience of Swift developers.<br>&gt;<br>&gt; I ran a one-question poll last night about &quot;Syntax.IntegerLiteralExpressible&quot;.<br>&gt; I asked what Swift developers (who were not following this discussion) thought it<br>&gt; meant.<br>&gt;<br>&gt; The results can be found here:<br>&gt; https://www.surveymonkey.com/results/SM-FGMC93JT/ &lt;https://www.surveymonkey.com/results/SM-FGMC93JT/&gt;<br>&gt; A tab at the top lets you view individual answers paired with explanations.<br>&gt;<br>&gt; By a margin of at least like 9:1 (more if you include the freeform answers of &quot;why&quot; such as<br>&gt; answer 80, which says &quot;It reminds me of StringLiteralExpressible which behaves that way.<br>&gt; But you&#39;re right, the name sounds like the other option.&quot;) developers thought that the <br>&gt; protocol meant (or should mean) that the conforming type could express itself as an integer <br>&gt; literal, and not that an integer literal can be expressed as the<br>&gt; conforming type.<br></p><p>Which is exactly the right sense.  Well, the only correct-ish option you<br>gave people is slightly awkward and inaccurate—I&#39;d have said “Instances<br>of the conforming type can be expressed as integer literals,” but that<br>matches the 90% meaning almost exactly; certainly much better than the<br>10%.<br></p><p>As far as I can tell, your poll supports my suggestion.<br></p><p>&gt; I encourage you to look at the individual responses. They include the<br>&gt; freeform answers that describe why each person chose as they did.<br></p><p><br>-- <br>Dave<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Revisiting SE-0041 Names</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 27, 2016 at 11:00:00pm</p></header><div class="content"><p>On Mon, Jun 27, 2016 at 6:47 PM, Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; on Thu Jun 23 2016, Xiaodi Wu &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; &gt; On Thu, Jun 23, 2016 at 1:26 AM, David Sweeris via swift-evolution &lt;<br>&gt; &gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt; On Jun 22, 2016, at 19:35, Dmitri Gribenko &lt;gribozavr at gmail.com&gt;<br>&gt; wrote:<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt;&gt; On Wed, Jun 22, 2016 at 5:15 PM, David Sweeris &lt;davesweeris at mac.com&gt;<br>&gt; &gt;&gt; wrote:<br>&gt; &gt;&gt; &gt;&gt; That&#39;s a really interesting idea. Is &quot;Syntax&quot; a placeholder, or is<br>&gt; that<br>&gt; &gt;&gt; the intended name?<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; It is the best name we could come up with, we are open to better<br>&gt; &gt;&gt; suggestions.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I guess it depends on the intended semantics of the &quot;namespace&quot;. If the<br>&gt; &gt;&gt; purpose is to be a container for the various LiteralConvertible<br>&gt; protocols,<br>&gt; &gt;&gt; then maybe something like `AcceptsLiteralType.Integer` might be better?<br>&gt; &gt;&gt; It&#39;s a bit wordy, though.<br>&gt; &gt;&gt;<br>&gt; &gt;<br>&gt; &gt; I get what&#39;s being aimed at here, but I think the meaning of `Syntax` in<br>&gt; &gt; this context is indecipherable. IIUC, the point to be conveyed by the<br>&gt; term<br>&gt; &gt; is that a literal has no type until it is supplied as an argument to the<br>&gt; &gt; initializer and becomes typed.<br>&gt;<br>&gt; No, it has no type until its type is deduced.  No initializer call<br>&gt; appears in the source.  Supplying the argument to the initializer is<br>&gt; merely the mechanism by which the compiler constructs the value once the<br>&gt; type is deduced.<br>&gt;<br></p><p>Right. Sorry, clearly a brainfart there on my part.<br></p><p><br>&gt;<br>&gt; &gt; Maybe we could say that the type gives form to the literal or embodies<br>&gt; &gt; the literal? Thus maybe a name like `IntegerLiteralEmbodiment` or<br>&gt; &gt; `IntegerLiteralManifestation`, maybe even `IntegerLiteralModeling`.<br>&gt;<br>&gt; The first two names are so esoteric that I can&#39;t imagine them being<br>&gt; anything but<br>&gt; confusing, and “Modeling” is redundant; everything that conforms to a<br>&gt; protocol models that protocol.<br>&gt;<br>&gt; If we were to add words to the name, I&#39;d go with<br>&gt;<br>&gt;    IntegerLiteralExpressible<br>&gt;<br></p><p>I think that sounds wonderful.<br></p><p><br>&gt; I *think* I still would want to sink this name into the Syntax<br>&gt; namespace, though.<br>&gt;<br></p><p>`Syntax.IntegerLiteralExpressible` absolutely makes sense to me. To me,<br>this says, the conforming type is integer literal expressible, which falls<br>under the umbrella of syntax. Somehow, `Syntax.IntegerLiteral` just does<br>not compute in my head, maybe because instinctively it looks like something<br>should come after &quot;literal,&quot; and using &quot;syntax&quot; to plug that hole doesn&#39;t<br>yield an interpretable name.<br></p><p><br>&gt;<br>&gt; &gt;&gt; &gt;&gt; Also, why an enum? Especially one without any cases...<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; It is not possible to create an instance of an enum that does not have<br>&gt; &gt;&gt; &gt; cases.  It becomes essentially a namespace.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Oh that&#39;s a clever work-around. I like it :-)<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; - Dave Sweeris<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt;<br>&gt; --<br>&gt; Dave<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/ac6becb6/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
