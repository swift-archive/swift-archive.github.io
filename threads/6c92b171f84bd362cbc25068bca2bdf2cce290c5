<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>ExpressibleByStringInterpolation vs. String re-evaluation vs. Regex</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>August  8, 2016 at 05:00:00pm</p></header><div class="content"><p>on Sat Jul 30 2016, Jacob Bandes-Storch &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; In the past, there has been some interest in refining the behavior of<br>&gt; ExpressibleByStringInterpolation (née StringInterpolationConvertible), for<br>&gt; example:<br>&gt;<br>&gt; - Ability to *restrict the types that can be used* as interpolation segments<br>&gt; - Ability to *distinguish the string-literal segments* from interpolation<br>&gt; segments whose type is String<br></p><p>Hi Jacob,<br></p><p>I see you&#39;ve already filed a Jira for the second bullet.  Can you file<br>one for the first one?  We&#39;re going to redesign<br>ExpressibleByStringInterpolation for Swift 4 and solve these problems.<br></p><p>Thanks,<br></p><p>&gt; Some prior discussions:<br>&gt; - &quot;StringInterpolationConvertible and StringLiteralConvertible inheritance&quot;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160516/017654.html<br>&gt; - Sub-discussion in &quot;Allow multiple conformances to the same protocol&quot;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160606/020746.html<br>&gt; - &quot;StringInterpolationConvertible: can&#39;t distinguish between literal<br>&gt; components and String arguments&quot;  https://bugs.swift.org/browse/SR-1260<br>&gt; / rdar://problem/19800456&amp;18681780<br>&gt; - &quot;Proposal: Deprecate optionals in string interpolation&quot;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160516/018000.html<br>&gt;<br>&gt; About Swift 4, Chris wrote:<br>&gt;<br>&gt;&gt;  - *String re-evaluation:* String is one of the most important<br>&gt;&gt; fundamental types in the language.  The standard library leads have<br>&gt;&gt; numerous ideas of how to improve the programming model for it, without<br>&gt;&gt; jeopardizing the goals of providing a unicode-correct-by-default model.<br>&gt;&gt; Our goal is to be better at string processing than Perl!<br>&gt;<br>&gt; I&#39;d be interested in any more detail the team can provide on this. I&#39;d like<br>&gt; to talk about string interpolation improvements, but it wouldn&#39;t be wise to<br>&gt; do so without keeping an eye towards possible regex/pattern-binding syntax,<br>&gt; and the String refinements that the stdlib team has in mind, if there&#39;s a<br>&gt; chance they would affect interpolation.<br>&gt;<br>&gt; Discuss!<br>&gt;<br>&gt; -Jacob<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>ExpressibleByStringInterpolation vs. String re-evaluation vs. Regex</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>August  8, 2016 at 10:00:00pm</p></header><div class="content"><p>Hi Dave,<br>I just filed https://bugs.swift.org/browse/SR-2303.<br></p><p>Brainstorming: is it important that the init(stringInterpolation:) and<br>init(stringInterpolationSegment:) requirements are on the same type?<br>Perhaps it would work to separate these two requirements, allowing the<br>segments to construct intermediate types, and only requiring the type<br>adopting ExpressibleByStringInterpolation to implement<br>init(stringInterpolation:).<br></p><p>This would be nice because it would be much easier for types which aren&#39;t<br>enums to conform to ExpressibleByStringInterpolation. In my auto layout<br>example (https://gist.github.com/jtbandes/9c1c25ee4996d2554375), the<br>ConstraintCollection type is only an enum because it has to provide all the<br>initializers, but it&#39;s strange that the cases are accessible publicly;<br>ideally it would just be a struct with no public initializers besides<br>init(stringInterpolation:). For example:<br></p><p>    enum InterpolationSegment&lt;T: InterpolationSegmentProtocol&gt; {<br>        case stringLiteral(String)<br>        case interpolatedValue(T)<br>    }<br></p><p>    protocol InterpolationSegmentProtocol {<br>        // Might want to implement init(stringInterpolationSegment:) for<br>multiple types,<br>        // so we can&#39;t require a single associated value (same with<br>ExpressibleByStringLiteral today)<br>    //    associatedtype Value<br>    //    init(stringInterpolationSegment value: Value)<br>    }<br></p><p>    protocol MyExpressibleByStringInterpolation {<br>        associatedtype Segment: InterpolationSegmentProtocol<br>        init(stringInterpolation: InterpolationSegment&lt;Segment&gt;...)<br>    }<br></p><p>    // Foo is constructed from a string interpolation containing only<br>    // String pieces and Foo.Segment pieces.<br>    struct Foo: MyExpressibleByStringInterpolation {<br>        struct Segment: InterpolationSegmentProtocol {<br>            init(stringInterpolationSegment value: Int) {}<br>            init(stringInterpolationSegment value: Double) {}<br>        }<br>        init(stringInterpolation: InterpolationSegment&lt;Segment&gt;...) {<br>            // ...<br>        }<br>    }<br></p><p>    let x: Foo = &quot;abc\(3)def&quot;<br>    // translated to<br>    Foo(stringInterpolation:<br>        .stringLiteral(&quot;abc&quot;),<br>        .interpolatedValue(.init(stringInterpolationSegment: 3)),<br>        .stringLiteral(&quot;def&quot;))<br></p><p><br>Jacob<br></p><p>On Mon, Aug 8, 2016 at 5:57 PM, Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; on Sat Jul 30 2016, Jacob Bandes-Storch &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; &gt; In the past, there has been some interest in refining the behavior of<br>&gt; &gt; ExpressibleByStringInterpolation (née StringInterpolationConvertible),<br>&gt; for<br>&gt; &gt; example:<br>&gt; &gt;<br>&gt; &gt; - Ability to *restrict the types that can be used* as interpolation<br>&gt; segments<br>&gt; &gt; - Ability to *distinguish the string-literal segments* from interpolation<br>&gt; &gt; segments whose type is String<br>&gt;<br>&gt; Hi Jacob,<br>&gt;<br>&gt; I see you&#39;ve already filed a Jira for the second bullet.  Can you file<br>&gt; one for the first one?  We&#39;re going to redesign<br>&gt; ExpressibleByStringInterpolation for Swift 4 and solve these problems.<br>&gt;<br>&gt; Thanks,<br>&gt;<br>&gt; &gt; Some prior discussions:<br>&gt; &gt; - &quot;StringInterpolationConvertible and StringLiteralConvertible<br>&gt; inheritance&quot;<br>&gt; &gt; https://lists.swift.org/pipermail/swift-evolution/<br>&gt; Week-of-Mon-20160516/017654.html<br>&gt; &gt; - Sub-discussion in &quot;Allow multiple conformances to the same protocol&quot;<br>&gt; &gt; https://lists.swift.org/pipermail/swift-evolution/<br>&gt; Week-of-Mon-20160606/020746.html<br>&gt; &gt; - &quot;StringInterpolationConvertible: can&#39;t distinguish between literal<br>&gt; &gt; components and String arguments&quot;  https://bugs.swift.org/browse/SR-1260<br>&gt; &gt; / rdar://problem/19800456&amp;18681780<br>&gt; &gt; - &quot;Proposal: Deprecate optionals in string interpolation&quot;<br>&gt; &gt; https://lists.swift.org/pipermail/swift-evolution/<br>&gt; Week-of-Mon-20160516/018000.html<br>&gt; &gt;<br>&gt; &gt; About Swift 4, Chris wrote:<br>&gt; &gt;<br>&gt; &gt;&gt;  - *String re-evaluation:* String is one of the most important<br>&gt; &gt;&gt; fundamental types in the language.  The standard library leads have<br>&gt; &gt;&gt; numerous ideas of how to improve the programming model for it, without<br>&gt; &gt;&gt; jeopardizing the goals of providing a unicode-correct-by-default model.<br>&gt; &gt;&gt; Our goal is to be better at string processing than Perl!<br>&gt; &gt;<br>&gt; &gt; I&#39;d be interested in any more detail the team can provide on this. I&#39;d<br>&gt; like<br>&gt; &gt; to talk about string interpolation improvements, but it wouldn&#39;t be wise<br>&gt; to<br>&gt; &gt; do so without keeping an eye towards possible regex/pattern-binding<br>&gt; syntax,<br>&gt; &gt; and the String refinements that the stdlib team has in mind, if there&#39;s a<br>&gt; &gt; chance they would affect interpolation.<br>&gt; &gt;<br>&gt; &gt; Discuss!<br>&gt; &gt;<br>&gt; &gt; -Jacob<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt;<br>&gt; --<br>&gt; -Dave<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160808/44830f43/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
