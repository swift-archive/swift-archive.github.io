<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b7500f08a3dd8dd1e8f3a58965aab0fa?s=50"></div><header><strong>lazy keyword vs lazy initialization pattern</strong> from <string>Cameron Knight</string> &lt;camjknight at mac.com&gt;<p>December  4, 2015 at 06:00:00pm</p></header><div class="content"><p>Unless I&#39;m missing something, this should give you the results you are looking for:<br></p><p>class MyClass {<br>    var foreignKey: Int64 {<br>        didSet {<br>            self.foreignObject = nil<br>        }<br>    }<br></p><p>    lazy var foreignObject: ForeignClass! = {<br>        return Database.expensiveSelect(self.foreignKey)<br>    }()<br>}<br></p><p>Using an Implicitly Unwrapped Optional instead of an Optional allows you to set foreignObject to nil which will give you the same behavior you use in Objective-C (a.k.a. null_resettable).<br></p><p>&gt; To me this actually feels more like something that might fit better as an additional type of optional, rather than a language feature.<br>&gt; <br>&gt; Setting this optional to nil could work normally, and any attempt to access the value when nil would cause the reload to occur. The initialization semantics might be a tad ugly though.<br>&gt; <br>&gt; var myLazyOpt = ReloadingOptional&lt;ForeignClass&gt;({<br>&gt; return Database.expensiveSelect(self.foreignKey)<br>&gt; })<br>&gt; <br>&gt; You could probably implement something like this yourself, though I&#39;m not sure how elegant that would be without full language support.<br>&gt; <br>&gt; Thanks for your time,<br>&gt; Cole Kurkowski<br>&gt; &gt; On Dec 4, 2015, at 07:40, David Hart &lt;david at hartbit.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt; &gt; <br>&gt; &gt; In Objective-C, I often used the lazy initialization pattern to implement a cache for expensive operations. For exemple, here is an often used scenario in a project where objects behind foreign keys in a database ORM are only fetched when necessary:<br>&gt; &gt; <br>&gt; &gt; @interface MyClass : NSObject<br>&gt; &gt; <br>&gt; &gt; @property (nonatomic) ForeignClass* foreignObject;<br>&gt; &gt; @property (nonatomic) int64_t foreignKey;<br>&gt; &gt; <br>&gt; &gt; @end<br>&gt; &gt; <br>&gt; &gt; @implementation MyClass<br>&gt; &gt; <br>&gt; &gt; - (void)setForeignKey:(int64_t)foreignKey {<br>&gt; &gt;   _foreignKey = foreignKey;<br>&gt; &gt;   _foreignObject = nil;<br>&gt; &gt; }<br>&gt; &gt; <br>&gt; &gt; - (ForeignClass*)foreignObject {<br>&gt; &gt;   if (!_foreignObject) {<br>&gt; &gt;       _foreignObject = [Database expensiveSelect:_foreignKey];<br>&gt; &gt;   }<br>&gt; &gt;   return _foreignObject;<br>&gt; &gt; }<br>&gt; &gt; <br>&gt; &gt; @end<br>&gt; &gt; <br>&gt; &gt; Unfortunately, the lazy keyword in Swift, which was supposed to make the lazy initialization pattern more concsive does not work in this case:<br>&gt; &gt; <br>&gt; &gt; class MyClass {<br>&gt; &gt;   var foreignKey: Int64 {<br>&gt; &gt;       didSet {<br>&gt; &gt;           self.foreignObject = nil<br>&gt; &gt;       }<br>&gt; &gt;   }<br>&gt; &gt; <br>&gt; &gt;   lazy var foreignObject: ForeignClass? = {<br>&gt; &gt;       return Database.expensiveSelect(self.foreignKey)<br>&gt; &gt;   }()<br>&gt; &gt; }<br>&gt; &gt; <br>&gt; &gt; I&#39;m forced to rewrite it this way:<br>&gt; &gt; <br>&gt; &gt; class MyClass {<br>&gt; &gt;   var foreignKey: Int64 {<br>&gt; &gt;       didSet {<br>&gt; &gt;           self.foreignObject = nil<br>&gt; &gt;       }<br>&gt; &gt;   }<br>&gt; &gt; <br>&gt; &gt;   private var _foreignObject: ForeignClass? = nil<br>&gt; &gt;   var foreignObject: ForeignClass? {<br>&gt; &gt;       if _foreignObject == nil {<br>&gt; &gt;           _foreignObject = Database.expensiveSelect(self.foreignKey)<br>&gt; &gt;       }<br>&gt; &gt;       return _foreignObject<br>&gt; &gt;   }<br>&gt; &gt; }<br>&gt; &gt; <br>&gt; &gt; When thinking about it, I came to the conclusion that the use cases of lazy seem very narrow compared to how useful the lazy initialization pattern was in Objective-C.<br>&gt; &gt; I want your opinion on three alternatives:<br>&gt; &gt; <br>&gt; &gt; 1- Do nothing, and use the slightly uglier Swift example when using a cache.<br>&gt; &gt; 2- Modify lazy semantics to re-calculates when nil (I think this is the worst solution).<br>&gt; &gt; 3- Add a cache modifier that re-calcualtes when nil.<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/f354edb3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>lazy keyword vs lazy initialization pattern</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December  4, 2015 at 04:00:00pm</p></header><div class="content"><p>AFAIK this behavior isn&#39;t actually documented anywhere, which means the<br>fact that it works at all is surprising. I&#39;m guessing it does this<br>because null_resettable properties are modeled as IUOs, but the fact<br>that it&#39;s not documented means I&#39;m leery of relying on it.<br></p><p>I&#39;d much rather that this didn&#39;t work, but that there was some syntax to<br>get access to the underlying storage of the lazy property so you can set<br>it to nil. Or alternatively that lazy properties actually had an<br>overloaded setter that accepted `nil` (or just a single setter that took<br>an optional, but I&#39;m not convinced that&#39;s a good idea), and then<br>null_resettable could be translated directly into a lazy property.<br>Though I still actually want access to the underlying storage because I<br>want to be able to test if the lazy property is already initialized<br>without having to make the initializer record that fact elsewhere.<br></p><p>-Kevin Ballard<br></p><p>On Fri, Dec 4, 2015, at 04:33 PM, Cameron Knight wrote:<br>&gt; Unless I&#39;m missing something, this should give you the results you are<br>&gt; looking for:<br>&gt;<br>&gt; class MyClass { var foreignKey: Int64 {        didSet {<br>&gt; self.foreignObject = nil        }    }<br>&gt;<br>&gt; lazy var foreignObject: ForeignClass! = {<br>&gt; returnDatabase.expensiveSelect(self.foreignKey)    }() }<br>&gt;<br>&gt; Using an Implicitly Unwrapped Optional instead of an Optional allows<br>&gt; you to set foreignObject to nil which will give you the same behavior<br>&gt; you use in Objective-C (a.k.a. null_resettable).<br>&gt;<br>&gt;<br>&gt;&gt; To me this actually feels more like something that might fit better<br>&gt;&gt; as an additional type of optional, rather than a language feature.<br></p><p>Setting this optional to nil could work normally, and any attempt to<br>access the value when nil would cause the reload to occur. The<br>initialization semantics might be a tad ugly though.<br></p><p>var myLazyOpt = ReloadingOptional&lt;ForeignClass&gt;({ return<br>Database.expensiveSelect(self.foreignKey) })<br></p><p>You could probably implement something like this yourself, though I&#39;m<br>not sure how elegant that would be without full language support.<br></p><p>Thanks for your time, Cole Kurkowski<br>&gt;* On Dec 4, 2015, at 07:40, David Hart &lt;david at hartbit.com[1]&gt; wrote:<br>*&gt;**&gt;* In Objective-C, I often used the lazy initialization pattern to<br>implement a cache for expensive operations. For exemple, here is an<br>often used scenario in a project where objects behind foreign keys in a<br>database ORM are only fetched when necessary: *&gt;**&gt;* @interface MyClass<br>: NSObject *&gt;**&gt;* @property (nonatomic) ForeignClass* foreignObject; *&gt;*<br>@property (nonatomic) int64_t foreignKey; *&gt;**&gt;* @end *&gt;**&gt;*<br>@implementation MyClass *&gt;**&gt;* - (void)setForeignKey:(int64_t)foreignKey<br>{ *&gt;*   _foreignKey = foreignKey; *&gt;*   _foreignObject = nil; *&gt;* }<br>*&gt;**&gt;* - (ForeignClass*)foreignObject { *&gt;*   if (!_foreignObject) { *&gt;*<br>_foreignObject = [Database expensiveSelect:_foreignKey]; *&gt;*   } *&gt;*<br>return _foreignObject; *&gt;* } *&gt;**&gt;* @end *&gt;**&gt;* Unfortunately, the lazy<br>keyword in Swift, which was supposed to make the lazy initialization<br>pattern more concsive does not work in this case: *&gt;**&gt;* class MyClass {<br>*&gt;*   var foreignKey: Int64 { *&gt;*       didSet { *&gt;*<br>self.foreignObject = nil *&gt;*       } *&gt;*   } *&gt;**&gt;*   lazy var<br>foreignObject: ForeignClass? = { *&gt;*       return<br>Database.expensiveSelect(self.foreignKey) *&gt;*   }() *&gt;* } *&gt;**&gt;* I&#39;m<br>forced to rewrite it this way: *&gt;**&gt;* class MyClass { *&gt;*   var<br>foreignKey: Int64 { *&gt;*       didSet { *&gt;*           self.foreignObject<br>= nil *&gt;*       } *&gt;*   } *&gt;**&gt;*   private var _foreignObject:<br>ForeignClass? = nil *&gt;*   var foreignObject: ForeignClass? { *&gt;*<br>if _foreignObject == nil { *&gt;*           _foreignObject =<br>Database.expensiveSelect(self.foreignKey) *&gt;*       } *&gt;*       return<br>_foreignObject *&gt;*   } *&gt;* } *&gt;**&gt;* When thinking about it, I came to<br>the conclusion that the use cases of lazy seem very narrow compared to<br>how useful the lazy initialization pattern was in Objective-C. *&gt;* I<br>want your opinion on three alternatives: *&gt;**&gt;* 1- Do nothing, and use<br>the slightly uglier Swift example when using a cache. *&gt;* 2- Modify lazy<br>semantics to re-calculates when nil (I think this is the worst<br>solution). *&gt;* 3- Add a cache modifier that re-calcualtes when nil. *&gt;*<br>_______________________________________________ *&gt;* swift-evolution<br>mailing list *&gt;*swift-evolution at swift.org[2]*&gt;*<br>https://lists.swift.org/mailman/listinfo/swift-evolution*<br>&gt;<br>&gt;<br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br></p><p>Links:<br></p><p>  1. https://lists.swift.org/mailman/listinfo/swift-evolution<br>  2. https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/e620baf4/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
