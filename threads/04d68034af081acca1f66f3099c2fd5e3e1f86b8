<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b2fc174169a3054f2e9bcb366884b02b?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>Fabian Ehrentraud</string> &lt;Fabian.Ehrentraud at willhaben.at&gt;<p>May 20, 2016 at 12:00:00pm</p></header><div class="content"><p>Hi,<br></p><p>there&#39;s been a little discussion about static vs. dynamic dispatch on this mailing list, and there is a good post about the pitfalls when using attributes defined in extensions [1].<br></p><p>Having run into this myself during development, is there a plan on how to reduce the pitfalls in future versions of Swift?<br></p><p>- Fabian<br></p><p><br>[1] https://developer.ibm.com/swift/2016/01/27/seven-swift-snares-how-to-avoid-them/<br></p><p><br>Sorry, I understand and appreciate your pragmatism. Right now it feels very much like a fight to the ideological death between POP and OOP and it may get really bad results this way.<br></p><p>Sent from my iPhone<br></p><p>On 4 Mar 2016, at 08:58, Brent Royal-Gordon &lt;brent at architechies.com&lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br></p><p>&gt;&gt; Brent, why is dynamic dispatching for protocol extension default implementations wrong in your mind? Wouldn&#39;t you agree that when static dispatching introduces such a side effect that it should not be automatically applied and perhaps a keyword should be added if you really wanted static dispatching nonetheless?<br>&gt;&gt;<br>&gt;&gt; I think that code execution should not be affected by type casting, it feels like a very confusing part of the language.<br>&gt;<br>&gt; I don&#39;t think dynamic dispatch is wrong; I think it&#39;s a large and technically challenging change. So in the spirit of incrementalism, I was trying to make cautious proposals which kept existing semantics intact but made them clearer, in preparation for perhaps eventually introducing dynamic dispatch. (Basically, I suggested that non-overridable protocol extension members should be marked `final` and it should be illegal to shadow them.)<br>&gt;<br>&gt; But the feedback I got indicated that most people wanted a more aggressive proposal which introduced dynamic dispatch immediately. That&#39;s much harder to propose because it touches on all sorts of runtime implementation details I know nothing about, so I didn&#39;t try to draft a proposal.<br>&gt;<br>&gt; (You are, perhaps inadvertently, currently demonstrating exactly what happened in those previous threads!)<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p><p><br>&gt; On Dec 11, 2015, at 8:56 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;<br>&gt; You think that Swift prefers virtual dispatch. I think it prefers static.<br>&gt;<br>&gt; I think what&#39;s really going on here is that _in most cases_ there&#39;s no observable difference between static dispatch and virtual dispatch. If you think of Swift as an OOP language with a powerful value-typed system added on, then you&#39;ll probably think Swift prefers virtual dispatch. If you think of Swift as a value-typed language with an OOP layer added, then you&#39;ll probably think Swift prefers static dispatch. In reality, Swift is a hybrid language and it uses different types of dispatch in different situations as appropriate.<br></p><p>(emphasis mine)<br></p><p>I know that this is a bit philosophical, but let me suggest a “next level down” way to look at this.  Static and dynamic are *both* great after all, and if you’re looking to type-cast languages, you need to consider them both in light of their semantics, but also factor in their compilation strategy and the programmer model that they all provide.  Let me give you some examples, but keep in mind that this is a narrow view and just MHO:<br></p><p>1. C: Static compilation model, static semantics.  While it does provide indirect function pointers, C does everything possible to punish their use (ever see the non-typedef&#39;d prototype for signal(3/7)?), and is almost always statically compiled.  It provides a very “static centric” programming model.  This is great in terms of predictability - it makes it trivial to “predict” what your code will look like at a machine level.<br></p><p>2. Javascript: Completely dynamic compilation model, completely dynamic semantics.  No one talks about statically compiling javascript, because the result of doing so would be a really really slow executable.  Javascript performance hinges on dynamic profile information to be able to efficiently execute a program.  This provides a very “dynamic centric” programming model, with no ability to understand how your code executes at a machine level.<br></p><p>3. C++: C++ is a step up from C in terms of introducing dynamism into the model with virtual functions.   Sadly, C++ also provides a hostile model for static optimizability - the existence of placement new prevents a lot of interesting devirtualization opportunities, and generally makes the compiler’s life difficult.  OTOH, like C, C++ provides a very predictable model: C++ programmers assume that C constructs are static, but virtual methods will be dynamically dispatched.  This is correct because (except for narrow cases) the compiler has to use dynamic dispatch for C++ virtual methods.   The good news here is that its dynamism is completely opt in, so C++ preserves all of the predictability, performance, and static-compilability of C while providing a higher level programming model.  If virtual methods are ever actually a performance problem, a C++ programmer has ways to deal with that, directly in their code.<br></p><p>4. Java: Java makes nearly &quot;everything&quot; an object (no structs or other non-primitive value types), and all methods default to being “virtual” (in the C++ sense).  Java also introduces interfaces, which offer an added dimension on dynamic dispatch.  To cope with this, Java assumes a JIT compilation model, which can use dynamic behavior to de-virtualize the (almost always) monomorphic calls into checked direct calls.  This works out really well in practice, because JIT compilers are great at telling when a program with apparently very dynamic semantics actually have static semantics in practice (e.g. a dynamic call has a single receiver).  OTOH, since the compilation model assumes a JIT, this means that purely “AOT” static compilers (which have no profile information, no knowledge of class loaders, etc) necessarily produce inferior code.  It also means that Java doesn’t “scale down” well to small embedded systems that can’t support a JIT, like a bootloader.<br></p><p>5) Objective-C: Objective-C provides a hybrid model which favors predictability due to its static compilation model (similar in some ways to C++).  The C-like constructs provide C-like performance, and the “messaging” constructs are never “devirtualized”, so they provide very predictable performance characteristics.  Because it is predictable, if the cost of a message send ever becomes an issue in practice, the programmer has many patterns to deal with it (including &quot;imp caching&quot;, and also including the ability to define the problem away by rewriting code in terms of C constructs).  The end result of this is that programmers write code which use C-level features where performance matters and dynamicism doesn’t, but use ObjC features where dynamicism is important or where performance doesn’t matter.<br></p><p>While it would be possible to implement a JIT compiler for ObjC, I’d expect the wins to be low, because the “hot” code which may be hinging on these dynamic features is likely to already be optimized by hand.<br></p><p>6) GoLang: From this narrow discussion and perspective, Go has a hybrid model that has similar characteristics to Objective-C 2013 (which introduced modules, but didn’t yet have generics).  It assumes static compilation and provides a very predictable hybrid programming model.  Its func’s are statically dispatched, but its interfaces are dynamically dispatched.  It doesn’t provide guaranteed dynamic dispatch (or “classes&quot;) like ObjC, but it provides even more dynamic feautres in other areas (e.g. it requires a cycle-collecting garbage collector).  Its &quot;interface{}” type is pretty equivalent to “id” (e.g. all uses of it are dynamically dispatched or must be downcasted), and it encourages use of it in the same places that Objective-C does.  Go introduces checked downcasts, which introduce some run-time overhead, but also provide safety compared to Objective-C. Go thankfully introduces a replacement for the imperative constructs in C, which defines away a bunch of C problems that Objective-C inherited, and it certainly is prettier!<br></p><p>… I can go on about other languages, but I have probably already gotten myself into enough trouble. :-)<br></p><p><br>With this as context, lets talk about Swift:<br></p><p>Swift is another case of a hybrid model: its semantics provide predictability between obviously static (structs, enums, and global funcs) and obviously dynamic (classes, protocols, and closures) constructs.  A focus of Swift (like Java and Javascript) is to provide an apparently simple programming model.  However, Swift also intentionally &quot;cheats&quot; in its global design by mixing in a few tricks to make the dynamic parts of the language optimizable by a static compiler in many common cases, without requiring profiling or other dynamic information..  For example, the Swift compiler can tell if methods in non-public classes are never overridden (and non-public is the default, for a lot of good reasons) - thus treating them as final.  This allows eliminating much of the overhead of dynamic dispatch without requiring a JIT.  Consider an “app”: because it never needs to have non-public classes, this is incredibly powerful - the design of the swift package manager extends this even further (in principle, not done yet) to external libraries. Further, Swift’s generics provide an a static performance model similar to C++ templates in release builds (though I agree we need to do more to really follow through on this) -- while Swift existentials (values of protocol type) provide a balance by giving a highly dynamic model.<br></p><p>The upshot of this is that Swift isn’t squarely in either of the static or dynamic camps: it aims to provide a very predictable performance model (someone writing a bootloader or firmware can stick to using Swift structs and have a simple guarantee of no dynamic overhead or runtime dependence) while also providing an expressive and clean high level programming model - simplifying learning and the common case where programmers don’t care to count cycles.  If anything, I’d say that Swift is an “opportunistic” language, in that it provides a very dynamic “default&quot; programming model, where you don’t have to think about the fact that a static compiler is able to transparently provide great performance - without needing the overhead of a JIT.<br></p><p>Finally, while it is possible that a JIT compiler might be interesting someday in the Swift space, if we do things right, it will never be “worth it” because programmers will have enough ability to reason about performance at their fingertips.  This means that there should be no Java or Javascript-magnitude &quot;performance delta&quot; sitting on the table waiting for a JIT to scoop up.  We’ll see how it works out long term, but I think we’re doing pretty well so far.<br></p><p>TL;DR: What I’m really getting at is that the old static vs dynamic trope is at the very least only half of the story.  You really need to include the compilation model and thus the resultant programmer model into the story, and the programmer model is what really matters, IMHO.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/04d686b8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 20, 2016 at 06:00:00pm</p></header><div class="content"><p>Regards<br>(From mobile)<br></p><p>&gt; On May 20, 2016, at 2:56 PM, Fabian Ehrentraud via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi,<br>&gt; <br>&gt; there&#39;s been a little discussion about static vs. dynamic dispatch on this mailing list, and there is a good post about the pitfalls when using attributes defined in extensions [1].<br>&gt; <br>&gt; Having run into this myself during development, is there a plan on how to reduce the pitfalls in future versions of Swift?<br>&gt; <br>&gt; - Fabian<br>&gt; <br>&gt; <br>&gt; [1] https://developer.ibm.com/swift/2016/01/27/seven-swift-snares-how-to-avoid-them/<br>&gt; <br>&gt;&gt; Sorry, I understand and appreciate your pragmatism. Right now it feels very much like a fight to the ideological death between POP and OOP and it may get really bad results this way.<br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt; On 4 Mar 2016, at 08:58, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt;&gt; Brent, why is dynamic dispatching for protocol extension default implementations wrong in your mind? Wouldn&#39;t you agree that when static dispatching introduces such a side effect that it should not be automatically applied and perhaps a keyword should be added if you really wanted static dispatching nonetheless?<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; I think that code execution should not be affected by type casting, it feels like a very confusing part of the language.<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; I don&#39;t think dynamic dispatch is wrong; I think it&#39;s a large and technically challenging change. So in the spirit of incrementalism, I was trying to make cautious proposals which kept existing semantics intact but made them clearer, in preparation for perhaps eventually introducing dynamic dispatch. (Basically, I suggested that non-overridable protocol extension members should be marked `final` and it should be illegal to shadow them.)<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; But the feedback I got indicated that most people wanted a more aggressive proposal which introduced dynamic dispatch immediately. That&#39;s much harder to propose because it touches on all sorts of runtime implementation details I know nothing about, so I didn&#39;t try to draft a proposal.<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; (You are, perhaps inadvertently, currently demonstrating exactly what happened in those previous threads!)<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; -- <br>&gt;&gt; &gt; Brent Royal-Gordon<br>&gt;&gt; &gt; Architechies<br>&gt;&gt; &gt; <br>&gt; <br>&gt;&gt; &gt; On Dec 11, 2015, at 8:56 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; You think that Swift prefers virtual dispatch. I think it prefers static.<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; I think what&#39;s really going on here is that _in most cases_ there&#39;s no observable difference between static dispatch and virtual dispatch. If you think of Swift as an OOP language with a powerful value-typed system added on, then you&#39;ll probably think Swift prefers virtual dispatch. If you think of Swift as a value-typed language with an OOP layer added, then you&#39;ll probably think Swift prefers static dispatch. In reality, Swift is a hybrid language and it uses different types of dispatch in different situations as appropriate.<br>&gt;&gt; <br>&gt;&gt; (emphasis mine)<br>&gt;&gt; <br>&gt;&gt; I know that this is a bit philosophical, but let me suggest a “next level down” way to look at this.  Static and dynamic are *both* great after all, and if you’re looking to type-cast languages, you need to consider them both in light of their semantics, but also factor in their compilation strategy and the programmer model that they all provide.  Let me give you some examples, but keep in mind that this is a narrow view and just MHO:<br>&gt;&gt; <br>&gt;&gt; 1. C: Static compilation model, static semantics.  While it does provide indirect function pointers, C does everything possible to punish their use (ever see the non-typedef&#39;d prototype for signal(3/7)?), and is almost always statically compiled.  It provides a very “static centric” programming model.  This is great in terms of predictability - it makes it trivial to “predict” what your code will look like at a machine level.<br>&gt;&gt; <br>&gt;&gt; 2. Javascript: Completely dynamic compilation model, completely dynamic semantics.  No one talks about statically compiling javascript, because the result of doing so would be a really really slow executable.  Javascript performance hinges on dynamic profile information to be able to efficiently execute a program.  This provides a very “dynamic centric” programming model, with no ability to understand how your code executes at a machine level.<br>&gt;&gt; <br>&gt;&gt; 3. C++: C++ is a step up from C in terms of introducing dynamism into the model with virtual functions.   Sadly, C++ also provides a hostile model for static optimizability - the existence of placement new prevents a lot of interesting devirtualization opportunities, and generally makes the compiler’s life difficult.  OTOH, like C, C++ provides a very predictable model: C++ programmers assume that C constructs are static, but virtual methods will be dynamically dispatched.  This is correct because (except for narrow cases) the compiler has to use dynamic dispatch for C++ virtual methods.   The good news here is that its dynamism is completely opt in, so C++ preserves all of the predictability, performance, and static-compilability of C while providing a higher level programming model.  If virtual methods are ever actually a performance problem, a C++ programmer has ways to deal with that, directly in their code.<br>Cpp templates were the promise that by trading longer compiler time, we would be able to produce c-like performing code while coding with the flexibility of virtual dispatch. There are some great debates on whether or not the compilers actually deliver it.<br></p><p><br>&gt;&gt; 4. Java: Java makes nearly &quot;everything&quot; an object (no structs or other non-primitive value types), and all methods default to being “virtual” (in the C++ sense).  Java also introduces interfaces, which offer an added dimension on dynamic dispatch.  To cope with this, Java assumes a JIT compilation model, which can use dynamic behavior to de-virtualize the (almost always) monomorphic calls into checked direct calls.  This works out really well in practice, because JIT compilers are great at telling when a program with apparently very dynamic semantics actually have static semantics in practice (e.g. a dynamic call has a single receiver).  OTOH, since the compilation model assumes a JIT, this means that purely “AOT” static compilers (which have no profile information, no knowledge of class loaders, etc) necessarily produce inferior code.  It also means that Java doesn’t “scale down” well to small embedded systems that can’t support a JIT, like a bootloader.<br>Java the following calling conventions<br>Invokespecial: constructors<br>Invokestatic: static methods. Need to resolve (heuristic is static)<br>Invokevirtual: obj type methods. Need to resolve (static heuristic)<br>Invokeinterface: iface type methods. Needs to resolve (static heuristic)<br>Invokedynamic: indy is special because the resolution heuristic is user customizable and even reversible at runtime (user code can rewrite the behavior of a callsite) all the while being highly optimized inside the jit compiler (lambdas use it &amp; jdk9 will optimize string concats with it). this is a huge improvement in jvms.<br></p><p>Graal is a upcoming(?) jit implemented in java that supports more agressive per call site optimizations (like same target code inlined differently depending on callsite behavior, including optimistic type specializations per code paths, all reversible). It is a promissing long term solution for the megamorphic callsite performance cliff problem in the jvm.<br>&gt;&gt; 5) Objective-C: Objective-C provides a hybrid model which favors predictability due to its static compilation model (similar in some ways to C++).  The C-like constructs provide C-like performance, and the “messaging” constructs are never “devirtualized”, so they provide very predictable performance characteristics.  Because it is predictable, if the cost of a message send ever becomes an issue in practice, the programmer has many patterns to deal with it (including &quot;imp caching&quot;, and also including the ability to define the problem away by rewriting code in terms of C constructs).  The end result of this is that programmers write code which use C-level features where performance matters and dynamicism doesn’t, but use ObjC features where dynamicism is important or where performance doesn’t matter.<br>&gt;&gt; <br>&gt;&gt; While it would be possible to implement a JIT compiler for ObjC, I’d expect the wins to be low, because the “hot” code which may be hinging on these dynamic features is likely to already be optimized by hand.<br>&gt;&gt; <br>&gt;&gt; 6) GoLang: From this narrow discussion and perspective, Go has a hybrid model that has similar characteristics to Objective-C 2013 (which introduced modules, but didn’t yet have generics).  It assumes static compilation and provides a very predictable hybrid programming model.  Its func’s are statically dispatched, but its interfaces are dynamically dispatched.  It doesn’t provide guaranteed dynamic dispatch (or “classes&quot;) like ObjC, but it provides even more dynamic feautres in other areas (e.g. it requires a cycle-collecting garbage collector).  Its &quot;interface{}” type is pretty equivalent to “id” (e.g. all uses of it are dynamically dispatched or must be downcasted), and it encourages use of it in the same places that Objective-C does.  Go introduces checked downcasts, which introduce some run-time overhead, but also provide safety compared to Objective-C. Go thankfully introduces a replacement for the imperative constructs in C, which defines away a bunch of C problems that Objective-C inherited, and it certainly is prettier!<br>&gt;&gt; <br>Scala is another of these interesting animals where the compiler is working super hard to try to produce magic-free runtime code (i.e. no extra lookup other then the jvm&#39;s)... not the case yet (the llvm scala backend is interesting though).<br></p><p><br>&gt;&gt; … I can go on about other languages, but I have probably already gotten myself into enough trouble. :-)<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; With this as context, lets talk about Swift:<br>&gt;&gt; <br>&gt;&gt; Swift is another case of a hybrid model: its semantics provide predictability between obviously static (structs, enums, and global funcs) and obviously dynamic (classes, protocols, and closures) constructs.  A focus of Swift (like Java and Javascript) is to provide an apparently simple programming model.  However, Swift also intentionally &quot;cheats&quot; in its global design by mixing in a few tricks to make the dynamic parts of the language optimizable by a static compiler in many common cases, without requiring profiling or other dynamic information..  For example, the Swift compiler can tell if methods in non-public classes are never overridden (and non-public is the default, for a lot of good reasons) - thus treating them as final.  This allows eliminating much of the overhead of dynamic dispatch without requiring a JIT.  Consider an “app”: because it never needs to have non-public classes, this is incredibly powerful - the design of the swift package manager extends this even further (in principle, not done yet) to external libraries. Further, Swift’s generics provide an a static performance model similar to C++ templates in release builds (though I agree we need to do more to really follow through on this) -- while Swift existentials (values of protocol type) provide a balance by giving a highly dynamic model.<br>&gt;&gt; <br>&gt;&gt; The upshot of this is that Swift isn’t squarely in either of the static or dynamic camps: it aims to provide a very predictable performance model (someone writing a bootloader or firmware can stick to using Swift structs and have a simple guarantee of no dynamic overhead or runtime dependence) while also providing an expressive and clean high level programming model - simplifying learning and the common case where programmers don’t care to count cycles.  If anything, I’d say that Swift is an “opportunistic” language, in that it provides a very dynamic “default&quot; programming model, where you don’t have to think about the fact that a static compiler is able to transparently provide great performance - without needing the overhead of a JIT.<br>&gt;&gt; <br>&gt;&gt; Finally, while it is possible that a JIT compiler might be interesting someday in the Swift space, if we do things right, it will never be “worth it” because programmers will have enough ability to reason about performance at their fingertips.  This means that there should be no Java or Javascript-magnitude &quot;performance delta&quot; sitting on the table waiting for a JIT to scoop up.  We’ll see how it works out long term, but I think we’re doing pretty well so far.<br>&gt;&gt; <br>&gt;&gt; TL;DR: What I’m really getting at is that the old static vs dynamic trope is at the very least only half of the story.  You really need to include the compilation model and thus the resultant programmer model into the story, and the programmer model is what really matters, IMHO.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/63b6adf1/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 20, 2016 at 09:00:00am</p></header><div class="content"><p>I almost want to propose forbidding methods in protocol extensions unless they&#39;re also a requirement in the protocol itself, but I don&#39;t think that would fly.<br></p><p>Austin<br></p><p>&gt; On May 20, 2016, at 5:56 AM, Fabian Ehrentraud via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi,<br>&gt; <br>&gt; there&#39;s been a little discussion about static vs. dynamic dispatch on this mailing list, and there is a good post about the pitfalls when using attributes defined in extensions [1].<br>&gt; <br>&gt; Having run into this myself during development, is there a plan on how to reduce the pitfalls in future versions of Swift?<br>&gt; <br>&gt; - Fabian<br>&gt; <br>&gt; <br>&gt; [1] https://developer.ibm.com/swift/2016/01/27/seven-swift-snares-how-to-avoid-them/ &lt;https://developer.ibm.com/swift/2016/01/27/seven-swift-snares-how-to-avoid-them/&gt;<br>&gt; <br>&gt;&gt; Sorry, I understand and appreciate your pragmatism. Right now it feels very much like a fight to the ideological death between POP and OOP and it may get really bad results this way.<br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt; On 4 Mar 2016, at 08:58, Brent Royal-Gordon &lt;brent at architechies.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt;&gt; Brent, why is dynamic dispatching for protocol extension default implementations wrong in your mind? Wouldn&#39;t you agree that when static dispatching introduces such a side effect that it should not be automatically applied and perhaps a keyword should be added if you really wanted static dispatching nonetheless?<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; I think that code execution should not be affected by type casting, it feels like a very confusing part of the language.<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; I don&#39;t think dynamic dispatch is wrong; I think it&#39;s a large and technically challenging change. So in the spirit of incrementalism, I was trying to make cautious proposals which kept existing semantics intact but made them clearer, in preparation for perhaps eventually introducing dynamic dispatch. (Basically, I suggested that non-overridable protocol extension members should be marked `final` and it should be illegal to shadow them.)<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; But the feedback I got indicated that most people wanted a more aggressive proposal which introduced dynamic dispatch immediately. That&#39;s much harder to propose because it touches on all sorts of runtime implementation details I know nothing about, so I didn&#39;t try to draft a proposal.<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; (You are, perhaps inadvertently, currently demonstrating exactly what happened in those previous threads!)<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; -- <br>&gt;&gt; &gt; Brent Royal-Gordon<br>&gt;&gt; &gt; Architechies<br>&gt;&gt; &gt; <br>&gt; <br>&gt;&gt; &gt; On Dec 11, 2015, at 8:56 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; You think that Swift prefers virtual dispatch. I think it prefers static.<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; I think what&#39;s really going on here is that _in most cases_ there&#39;s no observable difference between static dispatch and virtual dispatch. If you think of Swift as an OOP language with a powerful value-typed system added on, then you&#39;ll probably think Swift prefers virtual dispatch. If you think of Swift as a value-typed language with an OOP layer added, then you&#39;ll probably think Swift prefers static dispatch. In reality, Swift is a hybrid language and it uses different types of dispatch in different situations as appropriate.<br>&gt;&gt; <br>&gt;&gt; (emphasis mine)<br>&gt;&gt; <br>&gt;&gt; I know that this is a bit philosophical, but let me suggest a “next level down” way to look at this.  Static and dynamic are *both* great after all, and if you’re looking to type-cast languages, you need to consider them both in light of their semantics, but also factor in their compilation strategy and the programmer model that they all provide.  Let me give you some examples, but keep in mind that this is a narrow view and just MHO:<br>&gt;&gt; <br>&gt;&gt; 1. C: Static compilation model, static semantics.  While it does provide indirect function pointers, C does everything possible to punish their use (ever see the non-typedef&#39;d prototype for signal(3/7)?), and is almost always statically compiled.  It provides a very “static centric” programming model.  This is great in terms of predictability - it makes it trivial to “predict” what your code will look like at a machine level.<br>&gt;&gt; <br>&gt;&gt; 2. Javascript: Completely dynamic compilation model, completely dynamic semantics.  No one talks about statically compiling javascript, because the result of doing so would be a really really slow executable.  Javascript performance hinges on dynamic profile information to be able to efficiently execute a program.  This provides a very “dynamic centric” programming model, with no ability to understand how your code executes at a machine level.<br>&gt;&gt; <br>&gt;&gt; 3. C++: C++ is a step up from C in terms of introducing dynamism into the model with virtual functions.   Sadly, C++ also provides a hostile model for static optimizability - the existence of placement new prevents a lot of interesting devirtualization opportunities, and generally makes the compiler’s life difficult.  OTOH, like C, C++ provides a very predictable model: C++ programmers assume that C constructs are static, but virtual methods will be dynamically dispatched.  This is correct because (except for narrow cases) the compiler has to use dynamic dispatch for C++ virtual methods.   The good news here is that its dynamism is completely opt in, so C++ preserves all of the predictability, performance, and static-compilability of C while providing a higher level programming model.  If virtual methods are ever actually a performance problem, a C++ programmer has ways to deal with that, directly in their code.<br>&gt;&gt; <br>&gt;&gt; 4. Java: Java makes nearly &quot;everything&quot; an object (no structs or other non-primitive value types), and all methods default to being “virtual” (in the C++ sense).  Java also introduces interfaces, which offer an added dimension on dynamic dispatch.  To cope with this, Java assumes a JIT compilation model, which can use dynamic behavior to de-virtualize the (almost always) monomorphic calls into checked direct calls.  This works out really well in practice, because JIT compilers are great at telling when a program with apparently very dynamic semantics actually have static semantics in practice (e.g. a dynamic call has a single receiver).  OTOH, since the compilation model assumes a JIT, this means that purely “AOT” static compilers (which have no profile information, no knowledge of class loaders, etc) necessarily produce inferior code.  It also means that Java doesn’t “scale down” well to small embedded systems that can’t support a JIT, like a bootloader.<br>&gt;&gt; <br>&gt;&gt; 5) Objective-C: Objective-C provides a hybrid model which favors predictability due to its static compilation model (similar in some ways to C++).  The C-like constructs provide C-like performance, and the “messaging” constructs are never “devirtualized”, so they provide very predictable performance characteristics.  Because it is predictable, if the cost of a message send ever becomes an issue in practice, the programmer has many patterns to deal with it (including &quot;imp caching&quot;, and also including the ability to define the problem away by rewriting code in terms of C constructs).  The end result of this is that programmers write code which use C-level features where performance matters and dynamicism doesn’t, but use ObjC features where dynamicism is important or where performance doesn’t matter.<br>&gt;&gt; <br>&gt;&gt; While it would be possible to implement a JIT compiler for ObjC, I’d expect the wins to be low, because the “hot” code which may be hinging on these dynamic features is likely to already be optimized by hand.<br>&gt;&gt; <br>&gt;&gt; 6) GoLang: From this narrow discussion and perspective, Go has a hybrid model that has similar characteristics to Objective-C 2013 (which introduced modules, but didn’t yet have generics).  It assumes static compilation and provides a very predictable hybrid programming model.  Its func’s are statically dispatched, but its interfaces are dynamically dispatched.  It doesn’t provide guaranteed dynamic dispatch (or “classes&quot;) like ObjC, but it provides even more dynamic feautres in other areas (e.g. it requires a cycle-collecting garbage collector).  Its &quot;interface{}” type is pretty equivalent to “id” (e.g. all uses of it are dynamically dispatched or must be downcasted), and it encourages use of it in the same places that Objective-C does.  Go introduces checked downcasts, which introduce some run-time overhead, but also provide safety compared to Objective-C. Go thankfully introduces a replacement for the imperative constructs in C, which defines away a bunch of C problems that Objective-C inherited, and it certainly is prettier!<br>&gt;&gt; <br>&gt;&gt; … I can go on about other languages, but I have probably already gotten myself into enough trouble. :-)<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; With this as context, lets talk about Swift:<br>&gt;&gt; <br>&gt;&gt; Swift is another case of a hybrid model: its semantics provide predictability between obviously static (structs, enums, and global funcs) and obviously dynamic (classes, protocols, and closures) constructs.  A focus of Swift (like Java and Javascript) is to provide an apparently simple programming model.  However, Swift also intentionally &quot;cheats&quot; in its global design by mixing in a few tricks to make the dynamic parts of the language optimizable by a static compiler in many common cases, without requiring profiling or other dynamic information..  For example, the Swift compiler can tell if methods in non-public classes are never overridden (and non-public is the default, for a lot of good reasons) - thus treating them as final.  This allows eliminating much of the overhead of dynamic dispatch without requiring a JIT.  Consider an “app”: because it never needs to have non-public classes, this is incredibly powerful - the design of the swift package manager extends this even further (in principle, not done yet) to external libraries. Further, Swift’s generics provide an a static performance model similar to C++ templates in release builds (though I agree we need to do more to really follow through on this) -- while Swift existentials (values of protocol type) provide a balance by giving a highly dynamic model.<br>&gt;&gt; <br>&gt;&gt; The upshot of this is that Swift isn’t squarely in either of the static or dynamic camps: it aims to provide a very predictable performance model (someone writing a bootloader or firmware can stick to using Swift structs and have a simple guarantee of no dynamic overhead or runtime dependence) while also providing an expressive and clean high level programming model - simplifying learning and the common case where programmers don’t care to count cycles.  If anything, I’d say that Swift is an “opportunistic” language, in that it provides a very dynamic “default&quot; programming model, where you don’t have to think about the fact that a static compiler is able to transparently provide great performance - without needing the overhead of a JIT.<br>&gt;&gt; <br>&gt;&gt; Finally, while it is possible that a JIT compiler might be interesting someday in the Swift space, if we do things right, it will never be “worth it” because programmers will have enough ability to reason about performance at their fingertips.  This means that there should be no Java or Javascript-magnitude &quot;performance delta&quot; sitting on the table waiting for a JIT to scoop up.  We’ll see how it works out long term, but I think we’re doing pretty well so far.<br>&gt;&gt; <br>&gt;&gt; TL;DR: What I’m really getting at is that the old static vs dynamic trope is at the very least only half of the story.  You really need to include the compilation model and thus the resultant programmer model into the story, and the programmer model is what really matters, IMHO.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/d416d478/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 20, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On May 20, 2016, at 11:17 AM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I almost want to propose forbidding methods in protocol extensions unless they&#39;re also a requirement in the protocol itself, but I don&#39;t think that would fly.<br></p><p>That would prevent us from adding extension methods to protocols declared in modules we depend on.  This is way to useful to throw away.<br></p><p>&gt; <br>&gt; Austin<br>&gt; <br>&gt;&gt; On May 20, 2016, at 5:56 AM, Fabian Ehrentraud via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi,<br>&gt;&gt; <br>&gt;&gt; there&#39;s been a little discussion about static vs. dynamic dispatch on this mailing list, and there is a good post about the pitfalls when using attributes defined in extensions [1].<br>&gt;&gt; <br>&gt;&gt; Having run into this myself during development, is there a plan on how to reduce the pitfalls in future versions of Swift?<br>&gt;&gt; <br>&gt;&gt; - Fabian<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; [1] https://developer.ibm.com/swift/2016/01/27/seven-swift-snares-how-to-avoid-them/ &lt;https://developer.ibm.com/swift/2016/01/27/seven-swift-snares-how-to-avoid-them/&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; Sorry, I understand and appreciate your pragmatism. Right now it feels very much like a fight to the ideological death between POP and OOP and it may get really bad results this way.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 4 Mar 2016, at 08:58, Brent Royal-Gordon &lt;brent at architechies.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt;&gt; Brent, why is dynamic dispatching for protocol extension default implementations wrong in your mind? Wouldn&#39;t you agree that when static dispatching introduces such a side effect that it should not be automatically applied and perhaps a keyword should be added if you really wanted static dispatching nonetheless?<br>&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt; &gt;&gt; I think that code execution should not be affected by type casting, it feels like a very confusing part of the language.<br>&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt; &gt; I don&#39;t think dynamic dispatch is wrong; I think it&#39;s a large and technically challenging change. So in the spirit of incrementalism, I was trying to make cautious proposals which kept existing semantics intact but made them clearer, in preparation for perhaps eventually introducing dynamic dispatch. (Basically, I suggested that non-overridable protocol extension members should be marked `final` and it should be illegal to shadow them.)<br>&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt; &gt; But the feedback I got indicated that most people wanted a more aggressive proposal which introduced dynamic dispatch immediately. That&#39;s much harder to propose because it touches on all sorts of runtime implementation details I know nothing about, so I didn&#39;t try to draft a proposal.<br>&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt; &gt; (You are, perhaps inadvertently, currently demonstrating exactly what happened in those previous threads!)<br>&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt; &gt; -- <br>&gt;&gt;&gt; &gt; Brent Royal-Gordon<br>&gt;&gt;&gt; &gt; Architechies<br>&gt;&gt;&gt; &gt; <br>&gt;&gt; <br>&gt;&gt;&gt; &gt; On Dec 11, 2015, at 8:56 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt; &gt; You think that Swift prefers virtual dispatch. I think it prefers static.<br>&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt; &gt; I think what&#39;s really going on here is that _in most cases_ there&#39;s no observable difference between static dispatch and virtual dispatch. If you think of Swift as an OOP language with a powerful value-typed system added on, then you&#39;ll probably think Swift prefers virtual dispatch. If you think of Swift as a value-typed language with an OOP layer added, then you&#39;ll probably think Swift prefers static dispatch. In reality, Swift is a hybrid language and it uses different types of dispatch in different situations as appropriate.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (emphasis mine)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I know that this is a bit philosophical, but let me suggest a “next level down” way to look at this.  Static and dynamic are *both* great after all, and if you’re looking to type-cast languages, you need to consider them both in light of their semantics, but also factor in their compilation strategy and the programmer model that they all provide.  Let me give you some examples, but keep in mind that this is a narrow view and just MHO:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. C: Static compilation model, static semantics.  While it does provide indirect function pointers, C does everything possible to punish their use (ever see the non-typedef&#39;d prototype for signal(3/7)?), and is almost always statically compiled.  It provides a very “static centric” programming model.  This is great in terms of predictability - it makes it trivial to “predict” what your code will look like at a machine level.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2. Javascript: Completely dynamic compilation model, completely dynamic semantics.  No one talks about statically compiling javascript, because the result of doing so would be a really really slow executable.  Javascript performance hinges on dynamic profile information to be able to efficiently execute a program.  This provides a very “dynamic centric” programming model, with no ability to understand how your code executes at a machine level.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 3. C++: C++ is a step up from C in terms of introducing dynamism into the model with virtual functions.   Sadly, C++ also provides a hostile model for static optimizability - the existence of placement new prevents a lot of interesting devirtualization opportunities, and generally makes the compiler’s life difficult.  OTOH, like C, C++ provides a very predictable model: C++ programmers assume that C constructs are static, but virtual methods will be dynamically dispatched.  This is correct because (except for narrow cases) the compiler has to use dynamic dispatch for C++ virtual methods.   The good news here is that its dynamism is completely opt in, so C++ preserves all of the predictability, performance, and static-compilability of C while providing a higher level programming model.  If virtual methods are ever actually a performance problem, a C++ programmer has ways to deal with that, directly in their code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 4. Java: Java makes nearly &quot;everything&quot; an object (no structs or other non-primitive value types), and all methods default to being “virtual” (in the C++ sense).  Java also introduces interfaces, which offer an added dimension on dynamic dispatch.  To cope with this, Java assumes a JIT compilation model, which can use dynamic behavior to de-virtualize the (almost always) monomorphic calls into checked direct calls.  This works out really well in practice, because JIT compilers are great at telling when a program with apparently very dynamic semantics actually have static semantics in practice (e.g. a dynamic call has a single receiver).  OTOH, since the compilation model assumes a JIT, this means that purely “AOT” static compilers (which have no profile information, no knowledge of class loaders, etc) necessarily produce inferior code.  It also means that Java doesn’t “scale down” well to small embedded systems that can’t support a JIT, like a bootloader.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 5) Objective-C: Objective-C provides a hybrid model which favors predictability due to its static compilation model (similar in some ways to C++).  The C-like constructs provide C-like performance, and the “messaging” constructs are never “devirtualized”, so they provide very predictable performance characteristics.  Because it is predictable, if the cost of a message send ever becomes an issue in practice, the programmer has many patterns to deal with it (including &quot;imp caching&quot;, and also including the ability to define the problem away by rewriting code in terms of C constructs).  The end result of this is that programmers write code which use C-level features where performance matters and dynamicism doesn’t, but use ObjC features where dynamicism is important or where performance doesn’t matter.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; While it would be possible to implement a JIT compiler for ObjC, I’d expect the wins to be low, because the “hot” code which may be hinging on these dynamic features is likely to already be optimized by hand.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 6) GoLang: From this narrow discussion and perspective, Go has a hybrid model that has similar characteristics to Objective-C 2013 (which introduced modules, but didn’t yet have generics).  It assumes static compilation and provides a very predictable hybrid programming model.  Its func’s are statically dispatched, but its interfaces are dynamically dispatched.  It doesn’t provide guaranteed dynamic dispatch (or “classes&quot;) like ObjC, but it provides even more dynamic feautres in other areas (e.g. it requires a cycle-collecting garbage collector).  Its &quot;interface{}” type is pretty equivalent to “id” (e.g. all uses of it are dynamically dispatched or must be downcasted), and it encourages use of it in the same places that Objective-C does.  Go introduces checked downcasts, which introduce some run-time overhead, but also provide safety compared to Objective-C. Go thankfully introduces a replacement for the imperative constructs in C, which defines away a bunch of C problems that Objective-C inherited, and it certainly is prettier!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; … I can go on about other languages, but I have probably already gotten myself into enough trouble. :-)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; With this as context, lets talk about Swift:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift is another case of a hybrid model: its semantics provide predictability between obviously static (structs, enums, and global funcs) and obviously dynamic (classes, protocols, and closures) constructs.  A focus of Swift (like Java and Javascript) is to provide an apparently simple programming model.  However, Swift also intentionally &quot;cheats&quot; in its global design by mixing in a few tricks to make the dynamic parts of the language optimizable by a static compiler in many common cases, without requiring profiling or other dynamic information..  For example, the Swift compiler can tell if methods in non-public classes are never overridden (and non-public is the default, for a lot of good reasons) - thus treating them as final.  This allows eliminating much of the overhead of dynamic dispatch without requiring a JIT.  Consider an “app”: because it never needs to have non-public classes, this is incredibly powerful - the design of the swift package manager extends this even further (in principle, not done yet) to external libraries. Further, Swift’s generics provide an a static performance model similar to C++ templates in release builds (though I agree we need to do more to really follow through on this) -- while Swift existentials (values of protocol type) provide a balance by giving a highly dynamic model.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The upshot of this is that Swift isn’t squarely in either of the static or dynamic camps: it aims to provide a very predictable performance model (someone writing a bootloader or firmware can stick to using Swift structs and have a simple guarantee of no dynamic overhead or runtime dependence) while also providing an expressive and clean high level programming model - simplifying learning and the common case where programmers don’t care to count cycles.  If anything, I’d say that Swift is an “opportunistic” language, in that it provides a very dynamic “default&quot; programming model, where you don’t have to think about the fact that a static compiler is able to transparently provide great performance - without needing the overhead of a JIT.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Finally, while it is possible that a JIT compiler might be interesting someday in the Swift space, if we do things right, it will never be “worth it” because programmers will have enough ability to reason about performance at their fingertips.  This means that there should be no Java or Javascript-magnitude &quot;performance delta&quot; sitting on the table waiting for a JIT to scoop up.  We’ll see how it works out long term, but I think we’re doing pretty well so far.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; TL;DR: What I’m really getting at is that the old static vs dynamic trope is at the very least only half of the story.  You really need to include the compilation model and thus the resultant programmer model into the story, and the programmer model is what really matters, IMHO.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/cc74cf23/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9ce70a6cb7175e7a5e5db5658186a31?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>Brandon Knope</string> &lt;bknope at me.com&gt;<p>May 20, 2016 at 12:00:00pm</p></header><div class="content"><p>From the compilers/runtimes perspective why couldn&#39;t the declaration automatically be included in the main protocol definition as if it was defined there?<br></p><p>Brandon <br></p><p>&gt; On May 20, 2016, at 12:21 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 20, 2016, at 11:17 AM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I almost want to propose forbidding methods in protocol extensions unless they&#39;re also a requirement in the protocol itself, but I don&#39;t think that would fly.<br>&gt; <br>&gt; That would prevent us from adding extension methods to protocols declared in modules we depend on.  This is way to useful to throw away.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Austin<br>&gt;&gt; <br>&gt;&gt;&gt; On May 20, 2016, at 5:56 AM, Fabian Ehrentraud via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; there&#39;s been a little discussion about static vs. dynamic dispatch on this mailing list, and there is a good post about the pitfalls when using attributes defined in extensions [1].<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Having run into this myself during development, is there a plan on how to reduce the pitfalls in future versions of Swift?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Fabian<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; [1] https://developer.ibm.com/swift/2016/01/27/seven-swift-snares-how-to-avoid-them/<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sorry, I understand and appreciate your pragmatism. Right now it feels very much like a fight to the ideological death between POP and OOP and it may get really bad results this way.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 4 Mar 2016, at 08:58, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt;&gt; Brent, why is dynamic dispatching for protocol extension default implementations wrong in your mind? Wouldn&#39;t you agree that when static dispatching introduces such a side effect that it should not be automatically applied and perhaps a keyword should be added if you really wanted static dispatching nonetheless?<br>&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt; &gt;&gt; I think that code execution should not be affected by type casting, it feels like a very confusing part of the language.<br>&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt; &gt; I don&#39;t think dynamic dispatch is wrong; I think it&#39;s a large and technically challenging change. So in the spirit of incrementalism, I was trying to make cautious proposals which kept existing semantics intact but made them clearer, in preparation for perhaps eventually introducing dynamic dispatch. (Basically, I suggested that non-overridable protocol extension members should be marked `final` and it should be illegal to shadow them.)<br>&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt; &gt; But the feedback I got indicated that most people wanted a more aggressive proposal which introduced dynamic dispatch immediately. That&#39;s much harder to propose because it touches on all sorts of runtime implementation details I know nothing about, so I didn&#39;t try to draft a proposal.<br>&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt; &gt; (You are, perhaps inadvertently, currently demonstrating exactly what happened in those previous threads!)<br>&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt; &gt; -- <br>&gt;&gt;&gt;&gt; &gt; Brent Royal-Gordon<br>&gt;&gt;&gt;&gt; &gt; Architechies<br>&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt; On Dec 11, 2015, at 8:56 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt; &gt; You think that Swift prefers virtual dispatch. I think it prefers static.<br>&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt; &gt; I think what&#39;s really going on here is that _in most cases_ there&#39;s no observable difference between static dispatch and virtual dispatch. If you think of Swift as an OOP language with a powerful value-typed system added on, then you&#39;ll probably think Swift prefers virtual dispatch. If you think of Swift as a value-typed language with an OOP layer added, then you&#39;ll probably think Swift prefers static dispatch. In reality, Swift is a hybrid language and it uses different types of dispatch in different situations as appropriate.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (emphasis mine)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I know that this is a bit philosophical, but let me suggest a “next level down” way to look at this.  Static and dynamic are *both* great after all, and if you’re looking to type-cast languages, you need to consider them both in light of their semantics, but also factor in their compilation strategy and the programmer model that they all provide.  Let me give you some examples, but keep in mind that this is a narrow view and just MHO:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. C: Static compilation model, static semantics.  While it does provide indirect function pointers, C does everything possible to punish their use (ever see the non-typedef&#39;d prototype for signal(3/7)?), and is almost always statically compiled.  It provides a very “static centric” programming model.  This is great in terms of predictability - it makes it trivial to “predict” what your code will look like at a machine level.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2. Javascript: Completely dynamic compilation model, completely dynamic semantics.  No one talks about statically compiling javascript, because the result of doing so would be a really really slow executable.  Javascript performance hinges on dynamic profile information to be able to efficiently execute a program.  This provides a very “dynamic centric” programming model, with no ability to understand how your code executes at a machine level.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 3. C++: C++ is a step up from C in terms of introducing dynamism into the model with virtual functions.   Sadly, C++ also provides a hostile model for static optimizability - the existence of placement new prevents a lot of interesting devirtualization opportunities, and generally makes the compiler’s life difficult.  OTOH, like C, C++ provides a very predictable model: C++ programmers assume that C constructs are static, but virtual methods will be dynamically dispatched.  This is correct because (except for narrow cases) the compiler has to use dynamic dispatch for C++ virtual methods.   The good news here is that its dynamism is completely opt in, so C++ preserves all of the predictability, performance, and static-compilability of C while providing a higher level programming model.  If virtual methods are ever actually a performance problem, a C++ programmer has ways to deal with that, directly in their code.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 4. Java: Java makes nearly &quot;everything&quot; an object (no structs or other non-primitive value types), and all methods default to being “virtual” (in the C++ sense).  Java also introduces interfaces, which offer an added dimension on dynamic dispatch.  To cope with this, Java assumes a JIT compilation model, which can use dynamic behavior to de-virtualize the (almost always) monomorphic calls into checked direct calls.  This works out really well in practice, because JIT compilers are great at telling when a program with apparently very dynamic semantics actually have static semantics in practice (e.g. a dynamic call has a single receiver).  OTOH, since the compilation model assumes a JIT, this means that purely “AOT” static compilers (which have no profile information, no knowledge of class loaders, etc) necessarily produce inferior code.  It also means that Java doesn’t “scale down” well to small embedded systems that can’t support a JIT, like a bootloader.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 5) Objective-C: Objective-C provides a hybrid model which favors predictability due to its static compilation model (similar in some ways to C++).  The C-like constructs provide C-like performance, and the “messaging” constructs are never “devirtualized”, so they provide very predictable performance characteristics.  Because it is predictable, if the cost of a message send ever becomes an issue in practice, the programmer has many patterns to deal with it (including &quot;imp caching&quot;, and also including the ability to define the problem away by rewriting code in terms of C constructs).  The end result of this is that programmers write code which use C-level features where performance matters and dynamicism doesn’t, but use ObjC features where dynamicism is important or where performance doesn’t matter.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; While it would be possible to implement a JIT compiler for ObjC, I’d expect the wins to be low, because the “hot” code which may be hinging on these dynamic features is likely to already be optimized by hand.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 6) GoLang: From this narrow discussion and perspective, Go has a hybrid model that has similar characteristics to Objective-C 2013 (which introduced modules, but didn’t yet have generics).  It assumes static compilation and provides a very predictable hybrid programming model.  Its func’s are statically dispatched, but its interfaces are dynamically dispatched.  It doesn’t provide guaranteed dynamic dispatch (or “classes&quot;) like ObjC, but it provides even more dynamic feautres in other areas (e.g. it requires a cycle-collecting garbage collector).  Its &quot;interface{}” type is pretty equivalent to “id” (e.g. all uses of it are dynamically dispatched or must be downcasted), and it encourages use of it in the same places that Objective-C does.  Go introduces checked downcasts, which introduce some run-time overhead, but also provide safety compared to Objective-C. Go thankfully introduces a replacement for the imperative constructs in C, which defines away a bunch of C problems that Objective-C inherited, and it certainly is prettier!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; … I can go on about other languages, but I have probably already gotten myself into enough trouble. :-)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; With this as context, lets talk about Swift:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Swift is another case of a hybrid model: its semantics provide predictability between obviously static (structs, enums, and global funcs) and obviously dynamic (classes, protocols, and closures) constructs.  A focus of Swift (like Java and Javascript) is to provide an apparently simple programming model.  However, Swift also intentionally &quot;cheats&quot; in its global design by mixing in a few tricks to make the dynamic parts of the language optimizable by a static compiler in many common cases, without requiring profiling or other dynamic information..  For example, the Swift compiler can tell if methods in non-public classes are never overridden (and non-public is the default, for a lot of good reasons) - thus treating them as final.  This allows eliminating much of the overhead of dynamic dispatch without requiring a JIT.  Consider an “app”: because it never needs to have non-public classes, this is incredibly powerful - the design of the swift package manager extends this even further (in principle, not done yet) to external libraries. Further, Swift’s generics provide an a static performance model similar to C++ templates in release builds (though I agree we need to do more to really follow through on this) -- while Swift existentials (values of protocol type) provide a balance by giving a highly dynamic model.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The upshot of this is that Swift isn’t squarely in either of the static or dynamic camps: it aims to provide a very predictable performance model (someone writing a bootloader or firmware can stick to using Swift structs and have a simple guarantee of no dynamic overhead or runtime dependence) while also providing an expressive and clean high level programming model - simplifying learning and the common case where programmers don’t care to count cycles.  If anything, I’d say that Swift is an “opportunistic” language, in that it provides a very dynamic “default&quot; programming model, where you don’t have to think about the fact that a static compiler is able to transparently provide great performance - without needing the overhead of a JIT.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Finally, while it is possible that a JIT compiler might be interesting someday in the Swift space, if we do things right, it will never be “worth it” because programmers will have enough ability to reason about performance at their fingertips.  This means that there should be no Java or Javascript-magnitude &quot;performance delta&quot; sitting on the table waiting for a JIT to scoop up.  We’ll see how it works out long term, but I think we’re doing pretty well so far.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; TL;DR: What I’m really getting at is that the old static vs dynamic trope is at the very least only half of the story.  You really need to include the compilation model and thus the resultant programmer model into the story, and the programmer model is what really matters, IMHO.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/d82f1a72/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>May 20, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On May 20, 2016, at 10:43 AM, Brandon Knope via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; From the compilers/runtimes perspective why couldn&#39;t the declaration automatically be included in the main protocol definition as if it was defined there?<br></p><p>Assuming you have protocol extenders and protocol implementors as different people, they are competing in the same problem space. The odds of an unintentional name collision is higher than normal, in which case the person implementing a protocol just unknowingly changed behavior for everyone relying on that extension.<br></p><p>The implementors can’t look at the protocol to find out the list of requirements on the protocol anymore - they have to also find every extension.<br></p><p>-DW<br></p><p>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 496 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/bd9fbde0/attachment.sig&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 20, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On May 20, 2016, at 11:52 AM, David Waite &lt;david at alkaline-solutions.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 20, 2016, at 10:43 AM, Brandon Knope via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; From the compilers/runtimes perspective why couldn&#39;t the declaration automatically be included in the main protocol definition as if it was defined there?<br>&gt; <br>&gt; Assuming you have protocol extenders and protocol implementors as different people, they are competing in the same problem space. The odds of an unintentional name collision is higher than normal, in which case the person implementing a protocol just unknowingly changed behavior for everyone relying on that extension.<br>&gt; <br>&gt; The implementors can’t look at the protocol to find out the list of requirements on the protocol anymore - they have to also find every extension.<br></p><p><br>Thanks.  These are some of the issues I mentioned that were discussed quite a bit in earlier threads.  I suggest anyone who is interested in this problem catch up on those threads before moving any further in this discussion.<br></p><p>&gt; <br>&gt; -DW<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9ce70a6cb7175e7a5e5db5658186a31?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>Brandon Knope</string> &lt;bknope at me.com&gt;<p>May 20, 2016 at 01:00:00pm</p></header><div class="content"><p>Oh right! Doh!!<br></p><p>I looked at it too simply :(<br></p><p>Brandon <br></p><p>&gt; On May 20, 2016, at 12:52 PM, David Waite &lt;david at alkaline-solutions.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 20, 2016, at 10:43 AM, Brandon Knope via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; From the compilers/runtimes perspective why couldn&#39;t the declaration automatically be included in the main protocol definition as if it was defined there?<br>&gt; <br>&gt; Assuming you have protocol extenders and protocol implementors as different people, they are competing in the same problem space. The odds of an unintentional name collision is higher than normal, in which case the person implementing a protocol just unknowingly changed behavior for everyone relying on that extension.<br>&gt; <br>&gt; The implementors can’t look at the protocol to find out the list of requirements on the protocol anymore - they have to also find every extension.<br>&gt; <br>&gt; -DW<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>May 20, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On May 20, 2016, at 11:52 AM, David Waite via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On May 20, 2016, at 10:43 AM, Brandon Knope via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; From the compilers/runtimes perspective why couldn&#39;t the declaration automatically be included in the main protocol definition as if it was defined there?<br>&gt; <br>&gt; Assuming you have protocol extenders and protocol implementors as different people, they are competing in the same problem space. The odds of an unintentional name collision is higher than normal, in which case the person implementing a protocol just unknowingly changed behavior for everyone relying on that extension.<br>&gt; <br>&gt; The implementors can’t look at the protocol to find out the list of requirements on the protocol anymore - they have to also find every extension.<br></p><p>Implementers have to find every extension *already*, since there’s no other way to know if a method on a protocol actually needs to be implemented, or whether it already has a default implementation. Failure to do so results in a lot of reinventing the wheel.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/a7546faa/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 20, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On May 20, 2016, at 11:43 AM, Brandon Knope &lt;bknope at me.com&gt; wrote:<br>&gt; <br>&gt; From the compilers/runtimes perspective why couldn&#39;t the declaration automatically be included in the main protocol definition as if it was defined there?<br></p><p>That has been discussed as a possible solution but introduces implementation complexity.  I believe core team members have commented on the idea in the past.  I don’t recall the details but you should be able to find the discussions in the archives if you’re interested.<br></p><p>&gt; <br>&gt; Brandon <br>&gt; <br>&gt; On May 20, 2016, at 12:21 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 20, 2016, at 11:17 AM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I almost want to propose forbidding methods in protocol extensions unless they&#39;re also a requirement in the protocol itself, but I don&#39;t think that would fly.<br>&gt;&gt; <br>&gt;&gt; That would prevent us from adding extension methods to protocols declared in modules we depend on.  This is way to useful to throw away.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Austin<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 20, 2016, at 5:56 AM, Fabian Ehrentraud via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; there&#39;s been a little discussion about static vs. dynamic dispatch on this mailing list, and there is a good post about the pitfalls when using attributes defined in extensions [1].<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Having run into this myself during development, is there a plan on how to reduce the pitfalls in future versions of Swift?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Fabian<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; [1] https://developer.ibm.com/swift/2016/01/27/seven-swift-snares-how-to-avoid-them/ &lt;https://developer.ibm.com/swift/2016/01/27/seven-swift-snares-how-to-avoid-them/&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sorry, I understand and appreciate your pragmatism. Right now it feels very much like a fight to the ideological death between POP and OOP and it may get really bad results this way.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 4 Mar 2016, at 08:58, Brent Royal-Gordon &lt;brent at architechies.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; Brent, why is dynamic dispatching for protocol extension default implementations wrong in your mind? Wouldn&#39;t you agree that when static dispatching introduces such a side effect that it should not be automatically applied and perhaps a keyword should be added if you really wanted static dispatching nonetheless?<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; I think that code execution should not be affected by type casting, it feels like a very confusing part of the language.<br>&gt;&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt;&gt; &gt; I don&#39;t think dynamic dispatch is wrong; I think it&#39;s a large and technically challenging change. So in the spirit of incrementalism, I was trying to make cautious proposals which kept existing semantics intact but made them clearer, in preparation for perhaps eventually introducing dynamic dispatch. (Basically, I suggested that non-overridable protocol extension members should be marked `final` and it should be illegal to shadow them.)<br>&gt;&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt;&gt; &gt; But the feedback I got indicated that most people wanted a more aggressive proposal which introduced dynamic dispatch immediately. That&#39;s much harder to propose because it touches on all sorts of runtime implementation details I know nothing about, so I didn&#39;t try to draft a proposal.<br>&gt;&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt;&gt; &gt; (You are, perhaps inadvertently, currently demonstrating exactly what happened in those previous threads!)<br>&gt;&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt;&gt; &gt; -- <br>&gt;&gt;&gt;&gt;&gt; &gt; Brent Royal-Gordon<br>&gt;&gt;&gt;&gt;&gt; &gt; Architechies<br>&gt;&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt; On Dec 11, 2015, at 8:56 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt;&gt; &gt; You think that Swift prefers virtual dispatch. I think it prefers static.<br>&gt;&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt;&gt; &gt; I think what&#39;s really going on here is that _in most cases_ there&#39;s no observable difference between static dispatch and virtual dispatch. If you think of Swift as an OOP language with a powerful value-typed system added on, then you&#39;ll probably think Swift prefers virtual dispatch. If you think of Swift as a value-typed language with an OOP layer added, then you&#39;ll probably think Swift prefers static dispatch. In reality, Swift is a hybrid language and it uses different types of dispatch in different situations as appropriate.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; (emphasis mine)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I know that this is a bit philosophical, but let me suggest a “next level down” way to look at this.  Static and dynamic are *both* great after all, and if you’re looking to type-cast languages, you need to consider them both in light of their semantics, but also factor in their compilation strategy and the programmer model that they all provide.  Let me give you some examples, but keep in mind that this is a narrow view and just MHO:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 1. C: Static compilation model, static semantics.  While it does provide indirect function pointers, C does everything possible to punish their use (ever see the non-typedef&#39;d prototype for signal(3/7)?), and is almost always statically compiled.  It provides a very “static centric” programming model.  This is great in terms of predictability - it makes it trivial to “predict” what your code will look like at a machine level.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2. Javascript: Completely dynamic compilation model, completely dynamic semantics.  No one talks about statically compiling javascript, because the result of doing so would be a really really slow executable.  Javascript performance hinges on dynamic profile information to be able to efficiently execute a program.  This provides a very “dynamic centric” programming model, with no ability to understand how your code executes at a machine level.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 3. C++: C++ is a step up from C in terms of introducing dynamism into the model with virtual functions.   Sadly, C++ also provides a hostile model for static optimizability - the existence of placement new prevents a lot of interesting devirtualization opportunities, and generally makes the compiler’s life difficult.  OTOH, like C, C++ provides a very predictable model: C++ programmers assume that C constructs are static, but virtual methods will be dynamically dispatched.  This is correct because (except for narrow cases) the compiler has to use dynamic dispatch for C++ virtual methods.   The good news here is that its dynamism is completely opt in, so C++ preserves all of the predictability, performance, and static-compilability of C while providing a higher level programming model.  If virtual methods are ever actually a performance problem, a C++ programmer has ways to deal with that, directly in their code.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 4. Java: Java makes nearly &quot;everything&quot; an object (no structs or other non-primitive value types), and all methods default to being “virtual” (in the C++ sense).  Java also introduces interfaces, which offer an added dimension on dynamic dispatch.  To cope with this, Java assumes a JIT compilation model, which can use dynamic behavior to de-virtualize the (almost always) monomorphic calls into checked direct calls.  This works out really well in practice, because JIT compilers are great at telling when a program with apparently very dynamic semantics actually have static semantics in practice (e.g. a dynamic call has a single receiver).  OTOH, since the compilation model assumes a JIT, this means that purely “AOT” static compilers (which have no profile information, no knowledge of class loaders, etc) necessarily produce inferior code.  It also means that Java doesn’t “scale down” well to small embedded systems that can’t support a JIT, like a bootloader.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 5) Objective-C: Objective-C provides a hybrid model which favors predictability due to its static compilation model (similar in some ways to C++).  The C-like constructs provide C-like performance, and the “messaging” constructs are never “devirtualized”, so they provide very predictable performance characteristics.  Because it is predictable, if the cost of a message send ever becomes an issue in practice, the programmer has many patterns to deal with it (including &quot;imp caching&quot;, and also including the ability to define the problem away by rewriting code in terms of C constructs).  The end result of this is that programmers write code which use C-level features where performance matters and dynamicism doesn’t, but use ObjC features where dynamicism is important or where performance doesn’t matter.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; While it would be possible to implement a JIT compiler for ObjC, I’d expect the wins to be low, because the “hot” code which may be hinging on these dynamic features is likely to already be optimized by hand.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 6) GoLang: From this narrow discussion and perspective, Go has a hybrid model that has similar characteristics to Objective-C 2013 (which introduced modules, but didn’t yet have generics).  It assumes static compilation and provides a very predictable hybrid programming model.  Its func’s are statically dispatched, but its interfaces are dynamically dispatched.  It doesn’t provide guaranteed dynamic dispatch (or “classes&quot;) like ObjC, but it provides even more dynamic feautres in other areas (e.g. it requires a cycle-collecting garbage collector).  Its &quot;interface{}” type is pretty equivalent to “id” (e.g. all uses of it are dynamically dispatched or must be downcasted), and it encourages use of it in the same places that Objective-C does.  Go introduces checked downcasts, which introduce some run-time overhead, but also provide safety compared to Objective-C. Go thankfully introduces a replacement for the imperative constructs in C, which defines away a bunch of C problems that Objective-C inherited, and it certainly is prettier!<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; … I can go on about other languages, but I have probably already gotten myself into enough trouble. :-)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; With this as context, lets talk about Swift:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Swift is another case of a hybrid model: its semantics provide predictability between obviously static (structs, enums, and global funcs) and obviously dynamic (classes, protocols, and closures) constructs.  A focus of Swift (like Java and Javascript) is to provide an apparently simple programming model.  However, Swift also intentionally &quot;cheats&quot; in its global design by mixing in a few tricks to make the dynamic parts of the language optimizable by a static compiler in many common cases, without requiring profiling or other dynamic information..  For example, the Swift compiler can tell if methods in non-public classes are never overridden (and non-public is the default, for a lot of good reasons) - thus treating them as final.  This allows eliminating much of the overhead of dynamic dispatch without requiring a JIT.  Consider an “app”: because it never needs to have non-public classes, this is incredibly powerful - the design of the swift package manager extends this even further (in principle, not done yet) to external libraries. Further, Swift’s generics provide an a static performance model similar to C++ templates in release builds (though I agree we need to do more to really follow through on this) -- while Swift existentials (values of protocol type) provide a balance by giving a highly dynamic model.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The upshot of this is that Swift isn’t squarely in either of the static or dynamic camps: it aims to provide a very predictable performance model (someone writing a bootloader or firmware can stick to using Swift structs and have a simple guarantee of no dynamic overhead or runtime dependence) while also providing an expressive and clean high level programming model - simplifying learning and the common case where programmers don’t care to count cycles.  If anything, I’d say that Swift is an “opportunistic” language, in that it provides a very dynamic “default&quot; programming model, where you don’t have to think about the fact that a static compiler is able to transparently provide great performance - without needing the overhead of a JIT.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Finally, while it is possible that a JIT compiler might be interesting someday in the Swift space, if we do things right, it will never be “worth it” because programmers will have enough ability to reason about performance at their fingertips.  This means that there should be no Java or Javascript-magnitude &quot;performance delta&quot; sitting on the table waiting for a JIT to scoop up.  We’ll see how it works out long term, but I think we’re doing pretty well so far.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; TL;DR: What I’m really getting at is that the old static vs dynamic trope is at the very least only half of the story.  You really need to include the compilation model and thus the resultant programmer model into the story, and the programmer model is what really matters, IMHO.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/b3357d91/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 20, 2016 at 07:00:00pm</p></header><div class="content"><p>Regards<br>(From mobile)<br></p><p>&gt; On May 20, 2016, at 6:52 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 20, 2016, at 11:43 AM, Brandon Knope &lt;bknope at me.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; From the compilers/runtimes perspective why couldn&#39;t the declaration automatically be included in the main protocol definition as if it was defined there?<br>&gt; <br>&gt; That has been discussed as a possible solution but introduces implementation complexity.  I believe core team members have commented on the idea in the past.  I don’t recall the details but you should be able to find the discussions in the archives if you’re interested.<br>&gt; <br></p><p>Not to mention the security risk it represents.... yeah!!! an apple provided official way to patch any dylib during load time.<br></p><p><br>&gt;&gt; <br>&gt;&gt; Brandon <br>&gt;&gt; <br>&gt;&gt;&gt; On May 20, 2016, at 12:21 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 20, 2016, at 11:17 AM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I almost want to propose forbidding methods in protocol extensions unless they&#39;re also a requirement in the protocol itself, but I don&#39;t think that would fly.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That would prevent us from adding extension methods to protocols declared in modules we depend on.  This is way to useful to throw away.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 20, 2016, at 5:56 AM, Fabian Ehrentraud via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; there&#39;s been a little discussion about static vs. dynamic dispatch on this mailing list, and there is a good post about the pitfalls when using attributes defined in extensions [1].<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Having run into this myself during development, is there a plan on how to reduce the pitfalls in future versions of Swift?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - Fabian<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; [1] https://developer.ibm.com/swift/2016/01/27/seven-swift-snares-how-to-avoid-them/<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Sorry, I understand and appreciate your pragmatism. Right now it feels very much like a fight to the ideological death between POP and OOP and it may get really bad results this way.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 4 Mar 2016, at 08:58, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Brent, why is dynamic dispatching for protocol extension default implementations wrong in your mind? Wouldn&#39;t you agree that when static dispatching introduces such a side effect that it should not be automatically applied and perhaps a keyword should be added if you really wanted static dispatching nonetheless?<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; I think that code execution should not be affected by type casting, it feels like a very confusing part of the language.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; I don&#39;t think dynamic dispatch is wrong; I think it&#39;s a large and technically challenging change. So in the spirit of incrementalism, I was trying to make cautious proposals which kept existing semantics intact but made them clearer, in preparation for perhaps eventually introducing dynamic dispatch. (Basically, I suggested that non-overridable protocol extension members should be marked `final` and it should be illegal to shadow them.)<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; But the feedback I got indicated that most people wanted a more aggressive proposal which introduced dynamic dispatch immediately. That&#39;s much harder to propose because it touches on all sorts of runtime implementation details I know nothing about, so I didn&#39;t try to draft a proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; (You are, perhaps inadvertently, currently demonstrating exactly what happened in those previous threads!)<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; -- <br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Brent Royal-Gordon<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Architechies<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; On Dec 11, 2015, at 8:56 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; You think that Swift prefers virtual dispatch. I think it prefers static.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; I think what&#39;s really going on here is that _in most cases_ there&#39;s no observable difference between static dispatch and virtual dispatch. If you think of Swift as an OOP language with a powerful value-typed system added on, then you&#39;ll probably think Swift prefers virtual dispatch. If you think of Swift as a value-typed language with an OOP layer added, then you&#39;ll probably think Swift prefers static dispatch. In reality, Swift is a hybrid language and it uses different types of dispatch in different situations as appropriate.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; (emphasis mine)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I know that this is a bit philosophical, but let me suggest a “next level down” way to look at this.  Static and dynamic are *both* great after all, and if you’re looking to type-cast languages, you need to consider them both in light of their semantics, but also factor in their compilation strategy and the programmer model that they all provide.  Let me give you some examples, but keep in mind that this is a narrow view and just MHO:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 1. C: Static compilation model, static semantics.  While it does provide indirect function pointers, C does everything possible to punish their use (ever see the non-typedef&#39;d prototype for signal(3/7)?), and is almost always statically compiled.  It provides a very “static centric” programming model.  This is great in terms of predictability - it makes it trivial to “predict” what your code will look like at a machine level.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 2. Javascript: Completely dynamic compilation model, completely dynamic semantics.  No one talks about statically compiling javascript, because the result of doing so would be a really really slow executable.  Javascript performance hinges on dynamic profile information to be able to efficiently execute a program.  This provides a very “dynamic centric” programming model, with no ability to understand how your code executes at a machine level.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 3. C++: C++ is a step up from C in terms of introducing dynamism into the model with virtual functions.   Sadly, C++ also provides a hostile model for static optimizability - the existence of placement new prevents a lot of interesting devirtualization opportunities, and generally makes the compiler’s life difficult.  OTOH, like C, C++ provides a very predictable model: C++ programmers assume that C constructs are static, but virtual methods will be dynamically dispatched.  This is correct because (except for narrow cases) the compiler has to use dynamic dispatch for C++ virtual methods.   The good news here is that its dynamism is completely opt in, so C++ preserves all of the predictability, performance, and static-compilability of C while providing a higher level programming model.  If virtual methods are ever actually a performance problem, a C++ programmer has ways to deal with that, directly in their code.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 4. Java: Java makes nearly &quot;everything&quot; an object (no structs or other non-primitive value types), and all methods default to being “virtual” (in the C++ sense).  Java also introduces interfaces, which offer an added dimension on dynamic dispatch.  To cope with this, Java assumes a JIT compilation model, which can use dynamic behavior to de-virtualize the (almost always) monomorphic calls into checked direct calls.  This works out really well in practice, because JIT compilers are great at telling when a program with apparently very dynamic semantics actually have static semantics in practice (e.g. a dynamic call has a single receiver).  OTOH, since the compilation model assumes a JIT, this means that purely “AOT” static compilers (which have no profile information, no knowledge of class loaders, etc) necessarily produce inferior code.  It also means that Java doesn’t “scale down” well to small embedded systems that can’t support a JIT, like a bootloader.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 5) Objective-C: Objective-C provides a hybrid model which favors predictability due to its static compilation model (similar in some ways to C++).  The C-like constructs provide C-like performance, and the “messaging” constructs are never “devirtualized”, so they provide very predictable performance characteristics.  Because it is predictable, if the cost of a message send ever becomes an issue in practice, the programmer has many patterns to deal with it (including &quot;imp caching&quot;, and also including the ability to define the problem away by rewriting code in terms of C constructs).  The end result of this is that programmers write code which use C-level features where performance matters and dynamicism doesn’t, but use ObjC features where dynamicism is important or where performance doesn’t matter.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; While it would be possible to implement a JIT compiler for ObjC, I’d expect the wins to be low, because the “hot” code which may be hinging on these dynamic features is likely to already be optimized by hand.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 6) GoLang: From this narrow discussion and perspective, Go has a hybrid model that has similar characteristics to Objective-C 2013 (which introduced modules, but didn’t yet have generics).  It assumes static compilation and provides a very predictable hybrid programming model.  Its func’s are statically dispatched, but its interfaces are dynamically dispatched.  It doesn’t provide guaranteed dynamic dispatch (or “classes&quot;) like ObjC, but it provides even more dynamic feautres in other areas (e.g. it requires a cycle-collecting garbage collector).  Its &quot;interface{}” type is pretty equivalent to “id” (e.g. all uses of it are dynamically dispatched or must be downcasted), and it encourages use of it in the same places that Objective-C does.  Go introduces checked downcasts, which introduce some run-time overhead, but also provide safety compared to Objective-C. Go thankfully introduces a replacement for the imperative constructs in C, which defines away a bunch of C problems that Objective-C inherited, and it certainly is prettier!<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; … I can go on about other languages, but I have probably already gotten myself into enough trouble. :-)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; With this as context, lets talk about Swift:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Swift is another case of a hybrid model: its semantics provide predictability between obviously static (structs, enums, and global funcs) and obviously dynamic (classes, protocols, and closures) constructs.  A focus of Swift (like Java and Javascript) is to provide an apparently simple programming model.  However, Swift also intentionally &quot;cheats&quot; in its global design by mixing in a few tricks to make the dynamic parts of the language optimizable by a static compiler in many common cases, without requiring profiling or other dynamic information..  For example, the Swift compiler can tell if methods in non-public classes are never overridden (and non-public is the default, for a lot of good reasons) - thus treating them as final.  This allows eliminating much of the overhead of dynamic dispatch without requiring a JIT.  Consider an “app”: because it never needs to have non-public classes, this is incredibly powerful - the design of the swift package manager extends this even further (in principle, not done yet) to external libraries. Further, Swift’s generics provide an a static performance model similar to C++ templates in release builds (though I agree we need to do more to really follow through on this) -- while Swift existentials (values of protocol type) provide a balance by giving a highly dynamic model.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The upshot of this is that Swift isn’t squarely in either of the static or dynamic camps: it aims to provide a very predictable performance model (someone writing a bootloader or firmware can stick to using Swift structs and have a simple guarantee of no dynamic overhead or runtime dependence) while also providing an expressive and clean high level programming model - simplifying learning and the common case where programmers don’t care to count cycles.  If anything, I’d say that Swift is an “opportunistic” language, in that it provides a very dynamic “default&quot; programming model, where you don’t have to think about the fact that a static compiler is able to transparently provide great performance - without needing the overhead of a JIT.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Finally, while it is possible that a JIT compiler might be interesting someday in the Swift space, if we do things right, it will never be “worth it” because programmers will have enough ability to reason about performance at their fingertips.  This means that there should be no Java or Javascript-magnitude &quot;performance delta&quot; sitting on the table waiting for a JIT to scoop up.  We’ll see how it works out long term, but I think we’re doing pretty well so far.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; TL;DR: What I’m really getting at is that the old static vs dynamic trope is at the very least only half of the story.  You really need to include the compilation model and thus the resultant programmer model into the story, and the programmer model is what really matters, IMHO.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/08d2960d/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 20, 2016 at 07:00:00pm</p></header><div class="content"><p>Regards<br>(From mobile)<br></p><p>&gt; On May 20, 2016, at 6:43 PM, Brandon Knope via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; From the compilers/runtimes perspective why couldn&#39;t the declaration automatically be included in the main protocol definition as if it was defined there?<br></p><p>That&#39;s just the point, these 2 have very different views of the world. Trying to *fool* the runtime would mean building into it the kind of runtime support that exist in the objc runtime and that disappeared with swift. Part of swift&#39;s power is that the compiler is far smarter, making it possible to go back to a dumb (i.e fast) runtime. Method swizzling is fun... but it is slow. Although it is arguable that with the CPUs we now have, who cares if each instruction is actually a complete program, right?... except in the iot,embedded,wearable,mobile world where apple operates!!! <br>So we DO care that the compiler is orders of magnitude smater and that the runtime does not do vtable lookups on every call, even if we loose a couple things for now.<br></p><p><br>&gt; <br>&gt; Brandon <br>&gt; <br>&gt;&gt; On May 20, 2016, at 12:21 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 20, 2016, at 11:17 AM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I almost want to propose forbidding methods in protocol extensions unless they&#39;re also a requirement in the protocol itself, but I don&#39;t think that would fly.<br>&gt;&gt; <br>&gt;&gt; That would prevent us from adding extension methods to protocols declared in modules we depend on.  This is way to useful to throw away.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Austin<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 20, 2016, at 5:56 AM, Fabian Ehrentraud via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; there&#39;s been a little discussion about static vs. dynamic dispatch on this mailing list, and there is a good post about the pitfalls when using attributes defined in extensions [1].<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Having run into this myself during development, is there a plan on how to reduce the pitfalls in future versions of Swift?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Fabian<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; [1] https://developer.ibm.com/swift/2016/01/27/seven-swift-snares-how-to-avoid-them/<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sorry, I understand and appreciate your pragmatism. Right now it feels very much like a fight to the ideological death between POP and OOP and it may get really bad results this way.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 4 Mar 2016, at 08:58, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; Brent, why is dynamic dispatching for protocol extension default implementations wrong in your mind? Wouldn&#39;t you agree that when static dispatching introduces such a side effect that it should not be automatically applied and perhaps a keyword should be added if you really wanted static dispatching nonetheless?<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; I think that code execution should not be affected by type casting, it feels like a very confusing part of the language.<br>&gt;&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt;&gt; &gt; I don&#39;t think dynamic dispatch is wrong; I think it&#39;s a large and technically challenging change. So in the spirit of incrementalism, I was trying to make cautious proposals which kept existing semantics intact but made them clearer, in preparation for perhaps eventually introducing dynamic dispatch. (Basically, I suggested that non-overridable protocol extension members should be marked `final` and it should be illegal to shadow them.)<br>&gt;&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt;&gt; &gt; But the feedback I got indicated that most people wanted a more aggressive proposal which introduced dynamic dispatch immediately. That&#39;s much harder to propose because it touches on all sorts of runtime implementation details I know nothing about, so I didn&#39;t try to draft a proposal.<br>&gt;&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt;&gt; &gt; (You are, perhaps inadvertently, currently demonstrating exactly what happened in those previous threads!)<br>&gt;&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt;&gt; &gt; -- <br>&gt;&gt;&gt;&gt;&gt; &gt; Brent Royal-Gordon<br>&gt;&gt;&gt;&gt;&gt; &gt; Architechies<br>&gt;&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt; On Dec 11, 2015, at 8:56 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt;&gt; &gt; You think that Swift prefers virtual dispatch. I think it prefers static.<br>&gt;&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt;&gt; &gt; I think what&#39;s really going on here is that _in most cases_ there&#39;s no observable difference between static dispatch and virtual dispatch. If you think of Swift as an OOP language with a powerful value-typed system added on, then you&#39;ll probably think Swift prefers virtual dispatch. If you think of Swift as a value-typed language with an OOP layer added, then you&#39;ll probably think Swift prefers static dispatch. In reality, Swift is a hybrid language and it uses different types of dispatch in different situations as appropriate.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; (emphasis mine)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I know that this is a bit philosophical, but let me suggest a “next level down” way to look at this.  Static and dynamic are *both* great after all, and if you’re looking to type-cast languages, you need to consider them both in light of their semantics, but also factor in their compilation strategy and the programmer model that they all provide.  Let me give you some examples, but keep in mind that this is a narrow view and just MHO:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 1. C: Static compilation model, static semantics.  While it does provide indirect function pointers, C does everything possible to punish their use (ever see the non-typedef&#39;d prototype for signal(3/7)?), and is almost always statically compiled.  It provides a very “static centric” programming model.  This is great in terms of predictability - it makes it trivial to “predict” what your code will look like at a machine level.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2. Javascript: Completely dynamic compilation model, completely dynamic semantics.  No one talks about statically compiling javascript, because the result of doing so would be a really really slow executable.  Javascript performance hinges on dynamic profile information to be able to efficiently execute a program.  This provides a very “dynamic centric” programming model, with no ability to understand how your code executes at a machine level.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 3. C++: C++ is a step up from C in terms of introducing dynamism into the model with virtual functions.   Sadly, C++ also provides a hostile model for static optimizability - the existence of placement new prevents a lot of interesting devirtualization opportunities, and generally makes the compiler’s life difficult.  OTOH, like C, C++ provides a very predictable model: C++ programmers assume that C constructs are static, but virtual methods will be dynamically dispatched.  This is correct because (except for narrow cases) the compiler has to use dynamic dispatch for C++ virtual methods.   The good news here is that its dynamism is completely opt in, so C++ preserves all of the predictability, performance, and static-compilability of C while providing a higher level programming model.  If virtual methods are ever actually a performance problem, a C++ programmer has ways to deal with that, directly in their code.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 4. Java: Java makes nearly &quot;everything&quot; an object (no structs or other non-primitive value types), and all methods default to being “virtual” (in the C++ sense).  Java also introduces interfaces, which offer an added dimension on dynamic dispatch.  To cope with this, Java assumes a JIT compilation model, which can use dynamic behavior to de-virtualize the (almost always) monomorphic calls into checked direct calls.  This works out really well in practice, because JIT compilers are great at telling when a program with apparently very dynamic semantics actually have static semantics in practice (e.g. a dynamic call has a single receiver).  OTOH, since the compilation model assumes a JIT, this means that purely “AOT” static compilers (which have no profile information, no knowledge of class loaders, etc) necessarily produce inferior code.  It also means that Java doesn’t “scale down” well to small embedded systems that can’t support a JIT, like a bootloader.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 5) Objective-C: Objective-C provides a hybrid model which favors predictability due to its static compilation model (similar in some ways to C++).  The C-like constructs provide C-like performance, and the “messaging” constructs are never “devirtualized”, so they provide very predictable performance characteristics.  Because it is predictable, if the cost of a message send ever becomes an issue in practice, the programmer has many patterns to deal with it (including &quot;imp caching&quot;, and also including the ability to define the problem away by rewriting code in terms of C constructs).  The end result of this is that programmers write code which use C-level features where performance matters and dynamicism doesn’t, but use ObjC features where dynamicism is important or where performance doesn’t matter.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; While it would be possible to implement a JIT compiler for ObjC, I’d expect the wins to be low, because the “hot” code which may be hinging on these dynamic features is likely to already be optimized by hand.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 6) GoLang: From this narrow discussion and perspective, Go has a hybrid model that has similar characteristics to Objective-C 2013 (which introduced modules, but didn’t yet have generics).  It assumes static compilation and provides a very predictable hybrid programming model.  Its func’s are statically dispatched, but its interfaces are dynamically dispatched.  It doesn’t provide guaranteed dynamic dispatch (or “classes&quot;) like ObjC, but it provides even more dynamic feautres in other areas (e.g. it requires a cycle-collecting garbage collector).  Its &quot;interface{}” type is pretty equivalent to “id” (e.g. all uses of it are dynamically dispatched or must be downcasted), and it encourages use of it in the same places that Objective-C does.  Go introduces checked downcasts, which introduce some run-time overhead, but also provide safety compared to Objective-C. Go thankfully introduces a replacement for the imperative constructs in C, which defines away a bunch of C problems that Objective-C inherited, and it certainly is prettier!<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; … I can go on about other languages, but I have probably already gotten myself into enough trouble. :-)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; With this as context, lets talk about Swift:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Swift is another case of a hybrid model: its semantics provide predictability between obviously static (structs, enums, and global funcs) and obviously dynamic (classes, protocols, and closures) constructs.  A focus of Swift (like Java and Javascript) is to provide an apparently simple programming model.  However, Swift also intentionally &quot;cheats&quot; in its global design by mixing in a few tricks to make the dynamic parts of the language optimizable by a static compiler in many common cases, without requiring profiling or other dynamic information..  For example, the Swift compiler can tell if methods in non-public classes are never overridden (and non-public is the default, for a lot of good reasons) - thus treating them as final.  This allows eliminating much of the overhead of dynamic dispatch without requiring a JIT.  Consider an “app”: because it never needs to have non-public classes, this is incredibly powerful - the design of the swift package manager extends this even further (in principle, not done yet) to external libraries. Further, Swift’s generics provide an a static performance model similar to C++ templates in release builds (though I agree we need to do more to really follow through on this) -- while Swift existentials (values of protocol type) provide a balance by giving a highly dynamic model.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The upshot of this is that Swift isn’t squarely in either of the static or dynamic camps: it aims to provide a very predictable performance model (someone writing a bootloader or firmware can stick to using Swift structs and have a simple guarantee of no dynamic overhead or runtime dependence) while also providing an expressive and clean high level programming model - simplifying learning and the common case where programmers don’t care to count cycles.  If anything, I’d say that Swift is an “opportunistic” language, in that it provides a very dynamic “default&quot; programming model, where you don’t have to think about the fact that a static compiler is able to transparently provide great performance - without needing the overhead of a JIT.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Finally, while it is possible that a JIT compiler might be interesting someday in the Swift space, if we do things right, it will never be “worth it” because programmers will have enough ability to reason about performance at their fingertips.  This means that there should be no Java or Javascript-magnitude &quot;performance delta&quot; sitting on the table waiting for a JIT to scoop up.  We’ll see how it works out long term, but I think we’re doing pretty well so far.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; TL;DR: What I’m really getting at is that the old static vs dynamic trope is at the very least only half of the story.  You really need to include the compilation model and thus the resultant programmer model into the story, and the programmer model is what really matters, IMHO.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/c757cad6/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>May 20, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On May 20, 2016, at 10:17 AM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I almost want to propose forbidding methods in protocol extensions unless they&#39;re also a requirement in the protocol itself, but I don&#39;t think that would fly.<br>&gt; <br>&gt; Austin<br></p><p>Thats one option.<br></p><p>Think two separate developers - only who implements the protocol Foo and has an independent bar() method on their type, and one who writes an extension to Foo to add a bar method on it.<br></p><p>bar() is not part of the protocol specification. the person implementing the type has no idea that others are expecting his bar() to meet particular requirements, just because it was declared in a protocol extension. <br></p><p>So silently using the type implementor’s bar() method when using Foo is unacceptable. You don’t know if it meets the requirements, because Foo never specified requirements for a bar() method.<br></p><p>BTW, it would also be dangerous to let an extension make a protocol implement another protocol for similar reasons.<br></p><p>So, options to solve:<br>- Having the extension to protocol Foo only apply when dealing in terms of Foo type and not the implementors type. This sounds less useful than what we have today.<br>- You could have a warning if the compiler sees a Foo extension and a Foo implementation both with bar(). Hopefully the application developer has control over either the protocol definition, the extension, or the implementation of the protocol to try and resolve it.<br>- forbid protocol extensions adding methods - they can only implement existing methods<br>- If protocol implementations used “override” (or perhaps a better named keyword for covering this instance as well like “implement”), you could consider protocol extensions to extend the protocol definition more safely. You would also catch the case where the Protocol definition changed to include the same foo() method the implementing type defined independently, so the implementor can make sure their version of foo() meets the requirements the protocol gives.<br></p><p>-DW<br>&gt; <br>&gt;&gt; On May 20, 2016, at 5:56 AM, Fabian Ehrentraud via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi,<br>&gt;&gt; <br>&gt;&gt; there&#39;s been a little discussion about static vs. dynamic dispatch on this mailing list, and there is a good post about the pitfalls when using attributes defined in extensions [1].<br>&gt;&gt; <br>&gt;&gt; Having run into this myself during development, is there a plan on how to reduce the pitfalls in future versions of Swift?<br>&gt;&gt; <br>&gt;&gt; - Fabian<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; [1] https://developer.ibm.com/swift/2016/01/27/seven-swift-snares-how-to-avoid-them/ &lt;https://developer.ibm.com/swift/2016/01/27/seven-swift-snares-how-to-avoid-them/&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; Sorry, I understand and appreciate your pragmatism. Right now it feels very much like a fight to the ideological death between POP and OOP and it may get really bad results this way.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 4 Mar 2016, at 08:58, Brent Royal-Gordon &lt;brent at architechies.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt;&gt; Brent, why is dynamic dispatching for protocol extension default implementations wrong in your mind? Wouldn&#39;t you agree that when static dispatching introduces such a side effect that it should not be automatically applied and perhaps a keyword should be added if you really wanted static dispatching nonetheless?<br>&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt; &gt;&gt; I think that code execution should not be affected by type casting, it feels like a very confusing part of the language.<br>&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt; &gt; I don&#39;t think dynamic dispatch is wrong; I think it&#39;s a large and technically challenging change. So in the spirit of incrementalism, I was trying to make cautious proposals which kept existing semantics intact but made them clearer, in preparation for perhaps eventually introducing dynamic dispatch. (Basically, I suggested that non-overridable protocol extension members should be marked `final` and it should be illegal to shadow them.)<br>&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt; &gt; But the feedback I got indicated that most people wanted a more aggressive proposal which introduced dynamic dispatch immediately. That&#39;s much harder to propose because it touches on all sorts of runtime implementation details I know nothing about, so I didn&#39;t try to draft a proposal.<br>&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt; &gt; (You are, perhaps inadvertently, currently demonstrating exactly what happened in those previous threads!)<br>&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt; &gt; -- <br>&gt;&gt;&gt; &gt; Brent Royal-Gordon<br>&gt;&gt;&gt; &gt; Architechies<br>&gt;&gt;&gt; &gt; <br>&gt;&gt; <br>&gt;&gt;&gt; &gt; On Dec 11, 2015, at 8:56 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt; &gt; You think that Swift prefers virtual dispatch. I think it prefers static.<br>&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt; &gt; I think what&#39;s really going on here is that _in most cases_ there&#39;s no observable difference between static dispatch and virtual dispatch. If you think of Swift as an OOP language with a powerful value-typed system added on, then you&#39;ll probably think Swift prefers virtual dispatch. If you think of Swift as a value-typed language with an OOP layer added, then you&#39;ll probably think Swift prefers static dispatch. In reality, Swift is a hybrid language and it uses different types of dispatch in different situations as appropriate.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (emphasis mine)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I know that this is a bit philosophical, but let me suggest a “next level down” way to look at this.  Static and dynamic are *both* great after all, and if you’re looking to type-cast languages, you need to consider them both in light of their semantics, but also factor in their compilation strategy and the programmer model that they all provide.  Let me give you some examples, but keep in mind that this is a narrow view and just MHO:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. C: Static compilation model, static semantics.  While it does provide indirect function pointers, C does everything possible to punish their use (ever see the non-typedef&#39;d prototype for signal(3/7)?), and is almost always statically compiled.  It provides a very “static centric” programming model.  This is great in terms of predictability - it makes it trivial to “predict” what your code will look like at a machine level.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2. Javascript: Completely dynamic compilation model, completely dynamic semantics.  No one talks about statically compiling javascript, because the result of doing so would be a really really slow executable.  Javascript performance hinges on dynamic profile information to be able to efficiently execute a program.  This provides a very “dynamic centric” programming model, with no ability to understand how your code executes at a machine level.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 3. C++: C++ is a step up from C in terms of introducing dynamism into the model with virtual functions.   Sadly, C++ also provides a hostile model for static optimizability - the existence of placement new prevents a lot of interesting devirtualization opportunities, and generally makes the compiler’s life difficult.  OTOH, like C, C++ provides a very predictable model: C++ programmers assume that C constructs are static, but virtual methods will be dynamically dispatched.  This is correct because (except for narrow cases) the compiler has to use dynamic dispatch for C++ virtual methods.   The good news here is that its dynamism is completely opt in, so C++ preserves all of the predictability, performance, and static-compilability of C while providing a higher level programming model.  If virtual methods are ever actually a performance problem, a C++ programmer has ways to deal with that, directly in their code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 4. Java: Java makes nearly &quot;everything&quot; an object (no structs or other non-primitive value types), and all methods default to being “virtual” (in the C++ sense).  Java also introduces interfaces, which offer an added dimension on dynamic dispatch.  To cope with this, Java assumes a JIT compilation model, which can use dynamic behavior to de-virtualize the (almost always) monomorphic calls into checked direct calls.  This works out really well in practice, because JIT compilers are great at telling when a program with apparently very dynamic semantics actually have static semantics in practice (e.g. a dynamic call has a single receiver).  OTOH, since the compilation model assumes a JIT, this means that purely “AOT” static compilers (which have no profile information, no knowledge of class loaders, etc) necessarily produce inferior code.  It also means that Java doesn’t “scale down” well to small embedded systems that can’t support a JIT, like a bootloader.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 5) Objective-C: Objective-C provides a hybrid model which favors predictability due to its static compilation model (similar in some ways to C++).  The C-like constructs provide C-like performance, and the “messaging” constructs are never “devirtualized”, so they provide very predictable performance characteristics.  Because it is predictable, if the cost of a message send ever becomes an issue in practice, the programmer has many patterns to deal with it (including &quot;imp caching&quot;, and also including the ability to define the problem away by rewriting code in terms of C constructs).  The end result of this is that programmers write code which use C-level features where performance matters and dynamicism doesn’t, but use ObjC features where dynamicism is important or where performance doesn’t matter.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; While it would be possible to implement a JIT compiler for ObjC, I’d expect the wins to be low, because the “hot” code which may be hinging on these dynamic features is likely to already be optimized by hand.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 6) GoLang: From this narrow discussion and perspective, Go has a hybrid model that has similar characteristics to Objective-C 2013 (which introduced modules, but didn’t yet have generics).  It assumes static compilation and provides a very predictable hybrid programming model.  Its func’s are statically dispatched, but its interfaces are dynamically dispatched.  It doesn’t provide guaranteed dynamic dispatch (or “classes&quot;) like ObjC, but it provides even more dynamic feautres in other areas (e.g. it requires a cycle-collecting garbage collector).  Its &quot;interface{}” type is pretty equivalent to “id” (e.g. all uses of it are dynamically dispatched or must be downcasted), and it encourages use of it in the same places that Objective-C does.  Go introduces checked downcasts, which introduce some run-time overhead, but also provide safety compared to Objective-C. Go thankfully introduces a replacement for the imperative constructs in C, which defines away a bunch of C problems that Objective-C inherited, and it certainly is prettier!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; … I can go on about other languages, but I have probably already gotten myself into enough trouble. :-)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; With this as context, lets talk about Swift:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift is another case of a hybrid model: its semantics provide predictability between obviously static (structs, enums, and global funcs) and obviously dynamic (classes, protocols, and closures) constructs.  A focus of Swift (like Java and Javascript) is to provide an apparently simple programming model.  However, Swift also intentionally &quot;cheats&quot; in its global design by mixing in a few tricks to make the dynamic parts of the language optimizable by a static compiler in many common cases, without requiring profiling or other dynamic information..  For example, the Swift compiler can tell if methods in non-public classes are never overridden (and non-public is the default, for a lot of good reasons) - thus treating them as final.  This allows eliminating much of the overhead of dynamic dispatch without requiring a JIT.  Consider an “app”: because it never needs to have non-public classes, this is incredibly powerful - the design of the swift package manager extends this even further (in principle, not done yet) to external libraries. Further, Swift’s generics provide an a static performance model similar to C++ templates in release builds (though I agree we need to do more to really follow through on this) -- while Swift existentials (values of protocol type) provide a balance by giving a highly dynamic model.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The upshot of this is that Swift isn’t squarely in either of the static or dynamic camps: it aims to provide a very predictable performance model (someone writing a bootloader or firmware can stick to using Swift structs and have a simple guarantee of no dynamic overhead or runtime dependence) while also providing an expressive and clean high level programming model - simplifying learning and the common case where programmers don’t care to count cycles.  If anything, I’d say that Swift is an “opportunistic” language, in that it provides a very dynamic “default&quot; programming model, where you don’t have to think about the fact that a static compiler is able to transparently provide great performance - without needing the overhead of a JIT.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Finally, while it is possible that a JIT compiler might be interesting someday in the Swift space, if we do things right, it will never be “worth it” because programmers will have enough ability to reason about performance at their fingertips.  This means that there should be no Java or Javascript-magnitude &quot;performance delta&quot; sitting on the table waiting for a JIT to scoop up.  We’ll see how it works out long term, but I think we’re doing pretty well so far.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; TL;DR: What I’m really getting at is that the old static vs dynamic trope is at the very least only half of the story.  You really need to include the compilation model and thus the resultant programmer model into the story, and the programmer model is what really matters, IMHO.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/612649d2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9ce70a6cb7175e7a5e5db5658186a31?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>Brandon Knope</string> &lt;bknope at me.com&gt;<p>May 20, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On May 20, 2016, at 12:46 PM, David Waite via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 20, 2016, at 10:17 AM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I almost want to propose forbidding methods in protocol extensions unless they&#39;re also a requirement in the protocol itself, but I don&#39;t think that would fly.<br>&gt;&gt; <br>&gt;&gt; Austin<br>&gt; <br>&gt; Thats one option.<br>&gt; <br>&gt; Think two separate developers - only who implements the protocol Foo and has an independent bar() method on their type, and one who writes an extension to Foo to add a bar method on it.<br>&gt; <br>&gt; bar() is not part of the protocol specification. the person implementing the type has no idea that others are expecting his bar() to meet particular requirements, just because it was declared in a protocol extension. <br>&gt; <br></p><p>How is this the case? Don&#39;t you have to expect that others can use your protocol extension since it is visible to them?<br></p><p>I think the static behavior should be an opt in feature so the common case is what everyone expects to happen. <br></p><p><br>&gt; So silently using the type implementor’s bar() method when using Foo is unacceptable. You don’t know if it meets the requirements, because Foo never specified requirements for a bar() method.<br>&gt; <br>&gt; BTW, it would also be dangerous to let an extension make a protocol implement another protocol for similar reasons.<br>&gt; <br>&gt; So, options to solve:<br>&gt; - Having the extension to protocol Foo only apply when dealing in terms of Foo type and not the implementors type. This sounds less useful than what we have today.<br>&gt; - You could have a warning if the compiler sees a Foo extension and a Foo implementation both with bar(). Hopefully the application developer has control over either the protocol definition, the extension, or the implementation of the protocol to try and resolve it.<br>&gt; - forbid protocol extensions adding methods - they can only implement existing methods<br>&gt; - If protocol implementations used “override” (or perhaps a better named keyword for covering this instance as well like “implement”), you could consider protocol extensions to extend the protocol definition more safely. You would also catch the case where the Protocol definition changed to include the same foo() method the implementing type defined independently, so the implementor can make sure their version of foo() meets the requirements the protocol gives.<br>&gt; <br>&gt; -DW<br>&gt;&gt; <br>&gt;&gt;&gt; On May 20, 2016, at 5:56 AM, Fabian Ehrentraud via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; there&#39;s been a little discussion about static vs. dynamic dispatch on this mailing list, and there is a good post about the pitfalls when using attributes defined in extensions [1].<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Having run into this myself during development, is there a plan on how to reduce the pitfalls in future versions of Swift?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Fabian<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; [1] https://developer.ibm.com/swift/2016/01/27/seven-swift-snares-how-to-avoid-them/<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sorry, I understand and appreciate your pragmatism. Right now it feels very much like a fight to the ideological death between POP and OOP and it may get really bad results this way.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 4 Mar 2016, at 08:58, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt;&gt; Brent, why is dynamic dispatching for protocol extension default implementations wrong in your mind? Wouldn&#39;t you agree that when static dispatching introduces such a side effect that it should not be automatically applied and perhaps a keyword should be added if you really wanted static dispatching nonetheless?<br>&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt; &gt;&gt; I think that code execution should not be affected by type casting, it feels like a very confusing part of the language.<br>&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt; &gt; I don&#39;t think dynamic dispatch is wrong; I think it&#39;s a large and technically challenging change. So in the spirit of incrementalism, I was trying to make cautious proposals which kept existing semantics intact but made them clearer, in preparation for perhaps eventually introducing dynamic dispatch. (Basically, I suggested that non-overridable protocol extension members should be marked `final` and it should be illegal to shadow them.)<br>&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt; &gt; But the feedback I got indicated that most people wanted a more aggressive proposal which introduced dynamic dispatch immediately. That&#39;s much harder to propose because it touches on all sorts of runtime implementation details I know nothing about, so I didn&#39;t try to draft a proposal.<br>&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt; &gt; (You are, perhaps inadvertently, currently demonstrating exactly what happened in those previous threads!)<br>&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt; &gt; -- <br>&gt;&gt;&gt;&gt; &gt; Brent Royal-Gordon<br>&gt;&gt;&gt;&gt; &gt; Architechies<br>&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt; On Dec 11, 2015, at 8:56 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt; &gt; You think that Swift prefers virtual dispatch. I think it prefers static.<br>&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt; &gt; I think what&#39;s really going on here is that _in most cases_ there&#39;s no observable difference between static dispatch and virtual dispatch. If you think of Swift as an OOP language with a powerful value-typed system added on, then you&#39;ll probably think Swift prefers virtual dispatch. If you think of Swift as a value-typed language with an OOP layer added, then you&#39;ll probably think Swift prefers static dispatch. In reality, Swift is a hybrid language and it uses different types of dispatch in different situations as appropriate.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (emphasis mine)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I know that this is a bit philosophical, but let me suggest a “next level down” way to look at this.  Static and dynamic are *both* great after all, and if you’re looking to type-cast languages, you need to consider them both in light of their semantics, but also factor in their compilation strategy and the programmer model that they all provide.  Let me give you some examples, but keep in mind that this is a narrow view and just MHO:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. C: Static compilation model, static semantics.  While it does provide indirect function pointers, C does everything possible to punish their use (ever see the non-typedef&#39;d prototype for signal(3/7)?), and is almost always statically compiled.  It provides a very “static centric” programming model.  This is great in terms of predictability - it makes it trivial to “predict” what your code will look like at a machine level.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2. Javascript: Completely dynamic compilation model, completely dynamic semantics.  No one talks about statically compiling javascript, because the result of doing so would be a really really slow executable.  Javascript performance hinges on dynamic profile information to be able to efficiently execute a program.  This provides a very “dynamic centric” programming model, with no ability to understand how your code executes at a machine level.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 3. C++: C++ is a step up from C in terms of introducing dynamism into the model with virtual functions.   Sadly, C++ also provides a hostile model for static optimizability - the existence of placement new prevents a lot of interesting devirtualization opportunities, and generally makes the compiler’s life difficult.  OTOH, like C, C++ provides a very predictable model: C++ programmers assume that C constructs are static, but virtual methods will be dynamically dispatched.  This is correct because (except for narrow cases) the compiler has to use dynamic dispatch for C++ virtual methods.   The good news here is that its dynamism is completely opt in, so C++ preserves all of the predictability, performance, and static-compilability of C while providing a higher level programming model.  If virtual methods are ever actually a performance problem, a C++ programmer has ways to deal with that, directly in their code.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 4. Java: Java makes nearly &quot;everything&quot; an object (no structs or other non-primitive value types), and all methods default to being “virtual” (in the C++ sense).  Java also introduces interfaces, which offer an added dimension on dynamic dispatch.  To cope with this, Java assumes a JIT compilation model, which can use dynamic behavior to de-virtualize the (almost always) monomorphic calls into checked direct calls.  This works out really well in practice, because JIT compilers are great at telling when a program with apparently very dynamic semantics actually have static semantics in practice (e.g. a dynamic call has a single receiver).  OTOH, since the compilation model assumes a JIT, this means that purely “AOT” static compilers (which have no profile information, no knowledge of class loaders, etc) necessarily produce inferior code.  It also means that Java doesn’t “scale down” well to small embedded systems that can’t support a JIT, like a bootloader.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 5) Objective-C: Objective-C provides a hybrid model which favors predictability due to its static compilation model (similar in some ways to C++).  The C-like constructs provide C-like performance, and the “messaging” constructs are never “devirtualized”, so they provide very predictable performance characteristics.  Because it is predictable, if the cost of a message send ever becomes an issue in practice, the programmer has many patterns to deal with it (including &quot;imp caching&quot;, and also including the ability to define the problem away by rewriting code in terms of C constructs).  The end result of this is that programmers write code which use C-level features where performance matters and dynamicism doesn’t, but use ObjC features where dynamicism is important or where performance doesn’t matter.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; While it would be possible to implement a JIT compiler for ObjC, I’d expect the wins to be low, because the “hot” code which may be hinging on these dynamic features is likely to already be optimized by hand.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 6) GoLang: From this narrow discussion and perspective, Go has a hybrid model that has similar characteristics to Objective-C 2013 (which introduced modules, but didn’t yet have generics).  It assumes static compilation and provides a very predictable hybrid programming model.  Its func’s are statically dispatched, but its interfaces are dynamically dispatched.  It doesn’t provide guaranteed dynamic dispatch (or “classes&quot;) like ObjC, but it provides even more dynamic feautres in other areas (e.g. it requires a cycle-collecting garbage collector).  Its &quot;interface{}” type is pretty equivalent to “id” (e.g. all uses of it are dynamically dispatched or must be downcasted), and it encourages use of it in the same places that Objective-C does.  Go introduces checked downcasts, which introduce some run-time overhead, but also provide safety compared to Objective-C. Go thankfully introduces a replacement for the imperative constructs in C, which defines away a bunch of C problems that Objective-C inherited, and it certainly is prettier!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; … I can go on about other languages, but I have probably already gotten myself into enough trouble. :-)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; With this as context, lets talk about Swift:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Swift is another case of a hybrid model: its semantics provide predictability between obviously static (structs, enums, and global funcs) and obviously dynamic (classes, protocols, and closures) constructs.  A focus of Swift (like Java and Javascript) is to provide an apparently simple programming model.  However, Swift also intentionally &quot;cheats&quot; in its global design by mixing in a few tricks to make the dynamic parts of the language optimizable by a static compiler in many common cases, without requiring profiling or other dynamic information..  For example, the Swift compiler can tell if methods in non-public classes are never overridden (and non-public is the default, for a lot of good reasons) - thus treating them as final.  This allows eliminating much of the overhead of dynamic dispatch without requiring a JIT.  Consider an “app”: because it never needs to have non-public classes, this is incredibly powerful - the design of the swift package manager extends this even further (in principle, not done yet) to external libraries. Further, Swift’s generics provide an a static performance model similar to C++ templates in release builds (though I agree we need to do more to really follow through on this) -- while Swift existentials (values of protocol type) provide a balance by giving a highly dynamic model.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The upshot of this is that Swift isn’t squarely in either of the static or dynamic camps: it aims to provide a very predictable performance model (someone writing a bootloader or firmware can stick to using Swift structs and have a simple guarantee of no dynamic overhead or runtime dependence) while also providing an expressive and clean high level programming model - simplifying learning and the common case where programmers don’t care to count cycles.  If anything, I’d say that Swift is an “opportunistic” language, in that it provides a very dynamic “default&quot; programming model, where you don’t have to think about the fact that a static compiler is able to transparently provide great performance - without needing the overhead of a JIT.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Finally, while it is possible that a JIT compiler might be interesting someday in the Swift space, if we do things right, it will never be “worth it” because programmers will have enough ability to reason about performance at their fingertips.  This means that there should be no Java or Javascript-magnitude &quot;performance delta&quot; sitting on the table waiting for a JIT to scoop up.  We’ll see how it works out long term, but I think we’re doing pretty well so far.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; TL;DR: What I’m really getting at is that the old static vs dynamic trope is at the very least only half of the story.  You really need to include the compilation model and thus the resultant programmer model into the story, and the programmer model is what really matters, IMHO.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/9633b5ab/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 20, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On May 20, 2016, at 12:12 PM, Brandon Knope via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; On May 20, 2016, at 12:46 PM, David Waite via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 20, 2016, at 10:17 AM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I almost want to propose forbidding methods in protocol extensions unless they&#39;re also a requirement in the protocol itself, but I don&#39;t think that would fly.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Austin<br>&gt;&gt; <br>&gt;&gt; Thats one option.<br>&gt;&gt; <br>&gt;&gt; Think two separate developers - only who implements the protocol Foo and has an independent bar() method on their type, and one who writes an extension to Foo to add a bar method on it.<br>&gt;&gt; <br>&gt;&gt; bar() is not part of the protocol specification. the person implementing the type has no idea that others are expecting his bar() to meet particular requirements, just because it was declared in a protocol extension. <br>&gt;&gt; <br>&gt; <br>&gt; How is this the case? Don&#39;t you have to expect that others can use your protocol extension since it is visible to them?<br></p><p>If the conforming type is implemented in a separate module from the protocol extension that extension *is not* visible to them.  They would have no expectation that their `bar` method had anything to do with the protocol which *is* visible to them in its originally declared form.<br></p><p>&gt; <br>&gt; I think the static behavior should be an opt in feature so the common case is what everyone expects to happen. <br></p><p>A big part of the problem is that there are different perspectives on what is actually expected.<br></p><p>&gt; <br>&gt; <br>&gt;&gt; So silently using the type implementor’s bar() method when using Foo is unacceptable. You don’t know if it meets the requirements, because Foo never specified requirements for a bar() method.<br>&gt;&gt; <br>&gt;&gt; BTW, it would also be dangerous to let an extension make a protocol implement another protocol for similar reasons.<br>&gt;&gt; <br>&gt;&gt; So, options to solve:<br>&gt;&gt; - Having the extension to protocol Foo only apply when dealing in terms of Foo type and not the implementors type. This sounds less useful than what we have today.<br>&gt;&gt; - You could have a warning if the compiler sees a Foo extension and a Foo implementation both with bar(). Hopefully the application developer has control over either the protocol definition, the extension, or the implementation of the protocol to try and resolve it.<br>&gt;&gt; - forbid protocol extensions adding methods - they can only implement existing methods<br>&gt;&gt; - If protocol implementations used “override” (or perhaps a better named keyword for covering this instance as well like “implement”), you could consider protocol extensions to extend the protocol definition more safely. You would also catch the case where the Protocol definition changed to include the same foo() method the implementing type defined independently, so the implementor can make sure their version of foo() meets the requirements the protocol gives.<br>&gt;&gt; <br>&gt;&gt; -DW<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 20, 2016, at 5:56 AM, Fabian Ehrentraud via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; there&#39;s been a little discussion about static vs. dynamic dispatch on this mailing list, and there is a good post about the pitfalls when using attributes defined in extensions [1].<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Having run into this myself during development, is there a plan on how to reduce the pitfalls in future versions of Swift?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Fabian<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; [1] https://developer.ibm.com/swift/2016/01/27/seven-swift-snares-how-to-avoid-them/ &lt;https://developer.ibm.com/swift/2016/01/27/seven-swift-snares-how-to-avoid-them/&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sorry, I understand and appreciate your pragmatism. Right now it feels very much like a fight to the ideological death between POP and OOP and it may get really bad results this way.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 4 Mar 2016, at 08:58, Brent Royal-Gordon &lt;brent at architechies.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; Brent, why is dynamic dispatching for protocol extension default implementations wrong in your mind? Wouldn&#39;t you agree that when static dispatching introduces such a side effect that it should not be automatically applied and perhaps a keyword should be added if you really wanted static dispatching nonetheless?<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; I think that code execution should not be affected by type casting, it feels like a very confusing part of the language.<br>&gt;&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt;&gt; &gt; I don&#39;t think dynamic dispatch is wrong; I think it&#39;s a large and technically challenging change. So in the spirit of incrementalism, I was trying to make cautious proposals which kept existing semantics intact but made them clearer, in preparation for perhaps eventually introducing dynamic dispatch. (Basically, I suggested that non-overridable protocol extension members should be marked `final` and it should be illegal to shadow them.)<br>&gt;&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt;&gt; &gt; But the feedback I got indicated that most people wanted a more aggressive proposal which introduced dynamic dispatch immediately. That&#39;s much harder to propose because it touches on all sorts of runtime implementation details I know nothing about, so I didn&#39;t try to draft a proposal.<br>&gt;&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt;&gt; &gt; (You are, perhaps inadvertently, currently demonstrating exactly what happened in those previous threads!)<br>&gt;&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt;&gt; &gt; -- <br>&gt;&gt;&gt;&gt;&gt; &gt; Brent Royal-Gordon<br>&gt;&gt;&gt;&gt;&gt; &gt; Architechies<br>&gt;&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt; On Dec 11, 2015, at 8:56 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt;&gt; &gt; You think that Swift prefers virtual dispatch. I think it prefers static.<br>&gt;&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt;&gt; &gt; I think what&#39;s really going on here is that _in most cases_ there&#39;s no observable difference between static dispatch and virtual dispatch. If you think of Swift as an OOP language with a powerful value-typed system added on, then you&#39;ll probably think Swift prefers virtual dispatch. If you think of Swift as a value-typed language with an OOP layer added, then you&#39;ll probably think Swift prefers static dispatch. In reality, Swift is a hybrid language and it uses different types of dispatch in different situations as appropriate.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; (emphasis mine)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I know that this is a bit philosophical, but let me suggest a “next level down” way to look at this.  Static and dynamic are *both* great after all, and if you’re looking to type-cast languages, you need to consider them both in light of their semantics, but also factor in their compilation strategy and the programmer model that they all provide.  Let me give you some examples, but keep in mind that this is a narrow view and just MHO:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 1. C: Static compilation model, static semantics.  While it does provide indirect function pointers, C does everything possible to punish their use (ever see the non-typedef&#39;d prototype for signal(3/7)?), and is almost always statically compiled.  It provides a very “static centric” programming model.  This is great in terms of predictability - it makes it trivial to “predict” what your code will look like at a machine level.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2. Javascript: Completely dynamic compilation model, completely dynamic semantics.  No one talks about statically compiling javascript, because the result of doing so would be a really really slow executable.  Javascript performance hinges on dynamic profile information to be able to efficiently execute a program.  This provides a very “dynamic centric” programming model, with no ability to understand how your code executes at a machine level.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 3. C++: C++ is a step up from C in terms of introducing dynamism into the model with virtual functions.   Sadly, C++ also provides a hostile model for static optimizability - the existence of placement new prevents a lot of interesting devirtualization opportunities, and generally makes the compiler’s life difficult.  OTOH, like C, C++ provides a very predictable model: C++ programmers assume that C constructs are static, but virtual methods will be dynamically dispatched.  This is correct because (except for narrow cases) the compiler has to use dynamic dispatch for C++ virtual methods.   The good news here is that its dynamism is completely opt in, so C++ preserves all of the predictability, performance, and static-compilability of C while providing a higher level programming model.  If virtual methods are ever actually a performance problem, a C++ programmer has ways to deal with that, directly in their code.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 4. Java: Java makes nearly &quot;everything&quot; an object (no structs or other non-primitive value types), and all methods default to being “virtual” (in the C++ sense).  Java also introduces interfaces, which offer an added dimension on dynamic dispatch.  To cope with this, Java assumes a JIT compilation model, which can use dynamic behavior to de-virtualize the (almost always) monomorphic calls into checked direct calls.  This works out really well in practice, because JIT compilers are great at telling when a program with apparently very dynamic semantics actually have static semantics in practice (e.g. a dynamic call has a single receiver).  OTOH, since the compilation model assumes a JIT, this means that purely “AOT” static compilers (which have no profile information, no knowledge of class loaders, etc) necessarily produce inferior code.  It also means that Java doesn’t “scale down” well to small embedded systems that can’t support a JIT, like a bootloader.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 5) Objective-C: Objective-C provides a hybrid model which favors predictability due to its static compilation model (similar in some ways to C++).  The C-like constructs provide C-like performance, and the “messaging” constructs are never “devirtualized”, so they provide very predictable performance characteristics.  Because it is predictable, if the cost of a message send ever becomes an issue in practice, the programmer has many patterns to deal with it (including &quot;imp caching&quot;, and also including the ability to define the problem away by rewriting code in terms of C constructs).  The end result of this is that programmers write code which use C-level features where performance matters and dynamicism doesn’t, but use ObjC features where dynamicism is important or where performance doesn’t matter.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; While it would be possible to implement a JIT compiler for ObjC, I’d expect the wins to be low, because the “hot” code which may be hinging on these dynamic features is likely to already be optimized by hand.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 6) GoLang: From this narrow discussion and perspective, Go has a hybrid model that has similar characteristics to Objective-C 2013 (which introduced modules, but didn’t yet have generics).  It assumes static compilation and provides a very predictable hybrid programming model.  Its func’s are statically dispatched, but its interfaces are dynamically dispatched.  It doesn’t provide guaranteed dynamic dispatch (or “classes&quot;) like ObjC, but it provides even more dynamic feautres in other areas (e.g. it requires a cycle-collecting garbage collector).  Its &quot;interface{}” type is pretty equivalent to “id” (e.g. all uses of it are dynamically dispatched or must be downcasted), and it encourages use of it in the same places that Objective-C does.  Go introduces checked downcasts, which introduce some run-time overhead, but also provide safety compared to Objective-C. Go thankfully introduces a replacement for the imperative constructs in C, which defines away a bunch of C problems that Objective-C inherited, and it certainly is prettier!<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; … I can go on about other languages, but I have probably already gotten myself into enough trouble. :-)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; With this as context, lets talk about Swift:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Swift is another case of a hybrid model: its semantics provide predictability between obviously static (structs, enums, and global funcs) and obviously dynamic (classes, protocols, and closures) constructs.  A focus of Swift (like Java and Javascript) is to provide an apparently simple programming model.  However, Swift also intentionally &quot;cheats&quot; in its global design by mixing in a few tricks to make the dynamic parts of the language optimizable by a static compiler in many common cases, without requiring profiling or other dynamic information..  For example, the Swift compiler can tell if methods in non-public classes are never overridden (and non-public is the default, for a lot of good reasons) - thus treating them as final.  This allows eliminating much of the overhead of dynamic dispatch without requiring a JIT.  Consider an “app”: because it never needs to have non-public classes, this is incredibly powerful - the design of the swift package manager extends this even further (in principle, not done yet) to external libraries. Further, Swift’s generics provide an a static performance model similar to C++ templates in release builds (though I agree we need to do more to really follow through on this) -- while Swift existentials (values of protocol type) provide a balance by giving a highly dynamic model.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The upshot of this is that Swift isn’t squarely in either of the static or dynamic camps: it aims to provide a very predictable performance model (someone writing a bootloader or firmware can stick to using Swift structs and have a simple guarantee of no dynamic overhead or runtime dependence) while also providing an expressive and clean high level programming model - simplifying learning and the common case where programmers don’t care to count cycles.  If anything, I’d say that Swift is an “opportunistic” language, in that it provides a very dynamic “default&quot; programming model, where you don’t have to think about the fact that a static compiler is able to transparently provide great performance - without needing the overhead of a JIT.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Finally, while it is possible that a JIT compiler might be interesting someday in the Swift space, if we do things right, it will never be “worth it” because programmers will have enough ability to reason about performance at their fingertips.  This means that there should be no Java or Javascript-magnitude &quot;performance delta&quot; sitting on the table waiting for a JIT to scoop up.  We’ll see how it works out long term, but I think we’re doing pretty well so far.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; TL;DR: What I’m really getting at is that the old static vs dynamic trope is at the very least only half of the story.  You really need to include the compilation model and thus the resultant programmer model into the story, and the programmer model is what really matters, IMHO.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/2773a567/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 20, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On May 20, 2016, at 9:17 AM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; I almost want to propose forbidding methods in protocol extensions unless they&#39;re also a requirement in the protocol itself, but I don&#39;t think that would fly.<br></p><p>I don’t think that would fly :-).  That said, has anyone considered requiring a keyword on the method in the protocol extension that makes it explicit that the dispatch is non-dynamic?<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3dad7bea24aa580cabe5c16e8e64183e?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>Krystof Vasa</string> &lt;kvasa at icloud.com&gt;<p>May 20, 2016 at 07:00:00pm</p></header><div class="content"><p>How about the other way around, allowing something like this, explicitly specifying the dynamic nature of the function, thus forcing the dynamic dispatch?<br></p><p><br>protocol MyProtocol { }<br></p><p>extension MyProtocol {<br>	dynamic func getInt() -&gt; Int {<br>		return 0<br>	}<br>}<br></p><p>Krystof<br></p><p>&gt; I don’t think that would fly :-).  That said, has anyone considered requiring a keyword on the method in the protocol extension that makes it explicit that the dispatch is non-dynamic?<br>&gt; <br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/991e35a1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9ce70a6cb7175e7a5e5db5658186a31?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>Brandon Knope</string> &lt;bknope at me.com&gt;<p>May 20, 2016 at 01:00:00pm</p></header><div class="content"><p>Because I think the dynamic case is what most people expect and should be the default. The unexpected behavior should be the opt in behavior as you know what you are doing at this point. At least this is my reasoning <br></p><p>Brandon <br></p><p>&gt; On May 20, 2016, at 1:39 PM, Krystof Vasa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; How about the other way around, allowing something like this, explicitly specifying the dynamic nature of the function, thus forcing the dynamic dispatch?<br>&gt; <br>&gt; <br>&gt; protocol MyProtocol { }<br>&gt; <br>&gt; extension MyProtocol {<br>&gt; 	dynamic func getInt() -&gt; Int {<br>&gt; 		return 0<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; Krystof<br>&gt; <br>&gt;&gt; I don’t think that would fly :-).  That said, has anyone considered requiring a keyword on the method in the protocol extension that makes it explicit that the dispatch is non-dynamic?<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/46498a99/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9ce70a6cb7175e7a5e5db5658186a31?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>Brandon Knope</string> &lt;bknope at me.com&gt;<p>May 20, 2016 at 01:00:00pm</p></header><div class="content"><p>I was kind of alluding to this when I said it should be opt in...or at least I thought I mentioned it 😂. <br></p><p>What keyword name could clearly convey this meaning?<br></p><p>Brandon <br></p><p>&gt; On May 20, 2016, at 1:35 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 20, 2016, at 9:17 AM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I almost want to propose forbidding methods in protocol extensions unless they&#39;re also a requirement in the protocol itself, but I don&#39;t think that would fly.<br>&gt; <br>&gt; I don’t think that would fly :-).  That said, has anyone considered requiring a keyword on the method in the protocol extension that makes it explicit that the dispatch is non-dynamic?<br>&gt; <br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9d9d4c769b20cd12b15f4e5b991b4ca5?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>Timothy J. Wood</string> &lt;tjw at omnigroup.com&gt;<p>May 20, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On May 20, 2016, at 10:35 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I don’t think that would fly :-).  That said, has anyone considered requiring a keyword on the method in the protocol extension that makes it explicit that the dispatch is non-dynamic?<br></p><p>This would be fabulous. Of course, if you could mark it dynamic too to get that behavior that would be great, but preventing the error in the first place seems great.<br></p><p>`static` is taken already. `nondynamic`, `direct`, …? `nondynamic` seems the least surprising term to me.<br></p><p>-tim<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 20, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On May 20, 2016, at 12:35 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 20, 2016, at 9:17 AM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I almost want to propose forbidding methods in protocol extensions unless they&#39;re also a requirement in the protocol itself, but I don&#39;t think that would fly.<br>&gt; <br>&gt; I don’t think that would fly :-).  That said, has anyone considered requiring a keyword on the method in the protocol extension that makes it explicit that the dispatch is non-dynamic?<br></p><p>I believe `final` has been discussed previously for this purpose.  IIRC the intent was to *disallow* the type to have its own method with the same signature.  However, that interacts poorly with retroactive conformance which means `final` is probably not best choice.<br></p><p>Before we introduce a keyword I think we should be sure the current semantics are what we plan to stick with.  I haven’t seen any good alternatives proposed, but people do keep bringing up this topic.  The desire is usually to change the semantics, not just clarify the existing semantics.<br></p><p>&gt; <br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>May 20, 2016 at 08:00:00pm</p></header><div class="content"><p>Hello Chris,<br></p><p>I think that it would go along the line of thinking that sees static dispatching as an optimisation that should be either enforced by the developer&#39;s clear and explicit intent or performed automagically only if the compiler is sure of no side effects occurring.<br></p><p>Sent from my iPhone<br></p><p>&gt; On 20 May 2016, at 18:35, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 20, 2016, at 9:17 AM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I almost want to propose forbidding methods in protocol extensions unless they&#39;re also a requirement in the protocol itself, but I don&#39;t think that would fly.<br>&gt; <br>&gt; I don’t think that would fly :-).  That said, has anyone considered requiring a keyword on the method in the protocol extension that makes it explicit that the dispatch is non-dynamic?<br>&gt; <br>&gt; -Chris<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 21, 2016 at 04:00:00am</p></header><div class="content"><p>&gt; That said, has anyone considered requiring a keyword on the method in the protocol extension that makes it explicit that the dispatch is non-dynamic?<br></p><p>Many moons ago, I was pushing to require a `final` keyword on protocol extension methods, which would prevent conforming types from providing their own implementations. It was probably the first thing I worked on. There were long arguments about whether and how you could override the `final`-ness, people kept clamoring for dynamic dispatch, and I ultimately wasn&#39;t able to produce a consensus before I had to turn my attention back towards paying work.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>May 21, 2016 at 02:00:00pm</p></header><div class="content"><p>Making them final is not a good idea. I see the default implementations in protocols as something that should replace the optional methods in @objc protocols. Example - a delegate protocol for table view (either UITableView or NSTableView): How would you represent it in pure non- at objc Swift? If it was a regular protocol, you&#39;d need to implement all the methods.<br></p><p>With default implementations, the default implementation returns a default value and you don&#39;t need to implement this method from the protocol.<br></p><p>You might argue that you mean just the methods declared only in the protocol extension - I see those, however as something that may help subclassing delegated instances. Example:<br></p><p>You have a root class representing some kind of a view - it has a `delegate` property. Then you decide to make a subclass and would like to introduce your own delegate methods on top of those offered by the superclass.<br></p><p>You can subclass the protocol, but Swift won&#39;t let you override the `delegate` property with a different type. So you can create a new property `mySubclassDelegate`, which is horrid, but kinda works.<br></p><p>The other option is to simply extend the original delegate protocol with additional methods with default implementation, which you should be able to override in your conforming class.<br></p><p>In code example:<br></p><p>protocol Delegate {<br>	func myClassDidSomething(obj: MyClass)<br>}<br></p><p>class MyClass {<br>	weak var delegate: Delegate?<br>}<br></p><p>extension Delegate {<br>	func mySubclassDidSomethingElse(obj: MySubclass) { }<br>}<br></p><p>class MySubclass: MyClass { }<br></p><p>This is where I see how this can be very useful in many areas not having it final.<br></p><p>Charlie<br></p><p>&gt; Many moons ago, I was pushing to require a `final` keyword on protocol extension methods, which would prevent conforming types from providing their own implementations. It was probably the first thing I worked on. There were long arguments about whether and how you could override the `final`-ness, people kept clamoring for dynamic dispatch, and I ultimately wasn&#39;t able to produce a consensus before I had to turn my attention back towards paying work.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 21, 2016 at 07:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 21, 2016, at 7:05 AM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Making them final is not a good idea. I see the default implementations in protocols as something that should replace the optional methods in @objc protocols. Example - a delegate protocol for table view (either UITableView or NSTableView): How would you represent it in pure non- at objc Swift? If it was a regular protocol, you&#39;d need to implement all the methods.<br>&gt; <br>&gt; With default implementations, the default implementation returns a default value and you don&#39;t need to implement this method from the protocol.<br></p><p>This thread isn&#39;t default implementations of protocol requirements.  Those are dynamically dispatched.  This thread is about *new* methods introduced in protocol extensions.  These are not dynamically dispatched and exhibit different behavior depending on the static type due to the shadowing issue.<br></p><p>&gt; <br>&gt; You might argue that you mean just the methods declared only in the protocol extension - I see those, however as something that may help subclassing delegated instances. Example:<br>&gt; <br>&gt; You have a root class representing some kind of a view - it has a `delegate` property. Then you decide to make a subclass and would like to introduce your own delegate methods on top of those offered by the superclass.<br>&gt; <br>&gt; You can subclass the protocol, but Swift won&#39;t let you override the `delegate` property with a different type. So you can create a new property `mySubclassDelegate`, which is horrid, but kinda works.<br>&gt; <br>&gt; The other option is to simply extend the original delegate protocol with additional methods with default implementation, which you should be able to override in your conforming class.<br>&gt; <br>&gt; In code example:<br>&gt; <br>&gt; protocol Delegate {<br>&gt;    func myClassDidSomething(obj: MyClass)<br>&gt; }<br>&gt; <br>&gt; class MyClass {<br>&gt;    weak var delegate: Delegate?<br>&gt; }<br>&gt; <br>&gt; extension Delegate {<br>&gt;    func mySubclassDidSomethingElse(obj: MySubclass) { }<br>&gt; }<br>&gt; <br>&gt; class MySubclass: MyClass { }<br>&gt; <br>&gt; This is where I see how this can be very useful in many areas not having it final.<br>&gt; <br>&gt; Charlie<br>&gt; <br>&gt;&gt; Many moons ago, I was pushing to require a `final` keyword on protocol extension methods, which would prevent conforming types from providing their own implementations. It was probably the first thing I worked on. There were long arguments about whether and how you could override the `final`-ness, people kept clamoring for dynamic dispatch, and I ultimately wasn&#39;t able to produce a consensus before I had to turn my attention back towards paying work.<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>May 21, 2016 at 02:00:00pm</p></header><div class="content"><p>Yes, see below. I believe it should work as sketched below. Making the extension default implementations final will prevent from extending the delegate protocols by subclasses (and much more).<br></p><p>IMHO the default dispatch for methods on protocol extensions should be dynamic.<br></p><p>&gt; This thread isn&#39;t default implementations of protocol requirements.  Those are dynamically dispatched.  This thread is about *new* methods introduced in protocol extensions.  These are not dynamically dispatched and exhibit different behavior depending on the static type due to the shadowing issue.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; You might argue that you mean just the methods declared only in the protocol extension - I see those, however as something that may help subclassing delegated instances. Example:<br>&gt;&gt; <br>&gt;&gt; You have a root class representing some kind of a view - it has a `delegate` property. Then you decide to make a subclass and would like to introduce your own delegate methods on top of those offered by the superclass.<br>&gt;&gt; <br>&gt;&gt; You can subclass the protocol, but Swift won&#39;t let you override the `delegate` property with a different type. So you can create a new property `mySubclassDelegate`, which is horrid, but kinda works.<br>&gt;&gt; <br>&gt;&gt; The other option is to simply extend the original delegate protocol with additional methods with default implementation, which you should be able to override in your conforming class.<br>&gt;&gt; <br>&gt;&gt; In code example:<br>&gt;&gt; <br>&gt;&gt; protocol Delegate {<br>&gt;&gt;   func myClassDidSomething(obj: MyClass)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class MyClass {<br>&gt;&gt;   weak var delegate: Delegate?<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension Delegate {<br>&gt;&gt;   func mySubclassDidSomethingElse(obj: MySubclass) { }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class MySubclass: MyClass { }<br>&gt;&gt; <br>&gt;&gt; This is where I see how this can be very useful in many areas not having it final.<br>&gt;&gt; <br>&gt;&gt; Charlie<br>&gt;&gt; <br>&gt;&gt;&gt; Many moons ago, I was pushing to require a `final` keyword on protocol extension methods, which would prevent conforming types from providing their own implementations. It was probably the first thing I worked on. There were long arguments about whether and how you could override the `final`-ness, people kept clamoring for dynamic dispatch, and I ultimately wasn&#39;t able to produce a consensus before I had to turn my attention back towards paying work.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 21, 2016 at 08:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 21, 2016, at 7:17 AM, Charlie Monroe &lt;charlie at charliemonroe.net&gt; wrote:<br>&gt; <br>&gt; Yes, see below. I believe it should work as sketched below. Making the extension default implementations final will prevent from extending the delegate protocols by subclasses (and much more).<br>&gt; <br>&gt; IMHO the default dispatch for methods on protocol extensions should be dynamic.<br></p><p>This has been discussed extensively and is problematic for a number of reasons.  <br></p><p>&gt; <br>&gt;&gt; This thread isn&#39;t default implementations of protocol requirements.  Those are dynamically dispatched.  This thread is about *new* methods introduced in protocol extensions.  These are not dynamically dispatched and exhibit different behavior depending on the static type due to the shadowing issue.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You might argue that you mean just the methods declared only in the protocol extension - I see those, however as something that may help subclassing delegated instances. Example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You have a root class representing some kind of a view - it has a `delegate` property. Then you decide to make a subclass and would like to introduce your own delegate methods on top of those offered by the superclass.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You can subclass the protocol, but Swift won&#39;t let you override the `delegate` property with a different type. So you can create a new property `mySubclassDelegate`, which is horrid, but kinda works.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The other option is to simply extend the original delegate protocol with additional methods with default implementation, which you should be able to override in your conforming class.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In code example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol Delegate {<br>&gt;&gt;&gt;  func myClassDidSomething(obj: MyClass)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class MyClass {<br>&gt;&gt;&gt;  weak var delegate: Delegate?<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Delegate {<br>&gt;&gt;&gt;  func mySubclassDidSomethingElse(obj: MySubclass) { }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class MySubclass: MyClass { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is where I see how this can be very useful in many areas not having it final.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Charlie<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Many moons ago, I was pushing to require a `final` keyword on protocol extension methods, which would prevent conforming types from providing their own implementations. It was probably the first thing I worked on. There were long arguments about whether and how you could override the `final`-ness, people kept clamoring for dynamic dispatch, and I ultimately wasn&#39;t able to produce a consensus before I had to turn my attention back towards paying work.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 21, 2016 at 05:00:00am</p></header><div class="content"><p>&gt; Making them final is not a good idea. I see the default implementations in protocols as something that should replace the optional methods in @objc protocols.<br></p><p>We aren&#39;t discussing default implementations. We&#39;re discussing methods that are listed *only* in the protocol extension, not in the protocol itself. These methods cannot be &quot;overridden&quot; in the way that a defaulted protocol method can be; I think it&#39;s safest to outlaw any attempt to &quot;override&quot; them at all.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>May 21, 2016 at 01:00:00pm</p></header><div class="content"><p>Adding code to what really always sounded to me like pure interfaces/API contracts decoupling functionality from concrete implementation does bring its fair share of headaches, but in your experience is it really something delivering big upsides?<br>I do agree that in both Swift and Java the code in protocols/interfaces ship has long sailed so it is a moot point.<br></p><p>Sent from my iPhone<br></p><p>On 21 May 2016, at 13:25, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; Making them final is not a good idea. I see the default implementations in protocols as something that should replace the optional methods in @objc protocols.<br>&gt; <br>&gt; We aren&#39;t discussing default implementations. We&#39;re discussing methods that are listed *only* in the protocol extension, not in the protocol itself. These methods cannot be &quot;overridden&quot; in the way that a defaulted protocol method can be; I think it&#39;s safest to outlaw any attempt to &quot;override&quot; them at all.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>May 21, 2016 at 03:00:00pm</p></header><div class="content"><p>See the text below the quoted paragraph in my email - I&#39;ve mentioned how extending the protocol can be helpful e.g. in case of delegate protocols - where you may want to extend the protocol in subclasses of the delegated class introducing new methods for the delegate. In such scenarios, forcing them final is not an option.<br></p><p>21. 5. 2016 v 14:25, Brent Royal-Gordon &lt;brent at architechies.com&gt;:<br></p><p>&gt;&gt; Making them final is not a good idea. I see the default implementations in protocols as something that should replace the optional methods in @objc protocols.<br>&gt; <br>&gt; We aren&#39;t discussing default implementations. We&#39;re discussing methods that are listed *only* in the protocol extension, not in the protocol itself. These methods cannot be &quot;overridden&quot; in the way that a defaulted protocol method can be; I think it&#39;s safest to outlaw any attempt to &quot;override&quot; them at all.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 21, 2016 at 08:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 21, 2016, at 8:03 AM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; See the text below the quoted paragraph in my email - I&#39;ve mentioned how extending the protocol can be helpful e.g. in case of delegate protocols - where you may want to extend the protocol in subclasses of the delegated class introducing new methods for the delegate. In such scenarios, forcing them final is not an option.<br></p><p>Nobody is talking about forcing them final.  We are talking about annotating them with a keyword that documents their behavior (which is unintuitive for sure but makes sense when you think through how things work behind the scenes).  <br></p><p>Maybe we will figure out a way to have something better in the future, but until then highlighting the behavior via annotation is a pretty good option.<br></p><p>&gt; <br>&gt; 21. 5. 2016 v 14:25, Brent Royal-Gordon &lt;brent at architechies.com&gt;:<br>&gt; <br>&gt;&gt;&gt; Making them final is not a good idea. I see the default implementations in protocols as something that should replace the optional methods in @objc protocols.<br>&gt;&gt; <br>&gt;&gt; We aren&#39;t discussing default implementations. We&#39;re discussing methods that are listed *only* in the protocol extension, not in the protocol itself. These methods cannot be &quot;overridden&quot; in the way that a defaulted protocol method can be; I think it&#39;s safest to outlaw any attempt to &quot;override&quot; them at all.<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>May 21, 2016 at 03:00:00pm</p></header><div class="content"><p>I was responding to Brent&#39;s mail:<br></p><p>&gt; Many moons ago, I was pushing to require a `final` keyword on protocol extension methods, which would prevent conforming types from providing their own implementations. <br></p><p>Where was proposed to force them to be final and was just trying to provide an example in which the conforming class may want to override them, so forcing them final isn&#39;t a good idea. Sorry about the confusion. I&#39;m generally in favor of a modifier rather than annotation, e.g.<br></p><p>dynamic func myFunc()<br>nondynamic func myFunc()<br></p><p>Dynamic now being just for vars, so perhaps extending it to functions.<br></p><p>21. 5. 2016 v 15:27, Matthew Johnson &lt;matthew at anandabits.com&gt;:<br></p><p>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt;&gt; On May 21, 2016, at 8:03 AM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; See the text below the quoted paragraph in my email - I&#39;ve mentioned how extending the protocol can be helpful e.g. in case of delegate protocols - where you may want to extend the protocol in subclasses of the delegated class introducing new methods for the delegate. In such scenarios, forcing them final is not an option.<br>&gt; <br>&gt; Nobody is talking about forcing them final.  We are talking about annotating them with a keyword that documents their behavior (which is unintuitive for sure but makes sense when you think through how things work behind the scenes).  <br>&gt; <br>&gt; Maybe we will figure out a way to have something better in the future, but until then highlighting the behavior via annotation is a pretty good option.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; 21. 5. 2016 v 14:25, Brent Royal-Gordon &lt;brent at architechies.com&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; Making them final is not a good idea. I see the default implementations in protocols as something that should replace the optional methods in @objc protocols.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We aren&#39;t discussing default implementations. We&#39;re discussing methods that are listed *only* in the protocol extension, not in the protocol itself. These methods cannot be &quot;overridden&quot; in the way that a defaulted protocol method can be; I think it&#39;s safest to outlaw any attempt to &quot;override&quot; them at all.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt; Architechies<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 21, 2016 at 09:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 21, 2016, at 8:56 AM, Charlie Monroe &lt;charlie at charliemonroe.net&gt; wrote:<br>&gt; <br>&gt; I was responding to Brent&#39;s mail:<br>&gt; <br>&gt;&gt; Many moons ago, I was pushing to require a `final` keyword on protocol extension methods, which would prevent conforming types from providing their own implementations. <br>&gt; <br>&gt; Where was proposed to force them to be final and was just trying to provide an example in which the conforming class may want to override them, so forcing them final isn&#39;t a good idea.<br></p><p>Again, nobody ever proposed forcing them final.  The proposal was to use final as a way to document the existing behavior.  <br></p><p>You and many others are asking for a new option of dynamic dispatch of protocol extensions.  We may see this someday but it is not going to happen in Swift 3.<br></p><p>&gt; Sorry about the confusion. I&#39;m generally in favor of a modifier rather than annotation, e.g.<br>&gt; <br>&gt; dynamic func myFunc()<br>&gt; nondynamic func myFunc()<br>&gt; <br>&gt; Dynamic now being just for vars, so perhaps extending it to functions.<br></p><p>By annotation I just meant something indicating behavior.  Your &#39;nondynamic&#39; qualifies, but is not the right term.<br></p><p>&#39;dynamic&#39; in Swift does not just mean dynamic dispatch semantics.  It means always dispatched through the Objective-C runtime.  If it didn&#39;t already have this meaning I would probably like &#39;nondynamic&#39; quite a bit as a more precise alternative.<br></p><p>&gt; <br>&gt; 21. 5. 2016 v 15:27, Matthew Johnson &lt;matthew at anandabits.com&gt;:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt;&gt; On May 21, 2016, at 8:03 AM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; See the text below the quoted paragraph in my email - I&#39;ve mentioned how extending the protocol can be helpful e.g. in case of delegate protocols - where you may want to extend the protocol in subclasses of the delegated class introducing new methods for the delegate. In such scenarios, forcing them final is not an option.<br>&gt;&gt; <br>&gt;&gt; Nobody is talking about forcing them final.  We are talking about annotating them with a keyword that documents their behavior (which is unintuitive for sure but makes sense when you think through how things work behind the scenes).  <br>&gt;&gt; <br>&gt;&gt; Maybe we will figure out a way to have something better in the future, but until then highlighting the behavior via annotation is a pretty good option.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 21. 5. 2016 v 14:25, Brent Royal-Gordon &lt;brent at architechies.com&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Making them final is not a good idea. I see the default implementations in protocols as something that should replace the optional methods in @objc protocols.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We aren&#39;t discussing default implementations. We&#39;re discussing methods that are listed *only* in the protocol extension, not in the protocol itself. These methods cannot be &quot;overridden&quot; in the way that a defaulted protocol method can be; I think it&#39;s safest to outlaw any attempt to &quot;override&quot; them at all.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 21, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt;&gt; Where was proposed to force them to be final and was just trying to provide an example in which the conforming class may want to override them, so forcing them final isn&#39;t a good idea.<br>&gt; <br>&gt; Again, nobody ever proposed forcing them final.  The proposal was to use final as a way to document the existing behavior.  <br></p><p>I *did* propose forcing them final, and I&#39;m still very skeptical that a `nondynamic` keyword that does nothing when you shadow the method is a good idea. People are still going to naïvely try to override these methods and be surprised when it doesn&#39;t work. A `nondynamic` keyword at the original declaration site will help them understand what happened when they&#39;re investigating the bug, but it still seems like this kind of code is so suspect that Swift ought to flag it from the start.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 21, 2016 at 04:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>On May 21, 2016, at 3:16 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br></p><p>&gt;&gt;&gt; Where was proposed to force them to be final and was just trying to provide an example in which the conforming class may want to override them, so forcing them final isn&#39;t a good idea.<br>&gt;&gt; <br>&gt;&gt; Again, nobody ever proposed forcing them final.  The proposal was to use final as a way to document the existing behavior.  <br>&gt; <br>&gt; I *did* propose forcing them final, and I&#39;m still very skeptical that a `nondynamic` keyword that does nothing when you shadow the method is a good idea. People are still going to naïvely try to override these methods and be surprised when it doesn&#39;t work. A `nondynamic` keyword at the original declaration site will help them understand what happened when they&#39;re investigating the bug, but it still seems like this kind of code is so suspect that Swift ought to flag it from the start.<br></p><p>Sorry about that.  Either I didn&#39;t see that or I forgot about it.  Making them &#39;final&#39; causes problems with retroactive modeling.  There are other issues as well but that is the most significant one.<br></p><p>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 21, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; Making them &#39;final&#39; causes problems with retroactive modeling.<br></p><p>Because of that issue, I had an attribute you could use to acknowledge conflicts and disable the error. But this ended up being rather complex: you needed to be able to label a member *or* an extension *or* an import which made a conflicting member and conformance visible in the same place.<br></p><p>Here&#39;s the last draft of the proposal, from way back in December: &lt;https://github.com/brentdax/swift-evolution/blob/final-protocol-methods/proposals/0000-require-final-on-protocol-extension-methods.md&gt;<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 22, 2016 at 02:00:00am</p></header><div class="content"><p>On May 21, 2016, at 11:50 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; Making them &#39;final&#39; causes problems with retroactive modeling.<br>&gt; <br>&gt; Because of that issue, I had an attribute you could use to acknowledge conflicts and disable the error. But this ended up being rather complex: you needed to be able to label a member *or* an extension *or* an import which made a conflicting member and conformance visible in the same place.<br>&gt; <br></p><p>Read the proposal... I have an aversion to-go coffee cups that remind people that hot coffee may burn them, and when my daughter was 4 we explained to her why knives were to be handled with care, rather than remove them all from her sight. IMHO the proposal evoques mandating training wheels rather than letting people learn naturally from their errors.<br></p><p>&gt; Here&#39;s the last draft of the proposal, from way back in December: &lt;https://github.com/brentdax/swift-evolution/blob/final-protocol-methods/proposals/0000-require-final-on-protocol-extension-methods.md&gt;<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 22, 2016 at 09:00:00am</p></header><div class="content"><p>On 22.05.2016 3:01, L. Mihalkovic via swift-evolution wrote:<br>&gt; Read the proposal... I have an aversion to-go coffee cups that remind<br>&gt; people that hot coffee may burn them, and when my daughter was 4 we<br>&gt; explained to her why knives were to be handled with care, rather than<br>&gt; remove them all from her sight. IMHO the proposal evoques mandating<br>&gt; training wheels rather than letting people learn naturally from their<br>&gt; errors.<br></p><p>I can partially support this opinion. But we have a situation with protocol <br>extension methods and static dispatches in which we need Swift&#39;s help on <br>compilation stage. IMO Using your words, right now we just got knife in our <br>hands *without* any explanation. Then we hurt ourselves, and *then* we know <br>that such methods will be dispatched statically(and the rule of dispatch is <br>quite non-obvious). This is another extreme like &quot;remove all knives&quot;. We <br>need some golden middle. Personally I believe the solution is in compiler <br>warning and in some method to &#39;fix&#39; this warning.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b2fc174169a3054f2e9bcb366884b02b?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>Fabian Ehrentraud</string> &lt;Fabian.Ehrentraud at willhaben.at&gt;<p>May 22, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; Am 22.05.2016 um 08:49 schrieb Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt;&gt; On 22.05.2016 3:01, L. Mihalkovic via swift-evolution wrote:<br>&gt;&gt; Read the proposal... I have an aversion to-go coffee cups that remind<br>&gt;&gt; people that hot coffee may burn them, and when my daughter was 4 we<br>&gt;&gt; explained to her why knives were to be handled with care, rather than<br>&gt;&gt; remove them all from her sight. IMHO the proposal evoques mandating<br>&gt;&gt; training wheels rather than letting people learn naturally from their<br>&gt;&gt; errors.<br>&gt; <br>&gt; I can partially support this opinion. But we have a situation with protocol extension methods and static dispatches in which we need Swift&#39;s help on compilation stage. IMO Using your words, right now we just got knife in our hands *without* any explanation. Then we hurt ourselves, and *then* we know that such methods will be dispatched statically(and the rule of dispatch is quite non-obvious). This is another extreme like &quot;remove all knives&quot;. We need some golden middle. Personally I believe the solution is in compiler warning and in some method to &#39;fix&#39; this warning.<br></p><p>In other words, we should declare knives as UnsafePointy things ;-)<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 22, 2016 at 08:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 22, 2016, at 1:49 AM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On 22.05.2016 3:01, L. Mihalkovic via swift-evolution wrote:<br>&gt;&gt; Read the proposal... I have an aversion to-go coffee cups that remind<br>&gt;&gt; people that hot coffee may burn them, and when my daughter was 4 we<br>&gt;&gt; explained to her why knives were to be handled with care, rather than<br>&gt;&gt; remove them all from her sight. IMHO the proposal evoques mandating<br>&gt;&gt; training wheels rather than letting people learn naturally from their<br>&gt;&gt; errors.<br>&gt; <br>&gt; I can partially support this opinion. But we have a situation with protocol extension methods and static dispatches in which we need Swift&#39;s help on compilation stage. IMO Using your words, right now we just got knife in our hands *without* any explanation. Then we hurt ourselves, and *then* we know that such methods will be dispatched statically(and the rule of dispatch is quite non-obvious). This is another extreme like &quot;remove all knives&quot;. We need some golden middle. Personally I believe the solution is in compiler warning and in some method to &#39;fix&#39; this warning.<br></p><p>Why not just make it an error and require an annotation on the extension methods?<br></p><p>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 22, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On May 22, 2016, at 3:15 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt;&gt;&gt; On May 22, 2016, at 1:49 AM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 22.05.2016 3:01, L. Mihalkovic via swift-evolution wrote:<br>&gt;&gt;&gt; Read the proposal... I have an aversion to-go coffee cups that remind<br>&gt;&gt;&gt; people that hot coffee may burn them, and when my daughter was 4 we<br>&gt;&gt;&gt; explained to her why knives were to be handled with care, rather than<br>&gt;&gt;&gt; remove them all from her sight. IMHO the proposal evoques mandating<br>&gt;&gt;&gt; training wheels rather than letting people learn naturally from their<br>&gt;&gt;&gt; errors.<br>&gt;&gt; <br>&gt;&gt; I can partially support this opinion. But we have a situation with protocol extension methods and static dispatches in which we need Swift&#39;s help on compilation stage. IMO Using your words, right now we just got knife in our hands *without* any explanation. Then we hurt ourselves, and *then* we know that such methods will be dispatched statically(and the rule of dispatch is quite non-obvious). This is another extreme like &quot;remove all knives&quot;. We need some golden middle. Personally I believe the solution is in compiler warning and in some method to &#39;fix&#39; this warning.<br>&gt; <br>&gt; Why not just make it an error and require an annotation on the extension methods?<br>&gt; <br></p><p>See   https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160516/018560.html<br>And   https://github.com/lmihalkovic/swift-lang/tree/master/Dispatching.playground<br></p><p><br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 22, 2016 at 10:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 22, 2016, at 8:39 AM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 22, 2016, at 3:15 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 22, 2016, at 1:49 AM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 22.05.2016 3:01, L. Mihalkovic via swift-evolution wrote:<br>&gt;&gt;&gt;&gt; Read the proposal... I have an aversion to-go coffee cups that remind<br>&gt;&gt;&gt;&gt; people that hot coffee may burn them, and when my daughter was 4 we<br>&gt;&gt;&gt;&gt; explained to her why knives were to be handled with care, rather than<br>&gt;&gt;&gt;&gt; remove them all from her sight. IMHO the proposal evoques mandating<br>&gt;&gt;&gt;&gt; training wheels rather than letting people learn naturally from their<br>&gt;&gt;&gt;&gt; errors.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I can partially support this opinion. But we have a situation with protocol extension methods and static dispatches in which we need Swift&#39;s help on compilation stage. IMO Using your words, right now we just got knife in our hands *without* any explanation. Then we hurt ourselves, and *then* we know that such methods will be dispatched statically(and the rule of dispatch is quite non-obvious). This is another extreme like &quot;remove all knives&quot;. We need some golden middle. Personally I believe the solution is in compiler warning and in some method to &#39;fix&#39; this warning.<br>&gt;&gt; <br>&gt;&gt; Why not just make it an error and require an annotation on the extension methods?<br>&gt; <br>&gt; See   https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160516/018560.html<br>&gt; And   https://github.com/lmihalkovic/swift-lang/tree/master/Dispatching.playground<br></p><p>That doesn&#39;t answer my question.  I don&#39;t like any of the suggestions you posted.  I think we should just leave the behavior as is (at least for now) and just require annotations on non-default methods in protocol extensions (making it an error to declare a non-default method without the annotation).<br></p><p><br></p><p>&gt; <br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 22, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On May 22, 2016, at 5:31 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt;&gt; On May 22, 2016, at 8:39 AM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 22, 2016, at 3:15 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 22, 2016, at 1:49 AM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 22.05.2016 3:01, L. Mihalkovic via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt; Read the proposal... I have an aversion to-go coffee cups that remind<br>&gt;&gt;&gt;&gt;&gt; people that hot coffee may burn them, and when my daughter was 4 we<br>&gt;&gt;&gt;&gt;&gt; explained to her why knives were to be handled with care, rather than<br>&gt;&gt;&gt;&gt;&gt; remove them all from her sight. IMHO the proposal evoques mandating<br>&gt;&gt;&gt;&gt;&gt; training wheels rather than letting people learn naturally from their<br>&gt;&gt;&gt;&gt;&gt; errors.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I can partially support this opinion. But we have a situation with protocol extension methods and static dispatches in which we need Swift&#39;s help on compilation stage. IMO Using your words, right now we just got knife in our hands *without* any explanation. Then we hurt ourselves, and *then* we know that such methods will be dispatched statically(and the rule of dispatch is quite non-obvious). This is another extreme like &quot;remove all knives&quot;. We need some golden middle. Personally I believe the solution is in compiler warning and in some method to &#39;fix&#39; this warning.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Why not just make it an error and require an annotation on the extension methods?<br>&gt;&gt; <br>&gt;&gt; See   https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160516/018560.html<br>&gt;&gt; And   https://github.com/lmihalkovic/swift-lang/tree/master/Dispatching.playground<br>&gt; <br>&gt; That doesn&#39;t answer my question.  I don&#39;t like any of the suggestions you posted.  I think we should just leave the behavior as is (at least for now) and just require annotations on non-default methods in protocol extensions (making it an error to declare a non-default method without the annotation).<br>&gt; <br></p><p>Considering how things work fine the way they are today once THEIR logic is understood (the only problem today seems to be one of expectations mismatch, not that something is broken or illogic), it would IMHO be a waste of energy to revisit only to end up with a system that would only support a single model. It something is done, it might as well be to add freedom.<br></p><p>So if you make it optional to have an attribute (I seem to recall chris explicitely saying that annotations were not the idiomatic swift way to convey these types of behavirial adjustments) on non required extension methods, then what you describe is basically one of the proposals I listed.. for a simple reason mind you... what I listed is what I saw people debate. A few options were left out as being too complex to summarize, or not ringing true to what exists today and what has been explained about protocols with great clarity by Dave on stage at WWDC. Interestingly enough, the idea of default methods on the protocol itself (which I like in java8) was already listed by him and at least someone else in the compiler team.<br></p><p>Coming from working in asm, c, c++, perl, tcl, vb, java, c#, js, objc, scala, typescript and go in that order, I can get used to anything as long as its logic seems reasonable and adequately explained.  After reading so many emails I thought I might not be the only one craving a simple one page summary of what had been said so far.<br></p><p><br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>May 22, 2016 at 07:00:00pm</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On 22 May 2016, at 18:36, L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 22, 2016, at 5:31 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt;&gt; On May 22, 2016, at 8:39 AM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 22, 2016, at 3:15 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On May 22, 2016, at 1:49 AM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 22.05.2016 3:01, L. Mihalkovic via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; Read the proposal... I have an aversion to-go coffee cups that remind<br>&gt;&gt;&gt;&gt;&gt;&gt; people that hot coffee may burn them, and when my daughter was 4 we<br>&gt;&gt;&gt;&gt;&gt;&gt; explained to her why knives were to be handled with care, rather than<br>&gt;&gt;&gt;&gt;&gt;&gt; remove them all from her sight. IMHO the proposal evoques mandating<br>&gt;&gt;&gt;&gt;&gt;&gt; training wheels rather than letting people learn naturally from their<br>&gt;&gt;&gt;&gt;&gt;&gt; errors.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I can partially support this opinion. But we have a situation with protocol extension methods and static dispatches in which we need Swift&#39;s help on compilation stage. IMO Using your words, right now we just got knife in our hands *without* any explanation. Then we hurt ourselves, and *then* we know that such methods will be dispatched statically(and the rule of dispatch is quite non-obvious). This is another extreme like &quot;remove all knives&quot;. We need some golden middle. Personally I believe the solution is in compiler warning and in some method to &#39;fix&#39; this warning.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Why not just make it an error and require an annotation on the extension methods?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; See   https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160516/018560.html<br>&gt;&gt;&gt; And   https://github.com/lmihalkovic/swift-lang/tree/master/Dispatching.playground<br>&gt;&gt; <br>&gt;&gt; That doesn&#39;t answer my question.  I don&#39;t like any of the suggestions you posted.  I think we should just leave the behavior as is (at least for now) and just require annotations on non-default methods in protocol extensions (making it an error to declare a non-default method without the annotation).<br>&gt; <br>&gt; Considering how things work fine the way they are today once THEIR logic is understood (the only problem today seems to be one of expectations mismatch, not that something is broken or illogic), it would IMHO be a waste of energy to revisit only to end up with a system that would only support a single model. It something is done, it might as well be to add freedom.<br></p><p>It is logical because by definition it is not a random behaviour and it works as it is not marred by bugs and yes you can make it work (variable amount of pain depending how big he code base is and how many people work on it), but the problem of expectations mismatch and a bit steep learning curve (and probability of submarine errors popping up to haunt future self) is not one that should be swept under the rug.<br></p><p>Part of the problem comes from the desire to put code in protocols/interfaces. Java went full steam ahead with it in Java 8 and Swift did so later on, but I still feel it creates quite a bit of problems, maybe more than it solves. Sure, it is giving life to a new magical paradigm, but all magic comes with a price ;). I may be too defensive about this change,  but I would love to read a very very convincing arguments as to why I would want anything more than methods (or properties maybe, but they are methods too ;)) in a protocol/interface. I thought the point was that behaviour and implementation ought to be decoupled :).<br></p><p><br>One could bends things a bit and say that following a relatively strict TDD approach with genuine unit tests (everything is a mock but the class under test and Apple&#39;s own classes perhaps), integration, and automation tests that Objective-C&#39;s opt-in strictness (hello -Weverything, lightweight generics, nullability annotations, and various annotations like instancetype, NS_REQUIRES_SUPER, NS_DESIGNATED_INITIALIZER, etc...) is more than a safe enough path that gives you the most freedom and runtime responsibility to be used wisely and productively. Cocoa is a wonderful API to write apps with and yes it is not very Swift like and linked to the Objective-C runtime also in style, but perhaps that says something NCOs about both languages. In Objective-C having message sending/dynamic polymorphism by default never introduced illogical or hard to work through behaviour.<br></p><p>&gt; <br>&gt; So if you make it optional to have an attribute (I seem to recall chris explicitely saying that annotations were not the idiomatic swift way to convey these types of behavirial adjustments) on non required extension methods, then what you describe is basically one of the proposals I listed.. for a simple reason mind you... what I listed is what I saw people debate. A few options were left out as being too complex to summarize, or not ringing true to what exists today and what has been explained about protocols with great clarity by Dave on stage at WWDC. Interestingly enough, the idea of default methods on the protocol itself (which I like in java8) was already listed by him and at least someone else in the compiler team.<br>&gt; <br>&gt; Coming from working in asm, c, c++, perl, tcl, vb, java, c#, js, objc, scala, typescript and go in that order, I can get used to anything as long as its logic seems reasonable and adequately explained.  After reading so many emails I thought I might not be the only one craving a simple one page summary of what had been said so far.<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 22, 2016 at 09:00:00pm</p></header><div class="content"><p>Regards<br>(From mobile)<br></p><p>&gt; On May 22, 2016, at 8:03 PM, Goffredo Marocchi &lt;panajev at gmail.com&gt; wrote:<br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt;&gt; On 22 May 2016, at 18:36, L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 22, 2016, at 5:31 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 22, 2016, at 8:39 AM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 22, 2016, at 3:15 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 22, 2016, at 1:49 AM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 22.05.2016 3:01, L. Mihalkovic via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Read the proposal... I have an aversion to-go coffee cups that remind<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; people that hot coffee may burn them, and when my daughter was 4 we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; explained to her why knives were to be handled with care, rather than<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; remove them all from her sight. IMHO the proposal evoques mandating<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; training wheels rather than letting people learn naturally from their<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; errors.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I can partially support this opinion. But we have a situation with protocol extension methods and static dispatches in which we need Swift&#39;s help on compilation stage. IMO Using your words, right now we just got knife in our hands *without* any explanation. Then we hurt ourselves, and *then* we know that such methods will be dispatched statically(and the rule of dispatch is quite non-obvious). This is another extreme like &quot;remove all knives&quot;. We need some golden middle. Personally I believe the solution is in compiler warning and in some method to &#39;fix&#39; this warning.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Why not just make it an error and require an annotation on the extension methods?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; See   https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160516/018560.html<br>&gt;&gt;&gt;&gt; And   https://github.com/lmihalkovic/swift-lang/tree/master/Dispatching.playground<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That doesn&#39;t answer my question.  I don&#39;t like any of the suggestions you posted.  I think we should just leave the behavior as is (at least for now) and just require annotations on non-default methods in protocol extensions (making it an error to declare a non-default method without the annotation).<br>&gt;&gt; <br>&gt;&gt; Considering how things work fine the way they are today once THEIR logic is understood (the only problem today seems to be one of expectations mismatch, not that something is broken or illogic), it would IMHO be a waste of energy to revisit only to end up with a system that would only support a single model. It something is done, it might as well be to add freedom.<br>&gt; <br>&gt; It is logical because by definition it is not a random behaviour and it works as it is not marred by bugs and yes you can make it work (variable amount of pain depending how big he code base is and how many people work on it), but the problem of expectations mismatch and a bit steep learning curve (and probability of submarine errors popping up to haunt future self) is not one that should be swept under the rug.<br>&gt; <br>&gt; Part of the problem comes from the desire to put code in protocols/interfaces. Java went full steam ahead with it in Java 8 and Swift did so later on, but I still feel it creates quite a bit of problems, maybe more than it solves. Sure, it is giving life to a new magical paradigm, but all magic comes with a price ;). I may be too defensive about this change,  but I would love to read a very very convincing arguments as to why I would want anything more than methods (or properties maybe, but they are methods too ;)) in a protocol/interface. I thought the point was that behaviour and implementation ought to be decoupled :).<br>&gt; <br></p><p>Whatch Dave&#39;s presentation at WWDC on protocol based programming, if he does not convince you, then perhaps nobody will. IMHO the ship of why POP has long sailed... Objc is great, and was extremely innovative 30 years ago. Today there is a team of increadibly talented people bringing a new logic to the table, and if anyone is capable of making it work wonderfully for the next 30 years of apple dev, it is them. Our job is to act like sounding boards for where they want to go, not try to stop them or bring everything back to what they have set out to replace.<br></p><p>If you still have questions about methods in protocols, lookup presentations from brian goetz on the topic, or consider how it is a veeery elegant idiomatic swift solution for the problem of optional protocol methods in objc <br></p><p>&gt; <br>&gt; One could bends things a bit and say that following a relatively strict TDD approach with genuine unit tests (everything is a mock but the class under test and Apple&#39;s own classes perhaps), integration, and automation tests that Objective-C&#39;s opt-in strictness (hello -Weverything, lightweight generics, nullability annotations, and various annotations like instancetype, NS_REQUIRES_SUPER, NS_DESIGNATED_INITIALIZER, etc...) is more than a safe enough path that gives you the most freedom and runtime responsibility to be used wisely and productively. Cocoa is a wonderful API to write apps with and yes it is not very Swift like and linked to the Objective-C runtime also in style, but perhaps that says something NCOs about both languages. In Objective-C having message sending/dynamic polymorphism by default never introduced illogical or hard to work through behaviour.<br></p><p>It would be a shame with llvm under the hood to have every single method call resolved against a 13,000 entry hash table today. Ask bertrand serlet what he might have given to have llvm at his disposal when he was working on that part of the runtime.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; So if you make it optional to have an attribute (I seem to recall chris explicitely saying that annotations were not the idiomatic swift way to convey these types of behavirial adjustments) on non required extension methods, then what you describe is basically one of the proposals I listed.. for a simple reason mind you... what I listed is what I saw people debate. A few options were left out as being too complex to summarize, or not ringing true to what exists today and what has been explained about protocols with great clarity by Dave on stage at WWDC. Interestingly enough, the idea of default methods on the protocol itself (which I like in java8) was already listed by him and at least someone else in the compiler team.<br>&gt;&gt; <br>&gt;&gt; Coming from working in asm, c, c++, perl, tcl, vb, java, c#, js, objc, scala, typescript and go in that order, I can get used to anything as long as its logic seems reasonable and adequately explained.  After reading so many emails I thought I might not be the only one craving a simple one page summary of what had been said so far.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 22, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On May 22, 2016, at 12:36 PM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On May 22, 2016, at 5:31 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt;&gt; On May 22, 2016, at 8:39 AM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 22, 2016, at 3:15 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On May 22, 2016, at 1:49 AM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 22.05.2016 3:01, L. Mihalkovic via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; Read the proposal... I have an aversion to-go coffee cups that remind<br>&gt;&gt;&gt;&gt;&gt;&gt; people that hot coffee may burn them, and when my daughter was 4 we<br>&gt;&gt;&gt;&gt;&gt;&gt; explained to her why knives were to be handled with care, rather than<br>&gt;&gt;&gt;&gt;&gt;&gt; remove them all from her sight. IMHO the proposal evoques mandating<br>&gt;&gt;&gt;&gt;&gt;&gt; training wheels rather than letting people learn naturally from their<br>&gt;&gt;&gt;&gt;&gt;&gt; errors.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I can partially support this opinion. But we have a situation with protocol extension methods and static dispatches in which we need Swift&#39;s help on compilation stage. IMO Using your words, right now we just got knife in our hands *without* any explanation. Then we hurt ourselves, and *then* we know that such methods will be dispatched statically(and the rule of dispatch is quite non-obvious). This is another extreme like &quot;remove all knives&quot;. We need some golden middle. Personally I believe the solution is in compiler warning and in some method to &#39;fix&#39; this warning.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Why not just make it an error and require an annotation on the extension methods?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; See   https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160516/018560.html<br>&gt;&gt;&gt; And   https://github.com/lmihalkovic/swift-lang/tree/master/Dispatching.playground<br>&gt;&gt; <br>&gt;&gt; That doesn&#39;t answer my question.  I don&#39;t like any of the suggestions you posted.  I think we should just leave the behavior as is (at least for now) and just require annotations on non-default methods in protocol extensions (making it an error to declare a non-default method without the annotation).<br>&gt;&gt; <br>&gt; <br>&gt; Considering how things work fine the way they are today once THEIR logic is understood (the only problem today seems to be one of expectations mismatch, not that something is broken or illogic), it would IMHO be a waste of energy to revisit only to end up with a system that would only support a single model. It something is done, it might as well be to add freedom.<br>&gt; <br>&gt; So if you make it optional to have an attribute (I seem to recall chris explicitely saying that annotations were not the idiomatic swift way to convey these types of behavirial adjustments) on non required extension methods, then what you describe is basically one of the proposals I listed..<br></p><p>It would be pointless for this to be optional.  The whole point is to have the code reflect the fact that the dispatch semantics are likely to be surprising until you learn the rules (and also if you forget to consider them), and to always keep this fact in our minds as we work with protocol extensions.<br></p><p>Which of your proposals do you think this matches?<br></p><p>1. `override` in implementing classes.<br>2. `straw_man_dynamic_dispatch` at call site.<br>3. `straw_man_dynamic_dispatch` at declaration site in protocol extension.<br>4. doesn’t make sense (we are never going to statically dispatch protocol requirements and we can’t dynamically non-required extension methods in Swift 3)<br>5. `straw_man_default_attribute` on default methods in protocol extensions.<br></p><p>None of these are what I suggest.  What I suggest is that we leave behavior alone and we *don’t* annotate default implementations because those don’t surprise anyone.  I suggest requiring this:<br></p><p>`straw_man_static_dispatch` at declaration site of non-default methods in protocol extensions.  <br></p><p>The only question is what actual modifier we use (`final` and `nondynamic` are obvious candidates, but both are non-starters in my mind for reasons I have stated earlier).<br></p><p>I do think it would be a good idea to introduce this in Swift 3 as it is a breaking change. <br></p><p><br>&gt; for a simple reason mind you... what I listed is what I saw people debate. A few options were left out as being too complex to summarize, or not ringing true to what exists today and what has been explained about protocols with great clarity by Dave on stage at WWDC. Interestingly enough, the idea of default methods on the protocol itself (which I like in java8) was already listed by him and at least someone else in the compiler team.<br>&gt; <br>&gt; Coming from working in asm, c, c++, perl, tcl, vb, java, c#, js, objc, scala, typescript and go in that order, I can get used to anything as long as its logic seems reasonable and adequately explained.  After reading so many emails I thought I might not be the only one craving a simple one page summary of what had been said so far.<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160522/77bb4dac/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 22, 2016 at 01:00:00pm</p></header><div class="content"><p>This is an interesting idea. Here&#39;s another (I&#39;m just spitballing here):<br></p><p>Extension methods without a requirement must be marked with a @nonrequired attribute (names are all provisional).<br></p><p>If a requirement is later added to a protocol with the name of a previously declared nonrequired method, an extension must also be declared marking those method names @required:<br></p><p>protocol Foo { }<br>extension Foo {<br>  @nonrequired func blah(x: Int) { <br>     print(x + 100)<br>  }<br>}<br></p><p>Later:<br></p><p>protocol FooChild : Foo {<br>  func blah(x: Int)<br>}<br></p><p>// requires to compile<br>extension FooChild {<br>  @required blah(x:)<br>}<br></p><p>The only point of this would be to allow it to be made clear to users whether that protocol method is a requirement or not after extensions and retroactive modeling have occurred, and thus help them reason about whether it would be statically or dynamically dispatched. <br></p><p>Austin<br></p><p>Sent from my iPhone<br></p><p>&gt; On May 22, 2016, at 12:53 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On May 22, 2016, at 12:36 PM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On May 22, 2016, at 5:31 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 22, 2016, at 8:39 AM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 22, 2016, at 3:15 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 22, 2016, at 1:49 AM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 22.05.2016 3:01, L. Mihalkovic via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Read the proposal... I have an aversion to-go coffee cups that remind<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; people that hot coffee may burn them, and when my daughter was 4 we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; explained to her why knives were to be handled with care, rather than<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; remove them all from her sight. IMHO the proposal evoques mandating<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; training wheels rather than letting people learn naturally from their<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; errors.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I can partially support this opinion. But we have a situation with protocol extension methods and static dispatches in which we need Swift&#39;s help on compilation stage. IMO Using your words, right now we just got knife in our hands *without* any explanation. Then we hurt ourselves, and *then* we know that such methods will be dispatched statically(and the rule of dispatch is quite non-obvious). This is another extreme like &quot;remove all knives&quot;. We need some golden middle. Personally I believe the solution is in compiler warning and in some method to &#39;fix&#39; this warning.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Why not just make it an error and require an annotation on the extension methods?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; See   https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160516/018560.html<br>&gt;&gt;&gt;&gt; And   https://github.com/lmihalkovic/swift-lang/tree/master/Dispatching.playground<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That doesn&#39;t answer my question.  I don&#39;t like any of the suggestions you posted.  I think we should just leave the behavior as is (at least for now) and just require annotations on non-default methods in protocol extensions (making it an error to declare a non-default method without the annotation).<br>&gt;&gt; <br>&gt;&gt; Considering how things work fine the way they are today once THEIR logic is understood (the only problem today seems to be one of expectations mismatch, not that something is broken or illogic), it would IMHO be a waste of energy to revisit only to end up with a system that would only support a single model. It something is done, it might as well be to add freedom.<br>&gt;&gt; <br>&gt;&gt; So if you make it optional to have an attribute (I seem to recall chris explicitely saying that annotations were not the idiomatic swift way to convey these types of behavirial adjustments) on non required extension methods, then what you describe is basically one of the proposals I listed..<br>&gt; <br>&gt; It would be pointless for this to be optional.  The whole point is to have the code reflect the fact that the dispatch semantics are likely to be surprising until you learn the rules (and also if you forget to consider them), and to always keep this fact in our minds as we work with protocol extensions.<br>&gt; <br>&gt; Which of your proposals do you think this matches?<br>&gt; <br>&gt; 1. `override` in implementing classes.<br>&gt; 2. `straw_man_dynamic_dispatch` at call site.<br>&gt; 3. `straw_man_dynamic_dispatch` at declaration site in protocol extension.<br>&gt; 4. doesn’t make sense (we are never going to statically dispatch protocol requirements and we can’t dynamically non-required extension methods in Swift 3)<br>&gt; 5. `straw_man_default_attribute` on default methods in protocol extensions.<br>&gt; <br>&gt; None of these are what I suggest.  What I suggest is that we leave behavior alone and we *don’t* annotate default implementations because those don’t surprise anyone.  I suggest requiring this:<br>&gt; <br>&gt; `straw_man_static_dispatch` at declaration site of non-default methods in protocol extensions.  <br>&gt; <br>&gt; The only question is what actual modifier we use (`final` and `nondynamic` are obvious candidates, but both are non-starters in my mind for reasons I have stated earlier).<br>&gt; <br>&gt; I do think it would be a good idea to introduce this in Swift 3 as it is a breaking change. <br>&gt; <br>&gt; <br>&gt;&gt; for a simple reason mind you... what I listed is what I saw people debate. A few options were left out as being too complex to summarize, or not ringing true to what exists today and what has been explained about protocols with great clarity by Dave on stage at WWDC. Interestingly enough, the idea of default methods on the protocol itself (which I like in java8) was already listed by him and at least someone else in the compiler team.<br>&gt;&gt; <br>&gt;&gt; Coming from working in asm, c, c++, perl, tcl, vb, java, c#, js, objc, scala, typescript and go in that order, I can get used to anything as long as its logic seems reasonable and adequately explained.  After reading so many emails I thought I might not be the only one craving a simple one page summary of what had been said so far.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160522/ba83100e/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 23, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On May 22, 2016, at 9:53 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On May 22, 2016, at 12:36 PM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On May 22, 2016, at 5:31 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 22, 2016, at 8:39 AM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 22, 2016, at 3:15 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 22, 2016, at 1:49 AM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 22.05.2016 3:01, L. Mihalkovic via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Read the proposal... I have an aversion to-go coffee cups that remind<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; people that hot coffee may burn them, and when my daughter was 4 we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; explained to her why knives were to be handled with care, rather than<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; remove them all from her sight. IMHO the proposal evoques mandating<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; training wheels rather than letting people learn naturally from their<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; errors.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I can partially support this opinion. But we have a situation with protocol extension methods and static dispatches in which we need Swift&#39;s help on compilation stage. IMO Using your words, right now we just got knife in our hands *without* any explanation. Then we hurt ourselves, and *then* we know that such methods will be dispatched statically(and the rule of dispatch is quite non-obvious). This is another extreme like &quot;remove all knives&quot;. We need some golden middle. Personally I believe the solution is in compiler warning and in some method to &#39;fix&#39; this warning.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Why not just make it an error and require an annotation on the extension methods?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; See   https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160516/018560.html<br>&gt;&gt;&gt;&gt; And   https://github.com/lmihalkovic/swift-lang/tree/master/Dispatching.playground<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That doesn&#39;t answer my question.  I don&#39;t like any of the suggestions you posted.  I think we should just leave the behavior as is (at least for now) and just require annotations on non-default methods in protocol extensions (making it an error to declare a non-default method without the annotation).<br>&gt;&gt; <br>&gt;&gt; Considering how things work fine the way they are today once THEIR logic is understood (the only problem today seems to be one of expectations mismatch, not that something is broken or illogic), it would IMHO be a waste of energy to revisit only to end up with a system that would only support a single model. It something is done, it might as well be to add freedom.<br>&gt;&gt; <br>&gt;&gt; So if you make it optional to have an attribute (I seem to recall chris explicitely saying that annotations were not the idiomatic swift way to convey these types of behavirial adjustments) on non required extension methods, then what you describe is basically one of the proposals I listed..<br>&gt; <br>&gt; It would be pointless for this to be optional.  The whole point is to have the code reflect the fact that the dispatch semantics are likely to be surprising until you learn the rules (and also if you forget to consider them), and to always keep this fact in our minds as we work with protocol extensions.<br>&gt; <br>&gt; Which of your proposals do you think this matches?<br>&gt; <br>&gt; 1. `override` in implementing classes.<br>&gt; 2. `straw_man_dynamic_dispatch` at call site.<br>&gt; 3. `straw_man_dynamic_dispatch` at declaration site in protocol extension.<br>&gt; 4. doesn’t make sense (we are never going to statically dispatch protocol requirements and we can’t dynamically non-required extension methods in Swift 3)<br>&gt; 5. `straw_man_default_attribute` on default methods in protocol extensions.<br>&gt; <br>&gt; None of these are what I suggest.  What I suggest is that we leave behavior alone and we *don’t* annotate default implementations because those don’t surprise anyone.  I suggest requiring this:<br>&gt; <br>&gt; `straw_man_static_dispatch` at declaration site of non-default methods in protocol extensions.  <br>&gt; <br></p><p>It truly was not obvious that this is a subset of what 3 is allowing? I debated adding something to the effect of &quot;the attribute is NOT restricted to any particular type of method and can be applied to conformance providing method and/or additional-so-called helper methods&quot;, but thought it was self evident. <br>Although it might be construed as surprising-on-first-encounter, it is statistically impossible that I would be the only person outside the core team who would find the current situation justifiable. I think the POP model is somewhat surprising when considered from a objc or even java viewpoint, but it does make sense when considered by itself, based on the explanations from last year&#39;s (or before) WWDC.<br></p><p>&gt; The only question is what actual modifier we use (`final` and `nondynamic` are obvious candidates, but both are non-starters in my mind for reasons I have stated earlier).<br>&gt; <br>&gt; I do think it would be a good idea to introduce this in Swift 3 as it is a breaking change. <br>&gt; <br></p><p>-1 for the lack of elegance.<br></p><p><br></p><p>&gt; <br>&gt;&gt; for a simple reason mind you... what I listed is what I saw people debate. A few options were left out as being too complex to summarize, or not ringing true to what exists today and what has been explained about protocols with great clarity by Dave on stage at WWDC. Interestingly enough, the idea of default methods on the protocol itself (which I like in java8) was already listed by him and at least someone else in the compiler team.<br>&gt;&gt; <br>&gt;&gt; Coming from working in asm, c, c++, perl, tcl, vb, java, c#, js, objc, scala, typescript and go in that order, I can get used to anything as long as its logic seems reasonable and adequately explained.  After reading so many emails I thought I might not be the only one craving a simple one page summary of what had been said so far.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160523/d4212e41/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 22, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On May 22, 2016, at 5:13 PM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; On May 22, 2016, at 9:53 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 22, 2016, at 12:36 PM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com &lt;mailto:laurent.mihalkovic at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 22, 2016, at 5:31 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 22, 2016, at 8:39 AM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com &lt;mailto:laurent.mihalkovic at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On May 22, 2016, at 3:15 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 22, 2016, at 1:49 AM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 22.05.2016 3:01, L. Mihalkovic via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Read the proposal... I have an aversion to-go coffee cups that remind<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; people that hot coffee may burn them, and when my daughter was 4 we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; explained to her why knives were to be handled with care, rather than<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; remove them all from her sight. IMHO the proposal evoques mandating<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; training wheels rather than letting people learn naturally from their<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; errors.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I can partially support this opinion. But we have a situation with protocol extension methods and static dispatches in which we need Swift&#39;s help on compilation stage. IMO Using your words, right now we just got knife in our hands *without* any explanation. Then we hurt ourselves, and *then* we know that such methods will be dispatched statically(and the rule of dispatch is quite non-obvious). This is another extreme like &quot;remove all knives&quot;. We need some golden middle. Personally I believe the solution is in compiler warning and in some method to &#39;fix&#39; this warning.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Why not just make it an error and require an annotation on the extension methods?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; See   https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160516/018560.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160516/018560.html&gt;<br>&gt;&gt;&gt;&gt;&gt; And   https://github.com/lmihalkovic/swift-lang/tree/master/Dispatching.playground &lt;https://github.com/lmihalkovic/swift-lang/tree/master/Dispatching.playground&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That doesn&#39;t answer my question.  I don&#39;t like any of the suggestions you posted.  I think we should just leave the behavior as is (at least for now) and just require annotations on non-default methods in protocol extensions (making it an error to declare a non-default method without the annotation).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Considering how things work fine the way they are today once THEIR logic is understood (the only problem today seems to be one of expectations mismatch, not that something is broken or illogic), it would IMHO be a waste of energy to revisit only to end up with a system that would only support a single model. It something is done, it might as well be to add freedom.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So if you make it optional to have an attribute (I seem to recall chris explicitely saying that annotations were not the idiomatic swift way to convey these types of behavirial adjustments) on non required extension methods, then what you describe is basically one of the proposals I listed.. <br>&gt;&gt; <br>&gt;&gt; It would be pointless for this to be optional.  The whole point is to have the code reflect the fact that the dispatch semantics are likely to be surprising until you learn the rules (and also if you forget to consider them), and to always keep this fact in our minds as we work with protocol extensions.<br>&gt;&gt; <br>&gt;&gt; Which of your proposals do you think this matches?<br>&gt;&gt; <br>&gt;&gt; 1. `override` in implementing classes.<br>&gt;&gt; 2. `straw_man_dynamic_dispatch` at call site.<br>&gt;&gt; 3. `straw_man_dynamic_dispatch` at declaration site in protocol extension.<br>&gt;&gt; 4. doesn’t make sense (we are never going to statically dispatch protocol requirements and we can’t dynamically non-required extension methods in Swift 3)<br>&gt;&gt; 5. `straw_man_default_attribute` on default methods in protocol extensions.<br>&gt;&gt; <br>&gt;&gt; None of these are what I suggest.  What I suggest is that we leave behavior alone and we *don’t* annotate default implementations because those don’t surprise anyone.  I suggest requiring this:<br>&gt;&gt; <br>&gt;&gt; `straw_man_static_dispatch` at declaration site of non-default methods in protocol extensions.  <br>&gt;&gt; <br>&gt; <br>&gt; It truly was not obvious that this is a subset of what 3 is allowing? I debated adding something to the effect of &quot;the attribute is NOT restricted to any particular type of method and can be applied to conformance providing method and/or additional-so-called helper methods&quot;, but thought it was self evident. <br>&gt; Although it might be construed as surprising-on-first-encounter, it is statistically impossible that I would be the only person outside the core team who would find the current situation justifiable. I think the POP model is somewhat surprising when considered from a objc or even java viewpoint, but it does make sense when considered by itself, based on the explanations from last year&#39;s (or before) WWDC.<br>&gt; <br>&gt;&gt; The only question is what actual modifier we use (`final` and `nondynamic` are obvious candidates, but both are non-starters in my mind for reasons I have stated earlier).<br>&gt;&gt; <br>&gt;&gt; I do think it would be a good idea to introduce this in Swift 3 as it is a breaking change. <br>&gt;&gt; <br>&gt; <br>&gt; -1 for the lack of elegance.<br></p><p>Lack of elegance?  Can you elaborate?  But IMHO elegance isn’t what we’re striving for here anyway.  The fact that we need to do something at all is already rather inelegant.  But it is what it is.<br></p><p>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; for a simple reason mind you... what I listed is what I saw people debate. A few options were left out as being too complex to summarize, or not ringing true to what exists today and what has been explained about protocols with great clarity by Dave on stage at WWDC. Interestingly enough, the idea of default methods on the protocol itself (which I like in java8) was already listed by him and at least someone else in the compiler team.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Coming from working in asm, c, c++, perl, tcl, vb, java, c#, js, objc, scala, typescript and go in that order, I can get used to anything as long as its logic seems reasonable and adequately explained.  After reading so many emails I thought I might not be the only one craving a simple one page summary of what had been said so far.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160522/c6d3ea8d/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 22, 2016 at 08:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>On May 21, 2016, at 4:50 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br></p><p>&gt;&gt; Making them &#39;final&#39; causes problems with retroactive modeling.<br>&gt; <br>&gt; Because of that issue, I had an attribute you could use to acknowledge conflicts and disable the error. But this ended up being rather complex: you needed to be able to label a member *or* an extension *or* an import which made a conflicting member and conformance visible in the same place.<br>&gt; <br>&gt; Here&#39;s the last draft of the proposal, from way back in December: &lt;https://github.com/brentdax/swift-evolution/blob/final-protocol-methods/proposals/0000-require-final-on-protocol-extension-methods.md&gt;<br></p><p>Now I remember this thread.  Swift evolution was so active at the time that I think I didn&#39;t follow it too closely.<br></p><p>The proposal is well thought out and makes a valiant attempt at handling all of the issues necessary.  But I don&#39;t support it for a number of reasons.  I think it highlights how awkward it would be to try to address shadowing on a case-by-case basis, which isn&#39;t necessarily obvious until you explore what a solution might look like.  (And btw, &#39;final&#39; in this proposal is not exactly, because when combined with @incoherent the methods are not actually &#39;final&#39; - there is a necessary escape hatch).<br></p><p>There are two things we should do to help reduce confusion around this.  First, we should allow default implementations in the protocol declaration itself (I believe this is intended and is considered an implement ion limitation right now).  <br></p><p>Second, we should require annotation of methods in protocol extensions that are not default implementation of requirements.  Maybe &#39;shadowable&#39; or &#39;staticdispatch&#39;?  These are awkward, but so is the behavior and they describe it better than anything else I&#39;ve seen so far (maybe we can do better though).<br></p><p>I don&#39;t like &#39;nondynamic&#39; both because it is not aligned with the meaning of &#39;dynamic&#39; and also because it only says what the behavior *is not* rather than what the behavior *is*.<br></p><p>-Matthew<br></p><p>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 22, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; The proposal is well thought out and makes a valiant attempt at handling all of the issues necessary.  But I don&#39;t support it for a number of reasons.  I think it highlights how awkward it would be to try to address shadowing on a case-by-case basis, which isn&#39;t necessarily obvious until you explore what a solution might look like.<br></p><p>It does, but I&#39;m just not sure what else you can do about it. If there&#39;s a warning, you need a way to silence it. If you ignore some cases (like creating a conflict by importing two modules), you&#39;ll miss some of the subtlest and hardest-to-fix bugs.<br></p><p>Honestly, I&#39;m tempted to say &quot;you just can&#39;t ever shadow a final protocol method&quot; and be done with it. If that prevents certain conformances or stops certain imports, so be it. You can always work around that with wrapper types or other techniques.<br></p><p>&gt; (And btw, &#39;final&#39; in this proposal is not exactly, because when combined with @incoherent the methods are not actually &#39;final&#39; - there is a necessary escape hatch).<br></p><p>There is no particular reason you couldn&#39;t allow similar annotated shadowing of `final` methods on classes; they would have basically the same semantics as you get here, where if a piece of code knows it&#39;s working with the subclass you get subclass semantics, but otherwise you get superclass ones. I do not claim this is a good idea. :^)<br></p><p>&gt; Second, we should require annotation of methods in protocol extensions that are not default implementation of requirements.  Maybe &#39;shadowable&#39; or &#39;staticdispatch&#39;?  These are awkward, but so is the behavior and they describe it better than anything else I&#39;ve seen so far (maybe we can do better though).<br></p><p>I don&#39;t think `shadowable` makes sense here; that doesn&#39;t acknowledge a limitation, which is what we&#39;re trying to do here.<br></p><p>I continue to wish we hadn&#39;t taken `static` for statically-dispatched type methods. But I lost that argument years before swift-evolution became a thing.<br></p><p>&gt; I don&#39;t like &#39;nondynamic&#39; both because it is not aligned with the meaning of &#39;dynamic&#39; and also because it only says what the behavior *is not* rather than what the behavior *is*.<br></p><p>I do understand what you mean here. Unfortunately, the word &quot;virtual&quot; in a keyword makes me break out in hives, and I&#39;m not sure what else we might base it on.<br></p><p>This is why I selected `final` in my proposal. `final` is desperately close to the actual semantic here, far closer than anything else in the language.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May 22, 2016 at 04:00:00pm</p></header><div class="content"><p>On Sun, May 22, 2016 at 3:38 PM, Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; The proposal is well thought out and makes a valiant attempt at handling<br>&gt; all of the issues necessary.  But I don&#39;t support it for a number of<br>&gt; reasons.  I think it highlights how awkward it would be to try to address<br>&gt; shadowing on a case-by-case basis, which isn&#39;t necessarily obvious until<br>&gt; you explore what a solution might look like.<br>&gt;<br>&gt; It does, but I&#39;m just not sure what else you can do about it. If there&#39;s a<br>&gt; warning, you need a way to silence it. If you ignore some cases (like<br>&gt; creating a conflict by importing two modules), you&#39;ll miss some of the<br>&gt; subtlest and hardest-to-fix bugs.<br>&gt;<br>&gt; Honestly, I&#39;m tempted to say &quot;you just can&#39;t ever shadow a final protocol<br>&gt; method&quot; and be done with it. If that prevents certain conformances or stops<br>&gt; certain imports, so be it. You can always work around that with wrapper<br>&gt; types or other techniques.<br>&gt;<br></p><p>You know, I think this might be cleverest solution. It adds a small limit<br>to the language, but it doesn&#39;t unduly penalize retroactive modeling. If<br>you control either the protocol or the conforming type, you can change the<br>name of one of the methods so it doesn&#39;t shadow/get shadowed by the other.<br></p><p><br>&gt;<br>&gt; &gt; (And btw, &#39;final&#39; in this proposal is not exactly, because when combined<br>&gt; with @incoherent the methods are not actually &#39;final&#39; - there is a<br>&gt; necessary escape hatch).<br>&gt;<br>&gt; There is no particular reason you couldn&#39;t allow similar annotated<br>&gt; shadowing of `final` methods on classes; they would have basically the same<br>&gt; semantics as you get here, where if a piece of code knows it&#39;s working with<br>&gt; the subclass you get subclass semantics, but otherwise you get superclass<br>&gt; ones. I do not claim this is a good idea. :^)<br>&gt;<br>&gt; &gt; Second, we should require annotation of methods in protocol extensions<br>&gt; that are not default implementation of requirements.  Maybe &#39;shadowable&#39; or<br>&gt; &#39;staticdispatch&#39;?  These are awkward, but so is the behavior and they<br>&gt; describe it better than anything else I&#39;ve seen so far (maybe we can do<br>&gt; better though).<br>&gt;<br>&gt; I don&#39;t think `shadowable` makes sense here; that doesn&#39;t acknowledge a<br>&gt; limitation, which is what we&#39;re trying to do here.<br>&gt;<br>&gt; I continue to wish we hadn&#39;t taken `static` for statically-dispatched type<br>&gt; methods. But I lost that argument years before swift-evolution became a<br>&gt; thing.<br>&gt;<br>&gt; &gt; I don&#39;t like &#39;nondynamic&#39; both because it is not aligned with the<br>&gt; meaning of &#39;dynamic&#39; and also because it only says what the behavior *is<br>&gt; not* rather than what the behavior *is*.<br>&gt;<br>&gt; I do understand what you mean here. Unfortunately, the word &quot;virtual&quot; in a<br>&gt; keyword makes me break out in hives, and I&#39;m not sure what else we might<br>&gt; base it on.<br>&gt;<br>&gt; This is why I selected `final` in my proposal. `final` is desperately<br>&gt; close to the actual semantic here, far closer than anything else in the<br>&gt; language.<br>&gt;<br></p><p>How about `nonoverridable`? That said, I agree with earlier comments that<br>training-wheel annotations probably aren&#39;t the way to go. Maybe, as you<br>suggest above, just don&#39;t allow shadowing at all.<br></p><p><br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160522/1cad461b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 22, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On May 22, 2016, at 4:22 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Sun, May 22, 2016 at 3:38 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt; The proposal is well thought out and makes a valiant attempt at handling all of the issues necessary.  But I don&#39;t support it for a number of reasons.  I think it highlights how awkward it would be to try to address shadowing on a case-by-case basis, which isn&#39;t necessarily obvious until you explore what a solution might look like.<br>&gt; <br>&gt; It does, but I&#39;m just not sure what else you can do about it. If there&#39;s a warning, you need a way to silence it. If you ignore some cases (like creating a conflict by importing two modules), you&#39;ll miss some of the subtlest and hardest-to-fix bugs.<br>&gt; <br>&gt; Honestly, I&#39;m tempted to say &quot;you just can&#39;t ever shadow a final protocol method&quot; and be done with it. If that prevents certain conformances or stops certain imports, so be it. You can always work around that with wrapper types or other techniques.<br>&gt; <br>&gt; You know, I think this might be cleverest solution. It adds a small limit to the language, but it doesn&#39;t unduly penalize retroactive modeling. If you control either the protocol or the conforming type, you can change the name of one of the methods so it doesn&#39;t shadow/get shadowed by the other.<br></p><p>If you control the conforming type this isn’t too big an issue as long as the protocol was well designed.  However, if the protocol was poorly designed it could be an issue.  Maybe a method that can be more efficiently implemented by some types was not made a requirement, but an extension method (with a slower implementation) takes the obvious name.  Maybe you would be willing to live with the slower implementation when your type is accessed via the protocol, because at least it can still be used via the protocol, but you don’t want to burden callers who use the concrete type with the slow implementation.  What do you do then?  <br></p><p>If you control the protocol but want to retroactively model types you do not control this assumes you are willing to design your protocol around those types.  What if one of those types happens to implement a method that should not be a requirement of the protocol for one reason or another, but will be implemented as an extension method.  What do you do then?<br></p><p>And of course there are cases where you do not control either.   Some people write code with a lot of 3rd party dependencies these days (not my style, but pretty common).  This is not a trivial concern.<br></p><p>&gt;  <br>&gt; <br>&gt; &gt; (And btw, &#39;final&#39; in this proposal is not exactly, because when combined with @incoherent the methods are not actually &#39;final&#39; - there is a necessary escape hatch).<br>&gt; <br>&gt; There is no particular reason you couldn&#39;t allow similar annotated shadowing of `final` methods on classes; they would have basically the same semantics as you get here, where if a piece of code knows it&#39;s working with the subclass you get subclass semantics, but otherwise you get superclass ones. I do not claim this is a good idea. :^)<br>&gt; <br>&gt; &gt; Second, we should require annotation of methods in protocol extensions that are not default implementation of requirements.  Maybe &#39;shadowable&#39; or &#39;staticdispatch&#39;?  These are awkward, but so is the behavior and they describe it better than anything else I&#39;ve seen so far (maybe we can do better though).<br>&gt; <br>&gt; I don&#39;t think `shadowable` makes sense here; that doesn&#39;t acknowledge a limitation, which is what we&#39;re trying to do here.<br>&gt; <br>&gt; I continue to wish we hadn&#39;t taken `static` for statically-dispatched type methods. But I lost that argument years before swift-evolution became a thing.<br>&gt; <br>&gt; &gt; I don&#39;t like &#39;nondynamic&#39; both because it is not aligned with the meaning of &#39;dynamic&#39; and also because it only says what the behavior *is not* rather than what the behavior *is*.<br>&gt; <br>&gt; I do understand what you mean here. Unfortunately, the word &quot;virtual&quot; in a keyword makes me break out in hives, and I&#39;m not sure what else we might base it on.<br>&gt; <br>&gt; This is why I selected `final` in my proposal. `final` is desperately close to the actual semantic here, far closer than anything else in the language.<br>&gt; <br>&gt; How about `nonoverridable`? That said, I agree with earlier comments that training-wheel annotations probably aren&#39;t the way to go. Maybe, as you suggest above, just don&#39;t allow shadowing at all.<br></p><p>Unfortunately, ‘nonoverridable’ doesn’t really make sense because you don’t ‘override’ protocol requirements.<br></p><p>&gt;  <br>&gt; <br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160522/dcb80973/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May 22, 2016 at 11:00:00pm</p></header><div class="content"><p>On Sun, May 22, 2016 at 11:20 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt; On May 22, 2016, at 4:22 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Sun, May 22, 2016 at 3:38 PM, Brent Royal-Gordon via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; &gt; The proposal is well thought out and makes a valiant attempt at<br>&gt;&gt; handling all of the issues necessary.  But I don&#39;t support it for a number<br>&gt;&gt; of reasons.  I think it highlights how awkward it would be to try to<br>&gt;&gt; address shadowing on a case-by-case basis, which isn&#39;t necessarily obvious<br>&gt;&gt; until you explore what a solution might look like.<br>&gt;&gt;<br>&gt;&gt; It does, but I&#39;m just not sure what else you can do about it. If there&#39;s<br>&gt;&gt; a warning, you need a way to silence it. If you ignore some cases (like<br>&gt;&gt; creating a conflict by importing two modules), you&#39;ll miss some of the<br>&gt;&gt; subtlest and hardest-to-fix bugs.<br>&gt;&gt;<br>&gt;&gt; Honestly, I&#39;m tempted to say &quot;you just can&#39;t ever shadow a final protocol<br>&gt;&gt; method&quot; and be done with it. If that prevents certain conformances or stops<br>&gt;&gt; certain imports, so be it. You can always work around that with wrapper<br>&gt;&gt; types or other techniques.<br>&gt;&gt;<br>&gt;<br>&gt; You know, I think this might be cleverest solution. It adds a small limit<br>&gt; to the language, but it doesn&#39;t unduly penalize retroactive modeling. If<br>&gt; you control either the protocol or the conforming type, you can change the<br>&gt; name of one of the methods so it doesn&#39;t shadow/get shadowed by the other.<br>&gt;<br>&gt;<br>&gt; If you control the conforming type this isn’t too big an issue as long as<br>&gt; the protocol was well designed.  However, if the protocol was poorly<br>&gt; designed it could be an issue.  Maybe a method that can be more efficiently<br>&gt; implemented by some types was not made a requirement, but an extension<br>&gt; method (with a slower implementation) takes the obvious name.  Maybe you<br>&gt; would be willing to live with the slower implementation when your type is<br>&gt; accessed via the protocol, because at least it can still be used via the<br>&gt; protocol, but you don’t want to burden callers who use the concrete type<br>&gt; with the slow implementation.  What do you do then?<br>&gt;<br></p><p>If a method that really ought to be a protocol requirement isn&#39;t a<br>requirement and you don&#39;t control the protocol, well you&#39;re pretty much out<br>of luck even today. Any conforming type accessed via the protocol will use<br>the less efficient extension method and nothing about Brent&#39;s proposal<br>would make that worse or better.<br></p><p>Shadowing of the slow extension method doesn&#39;t remove the burden. It may<br>make calling your fast implementation look nicer, but a less informed user<br>of your type would unwittingly call the slower implementation if they<br>access your type via the protocol. You could instead:<br>* come up with another name for your fast implementation; maybe the<br>&quot;obvious&quot; name for the method is &quot;frobnicate&quot;--then name your method<br>&quot;quicklyFrobnicate&quot;;<br>* or, decide you don&#39;t want to conform your type to a poorly designed<br>protocol after all, instead retroactively modeling your type and other<br>types of interest with a better designed protocol of your making.<br></p><p><br>&gt; If you control the protocol but want to retroactively model types you do<br>&gt; not control this assumes you are willing to design your protocol around<br>&gt; those types.  What if one of those types happens to implement a method that<br>&gt; should not be a requirement of the protocol for one reason or another, but<br>&gt; will be implemented as an extension method.  What do you do then?<br>&gt;<br></p><p>I&#39;m not sure I quite understand when this arises. Surely, by construction,<br>if you wish to retroactively model types, you are willing to design your<br>protocol around them. What else could it mean to retroactively model<br>existing types? Can you give a concrete example where during retroactively<br>modeling you simply have no choice but to name an extension method using a<br>name that it is shadowed by a conforming type?<br></p><p><br>&gt; And of course there are cases where you do not control either.   Some<br>&gt; people write code with a lot of 3rd party dependencies these days (not my<br>&gt; style, but pretty common).  This is not a trivial concern.<br>&gt;<br></p><p>You are saying that it would be possible for a protocol extension in one<br>dependency to conflict with a conforming type in another? This issue can be<br>avoided if enforcement of non-shadowing by the compiler is such that when<br>neither conforming type nor protocol extension is under your control<br>everything continues to work as-is.<br></p><p>&gt;<br>&gt;&gt; &gt; (And btw, &#39;final&#39; in this proposal is not exactly, because when<br>&gt;&gt; combined with @incoherent the methods are not actually &#39;final&#39; - there is a<br>&gt;&gt; necessary escape hatch).<br>&gt;&gt;<br>&gt;&gt; There is no particular reason you couldn&#39;t allow similar annotated<br>&gt;&gt; shadowing of `final` methods on classes; they would have basically the same<br>&gt;&gt; semantics as you get here, where if a piece of code knows it&#39;s working with<br>&gt;&gt; the subclass you get subclass semantics, but otherwise you get superclass<br>&gt;&gt; ones. I do not claim this is a good idea. :^)<br>&gt;&gt;<br>&gt;&gt; &gt; Second, we should require annotation of methods in protocol extensions<br>&gt;&gt; that are not default implementation of requirements.  Maybe &#39;shadowable&#39; or<br>&gt;&gt; &#39;staticdispatch&#39;?  These are awkward, but so is the behavior and they<br>&gt;&gt; describe it better than anything else I&#39;ve seen so far (maybe we can do<br>&gt;&gt; better though).<br>&gt;&gt;<br>&gt;&gt; I don&#39;t think `shadowable` makes sense here; that doesn&#39;t acknowledge a<br>&gt;&gt; limitation, which is what we&#39;re trying to do here.<br>&gt;&gt;<br>&gt;&gt; I continue to wish we hadn&#39;t taken `static` for statically-dispatched<br>&gt;&gt; type methods. But I lost that argument years before swift-evolution became<br>&gt;&gt; a thing.<br>&gt;&gt;<br>&gt;&gt; &gt; I don&#39;t like &#39;nondynamic&#39; both because it is not aligned with the<br>&gt;&gt; meaning of &#39;dynamic&#39; and also because it only says what the behavior *is<br>&gt;&gt; not* rather than what the behavior *is*.<br>&gt;&gt;<br>&gt;&gt; I do understand what you mean here. Unfortunately, the word &quot;virtual&quot; in<br>&gt;&gt; a keyword makes me break out in hives, and I&#39;m not sure what else we might<br>&gt;&gt; base it on.<br>&gt;&gt;<br>&gt;&gt; This is why I selected `final` in my proposal. `final` is desperately<br>&gt;&gt; close to the actual semantic here, far closer than anything else in the<br>&gt;&gt; language.<br>&gt;&gt;<br>&gt;<br>&gt; How about `nonoverridable`? That said, I agree with earlier comments that<br>&gt; training-wheel annotations probably aren&#39;t the way to go. Maybe, as you<br>&gt; suggest above, just don&#39;t allow shadowing at all.<br>&gt;<br>&gt;<br>&gt; Unfortunately, ‘nonoverridable’ doesn’t really make sense because you<br>&gt; don’t ‘override’ protocol requirements.<br>&gt;<br></p><p>You don&#39;t override protocol requirements, but you do override their default<br>implementations, whereas you cannot &#39;override&#39; statically dispatched<br>extension methods. Within a protocol extension, there are methods that are<br>overridable by conforming types (i.e. default implementations of protocol<br>requirements) and methods that are not (i.e. statically dispatched<br>non-requirements).<br></p><p><br>&gt;&gt; --<br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160522/ce5ca8dc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 23, 2016 at 06:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 22, 2016, at 11:55 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Sun, May 22, 2016 at 11:20 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On May 22, 2016, at 4:22 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Sun, May 22, 2016 at 3:38 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt; The proposal is well thought out and makes a valiant attempt at handling all of the issues necessary.  But I don&#39;t support it for a number of reasons.  I think it highlights how awkward it would be to try to address shadowing on a case-by-case basis, which isn&#39;t necessarily obvious until you explore what a solution might look like.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It does, but I&#39;m just not sure what else you can do about it. If there&#39;s a warning, you need a way to silence it. If you ignore some cases (like creating a conflict by importing two modules), you&#39;ll miss some of the subtlest and hardest-to-fix bugs.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Honestly, I&#39;m tempted to say &quot;you just can&#39;t ever shadow a final protocol method&quot; and be done with it. If that prevents certain conformances or stops certain imports, so be it. You can always work around that with wrapper types or other techniques.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You know, I think this might be cleverest solution. It adds a small limit to the language, but it doesn&#39;t unduly penalize retroactive modeling. If you control either the protocol or the conforming type, you can change the name of one of the methods so it doesn&#39;t shadow/get shadowed by the other.<br>&gt;&gt; <br>&gt;&gt; If you control the conforming type this isn’t too big an issue as long as the protocol was well designed.  However, if the protocol was poorly designed it could be an issue.  Maybe a method that can be more efficiently implemented by some types was not made a requirement, but an extension method (with a slower implementation) takes the obvious name.  Maybe you would be willing to live with the slower implementation when your type is accessed via the protocol, because at least it can still be used via the protocol, but you don’t want to burden callers who use the concrete type with the slow implementation.  What do you do then?<br>&gt; <br>&gt; If a method that really ought to be a protocol requirement isn&#39;t a requirement and you don&#39;t control the protocol, well you&#39;re pretty much out of luck even today. Any conforming type accessed via the protocol will use the less efficient extension method and nothing about Brent&#39;s proposal would make that worse or better.<br>&gt; <br>&gt; Shadowing of the slow extension method doesn&#39;t remove the burden. It may make calling your fast implementation look nicer, but a less informed user of your type would unwittingly call the slower implementation if they access your type via the protocol. You could instead:<br>&gt; * come up with another name for your fast implementation; maybe the &quot;obvious&quot; name for the method is &quot;frobnicate&quot;--then name your method &quot;quicklyFrobnicate&quot;;<br>&gt; * or, decide you don&#39;t want to conform your type to a poorly designed protocol after all, instead retroactively modeling your type and other types of interest with a better designed protocol of your making.<br></p><p>Maybe you want the type to inter operate with code you don&#39;t control and in order to do that it must conform to the protocol.  And you don&#39;t want to obfuscate the interface to the concrete type because the protocol is poorly designed.  Conforming to the protocol *is not* the primary reason your type exists - conformance is used only for the purpose of using your type with a specific piece of third party code.<br></p><p>You *could* wrap your type for the purpose of this conformance.  This is what a Brent alluded to.  But it requires boilerplate and a bunch of conversion operations.  This is not just annoying, it could also be complex enough to lead to bugs.<br></p><p>&gt;  <br>&gt;&gt; If you control the protocol but want to retroactively model types you do not control this assumes you are willing to design your protocol around those types.  What if one of those types happens to implement a method that should not be a requirement of the protocol for one reason or another, but will be implemented as an extension method.  What do you do then?<br>&gt; <br>&gt; I&#39;m not sure I quite understand when this arises. Surely, by construction, if you wish to retroactively model types, you are willing to design your protocol around them. What else could it mean to retroactively model existing types? Can you give a concrete example where during retroactively modeling you simply have no choice but to name an extension method using a name that it is shadowed by a conforming type?<br></p><p>I&#39;m not saying you have *no choice*.  But again, conforming the one problematic type is not the primary purpose for which you are designing the protocol.  You know the shadowing method will not present any problems for your design.  Why should you be forced to design your protocol around this?<br></p><p>&gt;  <br>&gt;&gt; And of course there are cases where you do not control either.   Some people write code with a lot of 3rd party dependencies these days (not my style, but pretty common).  This is not a trivial concern.<br>&gt; <br>&gt; You are saying that it would be possible for a protocol extension in one dependency to conflict with a conforming type in another? This issue can be avoided if enforcement of non-shadowing by the compiler is such that when neither conforming type nor protocol extension is under your control everything continues to work as-is.<br></p><p>So you would still allow the developer to declare the conformance without error?  This means that developers still need to understand the shadowing behavior but it is pushed even further into a dark corner of the language with more special case rules that must be learned to understand when you might run into it.<br></p><p><br></p><p>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt; (And btw, &#39;final&#39; in this proposal is not exactly, because when combined with @incoherent the methods are not actually &#39;final&#39; - there is a necessary escape hatch).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There is no particular reason you couldn&#39;t allow similar annotated shadowing of `final` methods on classes; they would have basically the same semantics as you get here, where if a piece of code knows it&#39;s working with the subclass you get subclass semantics, but otherwise you get superclass ones. I do not claim this is a good idea. :^)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt; Second, we should require annotation of methods in protocol extensions that are not default implementation of requirements.  Maybe &#39;shadowable&#39; or &#39;staticdispatch&#39;?  These are awkward, but so is the behavior and they describe it better than anything else I&#39;ve seen so far (maybe we can do better though).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don&#39;t think `shadowable` makes sense here; that doesn&#39;t acknowledge a limitation, which is what we&#39;re trying to do here.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I continue to wish we hadn&#39;t taken `static` for statically-dispatched type methods. But I lost that argument years before swift-evolution became a thing.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt; I don&#39;t like &#39;nondynamic&#39; both because it is not aligned with the meaning of &#39;dynamic&#39; and also because it only says what the behavior *is not* rather than what the behavior *is*.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I do understand what you mean here. Unfortunately, the word &quot;virtual&quot; in a keyword makes me break out in hives, and I&#39;m not sure what else we might base it on.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is why I selected `final` in my proposal. `final` is desperately close to the actual semantic here, far closer than anything else in the language.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; How about `nonoverridable`? That said, I agree with earlier comments that training-wheel annotations probably aren&#39;t the way to go. Maybe, as you suggest above, just don&#39;t allow shadowing at all.<br>&gt;&gt; <br>&gt;&gt; Unfortunately, ‘nonoverridable’ doesn’t really make sense because you don’t ‘override’ protocol requirements.<br>&gt; <br>&gt; You don&#39;t override protocol requirements, but you do override their default implementations, whereas you cannot &#39;override&#39; statically dispatched extension methods. Within a protocol extension, there are methods that are overridable by conforming types (i.e. default implementations of protocol requirements) and methods that are not (i.e. statically dispatched non-requirements).<br>&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160523/80324394/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May 23, 2016 at 10:00:00am</p></header><div class="content"><p>On Mon, May 23, 2016 at 6:58 AM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; On May 22, 2016, at 11:55 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Sun, May 22, 2016 at 11:20 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On May 22, 2016, at 4:22 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Sun, May 22, 2016 at 3:38 PM, Brent Royal-Gordon via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; &gt; The proposal is well thought out and makes a valiant attempt at<br>&gt;&gt;&gt; handling all of the issues necessary.  But I don&#39;t support it for a number<br>&gt;&gt;&gt; of reasons.  I think it highlights how awkward it would be to try to<br>&gt;&gt;&gt; address shadowing on a case-by-case basis, which isn&#39;t necessarily obvious<br>&gt;&gt;&gt; until you explore what a solution might look like.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It does, but I&#39;m just not sure what else you can do about it. If there&#39;s<br>&gt;&gt;&gt; a warning, you need a way to silence it. If you ignore some cases (like<br>&gt;&gt;&gt; creating a conflict by importing two modules), you&#39;ll miss some of the<br>&gt;&gt;&gt; subtlest and hardest-to-fix bugs.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Honestly, I&#39;m tempted to say &quot;you just can&#39;t ever shadow a final<br>&gt;&gt;&gt; protocol method&quot; and be done with it. If that prevents certain conformances<br>&gt;&gt;&gt; or stops certain imports, so be it. You can always work around that with<br>&gt;&gt;&gt; wrapper types or other techniques.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; You know, I think this might be cleverest solution. It adds a small limit<br>&gt;&gt; to the language, but it doesn&#39;t unduly penalize retroactive modeling. If<br>&gt;&gt; you control either the protocol or the conforming type, you can change the<br>&gt;&gt; name of one of the methods so it doesn&#39;t shadow/get shadowed by the other.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; If you control the conforming type this isn’t too big an issue as long as<br>&gt;&gt; the protocol was well designed.  However, if the protocol was poorly<br>&gt;&gt; designed it could be an issue.  Maybe a method that can be more efficiently<br>&gt;&gt; implemented by some types was not made a requirement, but an extension<br>&gt;&gt; method (with a slower implementation) takes the obvious name.  Maybe you<br>&gt;&gt; would be willing to live with the slower implementation when your type is<br>&gt;&gt; accessed via the protocol, because at least it can still be used via the<br>&gt;&gt; protocol, but you don’t want to burden callers who use the concrete type<br>&gt;&gt; with the slow implementation.  What do you do then?<br>&gt;&gt;<br>&gt;<br>&gt; If a method that really ought to be a protocol requirement isn&#39;t a<br>&gt; requirement and you don&#39;t control the protocol, well you&#39;re pretty much out<br>&gt; of luck even today. Any conforming type accessed via the protocol will use<br>&gt; the less efficient extension method and nothing about Brent&#39;s proposal<br>&gt; would make that worse or better.<br>&gt;<br>&gt; Shadowing of the slow extension method doesn&#39;t remove the burden. It may<br>&gt; make calling your fast implementation look nicer, but a less informed user<br>&gt; of your type would unwittingly call the slower implementation if they<br>&gt; access your type via the protocol. You could instead:<br>&gt; * come up with another name for your fast implementation; maybe the<br>&gt; &quot;obvious&quot; name for the method is &quot;frobnicate&quot;--then name your method<br>&gt; &quot;quicklyFrobnicate&quot;;<br>&gt;<br>&gt; * or, decide you don&#39;t want to conform your type to a poorly designed<br>&gt; protocol after all, instead retroactively modeling your type and other<br>&gt; types of interest with a better designed protocol of your making.<br>&gt;<br>&gt;<br>&gt; Maybe you want the type to inter operate with code you don&#39;t control and<br>&gt; in order to do that it must conform to the protocol.  And you don&#39;t want to<br>&gt; obfuscate the interface to the concrete type because the protocol is poorly<br>&gt; designed.<br>&gt;<br></p><p>I&#39;m not sure this is a reasonable set of demands. I understand a protocol<br>to be a contract. If you decide to conform to a poorly designed protocol,<br>you *should* have a poorly designed concrete type. That is the purpose of a<br>protocol, to provide certain guarantees, be they wise or unwise. To me,<br>it&#39;s a bug rather than a feature to support papering over poor protocol<br>design when conforming to a protocol, which also forces the poor design to<br>be exposed only when accessing your type through that protocol. In the end,<br>you don&#39;t have a well-designed type; your type is instead simultaneously<br>well and poorly designed!<br></p><p><br>&gt;  Conforming to the protocol *is not* the primary reason your type exists -<br>&gt; conformance is used only for the purpose of using your type with a specific<br>&gt; piece of third party code.<br>&gt;<br>&gt; You *could* wrap your type for the purpose of this conformance.  This is<br>&gt; what a Brent alluded to.  But it requires boilerplate and a bunch of<br>&gt; conversion operations.  This is not just annoying, it could also be complex<br>&gt; enough to lead to bugs.<br>&gt;<br>&gt;<br>&gt;<br>&gt;&gt; If you control the protocol but want to retroactively model types you do<br>&gt;&gt; not control this assumes you are willing to design your protocol around<br>&gt;&gt; those types.  What if one of those types happens to implement a method that<br>&gt;&gt; should not be a requirement of the protocol for one reason or another, but<br>&gt;&gt; will be implemented as an extension method.  What do you do then?<br>&gt;&gt;<br>&gt;<br>&gt; I&#39;m not sure I quite understand when this arises. Surely, by construction,<br>&gt; if you wish to retroactively model types, you are willing to design your<br>&gt; protocol around them. What else could it mean to retroactively model<br>&gt; existing types? Can you give a concrete example where during retroactively<br>&gt; modeling you simply have no choice but to name an extension method using a<br>&gt; name that it is shadowed by a conforming type?<br>&gt;<br>&gt;<br>&gt; I&#39;m not saying you have *no choice*.  But again, conforming the one<br>&gt; problematic type is not the primary purpose for which you are designing the<br>&gt; protocol.  You know the shadowing method will not present any problems for<br>&gt; your design.  Why should you be forced to design your protocol around this?<br>&gt;<br></p><p>Because, again, a protocol is a contract. If you&#39;re retroactively modeling<br>many well designed types and one poorly designed type, the lowest common<br>denominator is a poorly designed protocol. That *should* be the result, no?<br></p><p><br>&gt; And of course there are cases where you do not control either.   Some<br>&gt;&gt; people write code with a lot of 3rd party dependencies these days (not my<br>&gt;&gt; style, but pretty common).  This is not a trivial concern.<br>&gt;&gt;<br>&gt;<br>&gt; You are saying that it would be possible for a protocol extension in one<br>&gt; dependency to conflict with a conforming type in another? This issue can be<br>&gt; avoided if enforcement of non-shadowing by the compiler is such that when<br>&gt; neither conforming type nor protocol extension is under your control<br>&gt; everything continues to work as-is.<br>&gt;<br>&gt;<br>&gt; So you would still allow the developer to declare the conformance without<br>&gt; error?  This means that developers still need to understand the shadowing<br>&gt; behavior but it is pushed even further into a dark corner of the language<br>&gt; with more special case rules that must be learned to understand when you<br>&gt; might run into it.<br>&gt;<br></p><p>No, I would forbid declaring any such conformance in code the developer<br>controls. If you control the conforming type and it contains a method name<br>that clashes with a protocol extension method, you would be forbidden from<br>declaring conformance without renaming your clashing method. In fact, I&#39;m<br>beginning to wonder if protocol extension methods on protocols outside the<br>same module should be internally scoped.<br></p><p><br>&gt;<br>&gt;&gt;&gt; &gt; (And btw, &#39;final&#39; in this proposal is not exactly, because when<br>&gt;&gt;&gt; combined with @incoherent the methods are not actually &#39;final&#39; - there is a<br>&gt;&gt;&gt; necessary escape hatch).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; There is no particular reason you couldn&#39;t allow similar annotated<br>&gt;&gt;&gt; shadowing of `final` methods on classes; they would have basically the same<br>&gt;&gt;&gt; semantics as you get here, where if a piece of code knows it&#39;s working with<br>&gt;&gt;&gt; the subclass you get subclass semantics, but otherwise you get superclass<br>&gt;&gt;&gt; ones. I do not claim this is a good idea. :^)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; Second, we should require annotation of methods in protocol extensions<br>&gt;&gt;&gt; that are not default implementation of requirements.  Maybe &#39;shadowable&#39; or<br>&gt;&gt;&gt; &#39;staticdispatch&#39;?  These are awkward, but so is the behavior and they<br>&gt;&gt;&gt; describe it better than anything else I&#39;ve seen so far (maybe we can do<br>&gt;&gt;&gt; better though).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I don&#39;t think `shadowable` makes sense here; that doesn&#39;t acknowledge a<br>&gt;&gt;&gt; limitation, which is what we&#39;re trying to do here.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I continue to wish we hadn&#39;t taken `static` for statically-dispatched<br>&gt;&gt;&gt; type methods. But I lost that argument years before swift-evolution became<br>&gt;&gt;&gt; a thing.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; I don&#39;t like &#39;nondynamic&#39; both because it is not aligned with the<br>&gt;&gt;&gt; meaning of &#39;dynamic&#39; and also because it only says what the behavior *is<br>&gt;&gt;&gt; not* rather than what the behavior *is*.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I do understand what you mean here. Unfortunately, the word &quot;virtual&quot; in<br>&gt;&gt;&gt; a keyword makes me break out in hives, and I&#39;m not sure what else we might<br>&gt;&gt;&gt; base it on.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This is why I selected `final` in my proposal. `final` is desperately<br>&gt;&gt;&gt; close to the actual semantic here, far closer than anything else in the<br>&gt;&gt;&gt; language.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; How about `nonoverridable`? That said, I agree with earlier comments that<br>&gt;&gt; training-wheel annotations probably aren&#39;t the way to go. Maybe, as you<br>&gt;&gt; suggest above, just don&#39;t allow shadowing at all.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Unfortunately, ‘nonoverridable’ doesn’t really make sense because you<br>&gt;&gt; don’t ‘override’ protocol requirements.<br>&gt;&gt;<br>&gt;<br>&gt; You don&#39;t override protocol requirements, but you do override their<br>&gt; default implementations, whereas you cannot &#39;override&#39; statically<br>&gt; dispatched extension methods. Within a protocol extension, there are<br>&gt; methods that are overridable by conforming types (i.e. default<br>&gt; implementations of protocol requirements) and methods that are not (i.e.<br>&gt; statically dispatched non-requirements).<br>&gt;<br>&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160523/71ec5693/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 23, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On May 23, 2016, at 10:50 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Mon, May 23, 2016 at 6:58 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On May 22, 2016, at 11:55 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Sun, May 22, 2016 at 11:20 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On May 22, 2016, at 4:22 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Sun, May 22, 2016 at 3:38 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt; The proposal is well thought out and makes a valiant attempt at handling all of the issues necessary.  But I don&#39;t support it for a number of reasons.  I think it highlights how awkward it would be to try to address shadowing on a case-by-case basis, which isn&#39;t necessarily obvious until you explore what a solution might look like.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It does, but I&#39;m just not sure what else you can do about it. If there&#39;s a warning, you need a way to silence it. If you ignore some cases (like creating a conflict by importing two modules), you&#39;ll miss some of the subtlest and hardest-to-fix bugs.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Honestly, I&#39;m tempted to say &quot;you just can&#39;t ever shadow a final protocol method&quot; and be done with it. If that prevents certain conformances or stops certain imports, so be it. You can always work around that with wrapper types or other techniques.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You know, I think this might be cleverest solution. It adds a small limit to the language, but it doesn&#39;t unduly penalize retroactive modeling. If you control either the protocol or the conforming type, you can change the name of one of the methods so it doesn&#39;t shadow/get shadowed by the other.<br>&gt;&gt; <br>&gt;&gt; If you control the conforming type this isn’t too big an issue as long as the protocol was well designed.  However, if the protocol was poorly designed it could be an issue.  Maybe a method that can be more efficiently implemented by some types was not made a requirement, but an extension method (with a slower implementation) takes the obvious name.  Maybe you would be willing to live with the slower implementation when your type is accessed via the protocol, because at least it can still be used via the protocol, but you don’t want to burden callers who use the concrete type with the slow implementation.  What do you do then? <br>&gt;&gt; <br>&gt;&gt; If a method that really ought to be a protocol requirement isn&#39;t a requirement and you don&#39;t control the protocol, well you&#39;re pretty much out of luck even today. Any conforming type accessed via the protocol will use the less efficient extension method and nothing about Brent&#39;s proposal would make that worse or better.<br>&gt;&gt; <br>&gt;&gt; Shadowing of the slow extension method doesn&#39;t remove the burden. It may make calling your fast implementation look nicer, but a less informed user of your type would unwittingly call the slower implementation if they access your type via the protocol. You could instead:<br>&gt;&gt; * come up with another name for your fast implementation; maybe the &quot;obvious&quot; name for the method is &quot;frobnicate&quot;--then name your method &quot;quicklyFrobnicate&quot;;<br>&gt;&gt; * or, decide you don&#39;t want to conform your type to a poorly designed protocol after all, instead retroactively modeling your type and other types of interest with a better designed protocol of your making.<br>&gt; <br>&gt; Maybe you want the type to inter operate with code you don&#39;t control and in order to do that it must conform to the protocol.  And you don&#39;t want to obfuscate the interface to the concrete type because the protocol is poorly designed.<br>&gt; <br>&gt; I&#39;m not sure this is a reasonable set of demands. I understand a protocol to be a contract.  If you decide to conform to a poorly designed protocol, you *should* have a poorly designed concrete type.<br></p><p>This is crazy.  If a protocol happens to place a method in an extension rather than making it a default implementation of a requirement and I want to conform to it does not mean my concrete type should have be poorly designed.  Sure, when the 3rd party type uses my concrete type via the interface of its protocol it will not receive the benefits of a higher performance implementation.  But maybe interoperability is more important than the highest performance possible.<br></p><p>&gt; That is the purpose of a protocol, to provide certain guarantees, be they wise or unwise. To me, it&#39;s a bug rather than a feature to support papering over poor protocol design when conforming to a protocol, which also forces the poor design to be exposed only when accessing your type through that protocol. In the end, you don&#39;t have a well-designed type; your type is instead simultaneously well and poorly designed!<br></p><p>When it comes to interoperating with code you do not control you get what you get.  You have to work with it one way or another.  What I am saying is that the language should not artificially limit our options here.<br></p><p>&gt;  <br>&gt;  Conforming to the protocol *is not* the primary reason your type exists - conformance is used only for the purpose of using your type with a specific piece of third party code.<br>&gt; <br>&gt; You *could* wrap your type for the purpose of this conformance.  This is what a Brent alluded to.  But it requires boilerplate and a bunch of conversion operations.  This is not just annoying, it could also be complex enough to lead to bugs.<br>&gt; <br>&gt;&gt;  <br>&gt;&gt; If you control the protocol but want to retroactively model types you do not control this assumes you are willing to design your protocol around those types.  What if one of those types happens to implement a method that should not be a requirement of the protocol for one reason or another, but will be implemented as an extension method.  What do you do then?<br>&gt;&gt; <br>&gt;&gt; I&#39;m not sure I quite understand when this arises. Surely, by construction, if you wish to retroactively model types, you are willing to design your protocol around them. What else could it mean to retroactively model existing types? Can you give a concrete example where during retroactively modeling you simply have no choice but to name an extension method using a name that it is shadowed by a conforming type?<br>&gt; <br>&gt; I&#39;m not saying you have *no choice*.  But again, conforming the one problematic type is not the primary purpose for which you are designing the protocol.  You know the shadowing method will not present any problems for your design.  Why should you be forced to design your protocol around this?<br>&gt; <br>&gt; Because, again, a protocol is a contract. If you&#39;re retroactively modeling many well designed types and one poorly designed type, the lowest common denominator is a poorly designed protocol. That *should* be the result, no?<br></p><p>It all depends on the types and the protocol.  Protocols often represent a small subset of the total interface and functionality of a type.  <br></p><p>The fact that the type may happen to use a name for a method that matches a name you would like to use in an extension to your protocol does not necessarily mean either is poorly designed.<br></p><p>&gt;  <br>&gt;&gt; And of course there are cases where you do not control either.   Some people write code with a lot of 3rd party dependencies these days (not my style, but pretty common).  This is not a trivial concern.<br>&gt;&gt; <br>&gt;&gt; You are saying that it would be possible for a protocol extension in one dependency to conflict with a conforming type in another? This issue can be avoided if enforcement of non-shadowing by the compiler is such that when neither conforming type nor protocol extension is under your control everything continues to work as-is.<br>&gt; <br>&gt; So you would still allow the developer to declare the conformance without error?  This means that developers still need to understand the shadowing behavior but it is pushed even further into a dark corner of the language with more special case rules that must be learned to understand when you might run into it.<br>&gt; <br>&gt; No, I would forbid declaring any such conformance in code the developer controls. If you control the conforming type and it contains a method name that clashes with a protocol extension method, you would be forbidden from declaring conformance without renaming your clashing method. In fact, I&#39;m beginning to wonder if protocol extension methods on protocols outside the same module should be internally scoped.<br></p><p>In this case you *don’t* control the conforming type.  You want to declare conformance for a type that is in a 3rd party library.  You said when neither is under your control you would leave things as-is.  Today you can declare conformance without error.  Would you still allow that?<br></p><p>&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; (And btw, &#39;final&#39; in this proposal is not exactly, because when combined with @incoherent the methods are not actually &#39;final&#39; - there is a necessary escape hatch).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There is no particular reason you couldn&#39;t allow similar annotated shadowing of `final` methods on classes; they would have basically the same semantics as you get here, where if a piece of code knows it&#39;s working with the subclass you get subclass semantics, but otherwise you get superclass ones. I do not claim this is a good idea. :^)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; Second, we should require annotation of methods in protocol extensions that are not default implementation of requirements.  Maybe &#39;shadowable&#39; or &#39;staticdispatch&#39;?  These are awkward, but so is the behavior and they describe it better than anything else I&#39;ve seen so far (maybe we can do better though).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t think `shadowable` makes sense here; that doesn&#39;t acknowledge a limitation, which is what we&#39;re trying to do here.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I continue to wish we hadn&#39;t taken `static` for statically-dispatched type methods. But I lost that argument years before swift-evolution became a thing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; I don&#39;t like &#39;nondynamic&#39; both because it is not aligned with the meaning of &#39;dynamic&#39; and also because it only says what the behavior *is not* rather than what the behavior *is*.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I do understand what you mean here. Unfortunately, the word &quot;virtual&quot; in a keyword makes me break out in hives, and I&#39;m not sure what else we might base it on.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is why I selected `final` in my proposal. `final` is desperately close to the actual semantic here, far closer than anything else in the language.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; How about `nonoverridable`? That said, I agree with earlier comments that training-wheel annotations probably aren&#39;t the way to go. Maybe, as you suggest above, just don&#39;t allow shadowing at all.<br>&gt;&gt; <br>&gt;&gt; Unfortunately, ‘nonoverridable’ doesn’t really make sense because you don’t ‘override’ protocol requirements.<br>&gt;&gt; <br>&gt;&gt; You don&#39;t override protocol requirements, but you do override their default implementations, whereas you cannot &#39;override&#39; statically dispatched extension methods. Within a protocol extension, there are methods that are overridable by conforming types (i.e. default implementations of protocol requirements) and methods that are not (i.e. statically dispatched non-requirements).<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160523/962b3e85/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May 23, 2016 at 03:00:00pm</p></header><div class="content"><p>On Mon, May 23, 2016 at 12:13 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt; On May 23, 2016, at 10:50 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Mon, May 23, 2016 at 6:58 AM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Sent from my iPad<br>&gt;&gt;<br>&gt;&gt; On May 22, 2016, at 11:55 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Sun, May 22, 2016 at 11:20 PM, Matthew Johnson &lt;matthew at anandabits.com<br>&gt;&gt; &gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On May 22, 2016, at 4:22 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Sun, May 22, 2016 at 3:38 PM, Brent Royal-Gordon via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt; The proposal is well thought out and makes a valiant attempt at<br>&gt;&gt;&gt;&gt; handling all of the issues necessary.  But I don&#39;t support it for a number<br>&gt;&gt;&gt;&gt; of reasons.  I think it highlights how awkward it would be to try to<br>&gt;&gt;&gt;&gt; address shadowing on a case-by-case basis, which isn&#39;t necessarily obvious<br>&gt;&gt;&gt;&gt; until you explore what a solution might look like.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; It does, but I&#39;m just not sure what else you can do about it. If<br>&gt;&gt;&gt;&gt; there&#39;s a warning, you need a way to silence it. If you ignore some cases<br>&gt;&gt;&gt;&gt; (like creating a conflict by importing two modules), you&#39;ll miss some of<br>&gt;&gt;&gt;&gt; the subtlest and hardest-to-fix bugs.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Honestly, I&#39;m tempted to say &quot;you just can&#39;t ever shadow a final<br>&gt;&gt;&gt;&gt; protocol method&quot; and be done with it. If that prevents certain conformances<br>&gt;&gt;&gt;&gt; or stops certain imports, so be it. You can always work around that with<br>&gt;&gt;&gt;&gt; wrapper types or other techniques.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; You know, I think this might be cleverest solution. It adds a small<br>&gt;&gt;&gt; limit to the language, but it doesn&#39;t unduly penalize retroactive modeling.<br>&gt;&gt;&gt; If you control either the protocol or the conforming type, you can change<br>&gt;&gt;&gt; the name of one of the methods so it doesn&#39;t shadow/get shadowed by the<br>&gt;&gt;&gt; other.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If you control the conforming type this isn’t too big an issue as long<br>&gt;&gt;&gt; as the protocol was well designed.  However, if the protocol was poorly<br>&gt;&gt;&gt; designed it could be an issue.  Maybe a method that can be more efficiently<br>&gt;&gt;&gt; implemented by some types was not made a requirement, but an extension<br>&gt;&gt;&gt; method (with a slower implementation) takes the obvious name.  Maybe you<br>&gt;&gt;&gt; would be willing to live with the slower implementation when your type is<br>&gt;&gt;&gt; accessed via the protocol, because at least it can still be used via the<br>&gt;&gt;&gt; protocol, but you don’t want to burden callers who use the concrete type<br>&gt;&gt;&gt; with the slow implementation.  What do you do then?<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; If a method that really ought to be a protocol requirement isn&#39;t a<br>&gt;&gt; requirement and you don&#39;t control the protocol, well you&#39;re pretty much out<br>&gt;&gt; of luck even today. Any conforming type accessed via the protocol will use<br>&gt;&gt; the less efficient extension method and nothing about Brent&#39;s proposal<br>&gt;&gt; would make that worse or better.<br>&gt;&gt;<br>&gt;&gt; Shadowing of the slow extension method doesn&#39;t remove the burden. It may<br>&gt;&gt; make calling your fast implementation look nicer, but a less informed user<br>&gt;&gt; of your type would unwittingly call the slower implementation if they<br>&gt;&gt; access your type via the protocol. You could instead:<br>&gt;&gt; * come up with another name for your fast implementation; maybe the<br>&gt;&gt; &quot;obvious&quot; name for the method is &quot;frobnicate&quot;--then name your method<br>&gt;&gt; &quot;quicklyFrobnicate&quot;;<br>&gt;&gt;<br>&gt;&gt; * or, decide you don&#39;t want to conform your type to a poorly designed<br>&gt;&gt; protocol after all, instead retroactively modeling your type and other<br>&gt;&gt; types of interest with a better designed protocol of your making.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Maybe you want the type to inter operate with code you don&#39;t control and<br>&gt;&gt; in order to do that it must conform to the protocol.  And you don&#39;t want to<br>&gt;&gt; obfuscate the interface to the concrete type because the protocol is poorly<br>&gt;&gt; designed.<br>&gt;&gt;<br>&gt;<br>&gt; I&#39;m not sure this is a reasonable set of demands. I understand a protocol<br>&gt; to be a contract.  If you decide to conform to a poorly designed protocol,<br>&gt; you *should* have a poorly designed concrete type.<br>&gt;<br>&gt;<br>&gt; This is crazy.  If a protocol happens to place a method in an extension<br>&gt; rather than making it a default implementation of a requirement and I want<br>&gt; to conform to it does not mean my concrete type should have be poorly<br>&gt; designed.<br>&gt;<br></p><p>Quite simply, I think it should.<br></p><p><br>&gt;  Sure, when the 3rd party type uses my concrete type via the interface of<br>&gt; its protocol it will not receive the benefits of a higher performance<br>&gt; implementation.  But maybe interoperability is more important than the<br>&gt; highest performance possible.<br>&gt;<br></p><p>As you have said, the workaround is to provide two classes, one wrapping<br>the other. One provides interoperability, the other high performance.<br></p><p><br>&gt;<br>&gt; That is the purpose of a protocol, to provide certain guarantees, be they<br>&gt; wise or unwise. To me, it&#39;s a bug rather than a feature to support papering<br>&gt; over poor protocol design when conforming to a protocol, which also forces<br>&gt; the poor design to be exposed only when accessing your type through that<br>&gt; protocol. In the end, you don&#39;t have a well-designed type; your type is<br>&gt; instead simultaneously well and poorly designed!<br>&gt;<br>&gt;<br>&gt; When it comes to interoperating with code you do not control you get what<br>&gt; you get.  You have to work with it one way or another.  What I am saying is<br>&gt; that the language should not artificially limit our options here.<br>&gt;<br></p><p>I wouldn&#39;t call it an &#39;artificial limit,&#39; at least any more than any other<br>aspect of language design. The language must determine what it means to<br>conform a type to a protocol. One option, which I think is entirely valid,<br>is to decide that extensions on a protocol are not to be shadowed by a<br>conforming type.<br></p><p><br>&gt;<br>&gt;<br>&gt;<br>&gt;&gt;  Conforming to the protocol *is not* the primary reason your type exists<br>&gt;&gt; - conformance is used only for the purpose of using your type with a<br>&gt;&gt; specific piece of third party code.<br>&gt;&gt;<br>&gt;&gt; You *could* wrap your type for the purpose of this conformance.  This is<br>&gt;&gt; what a Brent alluded to.  But it requires boilerplate and a bunch of<br>&gt;&gt; conversion operations.  This is not just annoying, it could also be complex<br>&gt;&gt; enough to lead to bugs.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; If you control the protocol but want to retroactively model types you do<br>&gt;&gt;&gt; not control this assumes you are willing to design your protocol around<br>&gt;&gt;&gt; those types.  What if one of those types happens to implement a method that<br>&gt;&gt;&gt; should not be a requirement of the protocol for one reason or another, but<br>&gt;&gt;&gt; will be implemented as an extension method.  What do you do then?<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I&#39;m not sure I quite understand when this arises. Surely, by<br>&gt;&gt; construction, if you wish to retroactively model types, you are willing to<br>&gt;&gt; design your protocol around them. What else could it mean to retroactively<br>&gt;&gt; model existing types? Can you give a concrete example where during<br>&gt;&gt; retroactively modeling you simply have no choice but to name an extension<br>&gt;&gt; method using a name that it is shadowed by a conforming type?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I&#39;m not saying you have *no choice*.  But again, conforming the one<br>&gt;&gt; problematic type is not the primary purpose for which you are designing the<br>&gt;&gt; protocol.  You know the shadowing method will not present any problems for<br>&gt;&gt; your design.  Why should you be forced to design your protocol around this?<br>&gt;&gt;<br>&gt;<br>&gt; Because, again, a protocol is a contract. If you&#39;re retroactively modeling<br>&gt; many well designed types and one poorly designed type, the lowest common<br>&gt; denominator is a poorly designed protocol. That *should* be the result, no?<br>&gt;<br>&gt;<br>&gt; It all depends on the types and the protocol.  Protocols often represent a<br>&gt; small subset of the total interface and functionality of a type.<br>&gt;<br>&gt; The fact that the type may happen to use a name for a method that matches<br>&gt; a name you would like to use in an extension to your protocol does not<br>&gt; necessarily mean either is poorly designed.<br>&gt;<br></p><p>I agree. Both the type and the protocol might be beautifully designed. But<br>I would argue that conforming the one to the other might be a poor design.<br></p><p><br>&gt; And of course there are cases where you do not control either.   Some<br>&gt;&gt;&gt; people write code with a lot of 3rd party dependencies these days (not my<br>&gt;&gt;&gt; style, but pretty common).  This is not a trivial concern.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; You are saying that it would be possible for a protocol extension in one<br>&gt;&gt; dependency to conflict with a conforming type in another? This issue can be<br>&gt;&gt; avoided if enforcement of non-shadowing by the compiler is such that when<br>&gt;&gt; neither conforming type nor protocol extension is under your control<br>&gt;&gt; everything continues to work as-is.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; So you would still allow the developer to declare the conformance without<br>&gt;&gt; error?  This means that developers still need to understand the shadowing<br>&gt;&gt; behavior but it is pushed even further into a dark corner of the language<br>&gt;&gt; with more special case rules that must be learned to understand when you<br>&gt;&gt; might run into it.<br>&gt;&gt;<br>&gt;<br>&gt; No, I would forbid declaring any such conformance in code the developer<br>&gt; controls. If you control the conforming type and it contains a method name<br>&gt; that clashes with a protocol extension method, you would be forbidden from<br>&gt; declaring conformance without renaming your clashing method. In fact, I&#39;m<br>&gt; beginning to wonder if protocol extension methods on protocols outside the<br>&gt; same module should be internally scoped.<br>&gt;<br>&gt;<br>&gt; In this case you *don’t* control the conforming type.  You want to declare<br>&gt; conformance for a type that is in a 3rd party library.  You said when<br>&gt; neither is under your control you would leave things as-is.  Today you can<br>&gt; declare conformance without error.  Would you still allow that?<br>&gt;<br></p><p>In that scenario, I would not. The type you don&#39;t control simply cannot<br>conform to the protocol you don&#39;t control. Again, there would be<br>workarounds.<br></p><p><br>&gt;<br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt; (And btw, &#39;final&#39; in this proposal is not exactly, because when<br>&gt;&gt;&gt;&gt; combined with @incoherent the methods are not actually &#39;final&#39; - there is a<br>&gt;&gt;&gt;&gt; necessary escape hatch).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; There is no particular reason you couldn&#39;t allow similar annotated<br>&gt;&gt;&gt;&gt; shadowing of `final` methods on classes; they would have basically the same<br>&gt;&gt;&gt;&gt; semantics as you get here, where if a piece of code knows it&#39;s working with<br>&gt;&gt;&gt;&gt; the subclass you get subclass semantics, but otherwise you get superclass<br>&gt;&gt;&gt;&gt; ones. I do not claim this is a good idea. :^)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt; Second, we should require annotation of methods in protocol<br>&gt;&gt;&gt;&gt; extensions that are not default implementation of requirements.  Maybe<br>&gt;&gt;&gt;&gt; &#39;shadowable&#39; or &#39;staticdispatch&#39;?  These are awkward, but so is the<br>&gt;&gt;&gt;&gt; behavior and they describe it better than anything else I&#39;ve seen so far<br>&gt;&gt;&gt;&gt; (maybe we can do better though).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I don&#39;t think `shadowable` makes sense here; that doesn&#39;t acknowledge a<br>&gt;&gt;&gt;&gt; limitation, which is what we&#39;re trying to do here.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I continue to wish we hadn&#39;t taken `static` for statically-dispatched<br>&gt;&gt;&gt;&gt; type methods. But I lost that argument years before swift-evolution became<br>&gt;&gt;&gt;&gt; a thing.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt; I don&#39;t like &#39;nondynamic&#39; both because it is not aligned with the<br>&gt;&gt;&gt;&gt; meaning of &#39;dynamic&#39; and also because it only says what the behavior *is<br>&gt;&gt;&gt;&gt; not* rather than what the behavior *is*.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I do understand what you mean here. Unfortunately, the word &quot;virtual&quot;<br>&gt;&gt;&gt;&gt; in a keyword makes me break out in hives, and I&#39;m not sure what else we<br>&gt;&gt;&gt;&gt; might base it on.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This is why I selected `final` in my proposal. `final` is desperately<br>&gt;&gt;&gt;&gt; close to the actual semantic here, far closer than anything else in the<br>&gt;&gt;&gt;&gt; language.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; How about `nonoverridable`? That said, I agree with earlier comments<br>&gt;&gt;&gt; that training-wheel annotations probably aren&#39;t the way to go. Maybe, as<br>&gt;&gt;&gt; you suggest above, just don&#39;t allow shadowing at all.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Unfortunately, ‘nonoverridable’ doesn’t really make sense because you<br>&gt;&gt;&gt; don’t ‘override’ protocol requirements.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; You don&#39;t override protocol requirements, but you do override their<br>&gt;&gt; default implementations, whereas you cannot &#39;override&#39; statically<br>&gt;&gt; dispatched extension methods. Within a protocol extension, there are<br>&gt;&gt; methods that are overridable by conforming types (i.e. default<br>&gt;&gt; implementations of protocol requirements) and methods that are not (i.e.<br>&gt;&gt; statically dispatched non-requirements).<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160523/81394285/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 24, 2016 at 12:00:00am</p></header><div class="content"><p>On 23.05.2016 23:09, Xiaodi Wu via swift-evolution wrote:<br>&gt; One option, which I think is entirely valid, is to decide that extensions<br>&gt; on a protocol are not to be shadowed by a conforming type.<br></p><p>Just to have the whole picture for those, who is reading your discussion <br>with Matthew : yes, extensions(that were not declared in protocol itself) <br>are not shadowed by a conforming type(if called by reference which type is <br>protocol, i.e let p = MyProtocol = MyType()). And I agree, that when you <br>know this - this is a simple rule.<br></p><p>But, you have to remember another rules:<br>* default implementation of protocol requirement (in protocol extension) - <br>*will* be shadowed by type&#39;s method *if* implemented *exactly* in the same <br>type that conformed to protocol<br>* default implementation of protocol requirement (in protocol extension) - <br>will *not* be shadowed *if* implemented in derived type which base type <br>conformed to protocol (i.e. type has implemented the method, type is <br>conformed to protocol, but protocol&#39;s default implementation will be called)<br></p><p>For me (now), it seems like these rules has strong reasons and we will not <br>change them. OK. But IMO we definitely needs some help from Swift to avoid <br>possible *not easy to fix* errors related to these rules.<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 22, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On May 22, 2016, at 3:38 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; The proposal is well thought out and makes a valiant attempt at handling all of the issues necessary.  But I don&#39;t support it for a number of reasons.  I think it highlights how awkward it would be to try to address shadowing on a case-by-case basis, which isn&#39;t necessarily obvious until you explore what a solution might look like.<br>&gt; <br>&gt; It does, but I&#39;m just not sure what else you can do about it. If there&#39;s a warning, you need a way to silence it. If you ignore some cases (like creating a conflict by importing two modules), you&#39;ll miss some of the subtlest and hardest-to-fix bugs.<br>&gt; <br>&gt; Honestly, I&#39;m tempted to say &quot;you just can&#39;t ever shadow a final protocol method&quot; and be done with it. If that prevents certain conformances or stops certain imports, so be it. You can always work around that with wrapper types or other techniques.<br></p><p>That’s pretty extreme.<br></p><p>I’m curious - does this still bite you now that you understand the behavior?  Or are you mostly concerned about users who don’t really understand how the language works?<br></p><p>&gt; <br>&gt;&gt; (And btw, &#39;final&#39; in this proposal is not exactly, because when combined with @incoherent the methods are not actually &#39;final&#39; - there is a necessary escape hatch).<br>&gt; <br>&gt; There is no particular reason you couldn&#39;t allow similar annotated shadowing of `final` methods on classes; they would have basically the same semantics as you get here, where if a piece of code knows it&#39;s working with the subclass you get subclass semantics, but otherwise you get superclass ones. I do not claim this is a good idea. :^)<br></p><p>Lol.  That would be terrible!  There are very good implementation reasons for the behavior of protocol extension methods.  There would be no such justification with classes.  IMO `final` should mean final, period.<br></p><p>&gt; <br>&gt;&gt; Second, we should require annotation of methods in protocol extensions that are not default implementation of requirements.  Maybe &#39;shadowable&#39; or &#39;staticdispatch&#39;?  These are awkward, but so is the behavior and they describe it better than anything else I&#39;ve seen so far (maybe we can do better though).<br>&gt; <br>&gt; I don&#39;t think `shadowable` makes sense here; that doesn&#39;t acknowledge a limitation, which is what we&#39;re trying to do here.<br></p><p>Sure, I admit it’s not great.  This is a pretty tricky naming problem!<br></p><p>&gt; <br>&gt; I continue to wish we hadn&#39;t taken `static` for statically-dispatched type methods. But I lost that argument years before swift-evolution became a thing.<br>&gt; <br>&gt;&gt; I don&#39;t like &#39;nondynamic&#39; both because it is not aligned with the meaning of &#39;dynamic&#39; and also because it only says what the behavior *is not* rather than what the behavior *is*.<br>&gt; <br>&gt; I do understand what you mean here. Unfortunately, the word &quot;virtual&quot; in a keyword makes me break out in hives, and I&#39;m not sure what else we might base it on.<br></p><p>Yeah, I don’t think `virtual` has a place in Swift.<br></p><p>&gt; <br>&gt; This is why I selected `final` in my proposal. `final` is desperately close to the actual semantic here, far closer than anything else in the language.<br></p><p>I agree `final` is kind of close, but not close enough.  It has a very precise meaning and I prefer to keep it that way.<br></p><p>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>Michael Peternell</string> &lt;michael.peternell at gmx.at&gt;<p>May 21, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; Am 21.05.2016 um 23:22 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On May 21, 2016, at 3:16 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt;&gt; Where was proposed to force them to be final and was just trying to provide an example in which the conforming class may want to override them, so forcing them final isn&#39;t a good idea.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Again, nobody ever proposed forcing them final.  The proposal was to use final as a way to document the existing behavior.  <br>&gt;&gt; <br>&gt;&gt; I *did* propose forcing them final, and I&#39;m still very skeptical that a `nondynamic` keyword that does nothing when you shadow the method is a good idea. People are still going to naïvely try to override these methods and be surprised when it doesn&#39;t work. A `nondynamic` keyword at the original declaration site will help them understand what happened when they&#39;re investigating the bug, but it still seems like this kind of code is so suspect that Swift ought to flag it from the start.<br>&gt; <br>&gt; Sorry about that.  Either I didn&#39;t see that or I forgot about it.  Making them &#39;final&#39; causes problems with retroactive modeling.  There are other issues as well but that is the most significant one.<br></p><p>indeed. IMHO a proper solution should deal with these use cases properly:<br></p><p>1) Someone adds a method to a class, and there are protocol extensions somewhere out there (maybe in another module) that he doesn&#39;t know about.<br>2) Someone creates a protocol extension for a type X, but he doesn&#39;t know the names of all (current and future) methods from all subtypes of X. How can this poor developer ever create a safe protocol extension?<br></p><p>This should not lead to<br>A) the class breaking (e.g. stopping to compile), because someone else creates a protocol extension with a conflicting symbol.<br>B) the wrong method being dispatched, because the two authors didn&#39;t agree on what the &quot;makeBlue&quot; method should do. they disagree, because they don&#39;t know each other. This becomes especially bad if both methods are not well-documented, and the contract mismatch is not obvious.<br></p><p>Can we agree that two methods with the same name sometimes have the same contract and sometimes not? And that this is not a programmer error? And that it would be good to distinguish between these two cases?<br></p><p>The more I think about it and follow the discussion, the more I come to the conclusion that the current behavior is not that bad. At least it is safe. Dispatching everything dynamically is unsafe (1). Adding a `nondynamic` keyword is unsafe (2). Forcing a `final` keyword is unsafe (3).<br></p><p>(1) I wrote about that earlier (yesterday I think)<br>(2) Because you would usually just rename such a method. It&#39;s much better. The problem  becomes apparent when the class author doesn&#39;t know the protocol extension, or when the protocol extension is created later, maybe by a different author in a different module.<br>(3) This disallows methods with the same name in classes that fall into the scope of the extension. See (2).<br></p><p>-Michael<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 22, 2016 at 09:00:00am</p></header><div class="content"><p>I support the opinion that Swift should somehow warn us that some type has <br>the same method(exact matched or even if the same name?) as in protocol <br>extension for the conformed protocol(if no such method is in protocol <br>itself *or* if declared, but conformance to protocol was introduced in base <br>class and base contains no implemntation for method with default <br>implementation(see my another email with example in this thread) - in both <br>cases it will be statically dispatched)<br></p><p>But I don&#39;t think `final` keyword will help there as it can&#39;t help if we <br>initially have protocol and extension in 3rd party code, and wants to <br>conforms our(or even not our) class with *existed* methods to that protocol <br>via type extension. So, we just can&#39;t/don&#39;t want/have no rights to change <br>anything in protocol/extension and probably in the type.<br></p><p>So, the only solution I can see here -<br>1) warning from Swift compiler if method in type just shadowing default <br>implementation in protocol and such protocol&#39;s mehtod will be dispatched <br>statically(in any of two possible situation of static dispatch)<br>2) *plus* some posibility to &#39;fix&#39; this warning. I see two options here:<br>some @warn_nondynamic(OurType.someMethod)<br>which will say to compiler &quot;I know that OurType.someMethod is the same as <br>protocol extension method that will be dispatched statically&quot;<br>or<br>some extended decorations in type itself or in *type extension*:<br>extension OurType {<br>   nondynamicwarn func someMethod(); // probably ; required here<br>}<br></p><p>On 21.05.2016 23:16, Brent Royal-Gordon via swift-evolution wrote:<br>&gt; I *did* propose forcing them final, and I&#39;m still very skeptical that a<br>&gt; `nondynamic` keyword that does nothing when you shadow the method is a<br>&gt; good idea. People are still going to naïvely try to override these<br>&gt; methods and be surprised when it doesn&#39;t work. A `nondynamic` keyword at<br>&gt; the original declaration site will help them understand what happened<br>&gt; when they&#39;re investigating the bug, but it still seems like this kind of<br>&gt; code is so suspect that Swift ought to flag it from the start.<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>May 22, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; On May 21, 2016, at 9:40 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; By annotation I just meant something indicating behavior.  Your &#39;nondynamic&#39; qualifies, but is not the right term.<br>&gt; <br>&gt; &#39;dynamic&#39; in Swift does not just mean dynamic dispatch semantics.  It means always dispatched through the Objective-C runtime.  If it didn&#39;t already have this meaning I would probably like &#39;nondynamic&#39; quite a bit as a more precise alternative.<br></p><p>Virtual/nonvirtual?<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160522/ff3ad75b/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 22, 2016 at 09:00:00am</p></header><div class="content"><p>I support *at least* to introduce such a special marker for method declared <br>*only* in protocol extension (no declaration for it in protocol itself) to <br>make it clear that it will be dispatched statically.<br>Probably right now I support `nondynamic`.<br></p><p>But, there is question regarding another situation when the protocol method <br>dispatched *statically* even if *defined* in protocol declaration:<br></p><p>protocol A {<br>     func f()<br>     func x()<br>}<br></p><p>extension A {<br>     func x() {print(&quot;a-x&quot;)}<br>}<br></p><p>class B: A { // already strange. B depends on A extension. did not <br>implement all required methods from A<br>     func f() {}<br>}<br></p><p>class C: B {<br>     func x(){print(&quot;c-x&quot;)}<br>}<br></p><p>var c : A = C()<br>c.x() // &quot;a-x&quot;. but C() *implements* x() that *is* defined in protocol<br></p><p>IMO this is totally unexpected and must be dispatched dynamically. I <br>believe that there can not be any explanation why this is correct: A - is a <br>protocol, C - is a class conformed to A protocol and implemented all <br>methods of that protocol.<br></p><p>It is clear, that you don&#39;t want to decorate A.x() with such `nondynamic` <br>as if it was implemented in B - it will be dynamic:<br></p><p>class B: A {<br>     func f() {}<br>     func x(){print(&quot;b-x&quot;)}<br>}<br></p><p>var b : A = B()<br>b.x() // &quot;b-x&quot;. now dynamic<br></p><p>So, again, IMO  at least we need to decorate protocol extension methods <br>that was not defined in protocol itself, but the &#39;issue&#39; is bigger &#39;than <br>just this.<br></p><p>On 21.05.2016 16:27, Matthew Johnson via swift-evolution wrote:<br>&gt; Nobody is talking about forcing them final.  We are talking about<br>&gt; annotating them with a keyword that documents their behavior (which is<br>&gt; unintuitive for sure but makes sense when you think through how things<br>&gt; work behind the scenes).<br>&gt;<br>&gt; Maybe we will figure out a way to have something better in the future,<br>&gt; but until then highlighting the behavior via annotation is a pretty good<br>&gt; option.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>May 22, 2016 at 09:00:00am</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On 22 May 2016, at 07:03, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I support *at least* to introduce such a special marker for method declared *only* in protocol extension (no declaration for it in protocol itself) to make it clear that it will be dispatched statically.<br>&gt; Probably right now I support `nondynamic`.<br>&gt; <br>&gt; But, there is question regarding another situation when the protocol method dispatched *statically* even if *defined* in protocol declaration:<br>&gt; <br>&gt; protocol A {<br>&gt;    func f()<br>&gt;    func x()<br>&gt; }<br>&gt; <br>&gt; extension A {<br>&gt;    func x() {print(&quot;a-x&quot;)}<br>&gt; }<br>&gt; <br>&gt; class B: A { // already strange. B depends on A extension. did not implement all required methods from A<br>&gt;    func f() {}<br>&gt; }<br>&gt; <br>&gt; class C: B {<br>&gt;    func x(){print(&quot;c-x&quot;)}<br>&gt; }<br>&gt; <br>&gt; var c : A = C()<br>&gt; c.x() // &quot;a-x&quot;. but C() *implements* x() that *is* defined in protocol<br>&gt; <br>&gt; IMO this is totally unexpected and must be dispatched dynamically. I believe that there can not be any explanation why this is correct: A - is a protocol, C - is a class conformed to A protocol and implemented all methods of that protocol.<br>&gt; <br>&gt; It is clear, that you don&#39;t want to decorate A.x() with such `nondynamic` as if it was implemented in B - it will be dynamic:<br>&gt; <br>&gt; class B: A {<br>&gt;    func f() {}<br>&gt;    func x(){print(&quot;b-x&quot;)}<br>&gt; }<br>&gt; <br>&gt; var b : A = B()<br>&gt; b.x() // &quot;b-x&quot;. now dynamic<br>&gt; <br>&gt; So, again, IMO  at least we need to decorate protocol extension methods that was not defined in protocol itself, but the &#39;issue&#39; is bigger &#39;than just this.<br></p><p>Agreed, the issue is an important one of deterministic logical behaviour. Especially with protocols which help us decouple behaviour from implementation of said behaviour, but not just with protocols, there should not be a case in which depending on the type of the reference used you call a method or another.<br></p><p>If an instance implements a method and said method is called on said instance the instead implementation should execute no matter the type of the reference we are accessing it by. Message dispatching in Objective-C got this right. <br></p><p>I do not think always dynamic dispatching/runtime message sending is not inherently unsafe/bad... and I am willing to trade off some of the extra automagic safety for the flexibility and predictability it can bring when used well. Without multiple inheritance and default methods/code in protocols, it is easier to tame the beast and have a working design in my opinion.<br></p><p>&gt; <br>&gt;&gt; On 21.05.2016 16:27, Matthew Johnson via swift-evolution wrote:<br>&gt;&gt; Nobody is talking about forcing them final.  We are talking about<br>&gt;&gt; annotating them with a keyword that documents their behavior (which is<br>&gt;&gt; unintuitive for sure but makes sense when you think through how things<br>&gt;&gt; work behind the scenes).<br>&gt;&gt; <br>&gt;&gt; Maybe we will figure out a way to have something better in the future,<br>&gt;&gt; but until then highlighting the behavior via annotation is a pretty good<br>&gt;&gt; option.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 22, 2016 at 01:00:00pm</p></header><div class="content"><p>I posted a small playground with a few of the identified use cases <br></p><p>	https://github.com/lmihalkovic/swift-lang<br></p><p>I also wrote somewhat of a summary of the current behavior (with what might cause trouble) and a summary of a few of the proposed remedies:<br></p><p>	https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160516/018560.html<br></p><p><br></p><p>&gt; On May 22, 2016, at 8:03 AM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I support *at least* to introduce such a special marker for method declared *only* in protocol extension (no declaration for it in protocol itself) to make it clear that it will be dispatched statically.<br>&gt; Probably right now I support `nondynamic`.<br>&gt; <br>&gt; But, there is question regarding another situation when the protocol method dispatched *statically* even if *defined* in protocol declaration:<br>&gt; <br>&gt; protocol A {<br>&gt;    func f()<br>&gt;    func x()<br>&gt; }<br>&gt; <br>&gt; extension A {<br>&gt;    func x() {print(&quot;a-x&quot;)}<br>&gt; }<br>&gt; <br>&gt; class B: A { // already strange. B depends on A extension. did not implement all required methods from A<br>&gt;    func f() {}<br>&gt; }<br>&gt; <br>&gt; class C: B {<br>&gt;    func x(){print(&quot;c-x&quot;)}<br>&gt; }<br>&gt; <br>&gt; var c : A = C()<br>&gt; c.x() // &quot;a-x&quot;. but C() *implements* x() that *is* defined in protocol<br>&gt; <br>&gt; IMO this is totally unexpected and must be dispatched dynamically. I believe that there can not be any explanation why this is correct: A - is a protocol, C - is a class conformed to A protocol and implemented all methods of that protocol.<br>&gt; <br>&gt; It is clear, that you don&#39;t want to decorate A.x() with such `nondynamic` as if it was implemented in B - it will be dynamic:<br>&gt; <br>&gt; class B: A {<br>&gt;    func f() {}<br>&gt;    func x(){print(&quot;b-x&quot;)}<br>&gt; }<br>&gt; <br>&gt; var b : A = B()<br>&gt; b.x() // &quot;b-x&quot;. now dynamic<br>&gt; <br>&gt; So, again, IMO  at least we need to decorate protocol extension methods that was not defined in protocol itself, but the &#39;issue&#39; is bigger &#39;than just this.<br>&gt; <br>&gt; On 21.05.2016 16:27, Matthew Johnson via swift-evolution wrote:<br>&gt;&gt; Nobody is talking about forcing them final.  We are talking about<br>&gt;&gt; annotating them with a keyword that documents their behavior (which is<br>&gt;&gt; unintuitive for sure but makes sense when you think through how things<br>&gt;&gt; work behind the scenes).<br>&gt;&gt; <br>&gt;&gt; Maybe we will figure out a way to have something better in the future,<br>&gt;&gt; but until then highlighting the behavior via annotation is a pretty good<br>&gt;&gt; option.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 21, 2016 at 07:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>On May 21, 2016, at 6:42 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; That said, has anyone considered requiring a keyword on the method in the protocol extension that makes it explicit that the dispatch is non-dynamic?<br>&gt; <br>&gt; Many moons ago, I was pushing to require a `final` keyword on protocol extension methods, which would prevent conforming types from providing their own implementations. It was probably the first thing I worked on. There were long arguments about whether and how you could override the `final`-ness, people kept clamoring for dynamic dispatch, and I ultimately wasn&#39;t able to produce a consensus before I had to turn my attention back towards paying work.<br></p><p>I agree a keyword here might be useful, but I&#39;m not sure &#39;final&#39; is the right choice.  The problem with this is that they aren&#39;t exactly &#39;final&#39;.  They can be shadowed by conforming types when the static type of an instance is the concrete type.  Disallowing shadowing by the concrete type is problematic in a number of ways (retroactive modeling, openness of protocol extensions, etc).  <br></p><p>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
