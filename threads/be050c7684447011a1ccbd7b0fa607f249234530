<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c14b8de3a00d0b57e1372600c83120cd?s=50"></div><header><strong>[Pitch] Reference storage for enum associated values</strong> from <string>Marc Prud&#39;hommeaux</string> &lt;marc at glimpse.io&gt;<p>May  3, 2016 at 11:00:00am</p></header><div class="content"><p>The following code currently has a retain cycle and memory leak:<br></p><p>enum ParentChild {<br>    case SonOf(Parent)<br>    case DaughterOf(Parent)<br>}<br></p><p>class Parent {<br>    lazy var son: Child = Child(parentChild: .SonOf(self))<br>    lazy var daughter: Child = Child(parentChild: .DaughterOf(self))<br>    deinit { print(&quot;deinit Parent&quot;) }<br>}<br></p><p>class Child {<br>    var parentChild: ParentChild<br>    init(parentChild: ParentChild) {<br>        self.parentChild = parentChild<br>    }<br>    deinit { print(&quot;deinit Child&quot;) }<br>}<br></p><p><br>do {<br>    let parent = Parent()<br>    parent.son<br>    parent.daughter<br>}<br></p><p><br>Child.parentChild cannot be declared unowned because ParentChild is a value type. I propose adding the ability to declare the reference storage class for an enum&#39;s associated value, like so:<br></p><p>enum ParentChild {<br>    case SonOf(unowned Parent)<br>    case DaughterOf(unowned Parent)<br>}<br></p><p>The only current alternative is to have some intermediate reference type that itself holds the reference, akin to the old &quot;Box&quot; type that we used to use to work around enum limitations. E.g., this is our current cumbersome work-around:<br></p><p>/// An unowned reference to a value, which is useful for maintaining parent-child relations through value types like enums<br>public struct UnownedRef&lt;T: AnyObject&gt; {<br>    public unowned let value: T<br>    public init(_ value: T) { self.value = value }<br>}<br></p><p>enum ParentChild {<br>    case SonOf(UnownedRef&lt;Parent&gt;)<br>    case DaughterOf(UnownedRef&lt;Parent&gt;)<br>}<br></p><p><br>class Parent {<br>    lazy var son: Child = Child(parentChild: .SonOf(UnownedRef(self)))<br>    lazy var daughter: Child = Child(parentChild: .DaughterOf(UnownedRef(self)))<br>    deinit { print(&quot;deinit Foo&quot;) }<br>}<br></p><p>class Child {<br>    var parentChild: ParentChild<br>    init(parentChild: ParentChild) {<br>        self.parentChild = parentChild<br>    }<br></p><p>    deinit { print(&quot;deinit Child&quot;) }<br>}<br></p><p>The storage type of an enum would, of course, be limited to reference types, and when the storage class is weak, it would require that the stored type be Optional, just like when declaring a weak variable.<br></p><p>What do people think?<br></p><p>	-Marc<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160503/be054530/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Pitch] Reference storage for enum associated values</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>May  3, 2016 at 11:00:00pm</p></header><div class="content"><p>It’s an interesting idea, but with the workaround you’ve found I wonder if it might make more sense to just have Unowned&lt;T&gt; and Weak&lt;T&gt; in the standard library? I’ve already defined these myself to work with a few awkward cases and to allow entries in collections to be weakly referenced.<br></p><p>I mean it’d be nice to have keyword support too; I wonder if could be made more flexible, e.g- let us also write things like:<br></p><p>	let foo:[weak AnyObject] = …<br></p><p>Externally this would appear as if the array were of type AnyObject?, but internally the array would have an actual type of Weak&lt;AnyObject&gt; or whatever. I dunno, just thinking out loud, point being that maybe this isn’t enum specific, even though enum is an important use-case, i.e- a keyword or global function could make this easier to do throughout the language.<br></p><p>&gt; On 3 May 2016, at 16:07, Marc Prud&#39;hommeaux via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; The following code currently has a retain cycle and memory leak:<br>&gt; <br>&gt; enum ParentChild {<br>&gt;     case SonOf(Parent)<br>&gt;     case DaughterOf(Parent)<br>&gt; }<br>&gt; <br>&gt; class Parent {<br>&gt;     lazy var son: Child = Child(parentChild: .SonOf(self))<br>&gt;     lazy var daughter: Child = Child(parentChild: .DaughterOf(self))<br>&gt;     deinit { print(&quot;deinit Parent&quot;) }<br>&gt; }<br>&gt; <br>&gt; class Child {<br>&gt;     var parentChild: ParentChild<br>&gt;     init(parentChild: ParentChild) {<br>&gt;         self.parentChild = parentChild<br>&gt;     }<br>&gt;     deinit { print(&quot;deinit Child&quot;) }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; do {<br>&gt;     let parent = Parent()<br>&gt;     parent.son<br>&gt;     parent.daughter<br>&gt; }<br>&gt; <br>&gt; <br>&gt; Child.parentChild cannot be declared unowned because ParentChild is a value type. I propose adding the ability to declare the reference storage class for an enum&#39;s associated value, like so:<br>&gt; <br>&gt; enum ParentChild {<br>&gt;     case SonOf(unowned Parent)<br>&gt;     case DaughterOf(unowned Parent)<br>&gt; }<br>&gt; <br>&gt; The only current alternative is to have some intermediate reference type that itself holds the reference, akin to the old &quot;Box&quot; type that we used to use to work around enum limitations. E.g., this is our current cumbersome work-around:<br>&gt; <br>&gt; /// An unowned reference to a value, which is useful for maintaining parent-child relations through value types like enums<br>&gt; public struct UnownedRef&lt;T: AnyObject&gt; {<br>&gt;     public unowned let value: T<br>&gt;     public init(_ value: T) { self.value = value }<br>&gt; }<br>&gt; <br>&gt; enum ParentChild {<br>&gt;     case SonOf(UnownedRef&lt;Parent&gt;)<br>&gt;     case DaughterOf(UnownedRef&lt;Parent&gt;)<br>&gt; }<br>&gt; <br>&gt; <br>&gt; class Parent {<br>&gt;     lazy var son: Child = Child(parentChild: .SonOf(UnownedRef(self)))<br>&gt;     lazy var daughter: Child = Child(parentChild: .DaughterOf(UnownedRef(self)))<br>&gt;     deinit { print(&quot;deinit Foo&quot;) }<br>&gt; }<br>&gt; <br>&gt; class Child {<br>&gt;     var parentChild: ParentChild<br>&gt;     init(parentChild: ParentChild) {<br>&gt;         self.parentChild = parentChild<br>&gt;     }<br>&gt; <br>&gt;     deinit { print(&quot;deinit Child&quot;) }<br>&gt; }<br>&gt; <br>&gt; The storage type of an enum would, of course, be limited to reference types, and when the storage class is weak, it would require that the stored type be Optional, just like when declaring a weak variable.<br>&gt; <br>&gt; What do people think?<br>&gt; <br>&gt; 	-Marc<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160503/009d71ff/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[Pitch] Reference storage for enum associated values</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>May  3, 2016 at 05:00:00pm</p></header><div class="content"><p>Why not separate the reference and its info? That way you can make the<br>reference weak.<br></p><p>  <br></p><p>enum ParentChildRelationship {<br></p><p>  case Son<br></p><p>  case Daughter<br></p><p>}<br></p><p>  <br></p><p>class Parent {<br></p><p>  lazy var son: Child = Child(sonOf: self)<br></p><p>  lazy var daughter: Child = Child(daughterOf: self)<br></p><p>  deinit { print(&quot;deinit Parent&quot;) }<br></p><p>}<br></p><p>  <br></p><p>class Child {<br></p><p>  weak var parent: Parent?<br></p><p>  var parentRelationship: ParentChildRelationship<br></p><p>  init(parent: Parent, relationship: ParentChildRelationship) {<br></p><p>    self.parent = parent<br></p><p>    self.parentRelationship = relationship<br></p><p>  }<br></p><p>  convenience init(sonOf parent: Parent) {<br></p><p>    self.init(parent: parent, relationship: .Son)<br></p><p>  }<br></p><p>  <br></p><p>  convenience init(daughterOf parent: Parent) {<br></p><p>    self.init(parent: parent, relationship: .Daughter)<br></p><p>  }<br></p><p>  <br></p><p>  deinit { print(&quot;deinit Child&quot;) }<br></p><p>}<br></p><p>  <br></p><p>  <br></p><p>do {<br></p><p>  let parent = Parent()<br></p><p>  parent.son<br></p><p>  parent.daughter<br></p><p>}<br></p><p>  <br></p><p>  <br>**Patrick Smith**  <br></p><p>On May 4 2016, at 1:07 am, Marc Prud&#39;hommeaux via swift-evolution &amp;lt;swift-<br>evolution at swift.org&amp;gt; wrote:  <br></p><p>&gt;  <br></p><p>&gt;<br></p><p>&gt; The following code currently has a retain cycle and memory leak:<br></p><p>&gt;<br></p><p>&gt;  <br></p><p>&gt;<br></p><p>&gt; enum ParentChild {<br></p><p>&gt;<br></p><p>&gt;     case SonOf(Parent)<br></p><p>&gt;<br></p><p>&gt;     case DaughterOf(Parent)<br></p><p>&gt;<br></p><p>&gt; }<br></p><p>&gt;<br></p><p>&gt;  <br></p><p>&gt;<br></p><p>&gt; class Parent {<br></p><p>&gt;<br></p><p>&gt;     lazy var son: Child = Child(parentChild: .SonOf(self))<br></p><p>&gt;<br></p><p>&gt;     lazy var daughter: Child = Child(parentChild: .DaughterOf(self))<br></p><p>&gt;<br></p><p>&gt;     deinit { print(&quot;deinit Parent&quot;) }<br></p><p>&gt;<br></p><p>&gt; }<br></p><p>&gt;<br></p><p>&gt;  <br></p><p>&gt;<br></p><p>&gt; class Child {<br></p><p>&gt;<br></p><p>&gt;     var parentChild: ParentChild<br></p><p>&gt;<br></p><p>&gt;     init(parentChild: ParentChild) {<br></p><p>&gt;<br></p><p>&gt;         self.parentChild = parentChild<br></p><p>&gt;<br></p><p>&gt;     }<br></p><p>&gt;<br></p><p>&gt;     deinit { print(&quot;deinit Child&quot;) }<br></p><p>&gt;<br></p><p>&gt; }<br></p><p>&gt;<br></p><p>&gt;  <br></p><p>&gt;<br></p><p>&gt;  <br></p><p>&gt;<br></p><p>&gt; do {<br></p><p>&gt;<br></p><p>&gt;     let parent = Parent()<br></p><p>&gt;<br></p><p>&gt;     parent.son<br></p><p>&gt;<br></p><p>&gt;     parent.daughter<br></p><p>&gt;<br></p><p>&gt; }<br></p><p>&gt;<br></p><p>&gt;  <br></p><p>&gt;<br></p><p>&gt;  <br></p><p>&gt;<br></p><p>&gt; Child.parentChild cannot be declared unowned because ParentChild is a value<br>type. I propose adding the ability to declare the reference storage class for<br>an enum&#39;s associated value, like so:<br></p><p>&gt;<br></p><p>&gt;  <br></p><p>&gt;<br></p><p>&gt; enum ParentChild {<br></p><p>&gt;<br></p><p>&gt;     case SonOf(unowned Parent)<br></p><p>&gt;<br></p><p>&gt;     case DaughterOf(unowned Parent)<br></p><p>&gt;<br></p><p>&gt; }<br></p><p>&gt;<br></p><p>&gt;  <br></p><p>&gt;<br></p><p>&gt; The only current alternative is to have some intermediate reference type<br>that itself holds the reference, akin to the old &quot;Box&quot; type that we used to<br>use to work around enum limitations. E.g., this is our current cumbersome<br>work-around:<br></p><p>&gt;<br></p><p>&gt;  <br></p><p>&gt;<br></p><p>&gt; /// An unowned reference to a value, which is useful for maintaining parent-<br>child relations through value types like enums<br></p><p>&gt;<br></p><p>&gt; public struct UnownedRef&amp;lt;T: AnyObject&amp;gt; {<br></p><p>&gt;<br></p><p>&gt;     public unowned let value: T<br></p><p>&gt;<br></p><p>&gt;     public init(_ value: T) { self.value = value }<br></p><p>&gt;<br></p><p>&gt; }<br></p><p>&gt;<br></p><p>&gt;  <br></p><p>&gt;<br></p><p>&gt; enum ParentChild {<br></p><p>&gt;<br></p><p>&gt;     case SonOf(UnownedRef&amp;lt;Parent&amp;gt;)<br></p><p>&gt;<br></p><p>&gt;     case DaughterOf(UnownedRef&amp;lt;Parent&amp;gt;)<br></p><p>&gt;<br></p><p>&gt; }<br></p><p>&gt;<br></p><p>&gt;  <br></p><p>&gt;<br></p><p>&gt;  <br></p><p>&gt;<br></p><p>&gt; class Parent {<br></p><p>&gt;<br></p><p>&gt;     lazy var son: Child = Child(parentChild: .SonOf(UnownedRef(self)))<br></p><p>&gt;<br></p><p>&gt;     lazy var daughter: Child = Child(parentChild:<br>.DaughterOf(UnownedRef(self)))<br></p><p>&gt;<br></p><p>&gt;     deinit { print(&quot;deinit Foo&quot;) }<br></p><p>&gt;<br></p><p>&gt; }<br></p><p>&gt;<br></p><p>&gt;  <br></p><p>&gt;<br></p><p>&gt; class Child {<br></p><p>&gt;<br></p><p>&gt;     var parentChild: ParentChild<br></p><p>&gt;<br></p><p>&gt;     init(parentChild: ParentChild) {<br></p><p>&gt;<br></p><p>&gt;         self.parentChild = parentChild<br></p><p>&gt;<br></p><p>&gt;     }<br></p><p>&gt;<br></p><p>&gt;  <br></p><p>&gt;<br></p><p>&gt;     deinit { print(&quot;deinit Child&quot;) }<br></p><p>&gt;<br></p><p>&gt; }<br></p><p>&gt;<br></p><p>&gt;  <br></p><p>&gt;<br></p><p>&gt; The storage type of an enum would, of course, be limited to reference types,<br>and when the storage class is weak, it would require that the stored type be<br>Optional, just like when declaring a weak variable.<br></p><p>&gt;<br></p><p>&gt;  <br></p><p>&gt;<br></p><p>&gt; What do people think?<br></p><p>&gt;<br></p><p>&gt;  <br></p><p>&gt;<br></p><p>&gt; -Marc<br></p><p>&gt;<br></p><p>&gt;  <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160503/8cdb30f3/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>[Pitch] Reference storage for enum associated values</strong> from <string>Michael Peternell</string> &lt;michael.peternell at gmx.at&gt;<p>May  4, 2016 at 06:00:00pm</p></header><div class="content"><p>I wonder if there is a practical use-case for this.. Is there? Just curious...<br></p><p>-Michael<br></p><p>&gt; Am 03.05.2016 um 17:07 schrieb Marc Prud&#39;hommeaux via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt; The following code currently has a retain cycle and memory leak:<br>&gt; <br>&gt; enum ParentChild {<br>&gt;     case SonOf(Parent)<br>&gt;     case DaughterOf(Parent)<br>&gt; }<br>&gt; <br>&gt; class Parent {<br>&gt;     lazy var son: Child = Child(parentChild: .SonOf(self))<br>&gt;     lazy var daughter: Child = Child(parentChild: .DaughterOf(self))<br>&gt;     deinit { print(&quot;deinit Parent&quot;) }<br>&gt; }<br>&gt; <br>&gt; class Child {<br>&gt;     var parentChild: ParentChild<br>&gt;     init(parentChild: ParentChild) {<br>&gt;         self.parentChild = parentChild<br>&gt;     }<br>&gt;     deinit { print(&quot;deinit Child&quot;) }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; do {<br>&gt;     let parent = Parent()<br>&gt;     parent.son<br>&gt;     parent.daughter<br>&gt; }<br>&gt; <br>&gt; <br>&gt; Child.parentChild cannot be declared unowned because ParentChild is a value type. I propose adding the ability to declare the reference storage class for an enum&#39;s associated value, like so:<br>&gt; <br>&gt; enum ParentChild {<br>&gt;     case SonOf(unowned Parent)<br>&gt;     case DaughterOf(unowned Parent)<br>&gt; }<br>&gt; <br>&gt; The only current alternative is to have some intermediate reference type that itself holds the reference, akin to the old &quot;Box&quot; type that we used to use to work around enum limitations. E.g., this is our current cumbersome work-around:<br>&gt; <br>&gt; /// An unowned reference to a value, which is useful for maintaining parent-child relations through value types like enums<br>&gt; public struct UnownedRef&lt;T: AnyObject&gt; {<br>&gt;     public unowned let value: T<br>&gt;     public init(_ value: T) { self.value = value }<br>&gt; }<br>&gt; <br>&gt; enum ParentChild {<br>&gt;     case SonOf(UnownedRef&lt;Parent&gt;)<br>&gt;     case DaughterOf(UnownedRef&lt;Parent&gt;)<br>&gt; }<br>&gt; <br>&gt; <br>&gt; class Parent {<br>&gt;     lazy var son: Child = Child(parentChild: .SonOf(UnownedRef(self)))<br>&gt;     lazy var daughter: Child = Child(parentChild: .DaughterOf(UnownedRef(self)))<br>&gt;     deinit { print(&quot;deinit Foo&quot;) }<br>&gt; }<br>&gt; <br>&gt; class Child {<br>&gt;     var parentChild: ParentChild<br>&gt;     init(parentChild: ParentChild) {<br>&gt;         self.parentChild = parentChild<br>&gt;     }<br>&gt; <br>&gt;     deinit { print(&quot;deinit Child&quot;) }<br>&gt; }<br>&gt; <br>&gt; The storage type of an enum would, of course, be limited to reference types, and when the storage class is weak, it would require that the stored type be Optional, just like when declaring a weak variable.<br>&gt; <br>&gt; What do people think?<br>&gt; <br>&gt; 	-Marc<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c14b8de3a00d0b57e1372600c83120cd?s=50"></div><header><strong>[Pitch] Reference storage for enum associated values</strong> from <string>Marc Prud&#39;hommeaux</string> &lt;marc at glimpse.io&gt;<p>May  6, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; I wonder if there is a practical use-case for this.. Is there? Just curious...<br></p><p>Without getting too deep into the weeds of our specific data modal, I&#39;ll summarize with &quot;yes&quot;. If you need to mix classes with enums and don&#39;t have the ability to declare the storage class of the variables, then reference cycles can only be avoided by shimming in some other type that does permit the declaration of the storage type. I would be surprised if I was the only person to encounter this issue; anyone else?<br></p><p>It is analogous to the hoops you would need to jump through to define a recursive enum before the &quot;indirect&quot; keyword. As a matter of fact, it is so similar to that case that I wonder if it would make sense to have weak/unowned keywords be before the case name, as with indirect. E.g.:<br></p><p>enum ChildGuardianship {<br>    unowned case ChildOf(Parent)<br>    indirect case GrandChildOf(ChildGuardianship)<br>    weak case WardOf(State?)<br>}<br></p><p>The obvious limitation of this would be that all associated types would be pegged to the same storage class, preventing the ability of having one associated type be weak and another be unowned. This limitation of indirect was mentioned at https://lists.swift.org/pipermail/swift-dev/Week-of-Mon-20151207/000312.html , but it doesn&#39;t seem to have been given much treatment since.<br></p><p>	-Marc<br></p><p><br>&gt; On May 4, 2016, at 12:25 PM, Michael Peternell &lt;michael.peternell at gmx.at&gt; wrote:<br>&gt; <br>&gt; I wonder if there is a practical use-case for this.. Is there? Just curious...<br>&gt; <br>&gt; -Michael<br>&gt; <br>&gt;&gt; Am 03.05.2016 um 17:07 schrieb Marc Prud&#39;hommeaux via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; The following code currently has a retain cycle and memory leak:<br>&gt;&gt; <br>&gt;&gt; enum ParentChild {<br>&gt;&gt;    case SonOf(Parent)<br>&gt;&gt;    case DaughterOf(Parent)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class Parent {<br>&gt;&gt;    lazy var son: Child = Child(parentChild: .SonOf(self))<br>&gt;&gt;    lazy var daughter: Child = Child(parentChild: .DaughterOf(self))<br>&gt;&gt;    deinit { print(&quot;deinit Parent&quot;) }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class Child {<br>&gt;&gt;    var parentChild: ParentChild<br>&gt;&gt;    init(parentChild: ParentChild) {<br>&gt;&gt;        self.parentChild = parentChild<br>&gt;&gt;    }<br>&gt;&gt;    deinit { print(&quot;deinit Child&quot;) }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; do {<br>&gt;&gt;    let parent = Parent()<br>&gt;&gt;    parent.son<br>&gt;&gt;    parent.daughter<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Child.parentChild cannot be declared unowned because ParentChild is a value type. I propose adding the ability to declare the reference storage class for an enum&#39;s associated value, like so:<br>&gt;&gt; <br>&gt;&gt; enum ParentChild {<br>&gt;&gt;    case SonOf(unowned Parent)<br>&gt;&gt;    case DaughterOf(unowned Parent)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; The only current alternative is to have some intermediate reference type that itself holds the reference, akin to the old &quot;Box&quot; type that we used to use to work around enum limitations. E.g., this is our current cumbersome work-around:<br>&gt;&gt; <br>&gt;&gt; /// An unowned reference to a value, which is useful for maintaining parent-child relations through value types like enums<br>&gt;&gt; public struct UnownedRef&lt;T: AnyObject&gt; {<br>&gt;&gt;    public unowned let value: T<br>&gt;&gt;    public init(_ value: T) { self.value = value }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; enum ParentChild {<br>&gt;&gt;    case SonOf(UnownedRef&lt;Parent&gt;)<br>&gt;&gt;    case DaughterOf(UnownedRef&lt;Parent&gt;)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; class Parent {<br>&gt;&gt;    lazy var son: Child = Child(parentChild: .SonOf(UnownedRef(self)))<br>&gt;&gt;    lazy var daughter: Child = Child(parentChild: .DaughterOf(UnownedRef(self)))<br>&gt;&gt;    deinit { print(&quot;deinit Foo&quot;) }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class Child {<br>&gt;&gt;    var parentChild: ParentChild<br>&gt;&gt;    init(parentChild: ParentChild) {<br>&gt;&gt;        self.parentChild = parentChild<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;    deinit { print(&quot;deinit Child&quot;) }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; The storage type of an enum would, of course, be limited to reference types, and when the storage class is weak, it would require that the stored type be Optional, just like when declaring a weak variable.<br>&gt;&gt; <br>&gt;&gt; What do people think?<br>&gt;&gt; <br>&gt;&gt; 	-Marc<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>[Pitch] Reference storage for enum associated values</strong> from <string>Michael Peternell</string> &lt;michael.peternell at gmx.at&gt;<p>May  6, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; Am 06.05.2016 um 14:08 schrieb Marc Prud&#39;hommeaux &lt;marc at glimpse.io&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; I wonder if there is a practical use-case for this.. Is there? Just curious...<br>&gt; <br>&gt; Without getting too deep into the weeds of our specific data modal, I&#39;ll summarize with &quot;yes&quot;. If you need to mix classes with enums and don&#39;t have the ability to declare the storage class of the variables, then reference cycles can only be avoided by shimming in some other type that does permit the declaration of the storage type. I would be surprised if I was the only person to encounter this issue; anyone else?<br>&gt; <br>&gt; It is analogous to the hoops you would need to jump through to define a recursive enum before the &quot;indirect&quot; keyword. As a matter of fact, it is so similar to that case that I wonder if it would make sense to have weak/unowned keywords be before the case name, as with indirect. E.g.:<br>&gt; <br>&gt; enum ChildGuardianship {<br>&gt;    unowned case ChildOf(Parent)<br>&gt;    indirect case GrandChildOf(ChildGuardianship)<br>&gt;    weak case WardOf(State?)<br>&gt; }<br></p><p>sorry, that doesn&#39;t really convince me. I don&#39;t consider a &quot;ChildGuardianship&quot; enum a practical use-case. The same for &quot;child&quot;, &quot;parent&quot;, &quot;daughterOf&quot;, &quot;sonOf&quot;, etc. Or were you programming a kindergarten application to help the kindergarten teachers to bill the parents correctly?<br></p><p>The obvious problem with a storage class in value types is that weak references are by definition mutable: they zero out as soon as the pointee starts deallocating. This means that the ChildGuardianship enum is no longer a real value type with value semantics but a value type with partial reference semantics.<br></p><p>I&#39;m sure there is a practical use-case for this somewhere, but I doubt that it would be generally useful enough to be included into Swift at the language level.<br></p><p>-Michael<br></p><p>&gt; <br>&gt; The obvious limitation of this would be that all associated types would be pegged to the same storage class, preventing the ability of having one associated type be weak and another be unowned. This limitation of indirect was mentioned at https://lists.swift.org/pipermail/swift-dev/Week-of-Mon-20151207/000312.html , but it doesn&#39;t seem to have been given much treatment since.<br>&gt; <br>&gt; 	-Marc<br>&gt; <br>&gt; <br>&gt;&gt; On May 4, 2016, at 12:25 PM, Michael Peternell &lt;michael.peternell at gmx.at&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I wonder if there is a practical use-case for this.. Is there? Just curious...<br>&gt;&gt; <br>&gt;&gt; -Michael<br>&gt;&gt; <br>&gt;&gt;&gt; Am 03.05.2016 um 17:07 schrieb Marc Prud&#39;hommeaux via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The following code currently has a retain cycle and memory leak:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; enum ParentChild {<br>&gt;&gt;&gt;   case SonOf(Parent)<br>&gt;&gt;&gt;   case DaughterOf(Parent)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class Parent {<br>&gt;&gt;&gt;   lazy var son: Child = Child(parentChild: .SonOf(self))<br>&gt;&gt;&gt;   lazy var daughter: Child = Child(parentChild: .DaughterOf(self))<br>&gt;&gt;&gt;   deinit { print(&quot;deinit Parent&quot;) }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class Child {<br>&gt;&gt;&gt;   var parentChild: ParentChild<br>&gt;&gt;&gt;   init(parentChild: ParentChild) {<br>&gt;&gt;&gt;       self.parentChild = parentChild<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt;   deinit { print(&quot;deinit Child&quot;) }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; do {<br>&gt;&gt;&gt;   let parent = Parent()<br>&gt;&gt;&gt;   parent.son<br>&gt;&gt;&gt;   parent.daughter<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Child.parentChild cannot be declared unowned because ParentChild is a value type. I propose adding the ability to declare the reference storage class for an enum&#39;s associated value, like so:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; enum ParentChild {<br>&gt;&gt;&gt;   case SonOf(unowned Parent)<br>&gt;&gt;&gt;   case DaughterOf(unowned Parent)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The only current alternative is to have some intermediate reference type that itself holds the reference, akin to the old &quot;Box&quot; type that we used to use to work around enum limitations. E.g., this is our current cumbersome work-around:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; /// An unowned reference to a value, which is useful for maintaining parent-child relations through value types like enums<br>&gt;&gt;&gt; public struct UnownedRef&lt;T: AnyObject&gt; {<br>&gt;&gt;&gt;   public unowned let value: T<br>&gt;&gt;&gt;   public init(_ value: T) { self.value = value }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; enum ParentChild {<br>&gt;&gt;&gt;   case SonOf(UnownedRef&lt;Parent&gt;)<br>&gt;&gt;&gt;   case DaughterOf(UnownedRef&lt;Parent&gt;)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class Parent {<br>&gt;&gt;&gt;   lazy var son: Child = Child(parentChild: .SonOf(UnownedRef(self)))<br>&gt;&gt;&gt;   lazy var daughter: Child = Child(parentChild: .DaughterOf(UnownedRef(self)))<br>&gt;&gt;&gt;   deinit { print(&quot;deinit Foo&quot;) }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class Child {<br>&gt;&gt;&gt;   var parentChild: ParentChild<br>&gt;&gt;&gt;   init(parentChild: ParentChild) {<br>&gt;&gt;&gt;       self.parentChild = parentChild<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   deinit { print(&quot;deinit Child&quot;) }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The storage type of an enum would, of course, be limited to reference types, and when the storage class is weak, it would require that the stored type be Optional, just like when declaring a weak variable.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What do people think?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	-Marc<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c14b8de3a00d0b57e1372600c83120cd?s=50"></div><header><strong>[Pitch] Reference storage for enum associated values</strong> from <string>Marc Prud&#39;hommeaux</string> &lt;marc at glimpse.io&gt;<p>May  6, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; This means that the ChildGuardianship enum is no longer a real value type with value semantics but a value type with partial reference semantics.<br></p><p>That&#39;s already true of any enum that has an associated reference type.<br></p><p><br>&gt; On May 6, 2016, at 10:26 AM, Michael Peternell &lt;michael.peternell at gmx.at&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Am 06.05.2016 um 14:08 schrieb Marc Prud&#39;hommeaux &lt;marc at glimpse.io&gt;:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; I wonder if there is a practical use-case for this.. Is there? Just curious...<br>&gt;&gt; <br>&gt;&gt; Without getting too deep into the weeds of our specific data modal, I&#39;ll summarize with &quot;yes&quot;. If you need to mix classes with enums and don&#39;t have the ability to declare the storage class of the variables, then reference cycles can only be avoided by shimming in some other type that does permit the declaration of the storage type. I would be surprised if I was the only person to encounter this issue; anyone else?<br>&gt;&gt; <br>&gt;&gt; It is analogous to the hoops you would need to jump through to define a recursive enum before the &quot;indirect&quot; keyword. As a matter of fact, it is so similar to that case that I wonder if it would make sense to have weak/unowned keywords be before the case name, as with indirect. E.g.:<br>&gt;&gt; <br>&gt;&gt; enum ChildGuardianship {<br>&gt;&gt;   unowned case ChildOf(Parent)<br>&gt;&gt;   indirect case GrandChildOf(ChildGuardianship)<br>&gt;&gt;   weak case WardOf(State?)<br>&gt;&gt; }<br>&gt; <br>&gt; sorry, that doesn&#39;t really convince me. I don&#39;t consider a &quot;ChildGuardianship&quot; enum a practical use-case. The same for &quot;child&quot;, &quot;parent&quot;, &quot;daughterOf&quot;, &quot;sonOf&quot;, etc. Or were you programming a kindergarten application to help the kindergarten teachers to bill the parents correctly?<br>&gt; <br>&gt; The obvious problem with a storage class in value types is that weak references are by definition mutable: they zero out as soon as the pointee starts deallocating. This means that the ChildGuardianship enum is no longer a real value type with value semantics but a value type with partial reference semantics.<br>&gt; <br>&gt; I&#39;m sure there is a practical use-case for this somewhere, but I doubt that it would be generally useful enough to be included into Swift at the language level.<br>&gt; <br>&gt; -Michael<br>&gt; <br>&gt;&gt; <br>&gt;&gt; The obvious limitation of this would be that all associated types would be pegged to the same storage class, preventing the ability of having one associated type be weak and another be unowned. This limitation of indirect was mentioned at https://lists.swift.org/pipermail/swift-dev/Week-of-Mon-20151207/000312.html , but it doesn&#39;t seem to have been given much treatment since.<br>&gt;&gt; <br>&gt;&gt; 	-Marc<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 4, 2016, at 12:25 PM, Michael Peternell &lt;michael.peternell at gmx.at&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I wonder if there is a practical use-case for this.. Is there? Just curious...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Michael<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 03.05.2016 um 17:07 schrieb Marc Prud&#39;hommeaux via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The following code currently has a retain cycle and memory leak:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; enum ParentChild {<br>&gt;&gt;&gt;&gt;  case SonOf(Parent)<br>&gt;&gt;&gt;&gt;  case DaughterOf(Parent)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class Parent {<br>&gt;&gt;&gt;&gt;  lazy var son: Child = Child(parentChild: .SonOf(self))<br>&gt;&gt;&gt;&gt;  lazy var daughter: Child = Child(parentChild: .DaughterOf(self))<br>&gt;&gt;&gt;&gt;  deinit { print(&quot;deinit Parent&quot;) }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class Child {<br>&gt;&gt;&gt;&gt;  var parentChild: ParentChild<br>&gt;&gt;&gt;&gt;  init(parentChild: ParentChild) {<br>&gt;&gt;&gt;&gt;      self.parentChild = parentChild<br>&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;  deinit { print(&quot;deinit Child&quot;) }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; do {<br>&gt;&gt;&gt;&gt;  let parent = Parent()<br>&gt;&gt;&gt;&gt;  parent.son<br>&gt;&gt;&gt;&gt;  parent.daughter<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Child.parentChild cannot be declared unowned because ParentChild is a value type. I propose adding the ability to declare the reference storage class for an enum&#39;s associated value, like so:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; enum ParentChild {<br>&gt;&gt;&gt;&gt;  case SonOf(unowned Parent)<br>&gt;&gt;&gt;&gt;  case DaughterOf(unowned Parent)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The only current alternative is to have some intermediate reference type that itself holds the reference, akin to the old &quot;Box&quot; type that we used to use to work around enum limitations. E.g., this is our current cumbersome work-around:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; /// An unowned reference to a value, which is useful for maintaining parent-child relations through value types like enums<br>&gt;&gt;&gt;&gt; public struct UnownedRef&lt;T: AnyObject&gt; {<br>&gt;&gt;&gt;&gt;  public unowned let value: T<br>&gt;&gt;&gt;&gt;  public init(_ value: T) { self.value = value }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; enum ParentChild {<br>&gt;&gt;&gt;&gt;  case SonOf(UnownedRef&lt;Parent&gt;)<br>&gt;&gt;&gt;&gt;  case DaughterOf(UnownedRef&lt;Parent&gt;)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class Parent {<br>&gt;&gt;&gt;&gt;  lazy var son: Child = Child(parentChild: .SonOf(UnownedRef(self)))<br>&gt;&gt;&gt;&gt;  lazy var daughter: Child = Child(parentChild: .DaughterOf(UnownedRef(self)))<br>&gt;&gt;&gt;&gt;  deinit { print(&quot;deinit Foo&quot;) }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class Child {<br>&gt;&gt;&gt;&gt;  var parentChild: ParentChild<br>&gt;&gt;&gt;&gt;  init(parentChild: ParentChild) {<br>&gt;&gt;&gt;&gt;      self.parentChild = parentChild<br>&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  deinit { print(&quot;deinit Child&quot;) }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The storage type of an enum would, of course, be limited to reference types, and when the storage class is weak, it would require that the stored type be Optional, just like when declaring a weak variable.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What do people think?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	-Marc<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Pitch] Reference storage for enum associated values</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>May  6, 2016 at 08:00:00am</p></header><div class="content"><p>Another way to address this might be by allowing property behaviors, a feature proposed in https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md to allow for factoring out property implementations, could also apply to `case` declarations. &quot;Weak&quot; and &quot;unowned&quot; could be considered to be property behaviors once we have them, so you&#39;d write something like:<br></p><p>class Foo {<br>  var parent: Foo?<br>    behavior weak<br>}<br></p><p>to define a property with &quot;weak&quot; behavior. We could potentially allow you to apply behaviors to &#39;case&#39; associated values too:<br></p><p>enum ParentChild {<br>  case Parent(Parent) behavior unowned<br>  case Child(Parent) behavior unowned<br>}<br></p><p>-Joe<br></p><p>&gt; On May 3, 2016, at 8:07 AM, Marc Prud&#39;hommeaux via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; The following code currently has a retain cycle and memory leak:<br>&gt; <br>&gt; enum ParentChild {<br>&gt;     case SonOf(Parent)<br>&gt;     case DaughterOf(Parent)<br>&gt; }<br>&gt; <br>&gt; class Parent {<br>&gt;     lazy var son: Child = Child(parentChild: .SonOf(self))<br>&gt;     lazy var daughter: Child = Child(parentChild: .DaughterOf(self))<br>&gt;     deinit { print(&quot;deinit Parent&quot;) }<br>&gt; }<br>&gt; <br>&gt; class Child {<br>&gt;     var parentChild: ParentChild<br>&gt;     init(parentChild: ParentChild) {<br>&gt;         self.parentChild = parentChild<br>&gt;     }<br>&gt;     deinit { print(&quot;deinit Child&quot;) }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; do {<br>&gt;     let parent = Parent()<br>&gt;     parent.son<br>&gt;     parent.daughter<br>&gt; }<br>&gt; <br>&gt; <br>&gt; Child.parentChild cannot be declared unowned because ParentChild is a value type. I propose adding the ability to declare the reference storage class for an enum&#39;s associated value, like so:<br>&gt; <br>&gt; enum ParentChild {<br>&gt;     case SonOf(unowned Parent)<br>&gt;     case DaughterOf(unowned Parent)<br>&gt; }<br>&gt; <br>&gt; The only current alternative is to have some intermediate reference type that itself holds the reference, akin to the old &quot;Box&quot; type that we used to use to work around enum limitations. E.g., this is our current cumbersome work-around:<br>&gt; <br>&gt; /// An unowned reference to a value, which is useful for maintaining parent-child relations through value types like enums<br>&gt; public struct UnownedRef&lt;T: AnyObject&gt; {<br>&gt;     public unowned let value: T<br>&gt;     public init(_ value: T) { self.value = value }<br>&gt; }<br>&gt; <br>&gt; enum ParentChild {<br>&gt;     case SonOf(UnownedRef&lt;Parent&gt;)<br>&gt;     case DaughterOf(UnownedRef&lt;Parent&gt;)<br>&gt; }<br>&gt; <br>&gt; <br>&gt; class Parent {<br>&gt;     lazy var son: Child = Child(parentChild: .SonOf(UnownedRef(self)))<br>&gt;     lazy var daughter: Child = Child(parentChild: .DaughterOf(UnownedRef(self)))<br>&gt;     deinit { print(&quot;deinit Foo&quot;) }<br>&gt; }<br>&gt; <br>&gt; class Child {<br>&gt;     var parentChild: ParentChild<br>&gt;     init(parentChild: ParentChild) {<br>&gt;         self.parentChild = parentChild<br>&gt;     }<br>&gt; <br>&gt;     deinit { print(&quot;deinit Child&quot;) }<br>&gt; }<br>&gt; <br>&gt; The storage type of an enum would, of course, be limited to reference types, and when the storage class is weak, it would require that the stored type be Optional, just like when declaring a weak variable.<br>&gt; <br>&gt; What do people think?<br>&gt; <br>&gt; 	-Marc<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c14b8de3a00d0b57e1372600c83120cd?s=50"></div><header><strong>[Pitch] Reference storage for enum associated values</strong> from <string>Marc Prud&#39;hommeaux</string> &lt;marc at glimpse.io&gt;<p>May  6, 2016 at 12:00:00pm</p></header><div class="content"><p>Joe-<br></p><p>I hadn&#39;t seen that proposal; it would make sense to harmonize with enum cases. Instead of the trailing &quot;behavior unowned&quot; syntax, perhaps your proposed bracket syntax could be used:<br></p><p>enum ChildGuardianship {<br>  case [unowned] ChildOf(Parent)<br>  case [indirect] GrandChildOf(ChildGuardianship)<br>  case [weak] WardOf(State?)<br>}<br></p><p>Or maybe inline with the :<br></p><p>enum ChildGuardianship {<br>  case ChildOf([unowned] Parent)<br>  case GrandChildOf([indirect] ChildGuardianship)<br>  case WardOf([weak] State?)<br>  case SharedCustodyOf([unowned] parent: Parent, [indirect] guardian: ChildGuardianship, [weak] ward: State?)<br>}<br></p><p>If that is amenable, how would one go about proposing it as an amendment to #0030?<br></p><p>	-Marc<br></p><p><br>&gt; On May 6, 2016, at 11:47 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; Another way to address this might be by allowing property behaviors, a feature proposed in https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md to allow for factoring out property implementations, could also apply to `case` declarations. &quot;Weak&quot; and &quot;unowned&quot; could be considered to be property behaviors once we have them, so you&#39;d write something like:<br>&gt; <br>&gt; class Foo {<br>&gt;  var parent: Foo?<br>&gt;    behavior weak<br>&gt; }<br>&gt; <br>&gt; to define a property with &quot;weak&quot; behavior. We could potentially allow you to apply behaviors to &#39;case&#39; associated values too:<br>&gt; <br>&gt; enum ParentChild {<br>&gt;  case Parent(Parent) behavior unowned<br>&gt;  case Child(Parent) behavior unowned<br>&gt; }<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; On May 3, 2016, at 8:07 AM, Marc Prud&#39;hommeaux via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; The following code currently has a retain cycle and memory leak:<br>&gt;&gt; <br>&gt;&gt; enum ParentChild {<br>&gt;&gt;    case SonOf(Parent)<br>&gt;&gt;    case DaughterOf(Parent)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class Parent {<br>&gt;&gt;    lazy var son: Child = Child(parentChild: .SonOf(self))<br>&gt;&gt;    lazy var daughter: Child = Child(parentChild: .DaughterOf(self))<br>&gt;&gt;    deinit { print(&quot;deinit Parent&quot;) }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class Child {<br>&gt;&gt;    var parentChild: ParentChild<br>&gt;&gt;    init(parentChild: ParentChild) {<br>&gt;&gt;        self.parentChild = parentChild<br>&gt;&gt;    }<br>&gt;&gt;    deinit { print(&quot;deinit Child&quot;) }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; do {<br>&gt;&gt;    let parent = Parent()<br>&gt;&gt;    parent.son<br>&gt;&gt;    parent.daughter<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Child.parentChild cannot be declared unowned because ParentChild is a value type. I propose adding the ability to declare the reference storage class for an enum&#39;s associated value, like so:<br>&gt;&gt; <br>&gt;&gt; enum ParentChild {<br>&gt;&gt;    case SonOf(unowned Parent)<br>&gt;&gt;    case DaughterOf(unowned Parent)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; The only current alternative is to have some intermediate reference type that itself holds the reference, akin to the old &quot;Box&quot; type that we used to use to work around enum limitations. E.g., this is our current cumbersome work-around:<br>&gt;&gt; <br>&gt;&gt; /// An unowned reference to a value, which is useful for maintaining parent-child relations through value types like enums<br>&gt;&gt; public struct UnownedRef&lt;T: AnyObject&gt; {<br>&gt;&gt;    public unowned let value: T<br>&gt;&gt;    public init(_ value: T) { self.value = value }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; enum ParentChild {<br>&gt;&gt;    case SonOf(UnownedRef&lt;Parent&gt;)<br>&gt;&gt;    case DaughterOf(UnownedRef&lt;Parent&gt;)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; class Parent {<br>&gt;&gt;    lazy var son: Child = Child(parentChild: .SonOf(UnownedRef(self)))<br>&gt;&gt;    lazy var daughter: Child = Child(parentChild: .DaughterOf(UnownedRef(self)))<br>&gt;&gt;    deinit { print(&quot;deinit Foo&quot;) }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class Child {<br>&gt;&gt;    var parentChild: ParentChild<br>&gt;&gt;    init(parentChild: ParentChild) {<br>&gt;&gt;        self.parentChild = parentChild<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;    deinit { print(&quot;deinit Child&quot;) }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; The storage type of an enum would, of course, be limited to reference types, and when the storage class is weak, it would require that the stored type be Optional, just like when declaring a weak variable.<br>&gt;&gt; <br>&gt;&gt; What do people think?<br>&gt;&gt; <br>&gt;&gt; 	-Marc<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
