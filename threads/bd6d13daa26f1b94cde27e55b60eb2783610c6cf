<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Are value semantics really appropriate in a diagramming app?</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>August  2, 2016 at 01:00:00pm</p></header><div class="content"><p>on Mon Aug 01 2016, Rick Mann &lt;swift-users-AT-swift.org&gt; wrote:<br></p><p>&gt;&gt; On Aug 1, 2016, at 19:18 , Jack Lawrence &lt;jackl at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Jens: Why? There are significant benefits to value semantics for<br>&gt;&gt; this type of problem, for the reasons laid out in the WWDC<br>&gt;&gt; videos. It would be helpful to know why you disagree in this<br>&gt;&gt; case—maybe there are solutions to the issues you’re thinking of.<br>&gt;&gt; <br>&gt;&gt; Rick: I’d think that value semantics would be the right choice<br>&gt;&gt; here. When you do a mutation, you would copy the state of the entire<br>&gt;&gt; diagram. It should be efficient via COW, but if not you can<br>&gt;&gt; implement you own more fine-grained COW types with<br>&gt;&gt; isUniquelyReferenced(). This would allow you to easily support<br>&gt;&gt; things like undo.<br>&gt;<br>&gt; The more I consider this, the more I think value semantics won&#39;t work<br>&gt; for me. I think, to take advantage of the easy undo feature, my entire<br>&gt; model *must* be implemented with value semantics.<br></p><p>That certainly helps.  You could introduce an explicit copy operation<br>to get around the use of classes, but that can get very messy.<br></p><p>&gt; But my model has implicit reference semantics: multiple instances of a<br>&gt; part can share a PartDefinition; it is intended that if the<br>&gt; PartDefinition changes, all the referencing instances get the<br>&gt; change. <br></p><p>That is definitely a reference.  However, there are lots of ways to<br>represent references such that the entire model still has value<br>semantics.  Reference semantics, in the broadest sense, are everywhere:<br>as soon as you have an array and an integer, you have reference<br>semantics.  The problem with using classes is that they introduce<br>reference semantics *implicitly* and *prolifically*.<br></p><p>So, for example, if you are implementing a model and you want to<br>represent a selection as a separate data structure, then you&#39;ll need to<br>give every selectable element some kind of id, so you can store the ids<br>there. One way to do that is to store all your elements in an array in<br>your model, and use the index into the array as the id.  Then when one<br>element needs to refer to another element, it stores the ID of that<br>element.<br></p><p>[Aside: one of the simplest and most efficient representations of a<br>generalized graph structure is `[[Int]]`, which has value semantics.<br>Each element of the outer array corresponds to a vertex, and each<br>element an inner array represents the target of that vertex&#39;s outgoing<br>edges]<br></p><p>The most obvious thing you don&#39;t get from this kind of arrangement is<br>automatic lifetime management: an element doesn&#39;t disappear just because<br>you&#39;ve stopped referring to it.  Whether that&#39;s appropriate for your<br>application or not is a question for you to answer.  <br></p><p>You can selectively recreate as much of the implicit behavior of classes<br>as you like, e.g. storing reference counts to recreate automatic<br>lifetime management and/or threading a free list through the array to<br>maintain ID stability, but of course at some point it becomes silly.<br></p><p>Where your particular application falls in this spectrum is for you to<br>say.  The fact that there&#39;s a component of reference semantics in your<br>model doesn&#39;t mean you can&#39;t use value types, and the fact that using<br>value types has some awesome benefits doesn&#39;t mean you can&#39;t use<br>classes.  Weigh the tradeoffs and make an informed choice.<br></p><p>&gt; There are additional situations in which reference semantics are at<br>&gt; play, as well: a PartDefinition can have one or more labels, but each<br>&gt; instance can specify the relative location of the label for that<br>&gt; instance. So, there is struct that contains a position and a reference<br>&gt; to the label in the PartDefinition. But if the contents of the label<br>&gt; changes, all the instances need to see that change.<br>&gt;<br>&gt; I don&#39;t think I get to take advantage of value semantics, and it makes<br>&gt; me wonder if any typical, non-trivial model&#39;s object graph really has<br>&gt; no reference semantics.<br></p><p>Some do, but many-to-one relationships are an important concept, and<br>many applications need to represent them somehow.  I&#39;ve personally found<br>that most such relationships are best expressed explicitly, which allows<br>me to preserve value semantics of the whole system. YMMV, of course.<br></p><p>HTH,<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8809800aec2460f291384b794d7e6f8f?s=50"></div><header><strong>Are value semantics really appropriate in a diagramming app?</strong> from <string>Rick Mann</string> &lt;rmann at latencyzero.com&gt;<p>August  2, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Aug 2, 2016, at 13:07 , Dave Abrahams via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Mon Aug 01 2016, Rick Mann &lt;swift-users-AT-swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Aug 1, 2016, at 19:18 , Jack Lawrence &lt;jackl at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Jens: Why? There are significant benefits to value semantics for<br>&gt;&gt;&gt; this type of problem, for the reasons laid out in the WWDC<br>&gt;&gt;&gt; videos. It would be helpful to know why you disagree in this<br>&gt;&gt;&gt; case—maybe there are solutions to the issues you’re thinking of.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Rick: I’d think that value semantics would be the right choice<br>&gt;&gt;&gt; here. When you do a mutation, you would copy the state of the entire<br>&gt;&gt;&gt; diagram. It should be efficient via COW, but if not you can<br>&gt;&gt;&gt; implement you own more fine-grained COW types with<br>&gt;&gt;&gt; isUniquelyReferenced(). This would allow you to easily support<br>&gt;&gt;&gt; things like undo.<br>&gt;&gt; <br>&gt;&gt; The more I consider this, the more I think value semantics won&#39;t work<br>&gt;&gt; for me. I think, to take advantage of the easy undo feature, my entire<br>&gt;&gt; model *must* be implemented with value semantics.<br>&gt; <br>&gt; That certainly helps.  You could introduce an explicit copy operation<br>&gt; to get around the use of classes, but that can get very messy.<br>&gt; <br>&gt;&gt; But my model has implicit reference semantics: multiple instances of a<br>&gt;&gt; part can share a PartDefinition; it is intended that if the<br>&gt;&gt; PartDefinition changes, all the referencing instances get the<br>&gt;&gt; change. <br>&gt; <br>&gt; That is definitely a reference.  However, there are lots of ways to<br>&gt; represent references such that the entire model still has value<br>&gt; semantics.  Reference semantics, in the broadest sense, are everywhere:<br>&gt; as soon as you have an array and an integer, you have reference<br>&gt; semantics.  The problem with using classes is that they introduce<br>&gt; reference semantics *implicitly* and *prolifically*.<br>&gt; <br>&gt; So, for example, if you are implementing a model and you want to<br>&gt; represent a selection as a separate data structure, then you&#39;ll need to<br>&gt; give every selectable element some kind of id, so you can store the ids<br>&gt; there. One way to do that is to store all your elements in an array in<br>&gt; your model, and use the index into the array as the id.  Then when one<br>&gt; element needs to refer to another element, it stores the ID of that<br>&gt; element.<br>&gt; <br>&gt; [Aside: one of the simplest and most efficient representations of a<br>&gt; generalized graph structure is `[[Int]]`, which has value semantics.<br>&gt; Each element of the outer array corresponds to a vertex, and each<br>&gt; element an inner array represents the target of that vertex&#39;s outgoing<br>&gt; edges]<br>&gt; <br>&gt; The most obvious thing you don&#39;t get from this kind of arrangement is<br>&gt; automatic lifetime management: an element doesn&#39;t disappear just because<br>&gt; you&#39;ve stopped referring to it.  Whether that&#39;s appropriate for your<br>&gt; application or not is a question for you to answer.  <br>&gt; <br>&gt; You can selectively recreate as much of the implicit behavior of classes<br>&gt; as you like, e.g. storing reference counts to recreate automatic<br>&gt; lifetime management and/or threading a free list through the array to<br>&gt; maintain ID stability, but of course at some point it becomes silly.<br>&gt; <br>&gt; Where your particular application falls in this spectrum is for you to<br>&gt; say.  The fact that there&#39;s a component of reference semantics in your<br>&gt; model doesn&#39;t mean you can&#39;t use value types, and the fact that using<br>&gt; value types has some awesome benefits doesn&#39;t mean you can&#39;t use<br>&gt; classes.  Weigh the tradeoffs and make an informed choice.<br>&gt; <br>&gt;&gt; There are additional situations in which reference semantics are at<br>&gt;&gt; play, as well: a PartDefinition can have one or more labels, but each<br>&gt;&gt; instance can specify the relative location of the label for that<br>&gt;&gt; instance. So, there is struct that contains a position and a reference<br>&gt;&gt; to the label in the PartDefinition. But if the contents of the label<br>&gt;&gt; changes, all the instances need to see that change.<br>&gt;&gt; <br>&gt;&gt; I don&#39;t think I get to take advantage of value semantics, and it makes<br>&gt;&gt; me wonder if any typical, non-trivial model&#39;s object graph really has<br>&gt;&gt; no reference semantics.<br>&gt; <br>&gt; Some do, but many-to-one relationships are an important concept, and<br>&gt; many applications need to represent them somehow.  I&#39;ve personally found<br>&gt; that most such relationships are best expressed explicitly, which allows<br>&gt; me to preserve value semantics of the whole system. YMMV, of course.<br></p><p>Hmm. Seems there&#39;s a need in the language for expressing exactly this kind of thing: explicit reference semantics. I sure don&#39;t want to manage that all on my own.<br></p><p>-- <br>Rick Mann<br>rmann at latencyzero.com<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Are value semantics really appropriate in a diagramming app?</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>August  2, 2016 at 02:00:00pm</p></header><div class="content"><p>on Tue Aug 02 2016, Rick Mann &lt;rmann-AT-latencyzero.com&gt; wrote:<br></p><p>&gt;&gt; On Aug 2, 2016, at 13:07 , Dave Abrahams via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Mon Aug 01 2016, Rick Mann &lt;swift-users-AT-swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;<br>&gt;&gt;&gt;&gt; On Aug 1, 2016, at 19:18 , Jack Lawrence &lt;jackl at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Jens: Why? There are significant benefits to value semantics for<br>&gt;&gt;&gt;&gt; this type of problem, for the reasons laid out in the WWDC<br>&gt;&gt;&gt;&gt; videos. It would be helpful to know why you disagree in this<br>&gt;&gt;&gt;&gt; case—maybe there are solutions to the issues you’re thinking of.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Rick: I’d think that value semantics would be the right choice<br>&gt;&gt;&gt;&gt; here. When you do a mutation, you would copy the state of the entire<br>&gt;&gt;&gt;&gt; diagram. It should be efficient via COW, but if not you can<br>&gt;&gt;&gt;&gt; implement you own more fine-grained COW types with<br>&gt;&gt;&gt;&gt; isUniquelyReferenced(). This would allow you to easily support<br>&gt;&gt;&gt;&gt; things like undo.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The more I consider this, the more I think value semantics won&#39;t work<br>&gt;&gt;&gt; for me. I think, to take advantage of the easy undo feature, my entire<br>&gt;&gt;&gt; model *must* be implemented with value semantics.<br>&gt;&gt; <br>&gt;&gt; That certainly helps.  You could introduce an explicit copy operation<br>&gt;&gt; to get around the use of classes, but that can get very messy.<br>&gt;&gt; <br>&gt;&gt;&gt; But my model has implicit reference semantics: multiple instances of a<br>&gt;&gt;&gt; part can share a PartDefinition; it is intended that if the<br>&gt;&gt;&gt; PartDefinition changes, all the referencing instances get the<br>&gt;&gt;&gt; change. <br>&gt;&gt; <br>&gt;&gt; That is definitely a reference.  However, there are lots of ways to<br>&gt;&gt; represent references such that the entire model still has value<br>&gt;&gt; semantics.  Reference semantics, in the broadest sense, are everywhere:<br>&gt;&gt; as soon as you have an array and an integer, you have reference<br>&gt;&gt; semantics.  The problem with using classes is that they introduce<br>&gt;&gt; reference semantics *implicitly* and *prolifically*.<br>&gt;&gt; <br>&gt;&gt; So, for example, if you are implementing a model and you want to<br>&gt;&gt; represent a selection as a separate data structure, then you&#39;ll need to<br>&gt;&gt; give every selectable element some kind of id, so you can store the ids<br>&gt;&gt; there. One way to do that is to store all your elements in an array in<br>&gt;&gt; your model, and use the index into the array as the id.  Then when one<br>&gt;&gt; element needs to refer to another element, it stores the ID of that<br>&gt;&gt; element.<br>&gt;&gt; <br>&gt;&gt; [Aside: one of the simplest and most efficient representations of a<br>&gt;&gt; generalized graph structure is `[[Int]]`, which has value semantics.<br>&gt;&gt; Each element of the outer array corresponds to a vertex, and each<br>&gt;&gt; element an inner array represents the target of that vertex&#39;s outgoing<br>&gt;&gt; edges]<br>&gt;&gt; <br>&gt;&gt; The most obvious thing you don&#39;t get from this kind of arrangement is<br>&gt;&gt; automatic lifetime management: an element doesn&#39;t disappear just because<br>&gt;&gt; you&#39;ve stopped referring to it.  Whether that&#39;s appropriate for your<br>&gt;&gt; application or not is a question for you to answer.  <br>&gt;&gt; <br>&gt;&gt; You can selectively recreate as much of the implicit behavior of classes<br>&gt;&gt; as you like, e.g. storing reference counts to recreate automatic<br>&gt;&gt; lifetime management and/or threading a free list through the array to<br>&gt;&gt; maintain ID stability, but of course at some point it becomes silly.<br>&gt;&gt; <br>&gt;&gt; Where your particular application falls in this spectrum is for you to<br>&gt;&gt; say.  The fact that there&#39;s a component of reference semantics in your<br>&gt;&gt; model doesn&#39;t mean you can&#39;t use value types, and the fact that using<br>&gt;&gt; value types has some awesome benefits doesn&#39;t mean you can&#39;t use<br>&gt;&gt; classes.  Weigh the tradeoffs and make an informed choice.<br>&gt;&gt; <br>&gt;&gt;&gt; There are additional situations in which reference semantics are at<br>&gt;&gt;&gt; play, as well: a PartDefinition can have one or more labels, but each<br>&gt;&gt;&gt; instance can specify the relative location of the label for that<br>&gt;&gt;&gt; instance. So, there is struct that contains a position and a reference<br>&gt;&gt;&gt; to the label in the PartDefinition. But if the contents of the label<br>&gt;&gt;&gt; changes, all the instances need to see that change.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t think I get to take advantage of value semantics, and it makes<br>&gt;&gt;&gt; me wonder if any typical, non-trivial model&#39;s object graph really has<br>&gt;&gt;&gt; no reference semantics.<br>&gt;&gt; <br>&gt;&gt; Some do, but many-to-one relationships are an important concept, and<br>&gt;&gt; many applications need to represent them somehow.  I&#39;ve personally found<br>&gt;&gt; that most such relationships are best expressed explicitly, which allows<br>&gt;&gt; me to preserve value semantics of the whole system. YMMV, of course.<br>&gt;<br>&gt; Hmm. Seems there&#39;s a need in the language for expressing exactly this<br>&gt; kind of thing: explicit reference semantics. <br></p><p>That&#39;s called “class.” ;-) But more seriously, if you have ideas, I&#39;m<br>all ears (on the -evolution list, of course).<br></p><p>&gt; I sure don&#39;t want to manage that all on my own.<br></p><p>It&#39;s not that big a deal; you manage it all on your own every time you<br>use an array, dictionary, or set, with indices or keys playing the role<br>of references.<br></p><p>Cheers,<br></p><p>-- <br>-Dave<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
