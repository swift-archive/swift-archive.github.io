<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>What about garbage collection?</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>February  8, 2016 at 02:00:00pm</p></header><div class="content"><p>Has there been a garbage collection thread so far? I understand that reference counting vs. garbage collection can be a heated debate, but it might be relevant to have it.<br></p><p>It seems to me that the two principal upsides of reference counting are that destruction is (essentially) deterministic and performance is more easily predicted. However, it comes with many downsides:<br></p><p>object references are expensive to update<br>object references cannot be atomically updated<br>heap fragmentation<br>the closure capture syntax uses up an unreasonable amount of mindshare just because of [weak self]<br></p><p>Since Swift doesn&#39;t expose memory management operations outside of `autoreleasepool`, it seems to me that you could just drop in a garbage collector instead of reference counting and it would work (for most purposes).<br></p><p>Has a GC been considered at all?<br></p><p>Félix<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160208/635c70bc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>What about garbage collection?</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February  8, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Feb 8, 2016, at 11:56 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Has there been a garbage collection thread so far? I understand that reference counting vs. garbage collection can be a heated debate, but it might be relevant to have it.<br>&gt; <br>&gt; It seems to me that the two principal upsides of reference counting are that destruction is (essentially) deterministic and performance is more easily predicted. However, it comes with many downsides:<br>&gt; <br>&gt; object references are expensive to update<br>&gt; object references cannot be atomically updated<br>&gt; heap fragmentation<br>&gt; the closure capture syntax uses up an unreasonable amount of mindshare just because of [weak self]<br>&gt; <br>&gt; Since Swift doesn&#39;t expose memory management operations outside of `autoreleasepool`, it seems to me that you could just drop in a garbage collector instead of reference counting and it would work (for most purposes).<br></p><p>While true in theory, code that relies on destructors to clean up unmanaged resources does not port cleanly to GC as-is in practice. GC of course has its own drawbacks. Heap scanning is expensive, thrashing cache and burning battery. GCs also require higher memory ceiling proportional to the amount of heap actively being used, and GCs suitable for interactive use tend to increase responsiveness at the cost of higher memory use, which has its own second-order energy costs—devices need more RAM, and spend more time swapping or killing, and thus need bigger batteries to refresh all that RAM. ARC interoperates better with unmanaged resources, both non-memory resources like sockets and files and also C-level memory resources. The ARC optimizer and Swift&#39;s calling convention also optimize toward reclaiming resources closer to their last use, keeping resource usage low.<br></p><p>-Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160208/74b9700d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>What about garbage collection?</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>February  8, 2016 at 08:00:00pm</p></header><div class="content"><p>Devices being able to house a compact amount of RAM is a device vendor concern not a Swift one although the former kind of owns the latter, but that is being a bit cheeky I will admit that ;). <br></p><p>Still, iPhone 6 Plus only having 1 GB of RAM... Grrrr... :P. Seriously, multitasking suffers greatly on that device as well as having multiple opened tabs on Safari...<br></p><p>Sent from my iPhone<br></p><p>&gt; On 8 Feb 2016, at 20:11, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 8, 2016, at 11:56 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Has there been a garbage collection thread so far? I understand that reference counting vs. garbage collection can be a heated debate, but it might be relevant to have it.<br>&gt;&gt; <br>&gt;&gt; It seems to me that the two principal upsides of reference counting are that destruction is (essentially) deterministic and performance is more easily predicted. However, it comes with many downsides:<br>&gt;&gt; <br>&gt;&gt; object references are expensive to update<br>&gt;&gt; object references cannot be atomically updated<br>&gt;&gt; heap fragmentation<br>&gt;&gt; the closure capture syntax uses up an unreasonable amount of mindshare just because of [weak self]<br>&gt;&gt; <br>&gt;&gt; Since Swift doesn&#39;t expose memory management operations outside of `autoreleasepool`, it seems to me that you could just drop in a garbage collector instead of reference counting and it would work (for most purposes).<br>&gt; <br>&gt; While true in theory, code that relies on destructors to clean up unmanaged resources does not port cleanly to GC as-is in practice. GC of course has its own drawbacks. Heap scanning is expensive, thrashing cache and burning battery. GCs also require higher memory ceiling proportional to the amount of heap actively being used, and GCs suitable for interactive use tend to increase responsiveness at the cost of higher memory use, which has its own second-order energy costs—devices need more RAM, and spend more time swapping or killing, and thus need bigger batteries to refresh all that RAM. ARC interoperates better with unmanaged resources, both non-memory resources like sockets and files and also C-level memory resources. The ARC optimizer and Swift&#39;s calling convention also optimize toward reclaiming resources closer to their last use, keeping resource usage low.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160208/2bdcbbb7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d0659d0725d0f35fa2b7d2cd23631502?s=50"></div><header><strong>What about garbage collection?</strong> from <string>Vanderlei Martinelli</string> &lt;vmartinelli at alecrim.com&gt;<p>February  8, 2016 at 06:00:00pm</p></header><div class="content"><p>-1 for any kind of GC in Swift and any other language/platform.<br></p><p>On Mon, Feb 8, 2016 at 6:26 PM, Goffredo Marocchi via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Devices being able to house a compact amount of RAM is a device vendor<br>&gt; concern not a Swift one although the former kind of owns the latter, but<br>&gt; that is being a bit cheeky I will admit that ;).<br>&gt;<br>&gt; Still, iPhone 6 Plus only having 1 GB of RAM... Grrrr... :P. Seriously,<br>&gt; multitasking suffers greatly on that device as well as having multiple<br>&gt; opened tabs on Safari...<br>&gt;<br>&gt; Sent from my iPhone<br>&gt;<br>&gt; On 8 Feb 2016, at 20:11, Joe Groff via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Feb 8, 2016, at 11:56 AM, Félix Cloutier via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Has there been a garbage collection thread so far? I understand that<br>&gt; reference counting vs. garbage collection can be a heated debate, but it<br>&gt; might be relevant to have it.<br>&gt;<br>&gt; It seems to me that the two principal upsides of reference counting are<br>&gt; that destruction is (essentially) deterministic and performance is more<br>&gt; easily predicted. However, it comes with many downsides:<br>&gt;<br>&gt;<br>&gt;    - object references are expensive to update<br>&gt;    - object references cannot be atomically updated<br>&gt;    - heap fragmentation<br>&gt;    - the closure capture syntax uses up an unreasonable amount of<br>&gt;    mindshare just because of [weak self]<br>&gt;<br>&gt;<br>&gt; Since Swift doesn&#39;t expose memory management operations outside of<br>&gt; `autoreleasepool`, it seems to me that you could just drop in a garbage<br>&gt; collector instead of reference counting and it would work (for most<br>&gt; purposes).<br>&gt;<br>&gt;<br>&gt; While true in theory, code that relies on destructors to clean up<br>&gt; unmanaged resources does not port cleanly to GC as-is in practice. GC of<br>&gt; course has its own drawbacks. Heap scanning is expensive, thrashing cache<br>&gt; and burning battery. GCs also require higher memory ceiling proportional to<br>&gt; the amount of heap actively being used, and GCs suitable for interactive<br>&gt; use tend to increase responsiveness at the cost of higher memory use, which<br>&gt; has its own second-order energy costs—devices need more RAM, and spend more<br>&gt; time swapping or killing, and thus need bigger batteries to refresh all<br>&gt; that RAM. ARC interoperates better with unmanaged resources, both<br>&gt; non-memory resources like sockets and files and also C-level memory<br>&gt; resources. The ARC optimizer and Swift&#39;s calling convention also optimize<br>&gt; toward reclaiming resources closer to their last use, keeping resource<br>&gt; usage low.<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160208/61376517/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>What about garbage collection?</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>February  8, 2016 at 08:00:00pm</p></header><div class="content"><p>Then the support for debugging and sorting reference cycles has got to improve in ease and effectiveness a lot. If you are not making a game, GC pauses with modern garbage collectors do not really impede developers a lot, do they?<br></p><p>Sent from my iPhone<br></p><p>&gt; On 8 Feb 2016, at 20:28, Vanderlei Martinelli &lt;vmartinelli at alecrim.com&gt; wrote:<br>&gt; <br>&gt; -1 for any kind of GC in Swift and any other language/platform.<br>&gt; <br>&gt;&gt; On Mon, Feb 8, 2016 at 6:26 PM, Goffredo Marocchi via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Devices being able to house a compact amount of RAM is a device vendor concern not a Swift one although the former kind of owns the latter, but that is being a bit cheeky I will admit that ;). <br>&gt;&gt; <br>&gt;&gt; Still, iPhone 6 Plus only having 1 GB of RAM... Grrrr... :P. Seriously, multitasking suffers greatly on that device as well as having multiple opened tabs on Safari...<br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt;&gt; On 8 Feb 2016, at 20:11, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 8, 2016, at 11:56 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Has there been a garbage collection thread so far? I understand that reference counting vs. garbage collection can be a heated debate, but it might be relevant to have it.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It seems to me that the two principal upsides of reference counting are that destruction is (essentially) deterministic and performance is more easily predicted. However, it comes with many downsides:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; object references are expensive to update<br>&gt;&gt;&gt;&gt; object references cannot be atomically updated<br>&gt;&gt;&gt;&gt; heap fragmentation<br>&gt;&gt;&gt;&gt; the closure capture syntax uses up an unreasonable amount of mindshare just because of [weak self]<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Since Swift doesn&#39;t expose memory management operations outside of `autoreleasepool`, it seems to me that you could just drop in a garbage collector instead of reference counting and it would work (for most purposes).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; While true in theory, code that relies on destructors to clean up unmanaged resources does not port cleanly to GC as-is in practice. GC of course has its own drawbacks. Heap scanning is expensive, thrashing cache and burning battery. GCs also require higher memory ceiling proportional to the amount of heap actively being used, and GCs suitable for interactive use tend to increase responsiveness at the cost of higher memory use, which has its own second-order energy costs—devices need more RAM, and spend more time swapping or killing, and thus need bigger batteries to refresh all that RAM. ARC interoperates better with unmanaged resources, both non-memory resources like sockets and files and also C-level memory resources. The ARC optimizer and Swift&#39;s calling convention also optimize toward reclaiming resources closer to their last use, keeping resource usage low.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160208/a98b25d4/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7321934b88ca8da079d7b89926501a9c?s=50"></div><header><strong>What about garbage collection?</strong> from <string>David Turnbull</string> &lt;dturnbull at gmail.com&gt;<p>February  8, 2016 at 01:00:00pm</p></header><div class="content"><p>On Mon, Feb 8, 2016 at 12:28 PM, Vanderlei Martinelli via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; -1 for any kind of GC in Swift and any other language/platform.<br>&gt;<br></p><p>+1 for removing mark-sweep GC from other languages. Oh, wait, was that not<br>the topic?<br></p><p>-david  https://github.com/AE9RB/SwiftGL<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160208/f3ebe28c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>What about garbage collection?</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>February  9, 2016 at 04:00:00am</p></header><div class="content"><p>+1. GC is bad.<br></p><p>On Mon, Feb 8, 2016 at 4:07 PM David Turnbull via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Mon, Feb 8, 2016 at 12:28 PM, Vanderlei Martinelli via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; -1 for any kind of GC in Swift and any other language/platform.<br>&gt;&gt;<br>&gt;<br>&gt; +1 for removing mark-sweep GC from other languages. Oh, wait, was that not<br>&gt; the topic?<br>&gt;<br>&gt; -david  https://github.com/AE9RB/SwiftGL<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160209/e7853cac/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>What about garbage collection?</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February  8, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Feb 8, 2016, at 12:26 PM, Goffredo Marocchi &lt;panajev at gmail.com&gt; wrote:<br>&gt; <br>&gt; Devices being able to house a compact amount of RAM is a device vendor concern not a Swift one although the former kind of owns the latter, but that is being a bit cheeky I will admit that ;). <br>&gt; <br>&gt; Still, iPhone 6 Plus only having 1 GB of RAM... Grrrr... :P. Seriously, multitasking suffers greatly on that device as well as having multiple opened tabs on Safari...<br></p><p>Please keep discussion of iPhone design on the iphone-evolution list. (j/k) No matter how much RAM your device has, though, it&#39;s still advantageous at the macro level to optimize for memory usage—you get better cache utilization, can run more processes, swap less, etc., and your hot paths that deserve to be greedy with memory will be more likely to have the space they need to be fast.<br></p><p>-Joe<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc045f9bdc3bd1885767f2a2ba8af458?s=50"></div><header><strong>What about garbage collection?</strong> from <string>Jonathan Tang</string> &lt;jonathan.d.tang at gmail.com&gt;<p>February  8, 2016 at 12:00:00pm</p></header><div class="content"><p>On Mon, Feb 8, 2016 at 12:11 PM, Joe Groff via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Feb 8, 2016, at 11:56 AM, Félix Cloutier via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Has there been a garbage collection thread so far? I understand that<br>&gt; reference counting vs. garbage collection can be a heated debate, but it<br>&gt; might be relevant to have it.<br>&gt;<br>&gt; It seems to me that the two principal upsides of reference counting are<br>&gt; that destruction is (essentially) deterministic and performance is more<br>&gt; easily predicted. However, it comes with many downsides:<br>&gt;<br>&gt;<br>&gt;    - object references are expensive to update<br>&gt;    - object references cannot be atomically updated<br>&gt;    - heap fragmentation<br>&gt;    - the closure capture syntax uses up an unreasonable amount of<br>&gt;    mindshare just because of [weak self]<br>&gt;<br>&gt;<br>&gt; Since Swift doesn&#39;t expose memory management operations outside of<br>&gt; `autoreleasepool`, it seems to me that you could just drop in a garbage<br>&gt; collector instead of reference counting and it would work (for most<br>&gt; purposes).<br>&gt;<br>&gt;<br>&gt; While true in theory, code that relies on destructors to clean up<br>&gt; unmanaged resources does not port cleanly to GC as-is in practice. GC of<br>&gt; course has its own drawbacks. Heap scanning is expensive, thrashing cache<br>&gt; and burning battery. GCs also require higher memory ceiling proportional to<br>&gt; the amount of heap actively being used, and GCs suitable for interactive<br>&gt; use tend to increase responsiveness at the cost of higher memory use, which<br>&gt; has its own second-order energy costs—devices need more RAM, and spend more<br>&gt; time swapping or killing, and thus need bigger batteries to refresh all<br>&gt; that RAM. ARC interoperates better with unmanaged resources, both<br>&gt; non-memory resources like sockets and files and also C-level memory<br>&gt; resources. The ARC optimizer and Swift&#39;s calling convention also optimize<br>&gt; toward reclaiming resources closer to their last use, keeping resource<br>&gt; usage low.<br>&gt;<br>&gt;<br>&gt;<br>I would imagine that the biggest consideration is compatibility with<br>existing class libraries.  It&#39;s notoriously difficult to integrate<br>libraries with different memory management systems together, whether it be<br>GC + refcounting (Erlang binaries, Java NIO), GC + malloc (JNI, V8<br>embedding), or refcounting + malloc (Python, ARC/C libraries).  The<br>ownership conventions have to become part of every function &amp; data type<br>that&#39;s exposed across the boundary, and oftentimes you need to copy the<br>whole memory block from one heap to another.  Refcounting seems to<br>integrate with manual memory management a bit more easily than GC does, and<br>of course many existing class libraries already use ARC.<br></p><p>Also, anyone interested in debating GC vs. refcounting should read this<br>paper, which argues that they are in fact duals and most production systems<br>(generational collectors, train algorithm, cycle detection in refcounts)<br>are hybrids of the two:<br></p><p>http://researcher.watson.ibm.com/researcher/files/us-bacon/Bacon04Unified.pdf<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160208/e3c0846b/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>What about garbage collection?</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>February  8, 2016 at 03:00:00pm</p></header><div class="content"><p>I should check because it&#39;s been a while, but in Objective-C loops that quickly modified references, I&#39;ve measured objc_retain make up to 15% of the loop&#39;s cost. My understanding is that most of that cost comes from tracking references in a global hash map, which I can&#39;t imagine being particularly kind to memory use or cache performance either.<br></p><p>&gt; Le 8 févr. 2016 à 15:11:52, Joe Groff &lt;jgroff at apple.com&gt; a écrit :<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Feb 8, 2016, at 11:56 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Has there been a garbage collection thread so far? I understand that reference counting vs. garbage collection can be a heated debate, but it might be relevant to have it.<br>&gt;&gt; <br>&gt;&gt; It seems to me that the two principal upsides of reference counting are that destruction is (essentially) deterministic and performance is more easily predicted. However, it comes with many downsides:<br>&gt;&gt; <br>&gt;&gt; object references are expensive to update<br>&gt;&gt; object references cannot be atomically updated<br>&gt;&gt; heap fragmentation<br>&gt;&gt; the closure capture syntax uses up an unreasonable amount of mindshare just because of [weak self]<br>&gt;&gt; <br>&gt;&gt; Since Swift doesn&#39;t expose memory management operations outside of `autoreleasepool`, it seems to me that you could just drop in a garbage collector instead of reference counting and it would work (for most purposes).<br>&gt; <br>&gt; While true in theory, code that relies on destructors to clean up unmanaged resources does not port cleanly to GC as-is in practice. GC of course has its own drawbacks. Heap scanning is expensive, thrashing cache and burning battery. GCs also require higher memory ceiling proportional to the amount of heap actively being used, and GCs suitable for interactive use tend to increase responsiveness at the cost of higher memory use, which has its own second-order energy costs—devices need more RAM, and spend more time swapping or killing, and thus need bigger batteries to refresh all that RAM. ARC interoperates better with unmanaged resources, both non-memory resources like sockets and files and also C-level memory resources. The ARC optimizer and Swift&#39;s calling convention also optimize toward reclaiming resources closer to their last use, keeping resource usage low.<br>&gt; <br>&gt; -Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160208/8c80456e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>What about garbage collection?</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February  8, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Feb 8, 2016, at 12:39 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt; <br>&gt; I should check because it&#39;s been a while, but in Objective-C loops that quickly modified references, I&#39;ve measured objc_retain make up to 15% of the loop&#39;s cost. My understanding is that most of that cost comes from tracking references in a global hash map, which I can&#39;t imagine being particularly kind to memory use or cache performance either.<br></p><p>That&#39;s less of a problem in modern Objective-C and Swift. On ARM64 and 64-bit Mac targeting &gt;=10.11, the refcount for ObjC objects is encoded in the &#39;isa&#39; word. Swift objects always store the refcount inline in the object as well. (In the worst case, consulting a hash map is definitely not ideal, but is going to be less thrashy than scanning the entire heap.)<br></p><p>-Joe<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b660eecceda60138f137d353b8289925?s=50"></div><header><strong>What about garbage collection?</strong> from <string>Janosch Hildebrand</string> &lt;jnosh at jnosh.com&gt;<p>February  9, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On 08 Feb 2016, at 21:39, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I should check because it&#39;s been a while, but in Objective-C loops that quickly modified references, I&#39;ve measured objc_retain make up to 15% of the loop&#39;s cost.<br></p><p>In my experience it is definitely possible to run into such situations with Swift, however while a GC might solve that particular issue you&#39;ll just get a different crop of issues from a GC.<br></p><p>Also, the compiler has already made huge strides in this area in my experience, doubly so if you use whole module optimization. I don&#39;t think this is a big issue for most people and applications.<br></p><p>And ARC has the advantage that this can be identified (by profiling) and worked around pretty well using tools such as:<br></p><p>* inout<br>* unsafe(unowned)<br>* UnsafePointer<br>* Unmanaged/UnsafeReference<br></p><p>depending on the circumstances. It&#39;s not trivial and there might be a bit of a learning curve but ultimately it&#39;s very predictable and abstractable. Working around GC issues seems a lot trickier to me.<br></p><p>I also think that for example Rusts &#39;borrowed references&#39; would be a big help in this area – and those have been discussed on this list previously with the Swift team mentioning that they would be interested to explore this direction.<br></p><p>- Janosch<br></p><p>&gt; My understanding is that most of that cost comes from tracking references in a global hash map, which I can&#39;t imagine being particularly kind to memory use or cache performance either.<br>&gt; <br>&gt;&gt; Le 8 févr. 2016 à 15:11:52, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Feb 8, 2016, at 11:56 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Has there been a garbage collection thread so far? I understand that reference counting vs. garbage collection can be a heated debate, but it might be relevant to have it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It seems to me that the two principal upsides of reference counting are that destruction is (essentially) deterministic and performance is more easily predicted. However, it comes with many downsides:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; object references are expensive to update<br>&gt;&gt;&gt; object references cannot be atomically updated<br>&gt;&gt;&gt; heap fragmentation<br>&gt;&gt;&gt; the closure capture syntax uses up an unreasonable amount of mindshare just because of [weak self]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Since Swift doesn&#39;t expose memory management operations outside of `autoreleasepool`, it seems to me that you could just drop in a garbage collector instead of reference counting and it would work (for most purposes).<br>&gt;&gt; <br>&gt;&gt; While true in theory, code that relies on destructors to clean up unmanaged resources does not port cleanly to GC as-is in practice. GC of course has its own drawbacks. Heap scanning is expensive, thrashing cache and burning battery. GCs also require higher memory ceiling proportional to the amount of heap actively being used, and GCs suitable for interactive use tend to increase responsiveness at the cost of higher memory use, which has its own second-order energy costs—devices need more RAM, and spend more time swapping or killing, and thus need bigger batteries to refresh all that RAM. ARC interoperates better with unmanaged resources, both non-memory resources like sockets and files and also C-level memory resources. The ARC optimizer and Swift&#39;s calling convention also optimize toward reclaiming resources closer to their last use, keeping resource usage low.<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160209/540a0f44/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>What about garbage collection?</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>February  8, 2016 at 12:00:00pm</p></header><div class="content"><p>(Sorry, Felix; I screwed up my original email and didn&#39;t send it to the<br>list.)<br></p><p>Having the option of a GC would be interesting, but one consideration among<br>many: how would it work with the COW value type collections? It seems those<br>would rule out a tracing garbage collector in practice, and the only &#39;real&#39;<br>option would be RC + a cycle detector?<br></p><p>On Mon, Feb 8, 2016 at 11:56 AM, Félix Cloutier &lt;swift-evolution at swift.org&gt;<br>wrote:<br></p><p>&gt; Has there been a garbage collection thread so far? I understand that<br>&gt; reference counting vs. garbage collection can be a heated debate, but it<br>&gt; might be relevant to have it.<br>&gt;<br>&gt; It seems to me that the two principal upsides of reference counting are<br>&gt; that destruction is (essentially) deterministic and performance is more<br>&gt; easily predicted. However, it comes with many downsides:<br>&gt;<br>&gt;<br>&gt;    - object references are expensive to update<br>&gt;    - object references cannot be atomically updated<br>&gt;    - heap fragmentation<br>&gt;    - the closure capture syntax uses up an unreasonable amount of<br>&gt;    mindshare just because of [weak self]<br>&gt;<br>&gt;<br>&gt; Since Swift doesn&#39;t expose memory management operations outside of<br>&gt; `autoreleasepool`, it seems to me that you could just drop in a garbage<br>&gt; collector instead of reference counting and it would work (for most<br>&gt; purposes).<br>&gt;<br>&gt; Has a GC been considered at all?<br>&gt;<br>&gt; Félix<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160208/4f34533d/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>What about garbage collection?</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>February  8, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Feb 8, 2016, at 1:56 PM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Has there been a garbage collection thread so far? I understand that reference counting vs. garbage collection can be a heated debate, but it might be relevant to have it.<br>&gt; <br>&gt; It seems to me that the two principal upsides of reference counting are that destruction is (essentially) deterministic and performance is more easily predicted. However, it comes with many downsides:<br>&gt; <br>&gt; object references are expensive to update<br>&gt; object references cannot be atomically updated<br>&gt; heap fragmentation<br>&gt; the closure capture syntax uses up an unreasonable amount of mindshare just because of [weak self]<br>&gt; <br>&gt; Since Swift doesn&#39;t expose memory management operations outside of `autoreleasepool`, it seems to me that you could just drop in a garbage collector instead of reference counting and it would work (for most purposes).<br>&gt; <br>&gt; Has a GC been considered at all?<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>Strong -1. The deterministic nature of the refcounting system is one of Swift’s best features.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160208/9ec443ee/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>What about garbage collection?</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>February  8, 2016 at 01:00:00pm</p></header><div class="content"><p>On Feb 8, 2016, at 11:56 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Has there been a garbage collection thread so far? I understand that reference counting vs. garbage collection can be a heated debate, but it might be relevant to have it.<br></p><p>Technically speaking, reference counting is a form of garbage collection, but I get what you mean.  Since there are multiple forms of GC, I&#39;ll assume that you mean a generational mark and sweep algorithm like you’d see in a Java implementation.<br></p><p>&gt; It seems to me that the two principal upsides of reference counting are that destruction is (essentially) deterministic and performance is more easily predicted.<br></p><p>Yes, deterministic destruction is a major feature.  Not having to explain what finalizers are (and why they shouldn’t generally be used) is a pretty huge.  Keep in mind that Swift interops with C, so deinit is unavoidable for certain types.<br></p><p>More pointedly, not relying on GC enables Swift to be used in domains that don’t want it - think boot loaders, kernels, real time systems like audio processing, etc.<br></p><p>We have discussed in the passed using hybrid approaches like introducing a cycle collector, which runs less frequently than a GC would.  The problem with this is that if you introduce a cycle collector, code will start depending on it. In time you end up with some libraries/packages that works without GC, and others that leak without it (the D community has relevant experience here).  As such, we have come to think that adding a cycle collector would be bad for the Swift community in the large.<br></p><p>&gt; However, it comes with many downsides:<br>&gt; <br>&gt; object references are expensive to update<br></p><p>Most garbage collectors have write barriers, which execute extra code when references are updated.  Most garbage collectors also have safe points, which means that extra instructions get inserted into loops.<br></p><p>&gt; object references cannot be atomically updated<br></p><p>This is true, but Swift currently has no memory model and no concurrency model, so it isn’t clear that this is actually important (e.g. if you have no shared mutable state).<br></p><p>&gt; heap fragmentation<br></p><p>This is at best a tradeoff depending on what problem you’re trying to solve (e.g. better cache locality or smaller max RSS of the process).  One thing that I don’t think is debatable is that the heap compaction behavior of a GC (which is what provides the heap fragmentation win) is incredibly hostile for cache (because it cycles the entire memory space of the process) and performance predictability.<br></p><p>Given that GC’s use a lot more memory than ARC systems do, it isn’t clear what you mean by GC’s winning on heap fragmentation.<br></p><p>&gt; the closure capture syntax uses up an unreasonable amount of mindshare just because of [weak self]<br></p><p>I think that this specific point is solvable in others ways, but I’ll interpret this bullet as saying that you don’t want to worry about weak/unowned pointers.  I completely agree that we strive to provide a simple programming model, and I can see how &quot;not having to think about memory management&quot; seems appealing.<br></p><p>On the other hand, there are major advantages to the Swift model.  Unlike MRR, Swift doesn’t require you to micromanage memory: you think about it at the object graph level when you’re building out your types.  Compared to MRR, ARC has moved memory management from being imperative to being declarative.  Swift also puts an emphasis on value types, so certain problems that you’d see in languages like Java are reduced.<br></p><p>That said, it is clear that it takes time and thought to use weak/unowned pointers correctly, so the question really becomes: does reasoning about your memory at the object graph level and expressing things in a declarative way contribute positively to your code?  <br></p><p>My opinion is yes: while I think it is silly to micromanage memory, I do think thinking about it some is useful. I think that expressing that intention directly in the code adds value in terms of maintenance of the code over time and communication to other people who work on it.<br></p><p>&gt; Since Swift doesn&#39;t expose memory management operations outside of `autoreleasepool`, it seems to me that you could just drop in a garbage collector instead of reference counting and it would work (for most purposes).<br>&gt; <br>&gt; Has a GC been considered at all?<br></p><p>GC also has several *huge* disadvantages that are usually glossed over: while it is true that modern GC&#39;s can provide high performance, they can only do that when they are granted *much* more memory than the process is actually using.  Generally, unless you give the GC 3-4x more memory than is needed, you’ll get thrashing and incredibly poor performance.  Additionally, since the sweep pass touches almost all RAM in the process, they tend to be very power inefficient (leading to reduced battery life).<br></p><p>I’m personally not interested in requiring a model that requires us to throw away a ton of perfectly good RAM to get an “simpler&quot; programming model - particularly on that adds so many tradeoffs.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160208/9d99990e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>What about garbage collection?</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>February  8, 2016 at 02:00:00pm</p></header><div class="content"><p>TL;DR - I agree generational garbage collection is not a great idea<br></p><p>&gt; On Feb 8, 2016, at 2:00 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; However, it comes with many downsides:<br>&gt;&gt; <br>&gt;&gt; object references are expensive to update<br>&gt; <br>&gt; Most garbage collectors have write barriers, which execute extra code when references are updated.  Most garbage collectors also have safe points, which means that extra instructions get inserted into loops.<br></p><p>Many even have read barriers for when the heap is compacted.<br></p><p>&gt;&gt; heap fragmentation<br>&gt; <br>&gt; This is at best a tradeoff depending on what problem you’re trying to solve (e.g. better cache locality or smaller max RSS of the process).  One thing that I don’t think is debatable is that the heap compaction behavior of a GC (which is what provides the heap fragmentation win) is incredibly hostile for cache (because it cycles the entire memory space of the process) and performance predictability.<br>&gt; <br>&gt; Given that GC’s use a lot more memory than ARC systems do, it isn’t clear what you mean by GC’s winning on heap fragmentation<br></p><p>I find only copy collectors focus on cache locality. Usually the mark and sweep is a fallback when the copy collectors fail to prevent growth, and compaction of the mature objects to really promote reducing RSS is a last resort.<br></p><p>&gt; <br>&gt;&gt; the closure capture syntax uses up an unreasonable amount of mindshare just because of [weak self]<br>&gt; <br>&gt; I think that this specific point is solvable in others ways, but I’ll interpret this bullet as saying that you don’t want to worry about weak/unowned pointers.  I completely agree that we strive to provide a simple programming model, and I can see how &quot;not having to think about memory management&quot; seems appealing.<br>&gt; <br>&gt; On the other hand, there are major advantages to the Swift model.  Unlike MRR, Swift doesn’t require you to micromanage memory: you think about it at the object graph level when you’re building out your types.  Compared to MRR, ARC has moved memory management from being imperative to being declarative.  Swift also puts an emphasis on value types, so certain problems that you’d see in languages like Java are reduced.<br>&gt; <br></p><p>Small changes in the relationships between objects and object lifetime in an object-oriented design can have huge impacts when doing manual memory management. What was a scope-lived instance can become a long-lived, shared instance as part of new requirements, and if you are doing manual memory management result in large amounts of changes to accommodate the new ownership rules. This is occasionally when people move from alloc/free or scoped memory management to MRR.<br></p><p>MRR then can have issues when you are not tracking that objects may have an interrelationship (a cycle), which weak references can solve.<br></p><p>The important part of declarative management IMHO is that there are rules for how separate subsystems within your architecture reference one another (e.g. weak references to delegates). That eliminates a lot of the macro-level problems. Comparatively, micro-level problems can be understood as part of a subsystem&#39;s design.<br></p><p>&gt; That said, it is clear that it takes time and thought to use weak/unowned pointers correctly, so the question really becomes: does reasoning about your memory at the object graph level and expressing things in a declarative way contribute positively to your code?<br>&gt; <br>&gt; My opinion is yes: while I think it is silly to micromanage memory, I do think thinking about it some is useful. I think that expressing that intention directly in the code adds value in terms of maintenance of the code over time and communication to other people who work on it.<br></p><p>In generational systems there are de-optimization issues when an application (or application server) is composed of components with differing memory needs.<br></p><p>For example, a web application may have a current request, current transaction, user state, and a cache of persisted state. All of these have differing lifetimes. If the GC is optimized toward handling a younger generation consisting of just the current transaction (due to timing or space tuning), current transaction data may very well get promoted to the mature generation, where it is likely to stay until there is a full GC. Even with tuning, heavy use of caching may still push data into the mature generation, including cache data which is meant to expire. You wind up having threads doing concurrent and incremental garbage collection to deal with the fact that while the GC can be tuned for performance of any one component, it cannot be tuned to handle them well in aggregate.<br></p><p>MRR and declarative memory management systems generally are not negatively impacted by other in-process components.<br></p><p>&gt;&gt; Since Swift doesn&#39;t expose memory management operations outside of `autoreleasepool`, it seems to me that you could just drop in a garbage collector instead of reference counting and it would work (for most purposes).<br>&gt;&gt; <br>&gt;&gt; Has a GC been considered at all?<br>&gt; <br>&gt; GC also has several *huge* disadvantages that are usually glossed over: while it is true that modern GC&#39;s can provide high performance, they can only do that when they are granted *much* more memory than the process is actually using.  Generally, unless you give the GC 3-4x more memory than is needed, you’ll get thrashing and incredibly poor performance.  Additionally, since the sweep pass touches almost all RAM in the process, they tend to be very power inefficient (leading to reduced battery life).<br></p><p>Externalizing the marks from objects can turn much of the sweep into a read of memory rather than writing, which I believe does help power usage (although I’ve seen no studies of GC impact on battery life). It certainly helps for scripting languages, particularly in server-oriented applications on unix platforms, which are apt to fork() processes to handle requests than use threads, and wish to retain the benefits of CoW memory usage past the first GC cycle.<br></p><p>The memory and CPU impact of using a fully automatic GC are not to be understated though. This is a strong reason that different mobile phone platforms have drastically different memory requirements for their devices, for instance.<br></p><p>-DW<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160208/cb02259f/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 496 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160208/cb02259f/attachment.sig&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>What about garbage collection?</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>February  8, 2016 at 06:00:00pm</p></header><div class="content"><p>Chris, I appreciate that your reply covers the questions without simply stating an opinion.<br></p><p>&gt;&gt; It seems to me that the two principal upsides of reference counting are that destruction is (essentially) deterministic and performance is more easily predicted.<br>&gt; <br>&gt; Yes, deterministic destruction is a major feature.  Not having to explain what finalizers are (and why they shouldn’t generally be used) is a pretty huge.  Keep in mind that Swift interops with C, so deinit is unavoidable for certain types.<br>&gt; <br>&gt; More pointedly, not relying on GC enables Swift to be used in domains that don’t want it - think boot loaders, kernels, real time systems like audio processing, etc.<br></p><p>I agree that you don&#39;t want a GC in these, but on the other hand, from what I know of the current RC implementation, I find it hard to believe that it would be much more acceptable. Beyond any cycle efficiency concerns, interrupting a retain/release operation could cause a real carnage, and disabling interrupts while it happens won&#39;t necessarily be acceptable either. (Which begs the question: how well does Swift react to signals right now?)<br></p><p>If I wanted to use Swift today in these environments, I&#39;d probably stick to UnsafePointers and structs. It wouldn&#39;t really matter if classes were managed with a reference count or a mark-and-sweep collector since I wouldn&#39;t have any.<br></p><p>&gt; We have discussed in the passed using hybrid approaches like introducing a cycle collector, which runs less frequently than a GC would.  The problem with this is that if you introduce a cycle collector, code will start depending on it. In time you end up with some libraries/packages that works without GC, and others that leak without it (the D community has relevant experience here).  As such, we have come to think that adding a cycle collector would be bad for the Swift community in the large.<br></p><p>Yes, I&#39;ve heard about many problems with that and I wouldn&#39;t be in favor of a mix either.<br></p><p>&gt;&gt; object references cannot be atomically updated<br>&gt; <br>&gt; This is true, but Swift currently has no memory model and no concurrency model, so it isn’t clear that this is actually important (e.g. if you have no shared mutable state).<br></p><p>The fact that references can&#39;t be updated atomically will necessarily influence any decision that is taken regarding the concurrency model. The concurrency model pre-proposal &lt;https://github.com/apple/swift/blob/master/docs/proposals/Concurrency.rst&gt; already uses it as an argument to push a model that respects this limitation. I will be shocked if the same argument doesn&#39;t come up again when these talks actually start.<br></p><p>&gt;&gt; the closure capture syntax uses up an unreasonable amount of mindshare just because of [weak self]<br>&gt; <br>&gt; I think that this specific point is solvable in others ways, but I’ll interpret this bullet as saying that you don’t want to worry about weak/unowned pointers.  I completely agree that we strive to provide a simple programming model, and I can see how &quot;not having to think about memory management&quot; seems appealing.<br></p><p>What I actually meant is that a lot of energy is being spent right now on how to address these issues, which wouldn&#39;t be issues at all if Swift relied on a garbage collector.<br></p><p>&gt; On the other hand, there are major advantages to the Swift model.  Unlike MRR, Swift doesn’t require you to micromanage memory: you think about it at the object graph level when you’re building out your types.  Compared to MRR, ARC has moved memory management from being imperative to being declarative.  Swift also puts an emphasis on value types, so certain problems that you’d see in languages like Java are reduced.<br>&gt; <br>&gt; That said, it is clear that it takes time and thought to use weak/unowned pointers correctly, so the question really becomes: does reasoning about your memory at the object graph level and expressing things in a declarative way contribute positively to your code?  <br>&gt; <br>&gt; My opinion is yes: while I think it is silly to micromanage memory, I do think thinking about it some is useful. I think that expressing that intention directly in the code adds value in terms of maintenance of the code over time and communication to other people who work on it.<br></p><p>I don&#39;t agree with this. People will very often use `weak` or `unowned` only to break a cycle, not because it really doesn&#39;t matter if the object suddenly disappears. The whole weak self capture is a good example of that. The unpopularity of weak references in garbage-collected languages is generally a demonstration that most applications don&#39;t need to bother with that.<br></p><p>&gt;&gt; Since Swift doesn&#39;t expose memory management operations outside of `autoreleasepool`, it seems to me that you could just drop in a garbage collector instead of reference counting and it would work (for most purposes).<br>&gt;&gt; <br>&gt;&gt; Has a GC been considered at all?<br>&gt; <br>&gt; GC also has several *huge* disadvantages that are usually glossed over: while it is true that modern GC&#39;s can provide high performance, they can only do that when they are granted *much* more memory than the process is actually using.  Generally, unless you give the GC 3-4x more memory than is needed, you’ll get thrashing and incredibly poor performance.  Additionally, since the sweep pass touches almost all RAM in the process, they tend to be very power inefficient (leading to reduced battery life).<br>&gt; <br>&gt; I’m personally not interested in requiring a model that requires us to throw away a ton of perfectly good RAM to get an “simpler&quot; programming model - particularly on that adds so many tradeoffs.<br></p><p>The way I have to reason about cycles isn&#39;t my favorite part of Swift, but I&#39;m not necessarily in favor of having a GC either. I was very surprised that it hadn&#39;t come up at all since RC causes actual issues that are currently discussed. (It&#39;s also nice that you can ask and have informed people reply to you.)<br></p><p>Félix<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160208/09f70d2f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>What about garbage collection?</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>February  9, 2016 at 01:00:00pm</p></header><div class="content"><p>On Feb 8, 2016, at 3:13 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt;&gt; Yes, deterministic destruction is a major feature.  Not having to explain what finalizers are (and why they shouldn’t generally be used) is a pretty huge.  Keep in mind that Swift interops with C, so deinit is unavoidable for certain types.<br>&gt;&gt; <br>&gt;&gt; More pointedly, not relying on GC enables Swift to be used in domains that don’t want it - think boot loaders, kernels, real time systems like audio processing, etc.<br>&gt; <br>&gt; I agree that you don&#39;t want a GC in these, but on the other hand, from what I know of the current RC implementation, I find it hard to believe that it would be much more acceptable.<br></p><p>Why not?  ARC provides determinism with a “light” runtime, which is all these really need.<br></p><p>&gt; Beyond any cycle efficiency concerns, interrupting a retain/release operation could cause a real carnage, and disabling interrupts while it happens won&#39;t necessarily be acceptable either. (Which begs the question: how well does Swift react to signals right now?)<br></p><p>I don’t understand what you mean here.  If you’re talking about unix signals, then it is exactly the same as C: you can only do &quot;async signal safe” operations in a signal handler.  This means you can’t do much of anything.  I don’t see how ARC or GC are related at all to signal handling, since neither would allow you to allocate memory in a signal.<br></p><p>&gt;&gt;&gt; object references cannot be atomically updated<br>&gt;&gt; <br>&gt;&gt; This is true, but Swift currently has no memory model and no concurrency model, so it isn’t clear that this is actually important (e.g. if you have no shared mutable state).<br>&gt; <br>&gt; The fact that references can&#39;t be updated atomically will necessarily influence any decision that is taken regarding the concurrency model. The concurrency model pre-proposal &lt;https://github.com/apple/swift/blob/master/docs/proposals/Concurrency.rst&gt; already uses it <br></p><p>That isn’t a pre-proposal.  That is a random unendorsed idea, which will not necessarily lead to a specific swift design.<br></p><p>&gt; I will be shocked if the same argument doesn&#39;t come up again when these talks actually start.<br></p><p>Sure, but in any case, GC doesn’t solve race conditions or any of the other problems of that come up with that form of concurrency, so claiming that it really moves the needle on concurrency model doesn’t seem particularly useful.<br></p><p>Also, if you take into account the memory model of the hardware, providing atomic pointer updates in a GC setting requires use of synchronizing store instructions that are more expensive than normal stores (at least on most architectures, not including X86).<br></p><p>&gt;&gt;&gt; the closure capture syntax uses up an unreasonable amount of mindshare just because of [weak self]<br>&gt;&gt; <br>&gt;&gt; I think that this specific point is solvable in others ways, but I’ll interpret this bullet as saying that you don’t want to worry about weak/unowned pointers.  I completely agree that we strive to provide a simple programming model, and I can see how &quot;not having to think about memory management&quot; seems appealing.<br>&gt; <br>&gt; What I actually meant is that a lot of energy is being spent right now on how to address these issues, which wouldn&#39;t be issues at all if Swift relied on a garbage collector.<br></p><p>It is hard to read emotion through email so I can’t tell if you intend this to be snarky or not, but I assure you that the effort we are expending on this is a *tiny* fraction of the effort that would be required to successfully switch to GC and make it as good as what we have today.<br></p><p>&gt;&gt; My opinion is yes: while I think it is silly to micromanage memory, I do think thinking about it some is useful. I think that expressing that intention directly in the code adds value in terms of maintenance of the code over time and communication to other people who work on it.<br>&gt; <br>&gt; I don&#39;t agree with this. People will very often use `weak` or `unowned` only to break a cycle, not because it really doesn&#39;t matter if the object suddenly disappears. The whole weak self capture is a good example of that. The unpopularity of weak references in garbage-collected languages is generally a demonstration that most applications don&#39;t need to bother with that.<br></p><p>Sure, I can respect that opinion.  As I said, it was just MHO.<br></p><p>&gt;&gt; I’m personally not interested in requiring a model that requires us to throw away a ton of perfectly good RAM to get an “simpler&quot; programming model - particularly on that adds so many tradeoffs.<br>&gt; <br>&gt; The way I have to reason about cycles isn&#39;t my favorite part of Swift, but I&#39;m not necessarily in favor of having a GC either. I was very surprised that it hadn&#39;t come up at all since RC causes actual issues that are currently discussed. (It&#39;s also nice that you can ask and have informed people reply to you.)<br></p><p>Makes sense, thank you for providing a list of perceived advantages of GC (allowing a detailed response), instead of just saying “someone else does this, we should too!” :-)<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160209/4aa5e759/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>What about garbage collection?</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>February  8, 2016 at 11:00:00pm</p></header><div class="content"><p>Le 8 févr. 2016 à 16:00, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br></p><p>&gt; I’m personally not interested in requiring a model that requires us to throw away a ton of perfectly good RAM to get an “simpler&quot; programming model - particularly on that adds so many tradeoffs.<br></p><p>Me neither. I certainly prefer ARC. Hence one reason I like Swift more than D.<br></p><p>I&#39;d just like to point out that a &quot;fake&quot; GC that stops short of actually freeing objects to instead print a warning on the console listing objects to be collected would be a great help to detect and fix cycles early in development.<br></p><p>-- <br>Michel Fortin<br>https://michelf.ca<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>What about garbage collection?</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>February  8, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Feb 8, 2016, at 10:20 PM, Michel Fortin via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Le 8 févr. 2016 à 16:00, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt; <br>&gt;&gt; I’m personally not interested in requiring a model that requires us to throw away a ton of perfectly good RAM to get an “simpler&quot; programming model - particularly on that adds so many tradeoffs.<br>&gt; <br>&gt; Me neither. I certainly prefer ARC. Hence one reason I like Swift more than D.<br>&gt; <br>&gt; I&#39;d just like to point out that a &quot;fake&quot; GC that stops short of actually freeing objects to instead print a warning on the console listing objects to be collected would be a great help to detect and fix cycles early in development.<br></p><p>Isn’t this essentially what the ‘leaks’ tool is?<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160208/2965dca9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>What about garbage collection?</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>February  9, 2016 at 07:00:00am</p></header><div class="content"><p>Le 8 févr. 2016 à 23:34, Charles Srstka &lt;cocoadev at charlessoft.com&gt; a écrit :<br>&gt; <br>&gt;&gt; On Feb 8, 2016, at 10:20 PM, Michel Fortin via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Le 8 févr. 2016 à 16:00, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt;&gt; I’m personally not interested in requiring a model that requires us to throw away a ton of perfectly good RAM to get an “simpler&quot; programming model - particularly on that adds so many tradeoffs.<br>&gt;&gt; <br>&gt;&gt; Me neither. I certainly prefer ARC. Hence one reason I like Swift more than D.<br>&gt;&gt; <br>&gt;&gt; I&#39;d just like to point out that a &quot;fake&quot; GC that stops short of actually freeing objects to instead print a warning on the console listing objects to be collected would be a great help to detect and fix cycles early in development.<br>&gt; <br>&gt; Isn’t this essentially what the ‘leaks’ tool is?<br></p><p>I think so. Except you rarely use the `leaks` tool early in development. If this was baked into debug builds (with a way to opt out, of course), retain cycles would be caught much earlier in the development process and you&#39;d see your leaks almost immediately after writing the offending code.<br></p><p>In fact, I&#39;m pretty sure most people here don&#39;t check for leaks even in the final build of their app unless there&#39;s an obvious leakage problem. I know I don&#39;t, generally.<br></p><p>-- <br>Michel Fortin<br>https://michelf.ca<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>What about garbage collection?</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>February  9, 2016 at 10:00:00am</p></header><div class="content"><p>When programming C and C++, I had a strong requirement that my testing tools were clean, so that I could run tools similar to leaks over my unit/integration test suite. <br></p><p>-DW<br></p><p>&gt; On Feb 9, 2016, at 5:16 AM, Michel Fortin via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Le 8 févr. 2016 à 23:34, Charles Srstka &lt;cocoadev at charlessoft.com&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 8, 2016, at 10:20 PM, Michel Fortin via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Le 8 févr. 2016 à 16:00, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m personally not interested in requiring a model that requires us to throw away a ton of perfectly good RAM to get an “simpler&quot; programming model - particularly on that adds so many tradeoffs.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Me neither. I certainly prefer ARC. Hence one reason I like Swift more than D.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;d just like to point out that a &quot;fake&quot; GC that stops short of actually freeing objects to instead print a warning on the console listing objects to be collected would be a great help to detect and fix cycles early in development.<br>&gt;&gt; <br>&gt;&gt; Isn’t this essentially what the ‘leaks’ tool is?<br>&gt; <br>&gt; I think so. Except you rarely use the `leaks` tool early in development. If this was baked into debug builds (with a way to opt out, of course), retain cycles would be caught much earlier in the development process and you&#39;d see your leaks almost immediately after writing the offending code.<br>&gt; <br>&gt; In fact, I&#39;m pretty sure most people here don&#39;t check for leaks even in the final build of their app unless there&#39;s an obvious leakage problem. I know I don&#39;t, generally.<br>&gt; <br>&gt; -- <br>&gt; Michel Fortin<br>&gt; https://michelf.ca<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: smime.p7s<br>Type: application/pkcs7-signature<br>Size: 4139 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160209/84fc748a/attachment.p7s&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>What about garbage collection?</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>February  8, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; <br>&gt; On Feb 8, 2016, at 1:00 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; the closure capture syntax uses up an unreasonable amount of mindshare just because of [weak self]<br>&gt; <br>&gt; I think that this specific point is solvable in others ways, but I’ll interpret this bullet as saying that you don’t want to worry about weak/unowned pointers.  I completely agree that we strive to provide a simple programming model, and I can see how &quot;not having to think about memory management&quot; seems appealing.<br>&gt; <br>I actually like RC, and don’t find it particularly problematic except in this one case…the closure case. If we could solve this one problem then I think the rest of it is fine. I don’t mind remembering to put a weak reference in for back pointers etc. The benefits of RC are great, and the introduction of ARC was a great mental burden lifted of developer’s minds. Just trying to explain and remember all the tricky rules around the closure capture would be nice to solve and would love to discuss that rather than garbage collection. <br></p><p>- Paul<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160208/5fd12c25/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d0659d0725d0f35fa2b7d2cd23631502?s=50"></div><header><strong>What about garbage collection?</strong> from <string>Vanderlei Martinelli</string> &lt;vmartinelli at alecrim.com&gt;<p>February  9, 2016 at 03:00:00am</p></header><div class="content"><p>Particularly I think the strong/weak dance, after understood and properly<br>applied, is a benefit and not a bad thing.<br></p><p>We can write things like:<br></p><p>doSomeLongRunningTaskThatCannotBeCancelled { [weak self] someText in<br>    self?.someLabel.text = someText<br>}<br></p><p>This is a very common case in Cocoa [Touch], I think. Using GC how could we<br>say: “hey, if the result comes in and I&#39;m no longer here, just ignore it,<br>okay?”<br></p><p>I really like that RC and ARC are alive in Swift. Perhaps in the future we<br>have something better, yet I would still like to be able to write code like<br>the above. About GC: I do not know any good reasons to bring it to Swift.<br></p><p>-Van<br></p><p>On Tue, Feb 9, 2016 at 2:54 AM, Paul Ossenbruggen via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Feb 8, 2016, at 1:00 PM, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt;    -<br>&gt;    the closure capture syntax uses up an unreasonable amount of mindshare<br>&gt;    just because of [weak self]<br>&gt;<br>&gt;<br>&gt; I think that this specific point is solvable in others ways, but I’ll<br>&gt; interpret this bullet as saying that you don’t want to worry about<br>&gt; weak/unowned pointers.  I completely agree that we strive to provide a<br>&gt; simple programming model, and I can see how &quot;not having to think about<br>&gt; memory management&quot; seems appealing.<br>&gt;<br>&gt; I actually like RC, and don’t find it particularly problematic except in<br>&gt; this one case…the closure case. If we could solve this one problem then I<br>&gt; think the rest of it is fine. I don’t mind remembering to put a weak<br>&gt; reference in for back pointers etc. The benefits of RC are great, and the<br>&gt; introduction of ARC was a great mental burden lifted of developer’s minds.<br>&gt; Just trying to explain and remember all the tricky rules around the closure<br>&gt; capture would be nice to solve and would love to discuss that rather than<br>&gt; garbage collection.<br>&gt;<br>&gt; - Paul<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160209/cafa53c8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d0659d0725d0f35fa2b7d2cd23631502?s=50"></div><header><strong>What about garbage collection?</strong> from <string>Vanderlei Martinelli</string> &lt;vmartinelli at alecrim.com&gt;<p>February  9, 2016 at 03:00:00am</p></header><div class="content"><p>It is good to explain that in the example I gave we do not have to declare<br>self as weak (completion handlers do not need this), but it was declared<br>this way to not retain the view controller (or view) while the user is<br>already seeing something else on the screen.<br></p><p>-Van<br></p><p>On Tue, Feb 9, 2016 at 3:04 AM, Vanderlei Martinelli &lt;<br>vmartinelli at alecrim.com&gt; wrote:<br></p><p>&gt; Particularly I think the strong/weak dance, after understood and properly<br>&gt; applied, is a benefit and not a bad thing.<br>&gt;<br>&gt; We can write things like:<br>&gt;<br>&gt; doSomeLongRunningTaskThatCannotBeCancelled { [weak self] someText in<br>&gt;     self?.someLabel.text = someText<br>&gt; }<br>&gt;<br>&gt; This is a very common case in Cocoa [Touch], I think. Using GC how could<br>&gt; we say: “hey, if the result comes in and I&#39;m no longer here, just ignore<br>&gt; it, okay?”<br>&gt;<br>&gt; I really like that RC and ARC are alive in Swift. Perhaps in the future we<br>&gt; have something better, yet I would still like to be able to write code like<br>&gt; the above. About GC: I do not know any good reasons to bring it to Swift.<br>&gt;<br>&gt; -Van<br>&gt;<br>&gt; On Tue, Feb 9, 2016 at 2:54 AM, Paul Ossenbruggen via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Feb 8, 2016, at 1:00 PM, Chris Lattner via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;    -<br>&gt;&gt;    the closure capture syntax uses up an unreasonable amount of<br>&gt;&gt;    mindshare just because of [weak self]<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I think that this specific point is solvable in others ways, but I’ll<br>&gt;&gt; interpret this bullet as saying that you don’t want to worry about<br>&gt;&gt; weak/unowned pointers.  I completely agree that we strive to provide a<br>&gt;&gt; simple programming model, and I can see how &quot;not having to think about<br>&gt;&gt; memory management&quot; seems appealing.<br>&gt;&gt;<br>&gt;&gt; I actually like RC, and don’t find it particularly problematic except in<br>&gt;&gt; this one case…the closure case. If we could solve this one problem then I<br>&gt;&gt; think the rest of it is fine. I don’t mind remembering to put a weak<br>&gt;&gt; reference in for back pointers etc. The benefits of RC are great, and the<br>&gt;&gt; introduction of ARC was a great mental burden lifted of developer’s minds.<br>&gt;&gt; Just trying to explain and remember all the tricky rules around the closure<br>&gt;&gt; capture would be nice to solve and would love to discuss that rather than<br>&gt;&gt; garbage collection.<br>&gt;&gt;<br>&gt;&gt; - Paul<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160209/f382c3e7/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>What about garbage collection?</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>February  9, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Feb 8, 2016, at 1:00 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; We have discussed in the passed using hybrid approaches like introducing a cycle collector, which runs less frequently than a GC would.  The problem with this is that if you introduce a cycle collector, code will start depending on it. In time you end up with some libraries/packages that works without GC, and others that leak without it (the D community has relevant experience here).  As such, we have come to think that adding a cycle collector would be bad for the Swift community in the large.<br></p><p>A cycle collector also requires that retaining storage and non-retaining storage be distinguishable. This would be possible in a pure-Swift environment with sufficient extra metadata, but is not in Objective-C. Any cycle that included an Objective-C object would not be detectable.<br></p><p><br>-- <br>Greg Parker     gparker at apple.com &lt;mailto:gparker at apple.com&gt;     Runtime Wrangler<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160209/74f7b289/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>What about garbage collection?</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>February 10, 2016 at 07:00:00am</p></header><div class="content"><p>Strong -1 for GC.<br></p><p>I think the advantages of ARC over GC as given by Chris, Joe and Dave with regards to energy efficiency, memory efficiency, caching behavior, predictability, value types with copy on write and declarative memory management on the object graph level are essential and indispensable. <br></p><p>And yes, I see it as an advantage having to think about memory management dependencies on the object graph level and deciding how to break cycles. I think this leads to much cleaner object models.<br></p><p>-Thorsten <br></p><p>&gt; Am 08.02.2016 um 22:00 schrieb Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt;&gt; On Feb 8, 2016, at 11:56 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Has there been a garbage collection thread so far? I understand that reference counting vs. garbage collection can be a heated debate, but it might be relevant to have it.<br>&gt; <br>&gt; Technically speaking, reference counting is a form of garbage collection, but I get what you mean.  Since there are multiple forms of GC, I&#39;ll assume that you mean a generational mark and sweep algorithm like you’d see in a Java implementation.<br>&gt; <br>&gt;&gt; It seems to me that the two principal upsides of reference counting are that destruction is (essentially) deterministic and performance is more easily predicted.<br>&gt; <br>&gt; Yes, deterministic destruction is a major feature.  Not having to explain what finalizers are (and why they shouldn’t generally be used) is a pretty huge.  Keep in mind that Swift interops with C, so deinit is unavoidable for certain types.<br>&gt; <br>&gt; More pointedly, not relying on GC enables Swift to be used in domains that don’t want it - think boot loaders, kernels, real time systems like audio processing, etc.<br>&gt; <br>&gt; We have discussed in the passed using hybrid approaches like introducing a cycle collector, which runs less frequently than a GC would.  The problem with this is that if you introduce a cycle collector, code will start depending on it. In time you end up with some libraries/packages that works without GC, and others that leak without it (the D community has relevant experience here).  As such, we have come to think that adding a cycle collector would be bad for the Swift community in the large.<br>&gt; <br>&gt;&gt; However, it comes with many downsides:<br>&gt;&gt; <br>&gt;&gt; object references are expensive to update<br>&gt; <br>&gt; Most garbage collectors have write barriers, which execute extra code when references are updated.  Most garbage collectors also have safe points, which means that extra instructions get inserted into loops.<br>&gt; <br>&gt;&gt; object references cannot be atomically updated<br>&gt; <br>&gt; This is true, but Swift currently has no memory model and no concurrency model, so it isn’t clear that this is actually important (e.g. if you have no shared mutable state).<br>&gt; <br>&gt;&gt; heap fragmentation<br>&gt; <br>&gt; This is at best a tradeoff depending on what problem you’re trying to solve (e.g. better cache locality or smaller max RSS of the process).  One thing that I don’t think is debatable is that the heap compaction behavior of a GC (which is what provides the heap fragmentation win) is incredibly hostile for cache (because it cycles the entire memory space of the process) and performance predictability.<br>&gt; <br>&gt; Given that GC’s use a lot more memory than ARC systems do, it isn’t clear what you mean by GC’s winning on heap fragmentation.<br>&gt; <br>&gt;&gt; the closure capture syntax uses up an unreasonable amount of mindshare just because of [weak self]<br>&gt; <br>&gt; I think that this specific point is solvable in others ways, but I’ll interpret this bullet as saying that you don’t want to worry about weak/unowned pointers.  I completely agree that we strive to provide a simple programming model, and I can see how &quot;not having to think about memory management&quot; seems appealing.<br>&gt; <br>&gt; On the other hand, there are major advantages to the Swift model.  Unlike MRR, Swift doesn’t require you to micromanage memory: you think about it at the object graph level when you’re building out your types.  Compared to MRR, ARC has moved memory management from being imperative to being declarative.  Swift also puts an emphasis on value types, so certain problems that you’d see in languages like Java are reduced.<br>&gt; <br>&gt; That said, it is clear that it takes time and thought to use weak/unowned pointers correctly, so the question really becomes: does reasoning about your memory at the object graph level and expressing things in a declarative way contribute positively to your code?  <br>&gt; <br>&gt; My opinion is yes: while I think it is silly to micromanage memory, I do think thinking about it some is useful. I think that expressing that intention directly in the code adds value in terms of maintenance of the code over time and communication to other people who work on it.<br>&gt; <br>&gt;&gt; Since Swift doesn&#39;t expose memory management operations outside of `autoreleasepool`, it seems to me that you could just drop in a garbage collector instead of reference counting and it would work (for most purposes).<br>&gt;&gt; <br>&gt;&gt; Has a GC been considered at all?<br>&gt; <br>&gt; GC also has several *huge* disadvantages that are usually glossed over: while it is true that modern GC&#39;s can provide high performance, they can only do that when they are granted *much* more memory than the process is actually using.  Generally, unless you give the GC 3-4x more memory than is needed, you’ll get thrashing and incredibly poor performance.  Additionally, since the sweep pass touches almost all RAM in the process, they tend to be very power inefficient (leading to reduced battery life).<br>&gt; <br>&gt; I’m personally not interested in requiring a model that requires us to throw away a ton of perfectly good RAM to get an “simpler&quot; programming model - particularly on that adds so many tradeoffs.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160210/547d43da/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>What about garbage collection?</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>February 10, 2016 at 07:00:00am</p></header><div class="content"><p>It does break the make it easy to debug rule though. In any non trivial system worked on by a moderate to large team, manually hunting cyclic references and appropriately breaking them down without introducing bugs can still be very painful. GC is one of those technologies where you trade the efficiency you mention for a safer and easier to use memory model where you would spend a lot less time to debug for correctness.<br></p><p>There are some system where memory safety, type safety, and thread safety rule over pure performance concerns... Reasons why C# and Java still have this much traction. Just as much as the small tax of reference counting (and having so much accumulated knowledge that is able to exploit the vast ways it allows you to go about it) is still greater than not 0... see why C++ still has this enormous presence on all platforms where performance really matters... Games on iOS too.<br></p><p>Still, if GC never comes to Swift, say not even a cycle detector exclusively say in Debug builds on the iOS Simulator just to restrict things a bit (Address Sanitiser does make a precedence),  but spotting them and hunting them down using Xcode becomes easier then it is a much much better overall win.<br></p><p>Sent from my iPhone<br></p><p>&gt; On 10 Feb 2016, at 06:14, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Strong -1 for GC.<br>&gt; <br>&gt; I think the advantages of ARC over GC as given by Chris, Joe and Dave with regards to energy efficiency, memory efficiency, caching behavior, predictability, value types with copy on write and declarative memory management on the object graph level are essential and indispensable. <br>&gt; <br>&gt; And yes, I see it as an advantage having to think about memory management dependencies on the object graph level and deciding how to break cycles. I think this leads to much cleaner object models.<br>&gt; <br>&gt; -Thorsten <br>&gt; <br>&gt;&gt; Am 08.02.2016 um 22:00 schrieb Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 8, 2016, at 11:56 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; Has there been a garbage collection thread so far? I understand that reference counting vs. garbage collection can be a heated debate, but it might be relevant to have it.<br>&gt;&gt; <br>&gt;&gt; Technically speaking, reference counting is a form of garbage collection, but I get what you mean.  Since there are multiple forms of GC, I&#39;ll assume that you mean a generational mark and sweep algorithm like you’d see in a Java implementation.<br>&gt;&gt; <br>&gt;&gt;&gt; It seems to me that the two principal upsides of reference counting are that destruction is (essentially) deterministic and performance is more easily predicted.<br>&gt;&gt; <br>&gt;&gt; Yes, deterministic destruction is a major feature.  Not having to explain what finalizers are (and why they shouldn’t generally be used) is a pretty huge.  Keep in mind that Swift interops with C, so deinit is unavoidable for certain types.<br>&gt;&gt; <br>&gt;&gt; More pointedly, not relying on GC enables Swift to be used in domains that don’t want it - think boot loaders, kernels, real time systems like audio processing, etc.<br>&gt;&gt; <br>&gt;&gt; We have discussed in the passed using hybrid approaches like introducing a cycle collector, which runs less frequently than a GC would.  The problem with this is that if you introduce a cycle collector, code will start depending on it. In time you end up with some libraries/packages that works without GC, and others that leak without it (the D community has relevant experience here).  As such, we have come to think that adding a cycle collector would be bad for the Swift community in the large.<br>&gt;&gt; <br>&gt;&gt;&gt; However, it comes with many downsides:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; object references are expensive to update<br>&gt;&gt; <br>&gt;&gt; Most garbage collectors have write barriers, which execute extra code when references are updated.  Most garbage collectors also have safe points, which means that extra instructions get inserted into loops.<br>&gt;&gt; <br>&gt;&gt;&gt; object references cannot be atomically updated<br>&gt;&gt; <br>&gt;&gt; This is true, but Swift currently has no memory model and no concurrency model, so it isn’t clear that this is actually important (e.g. if you have no shared mutable state).<br>&gt;&gt; <br>&gt;&gt;&gt; heap fragmentation<br>&gt;&gt; <br>&gt;&gt; This is at best a tradeoff depending on what problem you’re trying to solve (e.g. better cache locality or smaller max RSS of the process).  One thing that I don’t think is debatable is that the heap compaction behavior of a GC (which is what provides the heap fragmentation win) is incredibly hostile for cache (because it cycles the entire memory space of the process) and performance predictability.<br>&gt;&gt; <br>&gt;&gt; Given that GC’s use a lot more memory than ARC systems do, it isn’t clear what you mean by GC’s winning on heap fragmentation.<br>&gt;&gt; <br>&gt;&gt;&gt; the closure capture syntax uses up an unreasonable amount of mindshare just because of [weak self]<br>&gt;&gt; <br>&gt;&gt; I think that this specific point is solvable in others ways, but I’ll interpret this bullet as saying that you don’t want to worry about weak/unowned pointers.  I completely agree that we strive to provide a simple programming model, and I can see how &quot;not having to think about memory management&quot; seems appealing.<br>&gt;&gt; <br>&gt;&gt; On the other hand, there are major advantages to the Swift model.  Unlike MRR, Swift doesn’t require you to micromanage memory: you think about it at the object graph level when you’re building out your types.  Compared to MRR, ARC has moved memory management from being imperative to being declarative.  Swift also puts an emphasis on value types, so certain problems that you’d see in languages like Java are reduced.<br>&gt;&gt; <br>&gt;&gt; That said, it is clear that it takes time and thought to use weak/unowned pointers correctly, so the question really becomes: does reasoning about your memory at the object graph level and expressing things in a declarative way contribute positively to your code?  <br>&gt;&gt; <br>&gt;&gt; My opinion is yes: while I think it is silly to micromanage memory, I do think thinking about it some is useful. I think that expressing that intention directly in the code adds value in terms of maintenance of the code over time and communication to other people who work on it.<br>&gt;&gt; <br>&gt;&gt;&gt; Since Swift doesn&#39;t expose memory management operations outside of `autoreleasepool`, it seems to me that you could just drop in a garbage collector instead of reference counting and it would work (for most purposes).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Has a GC been considered at all?<br>&gt;&gt; <br>&gt;&gt; GC also has several *huge* disadvantages that are usually glossed over: while it is true that modern GC&#39;s can provide high performance, they can only do that when they are granted *much* more memory than the process is actually using.  Generally, unless you give the GC 3-4x more memory than is needed, you’ll get thrashing and incredibly poor performance.  Additionally, since the sweep pass touches almost all RAM in the process, they tend to be very power inefficient (leading to reduced battery life).<br>&gt;&gt; <br>&gt;&gt; I’m personally not interested in requiring a model that requires us to throw away a ton of perfectly good RAM to get an “simpler&quot; programming model - particularly on that adds so many tradeoffs.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160210/e422522f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>What about garbage collection?</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>February 10, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; On Feb 9, 2016, at 11:50 PM, Goffredo Marocchi via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; It does break the make it easy to debug rule though. In any non trivial system worked on by a moderate to large team, manually hunting cyclic references and appropriately breaking them down without introducing bugs can still be very painful. GC is one of those technologies where you trade the efficiency you mention for a safer and easier to use memory model where you would spend a lot less time to debug for correctness.<br></p><p>And this is replaced with analyzing performance profiles to understand why sporadic slowdowns are happening. Then you find that too many allocations of objects are being created causing the GC sweep to take longer than is acceptable. Now you need to try and preempt the GC sweep by triggering it sooner or pausing it all together. The other option is trying to fix what is most likely an architectural issue with the allocation graph. One way to do that is to go about creating pools of objects that no longer have real-lifetimes according to the GC because they are always alive and just marked as inactive.<br></p><p>That&#39;s just a sample of real-world performance analysis I used to do on the Visual Studio team when we starting using a bunch of managed code (C#) in it. <br></p><p>Another is simply not understanding what types of things hold onto objects so that they are never collected. C# has a problem (or did at least when I was still using it) with this and its eventing model. If you forget to unregister the events, then good luck getting that memory back. Or if one thing somewhere in your code is holding a reference to your giant data structures - nope, not going to get collected.<br></p><p>The point is, even with a GC, you still need to be conscious about what&#39;s going on.<br></p><p>It&#39;s simply not been my experience that debugging the type of issues you run into with a GC are significantly easier than a non-GC system. In fact, in many ways they are harder as often times the solution is to architecture around the limitations of the GC.<br></p><p>-David<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>What about garbage collection?</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>February 10, 2016 at 10:00:00pm</p></header><div class="content"><p>In the non trivial systems I have worked on which require loading complex object graphs or parts thereof from a database I have to think about cyclic references and ownership as well to allow loading parts of object graphs (for performance and memory reasons and we are talking about a server with lots of RAM here) without accidentally loading the whole graph. That’s quite the same problem and an important design aspect of the domain model IMO.<br></p><p>-Thorsten<br></p><p><br>&gt; Am 10.02.2016 um 08:50 schrieb Goffredo Marocchi &lt;panajev at gmail.com&gt;:<br>&gt; <br>&gt; It does break the make it easy to debug rule though. In any non trivial system worked on by a moderate to large team, manually hunting cyclic references and appropriately breaking them down without introducing bugs can still be very painful. GC is one of those technologies where you trade the efficiency you mention for a safer and easier to use memory model where you would spend a lot less time to debug for correctness.<br>&gt; <br>&gt; There are some system where memory safety, type safety, and thread safety rule over pure performance concerns... Reasons why C# and Java still have this much traction. Just as much as the small tax of reference counting (and having so much accumulated knowledge that is able to exploit the vast ways it allows you to go about it) is still greater than not 0... see why C++ still has this enormous presence on all platforms where performance really matters... Games on iOS too.<br>&gt; <br>&gt; Still, if GC never comes to Swift, say not even a cycle detector exclusively say in Debug builds on the iOS Simulator just to restrict things a bit (Address Sanitiser does make a precedence),  but spotting them and hunting them down using Xcode becomes easier then it is a much much better overall win.<br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt; On 10 Feb 2016, at 06:14, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Strong -1 for GC.<br>&gt;&gt; <br>&gt;&gt; I think the advantages of ARC over GC as given by Chris, Joe and Dave with regards to energy efficiency, memory efficiency, caching behavior, predictability, value types with copy on write and declarative memory management on the object graph level are essential and indispensable. <br>&gt;&gt; <br>&gt;&gt; And yes, I see it as an advantage having to think about memory management dependencies on the object graph level and deciding how to break cycles. I think this leads to much cleaner object models.<br>&gt;&gt; <br>&gt;&gt; -Thorsten <br>&gt;&gt; <br>&gt;&gt; Am 08.02.2016 um 22:00 schrieb Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 8, 2016, at 11:56 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; Has there been a garbage collection thread so far? I understand that reference counting vs. garbage collection can be a heated debate, but it might be relevant to have it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Technically speaking, reference counting is a form of garbage collection, but I get what you mean.  Since there are multiple forms of GC, I&#39;ll assume that you mean a generational mark and sweep algorithm like you’d see in a Java implementation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It seems to me that the two principal upsides of reference counting are that destruction is (essentially) deterministic and performance is more easily predicted.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, deterministic destruction is a major feature.  Not having to explain what finalizers are (and why they shouldn’t generally be used) is a pretty huge.  Keep in mind that Swift interops with C, so deinit is unavoidable for certain types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; More pointedly, not relying on GC enables Swift to be used in domains that don’t want it - think boot loaders, kernels, real time systems like audio processing, etc.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We have discussed in the passed using hybrid approaches like introducing a cycle collector, which runs less frequently than a GC would.  The problem with this is that if you introduce a cycle collector, code will start depending on it. In time you end up with some libraries/packages that works without GC, and others that leak without it (the D community has relevant experience here).  As such, we have come to think that adding a cycle collector would be bad for the Swift community in the large.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; However, it comes with many downsides:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; object references are expensive to update<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Most garbage collectors have write barriers, which execute extra code when references are updated.  Most garbage collectors also have safe points, which means that extra instructions get inserted into loops.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; object references cannot be atomically updated<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is true, but Swift currently has no memory model and no concurrency model, so it isn’t clear that this is actually important (e.g. if you have no shared mutable state).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; heap fragmentation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is at best a tradeoff depending on what problem you’re trying to solve (e.g. better cache locality or smaller max RSS of the process).  One thing that I don’t think is debatable is that the heap compaction behavior of a GC (which is what provides the heap fragmentation win) is incredibly hostile for cache (because it cycles the entire memory space of the process) and performance predictability.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Given that GC’s use a lot more memory than ARC systems do, it isn’t clear what you mean by GC’s winning on heap fragmentation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; the closure capture syntax uses up an unreasonable amount of mindshare just because of [weak self]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think that this specific point is solvable in others ways, but I’ll interpret this bullet as saying that you don’t want to worry about weak/unowned pointers.  I completely agree that we strive to provide a simple programming model, and I can see how &quot;not having to think about memory management&quot; seems appealing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On the other hand, there are major advantages to the Swift model.  Unlike MRR, Swift doesn’t require you to micromanage memory: you think about it at the object graph level when you’re building out your types.  Compared to MRR, ARC has moved memory management from being imperative to being declarative.  Swift also puts an emphasis on value types, so certain problems that you’d see in languages like Java are reduced.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That said, it is clear that it takes time and thought to use weak/unowned pointers correctly, so the question really becomes: does reasoning about your memory at the object graph level and expressing things in a declarative way contribute positively to your code?  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My opinion is yes: while I think it is silly to micromanage memory, I do think thinking about it some is useful. I think that expressing that intention directly in the code adds value in terms of maintenance of the code over time and communication to other people who work on it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Since Swift doesn&#39;t expose memory management operations outside of `autoreleasepool`, it seems to me that you could just drop in a garbage collector instead of reference counting and it would work (for most purposes).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Has a GC been considered at all?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; GC also has several *huge* disadvantages that are usually glossed over: while it is true that modern GC&#39;s can provide high performance, they can only do that when they are granted *much* more memory than the process is actually using.  Generally, unless you give the GC 3-4x more memory than is needed, you’ll get thrashing and incredibly poor performance.  Additionally, since the sweep pass touches almost all RAM in the process, they tend to be very power inefficient (leading to reduced battery life).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m personally not interested in requiring a model that requires us to throw away a ton of perfectly good RAM to get an “simpler&quot; programming model - particularly on that adds so many tradeoffs.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160210/a676d2de/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/46439321e8b5b5ba0944eef50e18c3a3?s=50"></div><header><strong>What about garbage collection?</strong> from <string>Jean-Denis Muys</string> &lt;jdmuys at gmail.com&gt;<p>February 10, 2016 at 09:00:00am</p></header><div class="content"><p>Based on this as the summary of arguments I read so far on this thread, I tend to increase my +1. Here is what I read:<br></p><p>- arguments regarding energy efficiency, memory efficiency, or more generally hardware limitations seem to me rather short-sighted, as in “640 KB or RAM should be enough for all times to come” (original design decision by IBM for the PC). Is Swift a language designed for todays hardware? Or is it supposed to outlast it a wee bit?<br></p><p>- arguments that say that managing [some aspect of] memory is good because it will lead to better programs could be equally be brought forward against any optimisation. With or without GC, with or without RC, you can expect many programmer to make bad design decisions for lack of understanding of the technology, hardware or software. I really question whether making the programmer responsible for managing the object graph is “essential”. This thread has claimed that, but not supported it.<br></p><p>- arguments claimed elsewhere as myths that have been debunked (better efficiency and predictability come to mind) in comparisons with state of the art GC systems.<br></p><p>- arguments that seem to me a bit disingenuous, such as blaming GC for Java’s failure on the desktop<br></p><p>- arguments which I am not competent enough to understand, e.g. the write and read barriers topic, on which I would like to get better educated<br></p><p><br>Of course some ideal would be a language where GC is an option. I am not sure whether that is possible, though the one argument I saw against that, namely that libraries would be compatible with one of the options only, can be solved with the fat binary idea. We used to have libraries compatible with both PowerPC and Intel processors. That sounds a lot more complex.<br></p><p>Overall, my opinion at this time is that precluding GC is too short sighted, and any decision made today should not be incompatible with the possible introduction of GC tomorrow. While RC is adequate, GC is better on the long run, simply because higher level constructs make [good] programmers more productive, and would be a good longer term goal. I have still to meet a more productive environment than what the Lisp machines proposed in the 90’s. While I do not claim that GC was responsible for that, it was certainly part of the deal. Or perhaps my memory is fading, making them better than they actually were, that’s possible too.<br></p><p>Jean-Denis<br></p><p><br>&gt; On 10 Feb 2016, at 07:14, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Strong -1 for GC.<br>&gt; <br>&gt; I think the advantages of ARC over GC as given by Chris, Joe and Dave with regards to energy efficiency, memory efficiency, caching behavior, predictability, value types with copy on write and declarative memory management on the object graph level are essential and indispensable. <br>&gt; <br>&gt; And yes, I see it as an advantage having to think about memory management dependencies on the object graph level and deciding how to break cycles. I think this leads to much cleaner object models.<br>&gt; <br>&gt; -Thorsten <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>What about garbage collection?</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>February 10, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; <br>&gt; - arguments regarding energy efficiency, memory efficiency, or more generally hardware limitations seem to me rather short-sighted, as in “640 KB or RAM should be enough for all times to come” (original design decision by IBM for the PC). Is Swift a language designed for todays hardware? Or is it supposed to outlast it a wee bit?<br></p><p>For the foreseeable future - energy efficiency is a very real and important factor.  Battery technology (as compared to other technology) is not moving quickly, so being efficient is important.  (and one of the items that is listed as a plus for iDevices over the competion)  The focus of the language (even though open sourced) is primarily focused on a programming language for “desktop” and iDevices.  A majority of the computers sold by Apple rely on battery (laptops, iDevices, etc.).  <br></p><p>The java type GC has a big advantage is that incompetent programmers don’t have to worry about memory management (and they make up a majority of programmers).  And yes, I have seen cases where someone wrote a server (microsoft based) component that had so many cylindrical references that people assumed would just clean up — that to make it work they had to write another monitor application to watch for the application memory usage growing above a certain size based on memory leaks then force a “reboot” of it :p<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>What about garbage collection?</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>February 10, 2016 at 04:00:00am</p></header><div class="content"><p>Mark-and-sweep GC seems to be a non-starter as long as Swift&#39;s collections<br>remain copy-on-write value types. The way an Array (or other dynamically<br>sized stdlib collection) knows to write to its existing buffer, rather than<br>creating a whole new copy, is by looking at the buffer object&#39;s reference<br>count (via the `isUniquelyReferenced` API). Mike Ash has a good summary of<br>how this process works here:<br>https://www.mikeash.com/pyblog/friday-qa-2015-04-17-lets-build-swiftarray.html<br>.<br></p><p>The RemObjects Silver Swift-alike compiler, which targets the JVM and CLR,<br>is forced to treat its collections as reference types because of how COW is<br>implemented:<br>http://docs.elementscompiler.com/Silver/DifferencesAndLimitations/.<br></p><p>The most pertinent questions with regards to Swift GC are: whether or not<br>some acceptably efficient form of efficient copy-on-write mechanism for<br>value type collections in a tracing GC environment exists, and if not<br>whether the enormous semantic change that turning collections into<br>reference types would entail would be worthwhile. (This in turn would have<br>a whole set of knock-on effects; for example, generic stdlib collections<br>could no longer be properly covariant.)<br></p><p><br>On Wed, Feb 10, 2016 at 1:08 AM, Craig Cruden via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt;<br>&gt; &gt; - arguments regarding energy efficiency, memory efficiency, or more<br>&gt; generally hardware limitations seem to me rather short-sighted, as in “640<br>&gt; KB or RAM should be enough for all times to come” (original design decision<br>&gt; by IBM for the PC). Is Swift a language designed for todays hardware? Or is<br>&gt; it supposed to outlast it a wee bit?<br>&gt;<br>&gt; For the foreseeable future - energy efficiency is a very real and<br>&gt; important factor.  Battery technology (as compared to other technology) is<br>&gt; not moving quickly, so being efficient is important.  (and one of the items<br>&gt; that is listed as a plus for iDevices over the competion)  The focus of the<br>&gt; language (even though open sourced) is primarily focused on a programming<br>&gt; language for “desktop” and iDevices.  A majority of the computers sold by<br>&gt; Apple rely on battery (laptops, iDevices, etc.).<br>&gt;<br>&gt; The java type GC has a big advantage is that incompetent programmers don’t<br>&gt; have to worry about memory management (and they make up a majority of<br>&gt; programmers).  And yes, I have seen cases where someone wrote a server<br>&gt; (microsoft based) component that had so many cylindrical references that<br>&gt; people assumed would just clean up — that to make it work they had to write<br>&gt; another monitor application to watch for the application memory usage<br>&gt; growing above a certain size based on memory leaks then force a “reboot” of<br>&gt; it :p<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160210/4e41f282/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>What about garbage collection?</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February 10, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Feb 10, 2016, at 4:31 AM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Mark-and-sweep GC seems to be a non-starter as long as Swift&#39;s collections remain copy-on-write value types. The way an Array (or other dynamically sized stdlib collection) knows to write to its existing buffer, rather than creating a whole new copy, is by looking at the buffer object&#39;s reference count (via the `isUniquelyReferenced` API). Mike Ash has a good summary of how this process works here: https://www.mikeash.com/pyblog/friday-qa-2015-04-17-lets-build-swiftarray.html &lt;https://www.mikeash.com/pyblog/friday-qa-2015-04-17-lets-build-swiftarray.html&gt;.<br>&gt; <br>&gt; The RemObjects Silver Swift-alike compiler, which targets the JVM and CLR, is forced to treat its collections as reference types because of how COW is implemented: http://docs.elementscompiler.com/Silver/DifferencesAndLimitations/ &lt;http://docs.elementscompiler.com/Silver/DifferencesAndLimitations/&gt;.<br>&gt; <br>&gt; The most pertinent questions with regards to Swift GC are: whether or not some acceptably efficient form of efficient copy-on-write mechanism for value type collections in a tracing GC environment exists, and if not whether the enormous semantic change that turning collections into reference types would entail would be worthwhile. (This in turn would have a whole set of knock-on effects; for example, generic stdlib collections could no longer be properly covariant.)<br></p><p>It&#39;s within the realm of possibility to have a hybrid approach, where value type buffers have reference counts maintained by compiler-inserted retain/release operations when semantic copies occur in an otherwise GC environment.<br></p><p>-Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160210/a9c00bca/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>What about garbage collection?</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>February 10, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Feb 10, 2016, at 1:08 AM, Craig Cruden via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; - arguments regarding energy efficiency, memory efficiency, or more generally hardware limitations seem to me rather short-sighted, as in “640 KB or RAM should be enough for all times to come” (original design decision by IBM for the PC). Is Swift a language designed for todays hardware? Or is it supposed to outlast it a wee bit?<br>&gt; <br>&gt; For the foreseeable future - energy efficiency is a very real and important factor.  Battery technology (as compared to other technology) is not moving quickly, so being efficient is important.  <br></p><p>Efficiency is always important, and if you haven’t noticed, computers aren’t getting significantly faster anymore.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>What about garbage collection?</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>February 11, 2016 at 08:00:00am</p></header><div class="content"><p>Haven’t noticed…. but then I am still using my Mac Pro 2008 as my primary computer (upgraded with 10GB ram, 2 x 5770 ATI cards, and a boot SSD using one of the internal SATA connections on the motherboard) :p<br></p><p><br>&gt; On 2016-02-11, at 4:42:30, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 10, 2016, at 1:08 AM, Craig Cruden via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - arguments regarding energy efficiency, memory efficiency, or more generally hardware limitations seem to me rather short-sighted, as in “640 KB or RAM should be enough for all times to come” (original design decision by IBM for the PC). Is Swift a language designed for todays hardware? Or is it supposed to outlast it a wee bit?<br>&gt;&gt; <br>&gt;&gt; For the foreseeable future - energy efficiency is a very real and important factor.  Battery technology (as compared to other technology) is not moving quickly, so being efficient is important.  <br>&gt; <br>&gt; Efficiency is always important, and if you haven’t noticed, computers aren’t getting significantly faster anymore.<br>&gt; <br>&gt; -Chris<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4002684831b0a89736f4837d2e60f66a?s=50"></div><header><strong>What about garbage collection?</strong> from <string>Pierre Monod-Broca</string> &lt;pierremonodbroca at gmail.com&gt;<p>February 22, 2016 at 09:00:00am</p></header><div class="content"><p>I also believe efficiency is always important.<br></p><p>Computers tends to get smaller rather than faster. Smartphones, smartwatches, internet of things…<br></p><p>-- <br>Pierre<br></p><p><br></p><p>&gt; Le 10 févr. 2016 à 22:42, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 10, 2016, at 1:08 AM, Craig Cruden via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - arguments regarding energy efficiency, memory efficiency, or more generally hardware limitations seem to me rather short-sighted, as in “640 KB or RAM should be enough for all times to come” (original design decision by IBM for the PC). Is Swift a language designed for todays hardware? Or is it supposed to outlast it a wee bit?<br>&gt;&gt; <br>&gt;&gt; For the foreseeable future - energy efficiency is a very real and important factor.  Battery technology (as compared to other technology) is not moving quickly, so being efficient is important.  <br>&gt; <br>&gt; Efficiency is always important, and if you haven’t noticed, computers aren’t getting significantly faster anymore.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160222/ee15468b/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>What about garbage collection?</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>February 10, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Feb 10, 2016, at 00:57, Jean-Denis Muys via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Based on this as the summary of arguments I read so far on this thread, I tend to increase my +1. Here is what I read:<br>&gt; <br>&gt; - arguments regarding energy efficiency, memory efficiency, or more generally hardware limitations seem to me rather short-sighted, as in “640 KB or RAM should be enough for all times to come” (original design decision by IBM for the PC). Is Swift a language designed for todays hardware? Or is it supposed to outlast it a wee bit?<br>&gt; <br>Planning for the future is a Good Thing, but if Swift isn’t useful today, it won’t last long enough for “the future” to get here. There are limitations in the current hardware (VM thrashing the NAND in iDevices, IIRC) that preclude other options.<br></p><p><br>&gt; Of course some ideal would be a language where GC is an option. I am not sure whether that is possible, though the one argument I saw against that, namely that libraries would be compatible with one of the options only, can be solved with the fat binary idea. We used to have libraries compatible with both PowerPC and Intel processors. That sounds a lot more complex.<br></p><p>We did it once before… Obj-C switched from manual memory management to ARC back in Xcode 4.2. Personally, I’d *much* rather stick with ARC for now, and worry about switching to some other scheme a few years down the road when supporting devices with write limitations starts becoming less of an issue.<br></p><p>- Dave Sweeris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160210/47e30717/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>What about garbage collection?</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>February  8, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Feb 8, 2016, at 11:56 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Has there been a garbage collection thread so far? I understand that reference counting vs. garbage collection can be a heated debate, but it might be relevant to have it.<br>&gt; <br>&gt; It seems to me that the two principal upsides of reference counting are that destruction is (essentially) deterministic and performance is more easily predicted. However, it comes with many downsides:<br>&gt; <br>&gt; object references are expensive to update<br>&gt; object references cannot be atomically updated<br>&gt; heap fragmentation<br>&gt; the closure capture syntax uses up an unreasonable amount of mindshare just because of [weak self]<br>&gt; <br>&gt; Since Swift doesn&#39;t expose memory management operations outside of `autoreleasepool`, it seems to me that you could just drop in a garbage collector instead of reference counting and it would work (for most purposes).<br>&gt; <br>&gt; Has a GC been considered at all?<br></p><p>We very deliberately chose an ARC model for Swift. It is *way* out of scope for Swift 3; I don’t think it’s worth discussing this on swift-evolution at all.<br></p><p>	- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160208/32ebb025/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c65faa002b79348ac10e1fb9c1a9ad83?s=50"></div><header><strong>What about garbage collection?</strong> from <string>Colin Cornaby</string> &lt;colin.cornaby at mac.com&gt;<p>February  8, 2016 at 10:00:00pm</p></header><div class="content"><p>I thought I’d add my opinion to this thread even though it’s been well covered in different posts, just to put more weight on the -1 argument…<br></p><p>I spend most my time dealing with performance sensitive code, and Swift’s predictability is a very strong pro for it against languages like Java. Java’s garbage collector provides too much uncertainty and instability to performance.<br></p><p>There certainly are tradeoffs. ARC won’t catch things like circular retain loops. But as mentioned, tagged pointers on the modern architecture take care of the retain/release overhead.<br></p><p>I’ll put it a different way that sums up why I felt the need to reply: ARC has it’s inconveniences, but moving to garbage collection would likely lead us to abandon any plans to adopt Swift for many of our performance sensitive projects. If someone solves the “pausing” problem in a garbage collected language I’d reconsider. But until then it would take Swift out of consideration for a lot of projects.<br></p><p>&gt; On Feb 8, 2016, at 11:56 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Has there been a garbage collection thread so far? I understand that reference counting vs. garbage collection can be a heated debate, but it might be relevant to have it.<br>&gt; <br>&gt; It seems to me that the two principal upsides of reference counting are that destruction is (essentially) deterministic and performance is more easily predicted. However, it comes with many downsides:<br>&gt; <br>&gt; object references are expensive to update<br>&gt; object references cannot be atomically updated<br>&gt; heap fragmentation<br>&gt; the closure capture syntax uses up an unreasonable amount of mindshare just because of [weak self]<br>&gt; <br>&gt; Since Swift doesn&#39;t expose memory management operations outside of `autoreleasepool`, it seems to me that you could just drop in a garbage collector instead of reference counting and it would work (for most purposes).<br>&gt; <br>&gt; Has a GC been considered at all?<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160208/e0bed7a1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>What about garbage collection?</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>February  9, 2016 at 11:00:00am</p></header><div class="content"><p>Just to add my thoughts, but I definitely don’t want garbage collection back; firstly because when Apple announced ARC for Objective-C, I couldn’t believe we hadn’t been using it all along, as it just seemed like such an obvious solution that makes garbage collection largely obsolete.<br></p><p>But more importantly, any time spent on supporting garbage collection is time that could be spent on making ARC even better, and really the only area where there is trouble right now is detecting cycles, but that’s a problem that should be solved by making the debugging and profiling tools as good as possible so that issues can be found and corrected with the right combination of weak references etc.<br></p><p>So a -1 from me. While some of the disadvantages might be valid, I think on the whole ARC is a better mechanism overall, and there may be other ways to address any of the issues it may have, which will be harder to do if the team has to dedicate time to a garbage collector.<br></p><p>&gt; On 9 Feb 2016, at 06:01, Colin Cornaby via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I thought I’d add my opinion to this thread even though it’s been well covered in different posts, just to put more weight on the -1 argument…<br>&gt; <br>&gt; I spend most my time dealing with performance sensitive code, and Swift’s predictability is a very strong pro for it against languages like Java. Java’s garbage collector provides too much uncertainty and instability to performance.<br>&gt; <br>&gt; There certainly are tradeoffs. ARC won’t catch things like circular retain loops. But as mentioned, tagged pointers on the modern architecture take care of the retain/release overhead.<br>&gt; <br>&gt; I’ll put it a different way that sums up why I felt the need to reply: ARC has it’s inconveniences, but moving to garbage collection would likely lead us to abandon any plans to adopt Swift for many of our performance sensitive projects. If someone solves the “pausing” problem in a garbage collected language I’d reconsider. But until then it would take Swift out of consideration for a lot of projects.<br>&gt; <br>&gt;&gt; On Feb 8, 2016, at 11:56 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Has there been a garbage collection thread so far? I understand that reference counting vs. garbage collection can be a heated debate, but it might be relevant to have it.<br>&gt;&gt; <br>&gt;&gt; It seems to me that the two principal upsides of reference counting are that destruction is (essentially) deterministic and performance is more easily predicted. However, it comes with many downsides:<br>&gt;&gt; <br>&gt;&gt; object references are expensive to update<br>&gt;&gt; object references cannot be atomically updated<br>&gt;&gt; heap fragmentation<br>&gt;&gt; the closure capture syntax uses up an unreasonable amount of mindshare just because of [weak self]<br>&gt;&gt; <br>&gt;&gt; Since Swift doesn&#39;t expose memory management operations outside of `autoreleasepool`, it seems to me that you could just drop in a garbage collector instead of reference counting and it would work (for most purposes).<br>&gt;&gt; <br>&gt;&gt; Has a GC been considered at all?<br>&gt;&gt; <br>&gt;&gt; Félix<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160209/53918278/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/46439321e8b5b5ba0944eef50e18c3a3?s=50"></div><header><strong>What about garbage collection?</strong> from <string>Jean-Denis Muys</string> &lt;jdmuys at gmail.com&gt;<p>February  9, 2016 at 03:00:00pm</p></header><div class="content"><p>My understanding (from what I’ve seen in the literature, but I am in no way an expert) is that RC has worse worse case behaviour than GC regarding pauses.<br></p><p>Also arguments regarding RAM use (and perhaps even battery use), as all hardware resource-based arguments, have always been proven wrong in the past as hardware has evolved to more and better.<br></p><p>The usual argument is RAM is cheap, programmer’s time, especially debugging time, is expensive.<br></p><p>I find it interesting that the commonly accepted wisdom is that GC is the right thing to do. To quote but one blog post I’ve read:<br></p><p>&gt; It’s a long since resolved dispute, and GC won. I don’t want Steve Jobs to reach out from the grave and drag us back to the 70s. There’s nothing special about mobile phones: they are more powerful than the computers that GC won on in the first place.<br></p><p><br>So I’d be interested in understanding why we are about alone on our Apple island with our opinion that RC is better than GC? Are they all collectively wrong in the rest of the universe? (not that I condone argument from majority)<br></p><p>I can only state that my experience with GC has been with mostly with Macintosh Common Lisp a rather long time ago, and I did really love it.<br></p><p>So for me, GC would be a +1, but not a very strong one, as I find RC adequate.<br></p><p>Jean-Denis<br></p><p><br></p><p>&gt; On 09 Feb 2016, at 07:01, Colin Cornaby via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I thought I’d add my opinion to this thread even though it’s been well covered in different posts, just to put more weight on the -1 argument…<br>&gt; <br>&gt; I spend most my time dealing with performance sensitive code, and Swift’s predictability is a very strong pro for it against languages like Java. Java’s garbage collector provides too much uncertainty and instability to performance.<br>&gt; <br>&gt; There certainly are tradeoffs. ARC won’t catch things like circular retain loops. But as mentioned, tagged pointers on the modern architecture take care of the retain/release overhead.<br>&gt; <br>&gt; I’ll put it a different way that sums up why I felt the need to reply: ARC has it’s inconveniences, but moving to garbage collection would likely lead us to abandon any plans to adopt Swift for many of our performance sensitive projects. If someone solves the “pausing” problem in a garbage collected language I’d reconsider. But until then it would take Swift out of consideration for a lot of projects.<br>&gt; <br>&gt;&gt; On Feb 8, 2016, at 11:56 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Has there been a garbage collection thread so far? I understand that reference counting vs. garbage collection can be a heated debate, but it might be relevant to have it.<br>&gt;&gt; <br>&gt;&gt; It seems to me that the two principal upsides of reference counting are that destruction is (essentially) deterministic and performance is more easily predicted. However, it comes with many downsides:<br>&gt;&gt; <br>&gt;&gt; object references are expensive to update<br>&gt;&gt; object references cannot be atomically updated<br>&gt;&gt; heap fragmentation<br>&gt;&gt; the closure capture syntax uses up an unreasonable amount of mindshare just because of [weak self]<br>&gt;&gt; <br>&gt;&gt; Since Swift doesn&#39;t expose memory management operations outside of `autoreleasepool`, it seems to me that you could just drop in a garbage collector instead of reference counting and it would work (for most purposes).<br>&gt;&gt; <br>&gt;&gt; Has a GC been considered at all?<br>&gt;&gt; <br>&gt;&gt; Félix<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160209/34fc540c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/aeab22e60ba7b7e2bd445775850448d1?s=50"></div><header><strong>What about garbage collection?</strong> from <string>Radosław Pietruszewski</string> &lt;radexpl at gmail.com&gt;<p>February  9, 2016 at 03:00:00pm</p></header><div class="content"><p>An***id lagged behind iOS for years in smoothness and responsiveness at comparable hardware — my understanding is that this is largely because of GC pauses.<br></p><p>I love GC. I’d love GC in Swift, too. But it really is a real performance problem in _interactive_ applications (much less of an issue for server side stuff), on memory-constrained devices.<br></p><p>— Radek<br></p><p>&gt; On 09 Feb 2016, at 15:35, Jean-Denis Muys via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; My understanding (from what I’ve seen in the literature, but I am in no way an expert) is that RC has worse worse case behaviour than GC regarding pauses.<br>&gt; <br>&gt; Also arguments regarding RAM use (and perhaps even battery use), as all hardware resource-based arguments, have always been proven wrong in the past as hardware has evolved to more and better.<br>&gt; <br>&gt; The usual argument is RAM is cheap, programmer’s time, especially debugging time, is expensive.<br>&gt; <br>&gt; I find it interesting that the commonly accepted wisdom is that GC is the right thing to do. To quote but one blog post I’ve read:<br>&gt; <br>&gt;&gt; It’s a long since resolved dispute, and GC won. I don’t want Steve Jobs to reach out from the grave and drag us back to the 70s. There’s nothing special about mobile phones: they are more powerful than the computers that GC won on in the first place.<br>&gt; <br>&gt; <br>&gt; So I’d be interested in understanding why we are about alone on our Apple island with our opinion that RC is better than GC? Are they all collectively wrong in the rest of the universe? (not that I condone argument from majority)<br>&gt; <br>&gt; I can only state that my experience with GC has been with mostly with Macintosh Common Lisp a rather long time ago, and I did really love it.<br>&gt; <br>&gt; So for me, GC would be a +1, but not a very strong one, as I find RC adequate.<br>&gt; <br>&gt; Jean-Denis<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On 09 Feb 2016, at 07:01, Colin Cornaby via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I thought I’d add my opinion to this thread even though it’s been well covered in different posts, just to put more weight on the -1 argument…<br>&gt;&gt; <br>&gt;&gt; I spend most my time dealing with performance sensitive code, and Swift’s predictability is a very strong pro for it against languages like Java. Java’s garbage collector provides too much uncertainty and instability to performance.<br>&gt;&gt; <br>&gt;&gt; There certainly are tradeoffs. ARC won’t catch things like circular retain loops. But as mentioned, tagged pointers on the modern architecture take care of the retain/release overhead.<br>&gt;&gt; <br>&gt;&gt; I’ll put it a different way that sums up why I felt the need to reply: ARC has it’s inconveniences, but moving to garbage collection would likely lead us to abandon any plans to adopt Swift for many of our performance sensitive projects. If someone solves the “pausing” problem in a garbage collected language I’d reconsider. But until then it would take Swift out of consideration for a lot of projects.<br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 8, 2016, at 11:56 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Has there been a garbage collection thread so far? I understand that reference counting vs. garbage collection can be a heated debate, but it might be relevant to have it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It seems to me that the two principal upsides of reference counting are that destruction is (essentially) deterministic and performance is more easily predicted. However, it comes with many downsides:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; object references are expensive to update<br>&gt;&gt;&gt; object references cannot be atomically updated<br>&gt;&gt;&gt; heap fragmentation<br>&gt;&gt;&gt; the closure capture syntax uses up an unreasonable amount of mindshare just because of [weak self]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Since Swift doesn&#39;t expose memory management operations outside of `autoreleasepool`, it seems to me that you could just drop in a garbage collector instead of reference counting and it would work (for most purposes).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Has a GC been considered at all?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Félix<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160209/9c39fa22/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6c95cd06f79f91eaf9f58e4f1c50a25a?s=50"></div><header><strong>What about garbage collection?</strong> from <string>Ondrej Barina</string> &lt;obarina at gmail.com&gt;<p>February  9, 2016 at 04:00:00pm</p></header><div class="content"><p>-1<br>GC does not have performance problems on server side??<br>Please tell that to my colleges who are spending 50% of their time<br>analysing and tweaking GC in java after every release of new versions.<br>It becoming such a pain sometimes, that we are discussing re-writing<br>some servers from Java to C++ (just to avoid GC issues)<br>Ondrej B.<br></p><p>On Tue, Feb 9, 2016 at 3:40 PM, Radosław Pietruszewski<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; An***id lagged behind iOS for years in smoothness and responsiveness at<br>&gt; comparable hardware — my understanding is that this is largely because of GC<br>&gt; pauses.<br>&gt;<br>&gt; I love GC. I’d love GC in Swift, too. But it really is a real performance<br>&gt; problem in _interactive_ applications (much less of an issue for server side<br>&gt; stuff), on memory-constrained devices.<br>&gt;<br>&gt; — Radek<br>&gt;<br>&gt; On 09 Feb 2016, at 15:35, Jean-Denis Muys via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; My understanding (from what I’ve seen in the literature, but I am in no way<br>&gt; an expert) is that RC has worse worse case behaviour than GC regarding<br>&gt; pauses.<br>&gt;<br>&gt; Also arguments regarding RAM use (and perhaps even battery use), as all<br>&gt; hardware resource-based arguments, have always been proven wrong in the past<br>&gt; as hardware has evolved to more and better.<br>&gt;<br>&gt; The usual argument is RAM is cheap, programmer’s time, especially debugging<br>&gt; time, is expensive.<br>&gt;<br>&gt; I find it interesting that the commonly accepted wisdom is that GC is the<br>&gt; right thing to do. To quote but one blog post I’ve read:<br>&gt;<br>&gt; It’s a long since resolved dispute, and GC won. I don’t want Steve Jobs to<br>&gt; reach out from the grave and drag us back to the 70s. There’s nothing<br>&gt; special about mobile phones: they are more powerful than the computers that<br>&gt; GC won on in the first place.<br>&gt;<br>&gt;<br>&gt; So I’d be interested in understanding why we are about alone on our Apple<br>&gt; island with our opinion that RC is better than GC? Are they all collectively<br>&gt; wrong in the rest of the universe? (not that I condone argument from<br>&gt; majority)<br>&gt;<br>&gt; I can only state that my experience with GC has been with mostly with<br>&gt; Macintosh Common Lisp a rather long time ago, and I did really love it.<br>&gt;<br>&gt; So for me, GC would be a +1, but not a very strong one, as I find RC<br>&gt; adequate.<br>&gt;<br>&gt; Jean-Denis<br>&gt;<br>&gt;<br>&gt;<br>&gt; On 09 Feb 2016, at 07:01, Colin Cornaby via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I thought I’d add my opinion to this thread even though it’s been well<br>&gt; covered in different posts, just to put more weight on the -1 argument…<br>&gt;<br>&gt; I spend most my time dealing with performance sensitive code, and Swift’s<br>&gt; predictability is a very strong pro for it against languages like Java.<br>&gt; Java’s garbage collector provides too much uncertainty and instability to<br>&gt; performance.<br>&gt;<br>&gt; There certainly are tradeoffs. ARC won’t catch things like circular retain<br>&gt; loops. But as mentioned, tagged pointers on the modern architecture take<br>&gt; care of the retain/release overhead.<br>&gt;<br>&gt; I’ll put it a different way that sums up why I felt the need to reply: ARC<br>&gt; has it’s inconveniences, but moving to garbage collection would likely lead<br>&gt; us to abandon any plans to adopt Swift for many of our performance sensitive<br>&gt; projects. If someone solves the “pausing” problem in a garbage collected<br>&gt; language I’d reconsider. But until then it would take Swift out of<br>&gt; consideration for a lot of projects.<br>&gt;<br>&gt; On Feb 8, 2016, at 11:56 AM, Félix Cloutier via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Has there been a garbage collection thread so far? I understand that<br>&gt; reference counting vs. garbage collection can be a heated debate, but it<br>&gt; might be relevant to have it.<br>&gt;<br>&gt; It seems to me that the two principal upsides of reference counting are that<br>&gt; destruction is (essentially) deterministic and performance is more easily<br>&gt; predicted. However, it comes with many downsides:<br>&gt;<br>&gt; object references are expensive to update<br>&gt; object references cannot be atomically updated<br>&gt; heap fragmentation<br>&gt; the closure capture syntax uses up an unreasonable amount of mindshare just<br>&gt; because of [weak self]<br>&gt;<br>&gt;<br>&gt; Since Swift doesn&#39;t expose memory management operations outside of<br>&gt; `autoreleasepool`, it seems to me that you could just drop in a garbage<br>&gt; collector instead of reference counting and it would work (for most<br>&gt; purposes).<br>&gt;<br>&gt; Has a GC been considered at all?<br>&gt;<br>&gt; Félix<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/aeab22e60ba7b7e2bd445775850448d1?s=50"></div><header><strong>What about garbage collection?</strong> from <string>Radosław Pietruszewski</string> &lt;radexpl at gmail.com&gt;<p>February  9, 2016 at 05:00:00pm</p></header><div class="content"><p>I sympathize. I said less of an issue. Still a problem for large applications, but when done correctly, a GC pause won’t occur in the middle of a request being processed, so the user won’t suffer from this directly.<br></p><p>Swift’s primary application are interactive apps, where we ideally want 60fps all the time. So there’s only milliseconds for any garbage collection randomly happening.<br></p><p>— Radek<br></p><p>&gt; On 09 Feb 2016, at 16:32, Ondrej Barina &lt;obarina at gmail.com&gt; wrote:<br>&gt; <br>&gt; -1<br>&gt; GC does not have performance problems on server side??<br>&gt; Please tell that to my colleges who are spending 50% of their time<br>&gt; analysing and tweaking GC in java after every release of new versions.<br>&gt; It becoming such a pain sometimes, that we are discussing re-writing<br>&gt; some servers from Java to C++ (just to avoid GC issues)<br>&gt; Ondrej B.<br>&gt; <br>&gt; On Tue, Feb 9, 2016 at 3:40 PM, Radosław Pietruszewski<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; An***id lagged behind iOS for years in smoothness and responsiveness at<br>&gt;&gt; comparable hardware — my understanding is that this is largely because of GC<br>&gt;&gt; pauses.<br>&gt;&gt; <br>&gt;&gt; I love GC. I’d love GC in Swift, too. But it really is a real performance<br>&gt;&gt; problem in _interactive_ applications (much less of an issue for server side<br>&gt;&gt; stuff), on memory-constrained devices.<br>&gt;&gt; <br>&gt;&gt; — Radek<br>&gt;&gt; <br>&gt;&gt; On 09 Feb 2016, at 15:35, Jean-Denis Muys via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; My understanding (from what I’ve seen in the literature, but I am in no way<br>&gt;&gt; an expert) is that RC has worse worse case behaviour than GC regarding<br>&gt;&gt; pauses.<br>&gt;&gt; <br>&gt;&gt; Also arguments regarding RAM use (and perhaps even battery use), as all<br>&gt;&gt; hardware resource-based arguments, have always been proven wrong in the past<br>&gt;&gt; as hardware has evolved to more and better.<br>&gt;&gt; <br>&gt;&gt; The usual argument is RAM is cheap, programmer’s time, especially debugging<br>&gt;&gt; time, is expensive.<br>&gt;&gt; <br>&gt;&gt; I find it interesting that the commonly accepted wisdom is that GC is the<br>&gt;&gt; right thing to do. To quote but one blog post I’ve read:<br>&gt;&gt; <br>&gt;&gt; It’s a long since resolved dispute, and GC won. I don’t want Steve Jobs to<br>&gt;&gt; reach out from the grave and drag us back to the 70s. There’s nothing<br>&gt;&gt; special about mobile phones: they are more powerful than the computers that<br>&gt;&gt; GC won on in the first place.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; So I’d be interested in understanding why we are about alone on our Apple<br>&gt;&gt; island with our opinion that RC is better than GC? Are they all collectively<br>&gt;&gt; wrong in the rest of the universe? (not that I condone argument from<br>&gt;&gt; majority)<br>&gt;&gt; <br>&gt;&gt; I can only state that my experience with GC has been with mostly with<br>&gt;&gt; Macintosh Common Lisp a rather long time ago, and I did really love it.<br>&gt;&gt; <br>&gt;&gt; So for me, GC would be a +1, but not a very strong one, as I find RC<br>&gt;&gt; adequate.<br>&gt;&gt; <br>&gt;&gt; Jean-Denis<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On 09 Feb 2016, at 07:01, Colin Cornaby via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I thought I’d add my opinion to this thread even though it’s been well<br>&gt;&gt; covered in different posts, just to put more weight on the -1 argument…<br>&gt;&gt; <br>&gt;&gt; I spend most my time dealing with performance sensitive code, and Swift’s<br>&gt;&gt; predictability is a very strong pro for it against languages like Java.<br>&gt;&gt; Java’s garbage collector provides too much uncertainty and instability to<br>&gt;&gt; performance.<br>&gt;&gt; <br>&gt;&gt; There certainly are tradeoffs. ARC won’t catch things like circular retain<br>&gt;&gt; loops. But as mentioned, tagged pointers on the modern architecture take<br>&gt;&gt; care of the retain/release overhead.<br>&gt;&gt; <br>&gt;&gt; I’ll put it a different way that sums up why I felt the need to reply: ARC<br>&gt;&gt; has it’s inconveniences, but moving to garbage collection would likely lead<br>&gt;&gt; us to abandon any plans to adopt Swift for many of our performance sensitive<br>&gt;&gt; projects. If someone solves the “pausing” problem in a garbage collected<br>&gt;&gt; language I’d reconsider. But until then it would take Swift out of<br>&gt;&gt; consideration for a lot of projects.<br>&gt;&gt; <br>&gt;&gt; On Feb 8, 2016, at 11:56 AM, Félix Cloutier via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Has there been a garbage collection thread so far? I understand that<br>&gt;&gt; reference counting vs. garbage collection can be a heated debate, but it<br>&gt;&gt; might be relevant to have it.<br>&gt;&gt; <br>&gt;&gt; It seems to me that the two principal upsides of reference counting are that<br>&gt;&gt; destruction is (essentially) deterministic and performance is more easily<br>&gt;&gt; predicted. However, it comes with many downsides:<br>&gt;&gt; <br>&gt;&gt; object references are expensive to update<br>&gt;&gt; object references cannot be atomically updated<br>&gt;&gt; heap fragmentation<br>&gt;&gt; the closure capture syntax uses up an unreasonable amount of mindshare just<br>&gt;&gt; because of [weak self]<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Since Swift doesn&#39;t expose memory management operations outside of<br>&gt;&gt; `autoreleasepool`, it seems to me that you could just drop in a garbage<br>&gt;&gt; collector instead of reference counting and it would work (for most<br>&gt;&gt; purposes).<br>&gt;&gt; <br>&gt;&gt; Has a GC been considered at all?<br>&gt;&gt; <br>&gt;&gt; Félix<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c65faa002b79348ac10e1fb9c1a9ad83?s=50"></div><header><strong>What about garbage collection?</strong> from <string>Colin Cornaby</string> &lt;colin.cornaby at mac.com&gt;<p>February 10, 2016 at 05:00:00pm</p></header><div class="content"><p>There’s a lot of talk in this thread about the user not noticing as part of UI feedback.<br></p><p>I work on real time audio and video processing, which is much more sensitive than UI. You do notice those bumps in garbage collection. Adding GC in would make Swift unsuitable for those applications. The user won’t notice, but these algorithms will. It’s why a lot of Android developers doing the same type of work are writing in C or C++ and not Java. I don’t think Google even supports the concept of real time audio processing on the Java layer.<br></p><p>I saw someone else mention audio processing as well, but user noticable shouldn’t be the metric here. Swift is a very serious contender to succeed C++ for this sort of work (where even Obj-C’s performance can be iffy), and I really don’t want to lose that. Not that I think this will probably move forward.<br></p><p>&gt; On Feb 9, 2016, at 8:35 AM, Radosław Pietruszewski via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I sympathize. I said less of an issue. Still a problem for large applications, but when done correctly, a GC pause won’t occur in the middle of a request being processed, so the user won’t suffer from this directly.<br>&gt; <br>&gt; Swift’s primary application are interactive apps, where we ideally want 60fps all the time. So there’s only milliseconds for any garbage collection randomly happening.<br>&gt; <br>&gt; — Radek<br>&gt; <br>&gt;&gt; On 09 Feb 2016, at 16:32, Ondrej Barina &lt;obarina at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; -1<br>&gt;&gt; GC does not have performance problems on server side??<br>&gt;&gt; Please tell that to my colleges who are spending 50% of their time<br>&gt;&gt; analysing and tweaking GC in java after every release of new versions.<br>&gt;&gt; It becoming such a pain sometimes, that we are discussing re-writing<br>&gt;&gt; some servers from Java to C++ (just to avoid GC issues)<br>&gt;&gt; Ondrej B.<br>&gt;&gt; <br>&gt;&gt; On Tue, Feb 9, 2016 at 3:40 PM, Radosław Pietruszewski<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; An***id lagged behind iOS for years in smoothness and responsiveness at<br>&gt;&gt;&gt; comparable hardware — my understanding is that this is largely because of GC<br>&gt;&gt;&gt; pauses.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I love GC. I’d love GC in Swift, too. But it really is a real performance<br>&gt;&gt;&gt; problem in _interactive_ applications (much less of an issue for server side<br>&gt;&gt;&gt; stuff), on memory-constrained devices.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; — Radek<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 09 Feb 2016, at 15:35, Jean-Denis Muys via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My understanding (from what I’ve seen in the literature, but I am in no way<br>&gt;&gt;&gt; an expert) is that RC has worse worse case behaviour than GC regarding<br>&gt;&gt;&gt; pauses.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Also arguments regarding RAM use (and perhaps even battery use), as all<br>&gt;&gt;&gt; hardware resource-based arguments, have always been proven wrong in the past<br>&gt;&gt;&gt; as hardware has evolved to more and better.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The usual argument is RAM is cheap, programmer’s time, especially debugging<br>&gt;&gt;&gt; time, is expensive.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I find it interesting that the commonly accepted wisdom is that GC is the<br>&gt;&gt;&gt; right thing to do. To quote but one blog post I’ve read:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It’s a long since resolved dispute, and GC won. I don’t want Steve Jobs to<br>&gt;&gt;&gt; reach out from the grave and drag us back to the 70s. There’s nothing<br>&gt;&gt;&gt; special about mobile phones: they are more powerful than the computers that<br>&gt;&gt;&gt; GC won on in the first place.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So I’d be interested in understanding why we are about alone on our Apple<br>&gt;&gt;&gt; island with our opinion that RC is better than GC? Are they all collectively<br>&gt;&gt;&gt; wrong in the rest of the universe? (not that I condone argument from<br>&gt;&gt;&gt; majority)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I can only state that my experience with GC has been with mostly with<br>&gt;&gt;&gt; Macintosh Common Lisp a rather long time ago, and I did really love it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So for me, GC would be a +1, but not a very strong one, as I find RC<br>&gt;&gt;&gt; adequate.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Jean-Denis<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 09 Feb 2016, at 07:01, Colin Cornaby via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I thought I’d add my opinion to this thread even though it’s been well<br>&gt;&gt;&gt; covered in different posts, just to put more weight on the -1 argument…<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I spend most my time dealing with performance sensitive code, and Swift’s<br>&gt;&gt;&gt; predictability is a very strong pro for it against languages like Java.<br>&gt;&gt;&gt; Java’s garbage collector provides too much uncertainty and instability to<br>&gt;&gt;&gt; performance.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There certainly are tradeoffs. ARC won’t catch things like circular retain<br>&gt;&gt;&gt; loops. But as mentioned, tagged pointers on the modern architecture take<br>&gt;&gt;&gt; care of the retain/release overhead.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’ll put it a different way that sums up why I felt the need to reply: ARC<br>&gt;&gt;&gt; has it’s inconveniences, but moving to garbage collection would likely lead<br>&gt;&gt;&gt; us to abandon any plans to adopt Swift for many of our performance sensitive<br>&gt;&gt;&gt; projects. If someone solves the “pausing” problem in a garbage collected<br>&gt;&gt;&gt; language I’d reconsider. But until then it would take Swift out of<br>&gt;&gt;&gt; consideration for a lot of projects.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Feb 8, 2016, at 11:56 AM, Félix Cloutier via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Has there been a garbage collection thread so far? I understand that<br>&gt;&gt;&gt; reference counting vs. garbage collection can be a heated debate, but it<br>&gt;&gt;&gt; might be relevant to have it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It seems to me that the two principal upsides of reference counting are that<br>&gt;&gt;&gt; destruction is (essentially) deterministic and performance is more easily<br>&gt;&gt;&gt; predicted. However, it comes with many downsides:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; object references are expensive to update<br>&gt;&gt;&gt; object references cannot be atomically updated<br>&gt;&gt;&gt; heap fragmentation<br>&gt;&gt;&gt; the closure capture syntax uses up an unreasonable amount of mindshare just<br>&gt;&gt;&gt; because of [weak self]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Since Swift doesn&#39;t expose memory management operations outside of<br>&gt;&gt;&gt; `autoreleasepool`, it seems to me that you could just drop in a garbage<br>&gt;&gt;&gt; collector instead of reference counting and it would work (for most<br>&gt;&gt;&gt; purposes).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Has a GC been considered at all?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Félix<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>What about garbage collection?</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>February  9, 2016 at 11:00:00am</p></header><div class="content"><p>Since GC is getting a lot of hate on this thread, I’ll throw it a little love — though ultimately I agree that it’s probably not right for Swift.<br></p><p>There’s no denying that GC eases programmer burden. Having to explicitly break every cycle takes effort, and sometimes undermines abstraction. There’s a tradeoff here: more deterministic / consistent performance in exchange for developer time. ARC keeps that effort pretty low, but it’s nonzero.<br></p><p>As Jean-Denis noted:<br></p><p>&gt; On Feb 9, 2016, at 8:35 AM, Jean-Denis Muys via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I find it interesting that the commonly accepted wisdom is that GC is the right thing to do. To quote but one blog post I’ve read:<br>&gt; <br>&gt;&gt; It’s a long since resolved dispute, and GC won. I don’t want Steve Jobs to reach out from the grave and drag us back to the 70s. There’s nothing special about mobile phones: they are more powerful than the computers that GC won on in the first place.<br></p><p>…GC has indeed pretty much won on the server side. That makes sense, because — at least as I understand it — the downsides of GC are much less severe there:<br></p><p>Quadrupling physical RAM is far less of a concern on a server than it is on a mobile device.<br>Most servers (1) are not CPU bound and (2) experience bursty load, and thus can absorb GC expense while blocking on I/O and/or in the quite microseconds between requests.<br>When servers do become CPU or RAM bound, one can always add more nodes — and for most companies, that’s cheaper than paying for more developer effort.<br>Servers tend to have a pool of long-lived, relatively static allocations, plus a rapid stream of short-lived allocations that last only as long as single requests. This duality maps neatly to generational garbage collection.<br>Furthermore, a server wants to get a response out the door as fast as possible when a request comes in, and it thus makes sense to defer ref counting and deallocation costs for those short-lived allocations — exactly as GC does — until after the response goes out, even if that comes at the cost of RAM and greater total CPU usage.<br>This high turnover also mitigates (though does not eliminate) the problem of cache thrash. The objects in the short-term pool tied to request lifecycle that GC needs to traverse frequently aren’t going to live long anyway, so there’s less value in keeping them cached.<br></p><p>Yes, maybe our data centers would be greener if we all ditched GC entirely, but the bottom line is that right now, the developer productivity advantages of GC clearly outweigh the costs … on the server. As long as our time remains expensive and servers and electricity remain cheap, this will remain true.<br></p><p>That whole equation changes on mobile devices.<br></p><p>Jean-Denis mentioned “our Apple island” where GC is frowned upon. It’s not just Apple. That island has other inhabitants: video game developers. That’s illuminating, and in ways that extend beyond memory management. One of the original brilliances of the iPhone was that it realized mobile apps have more in common with video games than with the enterprisey fill-in-the-text-field apps that are the home base of most UI stacks. This insight pervades the platform, and is a lot of what makes the iOS devices feel as polished as they do.<br></p><p>GC is probably not right for iOS devices, or for Swift. Swift made a mindful tradeoff here, and it was probably the right tradeoff. However, we should remember that there was a tradeoff, and keep an eye on what we gave up.<br></p><p>• • •<br></p><p>That said, I was a little surprised to hear Chris Lattner rule out any form of cycle detection for Swift. I figured that it might eventually arrive in some form, albeit limited.<br></p><p>No time for it at the moment, but I have some thoughts about places where the lack of GC gets in the way of clean code and good abstraction. Closure captures are one such pain point.<br></p><p>It would be nice examine those problems and tackle them in the Swift spirit of “look like high level, compiles like low level” abstractions.<br></p><p>• • •<br></p><p>&gt; On Feb 9, 2016, at 9:32 AM, Ondrej Barina via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; GC does not have performance problems on server side??<br>&gt; Please tell that to my colleges who are spending 50% of their time<br>&gt; analysing and tweaking GC in java after every release of new versions.<br></p><p>Radek did not say “does not have performance problems.” His words were:<br></p><p>&gt;&gt; much less of an issue for server side stuff<br></p><p>…and he was correct. Ondrej, it sounds like you’re in one of the rare situation where CPU and RAM really are the bottlenecks in the server farm. That’s not typical in my experience.<br></p><p>Cheers,<br></p><p>Paul<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160209/a5ffbdea/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>What about garbage collection?</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>February 10, 2016 at 12:00:00am</p></header><div class="content"><p>For the server side it depends on scale.  <br></p><p>When you talk about large scale deployments like Facebook and Google - the cost savings from an energy efficient datacenter is actually quite substantial (50%).  [and of course the savings on racks and racks of hardware]<br></p><p>Of course it usually does not become an issue or to the forefront UNTIL they become hugely successful and then it is a little late in the cycle.<br></p><p>Being able to say your green - priceless.  <br></p><p>For a banking / J2EE application - they probably won’t care or worry about it. (especially when you cannot do anything in regards to something that will likely take a majority of the performance requirements - Oracle / DB2).<br></p><p>The thing is that IF performance, energy efficient is not an issue - they would not move to a language closer to the metal and just have it run on a JVM language anyway.<br></p><p>IF performance is an issue or energy efficient then using ARC / Swift is potentially a viable solution.  [of course not if they use Oracle or DB2 databases right now since driver support would be spotty].<br></p><p>There are bigger issues at play though for Swift to be considered a server programming language.  An abend to the system does not affect one user it potentially brings a business to it’s knees…. so language features that mitigate the likelihood of programmer faults causing that situation would be more of an issue.<br></p><p>For server development my preferred development environment would be an LLVM language that provides better support for the functional paradigm/concepts, is very type safe, has proper database driver support for large commercial databases…. but I don’t see any options on the horizon….  The lack of GC would not be a deal breaker.<br></p><p><br>&gt; On 2016-02-10, at 0:04:36, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Since GC is getting a lot of hate on this thread, I’ll throw it a little love — though ultimately I agree that it’s probably not right for Swift.<br>&gt; <br>&gt; There’s no denying that GC eases programmer burden. Having to explicitly break every cycle takes effort, and sometimes undermines abstraction. There’s a tradeoff here: more deterministic / consistent performance in exchange for developer time. ARC keeps that effort pretty low, but it’s nonzero.<br>&gt; <br>&gt; As Jean-Denis noted:<br>&gt; <br>&gt;&gt; On Feb 9, 2016, at 8:35 AM, Jean-Denis Muys via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I find it interesting that the commonly accepted wisdom is that GC is the right thing to do. To quote but one blog post I’ve read:<br>&gt;&gt; <br>&gt;&gt;&gt; It’s a long since resolved dispute, and GC won. I don’t want Steve Jobs to reach out from the grave and drag us back to the 70s. There’s nothing special about mobile phones: they are more powerful than the computers that GC won on in the first place.<br>&gt; <br>&gt; …GC has indeed pretty much won on the server side. That makes sense, because — at least as I understand it — the downsides of GC are much less severe there:<br>&gt; <br>&gt; Quadrupling physical RAM is far less of a concern on a server than it is on a mobile device.<br>&gt; Most servers (1) are not CPU bound and (2) experience bursty load, and thus can absorb GC expense while blocking on I/O and/or in the quite microseconds between requests.<br>&gt; When servers do become CPU or RAM bound, one can always add more nodes — and for most companies, that’s cheaper than paying for more developer effort.<br>&gt; Servers tend to have a pool of long-lived, relatively static allocations, plus a rapid stream of short-lived allocations that last only as long as single requests. This duality maps neatly to generational garbage collection.<br>&gt; Furthermore, a server wants to get a response out the door as fast as possible when a request comes in, and it thus makes sense to defer ref counting and deallocation costs for those short-lived allocations — exactly as GC does — until after the response goes out, even if that comes at the cost of RAM and greater total CPU usage.<br>&gt; This high turnover also mitigates (though does not eliminate) the problem of cache thrash. The objects in the short-term pool tied to request lifecycle that GC needs to traverse frequently aren’t going to live long anyway, so there’s less value in keeping them cached.<br>&gt; <br>&gt; Yes, maybe our data centers would be greener if we all ditched GC entirely, but the bottom line is that right now, the developer productivity advantages of GC clearly outweigh the costs … on the server. As long as our time remains expensive and servers and electricity remain cheap, this will remain true.<br>&gt; <br>&gt; That whole equation changes on mobile devices.<br>&gt; <br>&gt; Jean-Denis mentioned “our Apple island” where GC is frowned upon. It’s not just Apple. That island has other inhabitants: video game developers. That’s illuminating, and in ways that extend beyond memory management. One of the original brilliances of the iPhone was that it realized mobile apps have more in common with video games than with the enterprisey fill-in-the-text-field apps that are the home base of most UI stacks. This insight pervades the platform, and is a lot of what makes the iOS devices feel as polished as they do.<br>&gt; <br>&gt; GC is probably not right for iOS devices, or for Swift. Swift made a mindful tradeoff here, and it was probably the right tradeoff. However, we should remember that there was a tradeoff, and keep an eye on what we gave up.<br>&gt; <br>&gt; • • •<br>&gt; <br>&gt; That said, I was a little surprised to hear Chris Lattner rule out any form of cycle detection for Swift. I figured that it might eventually arrive in some form, albeit limited.<br>&gt; <br>&gt; No time for it at the moment, but I have some thoughts about places where the lack of GC gets in the way of clean code and good abstraction. Closure captures are one such pain point.<br>&gt; <br>&gt; It would be nice examine those problems and tackle them in the Swift spirit of “look like high level, compiles like low level” abstractions.<br>&gt; <br>&gt; • • •<br>&gt; <br>&gt;&gt; On Feb 9, 2016, at 9:32 AM, Ondrej Barina via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; GC does not have performance problems on server side??<br>&gt;&gt; Please tell that to my colleges who are spending 50% of their time<br>&gt;&gt; analysing and tweaking GC in java after every release of new versions.<br>&gt; <br>&gt; Radek did not say “does not have performance problems.” His words were:<br>&gt; <br>&gt;&gt;&gt; much less of an issue for server side stuff<br>&gt; <br>&gt; …and he was correct. Ondrej, it sounds like you’re in one of the rare situation where CPU and RAM really are the bottlenecks in the server farm. That’s not typical in my experience.<br>&gt; <br>&gt; Cheers,<br>&gt; <br>&gt; Paul<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160210/da2ddcd8/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7321934b88ca8da079d7b89926501a9c?s=50"></div><header><strong>What about garbage collection?</strong> from <string>David Turnbull</string> &lt;dturnbull at gmail.com&gt;<p>February  9, 2016 at 10:00:00am</p></header><div class="content"><p>On Tue, Feb 9, 2016 at 9:04 AM, Paul Cantrell via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; That island has other inhabitants: video game developers.<br>&gt;<br></p><p>Audio systems too. 60fps video has a hard limit of 16.66ms per frame. Real<br>time audio needs 3ms buffers, imo, but can be less strict depending on the<br>application.<br></p><p>I think that Swift can become the first serious alternative to C++ for game<br>development and creative coding. For all platforms, not just Avalon (the<br>Isle of Apples, wokka wokka). If Swift becomes a mark-sweep GC language I&#39;m<br>going to get very angry and abandon my work from the last two months:<br>https://github.com/AE9RB/SwiftGL<br></p><p>-david<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160209/a7c7640a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>What about garbage collection?</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>February  9, 2016 at 08:00:00pm</p></header><div class="content"><p>In addition to memory and performance, the approach &quot;just write it somehow,<br>and the system will optimize it for you so you don&#39;t have to&quot; leads to bad<br>code that is slow and uses too many resources.<br>On Tue, Feb 9, 2016 at 1:30 PM David Turnbull via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Tue, Feb 9, 2016 at 9:04 AM, Paul Cantrell via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; That island has other inhabitants: video game developers.<br>&gt;&gt;<br>&gt;<br>&gt; Audio systems too. 60fps video has a hard limit of 16.66ms per frame. Real<br>&gt; time audio needs 3ms buffers, imo, but can be less strict depending on the<br>&gt; application.<br>&gt;<br>&gt; I think that Swift can become the first serious alternative to C++ for<br>&gt; game development and creative coding. For all platforms, not just Avalon<br>&gt; (the Isle of Apples, wokka wokka). If Swift becomes a mark-sweep GC<br>&gt; language I&#39;m going to get very angry and abandon my work from the last two<br>&gt; months: https://github.com/AE9RB/SwiftGL<br>&gt;<br>&gt; -david<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160209/bde9b02f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>What about garbage collection?</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>February  9, 2016 at 10:00:00pm</p></header><div class="content"><p>I am also agains introducing mark-and-sweep GC to Swift. I don’t see any real advantages to having it in the language and while explicitly building ownership graphs might seem tedious, I think it is a very useful  modelling step that allows one to build better code. <br></p><p>But since we are already talking about this, here are two small thoughts:<br></p><p> 1. I would love to see support for region-based allocation in Swift. To those unfamiliar with the concept: a region is basically a sub-heap from which objects are allocated. The allocation is very fast, because it usually just increments the pointer (a region could be implemented as a linked list of memory pages). All objects in the region are deallocated at once. This can be very useful in a case where you have a lot of small allocations that are guaranteed not to escape a certain scope. Essentially, you can remove the overhead of refcounting (but ARC should take care of that already), but also remove the overhead of deallocating every small object individually. It should be possible to do this in a safe way, e.g. by ensuring that only one reference to a object exists of any time (my type theory is very very rusty, but wasn’t that accomplished by linear types)?<br></p><p>2. For those interested in  mark-and-seep GC, check out the draft of the GC that Mike Pall (author of the incredible LuaJIT tracing compiler) designed: http://wiki.luajit.org/New-Garbage-Collector . I don’t think that GC ever got implemented, but it uses some quite clever tricks to ensure that its incredibly fast. It is also designed around smart use of bit-ops and cache-friendly data structures (e.g. the sweep phases are implemented via streaming  ANDs, ORS and XORS which fully utilise SIMD units). Some very cool stuff. Note: I only link it here because it is interesting, not because I think its a good match for a language like Swift. <br></p><p>Best, <br></p><p> Taras<br></p><p><br></p><p>&gt; On 09 Feb 2016, at 21:24, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; In addition to memory and performance, the approach &quot;just write it somehow, and the system will optimize it for you so you don&#39;t have to&quot; leads to bad code that is slow and uses too many resources.<br>&gt; On Tue, Feb 9, 2016 at 1:30 PM David Turnbull via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; On Tue, Feb 9, 2016 at 9:04 AM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; That island has other inhabitants: video game developers.<br>&gt; <br>&gt; Audio systems too. 60fps video has a hard limit of 16.66ms per frame. Real time audio needs 3ms buffers, imo, but can be less strict depending on the application.<br>&gt; <br>&gt; I think that Swift can become the first serious alternative to C++ for game development and creative coding. For all platforms, not just Avalon (the Isle of Apples, wokka wokka). If Swift becomes a mark-sweep GC language I&#39;m going to get very angry and abandon my work from the last two months: https://github.com/AE9RB/SwiftGL &lt;https://github.com/AE9RB/SwiftGL&gt;<br>&gt; <br>&gt; -david<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160209/a8f006ef/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>What about garbage collection?</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>February  9, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Feb 9, 2016, at 1:28 PM, Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I am also agains introducing mark-and-sweep GC to Swift. I don’t see any real advantages to having it in the language and while explicitly building ownership graphs might seem tedious, I think it is a very useful  modelling step that allows one to build better code. <br>&gt; <br>&gt; But since we are already talking about this, here are two small thoughts:<br>&gt; <br>&gt;  1. I would love to see support for region-based allocation in Swift. To those unfamiliar with the concept: a region is basically a sub-heap from which objects are allocated. The allocation is very fast, because it usually just increments the pointer (a region could be implemented as a linked list of memory pages). All objects in the region are deallocated at once. This can be very useful in a case where you have a lot of small allocations that are guaranteed not to escape a certain scope. Essentially, you can remove the overhead of refcounting (but ARC should take care of that already), but also remove the overhead of deallocating every small object individually. It should be possible to do this in a safe way, e.g. by ensuring that only one reference to a object exists of any time (my type theory is very very rusty, but wasn’t that accomplished by linear types)?<br></p><p>Good point. There are actually two ARC performance problems that eventually need to be solved for some problem domains vis-à-vis GC implementations:<br></p><p>1. Allocation and deallocation overhead.<br></p><p>2. Concurrency. Cache efficiency is more nuanced than this thread makes it seem. We should admit that standard reference counts are a bad idea for shared objects and rest assured that Swift’s concurrency model will take that into consideration.<br></p><p>I’m excited and optimistic about solving these, but neither are going to be solved in Swift 3, and we don’t have the bandwidth now to debate proposals.<br></p><p>Andy<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>What about garbage collection?</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>February  9, 2016 at 10:00:00pm</p></header><div class="content"><p>Let&#39;s go back to ASM? ;)<br></p><p>Sent from my iPhone<br></p><p>&gt; On 9 Feb 2016, at 20:24, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; In addition to memory and performance, the approach &quot;just write it somehow, and the system will optimize it for you so you don&#39;t have to&quot; leads to bad code that is slow and uses too many resources.<br>&gt;&gt; On Tue, Feb 9, 2016 at 1:30 PM David Turnbull via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; On Tue, Feb 9, 2016 at 9:04 AM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; That island has other inhabitants: video game developers.<br>&gt;&gt; <br>&gt;&gt; Audio systems too. 60fps video has a hard limit of 16.66ms per frame. Real time audio needs 3ms buffers, imo, but can be less strict depending on the application.<br>&gt;&gt; <br>&gt;&gt; I think that Swift can become the first serious alternative to C++ for game development and creative coding. For all platforms, not just Avalon (the Isle of Apples, wokka wokka). If Swift becomes a mark-sweep GC language I&#39;m going to get very angry and abandon my work from the last two months: https://github.com/AE9RB/SwiftGL<br>&gt;&gt; <br>&gt;&gt; -david<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160209/0b032951/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>What about garbage collection?</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February  9, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Feb 9, 2016, at 6:35 AM, Jean-Denis Muys via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; My understanding (from what I’ve seen in the literature, but I am in no way an expert) is that RC has worse worse case behaviour than GC regarding pauses.<br>&gt; <br>&gt; Also arguments regarding RAM use (and perhaps even battery use), as all hardware resource-based arguments, have always been proven wrong in the past as hardware has evolved to more and better.<br>&gt; <br>&gt; The usual argument is RAM is cheap, programmer’s time, especially debugging time, is expensive.<br>&gt; <br>&gt; I find it interesting that the commonly accepted wisdom is that GC is the right thing to do. To quote but one blog post I’ve read:<br>&gt; <br>&gt;&gt; It’s a long since resolved dispute, and GC won. I don’t want Steve Jobs to reach out from the grave and drag us back to the 70s. There’s nothing special about mobile phones: they are more powerful than the computers that GC won on in the first place.<br>&gt; <br>&gt; <br>&gt; So I’d be interested in understanding why we are about alone on our Apple island with our opinion that RC is better than GC? Are they all collectively wrong in the rest of the universe? (not that I condone argument from majority)<br>&gt; <br>&gt; I can only state that my experience with GC has been with mostly with Macintosh Common Lisp a rather long time ago, and I did really love it.<br>&gt; <br>&gt; So for me, GC would be a +1, but not a very strong one, as I find RC adequate.<br></p><p>I don&#39;t think it&#39;s just the Apple island—mark-and-sweep GC languages have consistently been tried and failed on the client side. Java applets and client-side apps died quickly; Microsoft tried and failed several times to reinvent their stack on top of .NET, and has since retreated to a refcounting-based foundation for WinRT; Apple too has tried to bring GC to the client several times, with the Java bridge, MacRuby, and ObjC GC. Javascript in the browser is an exception, though even there people are trying really hard to supplant it with a more primitive foundation like WebAssembly or asm.js.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160209/54d2d029/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>What about garbage collection?</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>February  9, 2016 at 10:00:00pm</p></header><div class="content"><p>I generally agree that refcounting is not a solution taken by the language and tools developers at Apple for laziness, but if we are quoting the failures at using GC for UI heavy interactive apps... I do disagree with an example, but again that probably could only be sorted by a huge huge thread with better informed people: .NET vs WinRT was not a historically purely just performance and fully merits driven battle, politics between the two different divisions that developed each alternative have to be considered (and lo and behold the solution pushed by the Windows team won ;)).<br></p><p>Also... we are ignoring a large green electronic elephant in the room using Java and not doing. A bad job with very similarly priced handsets... :). Sorry for the noise though and thanks for all these informative posts :).<br></p><p>Sent from my iPhone<br></p><p>&gt; On 9 Feb 2016, at 17:23, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Microsoft tried and failed several times to reinvent their stack on top of .NET, and has since retreated to a refcounting-based foundation for WinRT<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>What about garbage collection?</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>February  9, 2016 at 05:00:00pm</p></header><div class="content"><p>Your experiences may vary, but at the last large mobile company I worked for our Android engineers spent far more time wrestling with the GC than our iOS developers spent on similar memory issues. (A lot of this had to do with media handling or rendering complex UIs containing many high resolution image assets.)<br></p><p>That&#39;s not to say that Android apps can&#39;t be performant or smooth, nor that GC on Android hasn&#39;t greatly improved over time, but UI application development on a GC based resource constrained platform comes with its own tradeoffs. I would personally rather deal with breaking cycles (which can be worked around with the proper foresight and architecture) than placating a GC.<br></p><p>Sent from my iPhone<br></p><p>&gt; On Feb 9, 2016, at 2:16 PM, Goffredo Marocchi via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I generally agree that refcounting is not a solution taken by the language and tools developers at Apple for laziness, but if we are quoting the failures at using GC for UI heavy interactive apps... I do disagree with an example, but again that probably could only be sorted by a huge huge thread with better informed people: .NET vs WinRT was not a historically purely just performance and fully merits driven battle, politics between the two different divisions that developed each alternative have to be considered (and lo and behold the solution pushed by the Windows team won ;)).<br>&gt; <br>&gt; Also... we are ignoring a large green electronic elephant in the room using Java and not doing. A bad job with very similarly priced handsets... :). Sorry for the noise though and thanks for all these informative posts :).<br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt;&gt; On 9 Feb 2016, at 17:23, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Microsoft tried and failed several times to reinvent their stack on top of .NET, and has since retreated to a refcounting-based foundation for WinRT<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>What about garbage collection?</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>February  9, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Feb 9, 2016, at 7:35 AM, Jean-Denis Muys via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&lt;snip&gt;<br>&gt; I find it interesting that the commonly accepted wisdom is that GC is the right thing to do. To quote but one blog post I’ve read:<br>&gt; <br>&gt;&gt; It’s a long since resolved dispute, and GC won. I don’t want Steve Jobs to reach out from the grave and drag us back to the 70s. There’s nothing special about mobile phones: they are more powerful than the computers that GC won on in the first place.<br></p><p>I looked up that article (http://www.lshift.net/blog/2013/09/19/the-great-gc-vs-reference-counting-debate/) and it has several logical fallacies, including the obvious one that reference counting is not a form of GC!<br></p><p>In addition, the point that using a generational GC saves you from having a cost to object allocation is false, that web browsers could not do object compaction because they are written in C/C++ is false (JNI is a perfectly fine, if aged, example of interacting with a compacting GC from C++ code). There is in fact nothing preventing one from doing compaction in a reference counted system which is safe, nor using a reference counted system as part of a javascript implementation (although you would need cycle elimination via tracing as well).<br></p><p>While I didn’t look further, the article is probably correct in terms of the benchmark being complained about but for more meta reasons. It is very difficult to compare GC performance semantics, fundamentally because their designs prioritize different aspects of performance. For instance, mark and sweep GCs generally can fall back to having long pauses as all of memory is checked - which is why modern implementations have generational GCs and concurrent passes to attempt to reduce the frequency of “stop the world” GC pauses (anecdotally, I’ve actually seen a 12 minute stop-the-world GC pause in a production Java 7 application without proper tuning - and some of that tuning was simply setting a lower ceiling of memory usage for the Java process such that when it eventually hit a stop-the-world GC event, it would have less memory to check).<br></p><p>For reference counting, the cost of GC is amortized across usage, meaning you cannot get ‘stop the world’ pauses. Compacting GC systems will require objects to go through write or even read barriers, so such systems don’t operate for ‘free’ at execution time, and likewise still have an effect on things like loop performance. There have been clever attempts to solve the needs of in-code barrier checks using the MMU and page faulting, but also push-back on the trade-offs these have as well. Nobody has ‘won’ the title of ideal garbage collector implementation yet, and I suggest that such concepts as ideal are simply not possible.<br></p><p>&gt; So I’d be interested in understanding why we are about alone on our Apple island with our opinion that RC is better than GC? Are they all collectively wrong in the rest of the universe? (not that I condone argument from majority)<br></p><p>The promise of garbage collection systems in general is that they eliminate the need to think about object lifetime and ownership to produce safe code. With reference counted GC, this is obviously not true in the cases where you can have cycles. With tracing GCs like compacting or mark and sweep, you get closer to achieving this benefit, but with the side effect that a significant source of memory and performance impacts becomes outside of your control.<br></p><p>There is apparently a difference in opinion of whether such a trade-off is worth it ;-)<br></p><p>Objective C had a tracing (but I believe non-compacting) garbage collector for several years; I don’t know if the reasoning behind replacing it with ARC has been published. I can only guess that one of the reasons was the complexity of supporting two GC mechanisms - which, since Swift has to maintain compatibility with reference-counted Objective C code, would be one of the concerns for adding a tracing GC to the language.<br></p><p>-DW<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160209/5570c148/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: smime.p7s<br>Type: application/pkcs7-signature<br>Size: 4139 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160209/5570c148/attachment.p7s&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>What about garbage collection?</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>February  9, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Feb 9, 2016, at 9:45 AM, David Waite via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Feb 9, 2016, at 7:35 AM, Jean-Denis Muys via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I find it interesting that the commonly accepted wisdom is that GC is the right thing to do. To quote but one blog post I’ve read:<br>&gt;&gt; <br>&gt;&gt;&gt; It’s a long since resolved dispute, and GC won. I don’t want Steve Jobs to reach out from the grave and drag us back to the 70s. There’s nothing special about mobile phones: they are more powerful than the computers that GC won on in the first place.<br>&gt; <br>&gt; I looked up that article (http://www.lshift.net/blog/2013/09/19/the-great-gc-vs-reference-counting-debate/ &lt;http://www.lshift.net/blog/2013/09/19/the-great-gc-vs-reference-counting-debate/&gt;) and it has several logical fallacies, including the obvious one that reference counting is not a form of GC!<br></p><p>Counter-pedantry: Reference counting *with an automatic cycle collector* is GC. ARC-style reference counting is not GC.<br></p><p><br>-- <br>Greg Parker     gparker at apple.com &lt;mailto:gparker at apple.com&gt;     Runtime Wrangler<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160209/306cde37/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>What about garbage collection?</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>February  9, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Feb 9, 2016, at 4:29 PM, Greg Parker via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 9, 2016, at 9:45 AM, David Waite via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 9, 2016, at 7:35 AM, Jean-Denis Muys via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I find it interesting that the commonly accepted wisdom is that GC is the right thing to do. To quote but one blog post I’ve read:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It’s a long since resolved dispute, and GC won. I don’t want Steve Jobs to reach out from the grave and drag us back to the 70s. There’s nothing special about mobile phones: they are more powerful than the computers that GC won on in the first place.<br>&gt;&gt; <br>&gt;&gt; I looked up that article (http://www.lshift.net/blog/2013/09/19/the-great-gc-vs-reference-counting-debate/ &lt;http://www.lshift.net/blog/2013/09/19/the-great-gc-vs-reference-counting-debate/&gt;) and it has several logical fallacies, including the obvious one that reference counting is not a form of GC!<br>&gt; <br>&gt; Counter-pedantry: Reference counting *with an automatic cycle collector* is GC. ARC-style reference counting is not GC.<br></p><p>I don’t really want to get into a terminology debate, but by pretty much any well accepted definition, ARC is an algorithm for GC.  As one example:<br>https://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29#Reference_counting<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160209/31bb46bc/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>What about garbage collection?</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>February  9, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Feb 9, 2016, at 8:35 AM, Jean-Denis Muys via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; It’s a long since resolved dispute, and GC won. I don’t want Steve Jobs to reach out from the grave and drag us back to the 70s. There’s nothing special about mobile phones: they are more powerful than the computers that GC won on in the first place.<br></p><p>I’d disagree with that, for one rather important reason; the computers that GC won on had virtual memory. On mobile, when your RAM runs out, it’s out. So RAM constraints are somewhat more serious on mobile.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160209/5cee16a5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>What about garbage collection?</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>February  9, 2016 at 10:00:00pm</p></header><div class="content"><p>This will be then more fun when we have page file support as virtual memory is already there.<br></p><p>Sent from my iPhone<br></p><p>&gt; On 9 Feb 2016, at 18:18, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Feb 9, 2016, at 8:35 AM, Jean-Denis Muys via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It’s a long since resolved dispute, and GC won. I don’t want Steve Jobs to reach out from the grave and drag us back to the 70s. There’s nothing special about mobile phones: they are more powerful than the computers that GC won on in the first place.<br>&gt; <br>&gt; I’d disagree with that, for one rather important reason; the computers that GC won on had virtual memory. On mobile, when your RAM runs out, it’s out. So RAM constraints are somewhat more serious on mobile.<br>&gt; <br>&gt; Charles<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160209/0a941581/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>What about garbage collection?</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>February  9, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Feb 9, 2016, at 2:21 PM, Goffredo Marocchi via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On 9 Feb 2016, at 18:18, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 9, 2016, at 8:35 AM, Jean-Denis Muys via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It’s a long since resolved dispute, and GC won. I don’t want Steve Jobs to reach out from the grave and drag us back to the 70s. There’s nothing special about mobile phones: they are more powerful than the computers that GC won on in the first place.<br>&gt;&gt; <br>&gt;&gt; I’d disagree with that, for one rather important reason; the computers that GC won on had virtual memory. On mobile, when your RAM runs out, it’s out. So RAM constraints are somewhat more serious on mobile.<br>&gt; <br>&gt; This will be then more fun when we have page file support as virtual memory is already there.<br></p><p><br>Unlikely with current hardware technology. NAND storage on mobile devices has limited lifetime based on the number of writes. Adding a swap file would burn through that lifetime awfully fast.<br></p><p><br>-- <br>Greg Parker     gparker at apple.com &lt;mailto:gparker at apple.com&gt;     Runtime Wrangler<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160209/a60b5c4f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>What about garbage collection?</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>February 10, 2016 at 12:00:00am</p></header><div class="content"><p>I think those changes can be overcome... but yes, it is not something that would happen tomorrow... More like five years from now ;). *Crossing fingers for memristors or some new nonvolatile storage solution to overcome the current flash issue with frequent read/write cycles....*<br></p><p>Maybe enough redundancy and better controllers can allow the same flexibility on mobile&#39;s that we enjoy on any SSD on laptops and desktops nowadays and similar I/O throughout though. <br></p><p>Sent from my iPhone<br></p><p>&gt; On 10 Feb 2016, at 00:32, Greg Parker &lt;gparker at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Feb 9, 2016, at 2:21 PM, Goffredo Marocchi via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On 9 Feb 2016, at 18:18, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Feb 9, 2016, at 8:35 AM, Jean-Denis Muys via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It’s a long since resolved dispute, and GC won. I don’t want Steve Jobs to reach out from the grave and drag us back to the 70s. There’s nothing special about mobile phones: they are more powerful than the computers that GC won on in the first place.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’d disagree with that, for one rather important reason; the computers that GC won on had virtual memory. On mobile, when your RAM runs out, it’s out. So RAM constraints are somewhat more serious on mobile.<br>&gt;&gt; <br>&gt;&gt; This will be then more fun when we have page file support as virtual memory is already there.<br>&gt; <br>&gt; <br>&gt; Unlikely with current hardware technology. NAND storage on mobile devices has limited lifetime based on the number of writes. Adding a swap file would burn through that lifetime awfully fast.<br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Greg Parker     gparker at apple.com     Runtime Wrangler<br>&gt; <br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160210/f77e939a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>What about garbage collection?</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>February 10, 2016 at 07:00:00am</p></header><div class="content"><p>Much sooner…… Optane (which should dramatically increase the durability) is out this year from Intel, and the competitors plan to have equivalent out in a year I think….  <br></p><p><br>&gt; On 2016-02-10, at 7:43:40, Goffredo Marocchi via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I think those changes can be overcome... but yes, it is not something that would happen tomorrow... More like five years from now ;). *Crossing fingers for memristors or some new nonvolatile storage solution to overcome the current flash issue with frequent read/write cycles....*<br>&gt; <br>&gt; Maybe enough redundancy and better controllers can allow the same flexibility on mobile&#39;s that we enjoy on any SSD on laptops and desktops nowadays and similar I/O throughout though. <br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt; On 10 Feb 2016, at 00:32, Greg Parker &lt;gparker at apple.com &lt;mailto:gparker at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 9, 2016, at 2:21 PM, Goffredo Marocchi via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 9 Feb 2016, at 18:18, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Feb 9, 2016, at 8:35 AM, Jean-Denis Muys via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It’s a long since resolved dispute, and GC won. I don’t want Steve Jobs to reach out from the grave and drag us back to the 70s. There’s nothing special about mobile phones: they are more powerful than the computers that GC won on in the first place.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’d disagree with that, for one rather important reason; the computers that GC won on had virtual memory. On mobile, when your RAM runs out, it’s out. So RAM constraints are somewhat more serious on mobile.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This will be then more fun when we have page file support as virtual memory is already there.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Unlikely with current hardware technology. NAND storage on mobile devices has limited lifetime based on the number of writes. Adding a swap file would burn through that lifetime awfully fast.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Greg Parker     gparker at apple.com &lt;mailto:gparker at apple.com&gt;     Runtime Wrangler<br>&gt;&gt; <br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160210/d4b2b237/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>What about garbage collection?</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>February  9, 2016 at 04:00:00pm</p></header><div class="content"><p>Performance, too:<br>&gt; from http://www.eetimes.com/document.asp?doc_id=1328682<br>&gt; &quot;In an NVMe-based solid state drive, XPoint chips can deliver more than 95,000 I/O operations per second at a 9 microsecond latency, compared to 13,400 IOPs and 73 ms latency for flash.&quot;<br></p><p>Sent from my iPhone<br></p><p>&gt; On Feb 9, 2016, at 16:47, Craig Cruden via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Much sooner…… Optane (which should dramatically increase the durability) is out this year from Intel, and the competitors plan to have equivalent out in a year I think….  <br>&gt; <br>&gt; <br>&gt;&gt; On 2016-02-10, at 7:43:40, Goffredo Marocchi via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I think those changes can be overcome... but yes, it is not something that would happen tomorrow... More like five years from now ;). *Crossing fingers for memristors or some new nonvolatile storage solution to overcome the current flash issue with frequent read/write cycles....*<br>&gt;&gt; <br>&gt;&gt; Maybe enough redundancy and better controllers can allow the same flexibility on mobile&#39;s that we enjoy on any SSD on laptops and desktops nowadays and similar I/O throughout though. <br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt;&gt; On 10 Feb 2016, at 00:32, Greg Parker &lt;gparker at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Feb 9, 2016, at 2:21 PM, Goffredo Marocchi via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 9 Feb 2016, at 18:18, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Feb 9, 2016, at 8:35 AM, Jean-Denis Muys via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; It’s a long since resolved dispute, and GC won. I don’t want Steve Jobs to reach out from the grave and drag us back to the 70s. There’s nothing special about mobile phones: they are more powerful than the computers that GC won on in the first place.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I’d disagree with that, for one rather important reason; the computers that GC won on had virtual memory. On mobile, when your RAM runs out, it’s out. So RAM constraints are somewhat more serious on mobile.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This will be then more fun when we have page file support as virtual memory is already there.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Unlikely with current hardware technology. NAND storage on mobile devices has limited lifetime based on the number of writes. Adding a swap file would burn through that lifetime awfully fast.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Greg Parker     gparker at apple.com     Runtime Wrangler<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160209/c38689ca/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
