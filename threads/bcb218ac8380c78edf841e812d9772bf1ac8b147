<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Draft] Introducing StaticSelf, an Invariant Self</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 12, 2016 at 07:00:00pm</p></header><div class="content"><p>Erica Sadun and I have written a proposal are following up the recent discussion thread &quot;[RFC] #Self” with a proposal to introduce StaticSelf, an invariant Self.<br></p><p>The recent discussion can be found here: http://thread.gmane.org/gmane.comp.lang.swift.evolution/16565 &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/16565&gt;<br></p><p>The proposal can be found here: https://github.com/anandabits/swift-evolution/blob/static-self/proposals/NNNN-static-self.md &lt;https://github.com/anandabits/swift-evolution/blob/static-self/proposals/NNNN-static-self.md&gt;<br></p><p>We look forward to continuing the discussion.  We plan to submit a PR in the near future after incorporating your final feedback.<br></p><p>Thanks,<br>Matthew<br>Introducing StaticSelf, an Invariant Self<br></p><p>Proposal: TBD<br>Authors: Matthew Johnson &lt;https://github.com/anandabits&gt;, Erica Sadun &lt;https://github.com/erica&gt;<br>Status: TBD<br>Review manager: TBD<br>Introduction<br></p><p>This proposal introduces a new keyword that provides consistent invariant type semantics in all contexts.<br></p><p>The Swift-evolution thread about this topic can be found here: [RFC] #Self &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/16565&gt;<br>Motivation<br></p><p>The distinction between covariant and non-covariant type references come into play when<br>conforming non-final classes to protocols. Fixing a protocol requirement to a covarying type<br>means that a method returning Self must be overriden by all subclasses in order to return<br>the correct, matching type.<br></p><p>This proposal builds on the covariant construct Self accepted in SE–0068 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0068-universal-self.md&gt;<br>to introduce an invariant type identifier. It enables protocol declarations to consistently<br>refer to a type that is fixed at compile time. This ensures that subclasses can inherit<br>protocol implementations without having to re-implement that code at each level of<br>inheritance.<br></p><p>Under this proposal, a new identifier keyword is fixed in use at the point of protocol conformance<br>to the static type of that construct. <br></p><p>class A: MyProtocol<br>The invariant StaticSelf identifier will always refer to A, unlike Self, which is covarying and refers to<br>the type of the actual instance. Since multiple inheritance for non-protocol types is disallowed,<br>this establishes this invariant type identifier with no possibility for conflict.<br></p><p>Consider the following example, under the current system:<br></p><p>protocol StringCreatable {<br>    static func createWithString(s: String) -&gt; Self<br>}<br></p><p>extension NSURL: StringCreatable {<br> // cannot conform because NSURL is non-final<br> // error: method &#39;createWithString&#39; in non-final class &#39;NSURL&#39; must return `Self` to conform to protocol &#39;A&#39;<br>}<br>Introducing a static, invariant version of Self permits the desired conformance:<br></p><p>protocol StringCreatable {<br>    static func createWithString(s: String) -&gt; StaticSelf<br>}<br></p><p>extension NSURL: StringCreatable {<br> // can now conform conform because NSURL is fixed and matches the static<br> // type of the conforming construct. Subclasses need not re-implement<br> // NOTE: the return type can be declared as StaticSelf *or* as NSURL<br> //       they are interchangeable<br> static func createWithString(s: String) -&gt; StaticSelf { <br>     // ...<br> }<br>}<br>Additional Utility<br></p><p>The utility of StaticSelf is not limited to protocols. A secondary use enables code to refer to the lexical context’s current type without explicitly mentioning its name. This provides a useful shortcut when referencing static type members with especially long names and when re-purposing code between types.<br></p><p>class StructWithAVeryLongName {<br>    static func foo() -&gt; String {<br>      // ...<br>    }<br>    func bar() {<br>      // ...<br>      let s = StaticSelf.foo()<br>      //<br>    }<br>}<br>Detailed Design<br></p><p>This proposal introduces StaticSelf, a new keyword that may be used in protocols to refer to the invariant static type of a conforming construct. StaticSelf may also be used in the lexical context of any type declaration. In such use, the keyword is identical to spelling out the full name of that type.<br></p><p>Impact on existing code<br></p><p>Being additive, there should be no impact on existing code.<br></p><p>Alternatives considered<br></p><p>The keyword is not fixed at this time. Alternatives that have been discussed include StaticType, InvariantSelf, SelfType, or Type. The community is welcome to bikeshed on the most clear and concise name for this keyword.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160512/bcb2b147/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Draft] Introducing StaticSelf, an Invariant Self</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May 12, 2016 at 08:00:00pm</p></header><div class="content"><p>I like the way the motivation for this feature has been explained here. Now<br>that the reasoning behind it is evident, I have to say I&#39;m leaning towards<br>the &quot;InvariantSelf&quot; name--after all, you describe this feature in the title<br>as &quot;an invariant self.&quot;<br></p><p><br>On Thu, May 12, 2016 at 7:49 PM, Matthew Johnson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Erica Sadun and I have written a proposal are following up the recent<br>&gt; discussion thread &quot;[RFC] #Self” with a proposal to introduce StaticSelf, an<br>&gt; invariant Self.<br>&gt;<br>&gt; The recent discussion can be found here:<br>&gt; http://thread.gmane.org/gmane.comp.lang.swift.evolution/16565<br>&gt;<br>&gt; The proposal can be found here:<br>&gt; https://github.com/anandabits/swift-evolution/blob/static-self/proposals/NNNN-static-self.md<br>&gt;<br>&gt; We look forward to continuing the discussion.  We plan to submit a PR in<br>&gt; the near future after incorporating your final feedback.<br>&gt;<br>&gt; Thanks,<br>&gt; Matthew<br>&gt; Introducing StaticSelf, an Invariant Self<br>&gt;<br>&gt;    - Proposal: TBD<br>&gt;    - Authors: Matthew Johnson &lt;https://github.com/anandabits&gt;, Erica Sadun<br>&gt;    &lt;https://github.com/erica&gt;<br>&gt;    - Status: TBD<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt; Introduction<br>&gt;<br>&gt; This proposal introduces a new keyword that provides consistent invariant<br>&gt; type semantics in all contexts.<br>&gt;<br>&gt; *The Swift-evolution thread about this topic can be found here: [RFC]<br>&gt; #Self &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/16565&gt;*<br>&gt; Motivation<br>&gt;<br>&gt; The distinction between covariant and non-covariant type references come<br>&gt; into play when<br>&gt; conforming non-final classes to protocols. Fixing a protocol requirement<br>&gt; to a covarying type<br>&gt; means that a method returning Self must be overriden by all subclasses in<br>&gt; order to return<br>&gt; the correct, matching type.<br>&gt;<br>&gt; This proposal builds on the covariant construct Self accepted in SE–0068<br>&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0068-universal-self.md&gt;<br>&gt; to introduce an invariant type identifier. It enables protocol<br>&gt; declarations to consistently<br>&gt; refer to a type that is fixed at compile time. This ensures that<br>&gt; subclasses can inherit<br>&gt; protocol implementations without having to re-implement that code at each<br>&gt; level of<br>&gt; inheritance.<br>&gt;<br>&gt; Under this proposal, a new identifier keyword is fixed in use *at the<br>&gt; point of protocol conformance*<br>&gt; to the static type of that construct.<br>&gt;<br>&gt; class A: MyProtocol<br>&gt;<br>&gt; The invariant StaticSelf identifier will always refer to A, unlike Self,<br>&gt; which is covarying and refers to<br>&gt; the type of the actual instance. Since multiple inheritance for<br>&gt; non-protocol types is disallowed,<br>&gt; this establishes this invariant type identifier with no possibility for<br>&gt; conflict.<br>&gt;<br>&gt; Consider the following example, under the current system:<br>&gt;<br>&gt; protocol StringCreatable {<br>&gt;     static func createWithString(s: String) -&gt; Self<br>&gt; }<br>&gt; extension NSURL: StringCreatable {<br>&gt;  // cannot conform because NSURL is non-final<br>&gt;  // error: method &#39;createWithString&#39; in non-final class &#39;NSURL&#39; must return `Self` to conform to protocol &#39;A&#39;<br>&gt; }<br>&gt;<br>&gt; Introducing a static, invariant version of Self permits the desired<br>&gt; conformance:<br>&gt;<br>&gt; protocol StringCreatable {<br>&gt;     static func createWithString(s: String) -&gt; StaticSelf<br>&gt; }<br>&gt; extension NSURL: StringCreatable {<br>&gt;  // can now conform conform because NSURL is fixed and matches the static<br>&gt;  // type of the conforming construct. Subclasses need not re-implement<br>&gt;  // NOTE: the return type can be declared as StaticSelf *or* as NSURL<br>&gt;  //       they are interchangeable<br>&gt;  static func createWithString(s: String) -&gt; StaticSelf {<br>&gt;      // ...<br>&gt;  }<br>&gt; }<br>&gt;<br>&gt; Additional Utility<br>&gt;<br>&gt; The utility of StaticSelf is not limited to protocols. A secondary use<br>&gt; enables code to refer to the lexical context’s current type without<br>&gt; explicitly mentioning its name. This provides a useful shortcut when<br>&gt; referencing static type members with especially long names and when<br>&gt; re-purposing code between types.<br>&gt;<br>&gt; class StructWithAVeryLongName {<br>&gt;     static func foo() -&gt; String {<br>&gt;       // ...<br>&gt;     }<br>&gt;     func bar() {<br>&gt;       // ...<br>&gt;       let s = StaticSelf.foo()<br>&gt;       //<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; Detailed Design<br>&gt;<br>&gt; This proposal introduces StaticSelf, a new keyword that may be used in<br>&gt; protocols to refer to the invariant static type of a conforming construct.<br>&gt; StaticSelf may also be used in the lexical context of any type<br>&gt; declaration. In such use, the keyword is identical to spelling out the full<br>&gt; name of that type.<br>&gt; Impact on existing code<br>&gt;<br>&gt; Being additive, there should be no impact on existing code.<br>&gt; Alternatives considered<br>&gt;<br>&gt; The keyword is not fixed at this time. Alternatives that have been<br>&gt; discussed include StaticType, InvariantSelf, SelfType, or Type. The<br>&gt; community is welcome to bikeshed on the most clear and concise name for<br>&gt; this keyword.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160512/fc4cd932/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Draft] Introducing StaticSelf, an Invariant Self</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 13, 2016 at 10:00:00am</p></header><div class="content"><p>I don&#39;t feel that InvariantSelf reflects the fact that class conformed to <br>protocol with `f()-&gt;InvariantSelf` requirement will actually return<br>&#39;self or some base class&#39;. Especially when this `InvariantSelf` means <br>`exactly this concrete static type name` inside type declaration.<br></p><p>Probably the better name is BaseType (BaseSelf, ThisType.. #Type ?)<br></p><p>But actually I don&#39;t fully understand how this would work in generic functions:<br></p><p>protocol A {<br>   func g()-&gt;StaticSelf<br>}<br></p><p>class B: A {<br>   func g()-&gt;StaticSelf {return B()}<br>}<br></p><p>class C: B {<br>}<br></p><p><br>func x(a: A ){<br>     var xx : A = a.g() // will this work? as g returns *some in hierarchy*<br>     print(xx)<br>}<br></p><p>func z&lt;T: A&gt;(t: T) {<br>     let u = t.g() // will this work?<br>     print(u)<br>}<br></p><p>let c = C()<br>z(c)<br>x(c)<br></p><p><br></p><p><br>On 13.05.2016 4:59, Xiaodi Wu via swift-evolution wrote:<br>&gt; I like the way the motivation for this feature has been explained here. Now<br>&gt; that the reasoning behind it is evident, I have to say I&#39;m leaning towards<br>&gt; the &quot;InvariantSelf&quot; name--after all, you describe this feature in the title<br>&gt; as &quot;an invariant self.&quot;<br>&gt;<br>&gt;<br>&gt; On Thu, May 12, 2016 at 7:49 PM, Matthew Johnson via swift-evolution<br>&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;<br>&gt;     Erica Sadun and I have written a proposal are following up the recent<br>&gt;     discussion thread &quot;[RFC] #Self” with a proposal to introduce<br>&gt;     StaticSelf, an invariant Self.<br>&gt;<br>&gt;     The recent discussion can be found<br>&gt;     here: http://thread.gmane.org/gmane.comp.lang.swift.evolution/16565<br>&gt;<br>&gt;     The proposal can be found<br>&gt;     here: https://github.com/anandabits/swift-evolution/blob/static-self/proposals/NNNN-static-self.md<br>&gt;<br>&gt;     We look forward to continuing the discussion.  We plan to submit a PR<br>&gt;     in the near future after incorporating your final feedback.<br>&gt;<br>&gt;     Thanks,<br>&gt;     Matthew<br>&gt;<br>&gt;<br>&gt;       Introducing StaticSelf, an Invariant Self<br>&gt;<br>&gt;       * Proposal: TBD<br>&gt;       * Authors: Matthew Johnson &lt;https://github.com/anandabits&gt;, Erica<br>&gt;         Sadun &lt;https://github.com/erica&gt;<br>&gt;       * Status: TBD<br>&gt;       * Review manager: TBD<br>&gt;<br>&gt;<br>&gt;         Introduction<br>&gt;<br>&gt;     This proposal introduces a new keyword that provides consistent<br>&gt;     invariant type semantics in all contexts.<br>&gt;<br>&gt;     /The Swift-evolution thread about this topic can be found here: [RFC]<br>&gt;     #Self &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/16565&gt;/<br>&gt;<br>&gt;<br>&gt;         Motivation<br>&gt;<br>&gt;     The distinction between covariant and non-covariant type references<br>&gt;     come into play when<br>&gt;     conforming non-final classes to protocols. Fixing a protocol<br>&gt;     requirement to a covarying type<br>&gt;     means that a method returning |Self| must be overriden by all<br>&gt;     subclasses in order to return<br>&gt;     the correct, matching type.<br>&gt;<br>&gt;     This proposal builds on the covariant construct |Self| accepted<br>&gt;     in SE–0068<br>&gt;     &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0068-universal-self.md&gt;<br>&gt;     to introduce an invariant type identifier. It enables protocol<br>&gt;     declarations to consistently<br>&gt;     refer to a type that is fixed at compile time. This ensures that<br>&gt;     subclasses can inherit<br>&gt;     protocol implementations without having to re-implement that code at<br>&gt;     each level of<br>&gt;     inheritance.<br>&gt;<br>&gt;     Under this proposal, a new identifier keyword is fixed in use /at the<br>&gt;     point of protocol conformance/<br>&gt;     to the static type of that construct.<br>&gt;<br>&gt;     |class A: MyProtocol|<br>&gt;<br>&gt;     The invariant |StaticSelf| identifier will always refer to |A|,<br>&gt;     unlike |Self|, which is covarying and refers to<br>&gt;     the type of the actual instance. Since multiple inheritance for<br>&gt;     non-protocol types is disallowed,<br>&gt;     this establishes this invariant type identifier with no possibility for<br>&gt;     conflict.<br>&gt;<br>&gt;     Consider the following example, under the current system:<br>&gt;<br>&gt;     |protocol StringCreatable { static func createWithString(s: String) -&gt;<br>&gt;     Self } extension NSURL: StringCreatable { // cannot conform because<br>&gt;     NSURL is non-final // error: method &#39;createWithString&#39; in non-final<br>&gt;     class &#39;NSURL&#39; must return `Self` to conform to protocol &#39;A&#39; }|<br>&gt;<br>&gt;     Introducing a static, invariant version of |Self| permits the desired<br>&gt;     conformance:<br>&gt;<br>&gt;     |protocol StringCreatable { static func createWithString(s: String) -&gt;<br>&gt;     StaticSelf } extension NSURL: StringCreatable { // can now conform<br>&gt;     conform because NSURL is fixed and matches the static // type of the<br>&gt;     conforming construct. Subclasses need not re-implement // NOTE: the<br>&gt;     return type can be declared as StaticSelf *or* as NSURL // they are<br>&gt;     interchangeable static func createWithString(s: String) -&gt; StaticSelf {<br>&gt;     // ... } }|<br>&gt;<br>&gt;<br>&gt;           Additional Utility<br>&gt;<br>&gt;     The utility of |StaticSelf| is not limited to protocols. A secondary<br>&gt;     use enables code to refer to the lexical context’s current type without<br>&gt;     explicitly mentioning its name. This provides a useful shortcut when<br>&gt;     referencing static type members with especially long names and when<br>&gt;     re-purposing code between types.<br>&gt;<br>&gt;     |class StructWithAVeryLongName { static func foo() -&gt; String { // ... }<br>&gt;     func bar() { // ... let s = StaticSelf.foo() // } }|<br>&gt;<br>&gt;<br>&gt;         Detailed Design<br>&gt;<br>&gt;     This proposal introduces |StaticSelf|, a new keyword that may be used<br>&gt;     in protocols to refer to the invariant static type of a conforming<br>&gt;     construct. |StaticSelf| may also be used in the lexical context of any<br>&gt;     type declaration. In such use, the keyword is identical to spelling out<br>&gt;     the full name of that type.<br>&gt;<br>&gt;<br>&gt;         Impact on existing code<br>&gt;<br>&gt;     Being additive, there should be no impact on existing code.<br>&gt;<br>&gt;<br>&gt;         Alternatives considered<br>&gt;<br>&gt;     The keyword is not fixed at this time. Alternatives that have been<br>&gt;     discussed include |StaticType|, |InvariantSelf|, |SelfType|, or |Type|.<br>&gt;     The community is welcome to bikeshed on the most clear and concise name<br>&gt;     for this keyword.<br>&gt;<br>&gt;<br>&gt;     _______________________________________________<br>&gt;     swift-evolution mailing list<br>&gt;     swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Draft] Introducing StaticSelf, an Invariant Self</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 13, 2016 at 01:00:00pm</p></header><div class="content"><p>Considering the precedent of using ! and ? in swift, could it be that:<br></p><p>Self!  would designate what is known for sure, the invariant compile time type of self<br></p><p>Self? Would designate the yet unknown (*optional* if you will) covariant type of self<br></p><p><br>Regards<br>LM<br>(From mobile)<br></p><p>&gt; On May 13, 2016, at 3:59 AM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I like the way the motivation for this feature has been explained here. Now that the reasoning behind it is evident, I have to say I&#39;m leaning towards the &quot;InvariantSelf&quot; name--after all, you describe this feature in the title as &quot;an invariant self.&quot;<br>&gt; <br>&gt; <br>&gt;&gt; On Thu, May 12, 2016 at 7:49 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Erica Sadun and I have written a proposal are following up the recent discussion thread &quot;[RFC] #Self” with a proposal to introduce StaticSelf, an invariant Self.<br>&gt;&gt; <br>&gt;&gt; The recent discussion can be found here: http://thread.gmane.org/gmane.comp.lang.swift.evolution/16565<br>&gt;&gt; <br>&gt;&gt; The proposal can be found here: https://github.com/anandabits/swift-evolution/blob/static-self/proposals/NNNN-static-self.md<br>&gt;&gt; <br>&gt;&gt; We look forward to continuing the discussion.  We plan to submit a PR in the near future after incorporating your final feedback.<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; Matthew<br>&gt;&gt; Introducing StaticSelf, an Invariant Self<br>&gt;&gt; <br>&gt;&gt; Proposal: TBD<br>&gt;&gt; Authors: Matthew Johnson, Erica Sadun<br>&gt;&gt; Status: TBD<br>&gt;&gt; Review manager: TBD<br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; This proposal introduces a new keyword that provides consistent invariant type semantics in all contexts.<br>&gt;&gt; <br>&gt;&gt; The Swift-evolution thread about this topic can be found here: [RFC] #Self<br>&gt;&gt; <br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; The distinction between covariant and non-covariant type references come into play when<br>&gt;&gt; conforming non-final classes to protocols. Fixing a protocol requirement to a covarying type<br>&gt;&gt; means that a method returning Self must be overriden by all subclasses in order to return<br>&gt;&gt; the correct, matching type.<br>&gt;&gt; <br>&gt;&gt; This proposal builds on the covariant construct Self accepted in SE–0068<br>&gt;&gt; to introduce an invariant type identifier. It enables protocol declarations to consistently<br>&gt;&gt; refer to a type that is fixed at compile time. This ensures that subclasses can inherit<br>&gt;&gt; protocol implementations without having to re-implement that code at each level of<br>&gt;&gt; inheritance.<br>&gt;&gt; <br>&gt;&gt; Under this proposal, a new identifier keyword is fixed in use at the point of protocol conformance<br>&gt;&gt; to the static type of that construct. <br>&gt;&gt; <br>&gt;&gt; class A: MyProtocol<br>&gt;&gt; The invariant StaticSelf identifier will always refer to A, unlike Self, which is covarying and refers to<br>&gt;&gt; the type of the actual instance. Since multiple inheritance for non-protocol types is disallowed,<br>&gt;&gt; this establishes this invariant type identifier with no possibility for conflict.<br>&gt;&gt; <br>&gt;&gt; Consider the following example, under the current system:<br>&gt;&gt; <br>&gt;&gt; protocol StringCreatable {<br>&gt;&gt;     static func createWithString(s: String) -&gt; Self<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension NSURL: StringCreatable {<br>&gt;&gt;  // cannot conform because NSURL is non-final<br>&gt;&gt;  // error: method &#39;createWithString&#39; in non-final class &#39;NSURL&#39; must return `Self` to conform to protocol &#39;A&#39;<br>&gt;&gt; }<br>&gt;&gt; Introducing a static, invariant version of Self permits the desired conformance:<br>&gt;&gt; <br>&gt;&gt; protocol StringCreatable {<br>&gt;&gt;     static func createWithString(s: String) -&gt; StaticSelf<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension NSURL: StringCreatable {<br>&gt;&gt;  // can now conform conform because NSURL is fixed and matches the static<br>&gt;&gt;  // type of the conforming construct. Subclasses need not re-implement<br>&gt;&gt;  // NOTE: the return type can be declared as StaticSelf *or* as NSURL<br>&gt;&gt;  //       they are interchangeable<br>&gt;&gt;  static func createWithString(s: String) -&gt; StaticSelf { <br>&gt;&gt;      // ...<br>&gt;&gt;  }<br>&gt;&gt; }<br>&gt;&gt; Additional Utility<br>&gt;&gt; <br>&gt;&gt; The utility of StaticSelf is not limited to protocols. A secondary use enables code to refer to the lexical context’s current type without explicitly mentioning its name. This provides a useful shortcut when referencing static type members with especially long names and when re-purposing code between types.<br>&gt;&gt; <br>&gt;&gt; class StructWithAVeryLongName {<br>&gt;&gt;     static func foo() -&gt; String {<br>&gt;&gt;       // ...<br>&gt;&gt;     }<br>&gt;&gt;     func bar() {<br>&gt;&gt;       // ...<br>&gt;&gt;       let s = StaticSelf.foo()<br>&gt;&gt;       //<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; Detailed Design<br>&gt;&gt; <br>&gt;&gt; This proposal introduces StaticSelf, a new keyword that may be used in protocols to refer to the invariant static type of a conforming construct. StaticSelf may also be used in the lexical context of any type declaration. In such use, the keyword is identical to spelling out the full name of that type.<br>&gt;&gt; <br>&gt;&gt; Impact on existing code<br>&gt;&gt; <br>&gt;&gt; Being additive, there should be no impact on existing code.<br>&gt;&gt; <br>&gt;&gt; Alternatives considered<br>&gt;&gt; <br>&gt;&gt; The keyword is not fixed at this time. Alternatives that have been discussed include StaticType, InvariantSelf, SelfType, or Type. The community is welcome to bikeshed on the most clear and concise name for this keyword.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/054ff0db/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Draft] Introducing StaticSelf, an Invariant Self</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 13, 2016 at 01:00:00pm</p></header><div class="content"><p>The other advantage of Self! over StaticSelf is that in code completion, Self, Self? Self! Will come together, giving people a quick tool to discover/remind themselves of the semantic difference right at the point of use. <br></p><p>It might also address Joe&#39;s comment about StaticSelf not being much of a shortcut.<br></p><p><br>&gt; On May 13, 2016, at 1:15 PM, LM &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt; <br>&gt; Considering the precedent of using ! and ? in swift, could it be that:<br>&gt; <br>&gt; Self!  would designate what is known for sure, the invariant compile time type of self<br>&gt; <br>&gt; Self? Would designate the yet unknown (*optional* if you will) covariant type of self<br>&gt; <br>&gt; <br>&gt; Regards<br>&gt; LM<br>&gt; (From mobile)<br>&gt; <br>&gt;&gt; On May 13, 2016, at 3:59 AM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I like the way the motivation for this feature has been explained here. Now that the reasoning behind it is evident, I have to say I&#39;m leaning towards the &quot;InvariantSelf&quot; name--after all, you describe this feature in the title as &quot;an invariant self.&quot;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Thu, May 12, 2016 at 7:49 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; Erica Sadun and I have written a proposal are following up the recent discussion thread &quot;[RFC] #Self” with a proposal to introduce StaticSelf, an invariant Self.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The recent discussion can be found here: http://thread.gmane.org/gmane.comp.lang.swift.evolution/16565<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The proposal can be found here: https://github.com/anandabits/swift-evolution/blob/static-self/proposals/NNNN-static-self.md<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We look forward to continuing the discussion.  We plan to submit a PR in the near future after incorporating your final feedback.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt; Introducing StaticSelf, an Invariant Self<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposal: TBD<br>&gt;&gt;&gt; Authors: Matthew Johnson, Erica Sadun<br>&gt;&gt;&gt; Status: TBD<br>&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This proposal introduces a new keyword that provides consistent invariant type semantics in all contexts.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The Swift-evolution thread about this topic can be found here: [RFC] #Self<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The distinction between covariant and non-covariant type references come into play when<br>&gt;&gt;&gt; conforming non-final classes to protocols. Fixing a protocol requirement to a covarying type<br>&gt;&gt;&gt; means that a method returning Self must be overriden by all subclasses in order to return<br>&gt;&gt;&gt; the correct, matching type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This proposal builds on the covariant construct Self accepted in SE–0068<br>&gt;&gt;&gt; to introduce an invariant type identifier. It enables protocol declarations to consistently<br>&gt;&gt;&gt; refer to a type that is fixed at compile time. This ensures that subclasses can inherit<br>&gt;&gt;&gt; protocol implementations without having to re-implement that code at each level of<br>&gt;&gt;&gt; inheritance.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Under this proposal, a new identifier keyword is fixed in use at the point of protocol conformance<br>&gt;&gt;&gt; to the static type of that construct. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class A: MyProtocol<br>&gt;&gt;&gt; The invariant StaticSelf identifier will always refer to A, unlike Self, which is covarying and refers to<br>&gt;&gt;&gt; the type of the actual instance. Since multiple inheritance for non-protocol types is disallowed,<br>&gt;&gt;&gt; this establishes this invariant type identifier with no possibility for conflict.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Consider the following example, under the current system:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol StringCreatable {<br>&gt;&gt;&gt;     static func createWithString(s: String) -&gt; Self<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension NSURL: StringCreatable {<br>&gt;&gt;&gt;  // cannot conform because NSURL is non-final<br>&gt;&gt;&gt;  // error: method &#39;createWithString&#39; in non-final class &#39;NSURL&#39; must return `Self` to conform to protocol &#39;A&#39;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; Introducing a static, invariant version of Self permits the desired conformance:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol StringCreatable {<br>&gt;&gt;&gt;     static func createWithString(s: String) -&gt; StaticSelf<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension NSURL: StringCreatable {<br>&gt;&gt;&gt;  // can now conform conform because NSURL is fixed and matches the static<br>&gt;&gt;&gt;  // type of the conforming construct. Subclasses need not re-implement<br>&gt;&gt;&gt;  // NOTE: the return type can be declared as StaticSelf *or* as NSURL<br>&gt;&gt;&gt;  //       they are interchangeable<br>&gt;&gt;&gt;  static func createWithString(s: String) -&gt; StaticSelf { <br>&gt;&gt;&gt;      // ...<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; Additional Utility<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The utility of StaticSelf is not limited to protocols. A secondary use enables code to refer to the lexical context’s current type without explicitly mentioning its name. This provides a useful shortcut when referencing static type members with especially long names and when re-purposing code between types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class StructWithAVeryLongName {<br>&gt;&gt;&gt;     static func foo() -&gt; String {<br>&gt;&gt;&gt;       // ...<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     func bar() {<br>&gt;&gt;&gt;       // ...<br>&gt;&gt;&gt;       let s = StaticSelf.foo()<br>&gt;&gt;&gt;       //<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; Detailed Design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This proposal introduces StaticSelf, a new keyword that may be used in protocols to refer to the invariant static type of a conforming construct. StaticSelf may also be used in the lexical context of any type declaration. In such use, the keyword is identical to spelling out the full name of that type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Being additive, there should be no impact on existing code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alternatives considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The keyword is not fixed at this time. Alternatives that have been discussed include StaticType, InvariantSelf, SelfType, or Type. The community is welcome to bikeshed on the most clear and concise name for this keyword.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/66aa88e0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Draft] Introducing StaticSelf, an Invariant Self</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 13, 2016 at 02:00:00pm</p></header><div class="content"><p>I don&#39;t understand.<br>Right now we are allowed to have Optional(Self) :<br></p><p>protocol A {<br>   func g()-&gt;Self?<br>}<br></p><p>class B: A {<br>   func g()-&gt;Self? {return self}<br>}<br></p><p>print(B().g()) //Optional(main.B)<br></p><p>How do you want to divide your `-&gt;Self?` and this currently possible <br>`-&gt;Self?` ?<br></p><p><br>But I do like the idea to separate meaning of `Self` in protocol with some <br>marker.. What about `-&gt;?Self` and `-&gt;!Self` - no confusing with Optional&lt;&gt;<br></p><p>On 13.05.2016 14:21, LM via swift-evolution wrote:<br>&gt;<br>&gt; The other advantage of Self! over StaticSelf is that in code completion,<br>&gt; Self, Self? Self! Will come together, giving people a quick tool to<br>&gt; discover/remind themselves of the semantic difference right at the point of<br>&gt; use.<br>&gt;<br>&gt; It might also address Joe&#39;s comment about StaticSelf not being much of a<br>&gt; shortcut.<br>&gt;<br>&gt;<br>&gt; On May 13, 2016, at 1:15 PM, LM &lt;laurent.mihalkovic at gmail.com<br>&gt; &lt;mailto:laurent.mihalkovic at gmail.com&gt;&gt; wrote:<br>&gt;<br>&gt;&gt; Considering the precedent of using ! and ? in swift, could it be that:<br>&gt;&gt;<br>&gt;&gt; Self!  would designate what is known for sure, the invariant compile time<br>&gt;&gt; type of self<br>&gt;&gt;<br>&gt;&gt; Self? Would designate the yet unknown (*optional* if you will) covariant<br>&gt;&gt; type of self<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Regards<br>&gt;&gt; LM<br>&gt;&gt; (From mobile)<br>&gt;&gt;<br>&gt;&gt; On May 13, 2016, at 3:59 AM, Xiaodi Wu via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; I like the way the motivation for this feature has been explained here.<br>&gt;&gt;&gt; Now that the reasoning behind it is evident, I have to say I&#39;m leaning<br>&gt;&gt;&gt; towards the &quot;InvariantSelf&quot; name--after all, you describe this feature<br>&gt;&gt;&gt; in the title as &quot;an invariant self.&quot;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Thu, May 12, 2016 at 7:49 PM, Matthew Johnson via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     Erica Sadun and I have written a proposal are following up the<br>&gt;&gt;&gt;     recent discussion thread &quot;[RFC] #Self” with a proposal to introduce<br>&gt;&gt;&gt;     StaticSelf, an invariant Self.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     The recent discussion can be found<br>&gt;&gt;&gt;     here: http://thread.gmane.org/gmane.comp.lang.swift.evolution/16565<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     The proposal can be found<br>&gt;&gt;&gt;     here: https://github.com/anandabits/swift-evolution/blob/static-self/proposals/NNNN-static-self.md<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     We look forward to continuing the discussion.  We plan to submit a<br>&gt;&gt;&gt;     PR in the near future after incorporating your final feedback.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     Thanks,<br>&gt;&gt;&gt;     Matthew<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;       Introducing StaticSelf, an Invariant Self<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;       * Proposal: TBD<br>&gt;&gt;&gt;       * Authors: Matthew Johnson &lt;https://github.com/anandabits&gt;, Erica<br>&gt;&gt;&gt;         Sadun &lt;https://github.com/erica&gt;<br>&gt;&gt;&gt;       * Status: TBD<br>&gt;&gt;&gt;       * Review manager: TBD<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         Introduction<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     This proposal introduces a new keyword that provides consistent<br>&gt;&gt;&gt;     invariant type semantics in all contexts.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     /The Swift-evolution thread about this topic can be found<br>&gt;&gt;&gt;     here: [RFC] #Self<br>&gt;&gt;&gt;     &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/16565&gt;/<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         Motivation<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     The distinction between covariant and non-covariant type references<br>&gt;&gt;&gt;     come into play when<br>&gt;&gt;&gt;     conforming non-final classes to protocols. Fixing a protocol<br>&gt;&gt;&gt;     requirement to a covarying type<br>&gt;&gt;&gt;     means that a method returning |Self| must be overriden by all<br>&gt;&gt;&gt;     subclasses in order to return<br>&gt;&gt;&gt;     the correct, matching type.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     This proposal builds on the covariant construct |Self| accepted<br>&gt;&gt;&gt;     in SE–0068<br>&gt;&gt;&gt;     &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0068-universal-self.md&gt;<br>&gt;&gt;&gt;     to introduce an invariant type identifier. It enables protocol<br>&gt;&gt;&gt;     declarations to consistently<br>&gt;&gt;&gt;     refer to a type that is fixed at compile time. This ensures that<br>&gt;&gt;&gt;     subclasses can inherit<br>&gt;&gt;&gt;     protocol implementations without having to re-implement that code at<br>&gt;&gt;&gt;     each level of<br>&gt;&gt;&gt;     inheritance.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     Under this proposal, a new identifier keyword is fixed in use /at<br>&gt;&gt;&gt;     the point of protocol conformance/<br>&gt;&gt;&gt;     to the static type of that construct.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     |class A: MyProtocol|<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     The invariant |StaticSelf| identifier will always refer to |A|,<br>&gt;&gt;&gt;     unlike |Self|, which is covarying and refers to<br>&gt;&gt;&gt;     the type of the actual instance. Since multiple inheritance for<br>&gt;&gt;&gt;     non-protocol types is disallowed,<br>&gt;&gt;&gt;     this establishes this invariant type identifier with no possibility<br>&gt;&gt;&gt;     for conflict.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     Consider the following example, under the current system:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     |protocol StringCreatable { static func createWithString(s: String)<br>&gt;&gt;&gt;     -&gt; Self } extension NSURL: StringCreatable { // cannot conform<br>&gt;&gt;&gt;     because NSURL is non-final // error: method &#39;createWithString&#39; in<br>&gt;&gt;&gt;     non-final class &#39;NSURL&#39; must return `Self` to conform to protocol &#39;A&#39; }|<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     Introducing a static, invariant version of |Self| permits the<br>&gt;&gt;&gt;     desired conformance:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     |protocol StringCreatable { static func createWithString(s: String)<br>&gt;&gt;&gt;     -&gt; StaticSelf } extension NSURL: StringCreatable { // can now<br>&gt;&gt;&gt;     conform conform because NSURL is fixed and matches the static //<br>&gt;&gt;&gt;     type of the conforming construct. Subclasses need not re-implement<br>&gt;&gt;&gt;     // NOTE: the return type can be declared as StaticSelf *or* as NSURL<br>&gt;&gt;&gt;     // they are interchangeable static func createWithString(s: String)<br>&gt;&gt;&gt;     -&gt; StaticSelf { // ... } }|<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;           Additional Utility<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     The utility of |StaticSelf| is not limited to protocols. A secondary<br>&gt;&gt;&gt;     use enables code to refer to the lexical context’s current type<br>&gt;&gt;&gt;     without explicitly mentioning its name. This provides a useful<br>&gt;&gt;&gt;     shortcut when referencing static type members with especially long<br>&gt;&gt;&gt;     names and when re-purposing code between types.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     |class StructWithAVeryLongName { static func foo() -&gt; String { // ...<br>&gt;&gt;&gt;     } func bar() { // ... let s = StaticSelf.foo() // } }|<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         Detailed Design<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     This proposal introduces |StaticSelf|, a new keyword that may be<br>&gt;&gt;&gt;     used in protocols to refer to the invariant static type of a<br>&gt;&gt;&gt;     conforming construct. |StaticSelf| may also be used in the lexical<br>&gt;&gt;&gt;     context of any type declaration. In such use, the keyword is<br>&gt;&gt;&gt;     identical to spelling out the full name of that type.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         Impact on existing code<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     Being additive, there should be no impact on existing code.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         Alternatives considered<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     The keyword is not fixed at this time. Alternatives that have been<br>&gt;&gt;&gt;     discussed include |StaticType|, |InvariantSelf|, |SelfType|,<br>&gt;&gt;&gt;     or |Type|. The community is welcome to bikeshed on the most clear<br>&gt;&gt;&gt;     and concise name for this keyword.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     _______________________________________________<br>&gt;&gt;&gt;     swift-evolution mailing list<br>&gt;&gt;&gt;     swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Draft] Introducing StaticSelf, an Invariant Self</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 13, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On May 13, 2016, at 1:26 PM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt; <br>&gt; I don&#39;t understand.<br>&gt; Right now we are allowed to have Optional(Self) :<br>&gt; <br>&gt; protocol A {<br>&gt;  func g()-&gt;Self?<br>&gt; }<br>&gt; <br>&gt; class B: A {<br>&gt;  func g()-&gt;Self? {return self}<br>&gt; }<br>&gt; <br>&gt; print(B().g()) //Optional(main.B)<br>&gt; <br>&gt; How do you want to divide your `-&gt;Self?` and this currently possible `-&gt;Self?` ?<br>&gt; <br>&gt; <br>&gt; But I do like the idea to separate meaning of `Self` in protocol with some marker.. What about `-&gt;?Self` and `-&gt;!Self` - no confusing with Optional&lt;&gt;<br></p><p>My idea was to keep the markers at the end, rather than as a prefix (Lexer will thank you for it), such that in code completion they would be together, but your idea has some appeal.<br>Especially if the argument is made that the IDE should be smart enough to &#39;cleanup&#39; the list meaningfully, which I would expect coming from a decade of java as I do (at the risk of sounding critical, I am still rather put-off by the crude state of text editing in the obj-c/swift world). Although in fairness, mike &amp; team have done marvels these last couple years.<br></p><p><br>&gt; <br>&gt;&gt; On 13.05.2016 14:21, LM via swift-evolution wrote:<br>&gt;&gt; <br>&gt;&gt; The other advantage of Self! over StaticSelf is that in code completion,<br>&gt;&gt; Self, Self? Self! Will come together, giving people a quick tool to<br>&gt;&gt; discover/remind themselves of the semantic difference right at the point of<br>&gt;&gt; use.<br>&gt;&gt; <br>&gt;&gt; It might also address Joe&#39;s comment about StaticSelf not being much of a<br>&gt;&gt; shortcut.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On May 13, 2016, at 1:15 PM, LM &lt;laurent.mihalkovic at gmail.com<br>&gt;&gt; &lt;mailto:laurent.mihalkovic at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Considering the precedent of using ! and ? in swift, could it be that:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Self!  would designate what is known for sure, the invariant compile time<br>&gt;&gt;&gt; type of self<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Self? Would designate the yet unknown (*optional* if you will) covariant<br>&gt;&gt;&gt; type of self<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Regards<br>&gt;&gt;&gt; LM<br>&gt;&gt;&gt; (From mobile)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On May 13, 2016, at 3:59 AM, Xiaodi Wu via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I like the way the motivation for this feature has been explained here.<br>&gt;&gt;&gt;&gt; Now that the reasoning behind it is evident, I have to say I&#39;m leaning<br>&gt;&gt;&gt;&gt; towards the &quot;InvariantSelf&quot; name--after all, you describe this feature<br>&gt;&gt;&gt;&gt; in the title as &quot;an invariant self.&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Thu, May 12, 2016 at 7:49 PM, Matthew Johnson via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    Erica Sadun and I have written a proposal are following up the<br>&gt;&gt;&gt;&gt;    recent discussion thread &quot;[RFC] #Self” with a proposal to introduce<br>&gt;&gt;&gt;&gt;    StaticSelf, an invariant Self.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    The recent discussion can be found<br>&gt;&gt;&gt;&gt;    here: http://thread.gmane.org/gmane.comp.lang.swift.evolution/16565<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    The proposal can be found<br>&gt;&gt;&gt;&gt;    here: https://github.com/anandabits/swift-evolution/blob/static-self/proposals/NNNN-static-self.md<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    We look forward to continuing the discussion.  We plan to submit a<br>&gt;&gt;&gt;&gt;    PR in the near future after incorporating your final feedback.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    Thanks,<br>&gt;&gt;&gt;&gt;    Matthew<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;      Introducing StaticSelf, an Invariant Self<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;      * Proposal: TBD<br>&gt;&gt;&gt;&gt;      * Authors: Matthew Johnson &lt;https://github.com/anandabits&gt;, Erica<br>&gt;&gt;&gt;&gt;        Sadun &lt;https://github.com/erica&gt;<br>&gt;&gt;&gt;&gt;      * Status: TBD<br>&gt;&gt;&gt;&gt;      * Review manager: TBD<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;        Introduction<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    This proposal introduces a new keyword that provides consistent<br>&gt;&gt;&gt;&gt;    invariant type semantics in all contexts.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    /The Swift-evolution thread about this topic can be found<br>&gt;&gt;&gt;&gt;    here: [RFC] #Self<br>&gt;&gt;&gt;&gt;    &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/16565&gt;/<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;        Motivation<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    The distinction between covariant and non-covariant type references<br>&gt;&gt;&gt;&gt;    come into play when<br>&gt;&gt;&gt;&gt;    conforming non-final classes to protocols. Fixing a protocol<br>&gt;&gt;&gt;&gt;    requirement to a covarying type<br>&gt;&gt;&gt;&gt;    means that a method returning |Self| must be overriden by all<br>&gt;&gt;&gt;&gt;    subclasses in order to return<br>&gt;&gt;&gt;&gt;    the correct, matching type.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    This proposal builds on the covariant construct |Self| accepted<br>&gt;&gt;&gt;&gt;    in SE–0068<br>&gt;&gt;&gt;&gt;    &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0068-universal-self.md&gt;<br>&gt;&gt;&gt;&gt;    to introduce an invariant type identifier. It enables protocol<br>&gt;&gt;&gt;&gt;    declarations to consistently<br>&gt;&gt;&gt;&gt;    refer to a type that is fixed at compile time. This ensures that<br>&gt;&gt;&gt;&gt;    subclasses can inherit<br>&gt;&gt;&gt;&gt;    protocol implementations without having to re-implement that code at<br>&gt;&gt;&gt;&gt;    each level of<br>&gt;&gt;&gt;&gt;    inheritance.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    Under this proposal, a new identifier keyword is fixed in use /at<br>&gt;&gt;&gt;&gt;    the point of protocol conformance/<br>&gt;&gt;&gt;&gt;    to the static type of that construct.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    |class A: MyProtocol|<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    The invariant |StaticSelf| identifier will always refer to |A|,<br>&gt;&gt;&gt;&gt;    unlike |Self|, which is covarying and refers to<br>&gt;&gt;&gt;&gt;    the type of the actual instance. Since multiple inheritance for<br>&gt;&gt;&gt;&gt;    non-protocol types is disallowed,<br>&gt;&gt;&gt;&gt;    this establishes this invariant type identifier with no possibility<br>&gt;&gt;&gt;&gt;    for conflict.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    Consider the following example, under the current system:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    |protocol StringCreatable { static func createWithString(s: String)<br>&gt;&gt;&gt;&gt;    -&gt; Self } extension NSURL: StringCreatable { // cannot conform<br>&gt;&gt;&gt;&gt;    because NSURL is non-final // error: method &#39;createWithString&#39; in<br>&gt;&gt;&gt;&gt;    non-final class &#39;NSURL&#39; must return `Self` to conform to protocol &#39;A&#39; }|<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    Introducing a static, invariant version of |Self| permits the<br>&gt;&gt;&gt;&gt;    desired conformance:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    |protocol StringCreatable { static func createWithString(s: String)<br>&gt;&gt;&gt;&gt;    -&gt; StaticSelf } extension NSURL: StringCreatable { // can now<br>&gt;&gt;&gt;&gt;    conform conform because NSURL is fixed and matches the static //<br>&gt;&gt;&gt;&gt;    type of the conforming construct. Subclasses need not re-implement<br>&gt;&gt;&gt;&gt;    // NOTE: the return type can be declared as StaticSelf *or* as NSURL<br>&gt;&gt;&gt;&gt;    // they are interchangeable static func createWithString(s: String)<br>&gt;&gt;&gt;&gt;    -&gt; StaticSelf { // ... } }|<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;          Additional Utility<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    The utility of |StaticSelf| is not limited to protocols. A secondary<br>&gt;&gt;&gt;&gt;    use enables code to refer to the lexical context’s current type<br>&gt;&gt;&gt;&gt;    without explicitly mentioning its name. This provides a useful<br>&gt;&gt;&gt;&gt;    shortcut when referencing static type members with especially long<br>&gt;&gt;&gt;&gt;    names and when re-purposing code between types.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    |class StructWithAVeryLongName { static func foo() -&gt; String { // ...<br>&gt;&gt;&gt;&gt;    } func bar() { // ... let s = StaticSelf.foo() // } }|<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;        Detailed Design<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    This proposal introduces |StaticSelf|, a new keyword that may be<br>&gt;&gt;&gt;&gt;    used in protocols to refer to the invariant static type of a<br>&gt;&gt;&gt;&gt;    conforming construct. |StaticSelf| may also be used in the lexical<br>&gt;&gt;&gt;&gt;    context of any type declaration. In such use, the keyword is<br>&gt;&gt;&gt;&gt;    identical to spelling out the full name of that type.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;        Impact on existing code<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    Being additive, there should be no impact on existing code.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;        Alternatives considered<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    The keyword is not fixed at this time. Alternatives that have been<br>&gt;&gt;&gt;&gt;    discussed include |StaticType|, |InvariantSelf|, |SelfType|,<br>&gt;&gt;&gt;&gt;    or |Type|. The community is welcome to bikeshed on the most clear<br>&gt;&gt;&gt;&gt;    and concise name for this keyword.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    _______________________________________________<br>&gt;&gt;&gt;&gt;    swift-evolution mailing list<br>&gt;&gt;&gt;&gt;    swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;    https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Draft] Introducing StaticSelf, an Invariant Self</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>May 12, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On May 12, 2016, at 5:49 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The invariant StaticSelf identifier will always refer to A, unlike Self, which is covarying and refers to<br>&gt; the type of the actual instance. Since multiple inheritance for non-protocol types is disallowed,<br>&gt; this establishes this invariant type identifier with no possibility for conflict.<br>&gt; <br>&gt; Consider the following example, under the current system:<br>&gt; <br>&gt; protocol StringCreatable <br>&gt; {<br>&gt;     <br>&gt; static func createWithString(s: String) -&gt; Self<br>&gt; <br>&gt; }<br>&gt; <br>&gt; <br>&gt; extension NSURL: StringCreatable <br>&gt; {<br>&gt;  <br>&gt; // cannot conform because NSURL is non-final<br>&gt; <br>&gt;  <br>&gt; // error: method &#39;createWithString&#39; in non-final class &#39;NSURL&#39; must return `Self` to conform to protocol &#39;A&#39;<br>&gt; <br>&gt; }<br>&gt; <br>&gt; Introducing a static, invariant version of Self permits the desired conformance:<br>&gt; <br>&gt; protocol StringCreatable <br>&gt; {<br>&gt;     <br>&gt; static func createWithString(s: String) -&gt; StaticSelf<br>&gt; <br>&gt; }<br>&gt; <br>&gt; <br>&gt; extension NSURL: StringCreatable <br>&gt; {<br>&gt;  <br>&gt; // can now conform conform because NSURL is fixed and matches the static<br>&gt; <br>&gt;  <br>&gt; // type of the conforming construct. Subclasses need not re-implement<br>&gt; <br>&gt;  <br>&gt; // NOTE: the return type can be declared as StaticSelf *or* as NSURL<br>&gt; <br>&gt;  <br>&gt; //       they are interchangeable<br>&gt; <br>&gt;  <br>&gt; static func createWithString(s: String) -&gt; StaticSelf<br>&gt;  { <br>&gt;      <br>&gt; // ...<br>&gt; <br>&gt;  }<br>&gt; }<br>&gt; <br>&gt; <br></p><p>As I&#39;ve noted before, I don&#39;t think this makes sense to encode in the protocol. `Self` is already effectively invariant within a protocol. If a protocol doesn&#39;t have the foresight to use StaticSelf, then you still have the same problems retroactively conforming class hierarchies to the protocol. Whether a conformance is inherited or not feels more natural as a property of a conformance, not something that can be legislated a priori by a protocol definition.<br></p><p>Something like StaticSelf might still be useful as shorthand within a class definition with a long-winded name, though `StaticSelf` feels kind of long as a shortcut to me.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[Draft] Introducing StaticSelf, an Invariant Self</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>May 13, 2016 at 02:00:00pm</p></header><div class="content"><p>I didn’t really understand some of the lead in discussion examples regarding protocols A and B each being interwoven, but I would prefer to see StaticSelf only used for concrete types, and protocols only to use Self. If Self has problems with non-final classes, then maybe how it works in protocols could change. A class could interpret a protocol’s ‘Self’ as ‘myself or my subclasses’?<br></p><p>Maybe instead of introducing StaticSelf it could be renamed simply Self, and ‘Self’ as used in protocols could change to something else? ‘Instance’ perhaps?<br></p><p>&gt; On 13 May 2016, at 12:21 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 12, 2016, at 5:49 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The invariant StaticSelf identifier will always refer to A, unlike Self, which is covarying and refers to<br>&gt;&gt; the type of the actual instance. Since multiple inheritance for non-protocol types is disallowed,<br>&gt;&gt; this establishes this invariant type identifier with no possibility for conflict.<br>&gt;&gt; <br>&gt;&gt; Consider the following example, under the current system:<br>&gt;&gt; <br>&gt;&gt; protocol StringCreatable <br>&gt;&gt; {<br>&gt;&gt; <br>&gt;&gt; static func createWithString(s: String) -&gt; Self<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; extension NSURL: StringCreatable <br>&gt;&gt; {<br>&gt;&gt; <br>&gt;&gt; // cannot conform because NSURL is non-final<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; // error: method &#39;createWithString&#39; in non-final class &#39;NSURL&#39; must return `Self` to conform to protocol &#39;A&#39;<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Introducing a static, invariant version of Self permits the desired conformance:<br>&gt;&gt; <br>&gt;&gt; protocol StringCreatable <br>&gt;&gt; {<br>&gt;&gt; <br>&gt;&gt; static func createWithString(s: String) -&gt; StaticSelf<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; extension NSURL: StringCreatable <br>&gt;&gt; {<br>&gt;&gt; <br>&gt;&gt; // can now conform conform because NSURL is fixed and matches the static<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; // type of the conforming construct. Subclasses need not re-implement<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; // NOTE: the return type can be declared as StaticSelf *or* as NSURL<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; //       they are interchangeable<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; static func createWithString(s: String) -&gt; StaticSelf<br>&gt;&gt; { <br>&gt;&gt; <br>&gt;&gt; // ...<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; As I&#39;ve noted before, I don&#39;t think this makes sense to encode in the protocol. `Self` is already effectively invariant within a protocol. If a protocol doesn&#39;t have the foresight to use StaticSelf, then you still have the same problems retroactively conforming class hierarchies to the protocol. Whether a conformance is inherited or not feels more natural as a property of a conformance, not something that can be legislated a priori by a protocol definition.<br>&gt; <br>&gt; Something like StaticSelf might still be useful as shorthand within a class definition with a long-winded name, though `StaticSelf` feels kind of long as a shortcut to me.<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Draft] Introducing StaticSelf, an Invariant Self</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 13, 2016 at 09:00:00am</p></header><div class="content"><p>The proposed StaticSelf when used as `-&gt;StaticSelf` in protocol means <br>‘myself or my some *base* class’. I.e. if this requirement was implemented <br>in one of base classes, any subclass automatically conforms to the protocol <br>as it has `-&gt;(myself or some base class)` in his hierarchy.<br></p><p>This is the difference with `-&gt;Self` in protocol which requires &#39;myself&#39;.<br></p><p>On 13.05.2016 7:21, Patrick Smith via swift-evolution wrote:<br>&gt; I didn’t really understand some of the lead in discussion examples<br>&gt; regarding protocols A and B each being interwoven, but I would prefer to<br>&gt; see StaticSelf only used for concrete types, and protocols only to use<br>&gt; Self. If Self has problems with non-final classes, then maybe how it<br>&gt; works in protocols could change. A class could interpret a protocol’s<br>&gt; ‘Self’ as ‘myself or my subclasses’?<br>&gt;<br>&gt; Maybe instead of introducing StaticSelf it could be renamed simply Self,<br>&gt; and ‘Self’ as used in protocols could change to something else?<br>&gt; ‘Instance’ perhaps?<br>&gt;<br>&gt;&gt; On 13 May 2016, at 12:21 PM, Joe Groff via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; On May 12, 2016, at 5:49 PM, Matthew Johnson via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The invariant StaticSelf identifier will always refer to A, unlike<br>&gt;&gt;&gt; Self, which is covarying and refers to the type of the actual<br>&gt;&gt;&gt; instance. Since multiple inheritance for non-protocol types is<br>&gt;&gt;&gt; disallowed, this establishes this invariant type identifier with no<br>&gt;&gt;&gt; possibility for conflict.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Consider the following example, under the current system:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; protocol StringCreatable {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; static func createWithString(s: String) -&gt; Self<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; extension NSURL: StringCreatable {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; // cannot conform because NSURL is non-final<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; // error: method &#39;createWithString&#39; in non-final class &#39;NSURL&#39; must<br>&gt;&gt;&gt; return `Self` to conform to protocol &#39;A&#39;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Introducing a static, invariant version of Self permits the desired<br>&gt;&gt;&gt; conformance:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; protocol StringCreatable {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; static func createWithString(s: String) -&gt; StaticSelf<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; extension NSURL: StringCreatable {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; // can now conform conform because NSURL is fixed and matches the<br>&gt;&gt;&gt; static<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; // type of the conforming construct. Subclasses need not<br>&gt;&gt;&gt; re-implement<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; // NOTE: the return type can be declared as StaticSelf *or* as<br>&gt;&gt;&gt; NSURL<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; //       they are interchangeable<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; static func createWithString(s: String) -&gt; StaticSelf {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; // ...<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; } }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; As I&#39;ve noted before, I don&#39;t think this makes sense to encode in the<br>&gt;&gt; protocol. `Self` is already effectively invariant within a protocol.<br>&gt;&gt; If a protocol doesn&#39;t have the foresight to use StaticSelf, then you<br>&gt;&gt; still have the same problems retroactively conforming class<br>&gt;&gt; hierarchies to the protocol. Whether a conformance is inherited or not<br>&gt;&gt; feels more natural as a property of a conformance, not something that<br>&gt;&gt; can be legislated a priori by a protocol definition.<br>&gt;&gt;<br>&gt;&gt; Something like StaticSelf might still be useful as shorthand within a<br>&gt;&gt; class definition with a long-winded name, though `StaticSelf` feels<br>&gt;&gt; kind of long as a shortcut to me.<br>&gt;&gt;<br>&gt;&gt; -Joe _______________________________________________ swift-evolution<br>&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________ swift-evolution mailing<br>&gt; list swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[Draft] Introducing StaticSelf, an Invariant Self</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>May 13, 2016 at 04:00:00pm</p></header><div class="content"><p>Could protocol Self change to just the first behaviour for classes?<br></p><p>If a conformance absolutely needs to have a method returning ‘only me but not my subclasses’, then it sets that conforming method to be final.<br></p><p><br>&gt; On 13 May 2016, at 4:38 PM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt; <br>&gt; The proposed StaticSelf when used as `-&gt;StaticSelf` in protocol means ‘myself or my some *base* class’. I.e. if this requirement was implemented in one of base classes, any subclass automatically conforms to the protocol as it has `-&gt;(myself or some base class)` in his hierarchy.<br>&gt; <br>&gt; This is the difference with `-&gt;Self` in protocol which requires &#39;myself&#39;.<br>&gt; <br>&gt; On 13.05.2016 7:21, Patrick Smith via swift-evolution wrote:<br>&gt;&gt; I didn’t really understand some of the lead in discussion examples<br>&gt;&gt; regarding protocols A and B each being interwoven, but I would prefer to<br>&gt;&gt; see StaticSelf only used for concrete types, and protocols only to use<br>&gt;&gt; Self. If Self has problems with non-final classes, then maybe how it<br>&gt;&gt; works in protocols could change. A class could interpret a protocol’s<br>&gt;&gt; ‘Self’ as ‘myself or my subclasses’?<br>&gt;&gt; <br>&gt;&gt; Maybe instead of introducing StaticSelf it could be renamed simply Self,<br>&gt;&gt; and ‘Self’ as used in protocols could change to something else?<br>&gt;&gt; ‘Instance’ perhaps?<br>&gt;&gt; <br>&gt;&gt;&gt; On 13 May 2016, at 12:21 PM, Joe Groff via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 12, 2016, at 5:49 PM, Matthew Johnson via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The invariant StaticSelf identifier will always refer to A, unlike<br>&gt;&gt;&gt;&gt; Self, which is covarying and refers to the type of the actual<br>&gt;&gt;&gt;&gt; instance. Since multiple inheritance for non-protocol types is<br>&gt;&gt;&gt;&gt; disallowed, this establishes this invariant type identifier with no<br>&gt;&gt;&gt;&gt; possibility for conflict.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Consider the following example, under the current system:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol StringCreatable {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; static func createWithString(s: String) -&gt; Self<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension NSURL: StringCreatable {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // cannot conform because NSURL is non-final<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // error: method &#39;createWithString&#39; in non-final class &#39;NSURL&#39; must<br>&gt;&gt;&gt;&gt; return `Self` to conform to protocol &#39;A&#39;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Introducing a static, invariant version of Self permits the desired<br>&gt;&gt;&gt;&gt; conformance:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol StringCreatable {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; static func createWithString(s: String) -&gt; StaticSelf<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension NSURL: StringCreatable {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // can now conform conform because NSURL is fixed and matches the<br>&gt;&gt;&gt;&gt; static<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // type of the conforming construct. Subclasses need not<br>&gt;&gt;&gt;&gt; re-implement<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // NOTE: the return type can be declared as StaticSelf *or* as<br>&gt;&gt;&gt;&gt; NSURL<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; //       they are interchangeable<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; static func createWithString(s: String) -&gt; StaticSelf {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // ...<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; } }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As I&#39;ve noted before, I don&#39;t think this makes sense to encode in the<br>&gt;&gt;&gt; protocol. `Self` is already effectively invariant within a protocol.<br>&gt;&gt;&gt; If a protocol doesn&#39;t have the foresight to use StaticSelf, then you<br>&gt;&gt;&gt; still have the same problems retroactively conforming class<br>&gt;&gt;&gt; hierarchies to the protocol. Whether a conformance is inherited or not<br>&gt;&gt;&gt; feels more natural as a property of a conformance, not something that<br>&gt;&gt;&gt; can be legislated a priori by a protocol definition.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Something like StaticSelf might still be useful as shorthand within a<br>&gt;&gt;&gt; class definition with a long-winded name, though `StaticSelf` feels<br>&gt;&gt;&gt; kind of long as a shortcut to me.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe _______________________________________________ swift-evolution<br>&gt;&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________ swift-evolution mailing<br>&gt;&gt; list swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b1fc4ed1ed8e138ef0a87fd3e91c83a4?s=50"></div><header><strong>[Draft] Introducing StaticSelf, an Invariant Self</strong> from <string>Ricardo Parada</string> &lt;rparada at mac.com&gt;<p>May 13, 2016 at 06:00:00am</p></header><div class="content"><p>That makes sense to me. <br></p><p>&gt; On May 13, 2016, at 2:45 AM, Patrick Smith via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; If a conformance absolutely needs to have a method returning ‘only me but not my subclasses’, then it sets that conforming method to be final.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Draft] Introducing StaticSelf, an Invariant Self</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 13, 2016 at 02:00:00pm</p></header><div class="content"><p>On 13.05.2016 9:45, Patrick Smith wrote:<br>&gt; Could protocol Self change to just the first behaviour for classes?<br>&gt;<br>&gt; If a conformance absolutely needs to have a method returning ‘only me but not my subclasses’, then it sets that conforming method to be final.<br></p><p>Hm.. Do we *need* to change `-&gt;Self` behavior? It actually depends on what <br>such requirement will mean for classes. Right now it is &#39;-&gt;return instance <br>of self class&#39;. If we all agree that it should means &#39;-&gt;return instance of <br>self class or of any base class&#39; - then we obviously can require such a <br>change.<br></p><p>&gt;<br>&gt;<br>&gt;&gt; On 13 May 2016, at 4:38 PM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; The proposed StaticSelf when used as `-&gt;StaticSelf` in protocol means ‘myself or my some *base* class’. I.e. if this requirement was implemented in one of base classes, any subclass automatically conforms to the protocol as it has `-&gt;(myself or some base class)` in his hierarchy.<br>&gt;&gt;<br>&gt;&gt; This is the difference with `-&gt;Self` in protocol which requires &#39;myself&#39;.<br>&gt;&gt;<br>&gt;&gt; On 13.05.2016 7:21, Patrick Smith via swift-evolution wrote:<br>&gt;&gt;&gt; I didn’t really understand some of the lead in discussion examples<br>&gt;&gt;&gt; regarding protocols A and B each being interwoven, but I would prefer to<br>&gt;&gt;&gt; see StaticSelf only used for concrete types, and protocols only to use<br>&gt;&gt;&gt; Self. If Self has problems with non-final classes, then maybe how it<br>&gt;&gt;&gt; works in protocols could change. A class could interpret a protocol’s<br>&gt;&gt;&gt; ‘Self’ as ‘myself or my subclasses’?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Maybe instead of introducing StaticSelf it could be renamed simply Self,<br>&gt;&gt;&gt; and ‘Self’ as used in protocols could change to something else?<br>&gt;&gt;&gt; ‘Instance’ perhaps?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On 13 May 2016, at 12:21 PM, Joe Groff via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On May 12, 2016, at 5:49 PM, Matthew Johnson via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; The invariant StaticSelf identifier will always refer to A, unlike<br>&gt;&gt;&gt;&gt;&gt; Self, which is covarying and refers to the type of the actual<br>&gt;&gt;&gt;&gt;&gt; instance. Since multiple inheritance for non-protocol types is<br>&gt;&gt;&gt;&gt;&gt; disallowed, this establishes this invariant type identifier with no<br>&gt;&gt;&gt;&gt;&gt; possibility for conflict.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Consider the following example, under the current system:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; protocol StringCreatable {<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; static func createWithString(s: String) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; extension NSURL: StringCreatable {<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; // cannot conform because NSURL is non-final<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; // error: method &#39;createWithString&#39; in non-final class &#39;NSURL&#39; must<br>&gt;&gt;&gt;&gt;&gt; return `Self` to conform to protocol &#39;A&#39;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Introducing a static, invariant version of Self permits the desired<br>&gt;&gt;&gt;&gt;&gt; conformance:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; protocol StringCreatable {<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; static func createWithString(s: String) -&gt; StaticSelf<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; extension NSURL: StringCreatable {<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; // can now conform conform because NSURL is fixed and matches the<br>&gt;&gt;&gt;&gt;&gt; static<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; // type of the conforming construct. Subclasses need not<br>&gt;&gt;&gt;&gt;&gt; re-implement<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; // NOTE: the return type can be declared as StaticSelf *or* as<br>&gt;&gt;&gt;&gt;&gt; NSURL<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; //       they are interchangeable<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; static func createWithString(s: String) -&gt; StaticSelf {<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; // ...<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; } }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; As I&#39;ve noted before, I don&#39;t think this makes sense to encode in the<br>&gt;&gt;&gt;&gt; protocol. `Self` is already effectively invariant within a protocol.<br>&gt;&gt;&gt;&gt; If a protocol doesn&#39;t have the foresight to use StaticSelf, then you<br>&gt;&gt;&gt;&gt; still have the same problems retroactively conforming class<br>&gt;&gt;&gt;&gt; hierarchies to the protocol. Whether a conformance is inherited or not<br>&gt;&gt;&gt;&gt; feels more natural as a property of a conformance, not something that<br>&gt;&gt;&gt;&gt; can be legislated a priori by a protocol definition.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Something like StaticSelf might still be useful as shorthand within a<br>&gt;&gt;&gt;&gt; class definition with a long-winded name, though `StaticSelf` feels<br>&gt;&gt;&gt;&gt; kind of long as a shortcut to me.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; -Joe _______________________________________________ swift-evolution<br>&gt;&gt;&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________ swift-evolution mailing<br>&gt;&gt;&gt; list swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Draft] Introducing StaticSelf, an Invariant Self</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 13, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On May 13, 2016, at 1:45 AM, Patrick Smith via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Could protocol Self change to just the first behaviour for classes?<br>&gt; <br>&gt; If a conformance absolutely needs to have a method returning ‘only me but not my subclasses’, then it sets that conforming method to be final.<br></p><p>It does not say the method returns “only me but not my subclasses”.  It just says “subclasses are not *required* to return an instance of their own type, the original conforming type is sufficient to meet the requirement”.<br></p><p>This is quite a bit different from a ‘final’ requirement.  Subclasses are allowed to override the implementation if desired.  If they do choose to override the implementation they have more flexibility in *how* to implement it and what signature to expose.  This is exactly the same as a method in Base that is declared as returning Base rather than returning Self. <br></p><p><br>&gt; <br>&gt; <br>&gt;&gt; On 13 May 2016, at 4:38 PM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The proposed StaticSelf when used as `-&gt;StaticSelf` in protocol means ‘myself or my some *base* class’. I.e. if this requirement was implemented in one of base classes, any subclass automatically conforms to the protocol as it has `-&gt;(myself or some base class)` in his hierarchy.<br>&gt;&gt; <br>&gt;&gt; This is the difference with `-&gt;Self` in protocol which requires &#39;myself&#39;.<br>&gt;&gt; <br>&gt;&gt; On 13.05.2016 7:21, Patrick Smith via swift-evolution wrote:<br>&gt;&gt;&gt; I didn’t really understand some of the lead in discussion examples<br>&gt;&gt;&gt; regarding protocols A and B each being interwoven, but I would prefer to<br>&gt;&gt;&gt; see StaticSelf only used for concrete types, and protocols only to use<br>&gt;&gt;&gt; Self. If Self has problems with non-final classes, then maybe how it<br>&gt;&gt;&gt; works in protocols could change. A class could interpret a protocol’s<br>&gt;&gt;&gt; ‘Self’ as ‘myself or my subclasses’?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Maybe instead of introducing StaticSelf it could be renamed simply Self,<br>&gt;&gt;&gt; and ‘Self’ as used in protocols could change to something else?<br>&gt;&gt;&gt; ‘Instance’ perhaps?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 13 May 2016, at 12:21 PM, Joe Groff via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 12, 2016, at 5:49 PM, Matthew Johnson via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The invariant StaticSelf identifier will always refer to A, unlike<br>&gt;&gt;&gt;&gt;&gt; Self, which is covarying and refers to the type of the actual<br>&gt;&gt;&gt;&gt;&gt; instance. Since multiple inheritance for non-protocol types is<br>&gt;&gt;&gt;&gt;&gt; disallowed, this establishes this invariant type identifier with no<br>&gt;&gt;&gt;&gt;&gt; possibility for conflict.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Consider the following example, under the current system:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; protocol StringCreatable {<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; static func createWithString(s: String) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; extension NSURL: StringCreatable {<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // cannot conform because NSURL is non-final<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // error: method &#39;createWithString&#39; in non-final class &#39;NSURL&#39; must<br>&gt;&gt;&gt;&gt;&gt; return `Self` to conform to protocol &#39;A&#39;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Introducing a static, invariant version of Self permits the desired<br>&gt;&gt;&gt;&gt;&gt; conformance:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; protocol StringCreatable {<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; static func createWithString(s: String) -&gt; StaticSelf<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; extension NSURL: StringCreatable {<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // can now conform conform because NSURL is fixed and matches the<br>&gt;&gt;&gt;&gt;&gt; static<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // type of the conforming construct. Subclasses need not<br>&gt;&gt;&gt;&gt;&gt; re-implement<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // NOTE: the return type can be declared as StaticSelf *or* as<br>&gt;&gt;&gt;&gt;&gt; NSURL<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; //       they are interchangeable<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; static func createWithString(s: String) -&gt; StaticSelf {<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // ...<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; } }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As I&#39;ve noted before, I don&#39;t think this makes sense to encode in the<br>&gt;&gt;&gt;&gt; protocol. `Self` is already effectively invariant within a protocol.<br>&gt;&gt;&gt;&gt; If a protocol doesn&#39;t have the foresight to use StaticSelf, then you<br>&gt;&gt;&gt;&gt; still have the same problems retroactively conforming class<br>&gt;&gt;&gt;&gt; hierarchies to the protocol. Whether a conformance is inherited or not<br>&gt;&gt;&gt;&gt; feels more natural as a property of a conformance, not something that<br>&gt;&gt;&gt;&gt; can be legislated a priori by a protocol definition.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Something like StaticSelf might still be useful as shorthand within a<br>&gt;&gt;&gt;&gt; class definition with a long-winded name, though `StaticSelf` feels<br>&gt;&gt;&gt;&gt; kind of long as a shortcut to me.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Joe _______________________________________________ swift-evolution<br>&gt;&gt;&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________ swift-evolution mailing<br>&gt;&gt;&gt; list swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Draft] Introducing StaticSelf, an Invariant Self</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>May 13, 2016 at 08:00:00am</p></header><div class="content"><p>Totally agree. It feels weird to have protocols decide on how &quot;Self&quot; conformance a are inherited. It should a decision for the conforming type.<br></p><p>&gt; On 13 May 2016, at 04:21, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 12, 2016, at 5:49 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The invariant StaticSelf identifier will always refer to A, unlike Self, which is covarying and refers to<br>&gt;&gt; the type of the actual instance. Since multiple inheritance for non-protocol types is disallowed,<br>&gt;&gt; this establishes this invariant type identifier with no possibility for conflict.<br>&gt;&gt; <br>&gt;&gt; Consider the following example, under the current system:<br>&gt;&gt; <br>&gt;&gt; protocol StringCreatable <br>&gt;&gt; {<br>&gt;&gt; <br>&gt;&gt; static func createWithString(s: String) -&gt; Self<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; extension NSURL: StringCreatable <br>&gt;&gt; {<br>&gt;&gt; <br>&gt;&gt; // cannot conform because NSURL is non-final<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; // error: method &#39;createWithString&#39; in non-final class &#39;NSURL&#39; must return `Self` to conform to protocol &#39;A&#39;<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Introducing a static, invariant version of Self permits the desired conformance:<br>&gt;&gt; <br>&gt;&gt; protocol StringCreatable <br>&gt;&gt; {<br>&gt;&gt; <br>&gt;&gt; static func createWithString(s: String) -&gt; StaticSelf<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; extension NSURL: StringCreatable <br>&gt;&gt; {<br>&gt;&gt; <br>&gt;&gt; // can now conform conform because NSURL is fixed and matches the static<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; // type of the conforming construct. Subclasses need not re-implement<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; // NOTE: the return type can be declared as StaticSelf *or* as NSURL<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; //       they are interchangeable<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; static func createWithString(s: String) -&gt; StaticSelf<br>&gt;&gt; { <br>&gt;&gt; <br>&gt;&gt; // ...<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; }<br>&gt; <br>&gt; As I&#39;ve noted before, I don&#39;t think this makes sense to encode in the protocol. `Self` is already effectively invariant within a protocol. If a protocol doesn&#39;t have the foresight to use StaticSelf, then you still have the same problems retroactively conforming class hierarchies to the protocol. Whether a conformance is inherited or not feels more natural as a property of a conformance, not something that can be legislated a priori by a protocol definition.<br>&gt; <br>&gt; Something like StaticSelf might still be useful as shorthand within a class definition with a long-winded name, though `StaticSelf` feels kind of long as a shortcut to me.<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Draft] Introducing StaticSelf, an Invariant Self</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 13, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On May 13, 2016, at 1:26 AM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt; <br>&gt; Totally agree. It feels weird to have protocols decide on how &quot;Self&quot; conformance a are inherited. It should a decision for the conforming type.<br></p><p>Do you have any suggestions on how we allow the conforming type to make that decision?  Last time we had that discussion it didn’t produce clear answer.  It turns out there is quite a bit of complexity involved in doing this.<br></p><p>&gt; <br>&gt;&gt; On 13 May 2016, at 04:21, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 12, 2016, at 5:49 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The invariant StaticSelf identifier will always refer to A, unlike Self, which is covarying and refers to<br>&gt;&gt;&gt; the type of the actual instance. Since multiple inheritance for non-protocol types is disallowed,<br>&gt;&gt;&gt; this establishes this invariant type identifier with no possibility for conflict.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Consider the following example, under the current system:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol StringCreatable <br>&gt;&gt;&gt; {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; static func createWithString(s: String) -&gt; Self<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension NSURL: StringCreatable <br>&gt;&gt;&gt; {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // cannot conform because NSURL is non-final<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // error: method &#39;createWithString&#39; in non-final class &#39;NSURL&#39; must return `Self` to conform to protocol &#39;A&#39;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Introducing a static, invariant version of Self permits the desired conformance:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol StringCreatable <br>&gt;&gt;&gt; {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; static func createWithString(s: String) -&gt; StaticSelf<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension NSURL: StringCreatable <br>&gt;&gt;&gt; {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // can now conform conform because NSURL is fixed and matches the static<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // type of the conforming construct. Subclasses need not re-implement<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // NOTE: the return type can be declared as StaticSelf *or* as NSURL<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; //       they are interchangeable<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; static func createWithString(s: String) -&gt; StaticSelf<br>&gt;&gt;&gt; { <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // ...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; As I&#39;ve noted before, I don&#39;t think this makes sense to encode in the protocol. `Self` is already effectively invariant within a protocol. If a protocol doesn&#39;t have the foresight to use StaticSelf, then you still have the same problems retroactively conforming class hierarchies to the protocol. Whether a conformance is inherited or not feels more natural as a property of a conformance, not something that can be legislated a priori by a protocol definition.<br>&gt;&gt; <br>&gt;&gt; Something like StaticSelf might still be useful as shorthand within a class definition with a long-winded name, though `StaticSelf` feels kind of long as a shortcut to me.<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Draft] Introducing StaticSelf, an Invariant Self</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 13, 2016 at 09:00:00am</p></header><div class="content"><p>How about BaseType? (as just `Type` can not be used here) Or ThisType?<br></p><p>And, do you think we actually should use `#` here in analogue to #file as <br>this `StaticSelf` will be pre-processed on compilation stage to be replaced <br>with actual type name?<br></p><p>On 13.05.2016 5:21, Joe Groff via swift-evolution wrote:<br>&gt; Something like StaticSelf might still be useful as shorthand within a class definition with a long-winded name, though `StaticSelf` feels kind of long as a shortcut to me.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Draft] Introducing StaticSelf, an Invariant Self</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 13, 2016 at 10:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 12, 2016, at 9:21 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 12, 2016, at 5:49 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The invariant StaticSelf identifier will always refer to A, unlike Self, which is covarying and refers to<br>&gt;&gt; the type of the actual instance. Since multiple inheritance for non-protocol types is disallowed,<br>&gt;&gt; this establishes this invariant type identifier with no possibility for conflict.<br>&gt;&gt; <br>&gt;&gt; Consider the following example, under the current system:<br>&gt;&gt; <br>&gt;&gt; protocol StringCreatable <br>&gt;&gt; {<br>&gt;&gt; <br>&gt;&gt; static func createWithString(s: String) -&gt; Self<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; extension NSURL: StringCreatable <br>&gt;&gt; {<br>&gt;&gt; <br>&gt;&gt; // cannot conform because NSURL is non-final<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; // error: method &#39;createWithString&#39; in non-final class &#39;NSURL&#39; must return `Self` to conform to protocol &#39;A&#39;<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Introducing a static, invariant version of Self permits the desired conformance:<br>&gt;&gt; <br>&gt;&gt; protocol StringCreatable <br>&gt;&gt; {<br>&gt;&gt; <br>&gt;&gt; static func createWithString(s: String) -&gt; StaticSelf<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; extension NSURL: StringCreatable <br>&gt;&gt; {<br>&gt;&gt; <br>&gt;&gt; // can now conform conform because NSURL is fixed and matches the static<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; // type of the conforming construct. Subclasses need not re-implement<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; // NOTE: the return type can be declared as StaticSelf *or* as NSURL<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; //       they are interchangeable<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; static func createWithString(s: String) -&gt; StaticSelf<br>&gt;&gt; { <br>&gt;&gt; <br>&gt;&gt; // ...<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; }<br>&gt; <br>&gt; As I&#39;ve noted before, I don&#39;t think this makes sense to encode in the protocol. `Self` is already effectively invariant within a protocol.<br>&gt; <br>&gt; As I&#39;ve noted before, I don&#39;t think this makes sense to encode in the protocol. `Self` is already effectively invariant within a protocol.<br></p><p>&#39;Self&#39; is not invariant when used as a return type so I&#39;m not sure what you mean.<br></p><p>&gt; If a protocol doesn&#39;t have the foresight to use StaticSelf, then you still have the same problems retroactively conforming class hierarchies to the protocol.<br></p><p>True, but in many use cases we are in control of the protocol.  This has always been the case when I have personally encountered this problem.<br></p><p>&gt; Whether a conformance is inherited or not feels more natural as a property of a conformance, not something that can be legislated a priori by a protocol definition.<br></p><p>This proposal does not allow protocols to legislate whether conformance is inherited or not.  It just allows the protocol to specify more precisely how requirements are inherited.   <br></p><p>When I write a class Base with non-final methods that return instances of Base I can choose whether to state the return type as Self (covariant) or Base (invariant, under this proposal StaticSelf would also be an alternative way to state this).  If I choose to specify Base as the return type derived classes *may* override the method but are not required to.  Further, if they *do* override the method they are allowed to choose whether their implementation returns Base or Derived.<br></p><p>I believe protocols should have the same flexibility.  If superclasses can control the variance of the return types of their inherited methods why shouldn&#39;t protocols be able to do so as well?  The weaker requirement can be very useful in some cases.<br></p><p>I think the case for StaticSelf is:<br></p><p>1. It is useful as a general substitute for the name of the containing type.<br>2. It solves real world use cases of providing protocol conformance.<br>3. It is a small change (on the surface, I can&#39;t speak to implementation) and may have a chance at making it into Swift 3.<br>4. The previous discussion about controlling conformance at the usage site didn&#39;t really seem to reach any conclusions.  My impression is that this is a feature that is difficult to design well and probably isn&#39;t going to be a priority, at least for a while.<br>5. StaticSelf is perfectly compatible with such a feature if it is introduced in the future.  <br></p><p>&gt; <br>&gt; Something like StaticSelf might still be useful as shorthand within a class definition with a long-winded name, though `StaticSelf` feels kind of long as a shortcut to me.<br></p><p>That&#39;s a fair criticism for that use case.  Chris also mentioned that.  &#39;Type&#39; is the best shorter option we came up with.  We didn&#39;t go that route in the proposal because feels like it could be more confusing for those first learning it.  That said, we are willing to go with whatever the community decides on.  <br></p><p>If you like one of the alternatives better or have any new ideas please let us know...<br></p><p>&gt; <br>&gt; -Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/272d6991/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Draft] Introducing StaticSelf, an Invariant Self</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>May 13, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On May 13, 2016, at 8:18 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On May 12, 2016, at 9:21 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 12, 2016, at 5:49 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The invariant StaticSelf identifier will always refer to A, unlike Self, which is covarying and refers to<br>&gt;&gt;&gt; the type of the actual instance. Since multiple inheritance for non-protocol types is disallowed,<br>&gt;&gt;&gt; this establishes this invariant type identifier with no possibility for conflict.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Consider the following example, under the current system:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol StringCreatable <br>&gt;&gt;&gt; {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; static func createWithString(s: String) -&gt; Self<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension NSURL: StringCreatable <br>&gt;&gt;&gt; {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // cannot conform because NSURL is non-final<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // error: method &#39;createWithString&#39; in non-final class &#39;NSURL&#39; must return `Self` to conform to protocol &#39;A&#39;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Introducing a static, invariant version of Self permits the desired conformance:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol StringCreatable <br>&gt;&gt;&gt; {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; static func createWithString(s: String) -&gt; StaticSelf<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension NSURL: StringCreatable <br>&gt;&gt;&gt; {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // can now conform conform because NSURL is fixed and matches the static<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // type of the conforming construct. Subclasses need not re-implement<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // NOTE: the return type can be declared as StaticSelf *or* as NSURL<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; //       they are interchangeable<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; static func createWithString(s: String) -&gt; StaticSelf<br>&gt;&gt;&gt; { <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // ...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; As I&#39;ve noted before, I don&#39;t think this makes sense to encode in the protocol. `Self` is already effectively invariant within a protocol. <br>&gt; <br>&gt; &#39;Self&#39; is not invariant when used as a return type so I&#39;m not sure what you mean.<br></p><p>That&#39;s a property of a conformance. Class conformances are inherited, so they have to satisfy a protocol&#39;s requirements . Within the protocol definition, or in a protocol extension, `Self` is a generic parameter bound to a specific conforming type. When you conform a base class to a type, that means `Self == Base` and `Self == Derived` must be possible, but `Self` is never simultaneously `Base` and `Derived`.<br></p><p>&gt;&gt; If a protocol doesn&#39;t have the foresight to use StaticSelf, then you still have the same problems retroactively conforming class hierarchies to the protocol. <br>&gt; <br>&gt; True, but in many use cases we are in control of the protocol.  This has always been the case when I have personally encountered this problem.<br></p><p>That will likely change once resilient Swift frameworks start to exist. Changing `Self` to `StaticSelf` or back would also be a nonresilient change, so if frameworks get this wrong, they wouldn&#39;t be able to fix it without breaking ABI, which makes this even more problematic.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Draft] Introducing StaticSelf, an Invariant Self</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 13, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On May 13, 2016, at 10:39 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On May 13, 2016, at 8:18 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt; On May 12, 2016, at 9:21 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 12, 2016, at 5:49 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The invariant StaticSelf identifier will always refer to A, unlike Self, which is covarying and refers to<br>&gt;&gt;&gt;&gt; the type of the actual instance. Since multiple inheritance for non-protocol types is disallowed,<br>&gt;&gt;&gt;&gt; this establishes this invariant type identifier with no possibility for conflict.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Consider the following example, under the current system:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol StringCreatable <br>&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; static func createWithString(s: String) -&gt; Self<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension NSURL: StringCreatable <br>&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // cannot conform because NSURL is non-final<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // error: method &#39;createWithString&#39; in non-final class &#39;NSURL&#39; must return `Self` to conform to protocol &#39;A&#39;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Introducing a static, invariant version of Self permits the desired conformance:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol StringCreatable <br>&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; static func createWithString(s: String) -&gt; StaticSelf<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension NSURL: StringCreatable <br>&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // can now conform conform because NSURL is fixed and matches the static<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // type of the conforming construct. Subclasses need not re-implement<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // NOTE: the return type can be declared as StaticSelf *or* as NSURL<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; //       they are interchangeable<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; static func createWithString(s: String) -&gt; StaticSelf<br>&gt;&gt;&gt;&gt; { <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // ...<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As I&#39;ve noted before, I don&#39;t think this makes sense to encode in the protocol. `Self` is already effectively invariant within a protocol. <br>&gt;&gt; <br>&gt;&gt; &#39;Self&#39; is not invariant when used as a return type so I&#39;m not sure what you mean.<br>&gt; <br>&gt; That&#39;s a property of a conformance. Class conformances are inherited, so they have to satisfy a protocol&#39;s requirements . Within the protocol definition, or in a protocol extension, `Self` is a generic parameter bound to a specific conforming type. When you conform a base class to a type, that means `Self == Base` and `Self == Derived` must be possible, but `Self` is never simultaneously `Base` and `Derived`.<br>&gt; <br>&gt;&gt;&gt; If a protocol doesn&#39;t have the foresight to use StaticSelf, then you still have the same problems retroactively conforming class hierarchies to the protocol. <br>&gt;&gt; <br>&gt;&gt; True, but in many use cases we are in control of the protocol.  This has always been the case when I have personally encountered this problem.<br>&gt; <br>&gt; That will likely change once resilient Swift frameworks start to exist. Changing `Self` to `StaticSelf` or back would also be a nonresilient change, so if frameworks get this wrong, they wouldn&#39;t be able to fix it without breaking ABI, which makes this even more problematic.<br></p><p>You can say this about many things.  It seems less problematic than having no way to express this.  Frameworks would not be required to use it if the authors have concerns about ABI.<br></p><p>&gt; <br>&gt; -Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/ed7c6c3b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Draft] Introducing StaticSelf, an Invariant Self</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>May 13, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On May 13, 2016, at 9:06 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 13, 2016, at 10:39 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On May 13, 2016, at 8:18 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On May 12, 2016, at 9:21 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 12, 2016, at 5:49 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The invariant StaticSelf identifier will always refer to A, unlike Self, which is covarying and refers to<br>&gt;&gt;&gt;&gt;&gt; the type of the actual instance. Since multiple inheritance for non-protocol types is disallowed,<br>&gt;&gt;&gt;&gt;&gt; this establishes this invariant type identifier with no possibility for conflict.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Consider the following example, under the current system:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; protocol StringCreatable <br>&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; static func createWithString(s: String) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; extension NSURL: StringCreatable <br>&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // cannot conform because NSURL is non-final<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // error: method &#39;createWithString&#39; in non-final class &#39;NSURL&#39; must return `Self` to conform to protocol &#39;A&#39;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Introducing a static, invariant version of Self permits the desired conformance:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; protocol StringCreatable <br>&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; static func createWithString(s: String) -&gt; StaticSelf<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; extension NSURL: StringCreatable <br>&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // can now conform conform because NSURL is fixed and matches the static<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // type of the conforming construct. Subclasses need not re-implement<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // NOTE: the return type can be declared as StaticSelf *or* as NSURL<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; //       they are interchangeable<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; static func createWithString(s: String) -&gt; StaticSelf<br>&gt;&gt;&gt;&gt;&gt; { <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // ...<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As I&#39;ve noted before, I don&#39;t think this makes sense to encode in the protocol. `Self` is already effectively invariant within a protocol. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &#39;Self&#39; is not invariant when used as a return type so I&#39;m not sure what you mean.<br>&gt;&gt; <br>&gt;&gt; That&#39;s a property of a conformance. Class conformances are inherited, so they have to satisfy a protocol&#39;s requirements . Within the protocol definition, or in a protocol extension, `Self` is a generic parameter bound to a specific conforming type. When you conform a base class to a type, that means `Self == Base` and `Self == Derived` must be possible, but `Self` is never simultaneously `Base` and `Derived`.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; If a protocol doesn&#39;t have the foresight to use StaticSelf, then you still have the same problems retroactively conforming class hierarchies to the protocol. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; True, but in many use cases we are in control of the protocol.  This has always been the case when I have personally encountered this problem.<br>&gt;&gt; <br>&gt;&gt; That will likely change once resilient Swift frameworks start to exist. Changing `Self` to `StaticSelf` or back would also be a nonresilient change, so if frameworks get this wrong, they wouldn&#39;t be able to fix it without breaking ABI, which makes this even more problematic.<br>&gt; <br>&gt; You can say this about many things.  It seems less problematic than having no way to express this.  Frameworks would not be required to use it if the authors have concerns about ABI.<br></p><p>In this particular case, making conformances non-inheritable, under the conformer&#39;s control, would avoid the issue of the framework having to anticipate its users&#39; needs.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Draft] Introducing StaticSelf, an Invariant Self</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 13, 2016 at 11:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 13, 2016, at 11:08 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 13, 2016, at 9:06 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 13, 2016, at 10:39 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 13, 2016, at 8:18 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 12, 2016, at 9:21 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On May 12, 2016, at 5:49 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The invariant StaticSelf identifier will always refer to A, unlike Self, which is covarying and refers to<br>&gt;&gt;&gt;&gt;&gt;&gt; the type of the actual instance. Since multiple inheritance for non-protocol types is disallowed,<br>&gt;&gt;&gt;&gt;&gt;&gt; this establishes this invariant type identifier with no possibility for conflict.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Consider the following example, under the current system:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; protocol StringCreatable <br>&gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; static func createWithString(s: String) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; extension NSURL: StringCreatable <br>&gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // cannot conform because NSURL is non-final<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // error: method &#39;createWithString&#39; in non-final class &#39;NSURL&#39; must return `Self` to conform to protocol &#39;A&#39;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Introducing a static, invariant version of Self permits the desired conformance:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; protocol StringCreatable <br>&gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; static func createWithString(s: String) -&gt; StaticSelf<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; extension NSURL: StringCreatable <br>&gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // can now conform conform because NSURL is fixed and matches the static<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // type of the conforming construct. Subclasses need not re-implement<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // NOTE: the return type can be declared as StaticSelf *or* as NSURL<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; //       they are interchangeable<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; static func createWithString(s: String) -&gt; StaticSelf<br>&gt;&gt;&gt;&gt;&gt;&gt; { <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // ...<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; As I&#39;ve noted before, I don&#39;t think this makes sense to encode in the protocol. `Self` is already effectively invariant within a protocol.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &#39;Self&#39; is not invariant when used as a return type so I&#39;m not sure what you mean.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That&#39;s a property of a conformance. Class conformances are inherited, so they have to satisfy a protocol&#39;s requirements . Within the protocol definition, or in a protocol extension, `Self` is a generic parameter bound to a specific conforming type. When you conform a base class to a type, that means `Self == Base` and `Self == Derived` must be possible, but `Self` is never simultaneously `Base` and `Derived`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If a protocol doesn&#39;t have the foresight to use StaticSelf, then you still have the same problems retroactively conforming class hierarchies to the protocol.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; True, but in many use cases we are in control of the protocol.  This has always been the case when I have personally encountered this problem.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That will likely change once resilient Swift frameworks start to exist. Changing `Self` to `StaticSelf` or back would also be a nonresilient change, so if frameworks get this wrong, they wouldn&#39;t be able to fix it without breaking ABI, which makes this even more problematic.<br>&gt;&gt; <br>&gt;&gt; You can say this about many things.  It seems less problematic than having no way to express this.  Frameworks would not be required to use it if the authors have concerns about ABI.<br>&gt; <br>&gt; In this particular case, making conformances non-inheritable, under the conformer&#39;s control, would avoid the issue of the framework having to anticipate its users&#39; needs.<br></p><p>How would that work for class clusters?  I may have an instance of a subclass but only know about the visible superclass.  When the visible superclass conforms to a protocol I expect that the instance I have a reference to also conforms, regardless of its dynamic type.  <br></p><p>&gt; <br>&gt; -Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Draft] Introducing StaticSelf, an Invariant Self</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>May 13, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On May 13, 2016, at 9:22 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt;&gt; On May 13, 2016, at 11:08 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 13, 2016, at 9:06 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 13, 2016, at 10:39 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 13, 2016, at 8:18 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On May 12, 2016, at 9:21 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 12, 2016, at 5:49 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The invariant StaticSelf identifier will always refer to A, unlike Self, which is covarying and refers to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; the type of the actual instance. Since multiple inheritance for non-protocol types is disallowed,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; this establishes this invariant type identifier with no possibility for conflict.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Consider the following example, under the current system:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol StringCreatable <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; static func createWithString(s: String) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; extension NSURL: StringCreatable <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // cannot conform because NSURL is non-final<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // error: method &#39;createWithString&#39; in non-final class &#39;NSURL&#39; must return `Self` to conform to protocol &#39;A&#39;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Introducing a static, invariant version of Self permits the desired conformance:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol StringCreatable <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; static func createWithString(s: String) -&gt; StaticSelf<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; extension NSURL: StringCreatable <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // can now conform conform because NSURL is fixed and matches the static<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // type of the conforming construct. Subclasses need not re-implement<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // NOTE: the return type can be declared as StaticSelf *or* as NSURL<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; //       they are interchangeable<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; static func createWithString(s: String) -&gt; StaticSelf<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; { <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; As I&#39;ve noted before, I don&#39;t think this makes sense to encode in the protocol. `Self` is already effectively invariant within a protocol.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &#39;Self&#39; is not invariant when used as a return type so I&#39;m not sure what you mean.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That&#39;s a property of a conformance. Class conformances are inherited, so they have to satisfy a protocol&#39;s requirements . Within the protocol definition, or in a protocol extension, `Self` is a generic parameter bound to a specific conforming type. When you conform a base class to a type, that means `Self == Base` and `Self == Derived` must be possible, but `Self` is never simultaneously `Base` and `Derived`.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If a protocol doesn&#39;t have the foresight to use StaticSelf, then you still have the same problems retroactively conforming class hierarchies to the protocol.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; True, but in many use cases we are in control of the protocol.  This has always been the case when I have personally encountered this problem.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That will likely change once resilient Swift frameworks start to exist. Changing `Self` to `StaticSelf` or back would also be a nonresilient change, so if frameworks get this wrong, they wouldn&#39;t be able to fix it without breaking ABI, which makes this even more problematic.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You can say this about many things.  It seems less problematic than having no way to express this.  Frameworks would not be required to use it if the authors have concerns about ABI.<br>&gt;&gt; <br>&gt;&gt; In this particular case, making conformances non-inheritable, under the conformer&#39;s control, would avoid the issue of the framework having to anticipate its users&#39; needs.<br>&gt; <br>&gt; How would that work for class clusters?  I may have an instance of a subclass but only know about the visible superclass.  When the visible superclass conforms to a protocol I expect that the instance I have a reference to also conforms, regardless of its dynamic type.  <br></p><p>In most cases, the subtype conversion should still kick in, so that we can convert ImplSubclass to VisibleSuperclass and invoke a generic with T == VisibleSuperclass instead of with T == ImplSubclass. There might be problems if the ImplSubclass appeared structurally in an invariant position, where implicit conversion is rare, but for situations where you want invariant protocol conformances, such as class clusters, it&#39;s rare to work to specific implementation classes directly, since the visible superclass is the primary API interface.<br></p><p>-Joe<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Draft] Introducing StaticSelf, an Invariant Self</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>May 13, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On May 13, 2016, at 8:18 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; When I write a class Base with non-final methods that return instances of Base I can choose whether to state the return type as Self (covariant) or Base (invariant, under this proposal StaticSelf would also be an alternative way to state this).  If I choose to specify Base as the return type derived classes *may* override the method but are not required to.  Further, if they *do* override the method they are allowed to choose whether their implementation returns Base or Derived.<br></p><p>`StaticSelf` requirements by themselves don&#39;t even save you from covariance. If Base conforms to a protocol (with Self == Base), Derived inherits that conformance and also conforms (with Self == Derived). If `StaticSelf` always refers to the conforming type, then it must also be bindable to Base and Derived, so a base class must still use a covariant-returning method to satisfy the `StaticSelf` requirement.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Draft] Introducing StaticSelf, an Invariant Self</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 13, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On May 13, 2016, at 10:55 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 13, 2016, at 8:18 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; When I write a class Base with non-final methods that return instances of Base I can choose whether to state the return type as Self (covariant) or Base (invariant, under this proposal StaticSelf would also be an alternative way to state this).  If I choose to specify Base as the return type derived classes *may* override the method but are not required to.  Further, if they *do* override the method they are allowed to choose whether their implementation returns Base or Derived.<br>&gt; <br>&gt; `StaticSelf` requirements by themselves don&#39;t even save you from covariance. If Base conforms to a protocol (with Self == Base), Derived inherits that conformance and also conforms (with Self == Derived). If `StaticSelf` always refers to the conforming type, then it must also be bindable to Base and Derived, so a base class must still use a covariant-returning method to satisfy the `StaticSelf` requirement.<br></p><p>We are specifying that `StaticSelf` refers to the type that explicitly declares conformance.  If a class inherits conformance it refers to the base class which explicitly declared the conformance it is inheriting.<br></p><p>&gt; <br>&gt; -Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Draft] Introducing StaticSelf, an Invariant Self</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>May 13, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On May 13, 2016, at 9:06 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 13, 2016, at 10:55 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 13, 2016, at 8:18 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When I write a class Base with non-final methods that return instances of Base I can choose whether to state the return type as Self (covariant) or Base (invariant, under this proposal StaticSelf would also be an alternative way to state this).  If I choose to specify Base as the return type derived classes *may* override the method but are not required to.  Further, if they *do* override the method they are allowed to choose whether their implementation returns Base or Derived.<br>&gt;&gt; <br>&gt;&gt; `StaticSelf` requirements by themselves don&#39;t even save you from covariance. If Base conforms to a protocol (with Self == Base), Derived inherits that conformance and also conforms (with Self == Derived). If `StaticSelf` always refers to the conforming type, then it must also be bindable to Base and Derived, so a base class must still use a covariant-returning method to satisfy the `StaticSelf` requirement.<br>&gt; <br>&gt; We are specifying that `StaticSelf` refers to the type that explicitly declares conformance.  If a class inherits conformance it refers to the base class which explicitly declared the conformance it is inheriting.<br></p><p>That makes `StaticSelf` tricky to use in generic code. This would be invalid:<br></p><p>protocol Makable {<br>	static func make(value: Int) -&gt; StaticSelf<br>}<br></p><p>func makeWithZero&lt;T: Fooable&gt;(x: Int) -&gt; T {<br>	return T.make(value: 0) // ERROR: T.StaticSelf may be a supertype of T so isn&#39;t convertible to T<br>}<br></p><p>`StaticSelf` in this model is effectively an associated type of the protocol, with a `Self: StaticSelf` constraint (if that were supported).<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Draft] Introducing StaticSelf, an Invariant Self</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 14, 2016 at 12:00:00am</p></header><div class="content"><p>Seems like -&gt;StaticSelf can actually only means returns the class for which <br>protocol conformance was applied first(in hierarchy). I.e. some `-&gt;BaseSelf`.<br>But in this case we need a method to get this &#39;base&#39; class from protocol..<br></p><p>something like(just pseudo code!):<br></p><p>func makeWithZero&lt;T: Makable &gt;(x: Int) -&gt; Makable(T).FirstConformedClass {<br>	return T.make(value: 0)<br>}<br></p><p>or<br></p><p>func makeWithZero&lt;T: Makable &gt;(x: Int) -&gt; type&lt;T.make(value:)&gt; {<br>	return T.make(value: 0)<br>}<br></p><p>I don&#39;t know if all of this makes sense at all ;-)<br></p><p>On 13.05.2016 23:12, Joe Groff via swift-evolution wrote:<br>&gt;<br>&gt;&gt; On May 13, 2016, at 9:06 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; On May 13, 2016, at 10:55 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On May 13, 2016, at 8:18 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; When I write a class Base with non-final methods that return instances of Base I can choose whether to state the return type as Self (covariant) or Base (invariant, under this proposal StaticSelf would also be an alternative way to state this).  If I choose to specify Base as the return type derived classes *may* override the method but are not required to.  Further, if they *do* override the method they are allowed to choose whether their implementation returns Base or Derived.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; `StaticSelf` requirements by themselves don&#39;t even save you from covariance. If Base conforms to a protocol (with Self == Base), Derived inherits that conformance and also conforms (with Self == Derived). If `StaticSelf` always refers to the conforming type, then it must also be bindable to Base and Derived, so a base class must still use a covariant-returning method to satisfy the `StaticSelf` requirement.<br>&gt;&gt;<br>&gt;&gt; We are specifying that `StaticSelf` refers to the type that explicitly declares conformance.  If a class inherits conformance it refers to the base class which explicitly declared the conformance it is inheriting.<br>&gt;<br>&gt; That makes `StaticSelf` tricky to use in generic code. This would be invalid:<br>&gt;<br>&gt; protocol Makable {<br>&gt; 	static func make(value: Int) -&gt; StaticSelf<br>&gt; }<br>&gt;<br>&gt; func makeWithZero&lt;T: Fooable&gt;(x: Int) -&gt; T {<br>&gt; 	return T.make(value: 0) // ERROR: T.StaticSelf may be a supertype of T so isn&#39;t convertible to T<br>&gt; }<br>&gt;<br>&gt; `StaticSelf` in this model is effectively an associated type of the protocol, with a `Self: StaticSelf` constraint (if that were supported).<br>&gt;<br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Draft] Introducing StaticSelf, an Invariant Self</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 13, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On May 13, 2016, at 3:12 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On May 13, 2016, at 9:06 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 13, 2016, at 10:55 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 13, 2016, at 8:18 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; When I write a class Base with non-final methods that return instances of Base I can choose whether to state the return type as Self (covariant) or Base (invariant, under this proposal StaticSelf would also be an alternative way to state this).  If I choose to specify Base as the return type derived classes *may* override the method but are not required to.  Further, if they *do* override the method they are allowed to choose whether their implementation returns Base or Derived.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; `StaticSelf` requirements by themselves don&#39;t even save you from covariance. If Base conforms to a protocol (with Self == Base), Derived inherits that conformance and also conforms (with Self == Derived). If `StaticSelf` always refers to the conforming type, then it must also be bindable to Base and Derived, so a base class must still use a covariant-returning method to satisfy the `StaticSelf` requirement.<br>&gt;&gt; <br>&gt;&gt; We are specifying that `StaticSelf` refers to the type that explicitly declares conformance.  If a class inherits conformance it refers to the base class which explicitly declared the conformance it is inheriting.<br>&gt; <br>&gt; That makes `StaticSelf` tricky to use in generic code. This would be invalid:<br>&gt; <br>&gt; protocol Makable {<br>&gt; 	static func make(value: Int) -&gt; StaticSelf<br>&gt; }<br>&gt; <br>&gt; func makeWithZero&lt;T: Fooable&gt;(x: Int) -&gt; T {<br>&gt; 	return T.make(value: 0) // ERROR: T.StaticSelf may be a supertype of T so isn&#39;t convertible to T<br>&gt; }<br></p><p>I agree it’s a bit tricky.  But that’s better than not possible at all.  You just need a typealias and a same type constraint to make this work as expected / desired:<br></p><p>protocol Makable {<br>	typealias RootMakable = StaticSelf<br>	static func make(value: Int) -&gt; StaticSelf<br>}<br></p><p>func makeWithZero&lt;T: Makable where T == T.RootMakable&gt;(x: Int) -&gt; T {<br>	return T.make(value: 0) // works now <br>}<br></p><p>Now that we have a typealias we can refer to the binding of StaticSelf and constrain it as necessary for whatever purpose we have in mind.  In some cases that will be a same type constraint so that our code works properly with class clusters.  I don’t have concrete examples of other use cases but can imagine use cases constraining the typealias to a protocol, for example.<br></p><p>If we had control over inheritance of conformance at the point of conformance we probably wouldn’t be talking about StaticSelf.  But we don’t and this is a problem that has caused enough people trouble that it is worth solving.  StaticSelf does that in a general way that is also as a shorthand in types themselves and has consistent semantics in both use cases.  <br></p><p>IIRC the design of point-of-conformance control over inheritance of conformance is pretty thorny.  I wouldn’t mind seeing that feature eventually but don’t have any confidence that it will come soon.  <br></p><p>&gt; <br>&gt; `StaticSelf` in this model is effectively an associated type of the protocol, with a `Self: StaticSelf` constraint (if that were supported).<br></p><p>If you add that the associated type is automatically bound with the initial conformance (and cannot be modified by subclass conformances) then yes, you can look at it this way.<br></p><p><br></p><p>&gt; <br>&gt; -Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/3276330a/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Draft] Introducing StaticSelf, an Invariant Self</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 13, 2016 at 06:00:00am</p></header><div class="content"><p>+1<br></p><p>Good description of the motivating problem!<br></p><p>As for bikeshedding: ConformingSelf, ConformingType, BaseSelf, BaseType<br></p><p>-Thorsten <br></p><p>&gt; Am 13.05.2016 um 02:49 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Erica Sadun and I have written a proposal are following up the recent discussion thread &quot;[RFC] #Self” with a proposal to introduce StaticSelf, an invariant Self.<br>&gt; <br>&gt; The recent discussion can be found here: http://thread.gmane.org/gmane.comp.lang.swift.evolution/16565<br>&gt; <br>&gt; The proposal can be found here: https://github.com/anandabits/swift-evolution/blob/static-self/proposals/NNNN-static-self.md<br>&gt; <br>&gt; We look forward to continuing the discussion.  We plan to submit a PR in the near future after incorporating your final feedback.<br>&gt; <br>&gt; Thanks,<br>&gt; Matthew<br>&gt; Introducing StaticSelf, an Invariant Self<br>&gt; <br>&gt; Proposal: TBD<br>&gt; Authors: Matthew Johnson, Erica Sadun<br>&gt; Status: TBD<br>&gt; Review manager: TBD<br>&gt; Introduction<br>&gt; <br>&gt; This proposal introduces a new keyword that provides consistent invariant type semantics in all contexts.<br>&gt; <br>&gt; The Swift-evolution thread about this topic can be found here: [RFC] #Self<br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; The distinction between covariant and non-covariant type references come into play when<br>&gt; conforming non-final classes to protocols. Fixing a protocol requirement to a covarying type<br>&gt; means that a method returning Self must be overriden by all subclasses in order to return<br>&gt; the correct, matching type.<br>&gt; <br>&gt; This proposal builds on the covariant construct Self accepted in SE–0068<br>&gt; to introduce an invariant type identifier. It enables protocol declarations to consistently<br>&gt; refer to a type that is fixed at compile time. This ensures that subclasses can inherit<br>&gt; protocol implementations without having to re-implement that code at each level of<br>&gt; inheritance.<br>&gt; <br>&gt; Under this proposal, a new identifier keyword is fixed in use at the point of protocol conformance<br>&gt; to the static type of that construct. <br>&gt; <br>&gt; class A: MyProtocol<br>&gt; The invariant StaticSelf identifier will always refer to A, unlike Self, which is covarying and refers to<br>&gt; the type of the actual instance. Since multiple inheritance for non-protocol types is disallowed,<br>&gt; this establishes this invariant type identifier with no possibility for conflict.<br>&gt; <br>&gt; Consider the following example, under the current system:<br>&gt; <br>&gt; protocol StringCreatable {<br>&gt;     static func createWithString(s: String) -&gt; Self<br>&gt; }<br>&gt; <br>&gt; extension NSURL: StringCreatable {<br>&gt;  // cannot conform because NSURL is non-final<br>&gt;  // error: method &#39;createWithString&#39; in non-final class &#39;NSURL&#39; must return `Self` to conform to protocol &#39;A&#39;<br>&gt; }<br>&gt; Introducing a static, invariant version of Self permits the desired conformance:<br>&gt; <br>&gt; protocol StringCreatable {<br>&gt;     static func createWithString(s: String) -&gt; StaticSelf<br>&gt; }<br>&gt; <br>&gt; extension NSURL: StringCreatable {<br>&gt;  // can now conform conform because NSURL is fixed and matches the static<br>&gt;  // type of the conforming construct. Subclasses need not re-implement<br>&gt;  // NOTE: the return type can be declared as StaticSelf *or* as NSURL<br>&gt;  //       they are interchangeable<br>&gt;  static func createWithString(s: String) -&gt; StaticSelf { <br>&gt;      // ...<br>&gt;  }<br>&gt; }<br>&gt; Additional Utility<br>&gt; <br>&gt; The utility of StaticSelf is not limited to protocols. A secondary use enables code to refer to the lexical context’s current type without explicitly mentioning its name. This provides a useful shortcut when referencing static type members with especially long names and when re-purposing code between types.<br>&gt; <br>&gt; class StructWithAVeryLongName {<br>&gt;     static func foo() -&gt; String {<br>&gt;       // ...<br>&gt;     }<br>&gt;     func bar() {<br>&gt;       // ...<br>&gt;       let s = StaticSelf.foo()<br>&gt;       //<br>&gt;     }<br>&gt; }<br>&gt; Detailed Design<br>&gt; <br>&gt; This proposal introduces StaticSelf, a new keyword that may be used in protocols to refer to the invariant static type of a conforming construct. StaticSelf may also be used in the lexical context of any type declaration. In such use, the keyword is identical to spelling out the full name of that type.<br>&gt; <br>&gt; Impact on existing code<br>&gt; <br>&gt; Being additive, there should be no impact on existing code.<br>&gt; <br>&gt; Alternatives considered<br>&gt; <br>&gt; The keyword is not fixed at this time. Alternatives that have been discussed include StaticType, InvariantSelf, SelfType, or Type. The community is welcome to bikeshed on the most clear and concise name for this keyword.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/9c441d5c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Draft] Introducing StaticSelf, an Invariant Self</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 13, 2016 at 09:00:00am</p></header><div class="content"><p>In this case I propose to call it BaseType (or BaseSelf) as actually this <br>&#39;thing&#39; in meaning `-&gt;StaticSelf` means &#39;self or any base class&#39;<br></p><p>On 13.05.2016 7:56, Thorsten Seitz via swift-evolution wrote:<br>&gt; +1<br>&gt;<br>&gt; Good description of the motivating problem!<br>&gt;<br>&gt; As for bikeshedding: ConformingSelf, ConformingType, BaseSelf, BaseType<br>&gt;<br>&gt; -Thorsten<br>&gt;<br>&gt; Am 13.05.2016 um 02:49 schrieb Matthew Johnson via swift-evolution<br>&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;<br>&gt;&gt; Erica Sadun and I have written a proposal are following up the recent<br>&gt;&gt; discussion thread &quot;[RFC] #Self” with a proposal to introduce StaticSelf,<br>&gt;&gt; an invariant Self.<br>&gt;&gt;<br>&gt;&gt; The recent discussion can be found<br>&gt;&gt; here: http://thread.gmane.org/gmane.comp.lang.swift.evolution/16565<br>&gt;&gt;<br>&gt;&gt; The proposal can be found<br>&gt;&gt; here: https://github.com/anandabits/swift-evolution/blob/static-self/proposals/NNNN-static-self.md<br>&gt;&gt;<br>&gt;&gt; We look forward to continuing the discussion.  We plan to submit a PR in<br>&gt;&gt; the near future after incorporating your final feedback.<br>&gt;&gt;<br>&gt;&gt; Thanks,<br>&gt;&gt; Matthew<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;   Introducing StaticSelf, an Invariant Self<br>&gt;&gt;<br>&gt;&gt;   * Proposal: TBD<br>&gt;&gt;   * Authors: Matthew Johnson &lt;https://github.com/anandabits&gt;, Erica Sadun<br>&gt;&gt;     &lt;https://github.com/erica&gt;<br>&gt;&gt;   * Status: TBD<br>&gt;&gt;   * Review manager: TBD<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     Introduction<br>&gt;&gt;<br>&gt;&gt; This proposal introduces a new keyword that provides consistent invariant<br>&gt;&gt; type semantics in all contexts.<br>&gt;&gt;<br>&gt;&gt; /The Swift-evolution thread about this topic can be found here: [RFC]<br>&gt;&gt; #Self &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/16565&gt;/<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     Motivation<br>&gt;&gt;<br>&gt;&gt; The distinction between covariant and non-covariant type references come<br>&gt;&gt; into play when<br>&gt;&gt; conforming non-final classes to protocols. Fixing a protocol requirement<br>&gt;&gt; to a covarying type<br>&gt;&gt; means that a method returning |Self| must be overriden by all subclasses<br>&gt;&gt; in order to return<br>&gt;&gt; the correct, matching type.<br>&gt;&gt;<br>&gt;&gt; This proposal builds on the covariant construct |Self| accepted<br>&gt;&gt; in SE–0068<br>&gt;&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0068-universal-self.md&gt;<br>&gt;&gt; to introduce an invariant type identifier. It enables protocol<br>&gt;&gt; declarations to consistently<br>&gt;&gt; refer to a type that is fixed at compile time. This ensures that<br>&gt;&gt; subclasses can inherit<br>&gt;&gt; protocol implementations without having to re-implement that code at each<br>&gt;&gt; level of<br>&gt;&gt; inheritance.<br>&gt;&gt;<br>&gt;&gt; Under this proposal, a new identifier keyword is fixed in use /at the<br>&gt;&gt; point of protocol conformance/<br>&gt;&gt; to the static type of that construct.<br>&gt;&gt;<br>&gt;&gt; |class A: MyProtocol|<br>&gt;&gt;<br>&gt;&gt; The invariant |StaticSelf| identifier will always refer to |A|,<br>&gt;&gt; unlike |Self|, which is covarying and refers to<br>&gt;&gt; the type of the actual instance. Since multiple inheritance for<br>&gt;&gt; non-protocol types is disallowed,<br>&gt;&gt; this establishes this invariant type identifier with no possibility for<br>&gt;&gt; conflict.<br>&gt;&gt;<br>&gt;&gt; Consider the following example, under the current system:<br>&gt;&gt;<br>&gt;&gt; |protocol StringCreatable { static func createWithString(s: String) -&gt;<br>&gt;&gt; Self } extension NSURL: StringCreatable { // cannot conform because NSURL<br>&gt;&gt; is non-final // error: method &#39;createWithString&#39; in non-final class<br>&gt;&gt; &#39;NSURL&#39; must return `Self` to conform to protocol &#39;A&#39; }|<br>&gt;&gt;<br>&gt;&gt; Introducing a static, invariant version of |Self| permits the desired<br>&gt;&gt; conformance:<br>&gt;&gt;<br>&gt;&gt; |protocol StringCreatable { static func createWithString(s: String) -&gt;<br>&gt;&gt; StaticSelf } extension NSURL: StringCreatable { // can now conform<br>&gt;&gt; conform because NSURL is fixed and matches the static // type of the<br>&gt;&gt; conforming construct. Subclasses need not re-implement // NOTE: the<br>&gt;&gt; return type can be declared as StaticSelf *or* as NSURL // they are<br>&gt;&gt; interchangeable static func createWithString(s: String) -&gt; StaticSelf {<br>&gt;&gt; // ... } }|<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;       Additional Utility<br>&gt;&gt;<br>&gt;&gt; The utility of |StaticSelf| is not limited to protocols. A secondary use<br>&gt;&gt; enables code to refer to the lexical context’s current type without<br>&gt;&gt; explicitly mentioning its name. This provides a useful shortcut when<br>&gt;&gt; referencing static type members with especially long names and when<br>&gt;&gt; re-purposing code between types.<br>&gt;&gt;<br>&gt;&gt; |class StructWithAVeryLongName { static func foo() -&gt; String { // ... }<br>&gt;&gt; func bar() { // ... let s = StaticSelf.foo() // } }|<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     Detailed Design<br>&gt;&gt;<br>&gt;&gt; This proposal introduces |StaticSelf|, a new keyword that may be used in<br>&gt;&gt; protocols to refer to the invariant static type of a conforming<br>&gt;&gt; construct. |StaticSelf| may also be used in the lexical context of any<br>&gt;&gt; type declaration. In such use, the keyword is identical to spelling out<br>&gt;&gt; the full name of that type.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     Impact on existing code<br>&gt;&gt;<br>&gt;&gt; Being additive, there should be no impact on existing code.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     Alternatives considered<br>&gt;&gt;<br>&gt;&gt; The keyword is not fixed at this time. Alternatives that have been<br>&gt;&gt; discussed include |StaticType|, |InvariantSelf|, |SelfType|, or |Type|.<br>&gt;&gt; The community is welcome to bikeshed on the most clear and concise name<br>&gt;&gt; for this keyword.<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b1fc4ed1ed8e138ef0a87fd3e91c83a4?s=50"></div><header><strong>[Draft] Introducing StaticSelf, an Invariant Self</strong> from <string>Ricardo Parada</string> &lt;rparada at mac.com&gt;<p>May 13, 2016 at 06:00:00am</p></header><div class="content"><p>I would prefer BaseSelf. <br></p><p><br>&gt; On May 13, 2016, at 2:28 AM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; via<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Draft] Introducing StaticSelf, an Invariant Self</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 13, 2016 at 10:00:00am</p></header><div class="content"><p>Why did you decide to drop the `#` ? As `StaticSelf` will be resolved on <br>compilation time like #file etc ? I feel like this is inconsistent solution.<br></p><p>Also, do you expect this will work:<br></p><p>protocol A {<br>   func g()-&gt;StaticSelf<br>}<br></p><p>class B: A {<br>   func g()-&gt;StaticSelf {return B()}<br>}<br></p><p>class C: B {<br>   //func f(s: C) {}<br>}<br></p><p>func x(a: A ){<br>     var xx : A = a.g() // ?<br>     print(xx)<br>}<br></p><p>func z&lt;T: A&gt;(t: T) {<br>     let u = t.g() // ?<br>     print(u)<br>}<br></p><p>let c = C()<br>z(c)<br>x(c)<br></p><p><br>On 13.05.2016 3:49, Matthew Johnson via swift-evolution wrote:<br>&gt; Erica Sadun and I have written a proposal are following up the recent<br>&gt; discussion thread &quot;[RFC] #Self” with a proposal to introduce StaticSelf, an<br>&gt; invariant Self.<br>&gt;<br>&gt; The recent discussion can be found<br>&gt; here: http://thread.gmane.org/gmane.comp.lang.swift.evolution/16565<br>&gt;<br>&gt; The proposal can be found<br>&gt; here: https://github.com/anandabits/swift-evolution/blob/static-self/proposals/NNNN-static-self.md<br>&gt;<br>&gt; We look forward to continuing the discussion.  We plan to submit a PR in<br>&gt; the near future after incorporating your final feedback.<br>&gt;<br>&gt; Thanks,<br>&gt; Matthew<br>&gt;<br>&gt;<br>&gt;   Introducing StaticSelf, an Invariant Self<br>&gt;<br>&gt;   * Proposal: TBD<br>&gt;   * Authors: Matthew Johnson &lt;https://github.com/anandabits&gt;, Erica Sadun<br>&gt;     &lt;https://github.com/erica&gt;<br>&gt;   * Status: TBD<br>&gt;   * Review manager: TBD<br>&gt;<br>&gt;<br>&gt;     Introduction<br>&gt;<br>&gt; This proposal introduces a new keyword that provides consistent invariant<br>&gt; type semantics in all contexts.<br>&gt;<br>&gt; /The Swift-evolution thread about this topic can be found here: [RFC] #Self<br>&gt; &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/16565&gt;/<br>&gt;<br>&gt;<br>&gt;     Motivation<br>&gt;<br>&gt; The distinction between covariant and non-covariant type references come<br>&gt; into play when<br>&gt; conforming non-final classes to protocols. Fixing a protocol requirement to<br>&gt; a covarying type<br>&gt; means that a method returning |Self| must be overriden by all subclasses in<br>&gt; order to return<br>&gt; the correct, matching type.<br>&gt;<br>&gt; This proposal builds on the covariant construct |Self| accepted in SE–0068<br>&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0068-universal-self.md&gt;<br>&gt; to introduce an invariant type identifier. It enables protocol declarations<br>&gt; to consistently<br>&gt; refer to a type that is fixed at compile time. This ensures that subclasses<br>&gt; can inherit<br>&gt; protocol implementations without having to re-implement that code at each<br>&gt; level of<br>&gt; inheritance.<br>&gt;<br>&gt; Under this proposal, a new identifier keyword is fixed in use /at the point<br>&gt; of protocol conformance/<br>&gt; to the static type of that construct.<br>&gt;<br>&gt; |class A: MyProtocol|<br>&gt;<br>&gt; The invariant |StaticSelf| identifier will always refer to |A|,<br>&gt; unlike |Self|, which is covarying and refers to<br>&gt; the type of the actual instance. Since multiple inheritance for<br>&gt; non-protocol types is disallowed,<br>&gt; this establishes this invariant type identifier with no possibility for<br>&gt; conflict.<br>&gt;<br>&gt; Consider the following example, under the current system:<br>&gt;<br>&gt; |protocol StringCreatable { static func createWithString(s: String) -&gt; Self<br>&gt; } extension NSURL: StringCreatable { // cannot conform because NSURL is<br>&gt; non-final // error: method &#39;createWithString&#39; in non-final class &#39;NSURL&#39;<br>&gt; must return `Self` to conform to protocol &#39;A&#39; }|<br>&gt;<br>&gt; Introducing a static, invariant version of |Self| permits the desired<br>&gt; conformance:<br>&gt;<br>&gt; |protocol StringCreatable { static func createWithString(s: String) -&gt;<br>&gt; StaticSelf } extension NSURL: StringCreatable { // can now conform conform<br>&gt; because NSURL is fixed and matches the static // type of the conforming<br>&gt; construct. Subclasses need not re-implement // NOTE: the return type can be<br>&gt; declared as StaticSelf *or* as NSURL // they are interchangeable static<br>&gt; func createWithString(s: String) -&gt; StaticSelf { // ... } }|<br>&gt;<br>&gt;<br>&gt;       Additional Utility<br>&gt;<br>&gt; The utility of |StaticSelf| is not limited to protocols. A secondary use<br>&gt; enables code to refer to the lexical context’s current type without<br>&gt; explicitly mentioning its name. This provides a useful shortcut when<br>&gt; referencing static type members with especially long names and when<br>&gt; re-purposing code between types.<br>&gt;<br>&gt; |class StructWithAVeryLongName { static func foo() -&gt; String { // ... } func<br>&gt; bar() { // ... let s = StaticSelf.foo() // } }|<br>&gt;<br>&gt;<br>&gt;     Detailed Design<br>&gt;<br>&gt; This proposal introduces |StaticSelf|, a new keyword that may be used in<br>&gt; protocols to refer to the invariant static type of a conforming<br>&gt; construct. |StaticSelf| may also be used in the lexical context of any type<br>&gt; declaration. In such use, the keyword is identical to spelling out the full<br>&gt; name of that type.<br>&gt;<br>&gt;<br>&gt;     Impact on existing code<br>&gt;<br>&gt; Being additive, there should be no impact on existing code.<br>&gt;<br>&gt;<br>&gt;     Alternatives considered<br>&gt;<br>&gt; The keyword is not fixed at this time. Alternatives that have been<br>&gt; discussed include |StaticType|, |InvariantSelf|, |SelfType|, or |Type|. The<br>&gt; community is welcome to bikeshed on the most clear and concise name for<br>&gt; this keyword.<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Draft] Introducing StaticSelf, an Invariant Self</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 14, 2016 at 12:00:00am</p></header><div class="content"><p>I&#39;m not quite sure I understand the &#39;Additional Utility&#39; section. A given class hierarchy can only have one implementation of a given static method; static  methods are effectively final. Therefore, the &#39;Self&#39; introduced in the previous proposal should be completely sufficient for invoking a static method on a class. (Likewise, for moving around code.) In fact, the previous proposal for &#39;Self&#39; used a very similar example.<br></p><p>I think the example would make more sense if it involved class methods. However, *without considering the protocol applications* I wouldn&#39;t consider that a compelling enough use case, by itself, to add StaticSelf.<br></p><p>As for StaticSelf&#39;s impact on protocols, I defer to the opinions of the other folks who&#39;ve commented on the thread.<br></p><p>Austin<br></p><p><br>&gt; On May 12, 2016, at 5:49 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Erica Sadun and I have written a proposal are following up the recent discussion thread &quot;[RFC] #Self” with a proposal to introduce StaticSelf, an invariant Self.<br>&gt; <br>&gt; The recent discussion can be found here: http://thread.gmane.org/gmane.comp.lang.swift.evolution/16565 &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/16565&gt;<br>&gt; <br>&gt; The proposal can be found here: https://github.com/anandabits/swift-evolution/blob/static-self/proposals/NNNN-static-self.md &lt;https://github.com/anandabits/swift-evolution/blob/static-self/proposals/NNNN-static-self.md&gt;<br>&gt; <br>&gt; We look forward to continuing the discussion.  We plan to submit a PR in the near future after incorporating your final feedback.<br>&gt; <br>&gt; Thanks,<br>&gt; Matthew<br>&gt; Introducing StaticSelf, an Invariant Self<br>&gt; <br>&gt; Proposal: TBD<br>&gt; Authors: Matthew Johnson &lt;https://github.com/anandabits&gt;, Erica Sadun &lt;https://github.com/erica&gt;<br>&gt; Status: TBD<br>&gt; Review manager: TBD<br>&gt; Introduction<br>&gt; <br>&gt; This proposal introduces a new keyword that provides consistent invariant type semantics in all contexts.<br>&gt; <br>&gt; The Swift-evolution thread about this topic can be found here: [RFC] #Self &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/16565&gt;<br>&gt; Motivation<br>&gt; <br>&gt; The distinction between covariant and non-covariant type references come into play when<br>&gt; conforming non-final classes to protocols. Fixing a protocol requirement to a covarying type<br>&gt; means that a method returning Self must be overriden by all subclasses in order to return<br>&gt; the correct, matching type.<br>&gt; <br>&gt; This proposal builds on the covariant construct Self accepted in SE–0068 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0068-universal-self.md&gt;<br>&gt; to introduce an invariant type identifier. It enables protocol declarations to consistently<br>&gt; refer to a type that is fixed at compile time. This ensures that subclasses can inherit<br>&gt; protocol implementations without having to re-implement that code at each level of<br>&gt; inheritance.<br>&gt; <br>&gt; Under this proposal, a new identifier keyword is fixed in use at the point of protocol conformance<br>&gt; to the static type of that construct. <br>&gt; <br>&gt; class A: MyProtocol<br>&gt; The invariant StaticSelf identifier will always refer to A, unlike Self, which is covarying and refers to<br>&gt; the type of the actual instance. Since multiple inheritance for non-protocol types is disallowed,<br>&gt; this establishes this invariant type identifier with no possibility for conflict.<br>&gt; <br>&gt; Consider the following example, under the current system:<br>&gt; <br>&gt; protocol StringCreatable {<br>&gt;     static func createWithString(s: String) -&gt; Self<br>&gt; }<br>&gt; <br>&gt; extension NSURL: StringCreatable {<br>&gt;  // cannot conform because NSURL is non-final<br>&gt;  // error: method &#39;createWithString&#39; in non-final class &#39;NSURL&#39; must return `Self` to conform to protocol &#39;A&#39;<br>&gt; }<br>&gt; Introducing a static, invariant version of Self permits the desired conformance:<br>&gt; <br>&gt; protocol StringCreatable {<br>&gt;     static func createWithString(s: String) -&gt; StaticSelf<br>&gt; }<br>&gt; <br>&gt; extension NSURL: StringCreatable {<br>&gt;  // can now conform conform because NSURL is fixed and matches the static<br>&gt;  // type of the conforming construct. Subclasses need not re-implement<br>&gt;  // NOTE: the return type can be declared as StaticSelf *or* as NSURL<br>&gt;  //       they are interchangeable<br>&gt;  static func createWithString(s: String) -&gt; StaticSelf { <br>&gt;      // ...<br>&gt;  }<br>&gt; }<br>&gt; Additional Utility<br>&gt; <br>&gt; The utility of StaticSelf is not limited to protocols. A secondary use enables code to refer to the lexical context’s current type without explicitly mentioning its name. This provides a useful shortcut when referencing static type members with especially long names and when re-purposing code between types.<br>&gt; <br>&gt; class StructWithAVeryLongName {<br>&gt;     static func foo() -&gt; String {<br>&gt;       // ...<br>&gt;     }<br>&gt;     func bar() {<br>&gt;       // ...<br>&gt;       let s = StaticSelf.foo()<br>&gt;       //<br>&gt;     }<br>&gt; }<br>&gt; Detailed Design<br>&gt; <br>&gt; This proposal introduces StaticSelf, a new keyword that may be used in protocols to refer to the invariant static type of a conforming construct. StaticSelf may also be used in the lexical context of any type declaration. In such use, the keyword is identical to spelling out the full name of that type.<br>&gt; <br>&gt; Impact on existing code<br>&gt; <br>&gt; Being additive, there should be no impact on existing code.<br>&gt; <br>&gt; Alternatives considered<br>&gt; <br>&gt; The keyword is not fixed at this time. Alternatives that have been discussed include StaticType, InvariantSelf, SelfType, or Type. The community is welcome to bikeshed on the most clear and concise name for this keyword.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160514/d89ac0cb/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
