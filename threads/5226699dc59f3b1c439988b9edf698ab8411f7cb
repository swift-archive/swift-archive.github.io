<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cf2e4441943974c6550424bb9fa45d6b?s=50"></div><header><strong>sortBy, minElementBy and maxElementBy methods</strong> from <string>Susan Cheng</string> &lt;susan.doggie at gmail.com&gt;<p>December 31, 2015 at 02:00:00pm</p></header><div class="content"><p>Consider the follows:<br></p><p><br>struct Person {<br></p><p><br></p><p>    var name: String<br></p><p>    var age: Int<br></p><p>}<br></p><p><br>let peoples = [Person(name: &quot;Hawk&quot;, age: 24), Person(name: &quot;Andrew&quot;, age: 23<br>)]<br></p><p><br>let youngest = peoples.minElement { $0.age &lt; $1.age }<br></p><p><br>print(youngest?.name)<br></p><p><br>it&#39;s silly that we always have to write the code like { $0.some &lt; $1.some }<br>or { some($0) &lt; some($1) }<br></p><p><br>so, we should add those methods to stdlib:<br></p><p><br>extension SequenceType {<br></p><p>    /// Returns the minimum element in `self` or `nil` if the sequence is<br>empty.<br></p><p>    ///<br></p><p>    /// - Complexity: O(`elements.count`).<br></p><p>    ///<br></p><p>    @warn_unused_result<br></p><p>    public func minElement&lt;R : Comparable&gt;(@noescape by:<br>(Generator.Element) throws -&gt; R) rethrows -&gt; Generator.Element? {<br></p><p>        return try self.minElement { try by($0) &lt; by($1) }<br></p><p>    }<br></p><p>    /// Returns the maximum element in `self` or `nil` if the sequence is<br>empty.<br></p><p>    ///<br></p><p>    /// - Complexity: O(`elements.count`).<br></p><p>    ///<br></p><p>    @warn_unused_result<br></p><p>    public func maxElement&lt;R : Comparable&gt;(@noescape by:<br>(Generator.Element) throws -&gt; R) rethrows -&gt; Generator.Element? {<br></p><p>        return try self.maxElement { try by($0) &lt; by($1) }<br></p><p>    }<br></p><p>}<br></p><p><br>public extension MutableCollectionType {<br></p><p><br></p><p>    /// Return an `Array` containing the sorted elements of `source`.<br></p><p>    /// according to `by`.<br></p><p>    ///<br></p><p>    /// The sorting algorithm is not stable (can change the relative order<br>of<br></p><p>    /// elements that compare equal).<br></p><p>    @warn_unused_result(mutable_variant=&quot;sortInPlace&quot;)<br></p><p>    func sort&lt;R : Comparable&gt;(@noescape by: (Generator.Element) -&gt; R) -&gt; [<br>Generator.Element] {<br></p><p>        return self.sort { by($0) &lt; by($1) }<br></p><p>    }<br></p><p>}<br></p><p><br>public extension MutableCollectionType where Self.Index :<br>RandomAccessIndexType {<br></p><p><br></p><p>    /// Sort `self` in-place according to `by`.<br></p><p>    ///<br></p><p>    /// The sorting algorithm is not stable (can change the relative order<br>of<br></p><p>    /// elements that compare equal).<br></p><p>    mutating func sortInPlace&lt;R : Comparable&gt;(@noescape by: (Generator.<br>Element) -&gt; R) {<br></p><p>        self.sortInPlace { by($0) &lt; by($1) }<br></p><p>    }<br></p><p>}<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/5226f7cb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>sortBy, minElementBy and maxElementBy methods</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>December 30, 2015 at 11:00:00pm</p></header><div class="content"><p>+1, although I wonder if the method names should be distinct (such as<br>minElementBy, sortBy, etc.)<br></p><p>On Wed, Dec 30, 2015 at 10:38 PM, Susan Cheng via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; Consider the follows:<br>&gt;<br>&gt;<br>&gt; struct Person {<br>&gt;<br>&gt;<br>&gt;<br>&gt;     var name: String<br>&gt;<br>&gt;     var age: Int<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; let peoples = [Person(name: &quot;Hawk&quot;, age: 24), Person(name: &quot;Andrew&quot;, age:<br>&gt; 23)]<br>&gt;<br>&gt;<br>&gt; let youngest = peoples.minElement { $0.age &lt; $1.age }<br>&gt;<br>&gt;<br>&gt; print(youngest?.name)<br>&gt;<br>&gt;<br>&gt; it&#39;s silly that we always have to write the code like { $0.some &lt; $1.some }<br>&gt; or { some($0) &lt; some($1) }<br>&gt;<br>&gt;<br>&gt; so, we should add those methods to stdlib:<br>&gt;<br>&gt;<br>&gt; extension SequenceType {<br>&gt;<br>&gt;     /// Returns the minimum element in `self` or `nil` if the sequence is<br>&gt; empty.<br>&gt;<br>&gt;     ///<br>&gt;<br>&gt;     /// - Complexity: O(`elements.count`).<br>&gt;<br>&gt;     ///<br>&gt;<br>&gt;     @warn_unused_result<br>&gt;<br>&gt;     public func minElement&lt;R : Comparable&gt;(@noescape by:<br>&gt; (Generator.Element) throws -&gt; R) rethrows -&gt; Generator.Element? {<br>&gt;<br>&gt;         return try self.minElement { try by($0) &lt; by($1) }<br>&gt;<br>&gt;     }<br>&gt;<br>&gt;     /// Returns the maximum element in `self` or `nil` if the sequence is<br>&gt; empty.<br>&gt;<br>&gt;     ///<br>&gt;<br>&gt;     /// - Complexity: O(`elements.count`).<br>&gt;<br>&gt;     ///<br>&gt;<br>&gt;     @warn_unused_result<br>&gt;<br>&gt;     public func maxElement&lt;R : Comparable&gt;(@noescape by:<br>&gt; (Generator.Element) throws -&gt; R) rethrows -&gt; Generator.Element? {<br>&gt;<br>&gt;         return try self.maxElement { try by($0) &lt; by($1) }<br>&gt;<br>&gt;     }<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; public extension MutableCollectionType {<br>&gt;<br>&gt;<br>&gt;<br>&gt;     /// Return an `Array` containing the sorted elements of `source`.<br>&gt;<br>&gt;     /// according to `by`.<br>&gt;<br>&gt;     ///<br>&gt;<br>&gt;     /// The sorting algorithm is not stable (can change the relative<br>&gt; order of<br>&gt;<br>&gt;     /// elements that compare equal).<br>&gt;<br>&gt;     @warn_unused_result(mutable_variant=&quot;sortInPlace&quot;)<br>&gt;<br>&gt;     func sort&lt;R : Comparable&gt;(@noescape by: (Generator.Element) -&gt; R) -&gt; [<br>&gt; Generator.Element] {<br>&gt;<br>&gt;         return self.sort { by($0) &lt; by($1) }<br>&gt;<br>&gt;     }<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; public extension MutableCollectionType where Self.Index :<br>&gt; RandomAccessIndexType {<br>&gt;<br>&gt;<br>&gt;<br>&gt;     /// Sort `self` in-place according to `by`.<br>&gt;<br>&gt;     ///<br>&gt;<br>&gt;     /// The sorting algorithm is not stable (can change the relative<br>&gt; order of<br>&gt;<br>&gt;     /// elements that compare equal).<br>&gt;<br>&gt;     mutating func sortInPlace&lt;R : Comparable&gt;(@noescape by: (Generator.<br>&gt; Element) -&gt; R) {<br>&gt;<br>&gt;         self.sortInPlace { by($0) &lt; by($1) }<br>&gt;<br>&gt;     }<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/b089eec8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cf2e4441943974c6550424bb9fa45d6b?s=50"></div><header><strong>sortBy, minElementBy and maxElementBy methods</strong> from <string>Susan Cheng</string> &lt;susan.doggie at gmail.com&gt;<p>December 31, 2015 at 04:00:00pm</p></header><div class="content"><p>yes.<br>Shouldn&#39;t have shorter names to replace the minElementBy, maxElementBy and<br>sortInPlaceBy<br></p><p>minBy and maxBy?<br></p><p>Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; 於 2015年12月31日星期四 寫道：<br></p><p>&gt; +1, although I wonder if the method names should be distinct (such as<br>&gt; minElementBy, sortBy, etc.)<br>&gt;<br>&gt; On Wed, Dec 30, 2015 at 10:38 PM, Susan Cheng via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; Consider the follows:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; struct Person {<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     var name: String<br>&gt;&gt;<br>&gt;&gt;     var age: Int<br>&gt;&gt;<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; let peoples = [Person(name: &quot;Hawk&quot;, age: 24), Person(name: &quot;Andrew&quot;,<br>&gt;&gt; age: 23)]<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; let youngest = peoples.minElement { $0.age &lt; $1.age }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; print(youngest?.name)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; it&#39;s silly that we always have to write the code like { $0.some &lt; $1.some }<br>&gt;&gt; or { some($0) &lt; some($1) }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; so, we should add those methods to stdlib:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; extension SequenceType {<br>&gt;&gt;<br>&gt;&gt;     /// Returns the minimum element in `self` or `nil` if the sequence<br>&gt;&gt; is empty.<br>&gt;&gt;<br>&gt;&gt;     ///<br>&gt;&gt;<br>&gt;&gt;     /// - Complexity: O(`elements.count`).<br>&gt;&gt;<br>&gt;&gt;     ///<br>&gt;&gt;<br>&gt;&gt;     @warn_unused_result<br>&gt;&gt;<br>&gt;&gt;     public func minElement&lt;R : Comparable&gt;(@noescape by:<br>&gt;&gt; (Generator.Element) throws -&gt; R) rethrows -&gt; Generator.Element? {<br>&gt;&gt;<br>&gt;&gt;         return try self.minElement { try by($0) &lt; by($1) }<br>&gt;&gt;<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;     /// Returns the maximum element in `self` or `nil` if the sequence<br>&gt;&gt; is empty.<br>&gt;&gt;<br>&gt;&gt;     ///<br>&gt;&gt;<br>&gt;&gt;     /// - Complexity: O(`elements.count`).<br>&gt;&gt;<br>&gt;&gt;     ///<br>&gt;&gt;<br>&gt;&gt;     @warn_unused_result<br>&gt;&gt;<br>&gt;&gt;     public func maxElement&lt;R : Comparable&gt;(@noescape by:<br>&gt;&gt; (Generator.Element) throws -&gt; R) rethrows -&gt; Generator.Element? {<br>&gt;&gt;<br>&gt;&gt;         return try self.maxElement { try by($0) &lt; by($1) }<br>&gt;&gt;<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; public extension MutableCollectionType {<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     /// Return an `Array` containing the sorted elements of `source`.<br>&gt;&gt;<br>&gt;&gt;     /// according to `by`.<br>&gt;&gt;<br>&gt;&gt;     ///<br>&gt;&gt;<br>&gt;&gt;     /// The sorting algorithm is not stable (can change the relative<br>&gt;&gt; order of<br>&gt;&gt;<br>&gt;&gt;     /// elements that compare equal).<br>&gt;&gt;<br>&gt;&gt;     @warn_unused_result(mutable_variant=&quot;sortInPlace&quot;)<br>&gt;&gt;<br>&gt;&gt;     func sort&lt;R : Comparable&gt;(@noescape by: (Generator.Element) -&gt; R) -&gt;<br>&gt;&gt; [Generator.Element] {<br>&gt;&gt;<br>&gt;&gt;         return self.sort { by($0) &lt; by($1) }<br>&gt;&gt;<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; public extension MutableCollectionType where Self.Index :<br>&gt;&gt; RandomAccessIndexType {<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     /// Sort `self` in-place according to `by`.<br>&gt;&gt;<br>&gt;&gt;     ///<br>&gt;&gt;<br>&gt;&gt;     /// The sorting algorithm is not stable (can change the relative<br>&gt;&gt; order of<br>&gt;&gt;<br>&gt;&gt;     /// elements that compare equal).<br>&gt;&gt;<br>&gt;&gt;     mutating func sortInPlace&lt;R : Comparable&gt;(@noescape by: (Generator.<br>&gt;&gt; Element) -&gt; R) {<br>&gt;&gt;<br>&gt;&gt;         self.sortInPlace { by($0) &lt; by($1) }<br>&gt;&gt;<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/70dcd4b7/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>sortBy, minElementBy and maxElementBy methods</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 30, 2015 at 11:00:00pm</p></header><div class="content"><p>Why add all those algorithms when you can write this<br></p><p>func byComparing&lt;T, U: Comparable&gt;(getComparisonKey: (T)-&gt;U) -&gt; (T, T) -&gt; Bool {<br>  return { getComparisonKey($0) &lt; getComparisonKey($1) }<br>}<br></p><p>peoples.sort(byComparing { $0.name })<br></p><p>?<br></p><p>-Dave<br></p><p>&gt; On Dec 30, 2015, at 10:38 PM, Susan Cheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Consider the follows:<br>&gt; <br>&gt; struct Person {<br>&gt;     <br>&gt;     var name: String<br>&gt;     var age: Int<br>&gt; }<br>&gt; <br>&gt; let peoples = [Person(name: &quot;Hawk&quot;, age: 24), Person(name: &quot;Andrew&quot;, age: 23)]<br>&gt; <br>&gt; let youngest = peoples.minElement { $0.age &lt; $1.age }<br>&gt; <br>&gt; print(youngest?.name)<br>&gt; <br>&gt; it&#39;s silly that we always have to write the code like { $0.some &lt; $1.some } or { some($0) &lt; some($1) }<br>&gt; <br>&gt; so, we should add those methods to stdlib:<br>&gt; <br>&gt; extension SequenceType {<br>&gt;     /// Returns the minimum element in `self` or `nil` if the sequence is empty.<br>&gt;     ///<br>&gt;     /// - Complexity: O(`elements.count`).<br>&gt;     ///<br>&gt;     @warn_unused_result<br>&gt;     public func minElement&lt;R : Comparable&gt;(@noescape by: (Generator.Element) throws -&gt; R) rethrows -&gt; Generator.Element? {<br>&gt;         return try self.minElement { try by($0) &lt; by($1) }<br>&gt;     }<br>&gt;     /// Returns the maximum element in `self` or `nil` if the sequence is empty.<br>&gt;     ///<br>&gt;     /// - Complexity: O(`elements.count`).<br>&gt;     ///<br>&gt;     @warn_unused_result<br>&gt;     public func maxElement&lt;R : Comparable&gt;(@noescape by: (Generator.Element) throws -&gt; R) rethrows -&gt; Generator.Element? {<br>&gt;         return try self.maxElement { try by($0) &lt; by($1) }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; public extension MutableCollectionType {<br>&gt;     <br>&gt;     /// Return an `Array` containing the sorted elements of `source`.<br>&gt;     /// according to `by`.<br>&gt;     ///<br>&gt;     /// The sorting algorithm is not stable (can change the relative order of<br>&gt;     /// elements that compare equal).<br>&gt;     @warn_unused_result(mutable_variant=&quot;sortInPlace&quot;)<br>&gt;     func sort&lt;R : Comparable&gt;(@noescape by: (Generator.Element) -&gt; R) -&gt; [Generator.Element] {<br>&gt;         return self.sort { by($0) &lt; by($1) }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; public extension MutableCollectionType where Self.Index : RandomAccessIndexType {<br>&gt;     <br>&gt;     /// Sort `self` in-place according to `by`.<br>&gt;     ///<br>&gt;     /// The sorting algorithm is not stable (can change the relative order of<br>&gt;     /// elements that compare equal).<br>&gt;     mutating func sortInPlace&lt;R : Comparable&gt;(@noescape by: (Generator.Element) -&gt; R) {<br>&gt;         self.sortInPlace { by($0) &lt; by($1) }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/4b87b538/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cf2e4441943974c6550424bb9fa45d6b?s=50"></div><header><strong>sortBy, minElementBy and maxElementBy methods</strong> from <string>Susan Cheng</string> &lt;susan.doggie at gmail.com&gt;<p>December 31, 2015 at 04:00:00pm</p></header><div class="content"><p>It confuses people if provide a global function byComparing in stdlib<br>which&#39;s doing nothing alone.<br></p><p>Dave Abrahams &lt;dabrahams at apple.com&gt; 於 2015年12月31日星期四 寫道：<br></p><p>&gt; Why add all those algorithms when you can write this<br>&gt;<br>&gt; func byComparing&lt;T, U: Comparable&gt;(getComparisonKey: (T)-&gt;U) -&gt; (T, T) -&gt;<br>&gt; Bool {<br>&gt;   return { getComparisonKey($0) &lt; getComparisonKey($1) }<br>&gt; }<br>&gt;<br>&gt; peoples.sort(byComparing { $0.name })<br>&gt;<br>&gt; ?<br>&gt;<br>&gt; -Dave<br>&gt;<br>&gt; On Dec 30, 2015, at 10:38 PM, Susan Cheng via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt;<br>&gt; Consider the follows:<br>&gt;<br>&gt; struct Person {<br>&gt;<br>&gt;<br>&gt;     var name: String<br>&gt;     var age: Int<br>&gt; }<br>&gt;<br>&gt; let peoples = [Person(name: &quot;Hawk&quot;, age: 24), Person(name: &quot;Andrew&quot;, age:<br>&gt; 23)]<br>&gt;<br>&gt; let youngest = peoples.minElement { $0.age &lt; $1.age }<br>&gt;<br>&gt; print(youngest?.name)<br>&gt;<br>&gt; it&#39;s silly that we always have to write the code like { $0.some &lt; $1.some }<br>&gt; or { some($0) &lt; some($1) }<br>&gt;<br>&gt; so, we should add those methods to stdlib:<br>&gt;<br>&gt; extension SequenceType {<br>&gt;     /// Returns the minimum element in `self` or `nil` if the sequence is<br>&gt; empty.<br>&gt;     ///<br>&gt;     /// - Complexity: O(`elements.count`).<br>&gt;     ///<br>&gt;     @warn_unused_result<br>&gt;     public func minElement&lt;R : Comparable&gt;(@noescape by:<br>&gt; (Generator.Element) throws -&gt; R) rethrows -&gt; Generator.Element? {<br>&gt;         return try self.minElement { try by($0) &lt; by($1) }<br>&gt;     }<br>&gt;     /// Returns the maximum element in `self` or `nil` if the sequence is<br>&gt; empty.<br>&gt;     ///<br>&gt;     /// - Complexity: O(`elements.count`).<br>&gt;     ///<br>&gt;     @warn_unused_result<br>&gt;     public func maxElement&lt;R : Comparable&gt;(@noescape by:<br>&gt; (Generator.Element) throws -&gt; R) rethrows -&gt; Generator.Element? {<br>&gt;         return try self.maxElement { try by($0) &lt; by($1) }<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; public extension MutableCollectionType {<br>&gt;<br>&gt;<br>&gt;     /// Return an `Array` containing the sorted elements of `source`.<br>&gt;     /// according to `by`.<br>&gt;     ///<br>&gt;     /// The sorting algorithm is not stable (can change the relative<br>&gt; order of<br>&gt;     /// elements that compare equal).<br>&gt;     @warn_unused_result(mutable_variant=&quot;sortInPlace&quot;)<br>&gt;     func sort&lt;R : Comparable&gt;(@noescape by: (Generator.Element) -&gt; R) -&gt; [<br>&gt; Generator.Element] {<br>&gt;         return self.sort { by($0) &lt; by($1) }<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; public extension MutableCollectionType where Self.Index :<br>&gt; RandomAccessIndexType {<br>&gt;<br>&gt;<br>&gt;     /// Sort `self` in-place according to `by`.<br>&gt;     ///<br>&gt;     /// The sorting algorithm is not stable (can change the relative<br>&gt; order of<br>&gt;     /// elements that compare equal).<br>&gt;     mutating func sortInPlace&lt;R : Comparable&gt;(@noescape by: (Generator.<br>&gt; Element) -&gt; R) {<br>&gt;         self.sortInPlace { by($0) &lt; by($1) }<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/b444c20e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>sortBy, minElementBy and maxElementBy methods</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 31, 2015 at 12:00:00am</p></header><div class="content"><p>I don’t understand that argument.  Obviously the function would be documented and there would be examples showing how to use it.  Why would it confuse people?<br></p><p>I think you’d need much stronger reasons to justify adding an unbounded set of overloads (is every algorithm that takes a comparison closure going to get one of these?) when we can handle the problem economically with a single function.<br></p><p>-Dave<br></p><p>&gt; On Dec 31, 2015, at 12:04 AM, Susan Cheng &lt;susan.doggie at gmail.com&gt; wrote:<br>&gt; <br>&gt; It confuses people if provide a global function byComparing in stdlib which&#39;s doing nothing alone.<br>&gt; <br>&gt; Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; 於 2015年12月31日星期四 寫道：<br>&gt; Why add all those algorithms when you can write this<br>&gt; <br>&gt; func byComparing&lt;T, U: Comparable&gt;(getComparisonKey: (T)-&gt;U) -&gt; (T, T) -&gt; Bool {<br>&gt;   return { getComparisonKey($0) &lt; getComparisonKey($1) }<br>&gt; }<br>&gt; <br>&gt; peoples.sort(byComparing { $0.name &lt;http://0.name/&gt; })<br>&gt; <br>&gt; ?<br>&gt; <br>&gt; -Dave<br>&gt; <br>&gt;&gt; On Dec 30, 2015, at 10:38 PM, Susan Cheng via swift-evolution &lt;swift-evolution at swift.org &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Consider the follows:<br>&gt;&gt; <br>&gt;&gt; struct Person {<br>&gt;&gt;     <br>&gt;&gt;     var name: String<br>&gt;&gt;     var age: Int<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let peoples = [Person(name: &quot;Hawk&quot;, age: 24), Person(name: &quot;Andrew&quot;, age: 23)]<br>&gt;&gt; <br>&gt;&gt; let youngest = peoples.minElement { $0.age &lt; $1.age }<br>&gt;&gt; <br>&gt;&gt; print(youngest?.name)<br>&gt;&gt; <br>&gt;&gt; it&#39;s silly that we always have to write the code like { $0.some &lt; $1.some } or { some($0) &lt; some($1) }<br>&gt;&gt; <br>&gt;&gt; so, we should add those methods to stdlib:<br>&gt;&gt; <br>&gt;&gt; extension SequenceType {<br>&gt;&gt;     /// Returns the minimum element in `self` or `nil` if the sequence is empty.<br>&gt;&gt;     ///<br>&gt;&gt;     /// - Complexity: O(`elements.count`).<br>&gt;&gt;     ///<br>&gt;&gt;     @warn_unused_result<br>&gt;&gt;     public func minElement&lt;R : Comparable&gt;(@noescape by: (Generator.Element) throws -&gt; R) rethrows -&gt; Generator.Element? {<br>&gt;&gt;         return try self.minElement { try by($0) &lt; by($1) }<br>&gt;&gt;     }<br>&gt;&gt;     /// Returns the maximum element in `self` or `nil` if the sequence is empty.<br>&gt;&gt;     ///<br>&gt;&gt;     /// - Complexity: O(`elements.count`).<br>&gt;&gt;     ///<br>&gt;&gt;     @warn_unused_result<br>&gt;&gt;     public func maxElement&lt;R : Comparable&gt;(@noescape by: (Generator.Element) throws -&gt; R) rethrows -&gt; Generator.Element? {<br>&gt;&gt;         return try self.maxElement { try by($0) &lt; by($1) }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; public extension MutableCollectionType {<br>&gt;&gt;     <br>&gt;&gt;     /// Return an `Array` containing the sorted elements of `source`.<br>&gt;&gt;     /// according to `by`.<br>&gt;&gt;     ///<br>&gt;&gt;     /// The sorting algorithm is not stable (can change the relative order of<br>&gt;&gt;     /// elements that compare equal).<br>&gt;&gt;     @warn_unused_result(mutable_variant=&quot;sortInPlace&quot;)<br>&gt;&gt;     func sort&lt;R : Comparable&gt;(@noescape by: (Generator.Element) -&gt; R) -&gt; [Generator.Element] {<br>&gt;&gt;         return self.sort { by($0) &lt; by($1) }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; public extension MutableCollectionType where Self.Index : RandomAccessIndexType {<br>&gt;&gt;     <br>&gt;&gt;     /// Sort `self` in-place according to `by`.<br>&gt;&gt;     ///<br>&gt;&gt;     /// The sorting algorithm is not stable (can change the relative order of<br>&gt;&gt;     /// elements that compare equal).<br>&gt;&gt;     mutating func sortInPlace&lt;R : Comparable&gt;(@noescape by: (Generator.Element) -&gt; R) {<br>&gt;&gt;         self.sortInPlace { by($0) &lt; by($1) }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/5b15af17/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cf2e4441943974c6550424bb9fa45d6b?s=50"></div><header><strong>sortBy, minElementBy and maxElementBy methods</strong> from <string>Susan Cheng</string> &lt;susan.doggie at gmail.com&gt;<p>December 31, 2015 at 04:00:00pm</p></header><div class="content"><p>And how do you write a @noescape version with this function?<br></p><p>Dave Abrahams &lt;dabrahams at apple.com&gt; 於 2015年12月31日星期四 寫道：<br></p><p>&gt; I don’t understand that argument.  Obviously the function would be<br>&gt; documented and there would be examples showing how to use it.  Why would it<br>&gt; confuse people?<br>&gt;<br>&gt; I think you’d need much stronger reasons to justify adding an unbounded<br>&gt; set of overloads (is every algorithm that takes a comparison closure going<br>&gt; to get one of these?) when we can handle the problem economically with a<br>&gt; single function.<br>&gt;<br>&gt; -Dave<br>&gt;<br>&gt; On Dec 31, 2015, at 12:04 AM, Susan Cheng &lt;susan.doggie at gmail.com<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;susan.doggie at gmail.com&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt; It confuses people if provide a global function byComparing in stdlib<br>&gt; which&#39;s doing nothing alone.<br>&gt;<br>&gt; Dave Abrahams &lt;dabrahams at apple.com<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;dabrahams at apple.com&#39;);&gt;&gt; 於 2015年12月31日星期四<br>&gt; 寫道：<br>&gt;<br>&gt;&gt; Why add all those algorithms when you can write this<br>&gt;&gt;<br>&gt;&gt; func byComparing&lt;T, U: Comparable&gt;(getComparisonKey: (T)-&gt;U) -&gt; (T, T) -&gt;<br>&gt;&gt; Bool {<br>&gt;&gt;   return { getComparisonKey($0) &lt; getComparisonKey($1) }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; peoples.sort(byComparing { $0.name })<br>&gt;&gt;<br>&gt;&gt; ?<br>&gt;&gt;<br>&gt;&gt; -Dave<br>&gt;&gt;<br>&gt;&gt; On Dec 30, 2015, at 10:38 PM, Susan Cheng via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Consider the follows:<br>&gt;&gt;<br>&gt;&gt; struct Person {<br>&gt;&gt;<br>&gt;&gt;     var name: String<br>&gt;&gt;     var age: Int<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; let peoples = [Person(name: &quot;Hawk&quot;, age: 24), Person(name: &quot;Andrew&quot;,<br>&gt;&gt; age: 23)]<br>&gt;&gt;<br>&gt;&gt; let youngest = peoples.minElement { $0.age &lt; $1.age }<br>&gt;&gt;<br>&gt;&gt; print(youngest?.name)<br>&gt;&gt;<br>&gt;&gt; it&#39;s silly that we always have to write the code like { $0.some &lt; $1.some }<br>&gt;&gt; or { some($0) &lt; some($1) }<br>&gt;&gt;<br>&gt;&gt; so, we should add those methods to stdlib:<br>&gt;&gt;<br>&gt;&gt; extension SequenceType {<br>&gt;&gt;     /// Returns the minimum element in `self` or `nil` if the sequence<br>&gt;&gt; is empty.<br>&gt;&gt;     ///<br>&gt;&gt;     /// - Complexity: O(`elements.count`).<br>&gt;&gt;     ///<br>&gt;&gt;     @warn_unused_result<br>&gt;&gt;     public func minElement&lt;R : Comparable&gt;(@noescape by:<br>&gt;&gt; (Generator.Element) throws -&gt; R) rethrows -&gt; Generator.Element? {<br>&gt;&gt;         return try self.minElement { try by($0) &lt; by($1) }<br>&gt;&gt;     }<br>&gt;&gt;     /// Returns the maximum element in `self` or `nil` if the sequence<br>&gt;&gt; is empty.<br>&gt;&gt;     ///<br>&gt;&gt;     /// - Complexity: O(`elements.count`).<br>&gt;&gt;     ///<br>&gt;&gt;     @warn_unused_result<br>&gt;&gt;     public func maxElement&lt;R : Comparable&gt;(@noescape by:<br>&gt;&gt; (Generator.Element) throws -&gt; R) rethrows -&gt; Generator.Element? {<br>&gt;&gt;         return try self.maxElement { try by($0) &lt; by($1) }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; public extension MutableCollectionType {<br>&gt;&gt;<br>&gt;&gt;     /// Return an `Array` containing the sorted elements of `source`.<br>&gt;&gt;     /// according to `by`.<br>&gt;&gt;     ///<br>&gt;&gt;     /// The sorting algorithm is not stable (can change the relative<br>&gt;&gt; order of<br>&gt;&gt;     /// elements that compare equal).<br>&gt;&gt;     @warn_unused_result(mutable_variant=&quot;sortInPlace&quot;)<br>&gt;&gt;     func sort&lt;R : Comparable&gt;(@noescape by: (Generator.Element) -&gt; R) -&gt;<br>&gt;&gt; [Generator.Element] {<br>&gt;&gt;         return self.sort { by($0) &lt; by($1) }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; public extension MutableCollectionType where Self.Index :<br>&gt;&gt; RandomAccessIndexType {<br>&gt;&gt;<br>&gt;&gt;     /// Sort `self` in-place according to `by`.<br>&gt;&gt;     ///<br>&gt;&gt;     /// The sorting algorithm is not stable (can change the relative<br>&gt;&gt; order of<br>&gt;&gt;     /// elements that compare equal).<br>&gt;&gt;     mutating func sortInPlace&lt;R : Comparable&gt;(@noescape by: (Generator.<br>&gt;&gt; Element) -&gt; R) {<br>&gt;&gt;         self.sortInPlace { by($0) &lt; by($1) }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/c82c58ce/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>sortBy, minElementBy and maxElementBy methods</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 31, 2015 at 12:00:00am</p></header><div class="content"><p>You don’t.  Is that a problem for the intended use-cases?<br></p><p>-Dave<br></p><p>&gt; On Dec 31, 2015, at 12:11 AM, Susan Cheng &lt;susan.doggie at gmail.com&gt; wrote:<br>&gt; <br>&gt; And how do you write a @noescape version with this function?<br>&gt; <br>&gt; Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; 於 2015年12月31日星期四 寫道：<br>&gt; I don’t understand that argument.  Obviously the function would be documented and there would be examples showing how to use it.  Why would it confuse people?<br>&gt; <br>&gt; I think you’d need much stronger reasons to justify adding an unbounded set of overloads (is every algorithm that takes a comparison closure going to get one of these?) when we can handle the problem economically with a single function.<br>&gt; <br>&gt; -Dave<br>&gt; <br>&gt;&gt; On Dec 31, 2015, at 12:04 AM, Susan Cheng &lt;susan.doggie at gmail.com &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;susan.doggie at gmail.com&#39;);&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; It confuses people if provide a global function byComparing in stdlib which&#39;s doing nothing alone.<br>&gt;&gt; <br>&gt;&gt; Dave Abrahams &lt;dabrahams at apple.com &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;dabrahams at apple.com&#39;);&gt;&gt; 於 2015年12月31日星期四 寫道：<br>&gt;&gt; Why add all those algorithms when you can write this<br>&gt;&gt; <br>&gt;&gt; func byComparing&lt;T, U: Comparable&gt;(getComparisonKey: (T)-&gt;U) -&gt; (T, T) -&gt; Bool {<br>&gt;&gt;   return { getComparisonKey($0) &lt; getComparisonKey($1) }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; peoples.sort(byComparing { $0.name &lt;http://0.name/&gt; })<br>&gt;&gt; <br>&gt;&gt; ?<br>&gt;&gt; <br>&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 30, 2015, at 10:38 PM, Susan Cheng via swift-evolution &lt;swift-evolution at swift.org &lt;&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Consider the follows:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Person {<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     var name: String<br>&gt;&gt;&gt;     var age: Int<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let peoples = [Person(name: &quot;Hawk&quot;, age: 24), Person(name: &quot;Andrew&quot;, age: 23)]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let youngest = peoples.minElement { $0.age &lt; $1.age }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; print(youngest?.name)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; it&#39;s silly that we always have to write the code like { $0.some &lt; $1.some } or { some($0) &lt; some($1) }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; so, we should add those methods to stdlib:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension SequenceType {<br>&gt;&gt;&gt;     /// Returns the minimum element in `self` or `nil` if the sequence is empty.<br>&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;     /// - Complexity: O(`elements.count`).<br>&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;     @warn_unused_result<br>&gt;&gt;&gt;     public func minElement&lt;R : Comparable&gt;(@noescape by: (Generator.Element) throws -&gt; R) rethrows -&gt; Generator.Element? {<br>&gt;&gt;&gt;         return try self.minElement { try by($0) &lt; by($1) }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     /// Returns the maximum element in `self` or `nil` if the sequence is empty.<br>&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;     /// - Complexity: O(`elements.count`).<br>&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;     @warn_unused_result<br>&gt;&gt;&gt;     public func maxElement&lt;R : Comparable&gt;(@noescape by: (Generator.Element) throws -&gt; R) rethrows -&gt; Generator.Element? {<br>&gt;&gt;&gt;         return try self.maxElement { try by($0) &lt; by($1) }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public extension MutableCollectionType {<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     /// Return an `Array` containing the sorted elements of `source`.<br>&gt;&gt;&gt;     /// according to `by`.<br>&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;     /// The sorting algorithm is not stable (can change the relative order of<br>&gt;&gt;&gt;     /// elements that compare equal).<br>&gt;&gt;&gt;     @warn_unused_result(mutable_variant=&quot;sortInPlace&quot;)<br>&gt;&gt;&gt;     func sort&lt;R : Comparable&gt;(@noescape by: (Generator.Element) -&gt; R) -&gt; [Generator.Element] {<br>&gt;&gt;&gt;         return self.sort { by($0) &lt; by($1) }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public extension MutableCollectionType where Self.Index : RandomAccessIndexType {<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     /// Sort `self` in-place according to `by`.<br>&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;     /// The sorting algorithm is not stable (can change the relative order of<br>&gt;&gt;&gt;     /// elements that compare equal).<br>&gt;&gt;&gt;     mutating func sortInPlace&lt;R : Comparable&gt;(@noescape by: (Generator.Element) -&gt; R) {<br>&gt;&gt;&gt;         self.sortInPlace { by($0) &lt; by($1) }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/5e0748d7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>sortBy, minElementBy and maxElementBy methods</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>December 31, 2015 at 12:00:00am</p></header><div class="content"><p>With the optimizer as it is today, if this were @_transparent could the<br>extra function invocation(s) be optimized out when you use it in a<br>non-escaping context such as sort()?<br></p><p>Jacob<br></p><p>On Thu, Dec 31, 2015 at 12:26 AM, Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; You don’t.  Is that a problem for the intended use-cases?<br>&gt;<br>&gt; -Dave<br>&gt;<br>&gt; On Dec 31, 2015, at 12:11 AM, Susan Cheng &lt;susan.doggie at gmail.com&gt; wrote:<br>&gt;<br>&gt; And how do you write a @noescape version with this function?<br>&gt;<br>&gt; Dave Abrahams &lt;dabrahams at apple.com&gt; 於 2015年12月31日星期四 寫道：<br>&gt;<br>&gt;&gt; I don’t understand that argument.  Obviously the function would be<br>&gt;&gt; documented and there would be examples showing how to use it.  Why would it<br>&gt;&gt; confuse people?<br>&gt;&gt;<br>&gt;&gt; I think you’d need much stronger reasons to justify adding an unbounded<br>&gt;&gt; set of overloads (is every algorithm that takes a comparison closure going<br>&gt;&gt; to get one of these?) when we can handle the problem economically with a<br>&gt;&gt; single function.<br>&gt;&gt;<br>&gt;&gt; -Dave<br>&gt;&gt;<br>&gt;&gt; On Dec 31, 2015, at 12:04 AM, Susan Cheng &lt;susan.doggie at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; It confuses people if provide a global function byComparing in stdlib<br>&gt;&gt; which&#39;s doing nothing alone.<br>&gt;&gt;<br>&gt;&gt; Dave Abrahams &lt;dabrahams at apple.com&gt; 於 2015年12月31日星期四 寫道：<br>&gt;&gt;<br>&gt;&gt;&gt; Why add all those algorithms when you can write this<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func byComparing&lt;T, U: Comparable&gt;(getComparisonKey: (T)-&gt;U) -&gt; (T, T)<br>&gt;&gt;&gt; -&gt; Bool {<br>&gt;&gt;&gt;   return { getComparisonKey($0) &lt; getComparisonKey($1) }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; peoples.sort(byComparing { $0.name })<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Dec 30, 2015, at 10:38 PM, Susan Cheng via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Consider the follows:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; struct Person {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     var name: String<br>&gt;&gt;&gt;     var age: Int<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let peoples = [Person(name: &quot;Hawk&quot;, age: 24), Person(name: &quot;Andrew&quot;,<br>&gt;&gt;&gt; age: 23)]<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let youngest = peoples.minElement { $0.age &lt; $1.age }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; print(youngest?.name)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; it&#39;s silly that we always have to write the code like { $0.some &lt; $1.<br>&gt;&gt;&gt; some } or { some($0) &lt; some($1) }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; so, we should add those methods to stdlib:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; extension SequenceType {<br>&gt;&gt;&gt;     /// Returns the minimum element in `self` or `nil` if the sequence<br>&gt;&gt;&gt; is empty.<br>&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;     /// - Complexity: O(`elements.count`).<br>&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;     @warn_unused_result<br>&gt;&gt;&gt;     public func minElement&lt;R : Comparable&gt;(@noescape by:<br>&gt;&gt;&gt; (Generator.Element) throws -&gt; R) rethrows -&gt; Generator.Element? {<br>&gt;&gt;&gt;         return try self.minElement { try by($0) &lt; by($1) }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     /// Returns the maximum element in `self` or `nil` if the sequence<br>&gt;&gt;&gt; is empty.<br>&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;     /// - Complexity: O(`elements.count`).<br>&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;     @warn_unused_result<br>&gt;&gt;&gt;     public func maxElement&lt;R : Comparable&gt;(@noescape by:<br>&gt;&gt;&gt; (Generator.Element) throws -&gt; R) rethrows -&gt; Generator.Element? {<br>&gt;&gt;&gt;         return try self.maxElement { try by($0) &lt; by($1) }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; public extension MutableCollectionType {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     /// Return an `Array` containing the sorted elements of `source`.<br>&gt;&gt;&gt;     /// according to `by`.<br>&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;     /// The sorting algorithm is not stable (can change the relative<br>&gt;&gt;&gt; order of<br>&gt;&gt;&gt;     /// elements that compare equal).<br>&gt;&gt;&gt;     @warn_unused_result(mutable_variant=&quot;sortInPlace&quot;)<br>&gt;&gt;&gt;     func sort&lt;R : Comparable&gt;(@noescape by: (Generator.Element) -&gt; R)<br>&gt;&gt;&gt; -&gt; [Generator.Element] {<br>&gt;&gt;&gt;         return self.sort { by($0) &lt; by($1) }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; public extension MutableCollectionType where Self.Index :<br>&gt;&gt;&gt; RandomAccessIndexType {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     /// Sort `self` in-place according to `by`.<br>&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;     /// The sorting algorithm is not stable (can change the relative<br>&gt;&gt;&gt; order of<br>&gt;&gt;&gt;     /// elements that compare equal).<br>&gt;&gt;&gt;     mutating func sortInPlace&lt;R : Comparable&gt;(@noescape by: (Generator.<br>&gt;&gt;&gt; Element) -&gt; R) {<br>&gt;&gt;&gt;         self.sortInPlace { by($0) &lt; by($1) }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/7b042cf4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>sortBy, minElementBy and maxElementBy methods</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 31, 2015 at 12:00:00am</p></header><div class="content"><p>-Dave<br></p><p>&gt; On Dec 31, 2015, at 12:28 AM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt; <br>&gt; With the optimizer as it is today, if this were @_transparent could the extra function invocation(s) be optimized out when you use it in a non-escaping context such as sort()?<br></p><p>Sure.  It doesn’t need to be @_transparent; in general use @inline(__always) instead except in very special cases, (e.g. when you need constant folding to propagate through the function so you can give arithmetic overflow diagnostics at compile-time).<br></p><p><br>&gt; <br>&gt; Jacob<br>&gt; <br>&gt; On Thu, Dec 31, 2015 at 12:26 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; You don’t.  Is that a problem for the intended use-cases?<br>&gt; <br>&gt; -Dave<br>&gt; <br>&gt;&gt; On Dec 31, 2015, at 12:11 AM, Susan Cheng &lt;susan.doggie at gmail.com &lt;mailto:susan.doggie at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; And how do you write a @noescape version with this function?<br>&gt;&gt; <br>&gt;&gt; Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; 於 2015年12月31日星期四 寫道：<br>&gt;&gt; I don’t understand that argument.  Obviously the function would be documented and there would be examples showing how to use it.  Why would it confuse people?<br>&gt;&gt; <br>&gt;&gt; I think you’d need much stronger reasons to justify adding an unbounded set of overloads (is every algorithm that takes a comparison closure going to get one of these?) when we can handle the problem economically with a single function.<br>&gt;&gt; <br>&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 31, 2015, at 12:04 AM, Susan Cheng &lt;susan.doggie at gmail.com &lt;&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It confuses people if provide a global function byComparing in stdlib which&#39;s doing nothing alone.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Dave Abrahams &lt;dabrahams at apple.com &lt;&gt;&gt; 於 2015年12月31日星期四 寫道：<br>&gt;&gt;&gt; Why add all those algorithms when you can write this<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func byComparing&lt;T, U: Comparable&gt;(getComparisonKey: (T)-&gt;U) -&gt; (T, T) -&gt; Bool {<br>&gt;&gt;&gt;   return { getComparisonKey($0) &lt; getComparisonKey($1) }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; peoples.sort(byComparing { $0.name &lt;http://0.name/&gt; })<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 30, 2015, at 10:38 PM, Susan Cheng via swift-evolution &lt;swift-evolution at swift.org &lt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Consider the follows:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct Person {<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;     var name: String<br>&gt;&gt;&gt;&gt;     var age: Int<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let peoples = [Person(name: &quot;Hawk&quot;, age: 24), Person(name: &quot;Andrew&quot;, age: 23)]<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let youngest = peoples.minElement { $0.age &lt; $1.age }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; print(youngest?.name)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; it&#39;s silly that we always have to write the code like { $0.some &lt; $1.some } or { some($0) &lt; some($1) }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; so, we should add those methods to stdlib:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension SequenceType {<br>&gt;&gt;&gt;&gt;     /// Returns the minimum element in `self` or `nil` if the sequence is empty.<br>&gt;&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;&gt;     /// - Complexity: O(`elements.count`).<br>&gt;&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;&gt;     @warn_unused_result<br>&gt;&gt;&gt;&gt;     public func minElement&lt;R : Comparable&gt;(@noescape by: (Generator.Element) throws -&gt; R) rethrows -&gt; Generator.Element? {<br>&gt;&gt;&gt;&gt;         return try self.minElement { try by($0) &lt; by($1) }<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;     /// Returns the maximum element in `self` or `nil` if the sequence is empty.<br>&gt;&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;&gt;     /// - Complexity: O(`elements.count`).<br>&gt;&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;&gt;     @warn_unused_result<br>&gt;&gt;&gt;&gt;     public func maxElement&lt;R : Comparable&gt;(@noescape by: (Generator.Element) throws -&gt; R) rethrows -&gt; Generator.Element? {<br>&gt;&gt;&gt;&gt;         return try self.maxElement { try by($0) &lt; by($1) }<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; public extension MutableCollectionType {<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;     /// Return an `Array` containing the sorted elements of `source`.<br>&gt;&gt;&gt;&gt;     /// according to `by`.<br>&gt;&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;&gt;     /// The sorting algorithm is not stable (can change the relative order of<br>&gt;&gt;&gt;&gt;     /// elements that compare equal).<br>&gt;&gt;&gt;&gt;     @warn_unused_result(mutable_variant=&quot;sortInPlace&quot;)<br>&gt;&gt;&gt;&gt;     func sort&lt;R : Comparable&gt;(@noescape by: (Generator.Element) -&gt; R) -&gt; [Generator.Element] {<br>&gt;&gt;&gt;&gt;         return self.sort { by($0) &lt; by($1) }<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; public extension MutableCollectionType where Self.Index : RandomAccessIndexType {<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;     /// Sort `self` in-place according to `by`.<br>&gt;&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;&gt;     /// The sorting algorithm is not stable (can change the relative order of<br>&gt;&gt;&gt;&gt;     /// elements that compare equal).<br>&gt;&gt;&gt;&gt;     mutating func sortInPlace&lt;R : Comparable&gt;(@noescape by: (Generator.Element) -&gt; R) {<br>&gt;&gt;&gt;&gt;         self.sortInPlace { by($0) &lt; by($1) }<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/dac5a399/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cf2e4441943974c6550424bb9fa45d6b?s=50"></div><header><strong>sortBy, minElementBy and maxElementBy methods</strong> from <string>Susan Cheng</string> &lt;susan.doggie at gmail.com&gt;<p>December 31, 2015 at 04:00:00pm</p></header><div class="content"><p>It&#39;s a choice with overriding methods or provide a global function which&#39;s<br>missing @noescape version and has to write documentation to telling people<br>what&#39;s it doing.<br></p><p>However, sortBy method is common in other languages.<br></p><p>Dave Abrahams &lt;dabrahams at apple.com&gt; 於 2015年12月31日星期四 寫道：<br></p><p>&gt; You don’t.  Is that a problem for the intended use-cases?<br>&gt;<br>&gt; -Dave<br>&gt;<br>&gt; On Dec 31, 2015, at 12:11 AM, Susan Cheng &lt;susan.doggie at gmail.com<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;susan.doggie at gmail.com&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt; And how do you write a @noescape version with this function?<br>&gt;<br>&gt; Dave Abrahams &lt;dabrahams at apple.com<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;dabrahams at apple.com&#39;);&gt;&gt; 於 2015年12月31日星期四<br>&gt; 寫道：<br>&gt;<br>&gt;&gt; I don’t understand that argument.  Obviously the function would be<br>&gt;&gt; documented and there would be examples showing how to use it.  Why would it<br>&gt;&gt; confuse people?<br>&gt;&gt;<br>&gt;&gt; I think you’d need much stronger reasons to justify adding an unbounded<br>&gt;&gt; set of overloads (is every algorithm that takes a comparison closure going<br>&gt;&gt; to get one of these?) when we can handle the problem economically with a<br>&gt;&gt; single function.<br>&gt;&gt;<br>&gt;&gt; -Dave<br>&gt;&gt;<br>&gt;&gt; On Dec 31, 2015, at 12:04 AM, Susan Cheng &lt;susan.doggie at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; It confuses people if provide a global function byComparing in stdlib<br>&gt;&gt; which&#39;s doing nothing alone.<br>&gt;&gt;<br>&gt;&gt; Dave Abrahams &lt;dabrahams at apple.com&gt; 於 2015年12月31日星期四 寫道：<br>&gt;&gt;<br>&gt;&gt;&gt; Why add all those algorithms when you can write this<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func byComparing&lt;T, U: Comparable&gt;(getComparisonKey: (T)-&gt;U) -&gt; (T, T)<br>&gt;&gt;&gt; -&gt; Bool {<br>&gt;&gt;&gt;   return { getComparisonKey($0) &lt; getComparisonKey($1) }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; peoples.sort(byComparing { $0.name })<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Dec 30, 2015, at 10:38 PM, Susan Cheng via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Consider the follows:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; struct Person {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     var name: String<br>&gt;&gt;&gt;     var age: Int<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let peoples = [Person(name: &quot;Hawk&quot;, age: 24), Person(name: &quot;Andrew&quot;,<br>&gt;&gt;&gt; age: 23)]<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let youngest = peoples.minElement { $0.age &lt; $1.age }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; print(youngest?.name)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; it&#39;s silly that we always have to write the code like { $0.some &lt; $1.<br>&gt;&gt;&gt; some } or { some($0) &lt; some($1) }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; so, we should add those methods to stdlib:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; extension SequenceType {<br>&gt;&gt;&gt;     /// Returns the minimum element in `self` or `nil` if the sequence<br>&gt;&gt;&gt; is empty.<br>&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;     /// - Complexity: O(`elements.count`).<br>&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;     @warn_unused_result<br>&gt;&gt;&gt;     public func minElement&lt;R : Comparable&gt;(@noescape by:<br>&gt;&gt;&gt; (Generator.Element) throws -&gt; R) rethrows -&gt; Generator.Element? {<br>&gt;&gt;&gt;         return try self.minElement { try by($0) &lt; by($1) }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     /// Returns the maximum element in `self` or `nil` if the sequence<br>&gt;&gt;&gt; is empty.<br>&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;     /// - Complexity: O(`elements.count`).<br>&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;     @warn_unused_result<br>&gt;&gt;&gt;     public func maxElement&lt;R : Comparable&gt;(@noescape by:<br>&gt;&gt;&gt; (Generator.Element) throws -&gt; R) rethrows -&gt; Generator.Element? {<br>&gt;&gt;&gt;         return try self.maxElement { try by($0) &lt; by($1) }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; public extension MutableCollectionType {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     /// Return an `Array` containing the sorted elements of `source`.<br>&gt;&gt;&gt;     /// according to `by`.<br>&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;     /// The sorting algorithm is not stable (can change the relative<br>&gt;&gt;&gt; order of<br>&gt;&gt;&gt;     /// elements that compare equal).<br>&gt;&gt;&gt;     @warn_unused_result(mutable_variant=&quot;sortInPlace&quot;)<br>&gt;&gt;&gt;     func sort&lt;R : Comparable&gt;(@noescape by: (Generator.Element) -&gt; R)<br>&gt;&gt;&gt; -&gt; [Generator.Element] {<br>&gt;&gt;&gt;         return self.sort { by($0) &lt; by($1) }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; public extension MutableCollectionType where Self.Index :<br>&gt;&gt;&gt; RandomAccessIndexType {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     /// Sort `self` in-place according to `by`.<br>&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;     /// The sorting algorithm is not stable (can change the relative<br>&gt;&gt;&gt; order of<br>&gt;&gt;&gt;     /// elements that compare equal).<br>&gt;&gt;&gt;     mutating func sortInPlace&lt;R : Comparable&gt;(@noescape by: (Generator.<br>&gt;&gt;&gt; Element) -&gt; R) {<br>&gt;&gt;&gt;         self.sortInPlace { by($0) &lt; by($1) }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/f2ba6eb0/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>sortBy, minElementBy and maxElementBy methods</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>December 31, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; func byComparing&lt;T, U: Comparable&gt;(getComparisonKey: (T)-&gt;U) -&gt; (T, T) -&gt; Bool {<br>&gt;   return { getComparisonKey($0) &lt; getComparisonKey($1) }<br>&gt; }<br>I&#39;ve written something similar to bring file URLs into the order of their creation dates.<br>It is a small extension for collection types, and its only downside will disappear as soon as properties are accessible via method calls (afair there is a proposal in the making).<br></p><p>It was quite a lot fiddling with generics, and I don&#39;t have the tiny piece of code on my own computer, but it works in a way that you can do<br>let sorted = array.sortUsingAccessor(ElementType.methodThatReturnsComparable)<br>Beside the problems with properties, I really liked that approach.<br></p><p>Tino<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/e1613803/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>sortBy, minElementBy and maxElementBy methods</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 31, 2015 at 08:00:00am</p></header><div class="content"><p>&gt; On Dec 31, 2015, at 4:14 AM, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; func byComparing&lt;T, U: Comparable&gt;(getComparisonKey: (T)-&gt;U) -&gt; (T, T) -&gt; Bool {<br>&gt;&gt;   return { getComparisonKey($0) &lt; getComparisonKey($1) }<br>&gt;&gt; }<br>&gt; I&#39;ve written something similar to bring file URLs into the order of their creation dates.<br>&gt; It is a small extension for collection types, and its only downside will disappear as soon as properties are accessible via method calls (afair there is a proposal in the making).<br>&gt; <br>&gt; It was quite a lot fiddling with generics, and I don&#39;t have the tiny piece of code on my own computer, but it works in a way that you can do<br>&gt; let sorted = array.sortUsingAccessor(ElementType.methodThatReturnsComparable)<br>&gt; Beside the problems with properties, I really liked that approach.<br></p><p>This seems to be essentially the same design as Susan’s, and has the same problem: it requires a new overload for every algorithm that takes a comparison predicate.<br></p><p>-Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/2f169355/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cf2e4441943974c6550424bb9fa45d6b?s=50"></div><header><strong>sortBy, minElementBy and maxElementBy methods</strong> from <string>Susan Cheng</string> &lt;susan.doggie at gmail.com&gt;<p>January  1, 2016 at 12:00:00am</p></header><div class="content"><p>What&#39;s problem of overloading? We only have four methods to do so.<br></p><p>Dave Abrahams &lt;dabrahams at apple.com&gt; 於 2016年1月1日星期五 寫道：<br></p><p>&gt;<br>&gt; On Dec 31, 2015, at 4:14 AM, Tino Heth &lt;2th at gmx.de<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;2th at gmx.de&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt;<br>&gt; func byComparing&lt;T, U: Comparable&gt;(getComparisonKey: (T)-&gt;U) -&gt; (T, T) -&gt;<br>&gt; Bool {<br>&gt;   return { getComparisonKey($0) &lt; getComparisonKey($1) }<br>&gt; }<br>&gt;<br>&gt; I&#39;ve written something similar to bring file URLs into the order of their<br>&gt; creation dates.<br>&gt; It is a small extension for collection types, and its only downside will<br>&gt; disappear as soon as properties are accessible via method calls (afair<br>&gt; there is a proposal in the making).<br>&gt;<br>&gt; It was quite a lot fiddling with generics, and I don&#39;t have the tiny piece<br>&gt; of code on my own computer, but it works in a way that you can do<br>&gt; let sorted =<br>&gt; array.sortUsingAccessor(ElementType.methodThatReturnsComparable)<br>&gt; Beside the problems with properties, I really liked that approach.<br>&gt;<br>&gt;<br>&gt; This seems to be essentially the same design as Susan’s, and has the same<br>&gt; problem: it requires a new overload for every algorithm that takes a<br>&gt; comparison predicate.<br>&gt;<br>&gt; -Dave<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160101/a5192fe7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>sortBy, minElementBy and maxElementBy methods</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 31, 2015 at 08:00:00am</p></header><div class="content"><p>&gt; On Dec 31, 2015, at 8:44 AM, Susan Cheng &lt;susan.doggie at gmail.com&gt; wrote:<br>&gt; <br>&gt; What&#39;s problem of overloading? We only have four methods to do so.<br></p><p>The set of potential algorithms using comparison predicates is not closed, and they will be implemented not only by the standard library but also by third parties.  One component gets us the functionality for all those algorithms.<br></p><p>&gt; <br>&gt; Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; 於 2016年1月1日星期五 寫道：<br>&gt; <br>&gt;&gt; On Dec 31, 2015, at 4:14 AM, Tino Heth &lt;2th at gmx.de &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;2th at gmx.de&#39;);&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; func byComparing&lt;T, U: Comparable&gt;(getComparisonKey: (T)-&gt;U) -&gt; (T, T) -&gt; Bool {<br>&gt;&gt;&gt;   return { getComparisonKey($0) &lt; getComparisonKey($1) }<br>&gt;&gt;&gt; }<br>&gt;&gt; I&#39;ve written something similar to bring file URLs into the order of their creation dates.<br>&gt;&gt; It is a small extension for collection types, and its only downside will disappear as soon as properties are accessible via method calls (afair there is a proposal in the making).<br>&gt;&gt; <br>&gt;&gt; It was quite a lot fiddling with generics, and I don&#39;t have the tiny piece of code on my own computer, but it works in a way that you can do<br>&gt;&gt; let sorted = array.sortUsingAccessor(ElementType.methodThatReturnsComparable)<br>&gt;&gt; Beside the problems with properties, I really liked that approach.<br>&gt; <br>&gt; This seems to be essentially the same design as Susan’s, and has the same problem: it requires a new overload for every algorithm that takes a comparison predicate.<br>&gt; <br>&gt; -Dave<br>&gt; <br></p><p>-Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/3c048e3b/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>sortBy, minElementBy and maxElementBy methods</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>December 31, 2015 at 08:00:00am</p></header><div class="content"><p>I don’t get the resistance to Dave’s solution? I think it works well and much more applicable. Taking Susan’s original example, it’s not uncommon to want to sort or filter by multiple mechanisms.<br></p><p><br>func byComparing&lt;T, U: Comparable&gt;(getComparisonKey: (T)-&gt;U) -&gt; (T, T) -&gt; Bool {<br>    return { getComparisonKey($0) &lt; getComparisonKey($1) }<br>}<br></p><p>struct Person {<br>    var name: String<br>    var age: Int<br>    var height: Int<br>}<br></p><p>let peoples = [<br>    Person(name: &quot;Hawk&quot;, age: 24, height: 60),<br>    Person(name: &quot;Andrew&quot;, age: 23, height: 66)<br>]<br></p><p>let youngest = peoples.minElement(byComparing { $0.age })<br>let tallest = peoples.maxElement(byComparing { $0.height })<br></p><p>print(&quot;youngest: \(youngest?.name ?? &quot;&lt;none&gt;&quot;)&quot;)<br>print(&quot;tallest: \(tallest?.name ?? &quot;&lt;none&gt;&quot;)&quot;)<br></p><p><br>-David<br></p><p>&gt; On Dec 31, 2015, at 8:19 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 31, 2015, at 4:14 AM, Tino Heth &lt;2th at gmx.de &lt;mailto:2th at gmx.de&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; func byComparing&lt;T, U: Comparable&gt;(getComparisonKey: (T)-&gt;U) -&gt; (T, T) -&gt; Bool {<br>&gt;&gt;&gt;   return { getComparisonKey($0) &lt; getComparisonKey($1) }<br>&gt;&gt;&gt; }<br>&gt;&gt; I&#39;ve written something similar to bring file URLs into the order of their creation dates.<br>&gt;&gt; It is a small extension for collection types, and its only downside will disappear as soon as properties are accessible via method calls (afair there is a proposal in the making).<br>&gt;&gt; <br>&gt;&gt; It was quite a lot fiddling with generics, and I don&#39;t have the tiny piece of code on my own computer, but it works in a way that you can do<br>&gt;&gt; let sorted = array.sortUsingAccessor(ElementType.methodThatReturnsComparable)<br>&gt;&gt; Beside the problems with properties, I really liked that approach.<br>&gt; <br>&gt; This seems to be essentially the same design as Susan’s, and has the same problem: it requires a new overload for every algorithm that takes a comparison predicate.<br>&gt; <br>&gt; -Dave<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/bf40891a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>sortBy, minElementBy and maxElementBy methods</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 31, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; I don’t get the resistance to Dave’s solution? I think it works well and much more applicable.<br></p><p>I have two issues:<br></p><p>1. It&#39;s less discoverable. Someone merely *typing* `sort` into their editor will see `sortBy` right below it in their autocompletion list, and might discover it that way.<br></p><p>2. It forces a naïve implementation, which may not be the best idea. In the Perl world, for instance, we would usually use a Schwartzian transform to implement this, particularly if the key might be expensive to compute:<br></p><p>	array.map { ($0, sortKey($0)) }.sort { $0.1 &lt; $1.1 }.map { $0.0 }<br></p><p>Having said that, I think both of these concerns are relatively  minor.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>sortBy, minElementBy and maxElementBy methods</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>January  4, 2016 at 10:00:00am</p></header><div class="content"><p>As an alternative to minElement and maxElement, this could reduce the<br>number of overloads and provide autocomplete:<br></p><p>extension SequenceType {<br></p><p>    @warn_unused_result<br></p><p>    func reduce&lt;C: Comparable&gt;(<br></p><p>        @noescape combine: (C, C) throws -&gt; Bool,<br></p><p>        @noescape by key: Generator.Element -&gt; C<br></p><p>    ) rethrows -&gt; Generator.Element?<br></p><p>    {<br></p><p>        var generator = self.generate()<br></p><p>        guard let first = generator.next() else {<br></p><p>            return nil<br></p><p>        }<br></p><p>        var best = first, bestKey = key(first)<br></p><p>        while let element = generator.next() {<br></p><p>            let elementKey = key(element)<br></p><p>            if try !combine(bestKey, elementKey) {<br></p><p>                bestKey = elementKey<br></p><p>                best = element<br></p><p>            }<br></p><p>        }<br></p><p>        return best<br></p><p>    }<br></p><p>}<br></p><p><br>print([&quot;a&quot;,&quot;ab&quot;,&quot;abc&quot;].reduce(&lt;, by: { $0.characters.count })) //<br>Optional(&quot;a&quot;)<br></p><p>print([&quot;a&quot;,&quot;ab&quot;,&quot;abc&quot;].reduce(&gt;, by: { $0.characters.count })) //<br>Optional(&quot;abc&quot;)<br></p><p><br>The regular minElement, maxElement methods could have this alternative when<br>you don&#39;t want &quot;by&quot;:<br></p><p>extension SequenceType {<br></p><p>    @warn_unused_result<br></p><p>    func reduce(<br></p><p>        @noescape combine: (Generator.Element, Generator.Element) throws -&gt;<br>Bool<br></p><p>    ) rethrows -&gt; Generator.Element?<br></p><p>    {<br></p><p>        var generator = self.generate()<br></p><p>        guard let first = generator.next() else {<br></p><p>            return nil<br></p><p>        }<br></p><p>        var best = first<br></p><p>        while let element = generator.next() {<br></p><p>            best = try combine(best, element) ? best : element<br></p><p>        }<br></p><p>        return best<br></p><p>    }<br></p><p>}<br></p><p><br>print([0,1,2,3].reduce(&lt;)) // Optional(0)<br></p><p>print([0,1,2,3].reduce(&gt;)) // Optional(3)<br></p><p><br>It may be more efficient to define this on CollectionType where<br>SubSequence.Generator.Element == Generator.Element, using .first and .<br>dropFirst() rather than .generate(), but it&#39;s less flexible and this was<br>enough to illustrate the alternative.<br></p><p><br>On Fri, Jan 1, 2016 at 7:20 AM, Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; I don’t get the resistance to Dave’s solution? I think it works well and<br>&gt; much more applicable.<br>&gt;<br>&gt; I have two issues:<br>&gt;<br>&gt; 1. It&#39;s less discoverable. Someone merely *typing* `sort` into their<br>&gt; editor will see `sortBy` right below it in their autocompletion list, and<br>&gt; might discover it that way.<br>&gt;<br>&gt; 2. It forces a naïve implementation, which may not be the best idea. In<br>&gt; the Perl world, for instance, we would usually use a Schwartzian transform<br>&gt; to implement this, particularly if the key might be expensive to compute:<br>&gt;<br>&gt;         array.map { ($0, sortKey($0)) }.sort { $0.1 &lt; $1.1 }.map { $0.0 }<br>&gt;<br>&gt; Having said that, I think both of these concerns are relatively  minor.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160104/6e7286dc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>sortBy, minElementBy and maxElementBy methods</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January  5, 2016 at 07:00:00am</p></header><div class="content"><p>+1 for the reduce version that Andrew presented, it has wider applicability.<br></p><p><br>&gt; On 4 Jan 2016, at 10:42 AM, Andrew Bennett via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; As an alternative to minElement and maxElement, this could reduce the number of overloads and provide autocomplete:<br>&gt; <br>&gt; extension SequenceType {<br>&gt;     @warn_unused_result<br>&gt;     func reduce&lt;C: Comparable&gt;(<br>&gt;         @noescape combine: (C, C) throws -&gt; Bool,<br>&gt;         @noescape by key: Generator.Element -&gt; C<br>&gt;     ) rethrows -&gt; Generator.Element?<br>&gt;     {<br>&gt;         var generator = self.generate()<br>&gt;         guard let first = generator.next() else {<br>&gt;             return nil<br>&gt;         }<br>&gt;         var best = first, bestKey = key(first)<br>&gt;         while let element = generator.next() {<br>&gt;             let elementKey = key(element)<br>&gt;             if try !combine(bestKey, elementKey) {<br>&gt;                 bestKey = elementKey<br>&gt;                 best = element<br>&gt;             }<br>&gt;         }<br>&gt;         return best<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; print([&quot;a&quot;,&quot;ab&quot;,&quot;abc&quot;].reduce(&lt;, by: { $0.characters.count })) // Optional(&quot;a&quot;)<br>&gt; print([&quot;a&quot;,&quot;ab&quot;,&quot;abc&quot;].reduce(&gt;, by: { $0.characters.count })) // Optional(&quot;abc&quot;)<br>&gt; <br>&gt; The regular minElement, maxElement methods could have this alternative when you don&#39;t want &quot;by&quot;:<br>&gt; <br>&gt; extension SequenceType {<br>&gt;     @warn_unused_result<br>&gt;     func reduce(<br>&gt;         @noescape combine: (Generator.Element, Generator.Element) throws -&gt; Bool<br>&gt;     ) rethrows -&gt; Generator.Element?<br>&gt;     {<br>&gt;         var generator = self.generate()<br>&gt;         guard let first = generator.next() else {<br>&gt;             return nil<br>&gt;         }<br>&gt;         var best = first<br>&gt;         while let element = generator.next() {<br>&gt;             best = try combine(best, element) ? best : element<br>&gt;         }<br>&gt;         return best<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; print([0,1,2,3].reduce(&lt;)) // Optional(0)<br>&gt; print([0,1,2,3].reduce(&gt;)) // Optional(3)<br>&gt; <br>&gt; It may be more efficient to define this on CollectionType where SubSequence.Generator.Element == Generator.Element, using .first and .dropFirst() rather than .generate(), but it&#39;s less flexible and this was enough to illustrate the alternative.<br>&gt; <br>&gt; <br>&gt; On Fri, Jan 1, 2016 at 7:20 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt; I don’t get the resistance to Dave’s solution? I think it works well and much more applicable.<br>&gt; <br>&gt; I have two issues:<br>&gt; <br>&gt; 1. It&#39;s less discoverable. Someone merely *typing* `sort` into their editor will see `sortBy` right below it in their autocompletion list, and might discover it that way.<br>&gt; <br>&gt; 2. It forces a naïve implementation, which may not be the best idea. In the Perl world, for instance, we would usually use a Schwartzian transform to implement this, particularly if the key might be expensive to compute:<br>&gt; <br>&gt;         array.map { ($0, sortKey($0)) }.sort { $0.1 &lt; $1.1 }.map { $0.0 }<br>&gt; <br>&gt; Having said that, I think both of these concerns are relatively  minor.<br>&gt; <br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/8f907e32/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>sortBy, minElementBy and maxElementBy methods</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>January  5, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Dec 31, 2015, at 12:20, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; 2. It forces a naïve implementation, which may not be the best idea. In the Perl world, for instance, we would usually use a Schwartzian transform to implement this, particularly if the key might be expensive to compute:<br>&gt; <br>&gt; 	array.map { ($0, sortKey($0)) }.sort { $0.1 &lt; $1.1 }.map { $0.0 }<br></p><p>+1 and -1 to this. Computing the sort key N times instead of 2*(# of comparisons) can be a big win sometimes. On the other hand, allocating memory for the sort keys might be a net loss, especially if the collection being sorted is large. I guess that means it&#39;s better to be made explicit, but it would be nice™ if it were more convenient than it is now. Brent&#39;s way does a lot of copies; I tried to avoid that but quickly ran into trouble…<br></p><p>var keys = array.map { $0.key }<br>array.sort { ??? }<br></p><p>…because the current &#39;sort&#39; takes a comparator, which just takes values, not indices.<br></p><p>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/7538a4c9/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1696913cf1335685a75e63e11b459ae3?s=50"></div><header><strong>sortBy, minElementBy and maxElementBy methods</strong> from <string>Sune Foldager</string> &lt;cyano at me.com&gt;<p>January  4, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On 31 Dec 2015, at 17:45, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I don’t get the resistance to Dave’s solution? I think it works well and much more applicable. Taking Susan’s original example, it’s not uncommon to want to sort or filter by multiple mechanisms.<br></p><p>Agreed. I’m +1 on Dave’s solution, and in general on primitives that can be composed.<br></p><p>/Sune<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160104/fd4a721a/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
