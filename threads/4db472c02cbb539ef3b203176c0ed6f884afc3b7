<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June 28, 2016 at 01:00:00pm</p></header><div class="content"><p>on Thu Jun 23 2016, Nate Cook &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I like the namespace-based approach to group these protocols together<br>&gt; and I&#39;m very happy to see some clarification happening in this group<br>&gt; of protocols. However, I don&#39;t think the proposed new names<br>&gt; communicate what they need to. The names listed in the &quot;Alternatives<br>&gt; Considered&quot; section do a better job of describing the use and behavior<br>&gt; of these protocols.<br>&gt;<br>&gt; Primarily, the new names read like we&#39;re saying that a conforming type<br>&gt; is a literal, compounding a common existing confusion between literals<br>&gt; and types that can be initialized with a literal. <br></p><p>No, it&#39;s exactly the opposite, as I keep saying.  Conformance to this<br>protocol does *not* mean you can initialize the type with a literal.<br>Proof:<br></p><p>  func f&lt;T: IntegerLiteralConvertible&gt;() -&gt; T {<br>    return T(integerLiteral: 43) // Error<br>    return T(43)                 // Also an Error<br>  }<br></p><p>It means an instance of the type can be *written* as a literal:<br></p><p>  func f&lt;T: IntegerLiteralConvertible&gt;() -&gt; T {<br>    return 43   // OK<br>  }<br></p><p>Everybody&#39;s confused about the meaning of the protocol, and doesn&#39;t like<br>the proposed names because they imply exactly the actual meaning of the<br>protocol, which they misunderstand.<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>June 28, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jun 28, 2016, at 2:57 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; No, it&#39;s exactly the opposite, as I keep saying.  Conformance to this<br>&gt; protocol does *not* mean you can initialize the type with a literal.<br>&gt; Proof:<br>&gt; <br>&gt;  func f&lt;T: IntegerLiteralConvertible&gt;() -&gt; T {<br>&gt;    return T(integerLiteral: 43) // Error<br>&gt;    return T(43)                 // Also an Error<br>&gt;  }<br>&gt; <br>&gt; It means an instance of the type can be *written* as a literal:<br>&gt; <br>&gt;  func f&lt;T: IntegerLiteralConvertible&gt;() -&gt; T {<br>&gt;    return 43   // OK<br>&gt;  }<br>&gt; <br>&gt; Everybody&#39;s confused about the meaning of the protocol, and doesn&#39;t like<br>&gt; the proposed names because they imply exactly the actual meaning of the<br>&gt; protocol, which they misunderstand.<br></p><p><br>Or we&#39;re clueless AND it&#39;s a bad name.<br></p><p>func f&lt;T: IntegerPromotion&gt;() -&gt; T {<br>    return 42 // the answer to everything<br>}<br></p><p>-- E<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June 28, 2016 at 05:00:00pm</p></header><div class="content"><p>on Tue Jun 28 2016, Erica Sadun &lt;erica-AT-ericasadun.com&gt; wrote:<br></p><p>&gt;&gt; On Jun 28, 2016, at 2:57 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; No, it&#39;s exactly the opposite, as I keep saying.  Conformance to this<br>&gt;&gt; protocol does *not* mean you can initialize the type with a literal.<br>&gt;&gt; Proof:<br>&gt;&gt; <br>&gt;<br>&gt;&gt;  func f&lt;T: IntegerLiteralConvertible&gt;() -&gt; T {<br>&gt;&gt;    return T(integerLiteral: 43) // Error<br>&gt;&gt;    return T(43)                 // Also an Error<br>&gt;&gt;  }<br>&gt;&gt; <br>&gt;&gt; It means an instance of the type can be *written* as a literal:<br>&gt;&gt; <br>&gt;&gt;  func f&lt;T: IntegerLiteralConvertible&gt;() -&gt; T {<br>&gt;&gt;    return 43   // OK<br>&gt;&gt;  }<br>&gt;&gt; <br>&gt;&gt; Everybody&#39;s confused about the meaning of the protocol, and doesn&#39;t like<br>&gt;&gt; the proposed names because they imply exactly the actual meaning of the<br>&gt;&gt; protocol, which they misunderstand.<br>&gt;<br>&gt; Or we&#39;re clueless AND it&#39;s a bad name.<br></p><p>It&#39;s possible, but until we have an objective rationale for why it&#39;s bad<br>(arguments that it seems to imply what turns out to be the actual<br>meaning of the protocol don&#39;t count!), *and* a better alternative, it&#39;s<br>sort of moot.  If you don&#39;t like `Syntax.IntegerLiteral` or<br>`Syntax.IntegerLiteralExpressible` then I&#39;m out of suggestions.<br></p><p>&gt; func f&lt;T: IntegerPromotion&gt;() -&gt; T {<br>&gt;     return 42 // the answer to everything<br>&gt; }<br></p><p>Promotion means something very different; something that we actually<br>expect to incorporate into the language one day.<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>June 28, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Jun 28, 2016, at 6:13 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; Or we&#39;re clueless AND it&#39;s a bad name.<br>&gt; <br>&gt; It&#39;s possible, but until we have an objective rationale for why it&#39;s bad<br>&gt; (arguments that it seems to imply what turns out to be the actual<br>&gt; meaning of the protocol don&#39;t count!), *and* a better alternative, it&#39;s<br>&gt; sort of moot.  If you don&#39;t like `Syntax.IntegerLiteral` or<br>&gt; `Syntax.IntegerLiteralExpressible` then I&#39;m out of suggestions.<br>&gt; <br>&gt;&gt; func f&lt;T: IntegerPromotion&gt;() -&gt; T {<br>&gt;&gt;    return 42 // the answer to everything<br>&gt;&gt; }<br>&gt; <br>&gt; Promotion means something very different; something that we actually<br>&gt; expect to incorporate into the language one day.<br></p><p>Next pitch:<br>Syntax.IntegerLiteralInsertion<br>Less successful attempts to brainstorm:<br>Syntax.IntegerLiteralAdvancement<br>Syntax.IntegerLiteralUpgrade<br>Syntax.FreelyIntegerReplaceable<br>Syntax.IntegerParkour<br>Syntax.TodayTheRoleOfTWillBePlayedByIntegerLiteral<br>Syntax.IntegerLiteralTypePoseur<br>Syntax.IntegerLiteral.Zigazigahh<br>Syntax.IntegerLiteralBoosterPack<br>Syntax.IntegerLevelUp<br>Syntax.IntegerElevator<br>Syntax.MarvinTheDepressedIntegerLiteral<br>-- E<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/db66c7e0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 28, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jun 28, 2016, at 8:35 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 28, 2016, at 6:13 PM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; Or we&#39;re clueless AND it&#39;s a bad name.<br>&gt;&gt; <br>&gt;&gt; It&#39;s possible, but until we have an objective rationale for why it&#39;s bad<br>&gt;&gt; (arguments that it seems to imply what turns out to be the actual<br>&gt;&gt; meaning of the protocol don&#39;t count!), *and* a better alternative, it&#39;s<br>&gt;&gt; sort of moot.  If you don&#39;t like `Syntax.IntegerLiteral` or<br>&gt;&gt; `Syntax.IntegerLiteralExpressible` then I&#39;m out of suggestions.<br>&gt;&gt; <br>&gt;&gt;&gt; func f&lt;T: IntegerPromotion&gt;() -&gt; T {<br>&gt;&gt;&gt;    return 42 // the answer to everything<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Promotion means something very different; something that we actually<br>&gt;&gt; expect to incorporate into the language one day.<br>&gt; <br>&gt; Next pitch:<br>&gt; Syntax.IntegerLiteralInsertion<br>&gt; Less successful attempts to brainstorm:<br>&gt; Syntax.IntegerLiteralAdvancement<br>&gt; Syntax.IntegerLiteralUpgrade<br>&gt; Syntax.FreelyIntegerReplaceable<br>&gt; Syntax.IntegerParkour<br>&gt; Syntax.TodayTheRoleOfTWillBePlayedByIntegerLiteral<br>&gt; Syntax.IntegerLiteralTypePoseur<br>&gt; Syntax.IntegerLiteral.Zigazigahh<br>&gt; Syntax.IntegerLiteralBoosterPack<br>&gt; Syntax.IntegerLevelUp<br>&gt; Syntax.IntegerElevator<br>&gt; Syntax.MarvinTheDepressedIntegerLiteral<br>You really have me laughing with some of these!  Thanks Erica. :)<br></p><p><br>&gt; -- E<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/590869ee/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>June 28, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jun 28, 2016, at 7:52 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jun 28, 2016, at 8:35 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 28, 2016, at 6:13 PM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; Or we&#39;re clueless AND it&#39;s a bad name.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It&#39;s possible, but until we have an objective rationale for why it&#39;s bad<br>&gt;&gt;&gt; (arguments that it seems to imply what turns out to be the actual<br>&gt;&gt;&gt; meaning of the protocol don&#39;t count!), *and* a better alternative, it&#39;s<br>&gt;&gt;&gt; sort of moot.  If you don&#39;t like `Syntax.IntegerLiteral` or<br>&gt;&gt;&gt; `Syntax.IntegerLiteralExpressible` then I&#39;m out of suggestions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func f&lt;T: IntegerPromotion&gt;() -&gt; T {<br>&gt;&gt;&gt;&gt;    return 42 // the answer to everything<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Promotion means something very different; something that we actually<br>&gt;&gt;&gt; expect to incorporate into the language one day.<br>&gt;&gt; <br>&gt;&gt; Syntax.MarvinTheDepressedIntegerLiteral<br>&gt; You really have me laughing with some of these!  Thanks Erica. :)<br></p><p>A few more, with a slightly different approach that pushes the literal part towards the end of the name:<br>Syntax.SupportsIntegerLiterals<br>Syntax.AcceptsIntegerLiterals<br>Syntax.IncludesIntegerLiterals<br>Syntax.IncorporatesIntegerLiterals<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/d870da39/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 28, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jun 28, 2016, at 9:05 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jun 28, 2016, at 7:52 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jun 28, 2016, at 8:35 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 28, 2016, at 6:13 PM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; Or we&#39;re clueless AND it&#39;s a bad name.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It&#39;s possible, but until we have an objective rationale for why it&#39;s bad<br>&gt;&gt;&gt;&gt; (arguments that it seems to imply what turns out to be the actual<br>&gt;&gt;&gt;&gt; meaning of the protocol don&#39;t count!), *and* a better alternative, it&#39;s<br>&gt;&gt;&gt;&gt; sort of moot.  If you don&#39;t like `Syntax.IntegerLiteral` or<br>&gt;&gt;&gt;&gt; `Syntax.IntegerLiteralExpressible` then I&#39;m out of suggestions.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func f&lt;T: IntegerPromotion&gt;() -&gt; T {<br>&gt;&gt;&gt;&gt;&gt;    return 42 // the answer to everything<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Promotion means something very different; something that we actually<br>&gt;&gt;&gt;&gt; expect to incorporate into the language one day.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Syntax.MarvinTheDepressedIntegerLiteral<br>&gt;&gt; You really have me laughing with some of these!  Thanks Erica. :)<br>&gt; <br>&gt; A few more, with a slightly different approach that pushes the literal part towards the end of the name:<br>&gt; Syntax.SupportsIntegerLiterals<br>&gt; Syntax.AcceptsIntegerLiterals<br>&gt; Syntax.IncludesIntegerLiterals<br>&gt; Syntax.IncorporatesIntegerLiterals<br></p><p>If you want to pick out your favorites I’ll be happy to update the proposal to include them in the alternatives section.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/52f84f09/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>June 28, 2016 at 09:00:00pm</p></header><div class="content"><p>What about..<br></p><p>Syntax.ConvertibleFromIntegerLiteral<br>etc..<br></p><p>l8r<br>Sean<br></p><p>Sent from my iPad<br></p><p>&gt; On Jun 28, 2016, at 8:52 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Jun 28, 2016, at 8:35 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 28, 2016, at 6:13 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; Or we&#39;re clueless AND it&#39;s a bad name.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It&#39;s possible, but until we have an objective rationale for why it&#39;s bad<br>&gt;&gt;&gt; (arguments that it seems to imply what turns out to be the actual<br>&gt;&gt;&gt; meaning of the protocol don&#39;t count!), *and* a better alternative, it&#39;s<br>&gt;&gt;&gt; sort of moot.  If you don&#39;t like `Syntax.IntegerLiteral` or<br>&gt;&gt;&gt; `Syntax.IntegerLiteralExpressible` then I&#39;m out of suggestions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func f&lt;T: IntegerPromotion&gt;() -&gt; T {<br>&gt;&gt;&gt;&gt;    return 42 // the answer to everything<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Promotion means something very different; something that we actually<br>&gt;&gt;&gt; expect to incorporate into the language one day.<br>&gt;&gt; <br>&gt;&gt; Next pitch:<br>&gt;&gt; Syntax.IntegerLiteralInsertion<br>&gt;&gt; Less successful attempts to brainstorm:<br>&gt;&gt; Syntax.IntegerLiteralAdvancement<br>&gt;&gt; Syntax.IntegerLiteralUpgrade<br>&gt;&gt; Syntax.FreelyIntegerReplaceable<br>&gt;&gt; Syntax.IntegerParkour<br>&gt;&gt; Syntax.TodayTheRoleOfTWillBePlayedByIntegerLiteral<br>&gt;&gt; Syntax.IntegerLiteralTypePoseur<br>&gt;&gt; Syntax.IntegerLiteral.Zigazigahh<br>&gt;&gt; Syntax.IntegerLiteralBoosterPack<br>&gt;&gt; Syntax.IntegerLevelUp<br>&gt;&gt; Syntax.IntegerElevator<br>&gt;&gt; Syntax.MarvinTheDepressedIntegerLiteral<br>&gt; You really have me laughing with some of these!  Thanks Erica. :)<br>&gt; <br>&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/8eab9676/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>June 28, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jun 28, 2016, at 8:08 PM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt; <br>&gt; What about..<br>&gt; <br>&gt; Syntax.ConvertibleFromIntegerLiteral<br>&gt; etc..<br></p><p>I like it but Dave has already expressed that this isn&#39;t conversion. This<br>is something distinct, magical, and more importantly, ineffable.<br></p><p>He says it means an instance of the type can be written as a literal, and<br>not converted from a literal. He writes:<br></p><p>&gt; Conformance to this protocol does *not* mean you can initialize the type with<br>&gt; a literal. <br>&gt; <br>&gt; Proof:<br>&gt; <br>&gt;  func f&lt;T: IntegerLiteralConvertible&gt;() -&gt; T {<br>&gt;    return T(integerLiteral: 43) // Error<br>&gt;    return T(43)                 // Also an Error<br>&gt;  }<br>&gt; <br>&gt; It means an instance of the type can be *written* as a literal:<br>&gt; <br>&gt;  func f&lt;T: IntegerLiteralConvertible&gt;() -&gt; T {<br>&gt;    return 43   // OK<br>&gt;  }<br>&gt;&gt; <br></p><p>So we&#39;re looking at something more like:<br></p><p>Syntax.AnIntegerLiteralCanBeSubstitutedForThisTypeAndTheCompilerWillNotBarf<br></p><p>-- E<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>June 28, 2016 at 10:00:00pm</p></header><div class="content"><p>IntegerLiteralExpressable?<br></p><p>Does Apple employ any philosophers? We might need one...<br></p><p>l8r<br>Sean<br></p><p>Sent from my iPad<br></p><p>&gt; On Jun 28, 2016, at 10:02 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 28, 2016, at 8:08 PM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; What about..<br>&gt;&gt; <br>&gt;&gt; Syntax.ConvertibleFromIntegerLiteral<br>&gt;&gt; etc..<br>&gt; <br>&gt; I like it but Dave has already expressed that this isn&#39;t conversion. This<br>&gt; is something distinct, magical, and more importantly, ineffable.<br>&gt; <br>&gt; He says it means an instance of the type can be written as a literal, and<br>&gt; not converted from a literal. He writes:<br>&gt; <br>&gt;&gt; Conformance to this protocol does *not* mean you can initialize the type with<br>&gt;&gt; a literal. <br>&gt;&gt; <br>&gt;&gt; Proof:<br>&gt;&gt; <br>&gt;&gt; func f&lt;T: IntegerLiteralConvertible&gt;() -&gt; T {<br>&gt;&gt;   return T(integerLiteral: 43) // Error<br>&gt;&gt;   return T(43)                 // Also an Error<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; It means an instance of the type can be *written* as a literal:<br>&gt;&gt; <br>&gt;&gt; func f&lt;T: IntegerLiteralConvertible&gt;() -&gt; T {<br>&gt;&gt;   return 43   // OK<br>&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt; <br>&gt; So we&#39;re looking at something more like:<br>&gt; <br>&gt; Syntax.AnIntegerLiteralCanBeSubstitutedForThisTypeAndTheCompilerWillNotBarf<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>June 28, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jun 28, 2016, at 9:21 PM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt; <br>&gt; IntegerLiteralExpressable?<br>&gt; <br>&gt; Does Apple employ any philosophers? We might need one...<br>&gt; <br>&gt; l8r<br>&gt; Sean<br>&gt; <br></p><p>Aaaaaand...welcome to last night.<br></p><p>The problem being, that people see this and think that the type can be<br>expressed as an integer literal, not that an integer literal can be expressing<br>the type. (I won&#39;t even bring up other associations for that word since<br>most of the subscribers of this mailing list have not been nursing mothers<br>although some may be familiar with the technique.)<br></p><p>-- E<br></p><p><br>&gt; <br>&gt;&gt; On Jun 28, 2016, at 10:02 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 28, 2016, at 8:08 PM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What about..<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Syntax.ConvertibleFromIntegerLiteral<br>&gt;&gt;&gt; etc..<br>&gt;&gt; <br>&gt;&gt; I like it but Dave has already expressed that this isn&#39;t conversion. This<br>&gt;&gt; is something distinct, magical, and more importantly, ineffable.<br>&gt;&gt; <br>&gt;&gt; He says it means an instance of the type can be written as a literal, and<br>&gt;&gt; not converted from a literal. He writes:<br>&gt;&gt; <br>&gt;&gt;&gt; Conformance to this protocol does *not* mean you can initialize the type with<br>&gt;&gt;&gt; a literal. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proof:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func f&lt;T: IntegerLiteralConvertible&gt;() -&gt; T {<br>&gt;&gt;&gt;  return T(integerLiteral: 43) // Error<br>&gt;&gt;&gt;  return T(43)                 // Also an Error<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It means an instance of the type can be *written* as a literal:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func f&lt;T: IntegerLiteralConvertible&gt;() -&gt; T {<br>&gt;&gt;&gt;  return 43   // OK<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; So we&#39;re looking at something more like:<br>&gt;&gt; <br>&gt;&gt; Syntax.AnIntegerLiteralCanBeSubstitutedForThisTypeAndTheCompilerWillNotBarf<br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>June 28, 2016 at 10:00:00pm</p></header><div class="content"><p>Arg. Dang it!<br></p><p>Syntax.ExpressibleAsIntegerLiteral<br>Syntax.FromIntegerLiteral<br>Syntax.IntegerLiteralManifestation<br>Syntax.GhostOfIntegerLiteral<br>Syntax.FormerlyKnownAsIntegerLiteral<br></p><p>l8r<br>Sean <br></p><p>Sent from my iPad<br></p><p>On Jun 28, 2016, at 10:29 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br></p><p>&gt;&gt; On Jun 28, 2016, at 9:21 PM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; IntegerLiteralExpressable?<br>&gt;&gt; <br>&gt;&gt; Does Apple employ any philosophers? We might need one...<br>&gt;&gt; <br>&gt;&gt; l8r<br>&gt;&gt; Sean<br>&gt;&gt; <br>&gt; <br>&gt; Aaaaaand...welcome to last night.<br>&gt; <br>&gt; The problem being, that people see this and think that the type can be<br>&gt; expressed as an integer literal, not that an integer literal can be expressing<br>&gt; the type. (I won&#39;t even bring up other associations for that word since<br>&gt; most of the subscribers of this mailing list have not been nursing mothers<br>&gt; although some may be familiar with the technique.)<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 28, 2016, at 10:02 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 28, 2016, at 8:08 PM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What about..<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Syntax.ConvertibleFromIntegerLiteral<br>&gt;&gt;&gt;&gt; etc..<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I like it but Dave has already expressed that this isn&#39;t conversion. This<br>&gt;&gt;&gt; is something distinct, magical, and more importantly, ineffable.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; He says it means an instance of the type can be written as a literal, and<br>&gt;&gt;&gt; not converted from a literal. He writes:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Conformance to this protocol does *not* mean you can initialize the type with<br>&gt;&gt;&gt;&gt; a literal. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Proof:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func f&lt;T: IntegerLiteralConvertible&gt;() -&gt; T {<br>&gt;&gt;&gt;&gt; return T(integerLiteral: 43) // Error<br>&gt;&gt;&gt;&gt; return T(43)                 // Also an Error<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It means an instance of the type can be *written* as a literal:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func f&lt;T: IntegerLiteralConvertible&gt;() -&gt; T {<br>&gt;&gt;&gt;&gt; return 43   // OK<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So we&#39;re looking at something more like:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Syntax.AnIntegerLiteralCanBeSubstitutedForThisTypeAndTheCompilerWillNotBarf<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- E<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/caa7226ca750e974668243476ffbafd5?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>Greg Titus</string> &lt;greg at omnigroup.com&gt;<p>June 28, 2016 at 08:00:00pm</p></header><div class="content"><p>I’m honestly shocked that y’all (that I’ve seen) haven’t come up with Syntax.LiterallyIntegerLiteral yet.<br></p><p><br></p><p>&gt; On Jun 28, 2016, at 8:39 PM, Sean Heber via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Arg. Dang it!<br>&gt; <br>&gt; Syntax.ExpressibleAsIntegerLiteral<br>&gt; Syntax.FromIntegerLiteral<br>&gt; Syntax.IntegerLiteralManifestation<br>&gt; Syntax.GhostOfIntegerLiteral<br>&gt; Syntax.FormerlyKnownAsIntegerLiteral<br>&gt; <br>&gt; l8r<br>&gt; Sean <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On Jun 28, 2016, at 10:29 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Jun 28, 2016, at 9:21 PM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; IntegerLiteralExpressable?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Does Apple employ any philosophers? We might need one...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; l8r<br>&gt;&gt;&gt; Sean<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Aaaaaand...welcome to last night.<br>&gt;&gt; <br>&gt;&gt; The problem being, that people see this and think that the type can be<br>&gt;&gt; expressed as an integer literal, not that an integer literal can be expressing<br>&gt;&gt; the type. (I won&#39;t even bring up other associations for that word since<br>&gt;&gt; most of the subscribers of this mailing list have not been nursing mothers<br>&gt;&gt; although some may be familiar with the technique.)<br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 28, 2016, at 10:02 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 28, 2016, at 8:08 PM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; What about..<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Syntax.ConvertibleFromIntegerLiteral<br>&gt;&gt;&gt;&gt;&gt; etc..<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I like it but Dave has already expressed that this isn&#39;t conversion. This<br>&gt;&gt;&gt;&gt; is something distinct, magical, and more importantly, ineffable.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; He says it means an instance of the type can be written as a literal, and<br>&gt;&gt;&gt;&gt; not converted from a literal. He writes:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Conformance to this protocol does *not* mean you can initialize the type with<br>&gt;&gt;&gt;&gt;&gt; a literal. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Proof:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func f&lt;T: IntegerLiteralConvertible&gt;() -&gt; T {<br>&gt;&gt;&gt;&gt;&gt; return T(integerLiteral: 43) // Error<br>&gt;&gt;&gt;&gt;&gt; return T(43)                 // Also an Error<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It means an instance of the type can be *written* as a literal:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func f&lt;T: IntegerLiteralConvertible&gt;() -&gt; T {<br>&gt;&gt;&gt;&gt;&gt; return 43   // OK<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So we&#39;re looking at something more like:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Syntax.AnIntegerLiteralCanBeSubstitutedForThisTypeAndTheCompilerWillNotBarf<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- E<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>June 28, 2016 at 10:00:00pm</p></header><div class="content"><p>Now that&#39;s just silly!<br></p><p>l8r<br>Sean<br></p><p>Sent from my iPad<br></p><p>&gt; On Jun 28, 2016, at 10:49 PM, Greg Titus &lt;greg at omnigroup.com&gt; wrote:<br>&gt; <br>&gt; I’m honestly shocked that y’all (that I’ve seen) haven’t come up with Syntax.LiterallyIntegerLiteral yet.<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Jun 28, 2016, at 8:39 PM, Sean Heber via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Arg. Dang it!<br>&gt;&gt; <br>&gt;&gt; Syntax.ExpressibleAsIntegerLiteral<br>&gt;&gt; Syntax.FromIntegerLiteral<br>&gt;&gt; Syntax.IntegerLiteralManifestation<br>&gt;&gt; Syntax.GhostOfIntegerLiteral<br>&gt;&gt; Syntax.FormerlyKnownAsIntegerLiteral<br>&gt;&gt; <br>&gt;&gt; l8r<br>&gt;&gt; Sean <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt; On Jun 28, 2016, at 10:29 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 28, 2016, at 9:21 PM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; IntegerLiteralExpressable?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Does Apple employ any philosophers? We might need one...<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; l8r<br>&gt;&gt;&gt;&gt; Sean<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Aaaaaand...welcome to last night.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The problem being, that people see this and think that the type can be<br>&gt;&gt;&gt; expressed as an integer literal, not that an integer literal can be expressing<br>&gt;&gt;&gt; the type. (I won&#39;t even bring up other associations for that word since<br>&gt;&gt;&gt; most of the subscribers of this mailing list have not been nursing mothers<br>&gt;&gt;&gt; although some may be familiar with the technique.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- E<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 28, 2016, at 10:02 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 28, 2016, at 8:08 PM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; What about..<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Syntax.ConvertibleFromIntegerLiteral<br>&gt;&gt;&gt;&gt;&gt;&gt; etc..<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I like it but Dave has already expressed that this isn&#39;t conversion. This<br>&gt;&gt;&gt;&gt;&gt; is something distinct, magical, and more importantly, ineffable.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; He says it means an instance of the type can be written as a literal, and<br>&gt;&gt;&gt;&gt;&gt; not converted from a literal. He writes:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Conformance to this protocol does *not* mean you can initialize the type with<br>&gt;&gt;&gt;&gt;&gt;&gt; a literal. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Proof:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; func f&lt;T: IntegerLiteralConvertible&gt;() -&gt; T {<br>&gt;&gt;&gt;&gt;&gt;&gt; return T(integerLiteral: 43) // Error<br>&gt;&gt;&gt;&gt;&gt;&gt; return T(43)                 // Also an Error<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It means an instance of the type can be *written* as a literal:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; func f&lt;T: IntegerLiteralConvertible&gt;() -&gt; T {<br>&gt;&gt;&gt;&gt;&gt;&gt; return 43   // OK<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; So we&#39;re looking at something more like:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Syntax.AnIntegerLiteralCanBeSubstitutedForThisTypeAndTheCompilerWillNotBarf<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -- E<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>June 29, 2016 at 08:00:00am</p></header><div class="content"><p>How about:<br></p><p>public enum Syntax {<br>     <br>    public enum Literal {<br></p><p>        public typealias NilProtocol = ...<br>        public typealias BooleanProtocol = ...<br>        public typealias IntegerProtocol = ...<br>        public typealias FloatProtocol = ...<br>        public typealias UnicodeScalarProtocol = ...<br>        public typealias ExtendedGraphemeClusterProtocol = ...<br>        public typealias StringProtocol = ...<br>        public typealias StringInterpolationProtocol = ...<br>        public typealias ArrayProtocol = ...<br>        public typealias DictionaryProtocol = ...<br>    }<br>}<br></p><p>extension Array : Syntax.Literal.ArrayProtocol { ... }<br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/f33b746d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>June 29, 2016 at 08:00:00am</p></header><div class="content"><p>In fact this doesn’t tell you that you can do this:<br></p><p><br>func f&lt;T : Syntax.Literal.IntegerProtocol&gt;() -&gt; T {<br>    return T(integerLiteral: 43) // Error<br>    return T(43) // Also an Error<br>}<br>As I already said, literals will be read and converted to an actual type, but to adopt this, your time needs conformance to a protocol (sounds trivial?). The only direction we have is literal -&gt; type. Should always remember this.<br></p><p>With this in mind, this example is crystal clear:<br></p><p>func f&lt;T : Syntax.Literal.IntegerProtocol&gt;() -&gt; T {<br>    return 43 // OK<br>}<br>I’m only suggesting a clean design here, do what ever you want :P<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 29. Juni 2016 um 08:31:05, Adrian Zubarev (adrian.zubarev at devandartist.com) schrieb:<br></p><p>How about:<br></p><p>public enum Syntax {<br>      <br>    public enum Literal {<br></p><p>        public typealias NilProtocol = ...<br>        public typealias BooleanProtocol = ...<br>        public typealias IntegerProtocol = ...<br>        public typealias FloatProtocol = ...<br>        public typealias UnicodeScalarProtocol = ...<br>        public typealias ExtendedGraphemeClusterProtocol = ...<br>        public typealias StringProtocol = ...<br>        public typealias StringInterpolationProtocol = ...<br>        public typealias ArrayProtocol = ...<br>        public typealias DictionaryProtocol = ...<br>    }<br>}<br></p><p>extension Array : Syntax.Literal.ArrayProtocol { ... }<br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/2633340a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>June 29, 2016 at 08:00:00am</p></header><div class="content"><p>That silly autocorrection sometimes:<br></p><p>As I already said, literals will be read and converted to an actual type, but to adopt this, your type needs conformance to a protocol (sounds trivial?).<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 29. Juni 2016 um 08:44:58, Adrian Zubarev (adrian.zubarev at devandartist.com) schrieb:<br></p><p>As I already said, literals will be read and converted to an actual type, but to adopt this, your time needs conformance to a protocol (sounds trivial?).<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/2af1ea06/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>June 29, 2016 at 04:00:00am</p></header><div class="content"><p>I think +1 on the &quot;nested namespace&quot; idea, unless we&#39;ll (no pun intended) literally never use this for anything else.<br></p><p>- Dave Sweeris<br></p><p>&gt; On Jun 29, 2016, at 01:31, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; How about:<br>&gt; <br>&gt; public enum Syntax {<br>&gt;      <br>&gt;     public enum Literal {<br>&gt; <br>&gt;         public typealias NilProtocol = ...<br>&gt;         public typealias BooleanProtocol = ...<br>&gt;         public typealias IntegerProtocol = ...<br>&gt;         public typealias FloatProtocol = ...<br>&gt;         public typealias UnicodeScalarProtocol = ...<br>&gt;         public typealias ExtendedGraphemeClusterProtocol = ...<br>&gt;         public typealias StringProtocol = ...<br>&gt;         public typealias StringInterpolationProtocol = ...<br>&gt;         public typealias ArrayProtocol = ...<br>&gt;         public typealias DictionaryProtocol = ...<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; extension Array : Syntax.Literal.ArrayProtocol { ... }<br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/af072f6b/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>June 29, 2016 at 08:00:00am</p></header><div class="content"><p>I rather like this one.  It produces: `Syntax.Literal.IntegerProtocol`, which is honestly<br>the best I&#39;ve seen so far *and* it might get past the Dave test.<br></p><p>Thank you for bringing this into the conversation!<br></p><p>-- E<br></p><p>&gt; On Jun 29, 2016, at 12:31 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; How about:<br>&gt; <br>&gt; public enum Syntax {<br>&gt;      <br>&gt;     public enum Literal {<br>&gt; <br>&gt;         public typealias NilProtocol = ...<br>&gt;         public typealias BooleanProtocol = ...<br>&gt;         public typealias IntegerProtocol = ...<br>&gt;         public typealias FloatProtocol = ...<br>&gt;         public typealias UnicodeScalarProtocol = ...<br>&gt;         public typealias ExtendedGraphemeClusterProtocol = ...<br>&gt;         public typealias StringProtocol = ...<br>&gt;         public typealias StringInterpolationProtocol = ...<br>&gt;         public typealias ArrayProtocol = ...<br>&gt;         public typealias DictionaryProtocol = ...<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; extension Array : Syntax.Literal.ArrayProtocol { ... }<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/62459807/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 29, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 9:15 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I rather like this one.  It produces: `Syntax.Literal.IntegerProtocol`, which is honestly<br>&gt; the best I&#39;ve seen so far *and* it might get past the Dave test.<br></p><p>I’m curious to see what Dave thinks of this as well.  <br></p><p>`Syntax.IntegerLiteralType` is another that popped into my mind this morning.  I don’t recall if that has been mentioned yet.  The idea here is that an integer literal *can be typed as* a type that conforms to this protocol (the type suffix *is not* used in the sense that it used to be used in things like `SequenceType` which had the semantic that conforming types *are* sequences).  <br></p><p>-Matthew<br></p><p>&gt; <br>&gt; Thank you for bringing this into the conversation!<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt;&gt; On Jun 29, 2016, at 12:31 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; How about:<br>&gt;&gt; <br>&gt;&gt; public enum Syntax {<br>&gt;&gt;      <br>&gt;&gt;     public enum Literal {<br>&gt;&gt; <br>&gt;&gt;         public typealias NilProtocol = ...<br>&gt;&gt;         public typealias BooleanProtocol = ...<br>&gt;&gt;         public typealias IntegerProtocol = ...<br>&gt;&gt;         public typealias FloatProtocol = ...<br>&gt;&gt;         public typealias UnicodeScalarProtocol = ...<br>&gt;&gt;         public typealias ExtendedGraphemeClusterProtocol = ...<br>&gt;&gt;         public typealias StringProtocol = ...<br>&gt;&gt;         public typealias StringInterpolationProtocol = ...<br>&gt;&gt;         public typealias ArrayProtocol = ...<br>&gt;&gt;         public typealias DictionaryProtocol = ...<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension Array : Syntax.Literal.ArrayProtocol { ... }<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/0eb30596/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>June 29, 2016 at 04:00:00pm</p></header><div class="content"><p>I wouldn’t use the Type suffix, because I believe this will create even more confusion with the associatedtype IntegerLiteralType from the current IntegerLiteralConvertible itself.<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 29. Juni 2016 um 16:42:02, Matthew Johnson (matthew at anandabits.com) schrieb:<br></p><p><br>On Jun 29, 2016, at 9:15 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>I rather like this one.  It produces: `Syntax.Literal.IntegerProtocol`, which is honestly<br>the best I&#39;ve seen so far *and* it might get past the Dave test.<br></p><p>I’m curious to see what Dave thinks of this as well.  <br></p><p>`Syntax.IntegerLiteralType` is another that popped into my mind this morning.  I don’t recall if that has been mentioned yet.  The idea here is that an integer literal *can be typed as* a type that conforms to this protocol (the type suffix *is not* used in the sense that it used to be used in things like `SequenceType` which had the semantic that conforming types *are* sequences).  <br></p><p>-Matthew<br></p><p><br>Thank you for bringing this into the conversation!<br></p><p>-- E<br></p><p>On Jun 29, 2016, at 12:31 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>How about:<br></p><p>public enum Syntax {<br>      <br>    public enum Literal {<br></p><p>        public typealias NilProtocol = ...<br>        public typealias BooleanProtocol = ...<br>        public typealias IntegerProtocol = ...<br>        public typealias FloatProtocol = ...<br>        public typealias UnicodeScalarProtocol = ...<br>        public typealias ExtendedGraphemeClusterProtocol = ...<br>        public typealias StringProtocol = ...<br>        public typealias StringInterpolationProtocol = ...<br>        public typealias ArrayProtocol = ...<br>        public typealias DictionaryProtocol = ...<br>    }<br>}<br></p><p>extension Array : Syntax.Literal.ArrayProtocol { ... }<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/aca5c81f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 29, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 9:46 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I wouldn’t use the Type suffix, because I believe this will create even more confusion with the associatedtype IntegerLiteralType from the current IntegerLiteralConvertible itself.<br>&gt; <br>&gt; <br></p><p>Thanks for pointing this out!  I wasn’t thinking about the associated type names. We definitely would not want the protocol and the associated type to have the same name.  <br></p><p>Of course we *could* open the door to renaming the associated type requirements to something like `IntegerLiteralParameterType` if we decide that `Syntax.*LiteralType` is the best naming convention for the protocols.<br></p><p>I’m not necessarily advocating for this idea, but wanted to share it since there is very active bikeshedding happening right now.  My plan is to stay neutral on the naming and let the community and core team decide what is best.<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; Am 29. Juni 2016 um 16:42:02, Matthew Johnson (matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;) schrieb:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 29, 2016, at 9:15 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I rather like this one.  It produces: `Syntax.Literal.IntegerProtocol`, which is honestly<br>&gt;&gt;&gt; the best I&#39;ve seen so far *and* it might get past the Dave test.<br>&gt;&gt; <br>&gt;&gt; I’m curious to see what Dave thinks of this as well.  <br>&gt;&gt; <br>&gt;&gt; `Syntax.IntegerLiteralType` is another that popped into my mind this morning.  I don’t recall if that has been mentioned yet.  The idea here is that an integer literal *can be typed as* a type that conforms to this protocol (the type suffix *is not* used in the sense that it used to be used in things like `SequenceType` which had the semantic that conforming types *are* sequences).  <br>&gt;&gt; <br>&gt;&gt; -Matthew<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thank you for bringing this into the conversation!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- E<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 29, 2016, at 12:31 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; How about:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; public enum Syntax {<br>&gt;&gt;&gt;&gt;       <br>&gt;&gt;&gt;&gt;     public enum Literal {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;         public typealias NilProtocol = ...<br>&gt;&gt;&gt;&gt;         public typealias BooleanProtocol = ...<br>&gt;&gt;&gt;&gt;         public typealias IntegerProtocol = ...<br>&gt;&gt;&gt;&gt;         public typealias FloatProtocol = ...<br>&gt;&gt;&gt;&gt;         public typealias UnicodeScalarProtocol = ...<br>&gt;&gt;&gt;&gt;         public typealias ExtendedGraphemeClusterProtocol = ...<br>&gt;&gt;&gt;&gt;         public typealias StringProtocol = ...<br>&gt;&gt;&gt;&gt;         public typealias StringInterpolationProtocol = ...<br>&gt;&gt;&gt;&gt;         public typealias ArrayProtocol = ...<br>&gt;&gt;&gt;&gt;         public typealias DictionaryProtocol = ...<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension Array : Syntax.Literal.ArrayProtocol { ... }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/11bb0616/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>June 29, 2016 at 05:00:00pm</p></header><div class="content"><p>Since bikeshedding ideas in here abusing a closed enum anyway I’d like to share my vision of this proposal in a future release with pitched group mechanism (proposal link) and nested protocols in mind:<br></p><p>public group Syntax {<br>     <br>    // No need for `public` because groups inherit  <br>    // the access modifier from its root group<br>    group Literal {<br>         <br>        // no need for `public` here, because all group members  <br>        // will have the access modifier specified by the group<br>        protocol NilProtocol { ... }<br>        protocol BooleanProtocol { ... }<br>        protocol IntegerProtocol { ... }<br>        protocol FloatProtocol { ... }<br>        protocol UnicodeScalarProtocol { ... }<br>        protocol ExtendedGraphemeClusterProtocol { ... }<br>        protocol StringProtocol { ... }<br>        protocol StringInterpolationProtocol { ... }<br>        protocol ArrayProtocol { ... }<br>        protocol DictionaryProtocol { ... }<br>    }<br>}<br>Changing my first example of Syntax.Literal.*Protocol to this design won’t even break. :)<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 29. Juni 2016 um 16:55:10, Matthew Johnson (matthew at anandabits.com) schrieb:<br></p><p><br>On Jun 29, 2016, at 9:46 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>I wouldn’t use the Type suffix, because I believe this will create even more confusion with the associatedtype IntegerLiteralType from the current IntegerLiteralConvertible itself.<br></p><p><br></p><p>Thanks for pointing this out!  I wasn’t thinking about the associated type names. We definitely would not want the protocol and the associated type to have the same name.  <br></p><p>Of course we *could* open the door to renaming the associated type requirements to something like `IntegerLiteralParameterType` if we decide that `Syntax.*LiteralType` is the best naming convention for the protocols.<br></p><p>I’m not necessarily advocating for this idea, but wanted to share it since there is very active bikeshedding happening right now.  My plan is to stay neutral on the naming and let the community and core team decide what is best.<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 29. Juni 2016 um 16:42:02, Matthew Johnson (matthew at anandabits.com) schrieb:<br></p><p><br>On Jun 29, 2016, at 9:15 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>I rather like this one.  It produces: `Syntax.Literal.IntegerProtocol`, which is honestly<br>the best I&#39;ve seen so far *and* it might get past the Dave test.<br></p><p>I’m curious to see what Dave thinks of this as well.  <br></p><p>`Syntax.IntegerLiteralType` is another that popped into my mind this morning.  I don’t recall if that has been mentioned yet.  The idea here is that an integer literal *can be typed as* a type that conforms to this protocol (the type suffix *is not* used in the sense that it used to be used in things like `SequenceType` which had the semantic that conforming types *are* sequences).  <br></p><p>-Matthew<br></p><p><br>Thank you for bringing this into the conversation!<br></p><p>-- E<br></p><p>On Jun 29, 2016, at 12:31 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>How about:<br></p><p>public enum Syntax {<br>       <br>    public enum Literal {<br></p><p>        public typealias NilProtocol = ...<br>        public typealias BooleanProtocol = ...<br>        public typealias IntegerProtocol = ...<br>        public typealias FloatProtocol = ...<br>        public typealias UnicodeScalarProtocol = ...<br>        public typealias ExtendedGraphemeClusterProtocol = ...<br>        public typealias StringProtocol = ...<br>        public typealias StringInterpolationProtocol = ...<br>        public typealias ArrayProtocol = ...<br>        public typealias DictionaryProtocol = ...<br>    }<br>}<br></p><p>extension Array : Syntax.Literal.ArrayProtocol { ... }<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/563af832/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>June 29, 2016 at 05:00:00pm</p></header><div class="content"><p>By the way, what we’ve not have discussed here yet is if we want to use this new protocols like this:<br></p><p>extension SomeType : ArrayProtocol { … }<br>Or<br></p><p>extension SomeType : Syntax.Literal.ArrayProtocol { … }<br>Closed enums will allow us to use ArrayProtocol where groups won’t.<br></p><p>Just wanted to add this to the conversation.<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 29. Juni 2016 um 17:10:10, Adrian Zubarev (adrian.zubarev at devandartist.com) schrieb:<br></p><p>Since bikeshedding ideas in here abusing a closed enum anyway I’d like to share my vision of this proposal in a future release with pitched group mechanism (proposal link) and nested protocols in mind:<br></p><p>public group Syntax {<br>      <br>    // No need for `public` because groups inherit   <br>    // the access modifier from its root group<br>    group Literal {<br>          <br>        // no need for `public` here, because all group members   <br>        // will have the access modifier specified by the group<br>        protocol NilProtocol { ... }<br>        protocol BooleanProtocol { ... }<br>        protocol IntegerProtocol { ... }<br>        protocol FloatProtocol { ... }<br>        protocol UnicodeScalarProtocol { ... }<br>        protocol ExtendedGraphemeClusterProtocol { ... }<br>        protocol StringProtocol { ... }<br>        protocol StringInterpolationProtocol { ... }<br>        protocol ArrayProtocol { ... }<br>        protocol DictionaryProtocol { ... }<br>    }<br>}<br>Changing my first example of Syntax.Literal.*Protocol to this design won’t even break. :)<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 29. Juni 2016 um 16:55:10, Matthew Johnson (matthew at anandabits.com) schrieb:<br></p><p><br>On Jun 29, 2016, at 9:46 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>I wouldn’t use the Type suffix, because I believe this will create even more confusion with the associatedtype IntegerLiteralType from the current IntegerLiteralConvertible itself.<br></p><p><br></p><p>Thanks for pointing this out!  I wasn’t thinking about the associated type names. We definitely would not want the protocol and the associated type to have the same name.  <br></p><p>Of course we *could* open the door to renaming the associated type requirements to something like `IntegerLiteralParameterType` if we decide that `Syntax.*LiteralType` is the best naming convention for the protocols.<br></p><p>I’m not necessarily advocating for this idea, but wanted to share it since there is very active bikeshedding happening right now.  My plan is to stay neutral on the naming and let the community and core team decide what is best.<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 29. Juni 2016 um 16:42:02, Matthew Johnson (matthew at anandabits.com) schrieb:<br></p><p><br>On Jun 29, 2016, at 9:15 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>I rather like this one.  It produces: `Syntax.Literal.IntegerProtocol`, which is honestly<br>the best I&#39;ve seen so far *and* it might get past the Dave test.<br></p><p>I’m curious to see what Dave thinks of this as well.  <br></p><p>`Syntax.IntegerLiteralType` is another that popped into my mind this morning.  I don’t recall if that has been mentioned yet.  The idea here is that an integer literal *can be typed as* a type that conforms to this protocol (the type suffix *is not* used in the sense that it used to be used in things like `SequenceType` which had the semantic that conforming types *are* sequences).  <br></p><p>-Matthew<br></p><p><br>Thank you for bringing this into the conversation!<br></p><p>-- E<br></p><p>On Jun 29, 2016, at 12:31 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>How about:<br></p><p>public enum Syntax {<br>        <br>    public enum Literal {<br></p><p>        public typealias NilProtocol = ...<br>        public typealias BooleanProtocol = ...<br>        public typealias IntegerProtocol = ...<br>        public typealias FloatProtocol = ...<br>        public typealias UnicodeScalarProtocol = ...<br>        public typealias ExtendedGraphemeClusterProtocol = ...<br>        public typealias StringProtocol = ...<br>        public typealias StringInterpolationProtocol = ...<br>        public typealias ArrayProtocol = ...<br>        public typealias DictionaryProtocol = ...<br>    }<br>}<br></p><p>extension Array : Syntax.Literal.ArrayProtocol { ... }<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/026d5299/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>June 29, 2016 at 08:00:00pm</p></header><div class="content"><p>Okay I must correct myself. This wouldn’t work if it was a module, nested types behave differently. I’m sorry for any confusion.<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 29. Juni 2016 um 17:32:46, Adrian Zubarev (adrian.zubarev at devandartist.com) schrieb:<br></p><p>By the way, what we’ve not have discussed here yet is if we want to use this new protocols like this:<br></p><p>extension SomeType : ArrayProtocol { … }<br>Or<br></p><p>extension SomeType : Syntax.Literal.ArrayProtocol { … }<br>Closed enums will allow us to use ArrayProtocol where groups won’t.<br></p><p>Just wanted to add this to the conversation.<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 29. Juni 2016 um 17:10:10, Adrian Zubarev (adrian.zubarev at devandartist.com) schrieb:<br></p><p>Since bikeshedding ideas in here abusing a closed enum anyway I’d like to share my vision of this proposal in a future release with pitched group mechanism (proposal link) and nested protocols in mind:<br></p><p>public group Syntax {<br>       <br>    // No need for `public` because groups inherit    <br>    // the access modifier from its root group<br>    group Literal {<br>           <br>        // no need for `public` here, because all group members    <br>        // will have the access modifier specified by the group<br>        protocol NilProtocol { ... }<br>        protocol BooleanProtocol { ... }<br>        protocol IntegerProtocol { ... }<br>        protocol FloatProtocol { ... }<br>        protocol UnicodeScalarProtocol { ... }<br>        protocol ExtendedGraphemeClusterProtocol { ... }<br>        protocol StringProtocol { ... }<br>        protocol StringInterpolationProtocol { ... }<br>        protocol ArrayProtocol { ... }<br>        protocol DictionaryProtocol { ... }<br>    }<br>}<br>Changing my first example of Syntax.Literal.*Protocol to this design won’t even break. :)<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 29. Juni 2016 um 16:55:10, Matthew Johnson (matthew at anandabits.com) schrieb:<br></p><p><br>On Jun 29, 2016, at 9:46 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>I wouldn’t use the Type suffix, because I believe this will create even more confusion with the associatedtype IntegerLiteralType from the current IntegerLiteralConvertible itself.<br></p><p><br></p><p>Thanks for pointing this out!  I wasn’t thinking about the associated type names. We definitely would not want the protocol and the associated type to have the same name.  <br></p><p>Of course we *could* open the door to renaming the associated type requirements to something like `IntegerLiteralParameterType` if we decide that `Syntax.*LiteralType` is the best naming convention for the protocols.<br></p><p>I’m not necessarily advocating for this idea, but wanted to share it since there is very active bikeshedding happening right now.  My plan is to stay neutral on the naming and let the community and core team decide what is best.<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 29. Juni 2016 um 16:42:02, Matthew Johnson (matthew at anandabits.com) schrieb:<br></p><p><br>On Jun 29, 2016, at 9:15 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>I rather like this one.  It produces: `Syntax.Literal.IntegerProtocol`, which is honestly<br>the best I&#39;ve seen so far *and* it might get past the Dave test.<br></p><p>I’m curious to see what Dave thinks of this as well.  <br></p><p>`Syntax.IntegerLiteralType` is another that popped into my mind this morning.  I don’t recall if that has been mentioned yet.  The idea here is that an integer literal *can be typed as* a type that conforms to this protocol (the type suffix *is not* used in the sense that it used to be used in things like `SequenceType` which had the semantic that conforming types *are* sequences).  <br></p><p>-Matthew<br></p><p><br>Thank you for bringing this into the conversation!<br></p><p>-- E<br></p><p>On Jun 29, 2016, at 12:31 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>How about:<br></p><p>public enum Syntax {<br>         <br>    public enum Literal {<br></p><p>        public typealias NilProtocol = ...<br>        public typealias BooleanProtocol = ...<br>        public typealias IntegerProtocol = ...<br>        public typealias FloatProtocol = ...<br>        public typealias UnicodeScalarProtocol = ...<br>        public typealias ExtendedGraphemeClusterProtocol = ...<br>        public typealias StringProtocol = ...<br>        public typealias StringInterpolationProtocol = ...<br>        public typealias ArrayProtocol = ...<br>        public typealias DictionaryProtocol = ...<br>    }<br>}<br></p><p>extension Array : Syntax.Literal.ArrayProtocol { ... }<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/9a2f9135/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>June 29, 2016 at 06:00:00pm</p></header><div class="content"><p>I’m a bit late throwing my hat into the naming ring, but I was thinking<br></p><p>Swift.Literal.IntegerInitializable, NilInitializable, StringInterpolationInitializable, etc.<br></p><p>-DW<br></p><p>&gt; On Jun 29, 2016, at 9:10 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Since bikeshedding ideas in here abusing a closed enum anyway I’d like to share my vision of this proposal in a future release with pitched group mechanism (proposal link &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160627/022644.html&gt;) and nested protocols in mind:<br>&gt; <br>&gt; public group Syntax {<br>&gt; <br>&gt;     // No need for `public` because groups inherit<br>&gt;     // the access modifier from its root group<br>&gt;     group Literal {<br>&gt; <br>&gt;         // no need for `public` here, because all group members<br>&gt;         // will have the access modifier specified by the group<br>&gt;         protocol NilProtocol { ... }<br>&gt;         protocol BooleanProtocol { ... }<br>&gt;         protocol IntegerProtocol { ... }<br>&gt;         protocol FloatProtocol { ... }<br>&gt;         protocol UnicodeScalarProtocol { ... }<br>&gt;         protocol ExtendedGraphemeClusterProtocol { ... }<br>&gt;         protocol StringProtocol { ... }<br>&gt;         protocol StringInterpolationProtocol { ... }<br>&gt;         protocol ArrayProtocol { ... }<br>&gt;         protocol DictionaryProtocol { ... }<br>&gt;     }<br>&gt; }<br>&gt; Changing my first example of Syntax.Literal.*Protocol to this design won’t even break. :)<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; --<br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; Am 29. Juni 2016 um 16:55:10, Matthew Johnson (matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;) schrieb:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 29, 2016, at 9:46 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I wouldn’t use the Type suffix, because I believe this will create even more confusion with the associatedtype IntegerLiteralType from the current IntegerLiteralConvertible itself.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Thanks for pointing this out!  I wasn’t thinking about the associated type names. We definitely would not want the protocol and the associated type to have the same name.<br>&gt;&gt; <br>&gt;&gt; Of course we *could* open the door to renaming the associated type requirements to something like `IntegerLiteralParameterType` if we decide that `Syntax.*LiteralType` is the best naming convention for the protocols.<br>&gt;&gt; <br>&gt;&gt; I’m not necessarily advocating for this idea, but wanted to share it since there is very active bikeshedding happening right now.  My plan is to stay neutral on the naming and let the community and core team decide what is best.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am 29. Juni 2016 um 16:42:02, Matthew Johnson (matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;) schrieb:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 29, 2016, at 9:15 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I rather like this one.  It produces: `Syntax.Literal.IntegerProtocol`, which is honestly<br>&gt;&gt;&gt;&gt;&gt; the best I&#39;ve seen so far *and* it might get past the Dave test.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m curious to see what Dave thinks of this as well.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; `Syntax.IntegerLiteralType` is another that popped into my mind this morning.  I don’t recall if that has been mentioned yet.  The idea here is that an integer literal *can be typed as* a type that conforms to this protocol (the type suffix *is not* used in the sense that it used to be used in things like `SequenceType` which had the semantic that conforming types *are* sequences).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thank you for bringing this into the conversation!<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -- E<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 29, 2016, at 12:31 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; How about:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; public enum Syntax {<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;     public enum Literal {<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;         public typealias NilProtocol = ...<br>&gt;&gt;&gt;&gt;&gt;&gt;         public typealias BooleanProtocol = ...<br>&gt;&gt;&gt;&gt;&gt;&gt;         public typealias IntegerProtocol = ...<br>&gt;&gt;&gt;&gt;&gt;&gt;         public typealias FloatProtocol = ...<br>&gt;&gt;&gt;&gt;&gt;&gt;         public typealias UnicodeScalarProtocol = ...<br>&gt;&gt;&gt;&gt;&gt;&gt;         public typealias ExtendedGraphemeClusterProtocol = ...<br>&gt;&gt;&gt;&gt;&gt;&gt;         public typealias StringProtocol = ...<br>&gt;&gt;&gt;&gt;&gt;&gt;         public typealias StringInterpolationProtocol = ...<br>&gt;&gt;&gt;&gt;&gt;&gt;         public typealias ArrayProtocol = ...<br>&gt;&gt;&gt;&gt;&gt;&gt;         public typealias DictionaryProtocol = ...<br>&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; extension Array : Syntax.Literal.ArrayProtocol { ... }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/4fd54802/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 496 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/4fd54802/attachment.sig&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 29, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 7:57 PM, David Waite via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I’m a bit late throwing my hat into the naming ring, but I was thinking<br>&gt; <br>&gt; Swift.Literal.IntegerInitializable, NilInitializable, StringInterpolationInitializable, etc.<br></p><p>Dave has explained why the `Initializable` suffix is inaccurate.<br></p><p>&gt; <br>&gt; -DW<br>&gt; <br>&gt;&gt; On Jun 29, 2016, at 9:10 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Since bikeshedding ideas in here abusing a closed enum anyway I’d like to share my vision of this proposal in a future release with pitched group mechanism (proposal link &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160627/022644.html&gt;) and nested protocols in mind:<br>&gt;&gt; <br>&gt;&gt; public group Syntax {<br>&gt;&gt;      <br>&gt;&gt;     // No need for `public` because groups inherit  <br>&gt;&gt;     // the access modifier from its root group<br>&gt;&gt;     group Literal {<br>&gt;&gt;          <br>&gt;&gt;         // no need for `public` here, because all group members  <br>&gt;&gt;         // will have the access modifier specified by the group<br>&gt;&gt;         protocol NilProtocol { ... }<br>&gt;&gt;         protocol BooleanProtocol { ... }<br>&gt;&gt;         protocol IntegerProtocol { ... }<br>&gt;&gt;         protocol FloatProtocol { ... }<br>&gt;&gt;         protocol UnicodeScalarProtocol { ... }<br>&gt;&gt;         protocol ExtendedGraphemeClusterProtocol { ... }<br>&gt;&gt;         protocol StringProtocol { ... }<br>&gt;&gt;         protocol StringInterpolationProtocol { ... }<br>&gt;&gt;         protocol ArrayProtocol { ... }<br>&gt;&gt;         protocol DictionaryProtocol { ... }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; Changing my first example of Syntax.Literal.*Protocol to this design won’t even break. :)<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Adrian Zubarev<br>&gt;&gt; Sent with Airmail<br>&gt;&gt; <br>&gt;&gt; Am 29. Juni 2016 um 16:55:10, Matthew Johnson (matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;) schrieb:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 29, 2016, at 9:46 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I wouldn’t use the Type suffix, because I believe this will create even more confusion with the associatedtype IntegerLiteralType from the current IntegerLiteralConvertible itself.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks for pointing this out!  I wasn’t thinking about the associated type names. We definitely would not want the protocol and the associated type to have the same name.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Of course we *could* open the door to renaming the associated type requirements to something like `IntegerLiteralParameterType` if we decide that `Syntax.*LiteralType` is the best naming convention for the protocols.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m not necessarily advocating for this idea, but wanted to share it since there is very active bikeshedding happening right now.  My plan is to stay neutral on the naming and let the community and core team decide what is best.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 29. Juni 2016 um 16:42:02, Matthew Johnson (matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;) schrieb:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 29, 2016, at 9:15 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I rather like this one.  It produces: `Syntax.Literal.IntegerProtocol`, which is honestly<br>&gt;&gt;&gt;&gt;&gt;&gt; the best I&#39;ve seen so far *and* it might get past the Dave test.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I’m curious to see what Dave thinks of this as well.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; `Syntax.IntegerLiteralType` is another that popped into my mind this morning.  I don’t recall if that has been mentioned yet.  The idea here is that an integer literal *can be typed as* a type that conforms to this protocol (the type suffix *is not* used in the sense that it used to be used in things like `SequenceType` which had the semantic that conforming types *are* sequences).  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Thank you for bringing this into the conversation!<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -- E<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 29, 2016, at 12:31 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; How about:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; public enum Syntax {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;        <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     public enum Literal {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         public typealias NilProtocol = ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         public typealias BooleanProtocol = ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         public typealias IntegerProtocol = ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         public typealias FloatProtocol = ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         public typealias UnicodeScalarProtocol = ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         public typealias ExtendedGraphemeClusterProtocol = ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         public typealias StringProtocol = ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         public typealias StringInterpolationProtocol = ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         public typealias ArrayProtocol = ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         public typealias DictionaryProtocol = ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; extension Array : Syntax.Literal.ArrayProtocol { ... }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/1cf5fcaa/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June 29, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 7:41 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; `Syntax.IntegerLiteralType` is another that popped into my mind this morning.  I don’t recall if that has been mentioned yet.  The idea here is that an integer literal *can be typed as* a type that conforms to this protocol (the type suffix *is not* used in the sense that it used to be used in things like `SequenceType` which had the semantic that conforming types *are* sequences).  <br></p><p>Throwing my hat in:<br></p><p>IntegerLiteralCandidate (with or without a Syntax. prefix)<br></p><p>As in, when you see an integer literal and need to infer its actual type, this type is a candidate.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 29, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 5:04 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Jun 29, 2016, at 7:41 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; `Syntax.IntegerLiteralType` is another that popped into my mind this morning.  I don’t recall if that has been mentioned yet.  The idea here is that an integer literal *can be typed as* a type that conforms to this protocol (the type suffix *is not* used in the sense that it used to be used in things like `SequenceType` which had the semantic that conforming types *are* sequences).  <br>&gt; <br>&gt; Throwing my hat in:<br>&gt; <br>&gt; IntegerLiteralCandidate (with or without a Syntax. prefix)<br>&gt; <br>&gt; As in, when you see an integer literal and need to infer its actual type, this type is a candidate.<br></p><p>Thanks Brent.  <br></p><p>For everyone who is bike shedding here - feel free to continue informally.  However, I don’t plan to incorporate every alternative from the bikeshed into the alternatives section unless folks feel it is critical to do so.  I would prefer that everyone save their personal favorite(s) for the review period and continue the bike shedding at that time.  <br></p><p>The proposal already suggests the core team consider modifying the names based on bike shedding during review.  I hope that will be sufficient.<br></p><p>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>July  1, 2016 at 10:00:00am</p></header><div class="content"><p>We haven’t pass the dave test yet? :D<br></p><p>Still curious what he’d say about Syntax.Literal.*Protocol<br></p><p>One more question:<br></p><p>What can the namespace Syntax could be used for except for literals, any idea? (I have no clue.)<br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 30. Juni 2016 um 03:30:15, Matthew Johnson via swift-evolution (swift-evolution at swift.org) schrieb:<br></p><p><br>&gt; On Jun 29, 2016, at 5:04 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;  <br>&gt;&gt; On Jun 29, 2016, at 7:41 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;  <br>&gt;&gt; `Syntax.IntegerLiteralType` is another that popped into my mind this morning. I don’t recall if that has been mentioned yet. The idea here is that an integer literal *can be typed as* a type that conforms to this protocol (the type suffix *is not* used in the sense that it used to be used in things like `SequenceType` which had the semantic that conforming types *are* sequences).  <br>&gt;  <br>&gt; Throwing my hat in:<br>&gt;  <br>&gt; IntegerLiteralCandidate (with or without a Syntax. prefix)<br>&gt;  <br>&gt; As in, when you see an integer literal and need to infer its actual type, this type is a candidate.<br></p><p>Thanks Brent.  <br></p><p>For everyone who is bike shedding here - feel free to continue informally. However, I don’t plan to incorporate every alternative from the bikeshed into the alternatives section unless folks feel it is critical to do so. I would prefer that everyone save their personal favorite(s) for the review period and continue the bike shedding at that time.  <br></p><p>The proposal already suggests the core team consider modifying the names based on bike shedding during review. I hope that will be sufficient.<br></p><p>&gt;  <br>&gt; --  <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;  <br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160701/c36fc87e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>July  1, 2016 at 08:00:00am</p></header><div class="content"><p>If we go with the “Compiler” alternative, it might make sense to put things like the language/toolchain version, host, target, etc there:<br>if Compiler.language.version &gt;= 3 { celebrate() }<br>if Compiler.target.cpuCount * Compiler.target.coreCount &gt; someValue {/* parallelize something differently than you would have otherwise */}<br></p><p>Or maybe someday we could use it for expanding the language’s syntax:<br>// Not sure if “Compiler.appendSyntax(...)” would be better<br>Syntax.append(/* something which makes sense goes here */)<br></p><p>There was something I was going to reply to yesterday which included a suggestion to add something to the Syntax namespace, but I can’t find it now, so I guess that draft got scrapped or something.<br></p><p>- Dave Sweeris<br></p><p>&gt; On Jul 1, 2016, at 3:08 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; We haven’t pass the dave test yet? :D <br>&gt; <br>&gt; Still curious what he’d say about Syntax.Literal.*Protocol<br>&gt; <br>&gt; One more question:<br>&gt; <br>&gt; What can the namespace Syntax could be used for except for literals, any idea? (I have no clue.)<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; Am 30. Juni 2016 um 03:30:15, Matthew Johnson via swift-evolution (swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;) schrieb:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; &gt; On Jun 29, 2016, at 5:04 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt; &gt; <br>&gt;&gt; &gt;&gt; On Jun 29, 2016, at 7:41 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; `Syntax.IntegerLiteralType` is another that popped into my mind this morning. I don’t recall if that has been mentioned yet. The idea here is that an integer literal *can be typed as* a type that conforms to this protocol (the type suffix *is not* used in the sense that it used to be used in things like `SequenceType` which had the semantic that conforming types *are* sequences).  <br>&gt;&gt; &gt; <br>&gt;&gt; &gt; Throwing my hat in:<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; IntegerLiteralCandidate (with or without a Syntax. prefix)<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; As in, when you see an integer literal and need to infer its actual type, this type is a candidate.<br>&gt;&gt; <br>&gt;&gt; Thanks Brent.  <br>&gt;&gt; <br>&gt;&gt; For everyone who is bike shedding here - feel free to continue informally. However, I don’t plan to incorporate every alternative from the bikeshed into the alternatives section unless folks feel it is critical to do so. I would prefer that everyone save their personal favorite(s) for the review period and continue the bike shedding at that time.  <br>&gt;&gt; <br>&gt;&gt; The proposal already suggests the core team consider modifying the names based on bike shedding during review. I hope that will be sufficient.<br>&gt;&gt; <br>&gt;&gt; &gt; <br>&gt;&gt; &gt; -- <br>&gt;&gt; &gt; Brent Royal-Gordon<br>&gt;&gt; &gt; Architechies<br>&gt;&gt; &gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160701/0c70e299/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>July  1, 2016 at 10:00:00am</p></header><div class="content"><p>The best way to pass the Dave Test is to ask him directly, for example:<br></p><p>Dave:<br></p><p>Do you think the stdlib team would be okay with a naming scheme like <br>Syntax.Literal.ArrayProtocol,  Syntax.Literal.IntegerProtocol, etc. We think <br>this produces a clear description of the conformant role and one that is unlikely to be <br>misinterpreted. It may read less fluently but it&#39;s also less subject to confusing users. <br></p><p>This naming scheme uses the Syntax namespacing, and creates a Literal subspace. <br>Each protocol is named as &quot;XXXXProtocol&quot;. This introduction a distinction between <br>&quot;This is/can be used as  an integer literal&quot; and &quot;Conforming to this protocol ensures<br>that an instance of the type can be written as an integer literal&quot;. <br></p><p>The problem with earlier approximations was that people saw &quot;Syntax.IntegerLiteralXXX&quot; <br>and thought the typed could be substituted into expressions where an integer literal<br>was used, and not that an integer literal could be be used to write an instance of <br>the type.<br></p><p>So what do (and your team) think of this idea?<br></p><p>-- Adrian (and Erica)<br></p><p><br>&gt; On Jul 1, 2016, at 2:08 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; We haven’t pass the dave test yet? :D <br>&gt; <br>&gt; Still curious what he’d say about Syntax.Literal.*Protocol<br>&gt; <br>&gt; One more question:<br>&gt; <br>&gt; What can the namespace Syntax could be used for except for literals, any idea? (I have no clue.)<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160701/7552ee4e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>July  1, 2016 at 04:00:00pm</p></header><div class="content"><p>I would print it out and staple a $20 to the back of it and drop it his way<br>with a wink.<br></p><p>...on a more serious note I like this naming suggestion. +1 from me<br>On Fri, Jul 1, 2016 at 9:00 AM Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; The best way to pass the Dave Test is to ask him directly, for example:<br>&gt;<br>&gt; *Dave:*<br>&gt;<br>&gt; *Do you think the stdlib team would be okay with a naming scheme like *<br>&gt; *Syntax.Literal.ArrayProtocol,  Syntax.Literal.IntegerProtocol, etc. We<br>&gt; think *<br>&gt; *this **produces a clear description of the conformant role and one that<br>&gt; is unlikely to be *<br>&gt; *misinterpreted. It may read less fluently but it&#39;s also less subject to<br>&gt; confusing users. *<br>&gt;<br>&gt; *This naming scheme uses the Syntax namespacing, and creates a Literal<br>&gt; subspace. *<br>&gt; *Each protocol is named as &quot;XXXXProtocol&quot;. This introduction a distinction<br>&gt; between *<br>&gt; *&quot;This is/can be used as  an integer literal&quot; and &quot;Conforming to this<br>&gt; protocol ensures*<br>&gt; *that an instance of the type can be written **as an integer literal&quot;. *<br>&gt;<br>&gt; *The problem with earlier approximations was that people saw<br>&gt; &quot;Syntax.IntegerLiteralXXX&quot; *<br>&gt; *and thought the typed could be substituted into expressions where an<br>&gt; integer literal*<br>&gt; *was used, and not that an integer literal could be be used to write an<br>&gt; instance of *<br>&gt; *the type.*<br>&gt;<br>&gt; *So what do (and your team) think of this idea?*<br>&gt;<br>&gt; *-- Adrian (and Erica)*<br>&gt;<br>&gt;<br>&gt; On Jul 1, 2016, at 2:08 AM, Adrian Zubarev via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; We haven’t pass the dave test yet? :D<br>&gt;<br>&gt; Still curious what he’d say about Syntax.Literal.*Protocol<br>&gt;<br>&gt; One more question:<br>&gt;<br>&gt;    - What can the namespace Syntax could be used for except for literals,<br>&gt;    any idea? (I have no clue.)<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160701/292e35bc/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July  1, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jul 1, 2016, at 11:00 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; The best way to pass the Dave Test is to ask him directly, for example:<br>&gt; <br>&gt; Dave:<br>&gt; <br>&gt; Do you think the stdlib team would be okay with a naming scheme like <br>&gt; Syntax.Literal.ArrayProtocol,  Syntax.Literal.IntegerProtocol, etc. We think <br>&gt; this produces a clear description of the conformant role and one that is unlikely to be <br>&gt; misinterpreted. It may read less fluently but it&#39;s also less subject to confusing users. <br>&gt; <br>&gt; This naming scheme uses the Syntax namespacing, and creates a Literal subspace. <br>&gt; Each protocol is named as &quot;XXXXProtocol&quot;. This introduction a distinction between <br>&gt; &quot;This is/can be used as  an integer literal&quot; and &quot;Conforming to this protocol ensures<br>&gt; that an instance of the type can be written as an integer literal&quot;. <br>&gt; <br>&gt; The problem with earlier approximations was that people saw &quot;Syntax.IntegerLiteralXXX&quot; <br>&gt; and thought the typed could be substituted into expressions where an integer literal<br>&gt; was used, and not that an integer literal could be be used to write an instance of <br>&gt; the type.<br>&gt; <br>&gt; So what do (and your team) think of this idea?<br>&gt; <br>&gt; -- Adrian (and Erica)<br></p><p>This one has been added to the alternatives section of the proposal.  I expect the bike shedding to continue during review and expect the core team to exercise judgement in selecting the final naming scheme.<br></p><p><br>&gt; <br>&gt; <br>&gt;&gt; On Jul 1, 2016, at 2:08 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; We haven’t pass the dave test yet? :D <br>&gt;&gt; <br>&gt;&gt; Still curious what he’d say about Syntax.Literal.*Protocol<br>&gt;&gt; <br>&gt;&gt; One more question:<br>&gt;&gt; <br>&gt;&gt; What can the namespace Syntax could be used for except for literals, any idea? (I have no clue.)<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160701/c7a2c1e3/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July  1, 2016 at 01:00:00pm</p></header><div class="content"><p>on Fri Jul 01 2016, Erica Sadun &lt;erica-AT-ericasadun.com&gt; wrote:<br></p><p>&gt; The best way to pass the Dave Test is to ask him directly, for example:<br>&gt;<br>&gt; Dave:<br>&gt;<br>&gt; Do you think the stdlib team would be okay with a naming scheme like <br>&gt; Syntax.Literal.ArrayProtocol,  Syntax.Literal.IntegerProtocol, etc. We think <br>&gt; this produces a clear description of the conformant role and one that is unlikely to be <br>&gt; misinterpreted. It may read less fluently but it&#39;s also less subject<br>&gt; to confusing users. <br></p><p>No.  IMO Putting “Protocol” in the name just adds redundant type<br>information that doesn&#39;t help readability.<br></p><p>&gt; This naming scheme uses the Syntax namespacing, and creates a Literal<br>&gt; subspace.  Each protocol is named as &quot;XXXXProtocol&quot;. This introduction<br>&gt; a distinction between &quot;This is/can be used as an integer literal&quot; and<br>&gt; &quot;Conforming to this protocol ensures that an instance of the type can<br>&gt; be written as an integer literal&quot;.<br>&gt;<br>&gt; The problem with earlier approximations was that people saw<br>&gt; &quot;Syntax.IntegerLiteralXXX&quot; and thought the typed could be substituted<br>&gt; into expressions where an integer literal was used, and not that an<br>&gt; integer literal could be be used to write an instance of the type.<br>&gt;<br>&gt; So what do (and your team) think of this idea?<br></p><p>I think if `Syntax.IntegerLiteral` is actually unclear then the best<br>cure is `ExpressibleAsIntegerLiteral` (no namespace needed).  None of<br>the other suggestions I&#39;ve seen describe what the protocol means as well<br>as that.  I&#39;ve asked Matthew to update the proposal accordingly.<br></p><p>&gt;<br>&gt; -- Adrian (and Erica)<br>&gt;<br>&gt;&gt; On Jul 1, 2016, at 2:08 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; We haven’t pass the dave test yet? :D <br>&gt;&gt; <br>&gt;&gt; Still curious what he’d say about Syntax.Literal.*Protocol<br>&gt;&gt; <br>&gt;&gt; One more question:<br>&gt;&gt; <br>&gt;&gt; What can the namespace Syntax could be used for except for literals, any idea? (I have no clue.)<br>&gt;<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July  1, 2016 at 08:00:00pm</p></header><div class="content"><p>I thought your suggestion of IntegerLiteralExpressible (with or without<br>Syntax) was nice too.<br>On Fri, Jul 1, 2016 at 15:35 Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; on Fri Jul 01 2016, Erica Sadun &lt;erica-AT-ericasadun.com&gt; wrote:<br>&gt;<br>&gt; &gt; The best way to pass the Dave Test is to ask him directly, for example:<br>&gt; &gt;<br>&gt; &gt; Dave:<br>&gt; &gt;<br>&gt; &gt; Do you think the stdlib team would be okay with a naming scheme like<br>&gt; &gt; Syntax.Literal.ArrayProtocol,  Syntax.Literal.IntegerProtocol, etc. We<br>&gt; think<br>&gt; &gt; this produces a clear description of the conformant role and one that is<br>&gt; unlikely to be<br>&gt; &gt; misinterpreted. It may read less fluently but it&#39;s also less subject<br>&gt; &gt; to confusing users.<br>&gt;<br>&gt; No.  IMO Putting “Protocol” in the name just adds redundant type<br>&gt; information that doesn&#39;t help readability.<br>&gt;<br>&gt; &gt; This naming scheme uses the Syntax namespacing, and creates a Literal<br>&gt; &gt; subspace.  Each protocol is named as &quot;XXXXProtocol&quot;. This introduction<br>&gt; &gt; a distinction between &quot;This is/can be used as an integer literal&quot; and<br>&gt; &gt; &quot;Conforming to this protocol ensures that an instance of the type can<br>&gt; &gt; be written as an integer literal&quot;.<br>&gt; &gt;<br>&gt; &gt; The problem with earlier approximations was that people saw<br>&gt; &gt; &quot;Syntax.IntegerLiteralXXX&quot; and thought the typed could be substituted<br>&gt; &gt; into expressions where an integer literal was used, and not that an<br>&gt; &gt; integer literal could be be used to write an instance of the type.<br>&gt; &gt;<br>&gt; &gt; So what do (and your team) think of this idea?<br>&gt;<br>&gt; I think if `Syntax.IntegerLiteral` is actually unclear then the best<br>&gt; cure is `ExpressibleAsIntegerLiteral` (no namespace needed).  None of<br>&gt; the other suggestions I&#39;ve seen describe what the protocol means as well<br>&gt; as that.  I&#39;ve asked Matthew to update the proposal accordingly.<br>&gt;<br>&gt; &gt;<br>&gt; &gt; -- Adrian (and Erica)<br>&gt; &gt;<br>&gt; &gt;&gt; On Jul 1, 2016, at 2:08 AM, Adrian Zubarev via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; We haven’t pass the dave test yet? :D<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Still curious what he’d say about Syntax.Literal.*Protocol<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; One more question:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; What can the namespace Syntax could be used for except for literals,<br>&gt; any idea? (I have no clue.)<br>&gt; &gt;<br>&gt;<br>&gt; --<br>&gt; Dave<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160701/22eaab69/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>July  1, 2016 at 11:00:00pm</p></header><div class="content"><p>On 01.07.2016 23:39, Xiaodi Wu via swift-evolution wrote:<br>&gt; I thought your suggestion of IntegerLiteralExpressible (with or without<br>&gt; Syntax) was nice too.<br></p><p>Support. I still believe that Syntax.IntegerLiteralExpressible is the best.<br>We see &#39;Syntax&#39; first, then &#39;Integer&#39; just after point, &#39;Expressible&#39; at <br>the end. Easily parsed and IMO clear about the meaning.<br>Probably this also good but not sure: Syntax.LiteralExpressible.Integer<br></p><p>&gt; On Fri, Jul 1, 2016 at 15:35 Dave Abrahams via swift-evolution<br>&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;<br>&gt;<br>&gt;     on Fri Jul 01 2016, Erica Sadun &lt;erica-AT-ericasadun.com&gt; wrote:<br>&gt;<br>&gt;     &gt; The best way to pass the Dave Test is to ask him directly, for example:<br>&gt;     &gt;<br>&gt;     &gt; Dave:<br>&gt;     &gt;<br>&gt;     &gt; Do you think the stdlib team would be okay with a naming scheme like<br>&gt;     &gt; Syntax.Literal.ArrayProtocol,  Syntax.Literal.IntegerProtocol, etc.<br>&gt;     We think<br>&gt;     &gt; this produces a clear description of the conformant role and one that<br>&gt;     is unlikely to be<br>&gt;     &gt; misinterpreted. It may read less fluently but it&#39;s also less subject<br>&gt;     &gt; to confusing users.<br>&gt;<br>&gt;     No.  IMO Putting “Protocol” in the name just adds redundant type<br>&gt;     information that doesn&#39;t help readability.<br>&gt;<br>&gt;     &gt; This naming scheme uses the Syntax namespacing, and creates a Literal<br>&gt;     &gt; subspace.  Each protocol is named as &quot;XXXXProtocol&quot;. This introduction<br>&gt;     &gt; a distinction between &quot;This is/can be used as an integer literal&quot; and<br>&gt;     &gt; &quot;Conforming to this protocol ensures that an instance of the type can<br>&gt;     &gt; be written as an integer literal&quot;.<br>&gt;     &gt;<br>&gt;     &gt; The problem with earlier approximations was that people saw<br>&gt;     &gt; &quot;Syntax.IntegerLiteralXXX&quot; and thought the typed could be substituted<br>&gt;     &gt; into expressions where an integer literal was used, and not that an<br>&gt;     &gt; integer literal could be be used to write an instance of the type.<br>&gt;     &gt;<br>&gt;     &gt; So what do (and your team) think of this idea?<br>&gt;<br>&gt;     I think if `Syntax.IntegerLiteral` is actually unclear then the best<br>&gt;     cure is `ExpressibleAsIntegerLiteral` (no namespace needed).  None of<br>&gt;     the other suggestions I&#39;ve seen describe what the protocol means as well<br>&gt;     as that.  I&#39;ve asked Matthew to update the proposal accordingly.<br>&gt;<br>&gt;     &gt;<br>&gt;     &gt; -- Adrian (and Erica)<br>&gt;     &gt;<br>&gt;     &gt;&gt; On Jul 1, 2016, at 2:08 AM, Adrian Zubarev via swift-evolution<br>&gt;     &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;     &gt;&gt;<br>&gt;     &gt;&gt; We haven’t pass the dave test yet? :D<br>&gt;     &gt;&gt;<br>&gt;     &gt;&gt; Still curious what he’d say about Syntax.Literal.*Protocol<br>&gt;     &gt;&gt;<br>&gt;     &gt;&gt; One more question:<br>&gt;     &gt;&gt;<br>&gt;     &gt;&gt; What can the namespace Syntax could be used for except for literals,<br>&gt;     any idea? (I have no clue.)<br>&gt;     &gt;<br>&gt;<br>&gt;     --<br>&gt;     Dave<br>&gt;     _______________________________________________<br>&gt;     swift-evolution mailing list<br>&gt;     swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>July  1, 2016 at 01:00:00pm</p></header><div class="content"><p>On Fri, Jul 1, 2016 at 1:35 PM, Dave Abrahams via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; I think if `Syntax.IntegerLiteral` is actually unclear then the best<br>&gt; cure is `ExpressibleAsIntegerLiteral` (no namespace needed).  None of<br>&gt; the other suggestions I&#39;ve seen describe what the protocol means as well<br>&gt; as that.  I&#39;ve asked Matthew to update the proposal accordingly.<br></p><p>I also like `ExpressibleAsIntegerLiteral`.  It uses the ~ible/~able<br>convention which suggests a capability, and when the name is worded<br>like this, it is definitely describing a capability of the type.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July  1, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jul 1, 2016, at 3:59 PM, Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Fri, Jul 1, 2016 at 1:35 PM, Dave Abrahams via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; I think if `Syntax.IntegerLiteral` is actually unclear then the best<br>&gt;&gt; cure is `ExpressibleAsIntegerLiteral` (no namespace needed).  None of<br>&gt;&gt; the other suggestions I&#39;ve seen describe what the protocol means as well<br>&gt;&gt; as that.  I&#39;ve asked Matthew to update the proposal accordingly.<br>&gt; <br>&gt; I also like `ExpressibleAsIntegerLiteral`.  It uses the ~ible/~able<br>&gt; convention which suggests a capability, and when the name is worded<br>&gt; like this, it is definitely describing a capability of the type.<br></p><p>I like it quite a bit as well.  It’s the best name anyone has suggested.  <br></p><p>I have updated the proposal to reflect this decision.  Any further comments should be in the context of this new draft.<br></p><p>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>July  1, 2016 at 11:00:00pm</p></header><div class="content"><p>The only problem I can see with ExpressibleAs is that it also reads if I could potentially do something like this type &lt;-&gt; literal, but the direction type -&gt; literal is impossible.<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 1. Juli 2016 um 23:33:19, Matthew Johnson via swift-evolution (swift-evolution at swift.org) schrieb:<br></p><p><br>&gt; On Jul 1, 2016, at 3:59 PM, Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;  <br>&gt; On Fri, Jul 1, 2016 at 1:35 PM, Dave Abrahams via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; I think if `Syntax.IntegerLiteral` is actually unclear then the best<br>&gt;&gt; cure is `ExpressibleAsIntegerLiteral` (no namespace needed). None of<br>&gt;&gt; the other suggestions I&#39;ve seen describe what the protocol means as well<br>&gt;&gt; as that. I&#39;ve asked Matthew to update the proposal accordingly.<br>&gt;  <br>&gt; I also like `ExpressibleAsIntegerLiteral`. It uses the ~ible/~able<br>&gt; convention which suggests a capability, and when the name is worded<br>&gt; like this, it is definitely describing a capability of the type.<br></p><p>I like it quite a bit as well. It’s the best name anyone has suggested.  <br></p><p>I have updated the proposal to reflect this decision. Any further comments should be in the context of this new draft.<br></p><p>&gt;  <br>&gt; Dmitri<br>&gt;  <br>&gt; --  <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160701/2b005d2b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>July  1, 2016 at 04:00:00pm</p></header><div class="content"><p>Yeah, I’ve been wondering if there’d ever be a way to convert something into a *Literal… I can’t think of why, other than as a way to cast between types which are both “ExpressibleAs*Literal&quot;, but then the protocol would have to be strengthened to indicate that the conversion had to be lossless.<br></p><p>- Dave Sweeris<br></p><p>&gt; On Jul 1, 2016, at 4:39 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The only problem I can see with ExpressibleAs is that it also reads if I could potentially do something like this type &lt;-&gt; literal, but the direction type -&gt; literal is impossible.<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; Am 1. Juli 2016 um 23:33:19, Matthew Johnson via swift-evolution (swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;) schrieb:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; &gt; On Jul 1, 2016, at 3:59 PM, Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; On Fri, Jul 1, 2016 at 1:35 PM, Dave Abrahams via swift-evolution<br>&gt;&gt; &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt; I think if `Syntax.IntegerLiteral` is actually unclear then the best<br>&gt;&gt; &gt;&gt; cure is `ExpressibleAsIntegerLiteral` (no namespace needed). None of<br>&gt;&gt; &gt;&gt; the other suggestions I&#39;ve seen describe what the protocol means as well<br>&gt;&gt; &gt;&gt; as that. I&#39;ve asked Matthew to update the proposal accordingly.<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; I also like `ExpressibleAsIntegerLiteral`. It uses the ~ible/~able<br>&gt;&gt; &gt; convention which suggests a capability, and when the name is worded<br>&gt;&gt; &gt; like this, it is definitely describing a capability of the type.<br>&gt;&gt; <br>&gt;&gt; I like it quite a bit as well. It’s the best name anyone has suggested.  <br>&gt;&gt; <br>&gt;&gt; I have updated the proposal to reflect this decision. Any further comments should be in the context of this new draft.<br>&gt;&gt; <br>&gt;&gt; &gt; <br>&gt;&gt; &gt; Dmitri<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; -- <br>&gt;&gt; &gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt;&gt; &gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160701/6cb3160a/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>June 29, 2016 at 02:00:00pm</p></header><div class="content"><p>I read such names as &quot;Syntax.BlaBlaBlaBlaBlaBlaLiteral&quot;, then need to parse <br>&quot;Literal&quot; at the end, then need to parse actual literal <br>type(Integer,Nil,etc). Not clear from first view on such the name.<br></p><p>FWIW as non-English speaker, I prefer clear and short name like <br>&quot;Syntax.IntegerLiteral&quot; or even really like &quot;Syntax.Literal.Integer&quot; - IMO <br>it is so clear, first you find &quot;Syntax&quot;, you understand that it is related <br>to source code syntax features, then &quot;Literal&quot; - aha, this type could be <br>expressed as literal, then &quot;Integer&quot; - got it, could be written as integer <br>value. Or probably &quot;Syntax.LiteralExpressible.Integer&quot;.<br></p><p>On 29.06.2016 6:39, Sean Heber via swift-evolution wrote:<br>&gt; Arg. Dang it!<br>&gt;<br>&gt; Syntax.ExpressibleAsIntegerLiteral<br>&gt; Syntax.FromIntegerLiteral<br>&gt; Syntax.IntegerLiteralManifestation<br>&gt; Syntax.GhostOfIntegerLiteral<br>&gt; Syntax.FormerlyKnownAsIntegerLiteral<br>&gt;<br>&gt; l8r<br>&gt; Sean<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; On Jun 28, 2016, at 10:29 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;<br>&gt;&gt;&gt; On Jun 28, 2016, at 9:21 PM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; IntegerLiteralExpressable?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Does Apple employ any philosophers? We might need one...<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; l8r<br>&gt;&gt;&gt; Sean<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Aaaaaand...welcome to last night.<br>&gt;&gt;<br>&gt;&gt; The problem being, that people see this and think that the type can be<br>&gt;&gt; expressed as an integer literal, not that an integer literal can be expressing<br>&gt;&gt; the type. (I won&#39;t even bring up other associations for that word since<br>&gt;&gt; most of the subscribers of this mailing list have not been nursing mothers<br>&gt;&gt; although some may be familiar with the technique.)<br>&gt;&gt;<br>&gt;&gt; -- E<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Jun 28, 2016, at 10:02 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Jun 28, 2016, at 8:08 PM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; What about..<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Syntax.ConvertibleFromIntegerLiteral<br>&gt;&gt;&gt;&gt;&gt; etc..<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I like it but Dave has already expressed that this isn&#39;t conversion. This<br>&gt;&gt;&gt;&gt; is something distinct, magical, and more importantly, ineffable.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; He says it means an instance of the type can be written as a literal, and<br>&gt;&gt;&gt;&gt; not converted from a literal. He writes:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Conformance to this protocol does *not* mean you can initialize the type with<br>&gt;&gt;&gt;&gt;&gt; a literal.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Proof:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; func f&lt;T: IntegerLiteralConvertible&gt;() -&gt; T {<br>&gt;&gt;&gt;&gt;&gt; return T(integerLiteral: 43) // Error<br>&gt;&gt;&gt;&gt;&gt; return T(43)                 // Also an Error<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; It means an instance of the type can be *written* as a literal:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; func f&lt;T: IntegerLiteralConvertible&gt;() -&gt; T {<br>&gt;&gt;&gt;&gt;&gt; return 43   // OK<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; So we&#39;re looking at something more like:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Syntax.AnIntegerLiteralCanBeSubstitutedForThisTypeAndTheCompilerWillNotBarf<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; -- E<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>June 29, 2016 at 08:00:00am</p></header><div class="content"><p>Semi-serious question for integer literals in particular: do we need a separate protocol at all?  Are there types we want to support where integer literals should be supported, but + doesn&#39;t make sense?  Where 1+1 actually isn&#39;t 2?<br></p><p>If not, are integer literals really just part of Arithmetic?<br></p><p>- Steve<br></p><p>&gt; On Jun 28, 2016, at 11:21 PM, Sean Heber via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; IntegerLiteralExpressable?<br>&gt; <br>&gt; Does Apple employ any philosophers? We might need one...<br>&gt; <br>&gt; l8r<br>&gt; Sean<br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt;&gt; On Jun 28, 2016, at 10:02 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 28, 2016, at 8:08 PM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What about..<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Syntax.ConvertibleFromIntegerLiteral<br>&gt;&gt;&gt; etc..<br>&gt;&gt; <br>&gt;&gt; I like it but Dave has already expressed that this isn&#39;t conversion. This<br>&gt;&gt; is something distinct, magical, and more importantly, ineffable.<br>&gt;&gt; <br>&gt;&gt; He says it means an instance of the type can be written as a literal, and<br>&gt;&gt; not converted from a literal. He writes:<br>&gt;&gt; <br>&gt;&gt;&gt; Conformance to this protocol does *not* mean you can initialize the type with<br>&gt;&gt;&gt; a literal. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proof:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func f&lt;T: IntegerLiteralConvertible&gt;() -&gt; T {<br>&gt;&gt;&gt;  return T(integerLiteral: 43) // Error<br>&gt;&gt;&gt;  return T(43)                 // Also an Error<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It means an instance of the type can be *written* as a literal:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func f&lt;T: IntegerLiteralConvertible&gt;() -&gt; T {<br>&gt;&gt;&gt;  return 43   // OK<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; So we&#39;re looking at something more like:<br>&gt;&gt; <br>&gt;&gt; Syntax.AnIntegerLiteralCanBeSubstitutedForThisTypeAndTheCompilerWillNotBarf<br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>June 29, 2016 at 08:00:00am</p></header><div class="content"><p>Types where it makes sense, or types for which such semantics would be a good idea? Because, for example, you could do something like this:<br>struct HTMLParser : IntegerLiteralConvertible {<br>    init(integerLiteral value: IntegerLiteralType) {<br>        htmlMajorVersion = value<br>        htmlMinorVersion = 0<br>    }<br>}<br></p><p>Back in the realm of math, I don’t think Sedenions — a 16-demensional (in the sense that complex numbers are 2-dimensional) number  — have a well-defined division operator.<br></p><p>As a more likely example, I don’t think it’d be too much of a stretch to attach integer literal semantics to matrices:<br>let x: Matrix = 1 // Sets diagonal to 1<br>Matrices don’t have a division operator, and you can’t do any of the `Arithmetic` functions to two matrices without first checking their dimensions. Plus, inherently-dimensioned matrix types:<br>var x = Matrix&lt;_2,_3&gt;() // &quot;_2&quot; and &quot;_3&quot; are dummy types<br>can’t implement `*`, unless their two dimensions happen to be equal — &quot;Matrix&lt;2,3&gt;() * Matrix&lt;2,3&gt;()” doesn’t have a valid definition.<br></p><p>- Dave Sweeris<br></p><p>&gt; On Jun 29, 2016, at 7:49 AM, Steve Canon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Semi-serious question for integer literals in particular: do we need a separate protocol at all?  Are there types we want to support where integer literals should be supported, but + doesn&#39;t make sense?  Where 1+1 actually isn&#39;t 2?<br>&gt; <br>&gt; If not, are integer literals really just part of Arithmetic?<br>&gt; <br>&gt; - Steve<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/997fa7aa/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>June 29, 2016 at 10:00:00am</p></header><div class="content"><p>On Jun 29, 2016, at 9:33 AM, David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br></p><p>&gt; Types where it makes sense, or types for which such semantics would be a good idea? Because, for example, you could do something like this:<br>&gt; struct HTMLParser : IntegerLiteralConvertible {<br>&gt;     init(integerLiteral value: IntegerLiteralType) {<br>&gt;         htmlMajorVersion = value<br>&gt;         htmlMinorVersion = 0<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; Back in the realm of math, I don’t think Sedenions — a 16-demensional (in the sense that complex numbers are 2-dimensional) number  — have a well-defined division operator.<br>&gt; <br>&gt; As a more likely example, I don’t think it’d be too much of a stretch to attach integer literal semantics to matrices:<br>&gt; let x: Matrix = 1 // Sets diagonal to 1<br>&gt; Matrices don’t have a division operator, and you can’t do any of the `Arithmetic` functions to two matrices without first checking their dimensions.<br></p><p>There is at least an argument to be made that *division* doesn’t belong.  I think most people&#39;s common-sense notion of being “numbery” lies somewhere between a ring and a field (but probably doesn’t include the Sedenions, which aren’t associative).<br></p><p>That said, there are certainly some practical considerations in favor of including division in Arithmetic.<br></p><p>I think matrix dimension mismatches (for variably-dimensioned types) are best handled via precondition; the operator exists, but will trap if they don’t match.<br></p><p>&gt; Plus, inherently-dimensioned matrix types:<br>&gt; var x = Matrix&lt;_2,_3&gt;() // &quot;_2&quot; and &quot;_3&quot; are dummy types<br>&gt; can’t implement `*`, unless their two dimensions happen to be equal — &quot;Matrix&lt;2,3&gt;() * Matrix&lt;2,3&gt;()” doesn’t have a valid definition.<br></p><p>I’m not sure it makes sense to have scalar initializers or literals for non-square matrices, since you don&#39;t have 1*x = x.<br></p><p>We’re a little bit off in the weeds here =)<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/4a50bf50/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>June 29, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 9:05 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt; <br>&gt; We’re a little bit off in the weeds here =)<br></p><p><br>I was only providing examples of why we might not want to tie `Arithmetic` to, um I think `Syntax.Literal.Integer` is the latest suggestion. I know they aren’t perfect, but they all seem to be not too far-fetched (except the HTMLParser).<br></p><p>If you’re suggesting we start a thread about what it’d take to rework `Arithmetic` to support modeling rings and fields, I am totally on-board… :-)<br></p><p>- Dave Sweeris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/169a10bc/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>June 28, 2016 at 09:00:00pm</p></header><div class="content"><p>I vote for IntegerParkour :-)<br></p><p>Sent from my iPhone<br></p><p>&gt; On Jun 28, 2016, at 20:35, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Jun 28, 2016, at 6:13 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt; Or we&#39;re clueless AND it&#39;s a bad name.<br>&gt;&gt; <br>&gt;&gt; It&#39;s possible, but until we have an objective rationale for why it&#39;s bad<br>&gt;&gt; (arguments that it seems to imply what turns out to be the actual<br>&gt;&gt; meaning of the protocol don&#39;t count!), *and* a better alternative, it&#39;s<br>&gt;&gt; sort of moot.  If you don&#39;t like `Syntax.IntegerLiteral` or<br>&gt;&gt; `Syntax.IntegerLiteralExpressible` then I&#39;m out of suggestions.<br>&gt;&gt; <br>&gt;&gt;&gt; func f&lt;T: IntegerPromotion&gt;() -&gt; T {<br>&gt;&gt;&gt;    return 42 // the answer to everything<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Promotion means something very different; something that we actually<br>&gt;&gt; expect to incorporate into the language one day.<br>&gt; <br>&gt; Next pitch:<br>&gt; Syntax.IntegerLiteralInsertion<br>&gt; Less successful attempts to brainstorm:<br>&gt; Syntax.IntegerLiteralAdvancement<br>&gt; Syntax.IntegerLiteralUpgrade<br>&gt; Syntax.FreelyIntegerReplaceable<br>&gt; Syntax.IntegerParkour<br>&gt; Syntax.TodayTheRoleOfTWillBePlayedByIntegerLiteral<br>&gt; Syntax.IntegerLiteralTypePoseur<br>&gt; Syntax.IntegerLiteral.Zigazigahh<br>&gt; Syntax.IntegerLiteralBoosterPack<br>&gt; Syntax.IntegerLevelUp<br>&gt; Syntax.IntegerElevator<br>&gt; Syntax.MarvinTheDepressedIntegerLiteral<br>&gt; -- E<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/12b6e431/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/67a361b77f5c6cba256d06ba641f2af8?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>Nate Cook</string> &lt;nate at natecook.com&gt;<p>June 29, 2016 at 04:00:00pm</p></header><div class="content"><p>Nate<br>&gt; On Jun 28, 2016, at 3:57 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; on Thu Jun 23 2016, Nate Cook &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I like the namespace-based approach to group these protocols together<br>&gt;&gt; and I&#39;m very happy to see some clarification happening in this group<br>&gt;&gt; of protocols. However, I don&#39;t think the proposed new names<br>&gt;&gt; communicate what they need to. The names listed in the &quot;Alternatives<br>&gt;&gt; Considered&quot; section do a better job of describing the use and behavior<br>&gt;&gt; of these protocols.<br>&gt;&gt; <br>&gt;&gt; Primarily, the new names read like we&#39;re saying that a conforming type<br>&gt;&gt; is a literal, compounding a common existing confusion between literals<br>&gt;&gt; and types that can be initialized with a literal.<br>&gt; <br>&gt; No, it&#39;s exactly the opposite, as I keep saying.  Conformance to this<br>&gt; protocol does *not* mean you can initialize the type with a literal.<br></p><p>Fair enough! The point I&#39;m most concerned about is that there is confusion (among the populace at large, less so on this list) between literals and types that can be written as literals. The number 43 is an integer literal, not an `Int` - its type is either inferred from context or given explicitly. Some kind of adjective in the protocol name would make that more clear than removing the adjective.<br></p><p>&gt; Proof:<br>&gt; <br>&gt;  func f&lt;T: IntegerLiteralConvertible&gt;() -&gt; T {<br>&gt;    return T(integerLiteral: 43) // Error<br>&gt;    return T(43)                 // Also an Error<br>&gt;  }<br>&gt; <br>&gt; It means an instance of the type can be *written* as a literal:<br>&gt; <br>&gt;  func f&lt;T: IntegerLiteralConvertible&gt;() -&gt; T {<br>&gt;    return 43   // OK<br>&gt;  }<br>&gt; <br>&gt; Everybody&#39;s confused about the meaning of the protocol, and doesn&#39;t like<br>&gt; the proposed names because they imply exactly the actual meaning of the<br>&gt; protocol, which they misunderstand.<br></p><p>I resemble this remark.<br></p><p>Nate<br></p><p>&gt; -- <br>&gt; Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
