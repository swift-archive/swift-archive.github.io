<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/582b7183bda90126e385e2cc95cb7088?s=50"></div><header><strong>[Idea] Use optionals for non-optional parameters</strong> from <string>Justin Jia</string> &lt;justin.jia.developer at gmail.com&gt;<p>August 15, 2016 at 03:00:00pm</p></header><div class="content"><p>Hi!<br></p><p>I don’t know if this has came up before. I tried to search though the mailing list but didn’t find any related threads.<br></p><p>This is purely a syntactic thing (which I know it’s the lowest priority for Swift 4), but I think it’s an important one.<br></p><p>Let’s say we have a struct with a function:<br></p><p>```<br>struct Foo {<br>    func bar(x: Int)<br>}<br>```<br></p><p>We can use optionals:<br></p><p>```<br>let foo: Foo? = nil<br>let x = 1<br>foo!.bar(x: x) // Able to compile, but will cause runtime error<br>foo?.bar(x: x) // Able to compile, and won&#39;t cause runtime error<br>```<br></p><p>However:<br></p><p>```<br>let foo = Foo()<br>let x: Int? = nil<br>foo.bar(x: x!) // Able to compile, but will cause runtime error<br>foo.bar(x: x?) // Won&#39;t compile<br>```<br></p><p>I propose that we should allow `foo.bar(x: x?)`, which should be equivalent to:<br></p><p>```<br>if let x = x {<br>  foo.bar(x: x)<br>}<br>```<br></p><p>What do you think?<br></p><p>Thanks,<br>Justin<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Idea] Use optionals for non-optional parameters</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 15, 2016 at 02:00:00am</p></header><div class="content"><p>It has been mentioned before (more than once, perhaps, but not in its own<br>thread I don&#39;t think, so good luck finding it). IIRC, one of the problems<br>is that it&#39;s unclear what happens if your function takes multiple<br>arguments. Does evaluation proceed from left to right? does it<br>short-circuit? Put concretely:<br></p><p>```<br>func bar(_ x: Int) -&gt; Int? { /* side effects */ }<br>func baz(_ y: Int) -&gt; Int? { /* side effects */ }<br>func foo(_ z: Int, _ a: Int) -&gt; Int { /* ... */ }<br></p><p>print(foo(bar(42)?, baz(42)?))<br>```<br></p><p>Does baz(42) get evaluated if bar returns nil? Does bar(42) get evaluated<br>if baz returns nil?<br></p><p><br>On Mon, Aug 15, 2016 at 2:02 AM, Justin Jia via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hi!<br>&gt;<br>&gt; I don’t know if this has came up before. I tried to search though the<br>&gt; mailing list but didn’t find any related threads.<br>&gt;<br>&gt; This is purely a syntactic thing (which I know it’s the lowest priority<br>&gt; for Swift 4), but I think it’s an important one.<br>&gt;<br>&gt; Let’s say we have a struct with a function:<br>&gt;<br>&gt; ```<br>&gt; struct Foo {<br>&gt;     func bar(x: Int)<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; We can use optionals:<br>&gt;<br>&gt; ```<br>&gt; let foo: Foo? = nil<br>&gt; let x = 1<br>&gt; foo!.bar(x: x) // Able to compile, but will cause runtime error<br>&gt; foo?.bar(x: x) // Able to compile, and won&#39;t cause runtime error<br>&gt; ```<br>&gt;<br>&gt; However:<br>&gt;<br>&gt; ```<br>&gt; let foo = Foo()<br>&gt; let x: Int? = nil<br>&gt; foo.bar(x: x!) // Able to compile, but will cause runtime error<br>&gt; foo.bar(x: x?) // Won&#39;t compile<br>&gt; ```<br>&gt;<br>&gt; I propose that we should allow `foo.bar(x: x?)`, which should be<br>&gt; equivalent to:<br>&gt;<br>&gt; ```<br>&gt; if let x = x {<br>&gt;   foo.bar(x: x)<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; What do you think?<br>&gt;<br>&gt; Thanks,<br>&gt; Justin<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160815/8f362dc7/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Idea] Use optionals for non-optional parameters</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>August 15, 2016 at 09:00:00am</p></header><div class="content"><p>Hi Justin,<br></p><p>IIRC, there were several discussions about this, all of them ending up at a dead point. The question was, what would be the behavior of<br></p><p>foo(argA: methodA(), argB: methodB())<br></p><p>where methodA returns an optional. If that evaluates to nil, would methodB get evaluated as well? Or should it shortcircuit?<br></p><p>&gt; On Aug 15, 2016, at 9:02 AM, Justin Jia via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi!<br>&gt; <br>&gt; I don’t know if this has came up before. I tried to search though the mailing list but didn’t find any related threads.<br>&gt; <br>&gt; This is purely a syntactic thing (which I know it’s the lowest priority for Swift 4), but I think it’s an important one.<br>&gt; <br>&gt; Let’s say we have a struct with a function:<br>&gt; <br>&gt; ```<br>&gt; struct Foo {<br>&gt;    func bar(x: Int)<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; We can use optionals:<br>&gt; <br>&gt; ```<br>&gt; let foo: Foo? = nil<br>&gt; let x = 1<br>&gt; foo!.bar(x: x) // Able to compile, but will cause runtime error<br>&gt; foo?.bar(x: x) // Able to compile, and won&#39;t cause runtime error<br>&gt; ```<br>&gt; <br>&gt; However:<br>&gt; <br>&gt; ```<br>&gt; let foo = Foo()<br>&gt; let x: Int? = nil<br>&gt; foo.bar(x: x!) // Able to compile, but will cause runtime error<br>&gt; foo.bar(x: x?) // Won&#39;t compile<br>&gt; ```<br>&gt; <br>&gt; I propose that we should allow `foo.bar(x: x?)`, which should be equivalent to:<br>&gt; <br>&gt; ```<br>&gt; if let x = x {<br>&gt;  foo.bar(x: x)<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; What do you think?<br>&gt; <br>&gt; Thanks,<br>&gt; Justin<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Idea] Use optionals for non-optional parameters</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>August 15, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; Am 15.08.2016 um 09:02 schrieb Justin Jia via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; foo.bar(x: x?)<br>Yes, those guards and ifs can be tedious, but it is clear what they are doing, and there is no doubt what code will be evaluated and what will be skipped.<br>If Swift had syntactic sugar that acts like optional chaining for parameters, I don&#39;t think that I would use it, because by moving the question mark far to the right, it can easily hide that something is conditional.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Idea] Use optionals for non-optional parameters</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>August 15, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On 15 Aug 2016, at 08:02, Justin Jia via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi!<br>&gt; <br>&gt; I don’t know if this has came up before. I tried to search though the mailing list but didn’t find any related threads.<br>&gt; <br>&gt; This is purely a syntactic thing (which I know it’s the lowest priority for Swift 4), but I think it’s an important one.<br>&gt; <br>&gt; Let’s say we have a struct with a function:<br>&gt; <br>&gt; ```<br>&gt; struct Foo {<br>&gt;    func bar(x: Int)<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; We can use optionals:<br>&gt; <br>&gt; ```<br>&gt; let foo: Foo? = nil<br>&gt; let x = 1<br>&gt; foo!.bar(x: x) // Able to compile, but will cause runtime error<br>&gt; foo?.bar(x: x) // Able to compile, and won&#39;t cause runtime error<br>&gt; ```<br>&gt; <br>&gt; However:<br>&gt; <br>&gt; ```<br>&gt; let foo = Foo()<br>&gt; let x: Int? = nil<br>&gt; foo.bar(x: x!) // Able to compile, but will cause runtime error<br>&gt; foo.bar(x: x?) // Won&#39;t compile<br>&gt; ```<br>&gt; <br>&gt; I propose that we should allow `foo.bar(x: x?)`, which should be equivalent to:<br>&gt; <br>&gt; ```<br>&gt; if let x = x {<br>&gt;  foo.bar(x: x)<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; What do you think?<br></p><p>I like the intent behind this, but personally I think it&#39;s not clear enough. For me, putting the statement in a conditional as you&#39;ve shown is the better solution, as it&#39;s a lot clearer exactly what&#39;s going on. Putting a question mark on a variable makes it look like something specific to that variable, rather than preventing the entire statement from executing.<br></p><p>There may be some alternatives though, for example, what about a shorthand for the conditional like so:<br></p><p>	if let x? { foo.bar(x: x) }<br>	if x? { foo.bar(x: x) } // even shorter?<br></p><p>But in general, I think it&#39;s best to be explicit about the entire statement being optional, which the conditional does but a postfix on a variable doesn&#39;t to the same degree.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160815/6ec38dad/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/582b7183bda90126e385e2cc95cb7088?s=50"></div><header><strong>[Idea] Use optionals for non-optional parameters</strong> from <string>Justin Jia</string> &lt;justin.jia.developer at gmail.com&gt;<p>August 15, 2016 at 09:00:00pm</p></header><div class="content"><p>IMO `if x? { }` is not a lot shorter than `if let x = x`.<br></p><p>The problem with `if let` is, you need to explicit specify { } and call the function inside it. It is good for being explicit, but sometimes you ended up with something like this:<br></p><p>```<br>/* code 1 */<br>if let x = x, let y = y {<br>    / * code 2 */<br>    let z = foo(x, y)<br>    if let z = z {<br>        bar(z)<br>    }<br>    / * code 3 */<br>}<br>/* code 4 */<br>```<br></p><p>I would like to use guard if possible, but guard will force you to leave the entire function.<br></p><p>```<br>/ * code 1 */<br>guard let x = x, y = y else { return }<br>/* code 2 */<br>/ * some code */<br>guard let z = foo(x, y) else { return }<br>bar(z)<br>/ * code 3 */ // note: code 3 and code 4 won’t execute if x, y, or z is nil!<br>/ * code 4 */ <br>```<br></p><p>What I really want is some like this:<br></p><p>```<br>/ * code 1 */<br>let z = foo(x?, y?)<br>/ * code 2 */<br>bar(z?)<br>/ * code 3 */ // note: code 3 and code 4 will still execute even if z is nil!<br>/ * code 4 */<br>```<br></p><p>IMO, this is much easier to read.<br></p><p>Sincerely,<br>Justin<br></p><p><br>&gt; On Aug 15, 2016, at 7:05 PM, Haravikk &lt;swift-evolution at haravikk.me&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 15 Aug 2016, at 08:02, Justin Jia via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi!<br>&gt;&gt; <br>&gt;&gt; I don’t know if this has came up before. I tried to search though the mailing list but didn’t find any related threads.<br>&gt;&gt; <br>&gt;&gt; This is purely a syntactic thing (which I know it’s the lowest priority for Swift 4), but I think it’s an important one.<br>&gt;&gt; <br>&gt;&gt; Let’s say we have a struct with a function:<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; struct Foo {<br>&gt;&gt;    func bar(x: Int)<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; We can use optionals:<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; let foo: Foo? = nil<br>&gt;&gt; let x = 1<br>&gt;&gt; foo!.bar(x: x) // Able to compile, but will cause runtime error<br>&gt;&gt; foo?.bar(x: x) // Able to compile, and won&#39;t cause runtime error<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; However:<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; let foo = Foo()<br>&gt;&gt; let x: Int? = nil<br>&gt;&gt; foo.bar(x: x!) // Able to compile, but will cause runtime error<br>&gt;&gt; foo.bar(x: x?) // Won&#39;t compile<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; I propose that we should allow `foo.bar(x: x?)`, which should be equivalent to:<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; if let x = x {<br>&gt;&gt;  foo.bar(x: x)<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; What do you think?<br>&gt; <br>&gt; I like the intent behind this, but personally I think it&#39;s not clear enough. For me, putting the statement in a conditional as you&#39;ve shown is the better solution, as it&#39;s a lot clearer exactly what&#39;s going on. Putting a question mark on a variable makes it look like something specific to that variable, rather than preventing the entire statement from executing.<br>&gt; <br>&gt; There may be some alternatives though, for example, what about a shorthand for the conditional like so:<br>&gt; <br>&gt; 	if let x? { foo.bar(x: x) }<br>&gt; 	if x? { foo.bar(x: x) } // even shorter?<br>&gt; <br>&gt; But in general, I think it&#39;s best to be explicit about the entire statement being optional, which the conditional does but a postfix on a variable doesn&#39;t to the same degree.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160815/02ec4c7e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/15ed660cd9d971062f9dd5084932a698?s=50"></div><header><strong>[Idea] Use optionals for non-optional parameters</strong> from <string>David Rönnqvist</string> &lt;david.ronnqvist at gmail.com&gt;<p>August 15, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On 15 Aug 2016, at 15:29, Justin Jia via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; IMO `if x? { }` is not a lot shorter than `if let x = x`.<br>&gt; <br>&gt; The problem with `if let` is, you need to explicit specify { } and call the function inside it. It is good for being explicit, but sometimes you ended up with something like this:<br>&gt; <br>&gt; ```<br>&gt; /* code 1 */<br>&gt; if let x = x, let y = y {<br>&gt;     / * code 2 */<br>&gt;     let z = foo(x, y)<br>&gt;     if let z = z {<br>&gt;         bar(z)<br>&gt;     }<br>&gt;     / * code 3 */<br>&gt; }<br>&gt; /* code 4 */<br>&gt; ```<br>&gt; <br>&gt; I would like to use guard if possible, but guard will force you to leave the entire function.<br>&gt; <br>&gt; ```<br>&gt; / * code 1 */<br>&gt; guard let x = x, y = y else { return }<br>&gt; /* code 2 */<br>&gt; / * some code */<br>&gt; guard let z = foo(x, y) else { return }<br>&gt; bar(z)<br>&gt; / * code 3 */ // note: code 3 and code 4 won’t execute if x, y, or z is nil!<br>&gt; / * code 4 */ <br>&gt; ```<br>&gt; <br>&gt; What I really want is some like this:<br>&gt; <br>&gt; ```<br>&gt; / * code 1 */<br>&gt; let z = foo(x?, y?)<br>&gt; / * code 2 */<br>&gt; bar(z?)<br>&gt; / * code 3 */ // note: code 3 and code 4 will still execute even if z is nil!<br>&gt; / * code 4 */<br>&gt; ```<br>&gt; <br></p><p>The fact that this variant and the guard variant doesn’t do the same thing stands out to me. The if-let and guard variants while being more verbose is also very explicit about the control flow. While reading that I can fully understand under what circumstances code 3 and 4 will be executed. This sugar would be more equivalent to this (below), which I’m not sure if everyone would expect it to be. I can see people being surprised that code 3 and 4 was executed, especially if calling `bar` had some side effects that either code 3 or 4 was relying on.<br></p><p>/ * code 1 */<br>let z = x.flatMap { <br>  x in y.flatMap { <br>    y in foo(x, y)<br>  }<br>}<br>/ * code 2 */<br>let _ = z.flatMap { z in bar(z) }<br>/ * code 3 */ // note: code 3 and code 4 will still execute even if z is nil!<br>/ * code 4 */<br></p><p><br>&gt; IMO, this is much easier to read.<br>&gt; <br>&gt; Sincerely,<br>&gt; Justin<br>&gt; <br>&gt; <br>&gt;&gt; On Aug 15, 2016, at 7:05 PM, Haravikk &lt;swift-evolution at haravikk.me &lt;mailto:swift-evolution at haravikk.me&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 15 Aug 2016, at 08:02, Justin Jia via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don’t know if this has came up before. I tried to search though the mailing list but didn’t find any related threads.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is purely a syntactic thing (which I know it’s the lowest priority for Swift 4), but I think it’s an important one.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Let’s say we have a struct with a function:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; struct Foo {<br>&gt;&gt;&gt;    func bar(x: Int)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We can use optionals:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; let foo: Foo? = nil<br>&gt;&gt;&gt; let x = 1<br>&gt;&gt;&gt; foo!.bar(x: x) // Able to compile, but will cause runtime error<br>&gt;&gt;&gt; foo?.bar(x: x) // Able to compile, and won&#39;t cause runtime error<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; However:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; let foo = Foo()<br>&gt;&gt;&gt; let x: Int? = nil<br>&gt;&gt;&gt; foo.bar(x: x!) // Able to compile, but will cause runtime error<br>&gt;&gt;&gt; foo.bar(x: x?) // Won&#39;t compile<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I propose that we should allow `foo.bar(x: x?)`, which should be equivalent to:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; if let x = x {<br>&gt;&gt;&gt;  foo.bar(x: x)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What do you think?<br>&gt;&gt; <br>&gt;&gt; I like the intent behind this, but personally I think it&#39;s not clear enough. For me, putting the statement in a conditional as you&#39;ve shown is the better solution, as it&#39;s a lot clearer exactly what&#39;s going on. Putting a question mark on a variable makes it look like something specific to that variable, rather than preventing the entire statement from executing.<br>&gt;&gt; <br>&gt;&gt; There may be some alternatives though, for example, what about a shorthand for the conditional like so:<br>&gt;&gt; <br>&gt;&gt; 	if let x? { foo.bar(x: x) }<br>&gt;&gt; 	if x? { foo.bar(x: x) } // even shorter?<br>&gt;&gt; <br>&gt;&gt; But in general, I think it&#39;s best to be explicit about the entire statement being optional, which the conditional does but a postfix on a variable doesn&#39;t to the same degree.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160815/e8b9af30/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/582b7183bda90126e385e2cc95cb7088?s=50"></div><header><strong>[Idea] Use optionals for non-optional parameters</strong> from <string>Justin Jia</string> &lt;justin.jia.developer at gmail.com&gt;<p>August 16, 2016 at 01:00:00am</p></header><div class="content"><p>I agree that being explicit is nice and I also like to use `guard`.<br></p><p>But according to my observation, usually it is easier to make mistakes if we choose to use `guard`.<br></p><p>Let me give you a fake real world example.<br></p><p>With `guard`, you need to be really careful when you want to add new expression (people usually will add to the end of the function).<br></p><p>```<br>func updateCell(cell: Cell, data: CellData) {<br>  cell.label.text = data.title<br>  guard let imageName = data.imageName else { return }<br>  cell.sublabel.text = cell.humanize(imageName)<br>  guard let image = UIImage(named: imageName) else { return }<br>  cell.addBackgroundImage(image)<br>  // Let&#39;s say we changed the design and added a new heading that depends on image name<br>  cell.heading = String(imageName.characters.first) // This won&#39;t be called if image is nil!<br>}<br>```<br></p><p>With `if let`, it is really hard to read. This will become more complicated if we add more attributes to cell.<br></p><p>```<br>func updateCell(cell: Cell, data: CellData) {<br>  cell.label.text = data.title<br>  if let imageName = data.imageName {<br>    cell.sublabel.text = cell.humanize(imageName)<br>    if let image = UIImage(name: imageName) {<br>      cell.addBackgroundImage(image)<br>    }<br>    cell.heading = String(imageName.characters.first)<br>  }<br>}<br>```<br></p><p>With the proposed syntax:<br></p><p>```<br>func updateCell(cell: Cell, data: CellData) {<br>  cell.label.text = data.title<br>  let imageName = data.imageName // imageName is optional<br>  cell.sublabel.text = cell.humanize(imageName?)<br>  let image = UIImage(named: imageName?) // image is optional<br>  cell.addBackgroundImage(image?)<br>  cell.heading = String(imageName.characters.first?)<br>}<br>```<br></p><p>This is really easy to read. And everything works correctly.<br></p><p><br>&gt; On Aug 16, 2016, at 12:43 AM, David Rönnqvist &lt;david.ronnqvist at gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On 15 Aug 2016, at 15:29, Justin Jia via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; IMO `if x? { }` is not a lot shorter than `if let x = x`.<br>&gt;&gt; <br>&gt;&gt; The problem with `if let` is, you need to explicit specify { } and call the function inside it. It is good for being explicit, but sometimes you ended up with something like this:<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; /* code 1 */<br>&gt;&gt; if let x = x, let y = y {<br>&gt;&gt;     / * code 2 */<br>&gt;&gt;     let z = foo(x, y)<br>&gt;&gt;     if let z = z {<br>&gt;&gt;         bar(z)<br>&gt;&gt;     }<br>&gt;&gt;     / * code 3 */<br>&gt;&gt; }<br>&gt;&gt; /* code 4 */<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; I would like to use guard if possible, but guard will force you to leave the entire function.<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; / * code 1 */<br>&gt;&gt; guard let x = x, y = y else { return }<br>&gt;&gt; /* code 2 */<br>&gt;&gt; / * some code */<br>&gt;&gt; guard let z = foo(x, y) else { return }<br>&gt;&gt; bar(z)<br>&gt;&gt; / * code 3 */ // note: code 3 and code 4 won’t execute if x, y, or z is nil!<br>&gt;&gt; / * code 4 */ <br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; What I really want is some like this:<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; / * code 1 */<br>&gt;&gt; let z = foo(x?, y?)<br>&gt;&gt; / * code 2 */<br>&gt;&gt; bar(z?)<br>&gt;&gt; / * code 3 */ // note: code 3 and code 4 will still execute even if z is nil!<br>&gt;&gt; / * code 4 */<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt; <br>&gt; The fact that this variant and the guard variant doesn’t do the same thing stands out to me. The if-let and guard variants while being more verbose is also very explicit about the control flow. While reading that I can fully understand under what circumstances code 3 and 4 will be executed. This sugar would be more equivalent to this (below), which I’m not sure if everyone would expect it to be. I can see people being surprised that code 3 and 4 was executed, especially if calling `bar` had some side effects that either code 3 or 4 was relying on.<br>&gt; <br>&gt; / * code 1 */<br>&gt; let z = x.flatMap { <br>&gt;   x in y.flatMap { <br>&gt;     y in foo(x, y)<br>&gt;   }<br>&gt; }<br>&gt; / * code 2 */<br>&gt; let _ = z.flatMap { z in bar(z) }<br>&gt; / * code 3 */ // note: code 3 and code 4 will still execute even if z is nil!<br>&gt; / * code 4 */<br>&gt; <br>&gt; <br>&gt;&gt; IMO, this is much easier to read.<br>&gt;&gt; <br>&gt;&gt; Sincerely,<br>&gt;&gt; Justin<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Aug 15, 2016, at 7:05 PM, Haravikk &lt;swift-evolution at haravikk.me &lt;mailto:swift-evolution at haravikk.me&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 15 Aug 2016, at 08:02, Justin Jia via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don’t know if this has came up before. I tried to search though the mailing list but didn’t find any related threads.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is purely a syntactic thing (which I know it’s the lowest priority for Swift 4), but I think it’s an important one.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Let’s say we have a struct with a function:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; struct Foo {<br>&gt;&gt;&gt;&gt;    func bar(x: Int)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We can use optionals:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; let foo: Foo? = nil<br>&gt;&gt;&gt;&gt; let x = 1<br>&gt;&gt;&gt;&gt; foo!.bar(x: x) // Able to compile, but will cause runtime error<br>&gt;&gt;&gt;&gt; foo?.bar(x: x) // Able to compile, and won&#39;t cause runtime error<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; However:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; let foo = Foo()<br>&gt;&gt;&gt;&gt; let x: Int? = nil<br>&gt;&gt;&gt;&gt; foo.bar(x: x!) // Able to compile, but will cause runtime error<br>&gt;&gt;&gt;&gt; foo.bar(x: x?) // Won&#39;t compile<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I propose that we should allow `foo.bar(x: x?)`, which should be equivalent to:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; if let x = x {<br>&gt;&gt;&gt;&gt;  foo.bar(x: x)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What do you think?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I like the intent behind this, but personally I think it&#39;s not clear enough. For me, putting the statement in a conditional as you&#39;ve shown is the better solution, as it&#39;s a lot clearer exactly what&#39;s going on. Putting a question mark on a variable makes it look like something specific to that variable, rather than preventing the entire statement from executing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There may be some alternatives though, for example, what about a shorthand for the conditional like so:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	if let x? { foo.bar(x: x) }<br>&gt;&gt;&gt; 	if x? { foo.bar(x: x) } // even shorter?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But in general, I think it&#39;s best to be explicit about the entire statement being optional, which the conditional does but a postfix on a variable doesn&#39;t to the same degree.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160816/43515fd8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Idea] Use optionals for non-optional parameters</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>September  3, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; Am 15.08.2016 um 19:05 schrieb Justin Jia via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; I agree that being explicit is nice and I also like to use `guard`.<br>&gt; <br>&gt; But according to my observation, usually it is easier to make mistakes if we choose to use `guard`.<br>&gt; <br>&gt; Let me give you a fake real world example.<br>&gt; <br>&gt; With `guard`, you need to be really careful when you want to add new expression (people usually will add to the end of the function).<br>&gt; <br>&gt; ```<br>&gt; func updateCell(cell: Cell, data: CellData) {<br>&gt;   cell.label.text = data.title<br>&gt;   guard let imageName = data.imageName else { return }<br>&gt;   cell.sublabel.text = cell.humanize(imageName)<br>&gt;   guard let image = UIImage(named: imageName) else { return }<br>&gt;   cell.addBackgroundImage(image)<br>&gt;   // Let&#39;s say we changed the design and added a new heading that depends on image name<br>&gt;   cell.heading = String(imageName.characters.first) // This won&#39;t be called if image is nil!<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; With `if let`, it is really hard to read. This will become more complicated if we add more attributes to cell.<br>&gt; <br>&gt; ```<br>&gt; func updateCell(cell: Cell, data: CellData) {<br>&gt;   cell.label.text = data.title<br>&gt;   if let imageName = data.imageName {<br>&gt;     cell.sublabel.text = cell.humanize(imageName)<br>&gt;     if let image = UIImage(name: imageName) {<br>&gt;       cell.addBackgroundImage(image)<br>&gt;     }<br>&gt;     cell.heading = String(imageName.characters.first)<br>&gt;   }<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; With the proposed syntax:<br>&gt; <br>&gt; ```<br>&gt; func updateCell(cell: Cell, data: CellData) {<br>&gt;   cell.label.text = data.title<br>&gt;   let imageName = data.imageName // imageName is optional<br>&gt;   cell.sublabel.text = cell.humanize(imageName?)<br>&gt;   let image = UIImage(named: imageName?) // image is optional<br>&gt;   cell.addBackgroundImage(image?)<br>&gt;   cell.heading = String(imageName.characters.first?)<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; This is really easy to read. And everything works correctly.<br></p><p>It is even easier if you define the methods on Cell to take optional arguments. <br>Then you can write the code like in your last example and don&#39;t even need the proposed syntax:<br></p><p>class Cell {<br>    let label = UILabel()<br>    let sublabel = UILabel()<br>    var heading: String?<br>    func humanize(_ string: String?) -&gt; String {...}    // optional argument<br>    func addBackgroundImage(_ image: UIImage?)    // optional argument<br>}<br></p><p>extension UIImage {<br>    init?(named imageName: String?) {...}<br>}<br></p><p>extension String {<br>    init?(named imageName: Character?) {...}<br>}<br></p><p>func updateCell(cell: Cell, data: CellData) {<br>  cell.label.text = data.title<br>  let imageName = data.imageName<br>  cell.sublabel.text = cell.humanize(imageName)<br>  let image = UIImage(named: imageName)<br>  cell.addBackgroundImage(image)<br>  cell.heading = String(imageName?.characters?.first)<br>}<br></p><p>-Thorsten <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160903/72d0a2b0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/582b7183bda90126e385e2cc95cb7088?s=50"></div><header><strong>[Idea] Use optionals for non-optional parameters</strong> from <string>Justin Jia</string> &lt;justin.jia.developer at gmail.com&gt;<p>September  4, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On Sep 4, 2016, at 12:19 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Am 15.08.2016 um 19:05 schrieb Justin Jia via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; <br>&gt;&gt; I agree that being explicit is nice and I also like to use `guard`.<br>&gt;&gt; <br>&gt;&gt; But according to my observation, usually it is easier to make mistakes if we choose to use `guard`.<br>&gt;&gt; <br>&gt;&gt; Let me give you a fake real world example.<br>&gt;&gt; <br>&gt;&gt; With `guard`, you need to be really careful when you want to add new expression (people usually will add to the end of the function).<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; func updateCell(cell: Cell, data: CellData) {<br>&gt;&gt;   cell.label.text = data.title<br>&gt;&gt;   guard let imageName = data.imageName else { return }<br>&gt;&gt;   cell.sublabel.text = cell.humanize(imageName)<br>&gt;&gt;   guard let image = UIImage(named: imageName) else { return }<br>&gt;&gt;   cell.addBackgroundImage(image)<br>&gt;&gt;   // Let&#39;s say we changed the design and added a new heading that depends on image name<br>&gt;&gt;   cell.heading = String(imageName.characters.first) // This won&#39;t be called if image is nil!<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; With `if let`, it is really hard to read. This will become more complicated if we add more attributes to cell.<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; func updateCell(cell: Cell, data: CellData) {<br>&gt;&gt;   cell.label.text = data.title<br>&gt;&gt;   if let imageName = data.imageName {<br>&gt;&gt;     cell.sublabel.text = cell.humanize(imageName)<br>&gt;&gt;     if let image = UIImage(name: imageName) {<br>&gt;&gt;       cell.addBackgroundImage(image)<br>&gt;&gt;     }<br>&gt;&gt;     cell.heading = String(imageName.characters.first)<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; With the proposed syntax:<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; func updateCell(cell: Cell, data: CellData) {<br>&gt;&gt;   cell.label.text = data.title<br>&gt;&gt;   let imageName = data.imageName // imageName is optional<br>&gt;&gt;   cell.sublabel.text = cell.humanize(imageName?)<br>&gt;&gt;   let image = UIImage(named: imageName?) // image is optional<br>&gt;&gt;   cell.addBackgroundImage(image?)<br>&gt;&gt;   cell.heading = String(imageName.characters.first?)<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; This is really easy to read. And everything works correctly.<br>&gt; <br>&gt; It is even easier if you define the methods on Cell to take optional arguments. <br>&gt; Then you can write the code like in your last example and don&#39;t even need the proposed syntax:<br>&gt; <br>&gt; class Cell {<br>&gt;     let label = UILabel()<br>&gt;     let sublabel = UILabel()<br>&gt;     var heading: String?<br>&gt;     func humanize(_ string: String?) -&gt; String {...}    // optional argument<br>&gt;     func addBackgroundImage(_ image: UIImage?)    // optional argument<br>&gt; }<br>&gt; <br>&gt; extension UIImage {<br>&gt;     init?(named imageName: String?) {...}<br>&gt; }<br>&gt; <br>&gt; extension String {<br>&gt;     init?(named imageName: Character?) {...}<br>&gt; }<br>&gt; <br>&gt; func updateCell(cell: Cell, data: CellData) {<br>&gt;   cell.label.text = data.title<br>&gt;   let imageName = data.imageName<br>&gt;   cell.sublabel.text = cell.humanize(imageName)<br>&gt;   let image = UIImage(named: imageName)<br>&gt;   cell.addBackgroundImage(image)<br>&gt;   cell.heading = String(imageName?.characters?.first)<br>&gt; }<br>&gt; <br>&gt; -Thorsten <br></p><p><br>Quoting another email:<br></p><p>&gt; Actually there is an easy fix: make all functions accept optionals. I think this is a really bad idea because sometimes functions are designed to accept non-optionals.<br>&gt; <br>&gt; e.g.<br>&gt; <br>&gt; ```<br>&gt; func addSubview(_ view: UIView) { }<br>&gt; ```<br>&gt; <br>&gt; It doesn’t make sense if we want to add nil as the subview, so we choose to write code like this:<br>&gt; <br>&gt; ```<br>&gt; if let view = view {<br>&gt;     addSubview(view)<br>&gt; }<br>&gt; ```<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160904/e38cb27c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Idea] Use optionals for non-optional parameters</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>September  3, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; Am 03.09.2016 um 18:45 schrieb Justin Jia &lt;justin.jia.developer at gmail.com&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; On Sep 4, 2016, at 12:19 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Am 15.08.2016 um 19:05 schrieb Justin Jia via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; I agree that being explicit is nice and I also like to use `guard`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But according to my observation, usually it is easier to make mistakes if we choose to use `guard`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Let me give you a fake real world example.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; With `guard`, you need to be really careful when you want to add new expression (people usually will add to the end of the function).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; func updateCell(cell: Cell, data: CellData) {<br>&gt;&gt;&gt;   cell.label.text = data.title<br>&gt;&gt;&gt;   guard let imageName = data.imageName else { return }<br>&gt;&gt;&gt;   cell.sublabel.text = cell.humanize(imageName)<br>&gt;&gt;&gt;   guard let image = UIImage(named: imageName) else { return }<br>&gt;&gt;&gt;   cell.addBackgroundImage(image)<br>&gt;&gt;&gt;   // Let&#39;s say we changed the design and added a new heading that depends on image name<br>&gt;&gt;&gt;   cell.heading = String(imageName.characters.first) // This won&#39;t be called if image is nil!<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; With `if let`, it is really hard to read. This will become more complicated if we add more attributes to cell.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; func updateCell(cell: Cell, data: CellData) {<br>&gt;&gt;&gt;   cell.label.text = data.title<br>&gt;&gt;&gt;   if let imageName = data.imageName {<br>&gt;&gt;&gt;     cell.sublabel.text = cell.humanize(imageName)<br>&gt;&gt;&gt;     if let image = UIImage(name: imageName) {<br>&gt;&gt;&gt;       cell.addBackgroundImage(image)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     cell.heading = String(imageName.characters.first)<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; With the proposed syntax:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; func updateCell(cell: Cell, data: CellData) {<br>&gt;&gt;&gt;   cell.label.text = data.title<br>&gt;&gt;&gt;   let imageName = data.imageName // imageName is optional<br>&gt;&gt;&gt;   cell.sublabel.text = cell.humanize(imageName?)<br>&gt;&gt;&gt;   let image = UIImage(named: imageName?) // image is optional<br>&gt;&gt;&gt;   cell.addBackgroundImage(image?)<br>&gt;&gt;&gt;   cell.heading = String(imageName.characters.first?)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is really easy to read. And everything works correctly.<br>&gt;&gt; <br>&gt;&gt; It is even easier if you define the methods on Cell to take optional arguments. <br>&gt;&gt; Then you can write the code like in your last example and don&#39;t even need the proposed syntax:<br>&gt;&gt; <br>&gt;&gt; class Cell {<br>&gt;&gt;     let label = UILabel()<br>&gt;&gt;     let sublabel = UILabel()<br>&gt;&gt;     var heading: String?<br>&gt;&gt;     func humanize(_ string: String?) -&gt; String {...}    // optional argument<br>&gt;&gt;     func addBackgroundImage(_ image: UIImage?)    // optional argument<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension UIImage {<br>&gt;&gt;     init?(named imageName: String?) {...}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension String {<br>&gt;&gt;     init?(named imageName: Character?) {...}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func updateCell(cell: Cell, data: CellData) {<br>&gt;&gt;   cell.label.text = data.title<br>&gt;&gt;   let imageName = data.imageName<br>&gt;&gt;   cell.sublabel.text = cell.humanize(imageName)<br>&gt;&gt;   let image = UIImage(named: imageName)<br>&gt;&gt;   cell.addBackgroundImage(image)<br>&gt;&gt;   cell.heading = String(imageName?.characters?.first)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; -Thorsten <br>&gt; <br>&gt; <br>&gt; Quoting another email:<br>&gt; <br>&gt;&gt; Actually there is an easy fix: make all functions accept optionals. I think this is a really bad idea because sometimes functions are designed to accept non-optionals.<br>&gt;&gt; <br>&gt;&gt; e.g.<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; func addSubview(_ view: UIView) { }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; It doesn’t make sense if we want to add nil as the subview, so we choose to write code like this:<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; if let view = view {<br>&gt;&gt;     addSubview(view)<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt; <br></p><p>I agree. The proposal effectively does just that, though: turn every function into a function accepting optionals (returning nil if any argument is nil). I would prefer to do this explicitly in cases where it makes sense and use map or let-bindings elsewhere.<br></p><p>-Thorsten <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160903/5be3228d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/582b7183bda90126e385e2cc95cb7088?s=50"></div><header><strong>[Idea] Use optionals for non-optional parameters</strong> from <string>Justin Jia</string> &lt;justin.jia.developer at gmail.com&gt;<p>September  4, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Sep 4, 2016, at 1:35 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; Am 03.09.2016 um 18:45 schrieb Justin Jia &lt;justin.jia.developer at gmail.com&gt;:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Sep 4, 2016, at 12:19 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am 15.08.2016 um 19:05 schrieb Justin Jia via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I agree that being explicit is nice and I also like to use `guard`.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; But according to my observation, usually it is easier to make mistakes if we choose to use `guard`.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Let me give you a fake real world example.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; With `guard`, you need to be really careful when you want to add new expression (people usually will add to the end of the function).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; func updateCell(cell: Cell, data: CellData) {<br>&gt;&gt;&gt;&gt;   cell.label.text = data.title<br>&gt;&gt;&gt;&gt;   guard let imageName = data.imageName else { return }<br>&gt;&gt;&gt;&gt;   cell.sublabel.text = cell.humanize(imageName)<br>&gt;&gt;&gt;&gt;   guard let image = UIImage(named: imageName) else { return }<br>&gt;&gt;&gt;&gt;   cell.addBackgroundImage(image)<br>&gt;&gt;&gt;&gt;   // Let&#39;s say we changed the design and added a new heading that depends on image name<br>&gt;&gt;&gt;&gt;   cell.heading = String(imageName.characters.first) // This won&#39;t be called if image is nil!<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; With `if let`, it is really hard to read. This will become more complicated if we add more attributes to cell.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; func updateCell(cell: Cell, data: CellData) {<br>&gt;&gt;&gt;&gt;   cell.label.text = data.title<br>&gt;&gt;&gt;&gt;   if let imageName = data.imageName {<br>&gt;&gt;&gt;&gt;     cell.sublabel.text = cell.humanize(imageName)<br>&gt;&gt;&gt;&gt;     if let image = UIImage(name: imageName) {<br>&gt;&gt;&gt;&gt;       cell.addBackgroundImage(image)<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;     cell.heading = String(imageName.characters.first)<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; With the proposed syntax:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; func updateCell(cell: Cell, data: CellData) {<br>&gt;&gt;&gt;&gt;   cell.label.text = data.title<br>&gt;&gt;&gt;&gt;   let imageName = data.imageName // imageName is optional<br>&gt;&gt;&gt;&gt;   cell.sublabel.text = cell.humanize(imageName?)<br>&gt;&gt;&gt;&gt;   let image = UIImage(named: imageName?) // image is optional<br>&gt;&gt;&gt;&gt;   cell.addBackgroundImage(image?)<br>&gt;&gt;&gt;&gt;   cell.heading = String(imageName.characters.first?)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is really easy to read. And everything works correctly.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It is even easier if you define the methods on Cell to take optional arguments. <br>&gt;&gt;&gt; Then you can write the code like in your last example and don&#39;t even need the proposed syntax:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class Cell {<br>&gt;&gt;&gt;     let label = UILabel()<br>&gt;&gt;&gt;     let sublabel = UILabel()<br>&gt;&gt;&gt;     var heading: String?<br>&gt;&gt;&gt;     func humanize(_ string: String?) -&gt; String {...}    // optional argument<br>&gt;&gt;&gt;     func addBackgroundImage(_ image: UIImage?)    // optional argument<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension UIImage {<br>&gt;&gt;&gt;     init?(named imageName: String?) {...}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension String {<br>&gt;&gt;&gt;     init?(named imageName: Character?) {...}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func updateCell(cell: Cell, data: CellData) {<br>&gt;&gt;&gt;   cell.label.text = data.title<br>&gt;&gt;&gt;   let imageName = data.imageName<br>&gt;&gt;&gt;   cell.sublabel.text = cell.humanize(imageName)<br>&gt;&gt;&gt;   let image = UIImage(named: imageName)<br>&gt;&gt;&gt;   cell.addBackgroundImage(image)<br>&gt;&gt;&gt;   cell.heading = String(imageName?.characters?.first)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Thorsten <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Quoting another email:<br>&gt;&gt; <br>&gt;&gt;&gt; Actually there is an easy fix: make all functions accept optionals. I think this is a really bad idea because sometimes functions are designed to accept non-optionals.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; e.g.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; func addSubview(_ view: UIView) { }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It doesn’t make sense if we want to add nil as the subview, so we choose to write code like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; if let view = view {<br>&gt;&gt;&gt;     addSubview(view)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt; <br>&gt; <br>&gt; I agree. The proposal effectively does just that, though: turn every function into a function accepting optionals (returning nil if any argument is nil). I would prefer to do this explicitly in cases where it makes sense and use map or let-bindings elsewhere.<br>&gt; <br>&gt; -Thorsten <br></p><p>I was thinking about a precondition syntax. But I think it&#39;s too complicated. I agree. Maybe do this explicitly is better. <br></p><p>Justin<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160904/80b73958/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
