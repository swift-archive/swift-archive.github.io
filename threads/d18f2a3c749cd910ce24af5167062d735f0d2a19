<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/427280cb945b52af6e6717b44d417c6b?s=50"></div><header><strong>Immutable Structures</strong> from <string>Lino Rosa</string> &lt;lino.aguiar.rosa at gmail.com&gt;<p>December 23, 2015 at 03:00:00pm</p></header><div class="content"><p>I believe the language would be improved by making structures immutable.<br></p><p>1) The choice between classes and structures isn’t clear right now. If<br>structures were immutable it would be natural to use them as value objects.<br></p><p>2) Refactoring a mutable structure into a class when it’s being passed<br>around multiple threads removes the by-value semantics seamlessly. The<br>resulting mutable class isn’t thread-safe.<br></p><p>2.1) Even when passed around a single thread, the resulting class would be<br>passed by reference, so any mutations would have unintended consequences.<br></p><p>3) We could probably remove some syntax: `mutating` keyword and variable<br>parameters. Also the `var` keyword before a structure could be used to<br>denote reassignment (not mutability), just as it does with classes.<br></p><p>Of corse I might not be seeing the whole picture, so please weigh in.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/d18f2a19/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85ade213ef182c4a30916753b3c82b1e?s=50"></div><header><strong>Immutable Structures</strong> from <string>Ian Ynda-Hummel</string> &lt;ianynda at gmail.com&gt;<p>December 23, 2015 at 03:00:00pm</p></header><div class="content"><p>I thought structures were immutable and mutating functions actually just<br>created new structures, thus maintaining the by value semantics.<br>On Wed, Dec 23, 2015 at 10:45 AM Lino Rosa via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I believe the language would be improved by making structures immutable.<br>&gt;<br>&gt; 1) The choice between classes and structures isn’t clear right now. If<br>&gt; structures were immutable it would be natural to use them as value objects.<br>&gt;<br>&gt; 2) Refactoring a mutable structure into a class when it’s being passed<br>&gt; around multiple threads removes the by-value semantics seamlessly. The<br>&gt; resulting mutable class isn’t thread-safe.<br>&gt;<br>&gt; 2.1) Even when passed around a single thread, the resulting class would be<br>&gt; passed by reference, so any mutations would have unintended consequences.<br>&gt;<br>&gt; 3) We could probably remove some syntax: `mutating` keyword and variable<br>&gt; parameters. Also the `var` keyword before a structure could be used to<br>&gt; denote reassignment (not mutability), just as it does with classes.<br>&gt;<br>&gt; Of corse I might not be seeing the whole picture, so please weigh in.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/19576763/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/427280cb945b52af6e6717b44d417c6b?s=50"></div><header><strong>Immutable Structures</strong> from <string>Lino Rosa</string> &lt;lino.aguiar.rosa at gmail.com&gt;<p>December 23, 2015 at 04:00:00pm</p></header><div class="content"><p>Reassigning structures will create new ones. Mutating functions and<br>reassigning its properties won&#39;t: they mutate it.<br>On Wed, Dec 23, 2015 at 10:51 AM Ian Ynda-Hummel &lt;ianynda at gmail.com&gt; wrote:<br></p><p>&gt; I thought structures were immutable and mutating functions actually just<br>&gt; created new structures, thus maintaining the by value semantics.<br>&gt; On Wed, Dec 23, 2015 at 10:45 AM Lino Rosa via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; I believe the language would be improved by making structures immutable.<br>&gt;&gt;<br>&gt;&gt; 1) The choice between classes and structures isn’t clear right now. If<br>&gt;&gt; structures were immutable it would be natural to use them as value objects.<br>&gt;&gt;<br>&gt;&gt; 2) Refactoring a mutable structure into a class when it’s being passed<br>&gt;&gt; around multiple threads removes the by-value semantics seamlessly. The<br>&gt;&gt; resulting mutable class isn’t thread-safe.<br>&gt;&gt;<br>&gt;&gt; 2.1) Even when passed around a single thread, the resulting class would<br>&gt;&gt; be passed by reference, so any mutations would have unintended consequences.<br>&gt;&gt;<br>&gt;&gt; 3) We could probably remove some syntax: `mutating` keyword and variable<br>&gt;&gt; parameters. Also the `var` keyword before a structure could be used to<br>&gt;&gt; denote reassignment (not mutability), just as it does with classes.<br>&gt;&gt;<br>&gt;&gt; Of corse I might not be seeing the whole picture, so please weigh in.<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/58068f12/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bab03b11d4cd60804cf4a6ba68589430?s=50"></div><header><strong>Immutable Structures</strong> from <string>Kevin Lundberg</string> &lt;kevin at klundberg.com&gt;<p>December 23, 2015 at 11:00:00am</p></header><div class="content"><p>I believe Ian is correct in that changing any struct&#39;s value in any way creates a whole new struct.<br>See http://swiftstub.com/635749345 for proof (the didSet property observer fires every time a change happens to the struct).<br></p><p>&gt; On Dec 23, 2015, at 11:00 AM, Lino Rosa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Reassigning structures will create new ones. Mutating functions and reassigning its properties won&#39;t: they mutate it.<br>&gt; On Wed, Dec 23, 2015 at 10:51 AM Ian Ynda-Hummel &lt;ianynda at gmail.com &lt;mailto:ianynda at gmail.com&gt;&gt; wrote:<br>&gt; I thought structures were immutable and mutating functions actually just created new structures, thus maintaining the by value semantics.<br>&gt; On Wed, Dec 23, 2015 at 10:45 AM Lino Rosa via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; I believe the language would be improved by making structures immutable.<br>&gt; <br>&gt; 1) The choice between classes and structures isn’t clear right now. If structures were immutable it would be natural to use them as value objects.<br>&gt; <br>&gt; 2) Refactoring a mutable structure into a class when it’s being passed around multiple threads removes the by-value semantics seamlessly. The resulting mutable class isn’t thread-safe.<br>&gt; <br>&gt; 2.1) Even when passed around a single thread, the resulting class would be passed by reference, so any mutations would have unintended consequences.<br>&gt; <br>&gt; 3) We could probably remove some syntax: `mutating` keyword and variable parameters. Also the `var` keyword before a structure could be used to denote reassignment (not mutability), just as it does with classes.<br>&gt; <br>&gt; Of corse I might not be seeing the whole picture, so please weigh in.<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/f54cc6e2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Immutable Structures</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>December 23, 2015 at 11:00:00am</p></header><div class="content"><p>No, this is a consequence of structures being passed by value to property accessors. The getter doesn&#39;t return a reference to the frame, it returns a copy of it, so it is accompanied by a hidden set operation where it replaces the whole thing.<br></p><p>Félix<br></p><p>&gt; Le 23 déc. 2015 à 11:09:43, Kevin Lundberg via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; I believe Ian is correct in that changing any struct&#39;s value in any way creates a whole new struct.<br>&gt; See http://swiftstub.com/635749345 &lt;http://swiftstub.com/635749345&gt; for proof (the didSet property observer fires every time a change happens to the struct).<br>&gt; <br>&gt;&gt; On Dec 23, 2015, at 11:00 AM, Lino Rosa via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Reassigning structures will create new ones. Mutating functions and reassigning its properties won&#39;t: they mutate it.<br>&gt;&gt; On Wed, Dec 23, 2015 at 10:51 AM Ian Ynda-Hummel &lt;ianynda at gmail.com &lt;mailto:ianynda at gmail.com&gt;&gt; wrote:<br>&gt;&gt; I thought structures were immutable and mutating functions actually just created new structures, thus maintaining the by value semantics.<br>&gt;&gt; On Wed, Dec 23, 2015 at 10:45 AM Lino Rosa via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; I believe the language would be improved by making structures immutable.<br>&gt;&gt; <br>&gt;&gt; 1) The choice between classes and structures isn’t clear right now. If structures were immutable it would be natural to use them as value objects.<br>&gt;&gt; <br>&gt;&gt; 2) Refactoring a mutable structure into a class when it’s being passed around multiple threads removes the by-value semantics seamlessly. The resulting mutable class isn’t thread-safe.<br>&gt;&gt; <br>&gt;&gt; 2.1) Even when passed around a single thread, the resulting class would be passed by reference, so any mutations would have unintended consequences.<br>&gt;&gt; <br>&gt;&gt; 3) We could probably remove some syntax: `mutating` keyword and variable parameters. Also the `var` keyword before a structure could be used to denote reassignment (not mutability), just as it does with classes.<br>&gt;&gt; <br>&gt;&gt; Of corse I might not be seeing the whole picture, so please weigh in.<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/2fcd2e3b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>Immutable Structures</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>December 23, 2015 at 10:00:00am</p></header><div class="content"><p>Structs behave _as if_ they are immutable and every mutation creates a copy.<br></p><p>The compiler may — and usually does — optimize this away as a direct mutation. (And then there’s inout, which is tricky.)<br></p><p>It’s a brilliant model, and I believe a strong one as it stands. Lino, I believe this addresses your #1 and #3. I’m afraid I don’t follow your #2. Can you elaborate?<br></p><p>Cheers, P<br></p><p><br>&gt; On Dec 23, 2015, at 10:15 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; No, this is a consequence of structures being passed by value to property accessors. The getter doesn&#39;t return a reference to the frame, it returns a copy of it, so it is accompanied by a hidden set operation where it replaces the whole thing.<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 23 déc. 2015 à 11:09:43, Kevin Lundberg via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; I believe Ian is correct in that changing any struct&#39;s value in any way creates a whole new struct.<br>&gt;&gt; See http://swiftstub.com/635749345 &lt;http://swiftstub.com/635749345&gt; for proof (the didSet property observer fires every time a change happens to the struct).<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 23, 2015, at 11:00 AM, Lino Rosa via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Reassigning structures will create new ones. Mutating functions and reassigning its properties won&#39;t: they mutate it.<br>&gt;&gt;&gt; On Wed, Dec 23, 2015 at 10:51 AM Ian Ynda-Hummel &lt;ianynda at gmail.com &lt;mailto:ianynda at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; I thought structures were immutable and mutating functions actually just created new structures, thus maintaining the by value semantics.<br>&gt;&gt;&gt; On Wed, Dec 23, 2015 at 10:45 AM Lino Rosa via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; I believe the language would be improved by making structures immutable.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1) The choice between classes and structures isn’t clear right now. If structures were immutable it would be natural to use them as value objects.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2) Refactoring a mutable structure into a class when it’s being passed around multiple threads removes the by-value semantics seamlessly. The resulting mutable class isn’t thread-safe.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2.1) Even when passed around a single thread, the resulting class would be passed by reference, so any mutations would have unintended consequences.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 3) We could probably remove some syntax: `mutating` keyword and variable parameters. Also the `var` keyword before a structure could be used to denote reassignment (not mutability), just as it does with classes.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Of corse I might not be seeing the whole picture, so please weigh in.<br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/4d329ee2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/427280cb945b52af6e6717b44d417c6b?s=50"></div><header><strong>Immutable Structures</strong> from <string>Lino Rosa</string> &lt;lino.aguiar.rosa at gmail.com&gt;<p>December 23, 2015 at 04:00:00pm</p></header><div class="content"><p>Félix Cloutier*: *Yes immutable structures would look just like read-only<br>classes, but I don&#39;t think this makes the choice more ambiguous. The use of<br>structures could be encouraged whenever possible with a clear message: &quot;Is<br>it all immutable? Use structures then&quot;. Perhaps even be explicit on the<br>performance implications of stack storage. I believe the real problem is C<br>interop, and for that I have no arguments.<br></p><p>Paul Cantrell: Sure, example below. Changing `struct Position` into `class<br>Position` would still compile and print 30 instead.<br></p><p>==============================<br>struct Position {<br>  var x: Int<br>  var y: Int<br></p><p>  init(x: Int, y: Int) {<br>    self.x = x<br>    self.y = y<br>  }<br>}<br></p><p>func move(var position: Position) {<br>  position.x += 20<br>}<br></p><p>var p1 = Position(x: 10, y: 10)<br>move(p1)<br></p><p>print(p1.x) // prints 10<br>==============================<br></p><p>On Wed, Dec 23, 2015 at 11:24 AM Paul Cantrell &lt;cantrell at pobox.com&gt; wrote:<br></p><p>&gt; Structs behave _as if_ they are immutable and every mutation creates a<br>&gt; copy.<br>&gt;<br>&gt; The compiler may — and usually does — optimize this away as a direct<br>&gt; mutation. (And then there’s inout, which is tricky.)<br>&gt;<br>&gt; It’s a brilliant model, and I believe a strong one as it stands. Lino, I<br>&gt; believe this addresses your #1 and #3. I’m afraid I don’t follow your #2.<br>&gt; Can you elaborate?<br>&gt;<br>&gt; Cheers, P<br>&gt;<br>&gt;<br>&gt; On Dec 23, 2015, at 10:15 AM, Félix Cloutier via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; No, this is a consequence of structures being passed by value to property<br>&gt; accessors. The getter doesn&#39;t return a reference to the frame, it returns a<br>&gt; copy of it, so it is accompanied by a hidden set operation where it<br>&gt; replaces the whole thing.<br>&gt;<br>&gt; Félix<br>&gt;<br>&gt; Le 23 déc. 2015 à 11:09:43, Kevin Lundberg via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;<br>&gt; I believe Ian is correct in that changing any struct&#39;s value in any way<br>&gt; creates a whole new struct.<br>&gt; See http://swiftstub.com/635749345 for proof (the didSet property<br>&gt; observer fires every time a change happens to the struct).<br>&gt;<br>&gt; On Dec 23, 2015, at 11:00 AM, Lino Rosa via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Reassigning structures will create new ones. Mutating functions and<br>&gt; reassigning its properties won&#39;t: they mutate it.<br>&gt; On Wed, Dec 23, 2015 at 10:51 AM Ian Ynda-Hummel &lt;ianynda at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; I thought structures were immutable and mutating functions actually just<br>&gt;&gt; created new structures, thus maintaining the by value semantics.<br>&gt;&gt; On Wed, Dec 23, 2015 at 10:45 AM Lino Rosa via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; I believe the language would be improved by making structures immutable.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 1) The choice between classes and structures isn’t clear right now. If<br>&gt;&gt;&gt; structures were immutable it would be natural to use them as value objects.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 2) Refactoring a mutable structure into a class when it’s being passed<br>&gt;&gt;&gt; around multiple threads removes the by-value semantics seamlessly. The<br>&gt;&gt;&gt; resulting mutable class isn’t thread-safe.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 2.1) Even when passed around a single thread, the resulting class would<br>&gt;&gt;&gt; be passed by reference, so any mutations would have unintended consequences.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 3) We could probably remove some syntax: `mutating` keyword and variable<br>&gt;&gt;&gt; parameters. Also the `var` keyword before a structure could be used to<br>&gt;&gt;&gt; denote reassignment (not mutability), just as it does with classes.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Of corse I might not be seeing the whole picture, so please weigh in.<br>&gt;&gt;&gt;<br>&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/aee80c5d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>Immutable Structures</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>December 23, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 23, 2015, at 10:37 AM, Lino Rosa &lt;lino.aguiar.rosa at gmail.com&gt; wrote:<br>&gt; <br>&gt; Paul Cantrell: Sure, example below. Changing `struct Position` into `class Position` would still compile and print 30 instead. <br>&gt; <br>&gt; ==============================<br>&gt; struct Position {<br>&gt;   var x: Int<br>&gt;   var y: Int<br>&gt;   <br>&gt;   init(x: Int, y: Int) {<br>&gt;     self.x = x<br>&gt;     self.y = y<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; func move(var position: Position) {<br>&gt;   position.x += 20<br>&gt; }<br>&gt; <br>&gt; var p1 = Position(x: 10, y: 10)<br>&gt; move(p1)<br>&gt; <br>&gt; print(p1.x) // prints 10<br>&gt; ==============================<br></p><p>Ah, OK, sure … but why is this a problem? You changed the declaration! Of course it behaves differently. Changing a declaration can transparently change behavior in any number of circumstances. The following code still compiles if you change “Int” to “UInt8,” but it crashes:<br></p><p>    struct Position {<br>      var x: Int<br>      var y: Int<br>      <br>      init(x: Int, y: Int) {<br>        self.x = x<br>        self.y = y<br>      }<br>    }<br></p><p>    func move(var position: Position) {<br>      position.x += 200<br>    }<br></p><p>    var p1 = Position(x: 100, y: 100)<br>    move(p1)<br></p><p>    print(p1.x)<br></p><p>I could see this argument having some traction for protocol extensions, which can be attached to structs or classes with wildly different results. Protocols can limit themselves to classes only; can they limit themselves to structs as well? I don’t think so…. That could be a useful language change.<br></p><p>Cheers, P<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/b7435dd2/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>Immutable Structures</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>December 23, 2015 at 10:00:00am</p></header><div class="content"><p>I’m confused by your example below. Your move() function is equivalent to this:<br></p><p>func move(position: Position) {<br>    var copy = position<br>    copy.x += 20<br>}<br></p><p>Did you mean “var” there? (sidenote: var is being removed from the function call site)<br></p><p>Structs are immutable. It’s only with a var-declaration and a mutating function or it’s exposed properties, or the passing via inout, that structs appear to become immutable, but even that is a copy-on-write behavior. Like others have mentioned, the optimizer can remove this copy in many places for efficiency gains.<br></p><p>For instance, this is how you would change the incoming struct:<br></p><p>func move(inout position: Position) {<br>    position.x += 20<br>}<br></p><p>var p1 = Position(x: 10, y: 10)<br>move(&amp;p1)<br></p><p>This will print 30 both with struct or class.<br></p><p>&gt; 1) The choice between classes and structures isn’t clear right now. If structures were immutable it would be natural to use them as value objects.<br></p><p><br>If you have a value-type type and it supports equality, then a struct is the “right” choice. That’s the basic guideline. So anything you wish to treat as a value and have value-semantics (which is basically copy-on-write), use a struct. That seems like what you are saying, and that’s already the case.<br></p><p>&gt; 2) Refactoring a mutable structure into a class when it’s being passed around multiple threads removes the by-value semantics seamlessly. The resulting mutable class isn’t thread-safe.<br></p><p><br>Classes, by definition, remove value-semantics. I agree that this type of refactoring is inherently fragile, but I don’t see how having “immutable” structs changes this. <br></p><p>-David<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/73540c60/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/47e3aeeaf151d4f51ee15fc7871bf584?s=50"></div><header><strong>Immutable Structures</strong> from <string>Rudolf Adamkovič</string> &lt;salutis at me.com&gt;<p>December 23, 2015 at 10:00:00pm</p></header><div class="content"><p>BTW, structures are immutable yet they can have mutating functions.<br></p><p>I fully understand how this works as a language user but I wonder...<br></p><p>Isn’t there a better keyword (than “mutating”) that we could use here?<br></p><p>R+<br></p><p>&gt; On 23 Dec 2015, at 16:51, Ian Ynda-Hummel via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I thought structures were immutable and mutating functions actually just created new structures, thus maintaining the by value semantics.<br>&gt; On Wed, Dec 23, 2015 at 10:45 AM Lino Rosa via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; I believe the language would be improved by making structures immutable.<br>&gt; <br>&gt; 1) The choice between classes and structures isn’t clear right now. If structures were immutable it would be natural to use them as value objects.<br>&gt; <br>&gt; 2) Refactoring a mutable structure into a class when it’s being passed around multiple threads removes the by-value semantics seamlessly. The resulting mutable class isn’t thread-safe.<br>&gt; <br>&gt; 2.1) Even when passed around a single thread, the resulting class would be passed by reference, so any mutations would have unintended consequences.<br>&gt; <br>&gt; 3) We could probably remove some syntax: `mutating` keyword and variable parameters. Also the `var` keyword before a structure could be used to denote reassignment (not mutability), just as it does with classes.<br>&gt; <br>&gt; Of corse I might not be seeing the whole picture, so please weigh in.<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/e3169324/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Immutable Structures</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>December 23, 2015 at 11:00:00am</p></header><div class="content"><p>The current choice is that if you need pass-by-value semantics, you use a struct; if you need pass-by-reference semantics, you use a class. This is almost only relevant when structs are mutable: the only semantic difference between a struct and a class is that mutating a struct won&#39;t have an impact on the original. If structs were immutable, there would be absolutely no distinction between a struct and a read-only class. In my opinion, immutable structs would make the choice much more ambiguous than it is right now.<br></p><p>Changing this would have a major impact. Arrays, dictionaries, sets and strings are all pass-by-value right now. It would be a massively breaking change to make them plainly immutable or to make them reference types. It would also throw a wrench into C interop, which is critical for Swift to succeed in a non-ObjC environment (like Linux).<br></p><p>I personally don&#39;t see a problem with the current semantics and I don&#39;t like the impact, so I&#39;m not in favor of it.<br></p><p>Félix<br></p><p>&gt; Le 23 déc. 2015 à 10:44:49, Lino Rosa via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; I believe the language would be improved by making structures immutable.<br>&gt; <br>&gt; 1) The choice between classes and structures isn’t clear right now. If structures were immutable it would be natural to use them as value objects.<br>&gt; <br>&gt; 2) Refactoring a mutable structure into a class when it’s being passed around multiple threads removes the by-value semantics seamlessly. The resulting mutable class isn’t thread-safe.<br>&gt; <br>&gt; 2.1) Even when passed around a single thread, the resulting class would be passed by reference, so any mutations would have unintended consequences.<br>&gt; <br>&gt; 3) We could probably remove some syntax: `mutating` keyword and variable parameters. Also the `var` keyword before a structure could be used to denote reassignment (not mutability), just as it does with classes.<br>&gt; <br>&gt; Of corse I might not be seeing the whole picture, so please weigh in.<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/7163933b/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>Immutable Structures</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>December 23, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 23, 2015, at 7:44 AM, Lino Rosa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I believe the language would be improved by making structures immutable.<br>&gt; <br>&gt; 1) The choice between classes and structures isn’t clear right now. If structures were immutable it would be natural to use them as value objects.<br>&gt; <br>&gt; 2) Refactoring a mutable structure into a class when it’s being passed around multiple threads removes the by-value semantics seamlessly. The resulting mutable class isn’t thread-safe.<br>&gt; <br>&gt; 2.1) Even when passed around a single thread, the resulting class would be passed by reference, so any mutations would have unintended consequences.<br>&gt; <br>&gt; 3) We could probably remove some syntax: `mutating` keyword and variable parameters. Also the `var` keyword before a structure could be used to denote reassignment (not mutability), just as it does with classes.<br>&gt; <br>&gt; Of corse I might not be seeing the whole picture, so please weigh in.<br></p><p>Swift’s structures, enums, and standard library collections provide value semantics, which is far more useful than true immutability because it gives you immutability guaranteed when you want them (“let”) and efficient local mutation when you need it (“var”) . If you haven’t seen the “Building Better Apps with Value Types in Swift” talk from WWDC 2015, I suggest you check it out to get a sense of how value types work in Swift:<br></p><p>	https://developer.apple.com/videos/play/wwdc2015-414/<br></p><p>We’re very happy with value semantics as a programming model, so the likelihood of moving to a model where a value of struct type is always immutable is effectively zero. My hope is that the talk above—or other resources about value semantics in Swift—will convince you as thoroughly as it convinced us ;)<br></p><p>	- Doug<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Immutable Structures</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 23, 2015 at 05:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Dec 23, 2015, at 3:57 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 23, 2015, at 7:44 AM, Lino Rosa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I believe the language would be improved by making structures immutable.<br>&gt;&gt; <br>&gt;&gt; 1) The choice between classes and structures isn’t clear right now. If structures were immutable it would be natural to use them as value objects.<br>&gt;&gt; <br>&gt;&gt; 2) Refactoring a mutable structure into a class when it’s being passed around multiple threads removes the by-value semantics seamlessly. The resulting mutable class isn’t thread-safe.<br>&gt;&gt; <br>&gt;&gt; 2.1) Even when passed around a single thread, the resulting class would be passed by reference, so any mutations would have unintended consequences.<br>&gt;&gt; <br>&gt;&gt; 3) We could probably remove some syntax: `mutating` keyword and variable parameters. Also the `var` keyword before a structure could be used to denote reassignment (not mutability), just as it does with classes.<br>&gt;&gt; <br>&gt;&gt; Of corse I might not be seeing the whole picture, so please weigh in.<br>&gt; <br>&gt; Swift’s structures, enums, and standard library collections provide value semantics, which is far more useful than true immutability because it gives you immutability guaranteed when you want them (“let”) and efficient local mutation when you need it (“var”) . If you haven’t seen the “Building Better Apps with Value Types in Swift” talk from WWDC 2015, I suggest you check it out to get a sense of how value types work in Swift:<br>&gt; <br>&gt;    https://developer.apple.com/videos/play/wwdc2015-414/<br>&gt; <br>&gt; We’re very happy with value semantics as a programming model, so the likelihood of moving to a model where a value of struct type is always immutable is effectively zero. My hope is that the talk above—or other resources about value semantics in Swift—will convince you as thoroughly as it convinced us ;)<br></p><p>+1,000,000.  This is one of the best aspects of Swift IMO.<br></p><p><br>&gt; <br>&gt;    - Doug<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/427280cb945b52af6e6717b44d417c6b?s=50"></div><header><strong>Immutable Structures</strong> from <string>Lino Rosa</string> &lt;lino.aguiar.rosa at gmail.com&gt;<p>December 25, 2015 at 05:00:00pm</p></header><div class="content"><p>*Paul Cantrell:*<br></p><p>*&gt; “Ah, OK, sure … but why is this a problem? You changed the declaration!<br>Of course it behaves differently. Changing a declaration can transparently<br>change behavior in any number of circumstances. The following code still<br>compiles if you change “Int” to “UInt8,” but it crashes:”*<br></p><p>Good point, but I still think this is on a different class of problem<br>because  1) it’s really hard to track where we were relying on value<br>semantics before and adapt it to using classes and 2) the sort of bugs that<br>would creep out wouldn’t probably be crashes but weird side-effects<br>incredibly hard to track.<br></p><p>*David Owens II:*<br></p><p>&gt; *&quot;Did you mean “var” there? (sidenote: var is being removed from the<br>function call site)&quot;*<br></p><p>Yes I meant it, or it won’t compile. You’re right, they’re equivalent. Oh<br>the `var` is being deprecated there? Nice to know :)<br></p><p>&gt; *&quot;I agree that this type of refactoring is inherently fragile, but I<br>don’t see how having “immutable” structs changes this.&quot;*<br></p><p>It would solve it (although quite indirectly) because we couldn’t have had<br>code that mutated the structure before the said refactoring. In other<br>words, since we weren’t relying on the value semantics before (because of<br>immutability) then refactoring to classes wouldn’t be fragile.<br></p><p>*Rudolf Adamkovič:*<br></p><p>&gt; *&quot;Isn’t there a better keyword (than “mutating”) that we could use here?&quot;*<br></p><p>I don’t understand why we need the `mutating` keyword in the first place.<br>Is it for readability? Right now the compiler knows when a function mutates<br>a property and forces us to write `mutating`. Couldn’t it just fail<br>compiling when try to call a mutation function but we’re not allowed?<br></p><p>Douglas Gregor:<br></p><p>I realize there’s substantial personal opinion involved in this - and I’m<br>vastly outnumbered here :) Still, I’m replying with my thoughts after<br>watching your presentation. Maybe that clarifies some of my points and, who<br>knows, even increases my odds to 1%?<br></p><p>-- The temperature class example --<br>You make a point of how shared references sometimes result unintended<br>consequences. However, they’re only unintended because the fictional<br>developer in the example is using classes and expects value semantics.<br>Couldn’t one make the opposite argument, where the developer expected<br>reference semantics while using structures?<br></p><p>-- Immutability sometimes leads to awkward interfaces<br>This is the &quot;awkward&quot; version from the video:<br>`home.oven.temperature = Temperature(fahrenheit: temp.fahrenheit + 10.0)`<br></p><p>You could make it not awkward by implementing `+` and `-` in the global<br>scope so it adds numbers and `Temperature` together. This would bring it<br>back to:<br>`home.oven.temperature = temp + 10.0`. You already do it with strings: `let<br>foobar = &quot;Foo&quot; + &quot;Bar&quot;`.<br></p><p>By the way, structures as value types (arguably) create some awkwardness<br>and certainly add special cases to the language<br>1) `let`  and `var` aren’t just about reassignment anymore. It depends on<br>the context: for classes it’s still about reassignment; for structures it’s<br>about reassignment and mutability (well, also depending on whether the<br>properties of the structure are `let` or `var` themselves).<br>2) the `mutating` keyword on protocol extensions is only there for<br>structures and enums - and doesn’t even enforce them to actually mutate<br>anything.<br>3) the class specific protocol extensions.<br></p><p>-- Immutability does not map efficiently to the machine model --<br>Yes, but that’s only an issue if the language is 100% immutable.<br></p><p>-- Integers are value types --<br>Aren’t they also immutable?<br></p><p>-- Arrays are value types --<br>Why? I would honestly like to know. I think all languages I’ve used in the<br>past had arrays as reference types. Is it just because of equality?<br></p><p>-- CGPoints are value types --<br>Other than digging into the documentation, how can we tell it has value<br>semantics? We can’t just skim the code and understand it anymore - we have<br>to dig into class/structure definitions to figure out whether each thing is<br>a value or reference. And we’ll have to do it constantly because things<br>that work with structures would be disastrous for classes.<br></p><p>-- Freedom from race conditions --<br>Only accidental race conditions. Often memory is shared because it must be.<br>Those are the tricky ones to solve.<br></p><p>-- Reference types as properties of structures --<br>Why even allow it? Isn’t the whole point of structures to be used in small,<br>simple cases? Allowing reference types inside opens up a can of worms with<br>these “forReading/forWriting” methods…<br></p><p>Finally, thanks for the link to the video Douglas. I hope I didn’t sound<br>combative. It wasn’t my intention. Sadly I wasn&#39;t converted. Perhaps next<br>year? :)<br></p><p><br>On Wed, Dec 23, 2015 at 6:13 PM Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; &gt; On Dec 23, 2015, at 3:57 PM, Douglas Gregor via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On Dec 23, 2015, at 7:44 AM, Lino Rosa via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I believe the language would be improved by making structures immutable.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; 1) The choice between classes and structures isn’t clear right now. If<br>&gt; structures were immutable it would be natural to use them as value objects.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; 2) Refactoring a mutable structure into a class when it’s being passed<br>&gt; around multiple threads removes the by-value semantics seamlessly. The<br>&gt; resulting mutable class isn’t thread-safe.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; 2.1) Even when passed around a single thread, the resulting class would<br>&gt; be passed by reference, so any mutations would have unintended consequences.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; 3) We could probably remove some syntax: `mutating` keyword and<br>&gt; variable parameters. Also the `var` keyword before a structure could be<br>&gt; used to denote reassignment (not mutability), just as it does with classes.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Of corse I might not be seeing the whole picture, so please weigh in.<br>&gt; &gt;<br>&gt; &gt; Swift’s structures, enums, and standard library collections provide<br>&gt; value semantics, which is far more useful than true immutability because it<br>&gt; gives you immutability guaranteed when you want them (“let”) and efficient<br>&gt; local mutation when you need it (“var”) . If you haven’t seen the “Building<br>&gt; Better Apps with Value Types in Swift” talk from WWDC 2015, I suggest you<br>&gt; check it out to get a sense of how value types work in Swift:<br>&gt; &gt;<br>&gt; &gt;    https://developer.apple.com/videos/play/wwdc2015-414/<br>&gt; &gt;<br>&gt; &gt; We’re very happy with value semantics as a programming model, so the<br>&gt; likelihood of moving to a model where a value of struct type is always<br>&gt; immutable is effectively zero. My hope is that the talk above—or other<br>&gt; resources about value semantics in Swift—will convince you as thoroughly as<br>&gt; it convinced us ;)<br>&gt;<br>&gt; +1,000,000.  This is one of the best aspects of Swift IMO.<br>&gt;<br>&gt;<br>&gt; &gt;<br>&gt; &gt;    - Doug<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151225/2832295d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>Immutable Structures</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>December 25, 2015 at 11:00:00am</p></header><div class="content"><p>&gt;<br>&gt;<br>&gt;<br>&gt; I don’t understand why we need the `mutating` keyword in the first place.<br>&gt; Is it for readability? Right now the compiler knows when a function mutates<br>&gt; a property and forces us to write `mutating`. Couldn’t it just fail<br>&gt; compiling when try to call a mutation function but we’re not allowed?<br>&gt;<br>&gt;<br>I strongly disagree with this sentiment. I agree that the compiler can<br>figure it out without us in many cases but I appreciate knowing<br>*explicitly* which parts of an API will mutate a value. It is helpful for<br>both the vendor and consumer of the API to require that keyword.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151225/6690feb8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/427280cb945b52af6e6717b44d417c6b?s=50"></div><header><strong>Immutable Structures</strong> from <string>Lino Rosa</string> &lt;lino.aguiar.rosa at gmail.com&gt;<p>December 25, 2015 at 05:00:00pm</p></header><div class="content"><p>To me documentation plus the type signatures are generally enough. However<br>I could probably still agree with you if mutating was also used in classes.<br>What&#39;s the point of having it only on structures?<br>On Fri, Dec 25, 2015 at 12:32 T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br></p><p>&gt;<br>&gt;&gt;<br>&gt;&gt; I don’t understand why we need the `mutating` keyword in the first place.<br>&gt;&gt; Is it for readability? Right now the compiler knows when a function mutates<br>&gt;&gt; a property and forces us to write `mutating`. Couldn’t it just fail<br>&gt;&gt; compiling when try to call a mutation function but we’re not allowed?<br>&gt;&gt;<br>&gt;&gt;<br>&gt; I strongly disagree with this sentiment. I agree that the compiler can<br>&gt; figure it out without us in many cases but I appreciate knowing<br>&gt; *explicitly* which parts of an API will mutate a value. It is helpful for<br>&gt; both the vendor and consumer of the API to require that keyword.<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151225/3cca9439/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2969f67fc010e956c71442148f3f6fc0?s=50"></div><header><strong>Immutable Structures</strong> from <string>Wallacy</string> &lt;wallacyf at gmail.com&gt;<p>December 25, 2015 at 11:00:00pm</p></header><div class="content"><p>*&quot;To me documentation plus the type signatures are generally enough.<br>However I could probably still agree with you if mutating was also used in<br>classes. What&#39;s the point of having it only on structures?&quot;*<br></p><p>Because, structs ARE immutable by default. The mutating keyword says to<br>holding variable to copy-change and re-assign the value type. You never<br>notice the didSet called after mutation?<br></p><p>*&quot;By the way, structures as value types (arguably) create some awkwardness<br>and certainly add special cases to the language*<br>*1) `let`  and `var` aren’t just about reassignment anymore. It depends on<br>the context: for classes it’s still about reassignment; for structures it’s<br>about reassignment and mutability (well, also depending on whether the<br>properties of the structure are `let` or `var` themselves).*<br>*2) the `mutating` keyword on protocol extensions is only there for<br>structures and enums - and doesn’t even enforce them to actually mutate<br>anything.*<br>*3) the class specific protocol extensions.&quot;*<br></p><p>1) Its not true. Its just about the reassignment. But for value-types in<br>automatic the process of copy-change and assign.<br>2) because only value types need this keyword. And the problem of do not<br>enforce the mutation maybe can be a future improvement, it&#39;s not a big<br>deal, you can propose this adjustment.<br>3) what&#39;s the problem here?<br></p><p><br>*&quot;Good point, but I still think this is on a different class of problem<br>because  1) it’s really hard to track where we were relying on value<br>semantics before and adapt it to using classes and 2) the sort of bugs that<br>would creep out wouldn’t probably be crashes but weird side-effects<br>incredibly hard to track.&quot;*<br></p><p>Can you elaborate this? Does not appear a real world problem.<br>Change struct for class will always be a &quot;break change&quot;. Its not free of<br>bugs in any language.<br></p><p>*&quot;-- Integers are value types --*<br>*Aren’t they also immutable?&quot;*<br></p><p>yes....<br></p><p>*&quot;-- Arrays are value types --*<br>*Why? I would honestly like to know. I think all languages I’ve used in the<br>past had arrays as reference types. Is it just because of equality? *<br>*&quot;*<br></p><p>This ship sailed a long time ago.... This is a big feature in swift, on the<br>old swift forum may you can see the role discussion about that.<br></p><p>Value type arrays are something with I miss in other languages.<br></p><p>*&quot;-- CGPoints are value types --*<br>*Other than digging into the documentation, how can we tell it has value<br>semantics? We can’t just skim the code and understand it anymore - we have<br>to dig into class/structure definitions to figure out whether each thing is<br>a value or reference. And we’ll have to do it constantly because things<br>that work with structures would be disastrous for classes.&quot;*<br></p><p>hu?  Just check if the type is a struct or a enum! So will be a value type.<br>Whats the problem here?<br></p><p>*&quot;-- Freedom from race conditions --*<br>*Only accidental race conditions. Often memory is shared because it must<br>be. Those are the tricky ones to solve.*<br>*&quot;*<br></p><p>So, &quot;accidental&quot; are the name of most common bugs right? All bugs are<br>&quot;accidental&quot;.... The same argument you can use for avoid Optionals.<br></p><p>*&quot;-- Reference types as properties of structures --*<br>*Why even allow it? Isn’t the whole point of structures to be used in<br>small, simple cases? Allowing reference types inside opens up a can of<br>worms with these “forReading/forWriting” methods…*<br>*&quot;*<br></p><p>No, the whole point of structs are not to be used in small and simple<br>cases, not on Swift, in swift um Swift are first class citizen and can be<br>use for complex data structure, like Array and Strings. You can make a<br>private shared buffer behind the scenes.<br></p><p><br>&quot;Finally, thanks for the link to the video Douglas. I hope I didn’t sound<br>combative. It wasn’t my intention. Sadly I wasn&#39;t converted. Perhaps next<br>year? :)<br>&quot;<br></p><p>FWIW:<br>Try this one: https://developer.apple.com/videos/play/wwdc2015-408/ (<br>Protocol-Oriented<br>Programming in Swift )<br></p><p>It explains (too) why structs are so important in Swift. Spoiler: Because<br>its not a OO primary language.<br></p><p>Em sex, 25 de dez de 2015 às 15:47, Lino Rosa via swift-evolution &lt;<br>swift-evolution at swift.org&gt; escreveu:<br></p><p>&gt;<br>&gt; On Fri, Dec 25, 2015 at 12:32 T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I don’t understand why we need the `mutating` keyword in the first<br>&gt;&gt;&gt; place. Is it for readability? Right now the compiler knows when a function<br>&gt;&gt;&gt; mutates a property and forces us to write `mutating`. Couldn’t it just fail<br>&gt;&gt;&gt; compiling when try to call a mutation function but we’re not allowed?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt; I strongly disagree with this sentiment. I agree that the compiler can<br>&gt;&gt; figure it out without us in many cases but I appreciate knowing<br>&gt;&gt; *explicitly* which parts of an API will mutate a value. It is helpful for<br>&gt;&gt; both the vendor and consumer of the API to require that keyword.<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151225/7268d235/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Immutable Structures</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 25, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; However I could probably still agree with you if mutating was also used in classes. What&#39;s the point of having it only on structures?<br></p><p>In a regular method, `self` is a regular (constant) parameter, but in a `mutating` method, `self` is `inout` so that it can be mutated and those mutations will reach the caller&#39;s copy of the instance. There&#39;s no need for an `inout` `self` on reference types, because the mutations are performed on the shared instance which both the caller and callee have a reference to, so `mutating` only really makes sense for value types.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/427280cb945b52af6e6717b44d417c6b?s=50"></div><header><strong>Immutable Structures</strong> from <string>Lino Rosa</string> &lt;lino.aguiar.rosa at gmail.com&gt;<p>December 26, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; &quot;1) Its not true. Its just about the reassignment. But for value-types in<br>automatic the process of copy-change and assign.&quot;<br></p><p>I understand that, but semantically it sure looks like it&#39;s true. It&#39;s an<br>implementation detail, all about the copy-on-write optimization right? Why<br>should the developer have to know about that?<br></p><p>&gt; &quot;2) because only value types need this keyword&quot;<br>&gt; &quot;3) what&#39;s the problem here?&quot;<br></p><p>Consistency. Makes the language harder to explain. To me the `mutating`<br>keyword should either be used in classes as well or not used at all. Both<br>would simplify things. But this is running off-topic from the original post<br>though.<br></p><p>&gt; &quot;Can you elaborate this? Does not appear a real world problem.&quot;<br></p><p>Not a specific example, but every line like `something.a = &quot;anotherValue&quot;`<br>might or might not be relying on value semantics. After refactoring, the<br>developer would have no choice but to read every line with `something` and<br>judge whether value semantics was assumed or it was irrelevant. Really<br>error prone. Any mistake would result in unintended reference sharing, race<br>conditions etc. The actual bug might surface far from the originating issue.<br></p><p>&gt; &quot;hu?  Just check if the type is a struct or a enum! So will be a value<br>type. Whats the problem here?&quot;<br></p><p>Of course, but you&#39;d have to pause reading and jump to the definition each<br>time. And keep two mental models when structures and classes are used<br>together.<br></p><p>&gt; &quot;No, the whole point of structs are not to be used in small and simple<br>cases, not on Swift, in swift um Swift are first class citizen and can be<br>use for complex data structure, like Array and Strings. You can make a<br>private shared buffer behind the scenes.&quot;<br></p><p>It does certainly seem to be this way in practice. It was the impression I<br>got from Swift&#39;s official docs: &quot;*The structure’s primary purpose is to<br>encapsulate a few relatively simple data values.&quot;. *But now I realize it<br>talks about other possible use cases.<br></p><p>&gt; &quot;Try this one: https://developer.apple.com/videos/play/wwdc2015-408/ ( Protocol-Oriented<br>Programming in Swift )&quot;<br></p><p>I enjoyed this one, but it&#39;s about inheritance vs. protocols. He changes<br>classes to structures because he thinks it fits the model but he could have<br>kept classes and still proved his point that protocols are more powerful<br>and flexible.<br></p><p>I called my attention though, at around 25:20m he shows<br>`diagram.elements.append(diagram)` and says:* &quot;**Now, it took me a second<br>to realize why Drawing wasn&#39;t going into an infinite recursion at this<br>point&quot;*. That&#39;s kind of my point, these little surprises sprinkled around<br>the code.<br></p><p>Brent Royal-Gordon:<br></p><p>&gt; &quot;In a regular method, `self` is a regular (constant) parameter, but in a<br>`mutating` method, `self` is `inout` so that it can be mutated and those<br>mutations will reach the caller&#39;s copy of the instance. There&#39;s no need for<br>an `inout` `self` on reference types, because the mutations are performed<br>on the shared instance which both the caller and callee have a reference<br>to, so `mutating` only really makes sense for value types.&quot;<br></p><p>But the `mutating` keyword isn&#39;t really needed to make `self` work this way<br>for structures. It&#39;s actually not strictly needed at all. Another thing the<br>`mutating` keyword &quot;allows&quot; is for the method to be able to reassign<br>properties. I was advocating that `mutating` had only that meaning in order<br>to be more consistent. Then it would be equally useful for classes to make<br>APIs more clear with respect to mutation.<br></p><p><br>On Fri, Dec 25, 2015 at 7:16 PM Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>wrote:<br></p><p>&gt; &gt; However I could probably still agree with you if mutating was also used<br>&gt; in classes. What&#39;s the point of having it only on structures?<br>&gt;<br>&gt; In a regular method, `self` is a regular (constant) parameter, but in a<br>&gt; `mutating` method, `self` is `inout` so that it can be mutated and those<br>&gt; mutations will reach the caller&#39;s copy of the instance. There&#39;s no need for<br>&gt; an `inout` `self` on reference types, because the mutations are performed<br>&gt; on the shared instance which both the caller and callee have a reference<br>&gt; to, so `mutating` only really makes sense for value types.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151226/9eae652b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Immutable Structures</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>December 26, 2015 at 11:00:00am</p></header><div class="content"><p>If you&#39;re serious about your proposal, you need to come up with a realistic plan for phasing out the current struct semantics for everyone, in every use case that they have.<br></p><p>Félix<br></p><p>&gt; Le 26 déc. 2015 à 11:14:44, Lino Rosa via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; <br>&gt; &gt; &quot;1) Its not true. Its just about the reassignment. But for value-types in automatic the process of copy-change and assign.&quot;<br>&gt; <br>&gt; I understand that, but semantically it sure looks like it&#39;s true. It&#39;s an implementation detail, all about the copy-on-write optimization right? Why should the developer have to know about that?<br>&gt; <br>&gt; &gt; &quot;2) because only value types need this keyword&quot;<br>&gt; &gt; &quot;3) what&#39;s the problem here?&quot;<br>&gt; <br>&gt; Consistency. Makes the language harder to explain. To me the `mutating` keyword should either be used in classes as well or not used at all. Both would simplify things. But this is running off-topic from the original post though.<br>&gt; <br>&gt; &gt; &quot;Can you elaborate this? Does not appear a real world problem.&quot;<br>&gt; <br>&gt; Not a specific example, but every line like `something.a = &quot;anotherValue&quot;` might or might not be relying on value semantics. After refactoring, the developer would have no choice but to read every line with `something` and judge whether value semantics was assumed or it was irrelevant. Really error prone. Any mistake would result in unintended reference sharing, race conditions etc. The actual bug might surface far from the originating issue.<br>&gt; <br>&gt; &gt; &quot;hu?  Just check if the type is a struct or a enum! So will be a value type. Whats the problem here?&quot;<br>&gt; <br>&gt; Of course, but you&#39;d have to pause reading and jump to the definition each time. And keep two mental models when structures and classes are used together.<br>&gt; <br>&gt; &gt; &quot;No, the whole point of structs are not to be used in small and simple cases, not on Swift, in swift um Swift are first class citizen and can be use for complex data structure, like Array and Strings. You can make a private shared buffer behind the scenes.&quot;<br>&gt; <br>&gt; It does certainly seem to be this way in practice. It was the impression I got from Swift&#39;s official docs: &quot;The structure’s primary purpose is to encapsulate a few relatively simple data values.&quot;. But now I realize it talks about other possible use cases.<br>&gt; <br>&gt; &gt; &quot;Try this one: https://developer.apple.com/videos/play/wwdc2015-408/ &lt;https://developer.apple.com/videos/play/wwdc2015-408/&gt; ( Protocol-Oriented Programming in Swift )&quot;<br>&gt; <br>&gt; I enjoyed this one, but it&#39;s about inheritance vs. protocols. He changes classes to structures because he thinks it fits the model but he could have kept classes and still proved his point that protocols are more powerful and flexible. <br>&gt; <br>&gt; I called my attention though, at around 25:20m he shows `diagram.elements.append(diagram)` and says: &quot;Now, it took me a second to realize why Drawing wasn&#39;t going into an infinite recursion at this point&quot;. That&#39;s kind of my point, these little surprises sprinkled around the code.<br>&gt; <br>&gt; Brent Royal-Gordon:<br>&gt; <br>&gt; &gt; &quot;In a regular method, `self` is a regular (constant) parameter, but in a `mutating` method, `self` is `inout` so that it can be mutated and those mutations will reach the caller&#39;s copy of the instance. There&#39;s no need for an `inout` `self` on reference types, because the mutations are performed on the shared instance which both the caller and callee have a reference to, so `mutating` only really makes sense for value types.&quot;<br>&gt; <br>&gt; But the `mutating` keyword isn&#39;t really needed to make `self` work this way for structures. It&#39;s actually not strictly needed at all. Another thing the `mutating` keyword &quot;allows&quot; is for the method to be able to reassign properties. I was advocating that `mutating` had only that meaning in order to be more consistent. Then it would be equally useful for classes to make APIs more clear with respect to mutation.<br>&gt; <br>&gt; <br>&gt; On Fri, Dec 25, 2015 at 7:16 PM Brent Royal-Gordon &lt;brent at architechies.com &lt;mailto:brent at architechies.com&gt;&gt; wrote:<br>&gt; &gt; However I could probably still agree with you if mutating was also used in classes. What&#39;s the point of having it only on structures?<br>&gt; <br>&gt; In a regular method, `self` is a regular (constant) parameter, but in a `mutating` method, `self` is `inout` so that it can be mutated and those mutations will reach the caller&#39;s copy of the instance. There&#39;s no need for an `inout` `self` on reference types, because the mutations are performed on the shared instance which both the caller and callee have a reference to, so `mutating` only really makes sense for value types.<br>&gt; <br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151226/2c34639d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Immutable Structures</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>December 26, 2015 at 10:00:00am</p></header><div class="content"><p>Given that the Swift team has already said they aren&#39;t going to change the programming model, I don&#39;t think further conversation belongs on swift-evolution, to be honest.<br></p><p>Austin<br></p><p>&gt; On Dec 26, 2015, at 8:50 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; If you&#39;re serious about your proposal, you need to come up with a realistic plan for phasing out the current struct semantics for everyone, in every use case that they have.<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 26 déc. 2015 à 11:14:44, Lino Rosa via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; &gt; &quot;1) Its not true. Its just about the reassignment. But for value-types in automatic the process of copy-change and assign.&quot;<br>&gt;&gt; <br>&gt;&gt; I understand that, but semantically it sure looks like it&#39;s true. It&#39;s an implementation detail, all about the copy-on-write optimization right? Why should the developer have to know about that?<br>&gt;&gt; <br>&gt;&gt; &gt; &quot;2) because only value types need this keyword&quot;<br>&gt;&gt; &gt; &quot;3) what&#39;s the problem here?&quot;<br>&gt;&gt; <br>&gt;&gt; Consistency. Makes the language harder to explain. To me the `mutating` keyword should either be used in classes as well or not used at all. Both would simplify things. But this is running off-topic from the original post though.<br>&gt;&gt; <br>&gt;&gt; &gt; &quot;Can you elaborate this? Does not appear a real world problem.&quot;<br>&gt;&gt; <br>&gt;&gt; Not a specific example, but every line like `something.a = &quot;anotherValue&quot;` might or might not be relying on value semantics. After refactoring, the developer would have no choice but to read every line with `something` and judge whether value semantics was assumed or it was irrelevant. Really error prone. Any mistake would result in unintended reference sharing, race conditions etc. The actual bug might surface far from the originating issue.<br>&gt;&gt; <br>&gt;&gt; &gt; &quot;hu?  Just check if the type is a struct or a enum! So will be a value type. Whats the problem here?&quot;<br>&gt;&gt; <br>&gt;&gt; Of course, but you&#39;d have to pause reading and jump to the definition each time. And keep two mental models when structures and classes are used together.<br>&gt;&gt; <br>&gt;&gt; &gt; &quot;No, the whole point of structs are not to be used in small and simple cases, not on Swift, in swift um Swift are first class citizen and can be use for complex data structure, like Array and Strings. You can make a private shared buffer behind the scenes.&quot;<br>&gt;&gt; <br>&gt;&gt; It does certainly seem to be this way in practice. It was the impression I got from Swift&#39;s official docs: &quot;The structure’s primary purpose is to encapsulate a few relatively simple data values.&quot;. But now I realize it talks about other possible use cases.<br>&gt;&gt; <br>&gt;&gt; &gt; &quot;Try this one: https://developer.apple.com/videos/play/wwdc2015-408/ &lt;https://developer.apple.com/videos/play/wwdc2015-408/&gt; ( Protocol-Oriented Programming in Swift )&quot;<br>&gt;&gt; <br>&gt;&gt; I enjoyed this one, but it&#39;s about inheritance vs. protocols. He changes classes to structures because he thinks it fits the model but he could have kept classes and still proved his point that protocols are more powerful and flexible. <br>&gt;&gt; <br>&gt;&gt; I called my attention though, at around 25:20m he shows `diagram.elements.append(diagram)` and says: &quot;Now, it took me a second to realize why Drawing wasn&#39;t going into an infinite recursion at this point&quot;. That&#39;s kind of my point, these little surprises sprinkled around the code.<br>&gt;&gt; <br>&gt;&gt; Brent Royal-Gordon:<br>&gt;&gt; <br>&gt;&gt; &gt; &quot;In a regular method, `self` is a regular (constant) parameter, but in a `mutating` method, `self` is `inout` so that it can be mutated and those mutations will reach the caller&#39;s copy of the instance. There&#39;s no need for an `inout` `self` on reference types, because the mutations are performed on the shared instance which both the caller and callee have a reference to, so `mutating` only really makes sense for value types.&quot;<br>&gt;&gt; <br>&gt;&gt; But the `mutating` keyword isn&#39;t really needed to make `self` work this way for structures. It&#39;s actually not strictly needed at all. Another thing the `mutating` keyword &quot;allows&quot; is for the method to be able to reassign properties. I was advocating that `mutating` had only that meaning in order to be more consistent. Then it would be equally useful for classes to make APIs more clear with respect to mutation.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Fri, Dec 25, 2015 at 7:16 PM Brent Royal-Gordon &lt;brent at architechies.com &lt;mailto:brent at architechies.com&gt;&gt; wrote:<br>&gt;&gt; &gt; However I could probably still agree with you if mutating was also used in classes. What&#39;s the point of having it only on structures?<br>&gt;&gt; <br>&gt;&gt; In a regular method, `self` is a regular (constant) parameter, but in a `mutating` method, `self` is `inout` so that it can be mutated and those mutations will reach the caller&#39;s copy of the instance. There&#39;s no need for an `inout` `self` on reference types, because the mutations are performed on the shared instance which both the caller and callee have a reference to, so `mutating` only really makes sense for value types.<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151226/359bb6de/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Immutable Structures</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 26, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt; &gt; &quot;In a regular method, `self` is a regular (constant) parameter, but in a `mutating` method, `self` is `inout` so that it can be mutated and those mutations will reach the caller&#39;s copy of the instance. There&#39;s no need for an `inout` `self` on reference types, because the mutations are performed on the shared instance which both the caller and callee have a reference to, so `mutating` only really makes sense for value types.&quot;<br>&gt; <br>&gt; But the `mutating` keyword isn&#39;t really needed to make `self` work this way for structures. It&#39;s actually not strictly needed at all. Another thing the `mutating` keyword &quot;allows&quot; is for the method to be able to reassign properties. I was advocating that `mutating` had only that meaning in order to be more consistent. Then it would be equally useful for classes to make APIs more clear with respect to mutation.<br></p><p>I don&#39;t think you quite understand what I&#39;m saying. You can mutate properties in a `mutating` method *because* `self` is an `inout` parameter in a mutating method. That&#39;s how mutating the properties is implemented.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
