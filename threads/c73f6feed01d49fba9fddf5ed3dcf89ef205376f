<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1d54deb32312ab6a282cde8637bc7077?s=50"></div><header><strong>NSTask and try!</strong> from <string>James Lee</string> &lt;james at jelee.co.uk&gt;<p>May 13, 2016 at 08:00:00pm</p></header><div class="content"><p>Following on from a previous discussion with Tests failing on OSX. I <br>have been looking into the failures. It seems that one of the earliest <br>failures is due to an error from a try! within NSTask.launch(). This <br>came in with this commit: <br>https://github.com/apple/swift-corelibs-foundation/commit/4c6f04cfcad3d4b06688558021595d06751fc66a<br></p><p>Going by the docs for Foundation - The launch function apparently <br>&quot;Raises an NSInvalidArgumentException if the launch path has not been <br>set or is invalid or if it fails to create a process.&quot;<br></p><p>https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSTask_Class/#//apple_ref/occ/instm/NSTask/launch<br></p><p>My question is, should this be built into the Swift Foundation API? The <br>documentation for Swift doesn&#39;t state that the launch function throws.<br></p><p>With the test that is failing expecting an error, it feels more Swift-y <br>to have any errors throw explicitly, rather than looking at what the <br>lower level fills the data with.<br></p><p>But before jumping into doing this, I would rather put it out there and <br>see what the community feels about this?<br></p><p>Cheers<br></p><p>James<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be4c3c3b76631a155e1358db48066692?s=50"></div><header><strong>NSTask and try!</strong> from <string>Tony Parker</string> &lt;anthony.parker at apple.com&gt;<p>May 13, 2016 at 12:00:00pm</p></header><div class="content"><p>Hi James,<br></p><p>&gt; On May 13, 2016, at 12:25 PM, James Lee via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Following on from a previous discussion with Tests failing on OSX. I have been looking into the failures. It seems that one of the earliest failures is due to an error from a try! within NSTask.launch(). This came in with this commit: https://github.com/apple/swift-corelibs-foundation/commit/4c6f04cfcad3d4b06688558021595d06751fc66a<br>&gt; <br>&gt; Going by the docs for Foundation - The launch function apparently &quot;Raises an NSInvalidArgumentException if the launch path has not been set or is invalid or if it fails to create a process.&quot;<br>&gt; <br>&gt; https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSTask_Class/#//apple_ref/occ/instm/NSTask/launch<br>&gt; <br>&gt; My question is, should this be built into the Swift Foundation API? The documentation for Swift doesn&#39;t state that the launch function throws.<br>&gt; <br>&gt; With the test that is failing expecting an error, it feels more Swift-y to have any errors throw explicitly, rather than looking at what the lower level fills the data with.<br>&gt; <br>&gt; But before jumping into doing this, I would rather put it out there and see what the community feels about this?<br>&gt; <br></p><p>Unfortunately the ‘throws’ syntax in Swift often causes a mixup between two different things, because it flipped the terminology from what all of our documentation and header comments use.<br></p><p>1. Cocoa uses exceptions (@throw in ObjC) to indicate programmer errors and they are generally not intended to be recoverable.  Example: passing nil where not expected, passing an invalid argument, failing to meet a precondition of an API.<br>2. Cocoa uses NSError ** to indicate runtime errors that are recoverable or at least presentable to user. Example: out of disk space, name of file already exists.<br></p><p>The ‘throws’ syntax in Swift is actually for case #2, not #1. In Swift, #1 is fatalError or preconditionFailure. #2 is ‘throw Error’.<br></p><p>In the case of NSTask, when the documentation says “raises an NSInvalidArgumentException” (#1) then in Swift, that should translate to fatalError or preconditionFailure.<br></p><p>Hope this helps,<br>- Tony<br></p><p>&gt; Cheers<br>&gt; <br>&gt; James<br>&gt; _______________________________________________<br>&gt; swift-corelibs-dev mailing list<br>&gt; swift-corelibs-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1d54deb32312ab6a282cde8637bc7077?s=50"></div><header><strong>NSTask and try!</strong> from <string>James Lee</string> &lt;james at jelee.co.uk&gt;<p>May 13, 2016 at 09:00:00pm</p></header><div class="content"><p>Cheers for the clarification. I started assuming there may be a reason when changing the guard let on the launch args to use the InvalidArgumentException.<br></p><p>Could this be a position where we may need os checking to cover the regression for the moment. It seems odd that the test would pass in CI when an error is thrown with a try! but fail on OSX<br></p><p>Sent from my iPhone<br></p><p>&gt; On 13 May 2016, at 20:48, Tony Parker &lt;anthony.parker at apple.com&gt; wrote:<br>&gt; <br>&gt; Hi James,<br>&gt; <br>&gt;&gt; On May 13, 2016, at 12:25 PM, James Lee via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Following on from a previous discussion with Tests failing on OSX. I have been looking into the failures. It seems that one of the earliest failures is due to an error from a try! within NSTask.launch(). This came in with this commit: https://github.com/apple/swift-corelibs-foundation/commit/4c6f04cfcad3d4b06688558021595d06751fc66a<br>&gt;&gt; <br>&gt;&gt; Going by the docs for Foundation - The launch function apparently &quot;Raises an NSInvalidArgumentException if the launch path has not been set or is invalid or if it fails to create a process.&quot;<br>&gt;&gt; <br>&gt;&gt; https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSTask_Class/#//apple_ref/occ/instm/NSTask/launch<br>&gt;&gt; <br>&gt;&gt; My question is, should this be built into the Swift Foundation API? The documentation for Swift doesn&#39;t state that the launch function throws.<br>&gt;&gt; <br>&gt;&gt; With the test that is failing expecting an error, it feels more Swift-y to have any errors throw explicitly, rather than looking at what the lower level fills the data with.<br>&gt;&gt; <br>&gt;&gt; But before jumping into doing this, I would rather put it out there and see what the community feels about this?<br>&gt; <br>&gt; Unfortunately the ‘throws’ syntax in Swift often causes a mixup between two different things, because it flipped the terminology from what all of our documentation and header comments use.<br>&gt; <br>&gt; 1. Cocoa uses exceptions (@throw in ObjC) to indicate programmer errors and they are generally not intended to be recoverable.  Example: passing nil where not expected, passing an invalid argument, failing to meet a precondition of an API.<br>&gt; 2. Cocoa uses NSError ** to indicate runtime errors that are recoverable or at least presentable to user. Example: out of disk space, name of file already exists.<br>&gt; <br>&gt; The ‘throws’ syntax in Swift is actually for case #2, not #1. In Swift, #1 is fatalError or preconditionFailure. #2 is ‘throw Error’.<br>&gt; <br>&gt; In the case of NSTask, when the documentation says “raises an NSInvalidArgumentException” (#1) then in Swift, that should translate to fatalError or preconditionFailure.<br>&gt; <br>&gt; Hope this helps,<br>&gt; - Tony<br>&gt; <br>&gt;&gt; Cheers<br>&gt;&gt; <br>&gt;&gt; James<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-corelibs-dev mailing list<br>&gt;&gt; swift-corelibs-dev at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be4c3c3b76631a155e1358db48066692?s=50"></div><header><strong>NSTask and try!</strong> from <string>Tony Parker</string> &lt;anthony.parker at apple.com&gt;<p>May 13, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On May 13, 2016, at 1:05 PM, James Lee &lt;james at jelee.co.uk&gt; wrote:<br>&gt; <br>&gt; Cheers for the clarification. I started assuming there may be a reason when changing the guard let on the launch args to use the InvalidArgumentException.<br>&gt; <br>&gt; Could this be a position where we may need os checking to cover the regression for the moment. It seems odd that the test would pass in CI when an error is thrown with a try! but fail on OSX<br>&gt; <br></p><p>Task is certainly one of the cases where the underlying stuff that we’re abstracting is significantly different, so I’m not too surprised.<br></p><p>We should try to get something in place so we’re not failing on OS X in the short term for sure.<br></p><p>- Tony<br></p><p>&gt; Sent from my iPhone<br>&gt; <br>&gt;&gt; On 13 May 2016, at 20:48, Tony Parker &lt;anthony.parker at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi James,<br>&gt;&gt; <br>&gt;&gt;&gt; On May 13, 2016, at 12:25 PM, James Lee via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Following on from a previous discussion with Tests failing on OSX. I have been looking into the failures. It seems that one of the earliest failures is due to an error from a try! within NSTask.launch(). This came in with this commit: https://github.com/apple/swift-corelibs-foundation/commit/4c6f04cfcad3d4b06688558021595d06751fc66a<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Going by the docs for Foundation - The launch function apparently &quot;Raises an NSInvalidArgumentException if the launch path has not been set or is invalid or if it fails to create a process.&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSTask_Class/#//apple_ref/occ/instm/NSTask/launch<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My question is, should this be built into the Swift Foundation API? The documentation for Swift doesn&#39;t state that the launch function throws.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; With the test that is failing expecting an error, it feels more Swift-y to have any errors throw explicitly, rather than looking at what the lower level fills the data with.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But before jumping into doing this, I would rather put it out there and see what the community feels about this?<br>&gt;&gt; <br>&gt;&gt; Unfortunately the ‘throws’ syntax in Swift often causes a mixup between two different things, because it flipped the terminology from what all of our documentation and header comments use.<br>&gt;&gt; <br>&gt;&gt; 1. Cocoa uses exceptions (@throw in ObjC) to indicate programmer errors and they are generally not intended to be recoverable.  Example: passing nil where not expected, passing an invalid argument, failing to meet a precondition of an API.<br>&gt;&gt; 2. Cocoa uses NSError ** to indicate runtime errors that are recoverable or at least presentable to user. Example: out of disk space, name of file already exists.<br>&gt;&gt; <br>&gt;&gt; The ‘throws’ syntax in Swift is actually for case #2, not #1. In Swift, #1 is fatalError or preconditionFailure. #2 is ‘throw Error’.<br>&gt;&gt; <br>&gt;&gt; In the case of NSTask, when the documentation says “raises an NSInvalidArgumentException” (#1) then in Swift, that should translate to fatalError or preconditionFailure.<br>&gt;&gt; <br>&gt;&gt; Hope this helps,<br>&gt;&gt; - Tony<br>&gt;&gt; <br>&gt;&gt;&gt; Cheers<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; James<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-corelibs-dev mailing list<br>&gt;&gt;&gt; swift-corelibs-dev at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev<br>&gt;&gt; <br>&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
