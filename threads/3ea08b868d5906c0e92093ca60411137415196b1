<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>statically link the standard library on Linux</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>February 13, 2016 at 09:00:00pm</p></header><div class="content"><p>Whenever I update the installed Linux snapshot, my binaries break, with errors of the form:<br></p><p>[programname]: symbol lookup error: [programname]: undefined symbol: _TFOs7Processau9argumentsGSaSS_<br></p><p>I assume this is the standard library symbol Process.arguments (which is used in my program).<br></p><p>I guess this is because the standard library is not statically linked/embedded in this executable.  This happens by default on OSX, but I guess might not on Linux.<br></p><p>Is that a bug?<br>Is there a way to force statically link the standard library on Linux, so my binaries work without a recompile each new snapshot?<br></p><p><br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160213/3ea096b1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9f392a0dd25cf868afcfcdd1f3b812f2?s=50"></div><header><strong>statically link the standard library on Linux</strong> from <string>Trussell, Brandon</string> &lt;Brandon.Trussell at disney.com&gt;<p>February 14, 2016 at 09:00:00pm</p></header><div class="content"><p>AFAIK, the ABI isn’t stable, and therefore whenever a binary is compiled all of its dependencies must also be re-compiled.<br></p><p>- Brandon<br></p><p><br>From: &lt;swift-users-bounces at swift.org&lt;mailto:swift-users-bounces at swift.org&gt;&gt; on behalf of Drew Crawford via swift-users &lt;swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&gt;<br>Reply-To: Drew Crawford &lt;drew at sealedabstract.com&lt;mailto:drew at sealedabstract.com&gt;&gt;<br>Date: Saturday, February 13, 2016 at 7:54 PM<br>To: &quot;swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&quot; &lt;swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&gt;<br>Subject: [swift-users] statically link the standard library on Linux<br></p><p>Whenever I update the installed Linux snapshot, my binaries break, with errors of the form:<br></p><p>[programname]: symbol lookup error: [programname]: undefined symbol: _TFOs7Processau9argumentsGSaSS_<br></p><p>I assume this is the standard library symbol Process.arguments (which is used in my program).<br></p><p>I guess this is because the standard library is not statically linked/embedded in this executable.  This happens by default on OSX, but I guess might not on Linux.<br></p><p><br>  *   Is that a bug?<br>  *   Is there a way to force statically link the standard library on Linux, so my binaries work without a recompile each new snapshot?<br></p><p><br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160214/dd24abf7/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ae51ca494b37cc270597830da66f089f?s=50"></div><header><strong>statically link the standard library on Linux</strong> from <string>Max Howell</string> &lt;max.howell at apple.com&gt;<p>February 17, 2016 at 11:00:00am</p></header><div class="content"><p>We have a ticket open to implement static linking of swift libs.<br></p><p>If anyone on the Swift team knows how to do this and can comment here then I’m sure we can get it implemented pretty quickly.<br></p><p>&gt; On Feb 13, 2016, at 7:54 PM, Drew Crawford via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Whenever I update the installed Linux snapshot, my binaries break, with errors of the form:<br>&gt; <br>&gt; [programname]: symbol lookup error: [programname]: undefined symbol: _TFOs7Processau9argumentsGSaSS_<br>&gt; <br>&gt; I assume this is the standard library symbol Process.arguments (which is used in my program).<br>&gt; <br>&gt; I guess this is because the standard library is not statically linked/embedded in this executable.  This happens by default on OSX, but I guess might not on Linux.<br>&gt; <br>&gt; Is that a bug?<br>&gt; Is there a way to force statically link the standard library on Linux, so my binaries work without a recompile each new snapshot?<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160217/6b0153b6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>statically link the standard library on Linux</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>February 17, 2016 at 02:00:00pm</p></header><div class="content"><p>I traced this down to the sourcecode after I posted here: https://bugs.swift.org/browse/SR-730 &lt;https://bugs.swift.org/browse/SR-730&gt;<br></p><p>tll;dr the standard library is forcibly dynamically-linked on Linux, and we need a way to opt out of that from the swift frontend.  I have not gone further with that since A) my C++-foo is not very excellent and B) core hasn&#39;t blessed any particular solution I proffered in that thread.  If you can make progress there I would be grateful.<br></p><p>Then it is just a matter of getting the flags right; in practice, OSX wants -L path/to/swift_static -lc++ -framework Foundation -Xlinker -force_load_swift_libs, whereas Linux wants (I believe) -licuuc -licu18n -lbsd /path/to/swift_static/a.a /path/to/swift_static/b.a /path/to/swift_static/c.a ...  There may be an equivalent to force_load_swift_libs that knows what libs to load, but I haven&#39;t found it yet.<br></p><p>However as long as the Swift frontend forcibly injects the dynamic link we are SOL, so some progress needs to be made in the frontend first.<br></p><p><br></p><p><br>&gt; On Feb 17, 2016, at 1:37 PM, Max Howell &lt;max.howell at apple.com&gt; wrote:<br>&gt; <br>&gt; We have a ticket open to implement static linking of swift libs.<br>&gt; <br>&gt; If anyone on the Swift team knows how to do this and can comment here then I’m sure we can get it implemented pretty quickly.<br>&gt; <br>&gt;&gt; On Feb 13, 2016, at 7:54 PM, Drew Crawford via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Whenever I update the installed Linux snapshot, my binaries break, with errors of the form:<br>&gt;&gt; <br>&gt;&gt; [programname]: symbol lookup error: [programname]: undefined symbol: _TFOs7Processau9argumentsGSaSS_<br>&gt;&gt; <br>&gt;&gt; I assume this is the standard library symbol Process.arguments (which is used in my program).<br>&gt;&gt; <br>&gt;&gt; I guess this is because the standard library is not statically linked/embedded in this executable.  This happens by default on OSX, but I guess might not on Linux.<br>&gt;&gt; <br>&gt;&gt; Is that a bug?<br>&gt;&gt; Is there a way to force statically link the standard library on Linux, so my binaries work without a recompile each new snapshot?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160217/1480fa6d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>statically link the standard library on Linux</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>February 17, 2016 at 01:00:00pm</p></header><div class="content"><p>On Wed, Feb 17, 2016 at 12:40 PM, Drew Crawford via swift-users<br>&lt;swift-users at swift.org&gt; wrote:<br>&gt; I traced this down to the sourcecode after I posted here:<br>&gt; https://bugs.swift.org/browse/SR-730<br>&gt;<br>&gt; tll;dr the standard library is forcibly dynamically-linked on Linux, and we<br>&gt; need a way to opt out of that from the swift frontend.  I have not gone<br>&gt; further with that since A) my C++-foo is not very excellent and B) core<br>&gt; hasn&#39;t blessed any particular solution I proffered in that thread.  If you<br>&gt; can make progress there I would be grateful.<br>&gt;<br>&gt; Then it is just a matter of getting the flags right; in practice, OSX wants<br>&gt; -L path/to/swift_static -lc++ -framework Foundation -Xlinker<br>&gt; -force_load_swift_libs, whereas Linux wants (I believe) -licuuc -licu18n<br>&gt; -lbsd /path/to/swift_static/a.a /path/to/swift_static/b.a<br>&gt; /path/to/swift_static/c.a ...  There may be an equivalent to<br>&gt; force_load_swift_libs that knows what libs to load, but I haven&#39;t found it<br>&gt; yet.<br></p><p>We also want to move to using swift_begin.o and swift_end.o files<br>instead of the linker script.  With these files, it is *critical* that<br>they are added at the very beginning and at the very end of the<br>command line, otherwise one is guaranteed to get a subtle silent<br>miscompile.<br></p><p>I think we need to add a user-friendly driver-level flag for static<br>linking, that allows to decide on per-library basis.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>statically link the standard library on Linux</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February 19, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Feb 17, 2016, at 11:37 AM, Max Howell via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; We have a ticket open to implement static linking of swift libs.<br>&gt; <br>&gt; If anyone on the Swift team knows how to do this and can comment here then I’m sure we can get it implemented pretty quickly.<br></p><p>Static vs dynamic building of libraries may also have an interesting impact on the build system, particularly in how we set visibility for emitted symbols. For executables and dylibs, our current mapping of access control to visibility and linkage makes sense:<br></p><p>- public has default visibility,<br>- internal has hidden visibility (__attribute__((visibility(&quot;hidden&quot;))) in Clang),<br>- private has private linkage (like &#39;static&#39; in C).<br></p><p>However, when statically linking a library into another executable or dylib, the static library&#39;s public symbols in most cases probably ought to become hidden in the final target, unless the dylib or executable explicitly reexports the static library&#39;s module somehow.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ae51ca494b37cc270597830da66f089f?s=50"></div><header><strong>statically link the standard library on Linux</strong> from <string>Max Howell</string> &lt;max.howell at apple.com&gt;<p>February 19, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt;&gt; We have a ticket open to implement static linking of swift libs.<br>&gt;&gt; <br>&gt;&gt; If anyone on the Swift team knows how to do this and can comment here then I’m sure we can get it implemented pretty quickly.<br>&gt; <br>&gt; Static vs dynamic building of libraries may also have an interesting impact on the build system, particularly in how we set visibility for emitted symbols. For executables and dylibs, our current mapping of access control to visibility and linkage makes sense:<br>&gt; <br>&gt; - public has default visibility,<br>&gt; - internal has hidden visibility (__attribute__((visibility(&quot;hidden&quot;))) in Clang),<br>&gt; - private has private linkage (like &#39;static&#39; in C).<br>&gt; <br>&gt; However, when statically linking a library into another executable or dylib, the static library&#39;s public symbols in most cases probably ought to become hidden in the final target, unless the dylib or executable explicitly reexports the static library&#39;s module somehow.<br></p><p>I’ve worried about such things, but my conclusions were there weren’t any practically compelling reasons to worry about it too much.<br></p><p>My reasoning being: when writing a Swift file the compiler won’t give you access to those symbols unless you `import` that module, in which case you want them.<br></p><p>Unless there is something I’m missing?<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>statically link the standard library on Linux</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February 19, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Feb 19, 2016, at 12:37 PM, Max Howell &lt;max.howell at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; We have a ticket open to implement static linking of swift libs.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If anyone on the Swift team knows how to do this and can comment here then I’m sure we can get it implemented pretty quickly.<br>&gt;&gt; <br>&gt;&gt; Static vs dynamic building of libraries may also have an interesting impact on the build system, particularly in how we set visibility for emitted symbols. For executables and dylibs, our current mapping of access control to visibility and linkage makes sense:<br>&gt;&gt; <br>&gt;&gt; - public has default visibility,<br>&gt;&gt; - internal has hidden visibility (__attribute__((visibility(&quot;hidden&quot;))) in Clang),<br>&gt;&gt; - private has private linkage (like &#39;static&#39; in C).<br>&gt;&gt; <br>&gt;&gt; However, when statically linking a library into another executable or dylib, the static library&#39;s public symbols in most cases probably ought to become hidden in the final target, unless the dylib or executable explicitly reexports the static library&#39;s module somehow.<br>&gt; <br>&gt; I’ve worried about such things, but my conclusions were there weren’t any practically compelling reasons to worry about it too much.<br>&gt; <br>&gt; My reasoning being: when writing a Swift file the compiler won’t give you access to those symbols unless you `import` that module, in which case you want them.<br>&gt; <br>&gt; Unless there is something I’m missing?<br></p><p>Maybe not huge problems, but it&#39;s a secrecy violation and unwanted ABI liability, and also limits LTO-level optimization opportunities since exported functions have to preserve their existence and calling convention.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ae51ca494b37cc270597830da66f089f?s=50"></div><header><strong>statically link the standard library on Linux</strong> from <string>Max Howell</string> &lt;max.howell at apple.com&gt;<p>February 19, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt;&gt;&gt; Static vs dynamic building of libraries may also have an interesting impact on the build system, particularly in how we set visibility for emitted symbols. For executables and dylibs, our current mapping of access control to visibility and linkage makes sense:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - public has default visibility,<br>&gt;&gt;&gt; - internal has hidden visibility (__attribute__((visibility(&quot;hidden&quot;))) in Clang),<br>&gt;&gt;&gt; - private has private linkage (like &#39;static&#39; in C).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; However, when statically linking a library into another executable or dylib, the static library&#39;s public symbols in most cases probably ought to become hidden in the final target, unless the dylib or executable explicitly reexports the static library&#39;s module somehow.<br>&gt;&gt; <br>&gt;&gt; I’ve worried about such things, but my conclusions were there weren’t any practically compelling reasons to worry about it too much.<br>&gt;&gt; <br>&gt;&gt; My reasoning being: when writing a Swift file the compiler won’t give you access to those symbols unless you `import` that module, in which case you want them.<br>&gt;&gt; <br>&gt;&gt; Unless there is something I’m missing?<br>&gt; <br>&gt; Maybe not huge problems, but it&#39;s a secrecy violation and unwanted ABI liability, and also limits LTO-level optimization opportunities since exported functions have to preserve their existence and calling convention.<br></p><p>Makes sense, can we solve it? Our current direction is certainly one of: stuff all the (library) modules into a single linkage unit, be that a single dylib, a static library or a framework.<br></p><p>Max<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>statically link the standard library on Linux</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February 19, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Feb 19, 2016, at 1:06 PM, Max Howell &lt;max.howell at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt;&gt; Static vs dynamic building of libraries may also have an interesting impact on the build system, particularly in how we set visibility for emitted symbols. For executables and dylibs, our current mapping of access control to visibility and linkage makes sense:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - public has default visibility,<br>&gt;&gt;&gt;&gt; - internal has hidden visibility (__attribute__((visibility(&quot;hidden&quot;))) in Clang),<br>&gt;&gt;&gt;&gt; - private has private linkage (like &#39;static&#39; in C).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; However, when statically linking a library into another executable or dylib, the static library&#39;s public symbols in most cases probably ought to become hidden in the final target, unless the dylib or executable explicitly reexports the static library&#39;s module somehow.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’ve worried about such things, but my conclusions were there weren’t any practically compelling reasons to worry about it too much.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My reasoning being: when writing a Swift file the compiler won’t give you access to those symbols unless you `import` that module, in which case you want them.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Unless there is something I’m missing?<br>&gt;&gt; <br>&gt;&gt; Maybe not huge problems, but it&#39;s a secrecy violation and unwanted ABI liability, and also limits LTO-level optimization opportunities since exported functions have to preserve their existence and calling convention.<br>&gt; <br>&gt; Makes sense, can we solve it? Our current direction is certainly one of: stuff all the (library) modules into a single linkage unit, be that a single dylib, a static library or a framework.<br></p><p>If the frontend knows it&#39;s building for a static library, it could conceivably set the correct visibility contingent on that flag. There may also be ld flags to suppress exporting symbols from particular .o and .a files post-hoc.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c40db4457ab2c91a0d8006da31b177c6?s=50"></div><header><strong>statically link the standard library on Linux</strong> from <string>Trent Nadeau</string> &lt;tanadeau at gmail.com&gt;<p>February 23, 2016 at 09:00:00pm</p></header><div class="content"><p>The --exclude-libs linker option does exactly that.<br></p><p>On Fri, Feb 19, 2016 at 4:08 PM, Joe Groff via swift-users &lt;<br>swift-users at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Feb 19, 2016, at 1:06 PM, Max Howell &lt;max.howell at apple.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt;&gt;&gt; Static vs dynamic building of libraries may also have an interesting<br>&gt; impact on the build system, particularly in how we set visibility for<br>&gt; emitted symbols. For executables and dylibs, our current mapping of access<br>&gt; control to visibility and linkage makes sense:<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; - public has default visibility,<br>&gt; &gt;&gt;&gt;&gt; - internal has hidden visibility<br>&gt; (__attribute__((visibility(&quot;hidden&quot;))) in Clang),<br>&gt; &gt;&gt;&gt;&gt; - private has private linkage (like &#39;static&#39; in C).<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; However, when statically linking a library into another executable or<br>&gt; dylib, the static library&#39;s public symbols in most cases probably ought to<br>&gt; become hidden in the final target, unless the dylib or executable<br>&gt; explicitly reexports the static library&#39;s module somehow.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; I’ve worried about such things, but my conclusions were there weren’t<br>&gt; any practically compelling reasons to worry about it too much.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; My reasoning being: when writing a Swift file the compiler won’t give<br>&gt; you access to those symbols unless you `import` that module, in which case<br>&gt; you want them.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Unless there is something I’m missing?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Maybe not huge problems, but it&#39;s a secrecy violation and unwanted ABI<br>&gt; liability, and also limits LTO-level optimization opportunities since<br>&gt; exported functions have to preserve their existence and calling convention.<br>&gt; &gt;<br>&gt; &gt; Makes sense, can we solve it? Our current direction is certainly one of:<br>&gt; stuff all the (library) modules into a single linkage unit, be that a<br>&gt; single dylib, a static library or a framework.<br>&gt;<br>&gt; If the frontend knows it&#39;s building for a static library, it could<br>&gt; conceivably set the correct visibility contingent on that flag. There may<br>&gt; also be ld flags to suppress exporting symbols from particular .o and .a<br>&gt; files post-hoc.<br>&gt;<br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br></p><p><br></p><p>-- <br>Trent Nadeau<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160223/072960e5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>statically link the standard library on Linux</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February 23, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Feb 23, 2016, at 6:17 PM, Trent Nadeau &lt;tanadeau at gmail.com&gt; wrote:<br>&gt; <br>&gt; The --exclude-libs linker option does exactly that.<br></p><p>Good to know. I didn&#39;t immediately see an equivalent option in Darwin&#39;s ld, though.<br></p><p>-Joe<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
