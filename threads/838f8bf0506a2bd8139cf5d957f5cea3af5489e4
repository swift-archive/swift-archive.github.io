<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Review] SE-0075: Adding a Build Configuration Import Test</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 10, 2016 at 11:00:00am</p></header><div class="content"><p>Hello Swift community,<br></p><p>The review of &quot;SE-0075: Adding a Build Configuration Import Test&quot; begins now and runs through May 16. The proposal is available here:<br></p><p>	https://github.com/apple/swift-evolution/blob/master/proposals/0075-import-test.md<br></p><p>Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br></p><p>	https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>or, if you would like to keep your feedback private, directly to the review manager.<br></p><p>What goes into a review?<br></p><p>The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br></p><p>	* What is your evaluation of the proposal?<br>	* Is the problem being addressed significant enough to warrant a change to Swift?<br>	* Does this proposal fit well with the feel and direction of Swift?<br>	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>More information about the Swift evolution process is available at<br></p><p>	https://github.com/apple/swift-evolution/blob/master/process.md<br></p><p>Thank you,<br></p><p>-Chris Lattner<br>Review Manager<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Review] SE-0075: Adding a Build Configuration Import Test</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>May 11, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; 	* What is your evaluation of the proposal?<br></p><p>I think the proposal is worthwhile and I see myself using those when writing multiplatform code. I agree that they are much less brittle than os tests.<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes.<br></p><p>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>No. But I think that Swift will have many more non-multi-platform modules due to its roots.<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>A quick read.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Review] SE-0075: Adding a Build Configuration Import Test</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May 11, 2016 at 12:00:00am</p></header><div class="content"><p>&gt;         * What is your evaluation of the proposal?<br>&gt;<br></p><p>+1, solves a useful problem on the horizon.<br></p><p><br>&gt;         * Is the problem being addressed significant enough to warrant a<br>&gt; change to Swift?<br>&gt;<br></p><p>Yes.<br></p><p><br>&gt;         * Does this proposal fit well with the feel and direction of Swift?<br>&gt;<br></p><p>Yes. Although, if I could paint the bike shed just a little, &quot;importable&quot;<br>feels like a more Swifty term than &quot;canImport&quot;.<br></p><p><br>&gt;         * If you have used other languages or libraries with a similar<br>&gt; feature, how do you feel that this proposal compares to those?<br>&gt;<br></p><p>I haven&#39;t.<br></p><p><br>&gt;         * How much effort did you put into your review? A glance, a quick<br>&gt; reading, or an in-depth study?<br>&gt;<br></p><p>Followed initial discussion; re-read proposal.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160511/862f6832/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ab486d7597af4cfe0be33a762150848?s=50"></div><header><strong>[Review] SE-0075: Adding a Build Configuration Import Test</strong> from <string>Dany St-Amant</string> &lt;dsa.mls at icloud.com&gt;<p>May 12, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On May 10, 2016, at 2:49 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;SE-0075: Adding a Build Configuration Import Test&quot; begins now and runs through May 16. The proposal is available here:<br>&gt; <br>&gt;  https://github.com/apple/swift-evolution/blob/master/proposals/0075-import-test.md<br>&gt; <br>&gt;  * What is your evaluation of the proposal?<br></p><p>The goal is valid, but I do have an issue with the &#39;canImport&#39;. In my world it&#39;s not because you can import something that you want to use it. So for conditional compile code, I see this more as a &#39;didImport&#39;. <br></p><p>Unfortunately for the conditional import, since I&#39;m on the page of it&#39;s not because you can, that you should; I think it better serve by checking against the os() or arch(). Though, there is a need to ask to import something that might not exist; will this require both &#39;canImport&#39; and &#39;didImport&#39;, or should we, along my &#39;didImport&#39;, include a &#39;weakImport/quietImport/importIfExist&#39; which ignores failure to import?<br></p><p>&gt;  * Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>With common source there&#39;s a need to be able to compile code against different API providing the same functionality, so something like this is needed<br></p><p>&gt;  * Does this proposal fit well with the feel and direction of Swift?<br></p><p>&gt;  * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;  * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>Followed, the initial discussion, but not recalling much about it.<br></p><p>Dany<br></p><p>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt;  https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Review] SE-0075: Adding a Build Configuration Import Test</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>May 12, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On May 12, 2016, at 7:30 PM, Dany St-Amant via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 10, 2016, at 2:49 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello Swift community,<br>&gt;&gt; <br>&gt;&gt; The review of &quot;SE-0075: Adding a Build Configuration Import Test&quot; begins now and runs through May 16. The proposal is available here:<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0075-import-test.md<br>&gt;&gt; <br>&gt;&gt; * What is your evaluation of the proposal?<br>&gt; <br>&gt; The goal is valid, but I do have an issue with the &#39;canImport&#39;. In my world it&#39;s not because you can import something that you want to use it. So for conditional compile code, I see this more as a &#39;didImport&#39;. <br>&gt; <br>&gt; Unfortunately for the conditional import, since I&#39;m on the page of it&#39;s not because you can, that you should; I think it better serve by checking against the os() or arch(). Though, there is a need to ask to import something that might not exist; will this require both &#39;canImport&#39; and &#39;didImport&#39;, or should we, along my &#39;didImport&#39;, include a &#39;weakImport/quietImport/importIfExist&#39; which ignores failure to import?<br></p><p><br>canImport (or whatever it ends up being called) is deliberate.<br></p><p>You test before you import:<br></p><p>#if canImport(x)<br>    import x<br>#else<br>...<br>#endif<br></p><p>and you test at the use-site<br></p><p>#if canImport(x)<br>   // use things that are available in x<br>#else<br>...<br></p><p>So you don&#39;t import UIKit unless you *can*, and you don&#39;t use UIColor unless you can import UIKit. This follows closely on the design of __has_include.<br></p><p>-- E<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[Review] SE-0075: Adding a Build Configuration Import Test</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>May 13, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; canImport (or whatever it ends up being called) is deliberate.<br>&gt; <br>&gt; You test before you import:<br>&gt; <br>&gt; #if canImport(x)<br>&gt;    import x<br>&gt; #else<br>&gt; ...<br>&gt; #endif<br>&gt; <br>&gt; and you test at the use-site<br>&gt; <br>&gt; #if canImport(x)<br>&gt;   // use things that are available in x<br>&gt; #else<br>&gt; ...<br>&gt; <br>&gt; So you don&#39;t import UIKit unless you *can*, and you don&#39;t use UIColor unless you can import UIKit. This follows closely on the design of __has_include.<br>&gt; <br>&gt; -- E<br></p><p><br>I guess one issue I can see is it’s used in two different ways:<br>- The first use of canImport is used to check whether it can import a module, and then does so, but there’s no requirement for it to do so. Is this the right this to do?<br>- The second use of canImport makes no guarantee that the module has been imported, only that it can.<br></p><p>What if instead `import` could return whether it imported or not, when used with #if? Instead of ‘can import’, you get ‘did just import’ and ‘has imported’.<br></p><p><br>import Required // Error if not present, current behaviour<br></p><p>#if import CoolThing // Skips code block if not present, imports otherwise<br>  // Do something with CoolThing module<br>#else<br>  import AlmostAsCoolThing<br>#endif<br></p><p>and you test at the use-site<br></p><p>#if module(X) // Does not import, only checks if it has been imported<br>  // use things that are available in X<br>#else<br></p><p><br>As per Pyry’s feedback, you could add a version:<br></p><p>#if import Frobnication(&lt;1.7.3) // &lt;- Only added version constraint here.<br>extension Knob : Frobnicatable { ... }<br>#endif<br></p><p><br></p><p>Just a way to make it less low level.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[Review] SE-0075: Adding a Build Configuration Import Test</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>May 13, 2016 at 11:00:00am</p></header><div class="content"><p>Patrick,<br></p><p>I think you&#39;re making valuable points here. I also can&#39;t think of cases where you wouldn&#39;t also import a module in case it was found to be importable. So the use cases I can think of could as well be tackled by allowing expressions such as `import Foo.Bar` as compile-time checks within the conditions of `#if` like you suggested. That would bring those libraries only visible within the scope of that block.<br></p><p>However, there can be cases where you&#39;re considering importing more than one module, so something like:<br></p><p>    #if import Foo, import Bar<br>      ...<br>    #elseif import Baz<br>      ...<br>    #endif<br></p><p>should be considered in that design too. And I don&#39;t like the fact that it would import many modules in one line of code.<br></p><p>However, I don&#39;t get your concerns of &quot;whether already imported or not&quot;. Isn&#39;t `import` strictly about bringing identifiers of linked libraries visible in the current file and not about linking to libraries in code.<br></p><p>— Pyry<br></p><p>&gt; I guess one issue I can see is it’s used in two different ways:<br>&gt; - The first use of canImport is used to check whether it can import a module, and then does so, but there’s no requirement for it to do so. Is this the right this to do?<br>&gt; - The second use of canImport makes no guarantee that the module has been imported, only that it can.<br>&gt; <br>&gt; What if instead `import` could return whether it imported or not, when used with #if? Instead of ‘can import’, you get ‘did just import’ and ‘has imported’.<br>&gt; <br>&gt; <br>&gt; import Required // Error if not present, current behaviour<br>&gt; <br>&gt; #if import CoolThing // Skips code block if not present, imports otherwise<br>&gt;  // Do something with CoolThing module<br>&gt; #else<br>&gt;  import AlmostAsCoolThing<br>&gt; #endif<br>&gt; <br>&gt; and you test at the use-site<br>&gt; <br>&gt; #if module(X) // Does not import, only checks if it has been imported<br>&gt;  // use things that are available in X<br>&gt; #else<br>&gt; <br>&gt; <br>&gt; As per Pyry’s feedback, you could add a version:<br>&gt; <br>&gt; #if import Frobnication(&lt;1.7.3) // &lt;- Only added version constraint here.<br>&gt; extension Knob : Frobnicatable { ... }<br>&gt; #endif<br>&gt; <br>&gt; <br>&gt; <br>&gt; Just a way to make it less low level.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/f3953d69/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>[Review] SE-0075: Adding a Build Configuration Import Test</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>May 13, 2016 at 10:00:00am</p></header><div class="content"><p>Hello,<br></p><p>`#if import Foo` can not deal with the fact that a single source file may have to perform the importability test several times.<br></p><p>For example:<br></p><p>	#if canImport(UIKit)<br>		import UIKit<br>		// Some UIKit-related declarations<br>	#endif<br>	// Later in the same file<br>	func f() {<br>		#if canImport(UIKit)<br>			// Use UIKit-only declarations<br>		#endif<br>	}<br></p><p>I know, I know, some will tell me to refactor my code. So let&#39;s just say I&#39;m prototyping and that the code doesn&#39;t have its final shape, OK?<br></p><p>Still, testing for module importability is not the same as importing it.<br></p><p>Gwendal Roué<br></p><p>&gt; Le 13 mai 2016 à 10:40, Pyry Jahkola via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Patrick,<br>&gt; <br>&gt; I think you&#39;re making valuable points here. I also can&#39;t think of cases where you wouldn&#39;t also import a module in case it was found to be importable. So the use cases I can think of could as well be tackled by allowing expressions such as `import Foo.Bar` as compile-time checks within the conditions of `#if` like you suggested. That would bring those libraries only visible within the scope of that block.<br>&gt; <br>&gt; However, there can be cases where you&#39;re considering importing more than one module, so something like:<br>&gt; <br>&gt;     #if import Foo, import Bar<br>&gt;       ...<br>&gt;     #elseif import Baz<br>&gt;       ...<br>&gt;     #endif<br>&gt; <br>&gt; should be considered in that design too. And I don&#39;t like the fact that it would import many modules in one line of code.<br>&gt; <br>&gt; However, I don&#39;t get your concerns of &quot;whether already imported or not&quot;. Isn&#39;t `import` strictly about bringing identifiers of linked libraries visible in the current file and not about linking to libraries in code.<br>&gt; <br>&gt; — Pyry<br>&gt; <br>&gt;&gt; I guess one issue I can see is it’s used in two different ways:<br>&gt;&gt; - The first use of canImport is used to check whether it can import a module, and then does so, but there’s no requirement for it to do so. Is this the right this to do?<br>&gt;&gt; - The second use of canImport makes no guarantee that the module has been imported, only that it can.<br>&gt;&gt; <br>&gt;&gt; What if instead `import` could return whether it imported or not, when used with #if? Instead of ‘can import’, you get ‘did just import’ and ‘has imported’.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; import Required // Error if not present, current behaviour<br>&gt;&gt; <br>&gt;&gt; #if import CoolThing // Skips code block if not present, imports otherwise<br>&gt;&gt;  // Do something with CoolThing module<br>&gt;&gt; #else<br>&gt;&gt;  import AlmostAsCoolThing<br>&gt;&gt; #endif<br>&gt;&gt; <br>&gt;&gt; and you test at the use-site<br>&gt;&gt; <br>&gt;&gt; #if module(X) // Does not import, only checks if it has been imported<br>&gt;&gt;  // use things that are available in X<br>&gt;&gt; #else<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; As per Pyry’s feedback, you could add a version:<br>&gt;&gt; <br>&gt;&gt; #if import Frobnication(&lt;1.7.3) // &lt;- Only added version constraint here.<br>&gt;&gt; extension Knob : Frobnicatable { ... }<br>&gt;&gt; #endif<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Just a way to make it less low level.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/3c039006/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[Review] SE-0075: Adding a Build Configuration Import Test</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>May 13, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; Gwendal Roué wrote:<br>&gt; <br>&gt; `#if import Foo` can not deal with the fact that a single source file may have to perform the importability test several times.<br></p><p>This would be less of a problem if conditional imports like that worked locally in all scopes of code, so you could write just<br></p><p>    func foo() {<br>        #if import UIKit<br>            // Actually use UIKit...<br>        #endif<br>        // UIKit no longer visible.<br>    }<br></p><p>— Pyry<br></p><p>&gt; For example:<br>&gt; <br>&gt; 	#if canImport(UIKit)<br>&gt; 		import UIKit<br>&gt; 		// Some UIKit-related declarations<br>&gt; 	#endif<br>&gt; 	// Later in the same file<br>&gt; 	func f() {<br>&gt; 		#if canImport(UIKit)<br>&gt; 			// Use UIKit-only declarations<br>&gt; 		#endif<br>&gt; 	}<br>&gt; <br>&gt; I know, I know, some will tell me to refactor my code. So let&#39;s just say I&#39;m prototyping and that the code doesn&#39;t have its final shape, OK?<br>&gt; <br>&gt; Still, testing for module importability is not the same as importing it.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/9b249247/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>[Review] SE-0075: Adding a Build Configuration Import Test</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>May 13, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; Le 13 mai 2016 à 11:05, Pyry Jahkola &lt;pyry.jahkola at iki.fi&gt; a écrit :<br>&gt; <br>&gt;&gt; Gwendal Roué wrote:<br>&gt;&gt; <br>&gt;&gt; `#if import Foo` can not deal with the fact that a single source file may have to perform the importability test several times.<br>&gt; <br>&gt; This would be less of a problem if conditional imports like that worked locally in all scopes of code, so you could write just<br>&gt; <br>&gt;     func foo() {<br>&gt;         #if import UIKit<br>&gt;             // Actually use UIKit...<br>&gt;         #endif<br>&gt;         // UIKit no longer visible.<br>&gt;     }<br>&gt; <br>&gt; — Pyry<br></p><p>Neat idea!<br></p><p>Gwendal<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/ee84c99e/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[Review] SE-0075: Adding a Build Configuration Import Test</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>May 13, 2016 at 08:00:00pm</p></header><div class="content"><p>I can’t decide if this would be a good idea or not? I can see pluses and minuses!<br></p><p>+<br>Consistent.<br>One way to remember to work with modules.<br>Reinforces the rule that if you want to work with a module, you want to import it.<br></p><p>-<br>Could get confusing exactly where things are being imported, but you can stick an import away from the top of file today.<br></p><p><br>I imagine might still need something like `#if module(UIKit)` for certain scenarios, but not sure.<br></p><p><br>Patrick<br></p><p><br>&gt; On 13 May 2016, at 7:05 PM, Pyry Jahkola via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This would be less of a problem if conditional imports like that worked locally in all scopes of code, so you could write just<br>&gt; <br>&gt;     func foo() {<br>&gt;         #if import UIKit<br>&gt;             // Actually use UIKit...<br>&gt;         #endif<br>&gt;         // UIKit no longer visible.<br>&gt;     }<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/1e98e6c9/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[Review] SE-0075: Adding a Build Configuration Import Test</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>May 13, 2016 at 08:00:00pm</p></header><div class="content"><p>Well my idea also included module(X), modelled after the os() function, e.g. #if os(OSX)<br></p><p>#if import UIKit<br>	// Some UIKit-related declarations<br>#endif<br>// Later in the same file<br>func f() {<br>	#if module(UIKit)<br>		// Use UIKit-only declarations<br>	#endif<br>}<br></p><p><br>Looking forward to seeing more feedback, esp from Erica. My concern was that hasModule() was just a bit raw.<br></p><p>I will point out a few concerns I have:<br></p><p>Is there a better way of writing this with nothing inside:<br>#if import UIKit<br>#endif<br></p><p>Is it strange that all other functions with #if use parentheses (), but not import?<br></p><p>However, I just feel code like this doesn’t feel very Swifty:<br></p><p>#if hasModule(UIKit)<br>	import UIKit<br>#endif<br></p><p>&gt; However, I don&#39;t get your concerns of &quot;whether already imported or not&quot;. Isn&#39;t `import` strictly about bringing identifiers of linked libraries visible in the current file and not about linking to libraries in code.<br></p><p><br>I was originally going to include this, but cut it out, because it would be an unclear way to still import something. import ‘returned’ a boolean. So forgot to cut that bit out too.<br></p><p>#if ! import SomethingCool<br>	import SomeFallback<br>#endif<br></p><p>&gt; On 13 May 2016, at 6:54 PM, Gwendal Roué &lt;gwendal.roue at gmail.com&gt; wrote:<br>&gt; <br>&gt; Hello,<br>&gt; <br>&gt; `#if import Foo` can not deal with the fact that a single source file may have to perform the importability test several times.<br>&gt; <br>&gt; For example:<br>&gt; <br>&gt; 	#if canImport(UIKit)<br>&gt; 		import UIKit<br>&gt; 		// Some UIKit-related declarations<br>&gt; 	#endif<br>&gt; 	// Later in the same file<br>&gt; 	func f() {<br>&gt; 		#if canImport(UIKit)<br>&gt; 			// Use UIKit-only declarations<br>&gt; 		#endif<br>&gt; 	}<br>&gt; <br>&gt; I know, I know, some will tell me to refactor my code. So let&#39;s just say I&#39;m prototyping and that the code doesn&#39;t have its final shape, OK?<br>&gt; <br>&gt; Still, testing for module importability is not the same as importing it.<br>&gt; <br>&gt; Gwendal Roué<br>&gt; <br>&gt;&gt; Le 13 mai 2016 à 10:40, Pyry Jahkola via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; Patrick,<br>&gt;&gt; <br>&gt;&gt; I think you&#39;re making valuable points here. I also can&#39;t think of cases where you wouldn&#39;t also import a module in case it was found to be importable. So the use cases I can think of could as well be tackled by allowing expressions such as `import Foo.Bar` as compile-time checks within the conditions of `#if` like you suggested. That would bring those libraries only visible within the scope of that block.<br>&gt;&gt; <br>&gt;&gt; However, there can be cases where you&#39;re considering importing more than one module, so something like:<br>&gt;&gt; <br>&gt;&gt;     #if import Foo, import Bar<br>&gt;&gt;       ...<br>&gt;&gt;     #elseif import Baz<br>&gt;&gt;       ...<br>&gt;&gt;     #endif<br>&gt;&gt; <br>&gt;&gt; should be considered in that design too. And I don&#39;t like the fact that it would import many modules in one line of code.<br>&gt;&gt; <br>&gt;&gt; However, I don&#39;t get your concerns of &quot;whether already imported or not&quot;. Isn&#39;t `import` strictly about bringing identifiers of linked libraries visible in the current file and not about linking to libraries in code.<br>&gt;&gt; <br>&gt;&gt; — Pyry<br>&gt;&gt; <br>&gt;&gt;&gt; I guess one issue I can see is it’s used in two different ways:<br>&gt;&gt;&gt; - The first use of canImport is used to check whether it can import a module, and then does so, but there’s no requirement for it to do so. Is this the right this to do?<br>&gt;&gt;&gt; - The second use of canImport makes no guarantee that the module has been imported, only that it can.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What if instead `import` could return whether it imported or not, when used with #if? Instead of ‘can import’, you get ‘did just import’ and ‘has imported’.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; import Required // Error if not present, current behaviour<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; #if import CoolThing // Skips code block if not present, imports otherwise<br>&gt;&gt;&gt;  // Do something with CoolThing module<br>&gt;&gt;&gt; #else<br>&gt;&gt;&gt;  import AlmostAsCoolThing<br>&gt;&gt;&gt; #endif<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; and you test at the use-site<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; #if module(X) // Does not import, only checks if it has been imported<br>&gt;&gt;&gt;  // use things that are available in X<br>&gt;&gt;&gt; #else<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As per Pyry’s feedback, you could add a version:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; #if import Frobnication(&lt;1.7.3) // &lt;- Only added version constraint here.<br>&gt;&gt;&gt; extension Knob : Frobnicatable { ... }<br>&gt;&gt;&gt; #endif<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Just a way to make it less low level.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/9ee56af1/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Review] SE-0075: Adding a Build Configuration Import Test</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>May 13, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On May 13, 2016, at 1:42 AM, Patrick Smith &lt;pgwsmith at gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; canImport (or whatever it ends up being called) is deliberate.<br>&gt;&gt; <br>&gt;&gt; You test before you import:<br>&gt;&gt; <br>&gt;&gt; #if canImport(x)<br>&gt;&gt;   import x<br>&gt;&gt; #else<br>&gt;&gt; ...<br>&gt;&gt; #endif<br>&gt;&gt; <br>&gt;&gt; and you test at the use-site<br>&gt;&gt; <br>&gt;&gt; #if canImport(x)<br>&gt;&gt;  // use things that are available in x<br>&gt;&gt; #else<br>&gt;&gt; ...<br>&gt;&gt; <br>&gt;&gt; So you don&#39;t import UIKit unless you *can*, and you don&#39;t use UIColor unless you can import UIKit. This follows closely on the design of __has_include.<br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt; <br>&gt; <br>&gt; I guess one issue I can see is it’s used in two different ways:<br>&gt; - The first use of canImport is used to check whether it can import a module, and then does so, but there’s no requirement for it to do so. Is this the right this to do?<br>&gt; - The second use of canImport makes no guarantee that the module has been imported, only that it can.<br>&gt; <br>&gt; What if instead `import` could return whether it imported or not, when used with #if? Instead of ‘can import’, you get ‘did just import’ and ‘has imported’.<br></p><p>That would be a much more complicated proposal than this simple build configuration test. <br></p><p>&gt; As per Pyry’s feedback, you could add a version:<br>&gt; <br>&gt; #if import Frobnication(&lt;1.7.3) // &lt;- Only added version constraint here.<br>&gt; extension Knob : Frobnicatable { ... }<br>&gt; #endif<br></p><p>I have no problem with this but would need to defer to the build and language people to determine whether that&#39;s practical in today&#39;s Swift. Right now, there&#39;s a major-version mention in build packages but I&#39;m not sure whether that information then propagates in a usable way. If it&#39;s possible, then yes, I&#39;d rather add it in the initial design than as a later addition and I can extend Pyry&#39;s suggestion in &quot;Future Directions&quot;.<br></p><p>I&#39;ve cc&#39;ed in Daniel Dunbar to see if he has anything specific to add about this.<br></p><p>-- E<br></p><p>p.s. Also on my Swift Bucket list: &quot;import as&quot;.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[Review] SE-0075: Adding a Build Configuration Import Test</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>May 13, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On 13 May 2016, Erica Sadun wrote:<br>&gt; <br>&gt;&gt; As per Pyry’s feedback, you could add a version:<br>&gt;&gt; <br>&gt;&gt; #if import Frobnication(&lt;1.7.3) // &lt;- Only added version constraint here.<br>&gt;&gt; extension Knob : Frobnicatable { ... }<br>&gt;&gt; #endif<br>&gt; <br>&gt; I have no problem with this but would need to defer to the build and language people to determine whether that&#39;s practical in today&#39;s Swift. Right now, there&#39;s a major-version mention in build packages but I&#39;m not sure whether that information then propagates in a usable way. If it&#39;s possible, then yes, I&#39;d rather add it in the initial design than as a later addition and I can extend Pyry&#39;s suggestion in &quot;Future Directions&quot;.<br></p><p>I already gave my +1 on the original proposal and if `canImport` is indeed easiest to implement we should get it going now.<br></p><p>The `#if import Foo` blocks and conditional imports with version checks can easily be added at a later time without much complication or breakage, AFAICT. Good if you can include those in the &quot;Future Directions&quot; section.<br></p><p>&gt; p.s. Also on my Swift Bucket list: &quot;import as&quot;.<br></p><p>Splendid! I&#39;d already forgotten about qualified imports and renaming! Those would be welcome additions too.<br></p><p>— Pyry<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/9e170f04/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[Review] SE-0075: Adding a Build Configuration Import Test</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>May 13, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; The review of &quot;SE-0075: Adding a Build Configuration Import Test&quot; begins now and runs through May 16. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0075-import-test.md<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br></p><p>+1, I think it&#39;s a welcome change that improves modularity between libraries.<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes.<br></p><p>There&#39;s another real problem that this feature solves which I couldn&#39;t see mentioned in the proposal: adding protocol conformances to optional dependencies. Suppose a library named Frobnication defined a protocol `Frobnicatable`, with some known conformances:<br></p><p>    // module Frobnication<br>    public protocol Frobnicatable {<br>        mutating func frobnicate()<br>    }<br>    extension String : Frobnicatable { ... }<br>    extension Frob : Frobnicatable { ... }<br></p><p>Now, suppose something in a 3rd party library called Knobs was also clearly `Frobnicatable` but `canImport` didn&#39;t exist. The community would have to pick from the following poorly scaling alternatives:<br></p><p>#1) Either Frobnication would require and import Knobs as its dependency and add the conformances,<br>#2) or vice versa, Knobs would pull Frobnication as its dependency,<br>#3) or everybody using both libraries would need to define the conformances theirselves,<br>#4) or someone would need to maintain a &quot;KnobsFrobnication&quot; library for the sole purpose of defining the said protocol conformances.<br></p><p>* * *<br></p><p>With `canImport`, on the other hand, we get two good options:<br></p><p>#5) Either Frobnication checks `#if canImport(Knobs)` and conditionally adds the conformances,<br>#6) or Knobs checks if it `canImport(Frobnication)` and conditionally adds the conformances to any suitable types it defines (which is what any new libraries that the author of Frobnication wasn&#39;t aware of could do in the future).<br></p><p>* * *<br></p><p>But there remains one issue that there&#39;s no clear path for moving conformance definitions from one library into the other one day. This proposal could be improved by allowing to check for library versions too! If similarly to `#if swift(&gt;=2.2)`, we could check `#if canImport(Knobs &gt;= @2.10.0)`, then the authors of Knobs and Frobnication could organise an orchestrated move of conformance definitions from one library into another. Before the move, Knobs 2.9.x would have defined:<br></p><p>    // module Knobs 2.9.x<br>    #if canImport(Frobnication)<br>    import Frobnication<br>    extension Knob : Frobnicatable { ... }<br>    #endif<br></p><p>Preparing for the move, a new version of Frobnication could introduce the conformance thusly:<br></p><p>    // module Frobnication 1.7.3<br>    #if canImport(Knobs &gt;= @2.10.0) // *) see note below<br>    import Knobs<br>    extension Knob : Frobnicatable { ... }<br>    #endif<br></p><p>Then, Knobs could gracefully sunset its conformance definitions beginning from the 2.10.0 release:<br></p><p>    // module Knobs 2.10.0<br>    #if canImport(Frobnication &lt; @1.7.3) // &lt;- Only added version constraint here.<br>    import Frobnication<br>    extension Knob : Frobnicatable { ... }<br>    #endif<br></p><p>*) I&#39;m not sold to any specific syntax, but we could e.g. use the `@` prefix to distinguish version number literals like `@1`, `@0.10` and `@0.10.0` from similar but differently behaving numeric literals.<br></p><p>In any case, even with just `canImport(module)`, we can do a lot better than currently.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes.<br></p><p>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>Yes, like mentioned in the proposal, it&#39;s very similar to the `__has_import(&lt;path/to/import.h&gt;)` macro in Clang. I&#39;m not fully familiar with the design space in Haskell, but it seems to me instead of using something similar to `canImport` Haskellers tend to favour the approach I listed above as alternative #4 (e.g. https://github.com/lens/lens-aeson/ &lt;https://github.com/lens/lens-aeson/&gt; brings the lens and aeson libraries together).<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>Quick reading.<br></p><p>— Pyry<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/a3419a8c/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2ff1daab58cd5e44a457908d1905c322?s=50"></div><header><strong>[Review] SE-0075: Adding a Build Configuration Import Test</strong> from <string>Krzysztof Siejkowski</string> &lt;krzysztof at siejkowski.net&gt;<p>May 13, 2016 at 09:00:00am</p></header><div class="content"><p>* What is your evaluation of the proposal?<br>+1.<br></p><p>It attacks a real problem that is met regularly when working on multi-platform code.<br></p><p>I also like `canImport`. As it’s gonna be used mostly after #if, the whole statement becomes very readable.<br></p><p><br></p><p>* Is the problem being addressed significant enough to warrant a change to Swift?<br>Definitely. Also, now is the good time to introduce such a change, since the multiplatform use of Swift is only getting momentum.<br></p><p><br></p><p>* Does this proposal fit well with the feel and direction of Swift?<br>I do think so. Swift was always presented with a vision of language of the future, something that can take place of C++ in the terms of the best solution to write multiplatform code. A great community effort has already introduced basic support for Android, RaspberryPi, multiple Linux distros. The differences in frameworks availability and naming are unavoidable.<br></p><p><br></p><p>* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>No, I haven’t. I’ve been bitten by problems coming from a lack of such a feature in other languages, though.<br></p><p><br></p><p>* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>I’ve read the proposal and related discussion.<br></p><p><br></p><p>Cheers,<br></p><p>Krzysztof<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/6d9487ef/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
