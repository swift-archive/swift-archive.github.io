<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8809800aec2460f291384b794d7e6f8f?s=50"></div><header><strong>Protocol with instance var that&#39;s set on construction, otherwise read-only</strong> from <string>Rick Mann</string> &lt;rmann at latencyzero.com&gt;<p>August  2, 2016 at 04:00:00pm</p></header><div class="content"><p>I&#39;m trying to define a protocol that has a read-only, immutable member &quot;uuid&quot; that can be set in the init() method, but I&#39;m having trouble. I have this:<br></p><p>protocol<br>Element<br>{<br>    var uuid : { get }<br>}<br></p><p>extension<br>Element<br>{<br>    init(...)<br>    {<br>	self.uuid = ...<br>    }<br>}<br></p><p>I can&#39;t make it let, because they&#39;re computed.<br></p><p>I&#39;m realizing from other stuff that I really can&#39;t have the init(...) method in the extension, anyway. But I&#39;d really like to be able to specify a let member in the protocol. What&#39;s the best way to have that effect?<br></p><p>In my semantics, an Element has a uniquely-assigned uuid. It might be generated when the object is instantiated, or it might be deserialized from disk, but once that&#39;s done, it can never change. How do I express that?<br></p><p>Thanks,<br></p><p>-- <br>Rick Mann<br>rmann at latencyzero.com<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Protocol with instance var that&#39;s set on construction, otherwise read-only</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>August  2, 2016 at 06:00:00pm</p></header><div class="content"><p>If I understand things correctly, you *can* make uuid a let because you’re allowed to set them (once) during init functions.<br></p><p>- Dave Sweeris<br></p><p>&gt; On Aug 2, 2016, at 6:22 PM, Rick Mann via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;m trying to define a protocol that has a read-only, immutable member &quot;uuid&quot; that can be set in the init() method, but I&#39;m having trouble. I have this:<br>&gt; <br>&gt; protocol<br>&gt; Element<br>&gt; {<br>&gt;    var uuid : { get }<br>&gt; }<br>&gt; <br>&gt; extension<br>&gt; Element<br>&gt; {<br>&gt;    init(...)<br>&gt;    {<br>&gt; 	self.uuid = ...<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; I can&#39;t make it let, because they&#39;re computed.<br>&gt; <br>&gt; I&#39;m realizing from other stuff that I really can&#39;t have the init(...) method in the extension, anyway. But I&#39;d really like to be able to specify a let member in the protocol. What&#39;s the best way to have that effect?<br>&gt; <br>&gt; In my semantics, an Element has a uniquely-assigned uuid. It might be generated when the object is instantiated, or it might be deserialized from disk, but once that&#39;s done, it can never change. How do I express that?<br>&gt; <br>&gt; Thanks,<br>&gt; <br>&gt; -- <br>&gt; Rick Mann<br>&gt; rmann at latencyzero.com<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8809800aec2460f291384b794d7e6f8f?s=50"></div><header><strong>Protocol with instance var that&#39;s set on construction, otherwise read-only</strong> from <string>Rick Mann</string> &lt;rmann at latencyzero.com&gt;<p>August  2, 2016 at 05:00:00pm</p></header><div class="content"><p>It complains if I make it a let because computed properties must be var. Because it&#39;s a protocol, it can&#39;t be stored (even though it can be stored in the conforming type).<br></p><p>If I make it { get }, I can&#39;t set it in the extensions init() method.<br></p><p>I guess I could make it private set (not sure of the syntax for that), but it still doesn&#39;t have let semantics.<br></p><p>&gt; On Aug 2, 2016, at 16:28 , David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt; <br>&gt; If I understand things correctly, you *can* make uuid a let because you’re allowed to set them (once) during init functions.<br>&gt; <br>&gt; - Dave Sweeris<br>&gt; <br>&gt;&gt; On Aug 2, 2016, at 6:22 PM, Rick Mann via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;m trying to define a protocol that has a read-only, immutable member &quot;uuid&quot; that can be set in the init() method, but I&#39;m having trouble. I have this:<br>&gt;&gt; <br>&gt;&gt; protocol<br>&gt;&gt; Element<br>&gt;&gt; {<br>&gt;&gt;   var uuid : { get }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension<br>&gt;&gt; Element<br>&gt;&gt; {<br>&gt;&gt;   init(...)<br>&gt;&gt;   {<br>&gt;&gt; 	self.uuid = ...<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I can&#39;t make it let, because they&#39;re computed.<br>&gt;&gt; <br>&gt;&gt; I&#39;m realizing from other stuff that I really can&#39;t have the init(...) method in the extension, anyway. But I&#39;d really like to be able to specify a let member in the protocol. What&#39;s the best way to have that effect?<br>&gt;&gt; <br>&gt;&gt; In my semantics, an Element has a uniquely-assigned uuid. It might be generated when the object is instantiated, or it might be deserialized from disk, but once that&#39;s done, it can never change. How do I express that?<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Rick Mann<br>&gt;&gt; rmann at latencyzero.com<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt; <br></p><p><br>-- <br>Rick Mann<br>rmann at latencyzero.com<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Protocol with instance var that&#39;s set on construction, otherwise read-only</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>August  2, 2016 at 08:00:00pm</p></header><div class="content"><p>Oh, it&#39;s a computed property! Got it, I thought you meant its value was computed in the init and never changed again.<br></p><p>Sent from my iPhone<br></p><p>&gt; On Aug 2, 2016, at 19:01, Rick Mann &lt;rmann at latencyzero.com&gt; wrote:<br>&gt; <br>&gt; It complains if I make it a let because computed properties must be var. Because it&#39;s a protocol, it can&#39;t be stored (even though it can be stored in the conforming type).<br>&gt; <br>&gt; If I make it { get }, I can&#39;t set it in the extensions init() method.<br>&gt; <br>&gt; I guess I could make it private set (not sure of the syntax for that), but it still doesn&#39;t have let semantics.<br>&gt; <br>&gt;&gt; On Aug 2, 2016, at 16:28 , David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; If I understand things correctly, you *can* make uuid a let because you’re allowed to set them (once) during init functions.<br>&gt;&gt; <br>&gt;&gt; - Dave Sweeris<br>&gt;&gt; <br>&gt;&gt;&gt; On Aug 2, 2016, at 6:22 PM, Rick Mann via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m trying to define a protocol that has a read-only, immutable member &quot;uuid&quot; that can be set in the init() method, but I&#39;m having trouble. I have this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol<br>&gt;&gt;&gt; Element<br>&gt;&gt;&gt; {<br>&gt;&gt;&gt;  var uuid : { get }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension<br>&gt;&gt;&gt; Element<br>&gt;&gt;&gt; {<br>&gt;&gt;&gt;  init(...)<br>&gt;&gt;&gt;  {<br>&gt;&gt;&gt;    self.uuid = ...<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I can&#39;t make it let, because they&#39;re computed.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m realizing from other stuff that I really can&#39;t have the init(...) method in the extension, anyway. But I&#39;d really like to be able to specify a let member in the protocol. What&#39;s the best way to have that effect?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In my semantics, an Element has a uniquely-assigned uuid. It might be generated when the object is instantiated, or it might be deserialized from disk, but once that&#39;s done, it can never change. How do I express that?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Rick Mann<br>&gt;&gt;&gt; rmann at latencyzero.com<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt; swift-users at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Rick Mann<br>&gt; rmann at latencyzero.com<br>&gt; <br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Protocol with instance var that&#39;s set on construction, otherwise read-only</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>August  2, 2016 at 07:00:00pm</p></header><div class="content"><p>I don’t think it makes sense to do this. A protocol cannot control how a particular property is implemented (stored or computed), and any conforming type must initialize all of its stored properties before returning from its own initializer. (You can’t write an initializer in a protocol that doesn’t delegate to another initializer because you don’t know what other stored properties the conforming type might have.)<br></p><p>Given that the protocol can’t control how the property gets initialized, it doesn’t make sense to allow the protocol to &quot;set the variable, but only in the initializer”.<br></p><p>Jordan<br></p><p><br>&gt; On Aug 2, 2016, at 17:01, Rick Mann via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; It complains if I make it a let because computed properties must be var. Because it&#39;s a protocol, it can&#39;t be stored (even though it can be stored in the conforming type).<br>&gt; <br>&gt; If I make it { get }, I can&#39;t set it in the extensions init() method.<br>&gt; <br>&gt; I guess I could make it private set (not sure of the syntax for that), but it still doesn&#39;t have let semantics.<br>&gt; <br>&gt;&gt; On Aug 2, 2016, at 16:28 , David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; If I understand things correctly, you *can* make uuid a let because you’re allowed to set them (once) during init functions.<br>&gt;&gt; <br>&gt;&gt; - Dave Sweeris<br>&gt;&gt; <br>&gt;&gt;&gt; On Aug 2, 2016, at 6:22 PM, Rick Mann via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m trying to define a protocol that has a read-only, immutable member &quot;uuid&quot; that can be set in the init() method, but I&#39;m having trouble. I have this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol<br>&gt;&gt;&gt; Element<br>&gt;&gt;&gt; {<br>&gt;&gt;&gt;  var uuid : { get }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension<br>&gt;&gt;&gt; Element<br>&gt;&gt;&gt; {<br>&gt;&gt;&gt;  init(...)<br>&gt;&gt;&gt;  {<br>&gt;&gt;&gt; 	self.uuid = ...<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I can&#39;t make it let, because they&#39;re computed.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m realizing from other stuff that I really can&#39;t have the init(...) method in the extension, anyway. But I&#39;d really like to be able to specify a let member in the protocol. What&#39;s the best way to have that effect?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In my semantics, an Element has a uniquely-assigned uuid. It might be generated when the object is instantiated, or it might be deserialized from disk, but once that&#39;s done, it can never change. How do I express that?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Rick Mann<br>&gt;&gt;&gt; rmann at latencyzero.com<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt; swift-users at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Rick Mann<br>&gt; rmann at latencyzero.com &lt;mailto:rmann at latencyzero.com&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160802/5eff579b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8809800aec2460f291384b794d7e6f8f?s=50"></div><header><strong>Protocol with instance var that&#39;s set on construction, otherwise read-only</strong> from <string>Rick Mann</string> &lt;rmann at latencyzero.com&gt;<p>August  3, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; On Aug 2, 2016, at 19:06 , Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; I don’t think it makes sense to do this. A protocol cannot control how a particular property is implemented (stored or computed), and any conforming type must initialize all of its stored properties before returning from its own initializer. (You can’t write an initializer in a protocol that doesn’t delegate to another initializer because you don’t know what other stored properties the conforming type might have.)<br>&gt; <br>&gt; Given that the protocol can’t control how the property gets initialized, it doesn’t make sense to allow the protocol to &quot;set the variable, but only in the initializer”.<br></p><p>Really? It seems pretty natural for a conforming type to set a property once in the initializer, and it&#39;s immutable from then on out. I can do that quite cleanly with classes, but there&#39;s no way (that I know) to describe this using protocols. Ideally, I could just do:<br></p><p>protocol<br>Element<br>{<br>    let uuid: UUID<br>}<br></p><p>which implies that all conforming types must initialize that value on creation, or provide a getter with let semantics (the latter might be too easy to break, and could be disallowed, requiring conforming types to create storage for the property and set it in init()).<br></p><p>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; <br>&gt;&gt; On Aug 2, 2016, at 17:01, Rick Mann via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; It complains if I make it a let because computed properties must be var. Because it&#39;s a protocol, it can&#39;t be stored (even though it can be stored in the conforming type).<br>&gt;&gt; <br>&gt;&gt; If I make it { get }, I can&#39;t set it in the extensions init() method.<br>&gt;&gt; <br>&gt;&gt; I guess I could make it private set (not sure of the syntax for that), but it still doesn&#39;t have let semantics.<br>&gt;&gt; <br>&gt;&gt;&gt; On Aug 2, 2016, at 16:28 , David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If I understand things correctly, you *can* make uuid a let because you’re allowed to set them (once) during init functions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Dave Sweeris<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Aug 2, 2016, at 6:22 PM, Rick Mann via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m trying to define a protocol that has a read-only, immutable member &quot;uuid&quot; that can be set in the init() method, but I&#39;m having trouble. I have this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol<br>&gt;&gt;&gt;&gt; Element<br>&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;  var uuid : { get }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension<br>&gt;&gt;&gt;&gt; Element<br>&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;  init(...)<br>&gt;&gt;&gt;&gt;  {<br>&gt;&gt;&gt;&gt; 	self.uuid = ...<br>&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I can&#39;t make it let, because they&#39;re computed.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m realizing from other stuff that I really can&#39;t have the init(...) method in the extension, anyway. But I&#39;d really like to be able to specify a let member in the protocol. What&#39;s the best way to have that effect?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In my semantics, an Element has a uniquely-assigned uuid. It might be generated when the object is instantiated, or it might be deserialized from disk, but once that&#39;s done, it can never change. How do I express that?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; Rick Mann<br>&gt;&gt;&gt;&gt; rmann at latencyzero.com<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt;&gt; swift-users at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Rick Mann<br>&gt;&gt; rmann at latencyzero.com<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt; <br></p><p><br>-- <br>Rick Mann<br>rmann at latencyzero.com<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0f0154768aeec561194e651b0bca02d9?s=50"></div><header><strong>Protocol with instance var that&#39;s set on construction, otherwise read-only</strong> from <string>Dan Loewenherz</string> &lt;dan at lionheartsw.com&gt;<p>August  3, 2016 at 05:00:00am</p></header><div class="content"><p>On Wed, Aug 3, 2016 at 3:51 AM, Rick Mann via swift-users &lt;<br>swift-users at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Aug 2, 2016, at 19:06 , Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I don’t think it makes sense to do this. A protocol cannot control how a<br>&gt; particular property is implemented (stored or computed), and any conforming<br>&gt; type must initialize all of its stored properties before returning from its<br>&gt; own initializer. (You can’t write an initializer in a protocol that doesn’t<br>&gt; delegate to another initializer because you don’t know what other stored<br>&gt; properties the conforming type might have.)<br>&gt; &gt;<br>&gt; &gt; Given that the protocol can’t control how the property gets initialized,<br>&gt; it doesn’t make sense to allow the protocol to &quot;set the variable, but only<br>&gt; in the initializer”.<br>&gt;<br>&gt; Really? It seems pretty natural for a conforming type to set a property<br>&gt; once in the initializer, and it&#39;s immutable from then on out. I can do that<br>&gt; quite cleanly with classes, but there&#39;s no way (that I know) to describe<br>&gt; this using protocols. Ideally, I could just do:<br>&gt;<br>&gt; protocol<br>&gt; Element<br>&gt; {<br>&gt;     let uuid: UUID<br>&gt; }<br>&gt;<br>&gt; which implies that all conforming types must initialize that value on<br>&gt; creation, or provide a getter with let semantics (the latter might be too<br>&gt; easy to break, and could be disallowed, requiring conforming types to<br>&gt; create storage for the property and set it in init()).<br></p><p><br>The compiler only knows as much as you tell it, and when you define a<br>protocol and set it as { get } only, it&#39;s not going to let you set that<br>property in a protocol extension for a protocol that doesn&#39;t expect a<br>setter. Why or how would the compiler let you?<br></p><p>The solution is to create your init implementation in a concrete type, and<br>define the let property in there as well. E.g.<br></p><p>protocol Element {<br>    var uuid: UUID { get }<br>}<br></p><p>class Item: Element {<br>    let uuid: UUID<br></p><p>    init(uuid: UUID) {<br>        self.uuid = uuid<br>    }<br>}<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160803/35e23de3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8809800aec2460f291384b794d7e6f8f?s=50"></div><header><strong>Protocol with instance var that&#39;s set on construction, otherwise read-only</strong> from <string>Rick Mann</string> &lt;rmann at latencyzero.com&gt;<p>August  8, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Aug 3, 2016, at 03:23 , Dan Loewenherz &lt;dan at lionheartsw.com&gt; wrote:<br>&gt; <br>&gt; On Wed, Aug 3, 2016 at 3:51 AM, Rick Mann via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; &gt; On Aug 2, 2016, at 19:06 , Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I don’t think it makes sense to do this. A protocol cannot control how a particular property is implemented (stored or computed), and any conforming type must initialize all of its stored properties before returning from its own initializer. (You can’t write an initializer in a protocol that doesn’t delegate to another initializer because you don’t know what other stored properties the conforming type might have.)<br>&gt; &gt;<br>&gt; &gt; Given that the protocol can’t control how the property gets initialized, it doesn’t make sense to allow the protocol to &quot;set the variable, but only in the initializer”.<br>&gt; <br>&gt; Really? It seems pretty natural for a conforming type to set a property once in the initializer, and it&#39;s immutable from then on out. I can do that quite cleanly with classes, but there&#39;s no way (that I know) to describe this using protocols. Ideally, I could just do:<br>&gt; <br>&gt; protocol<br>&gt; Element<br>&gt; {<br>&gt;     let uuid: UUID<br>&gt; }<br>&gt; <br>&gt; which implies that all conforming types must initialize that value on creation, or provide a getter with let semantics (the latter might be too easy to break, and could be disallowed, requiring conforming types to create storage for the property and set it in init()).<br>&gt; <br>&gt; The compiler only knows as much as you tell it, and when you define a protocol and set it as { get } only, it&#39;s not going to let you set that property in a protocol extension for a protocol that doesn&#39;t expect a setter. Why or how would the compiler let you?<br>&gt; <br>&gt; The solution is to create your init implementation in a concrete type, and define the let property in there as well. E.g.<br>&gt; <br>&gt; protocol Element {<br>&gt;     var uuid: UUID { get }<br>&gt; }<br>&gt; <br>&gt; class Item: Element {<br>&gt;     let uuid: UUID<br>&gt; <br>&gt;     init(uuid: UUID) {<br>&gt;         self.uuid = uuid<br>&gt;     }<br>&gt; }<br>&gt; <br></p><p>Because then Element.uuid doesn&#39;t have let semantics. It can&#39;t be set, but it&#39;s not constant.<br></p><p>-- <br>Rick Mann<br>rmann at latencyzero.com<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0f0154768aeec561194e651b0bca02d9?s=50"></div><header><strong>Protocol with instance var that&#39;s set on construction, otherwise read-only</strong> from <string>Dan Loewenherz</string> &lt;dan at lionheartsw.com&gt;<p>August  9, 2016 at 08:00:00am</p></header><div class="content"><p>On Mon, Aug 8, 2016 at 6:16 PM, Rick Mann &lt;rmann at latencyzero.com&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Aug 3, 2016, at 03:23 , Dan Loewenherz &lt;dan at lionheartsw.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; On Wed, Aug 3, 2016 at 3:51 AM, Rick Mann via swift-users &lt;<br>&gt; swift-users at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; &gt; On Aug 2, 2016, at 19:06 , Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; I don’t think it makes sense to do this. A protocol cannot control how<br>&gt; a particular property is implemented (stored or computed), and any<br>&gt; conforming type must initialize all of its stored properties before<br>&gt; returning from its own initializer. (You can’t write an initializer in a<br>&gt; protocol that doesn’t delegate to another initializer because you don’t<br>&gt; know what other stored properties the conforming type might have.)<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; Given that the protocol can’t control how the property gets<br>&gt; initialized, it doesn’t make sense to allow the protocol to &quot;set the<br>&gt; variable, but only in the initializer”.<br>&gt; &gt;<br>&gt; &gt; Really? It seems pretty natural for a conforming type to set a property<br>&gt; once in the initializer, and it&#39;s immutable from then on out. I can do that<br>&gt; quite cleanly with classes, but there&#39;s no way (that I know) to describe<br>&gt; this using protocols. Ideally, I could just do:<br>&gt; &gt;<br>&gt; &gt; protocol<br>&gt; &gt; Element<br>&gt; &gt; {<br>&gt; &gt;     let uuid: UUID<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; which implies that all conforming types must initialize that value on<br>&gt; creation, or provide a getter with let semantics (the latter might be too<br>&gt; easy to break, and could be disallowed, requiring conforming types to<br>&gt; create storage for the property and set it in init()).<br>&gt; &gt;<br>&gt; &gt; The compiler only knows as much as you tell it, and when you define a<br>&gt; protocol and set it as { get } only, it&#39;s not going to let you set that<br>&gt; property in a protocol extension for a protocol that doesn&#39;t expect a<br>&gt; setter. Why or how would the compiler let you?<br>&gt; &gt;<br>&gt; &gt; The solution is to create your init implementation in a concrete type,<br>&gt; and define the let property in there as well. E.g.<br>&gt; &gt;<br>&gt; &gt; protocol Element {<br>&gt; &gt;     var uuid: UUID { get }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; class Item: Element {<br>&gt; &gt;     let uuid: UUID<br>&gt; &gt;<br>&gt; &gt;     init(uuid: UUID) {<br>&gt; &gt;         self.uuid = uuid<br>&gt; &gt;     }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt;<br>&gt; Because then Element.uuid doesn&#39;t have let semantics. It can&#39;t be set, but<br>&gt; it&#39;s not constant.<br>&gt;<br></p><p>It&#39;s unavoidable. In this case, whether a variable can be set only once or<br>more than once is an implementation detail that you need to deal with in a<br>concrete type. What you&#39;re looking for would be a new feature, like<br>&quot;setonce&quot;. But let&#39;s assume the language designers added that in, how would<br>it work?<br></p><p>protocol Element {<br>    var uuid: UUID { get setonce }<br>}<br></p><p>And somewhere in your codebase, you have something like this:<br></p><p>for element in elements {<br>    element.uuid = UUID()<br>}<br></p><p>The problem is that whether or not &quot;uuid&quot; is set can only be decided at<br>runtime. As a result, the type checker can&#39;t tell you if you&#39;re making a<br>mistake. It has no way to know if you&#39;ve already set the value of &quot;uuid&quot;<br>somewhere else, e.g., through a UI interaction, or some other code that&#39;s<br>based on state.<br></p><p>The result is that if &quot;uuid&quot; happens to already be set, you&#39;d get a runtime<br>error, which would be a very un-Swift-y thing to do, or every assignment<br>would need to get wrapped in some sort of error handler.<br></p><p>Dan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160809/41b262ab/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>Protocol with instance var that&#39;s set on construction, otherwise read-only</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>August  9, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On 3 Aug 2016, at 02:01, Rick Mann via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; It complains if I make it a let because computed properties must be var. Because it&#39;s a protocol, it can&#39;t be stored (even though it can be stored in the conforming type).<br>&gt; <br>&gt; If I make it { get }, I can&#39;t set it in the extensions init() method.<br>&gt; <br>&gt; I guess I could make it private set (not sure of the syntax for that), but it still doesn&#39;t have let semantics.<br></p><p>It sounds like you should put the calculation function in the protocol extension, the property in the protocol, and let conforming types decide how to store that property (and when to calculate it).<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160809/3c2bb975/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8809800aec2460f291384b794d7e6f8f?s=50"></div><header><strong>Protocol with instance var that&#39;s set on construction, otherwise read-only</strong> from <string>Rick Mann</string> &lt;rmann at latencyzero.com&gt;<p>August  9, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Aug 9, 2016, at 08:24 , Karl &lt;razielim at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 3 Aug 2016, at 02:01, Rick Mann via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; It complains if I make it a let because computed properties must be var. Because it&#39;s a protocol, it can&#39;t be stored (even though it can be stored in the conforming type).<br>&gt;&gt; <br>&gt;&gt; If I make it { get }, I can&#39;t set it in the extensions init() method.<br>&gt;&gt; <br>&gt;&gt; I guess I could make it private set (not sure of the syntax for that), but it still doesn&#39;t have let semantics.<br>&gt; <br>&gt; It sounds like you should put the calculation function in the protocol extension, the property in the protocol, and let conforming types decide how to store that property (and when to calculate it).<br></p><p>That still doesn&#39;t mean that someone on the outside looking in at Element sees let semantics.<br></p><p>-- <br>Rick Mann<br>rmann at latencyzero.com<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
