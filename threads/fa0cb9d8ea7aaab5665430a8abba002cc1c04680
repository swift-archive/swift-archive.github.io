<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>February 10, 2016 at 02:00:00pm</p></header><div class="content"><p>Hello Swift community,<br></p><p>The review of SE-0030 &quot;Property Behaviors&quot; begins now and runs through February, 2016. The proposal is available here:<br></p><p>https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-proposal.md&gt;<br>Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br></p><p>https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br></p><p>Proposal link:<br></p><p>https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md<br>Reply text<br></p><p>Other replies<br> &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What goes into a review?<br></p><p>The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br></p><p>What is your evaluation of the proposal?<br>Is the problem being addressed significant enough to warrant a change to Swift?<br>Does this proposal fit well with the feel and direction of Swift?<br>If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>More information about the Swift evolution process is available at<br></p><p>https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>Thank you,<br></p><p>Doug Gregor<br></p><p>Review Manager<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution-announce/attachments/20160210/fa0c4680/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Review extension] SE-0030 Property Behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February 15, 2016 at 02:00:00pm</p></header><div class="content"><p>Hi everyone. In response to feedback, I&#39;ve extended the review period for SE-0030 for another week. I&#39;ve also decided to subset out member access from the initial proposal, as in accessing `x.[lazy].clear()` or other behavior-provided methods on a property. There&#39;s a lot of contention about the syntax, of course, but Michel Fortin and private reviewers have made good points that tying these &quot;out-of-band&quot; non-type members to properties is a feature that may not be best expressed as part of behaviors. Like many of the other topics that were factored out, the design space is deep enough that out-of-band member access deserves a design and review of its own. Thank you all for the feedback so far!<br></p><p>-Joe<br></p><p>&gt; On Feb 10, 2016, at 2:00 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of SE-0030 &quot;Property Behaviors&quot; begins now and runs through February, 2016. The proposal is available here:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-proposal.md&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br>&gt; <br>&gt; Proposal link:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md&gt;<br>&gt; Reply text<br>&gt; <br>&gt; Other replies<br>&gt;  &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; What is your evaluation of the proposal?<br>&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt; Thank you,<br>&gt; <br>&gt; Doug Gregor<br>&gt; <br>&gt; Review Manager<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution-announce/attachments/20160215/6bb519ef/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>[Review extension] SE-0030 Property Behaviors</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>February 19, 2016 at 09:00:00pm</p></header><div class="content"><p>I personally like the functionality outlined in this proposal. Also *tip of<br>my hat* to those that have put together this proposal and prototype<br>implementation.<br></p><p>The biggest issue seems to be the syntax for it and it is becoming hard to<br>follow the discussion thread given all the – often nicely – outlined<br>alternatives.<br></p><p>I guess it isn&#39;t clear what of the alternatives are seriously being<br>considered, etc. ... as well as the state of the proposal potentially<br>incorporating these alternates.<br></p><p>If property behaviors are likely to be user definable in addition to a<br>canned set of behaviors provided by the standard library then I feel we<br>should attempt to avoid yet another methodology of name-spacing /<br>extending. I feel we should attempt to leverage existing language<br>methodologies as possible (for example the suggestion around consider<br>behaviors as an extension to var and let, etc.).<br></p><p>I don&#39;t have anything really to propose along those lines (still trying to<br>get a lot worked out in my head) but I wanted to express my first gut<br>feeling on this.<br></p><p>-Shawn<br></p><p><br>On Mon, Feb 15, 2016 at 2:38 PM Joe Groff via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hi everyone. In response to feedback, I&#39;ve extended the review period for<br>&gt; SE-0030 for another week. I&#39;ve also decided to subset out *member access*<br>&gt; from the initial proposal, as in accessing `x.[lazy].clear()` or other<br>&gt; behavior-provided methods on a property. There&#39;s a lot of contention about<br>&gt; the syntax, of course, but Michel Fortin and private reviewers have made<br>&gt; good points that tying these &quot;out-of-band&quot; non-type members to properties<br>&gt; is a feature that may not be best expressed as part of behaviors. Like many<br>&gt; of the other topics that were factored out, the design space is deep enough<br>&gt; that out-of-band member access deserves a design and review of its own.<br>&gt; Thank you all for the feedback so far!<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt; On Feb 10, 2016, at 2:00 PM, Douglas Gregor via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Hello Swift community,<br>&gt;<br>&gt; The review of SE-0030 &quot;Property Behaviors&quot; begins now and runs through<br>&gt; February, 2016. The proposal is available here:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md<br>&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-proposal.md&gt;<br>&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt; should be sent to the swift-evolution mailing list at<br>&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the<br>&gt; review manager. When replying, please try to keep the proposal link at the<br>&gt; top of the message:<br>&gt;<br>&gt; Proposal link:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md<br>&gt;<br>&gt; Reply text<br>&gt;<br>&gt; Other replies<br>&gt;<br>&gt; &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What<br>&gt; goes into a review?<br>&gt;<br>&gt; The goal of the review process is to improve the proposal under review<br>&gt; through constructive criticism and, eventually, determine the direction of<br>&gt; Swift. When writing your review, here are some questions you might want to<br>&gt; answer in your review:<br>&gt;<br>&gt;    - What is your evaluation of the proposal?<br>&gt;    - Is the problem being addressed significant enough to warrant a<br>&gt;    change to Swift?<br>&gt;    - Does this proposal fit well with the feel and direction of Swift?<br>&gt;    - If you have used other languages or libraries with a similar<br>&gt;    feature, how do you feel that this proposal compares to those?<br>&gt;    - How much effort did you put into your review? A glance, a quick<br>&gt;    reading, or an in-depth study?<br>&gt;<br>&gt; More information about the Swift evolution process is available at<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;<br>&gt; Thank you,<br>&gt;<br>&gt; Doug Gregor<br>&gt;<br>&gt; Review Manager<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160219/08647234/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0030 Property Behaviors</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>February 10, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Feb 10, 2016, at 2:00 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of SE-0030 &quot;Property Behaviors&quot; begins now and runs through February, 2016. The proposal is available here:<br>&gt; <br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md&gt;<br>Through February 16, that is.<br></p><p>	- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160210/1455f066/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ab486d7597af4cfe0be33a762150848?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0030 Property Behaviors</strong> from <string>Dany St-Amant</string> &lt;dsa.mls at icloud.com&gt;<p>February 10, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; Le 10 févr. 2016 à 17:04, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 10, 2016, at 2:00 PM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello Swift community,<br>&gt;&gt; <br>&gt;&gt; The review of SE-0030 &quot;Property Behaviors&quot; begins now and runs through February, 2016. The proposal is available here:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md&gt;<br>&gt; Through February 16, that is.<br>&gt; <br></p><p>I hope you’ll forgive me for a not really constructive comment, but living in the country neighbouring the USA to the north, I’ll have hard time not typing the « u » in this new behaviour keyword. I do not want to start a war on which English is the proper one, after all if one do not like the wording of an API he can always create wrappers, but for main language keyword such thing is impossible in Swift.<br></p><p>At least the behaviour keyword is one that is not used that often in single file, so I’ll survive.<br>But I thought it was worth mentioning that not everyone use the same English dictionary.<br></p><p>Dany<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160210/100a7d0a/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0030 Property Behaviors</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February 10, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; The review of SE-0030 &quot;Property Behaviors&quot; begins now and runs through February, 2016. The proposal is available here:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md<br></p><p>I&#39;m afraid that, although the address as written here is correct, the href attribute on the link is not. You&#39;ll need to copy and paste the address, not click on the link.<br></p><p>Given the frequent mistakes in review announcements (it&#39;s not just you, Doug, I&#39;ve seen this happen during reviews managed by others too), perhaps someone should write a bot that monitors swift-evolution/master&#39;s schedule.md and generates these messages automatically. :^)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0030 Property Behaviors</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February 10, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md<br></p><p><br>As for the proposal itself:<br></p><p>&gt; 	• What is your evaluation of the proposal?<br></p><p>+1 with no changes suggested.<br></p><p>I do, however, have one caveat: this proposal is a good core for property behaviors, but alone, I don&#39;t think it carries its own weight. It will need at least a couple of the items in &quot;Future Directions&quot; section before it&#39;s really worth having. If we find we&#39;re not able to get those things proposed and accepted, we may want to reconsider whether we should add the feature at all.<br></p><p>Overall, though, I&#39;m eagerly anticipating this feature.<br></p><p>&gt; 	• Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes. Special behavior tied to properties is one of the largest sources of boilerplate in Swift, and allowing that boilerplate to be factored out is an extremely welcome step. Ever since the discussions about behaviors first started, I&#39;ve been keeping an eye out for places I would use them if they were available, and I&#39;ve spotted many such cases in my code.<br></p><p>&gt; 	• Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes. Eventually, this proposal should allow us to rework many ad-hoc features of Swift properties into standard library features. This approach is very, very Swifty.<br></p><p>&gt; 	• If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>I&#39;ve used metaprogramming in Ruby and Objective-C to do broadly similar factoring in a different way, by generating accessors at runtime based on pseudo-declarative code. The behaviors approach is less flexible, because it has to be extended for each capability we want to add, but it&#39;s also *far* easier to use correctly.<br></p><p>I also have experience with the Perl 6 approach (I haven&#39;t actually used the final Perl 6, but I was active in its design process, and actually wrote a proof-of-concept CMS for Pugs as a Summer of Code project). Perl 6 does this quite differently; essentially, it makes the variable an object of its own, separate from the value stored in it, and allows you to apply roles (traits/mixins) to the variable in order to customize its behavior. This is a very, very powerful approach, but it would most likely introduce more overhead than is appropriate for Swift, which aspires to be a systems language.<br></p><p>&gt; 	• How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I participated quite heavily in the preliminary discussions and submitted detailed critiques at that time; it&#39;s probably safe to say that I have not suggested any changes because my suggestions have already been discussed and incorporated where appropriate. I&#39;ve also been keeping an eye out in my Swift codebases for places where I would have used behaviors if they were available.<br></p><p>For this review specifically, I re-read the proposal from top to bottom.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0030 Property Behaviors</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>February 10, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Feb 10, 2016, at 3:53 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md<br>&gt; <br>&gt; <br>&gt; I do, however, have one caveat: this proposal is a good core for property behaviors, but alone, I don&#39;t think it carries its own weight. It will need at least a couple of the items in &quot;Future Directions&quot; section before it&#39;s really worth having. If we find we&#39;re not able to get those things proposed and accepted, we may want to reconsider whether we should add the feature at all.<br></p><p>FWIW, I agree with this.  I see this as a step in the right direction, not the full answer.  I also expect some iteration  and refinement (in future proposals) based on usage experience.  This is what we’ve seen for all other “big” features that have gone in in the past.<br></p><p>-Chris<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d04f3c48ab68a1dd3e712dcab04004ce?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Curt Clifton</string> &lt;curt at omnigroup.com&gt;<p>February 10, 2016 at 07:00:00pm</p></header><div class="content"><p>Original proposal: https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md<br></p><p># What is your evaluation of the proposal?<br></p><p>I am strongly in favor of the proposal. While I eagerly await some of the work described in future directions—binding the name of the property, in particular—I think the proposal stands tall on its own.<br></p><p># Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes. Property behaviors provide a well-founded mechanism to replace several existing special cases in the language. The new mechanism is orthogonal to existing language features, so it actually simplifies the language versus having special cases. As a general tool, it will help developers to eliminate substantial boilerplate in a principled way.<br></p><p># Does this proposal fit well with the feel and direction of Swift?<br></p><p>Mostly certainly! Like Brent, I&#39;ve been looking for places in my daily work that could benefit from property behaviors. These come up surprisingly often.<br></p><p># If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>I&#39;ve used both KVC and dynamic method generation in Objective-C for achieving some of the aims satisfied by property behaviors. I expect that property behaviors will prove to be a more approachable and less error prone solution.<br></p><p># How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I read all of the preceding discussions and participated in them lightly (2-3 emails sent). I closely read every public draft of the proposal.<br></p><p>Cheers,  <br></p><p>Curt<br></p><p>-------------------------<br>Curt Clifton, PhD <br>Software Developer <br>The Omni Group <br>www.curtclifton.net<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>February 10, 2016 at 10:00:00pm</p></header><div class="content"><p>On Feb 10, 2016, at 2:00 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Proposal link:<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md&gt;<br>&gt;  &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; What is your evaluation of the proposal?<br>I’m +1 on the feature.  I have some comments for discussion though, I’m sorry I didn’t get these to you before the formal proposal went out:<br></p><p><br></p><p>First, on the most obvious bikeshed, the surface level syntax proposed:<br></p><p>	var [lazy] foo = 1738<br>	foo.[lazy].clear()<br></p><p><br>Given the recent trend to use # for compiler synthesized / macroish / magic syntax, it is worth considering whether:<br></p><p>	var #lazy foo = 1738<br>	foo.#lazy.clear()<br></p><p>might make sense, or even:<br></p><p>	 #lazy var foo = 1738<br></p><p>I think that something like this is a bit better aesthetically, since the [] delimiters are heavily array/collection/subscript-centric (which is a good thing).  OTOH, this would be giving users access to the “#” namespace, which means that future conflicts would have to be resolved with backticks - e.g. if they wanted a “line” behavior, they’d have to use &quot;var #`line` foo = 1738”. I guess the fact that we already have a solution to the imagined problem means that this isn’t a big concern in practice.<br></p><p>In any case, I think we should just pick a syntax, land the feature, and keep bikeshedding on it through the end of Swift 3 :-)<br></p><p><br></p><p>What are the semantics of behaviors applied to var/let decls with non-trivial patterns?  For example:<br></p><p>	var [lazy] (foo, bar) = qux()<br></p><p>?  While we could devise semantics for this in some cases, I think it is reasonable to only allow behaviors on single-identifier patterns, and reject the other cases as invalid.  If you agree, please loop that into the proposal.<br></p><p><br></p><p>I understand the need to specifying whether the getter/setter and other random methods are mutating or not, but doesn’t this eliminate the difference between a var/let behavior?  Couldn’t we just say that a behavior with a nonmutating getter &amp; setter are valid on a “let”, and that any other mutating members are unavailable on a let?  This seems like a theoretical win, though I’m not sure whether it would actually be a win in practice for any conceivable behaviors you’ve been thinking about.<br></p><p><br></p><p>I like the approach of having a behavior decl, but am not excited about the decl syntax itself:<br>behavior var [lazy] _: Value = initialValue {<br></p><p>I understand that this is intended to provide a template-like construct, but I have a few problems with this:<br></p><p>1) A number of the things here are actually totally invariant (e.g. the _, the colon) or only serve to provide a name (Value, initialValue) but cannot be expanded into general expressions, though they look like they are.<br></p><p>2) This is totally unprecedented in Swift.  We have a very regular structure of “@attributes decl-modifiers introducer_keyword name” - we have no declarations that look like this.  For example, while operator decls could follow this structure, they don’t.<br></p><p>3) If you agree that we don’t need to differentiate between var/let then “behavior var&quot; is providing potentially misleading info.<br></p><p>IMO, the most regular decl structure would be:<br></p><p>@initial_value_required      // or something like it.<br>property behavior lazy {      // could be “subscript behavior” at some point in the future?<br>   var value: Self? = nil        // Self is the property type?  Seems weird if it is the enclosing type.<br>   ...<br>}<br></p><p>or perhaps:<br></p><p>@initial_value_required<br>property behavior lazy&lt;PropertyType&gt; {  // specify the type of the property as a generic constraint?<br>   var value: PropertyType? = nil   <br>   ...<br>}<br></p><p>though I agree that this would require us to take “behavior” as a keyword.  Do we know whether or not this would be a problem in practice?  If so, going with “behavior var” and “behavior let” is probably ok.<br></p><p><br>Of course, @initial_value_required is also pretty gross.  The alternative is to follow the precedent of operator decls, and introduce random syntax in their body, such as:<br></p><p>property behavior lazy&lt;PropertyType&gt; {<br>   initializer initValue<br>   var value: PropertyType? = nil   <br>   …<br>       value = initValue<br>   ...<br>}<br></p><p><br></p><p><br>  // Behaviors can declare storage that backs the property.<br>  private var value: Value?<br></p><p>What is the full range of access control allowed here?  Is there any reason to allow anything other than “public” (which would mean that the entity is exposed at whatever the properties access control level is)?  If so, why allow specifying internal?  For sake of exposition in the proposal, it seems simplest to say:<br></p><p>var value: Value?  // private by default<br></p><p>or something.<br></p><p><br></p><p><br>  // Behaviors can declare initialization logic for the storage.<br>  // (Stored properties can also be initialized in-line.)<br>  init() {<br>    value = nil<br>  }<br></p><p>If a behavior has an init() with no arguments, then are the semantics that it is *always* run?  What if there are both an init() and an init(value : Value)?<br></p><p><br> // Inline initializers are also supported, so `var value: Value? = nil`<br>  // would work equivalently.<br></p><p>This example is using a stored property of type Optional&lt;Value&gt; which has a default value of nil, does that count or is this a syntactic requirement?  To me, it seems most natural to follow the existing rules we have:<br></p><p>1) If you write any init, then you get what you write.<br>2) If there are no init’s, and any stored property in a behavior is non-default initializable, then it is an error.<br>3) If there are no init’s, and all stored properties in a behavior are default initializable, then you get init() implicitly.<br></p><p><br></p><p>Typographical comment:<br>    if let value = value {<br>      return value<br>    }<br></p><p>You have way too many “value”s floating around, for sake of clarity, how about:<br></p><p>    if let valuePresent = value {<br>      return valuePresent<br>    }<br></p><p><br>In &quot;Resettable properties”, you have this:<br></p><p>  // Reset the property to its original initialized value.<br>  mutating func reset() {<br>    value = initialValue<br>  }<br></p><p>This raises the question of how “initialValue” works:  Is it evaluated once when the property is bound and the resultant value is stored somewhere (evaluating any side effects exactly once) or is it an auto-closure-like concept?  If it is autoclosure-like, what does it mean in terms of requiring “self.&quot; qualification &amp; @noescape?<br></p><p><br>In the context of your @NSCopying-replacement example, I would want something like this:<br></p><p>class Foo {<br>  var [copying] myproperty : NSString<br></p><p>  init(a : NSString) {<br>     myproperty = a<br>  }<br>}<br></p><p>to work, where the behavior requires an initial value, but that value is provided by a flow-sensitive initialization point by DI .  How does this happen?<br></p><p><br></p><p>&quot;This imposes an initializer requirement on the behavior. Any property using the behavior must be declared with an initial value&quot;<br></p><p>Ah, this gets to the @NSCopying replacement example.  This might be too limiting, but so long as there is a path forward to generalize this, it seems like a fine starting point.<br></p><p>[[Coming back to this after reading to the end]] Ok, I see this is in the future directions section.  I’m fine with punting this to a further revision of the proposal, but I think that it is worthwhile to provide a syntactic affordance to differentiate properties that “must have an initializer expression” and “must be initialized by an &#39;init(v: Value)’ member on the behavior before otherwise used”.  @NSCopying replacement seems like the later case.  I’m fine with pushing off the general case to a later proposal, but we should carve out space for it to fit in.<br></p><p><br></p><p><br></p><p>public behavior var [changeObserved] _: Value = initialValue {<br>...<br>   <br>    if oldValue != newValue {<br></p><p><br>This makes me vaguely uncomfortable, given that “changeObserved” has undeclared type requirements that are only diagnosed when the behavior is instantiated.  I’d greatly prefer to see something like:<br></p><p>@initial_value_required<br>property behavior changeObserved&lt;PropertyType : Equatable&gt; {  // constraint specified!<br></p><p>which would allow the behavior to be modularly type checked.<br></p><p>[[later…]] ah, I see that you’re doing something similar but different in the &quot;Synchronized Property Access” example.  I mostly care that we can express and modularly check this, the exact syntax isn’t as important.<br></p><p><br></p><p><br>In detailed design:<br>property-behavior-decl ::=<br>  attribute* decl-modifier*<br>  &#39;behavior&#39; &#39;var&#39; &#39;[&#39; identifier &#39;]&#39; // behavior name<br>  (identifier | &#39;_&#39;)                  // property name binding<br>If you go with this declaration syntax, I’d suggest requiring _ for the name, since the name isn’t otherwise used for anything.  Ah, it looks like you say this later, maybe the grammar just needs to be updated?<br>A _ placeholder is required in the name position. (A future extension of behaviors may allow the property name to be bound as a string literal here.)<br></p><p><br></p><p><br>&quot;Inside a behavior declaration, self is implicitly bound to the value that contains the property instantiated using this behavior. For a freestanding property at global or local scope, this will be the empty tuple (), and for a static or class property, this will be the metatype. Within the behavior declaration, the type of self is abstract and represented by the implicit generic type parameter Self.&quot;<br></p><p>This is somewhat strange to me.  Would it be reasonable to say that self is bound iff the behavior has a classbound requirement on Self?  Alternatively, perhaps you could somehow declare/name the declcontext type, and refer to it later by a name other than Self?<br></p><p>  mutating func update(x: Int) {<br>    [foo].x = x // Disambiguate reference to behavior storage<br>  }<br></p><p>It would be really nice to be able to keep “self” referring to the behavior, and require an explicit declaration for the enclosing declaration if a behavior requires one (e.g. in the case of atomic).<br></p><p><br></p><p><br></p><p>&quot;Nested Types in Behaviors”<br></p><p>This sounds great in the fullness of time, but it seems subsettable out of the first implementation/proposal.  Lacking this, it can be easily worked around with a private peer type.<br></p><p><br></p><p><br></p><p>    // Parameter gets the name &#39;bas&#39; from the accessor requirement<br>    // by default, as with built-in accessors today.<br></p><p><br>Not really important for the v1 proposal, but it seems like a natural direction to allow this to be controlled by “API names” in the accessor.  The default would be that there are no API names, but if a behavior specified one, e.g.:<br></p><p>		willSet(newValue newValue : Value)  <br></p><p>then “newValue” would be the default name in the body of the accessor.  If no “API name” were specified, then no name would be default injected.<br></p><p><br>Typographical comment w.r.t. the &quot;// Reinvent computed properties” example, you refer to the behavior as both “foobar” and “computed” later, I think the later reference is supposed to be &quot;var [foobar] bar: Int”?  Feel free to find more diversity in your metasyntactic names here :-)<br></p><p><br></p><p><br></p><p>&quot;Accessor requirements cannot take visibility modifiers; they are always as visible as the behavior itself.&quot;<br></p><p>Maybe I’m misinterpreting this, but I see accessors differently.  I see them as “never being accessible to the code that declares a property using the behavior”.  If you want this, you can define a method that wraps them or something.  To a client of a behaviors, accessors are “implementation only”.<br></p><p><br></p><p><br>Can property requirements in protocols have behaviors on them?<br></p><p><br></p><p>&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>Yep.<br></p><p>&gt; Does this proposal fit well with the feel and direction of Swift?<br>Yep, moving generalizing special case hacks and moving them out of the compiler is a great direction.<br></p><p>&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>I have not.<br></p><p>&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>I’m spent a lot of time following the discussion and chatting with Joe about this periodically, starting when Dmitri pointed out this possible direction back in Dec 2014. :-)<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160210/ac4fc157/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>February 11, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; What is your evaluation of the proposal?<br>I agree with a number of people that have already replied before me: I think this is a very exiting proposal, but as it is right now, its not 100% fleshed out. Chris and other already provided comments on a number of points that also came to my mind. Specifically, I am not very keen on the proposed v.[foo] syntax and also the declaration of behaviours looks off to me as well (even though its elegant in its own right). I’d prefer something like<br></p><p>property behavior foo&lt;valueType: Value, instanceType: Self where …&gt; {<br></p><p>}<br></p><p>e.g. where we take the already available generics syntax and extend it with arguments to signal that behaviours are generics over multiple specific dimensions (this can be also used for a future extension of generic types). Required initial value can be coded by a presence of a constructor that takes mandatory argument, for example, or by an attribute as Chris suggests.<br></p><p>One potential problem with a feature like this is that it is very fundamental —it affects many areas of the language, some of those in a non-trivial way. These things are hard to get from the first go. I’d suggest that one makes an experimental implementation first and lets a bunch of people test-drive it for a couple of weeks or even months. I am sure that there will be some subtle design decisions that one might regret later. <br></p><p>So yes, its a definitive +1 but of the kind “revise and resubmit”. Also, sole real-world testing should be done before feature like this is be accepted into the core language. I also believe that fundamental, non-trivial features like these are best designed in a team. <br></p><p>&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>Yes. it makes the language more consistent and flexible, while removing idiosyncrazy. I am also sure that it will open up new possibilities for the UI framework teams to come up with great APIs :)<br></p><p>&gt; Does this proposal fit well with the feel and direction of Swift?<br>Yes, definitely <br></p><p>&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>I have used Python that has a very similar feature (property descriptors) quite extensively, and I have implemented many different patterns using this mechanism (such as property observing and binding). I have also implemented something similar for R.  I believe that Joe’s proposal is much better thought out and fits the overall theme of a strongly typed language very well. <br></p><p>&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>A quick reading. I was also following the discussion, but its a bit difficult to keep up — watching the swift-evolution list is more like a full-time job :)<br></p><p>— Taras<br></p><p>&gt; On 11 Feb 2016, at 07:13, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Feb 10, 2016, at 2:00 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Proposal link:<br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md&gt;<br>&gt;&gt;  &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What goes into a review?<br>&gt;&gt; <br>&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt; <br>&gt;&gt; What is your evaluation of the proposal?<br>&gt; I’m +1 on the feature.  I have some comments for discussion though, I’m sorry I didn’t get these to you before the formal proposal went out:<br>&gt; <br>&gt; <br>&gt; <br>&gt; First, on the most obvious bikeshed, the surface level syntax proposed:<br>&gt; <br>&gt; 	var [lazy] foo = 1738<br>&gt; 	foo.[lazy].clear()<br>&gt; <br>&gt; <br>&gt; Given the recent trend to use # for compiler synthesized / macroish / magic syntax, it is worth considering whether:<br>&gt; <br>&gt; 	var #lazy foo = 1738<br>&gt; 	foo.#lazy.clear()<br>&gt; <br>&gt; might make sense, or even:<br>&gt; <br>&gt; 	 #lazy var foo = 1738<br>&gt; <br>&gt; I think that something like this is a bit better aesthetically, since the [] delimiters are heavily array/collection/subscript-centric (which is a good thing).  OTOH, this would be giving users access to the “#” namespace, which means that future conflicts would have to be resolved with backticks - e.g. if they wanted a “line” behavior, they’d have to use &quot;var #`line` foo = 1738”. I guess the fact that we already have a solution to the imagined problem means that this isn’t a big concern in practice.<br>&gt; <br>&gt; In any case, I think we should just pick a syntax, land the feature, and keep bikeshedding on it through the end of Swift 3 :-)<br>&gt; <br>&gt; <br>&gt; <br>&gt; What are the semantics of behaviors applied to var/let decls with non-trivial patterns?  For example:<br>&gt; <br>&gt; 	var [lazy] (foo, bar) = qux()<br>&gt; <br>&gt; ?  While we could devise semantics for this in some cases, I think it is reasonable to only allow behaviors on single-identifier patterns, and reject the other cases as invalid.  If you agree, please loop that into the proposal.<br>&gt; <br>&gt; <br>&gt; <br>&gt; I understand the need to specifying whether the getter/setter and other random methods are mutating or not, but doesn’t this eliminate the difference between a var/let behavior?  Couldn’t we just say that a behavior with a nonmutating getter &amp; setter are valid on a “let”, and that any other mutating members are unavailable on a let?  This seems like a theoretical win, though I’m not sure whether it would actually be a win in practice for any conceivable behaviors you’ve been thinking about.<br>&gt; <br>&gt; <br>&gt; <br>&gt; I like the approach of having a behavior decl, but am not excited about the decl syntax itself:<br>&gt; behavior var [lazy] _: Value = initialValue {<br>&gt; <br>&gt; I understand that this is intended to provide a template-like construct, but I have a few problems with this:<br>&gt; <br>&gt; 1) A number of the things here are actually totally invariant (e.g. the _, the colon) or only serve to provide a name (Value, initialValue) but cannot be expanded into general expressions, though they look like they are.<br>&gt; <br>&gt; 2) This is totally unprecedented in Swift.  We have a very regular structure of “@attributes decl-modifiers introducer_keyword name” - we have no declarations that look like this.  For example, while operator decls could follow this structure, they don’t.<br>&gt; <br>&gt; 3) If you agree that we don’t need to differentiate between var/let then “behavior var&quot; is providing potentially misleading info.<br>&gt; <br>&gt; IMO, the most regular decl structure would be:<br>&gt; <br>&gt; @initial_value_required      // or something like it.<br>&gt; property behavior lazy {      // could be “subscript behavior” at some point in the future?<br>&gt;    var value: Self? = nil        // Self is the property type?  Seems weird if it is the enclosing type.<br>&gt;    ...<br>&gt; }<br>&gt; <br>&gt; or perhaps:<br>&gt; <br>&gt; @initial_value_required<br>&gt; property behavior lazy&lt;PropertyType&gt; {  // specify the type of the property as a generic constraint?<br>&gt;    var value: PropertyType? = nil   <br>&gt;    ...<br>&gt; }<br>&gt; <br>&gt; though I agree that this would require us to take “behavior” as a keyword.  Do we know whether or not this would be a problem in practice?  If so, going with “behavior var” and “behavior let” is probably ok.<br>&gt; <br>&gt; <br>&gt; Of course, @initial_value_required is also pretty gross.  The alternative is to follow the precedent of operator decls, and introduce random syntax in their body, such as:<br>&gt; <br>&gt; property behavior lazy&lt;PropertyType&gt; {<br>&gt;    initializer initValue<br>&gt;    var value: PropertyType? = nil   <br>&gt;    …<br>&gt;        value = initValue<br>&gt;    ...<br>&gt; }<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt;   // Behaviors can declare storage that backs the property.<br>&gt;   private var value: Value?<br>&gt; <br>&gt; What is the full range of access control allowed here?  Is there any reason to allow anything other than “public” (which would mean that the entity is exposed at whatever the properties access control level is)?  If so, why allow specifying internal?  For sake of exposition in the proposal, it seems simplest to say:<br>&gt; <br>&gt; var value: Value?  // private by default<br>&gt; <br>&gt; or something.<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt;   // Behaviors can declare initialization logic for the storage.<br>&gt;   // (Stored properties can also be initialized in-line.)<br>&gt;   init() {<br>&gt;     value = nil<br>&gt;   }<br>&gt; <br>&gt; If a behavior has an init() with no arguments, then are the semantics that it is *always* run?  What if there are both an init() and an init(value : Value)?<br>&gt; <br>&gt; <br>&gt;  // Inline initializers are also supported, so `var value: Value? = nil`<br>&gt;   // would work equivalently.<br>&gt; <br>&gt; This example is using a stored property of type Optional&lt;Value&gt; which has a default value of nil, does that count or is this a syntactic requirement?  To me, it seems most natural to follow the existing rules we have:<br>&gt; <br>&gt; 1) If you write any init, then you get what you write.<br>&gt; 2) If there are no init’s, and any stored property in a behavior is non-default initializable, then it is an error.<br>&gt; 3) If there are no init’s, and all stored properties in a behavior are default initializable, then you get init() implicitly.<br>&gt; <br>&gt; <br>&gt; <br>&gt; Typographical comment:<br>&gt;     if let value = value {<br>&gt;       return value<br>&gt;     }<br>&gt; <br>&gt; You have way too many “value”s floating around, for sake of clarity, how about:<br>&gt; <br>&gt;     if let valuePresent = value {<br>&gt;       return valuePresent<br>&gt;     }<br>&gt; <br>&gt; <br>&gt; In &quot;Resettable properties”, you have this:<br>&gt; <br>&gt;   // Reset the property to its original initialized value.<br>&gt;   mutating func reset() {<br>&gt;     value = initialValue<br>&gt;   }<br>&gt; <br>&gt; This raises the question of how “initialValue” works:  Is it evaluated once when the property is bound and the resultant value is stored somewhere (evaluating any side effects exactly once) or is it an auto-closure-like concept?  If it is autoclosure-like, what does it mean in terms of requiring “self.&quot; qualification &amp; @noescape?<br>&gt; <br>&gt; <br>&gt; In the context of your @NSCopying-replacement example, I would want something like this:<br>&gt; <br>&gt; class Foo {<br>&gt;   var [copying] myproperty : NSString<br>&gt; <br>&gt;   init(a : NSString) {<br>&gt;      myproperty = a<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; to work, where the behavior requires an initial value, but that value is provided by a flow-sensitive initialization point by DI .  How does this happen?<br>&gt; <br>&gt; <br>&gt; <br>&gt; &quot;This imposes an initializer requirement on the behavior. Any property using the behavior must be declared with an initial value&quot;<br>&gt; <br>&gt; Ah, this gets to the @NSCopying replacement example.  This might be too limiting, but so long as there is a path forward to generalize this, it seems like a fine starting point.<br>&gt; <br>&gt; [[Coming back to this after reading to the end]] Ok, I see this is in the future directions section.  I’m fine with punting this to a further revision of the proposal, but I think that it is worthwhile to provide a syntactic affordance to differentiate properties that “must have an initializer expression” and “must be initialized by an &#39;init(v: Value)’ member on the behavior before otherwise used”.  @NSCopying replacement seems like the later case.  I’m fine with pushing off the general case to a later proposal, but we should carve out space for it to fit in.<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; public behavior var [changeObserved] _: Value = initialValue {<br>&gt; ...<br>&gt;    <br>&gt;     if oldValue != newValue {<br>&gt; <br>&gt; <br>&gt; This makes me vaguely uncomfortable, given that “changeObserved” has undeclared type requirements that are only diagnosed when the behavior is instantiated.  I’d greatly prefer to see something like:<br>&gt; <br>&gt; @initial_value_required<br>&gt; property behavior changeObserved&lt;PropertyType : Equatable&gt; {  // constraint specified!<br>&gt; <br>&gt; which would allow the behavior to be modularly type checked.<br>&gt; <br>&gt; [[later…]] ah, I see that you’re doing something similar but different in the &quot;Synchronized Property Access” example.  I mostly care that we can express and modularly check this, the exact syntax isn’t as important.<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; In detailed design:<br>&gt; property-behavior-decl ::=<br>&gt;   attribute* decl-modifier*<br>&gt;   &#39;behavior&#39; &#39;var&#39; &#39;[&#39; identifier &#39;]&#39; // behavior name<br>&gt;   (identifier | &#39;_&#39;)                  // property name binding<br>&gt; If you go with this declaration syntax, I’d suggest requiring _ for the name, since the name isn’t otherwise used for anything.  Ah, it looks like you say this later, maybe the grammar just needs to be updated?<br>&gt; A _ placeholder is required in the name position. (A future extension of behaviors may allow the property name to be bound as a string literal here.)<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; &quot;Inside a behavior declaration, self is implicitly bound to the value that contains the property instantiated using this behavior. For a freestanding property at global or local scope, this will be the empty tuple (), and for a static or class property, this will be the metatype. Within the behavior declaration, the type of self is abstract and represented by the implicit generic type parameter Self.&quot;<br>&gt; <br>&gt; This is somewhat strange to me.  Would it be reasonable to say that self is bound iff the behavior has a classbound requirement on Self?  Alternatively, perhaps you could somehow declare/name the declcontext type, and refer to it later by a name other than Self?<br>&gt; <br>&gt;   mutating func update(x: Int) {<br>&gt;     [foo].x = x // Disambiguate reference to behavior storage<br>&gt;   }<br>&gt; <br>&gt; It would be really nice to be able to keep “self” referring to the behavior, and require an explicit declaration for the enclosing declaration if a behavior requires one (e.g. in the case of atomic).<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; &quot;Nested Types in Behaviors”<br>&gt; <br>&gt; This sounds great in the fullness of time, but it seems subsettable out of the first implementation/proposal.  Lacking this, it can be easily worked around with a private peer type.<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt;     // Parameter gets the name &#39;bas&#39; from the accessor requirement<br>&gt;     // by default, as with built-in accessors today.<br>&gt; <br>&gt; <br>&gt; Not really important for the v1 proposal, but it seems like a natural direction to allow this to be controlled by “API names” in the accessor.  The default would be that there are no API names, but if a behavior specified one, e.g.:<br>&gt; <br>&gt; 		willSet(newValue newValue : Value)  <br>&gt; <br>&gt; then “newValue” would be the default name in the body of the accessor.  If no “API name” were specified, then no name would be default injected.<br>&gt; <br>&gt; <br>&gt; Typographical comment w.r.t. the &quot;// Reinvent computed properties” example, you refer to the behavior as both “foobar” and “computed” later, I think the later reference is supposed to be &quot;var [foobar] bar: Int”?  Feel free to find more diversity in your metasyntactic names here :-)<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; &quot;Accessor requirements cannot take visibility modifiers; they are always as visible as the behavior itself.&quot;<br>&gt; <br>&gt; Maybe I’m misinterpreting this, but I see accessors differently.  I see them as “never being accessible to the code that declares a property using the behavior”.  If you want this, you can define a method that wraps them or something.  To a client of a behaviors, accessors are “implementation only”.<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; Can property requirements in protocols have behaviors on them?<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; Yep.<br>&gt; <br>&gt;&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt; Yep, moving generalizing special case hacks and moving them out of the compiler is a great direction.<br>&gt; <br>&gt;&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; I have not.<br>&gt; <br>&gt;&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; I’m spent a lot of time following the discussion and chatting with Joe about this periodically, starting when Dmitri pointed out this possible direction back in Dec 2014. :-)<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/0a7ba0d0/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>February 11, 2016 at 12:00:00pm</p></header><div class="content"><p>I haven&#39;t looked at the proposal extensively, but I like the overall<br>direction. One thought about syntax. If it goes through, I hope that it<br>does not use the #. I like how it&#39;s similar to the closure capture list<br>now, and it doesn&#39;t seem to belong to a macro system. To me, it&#39;s in the<br>same category as the capture list.<br>On Thu, Feb 11, 2016 at 6:15 AM Taras Zakharko via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt;    - What is your evaluation of the proposal?<br>&gt;<br>&gt; I agree with a number of people that have already replied before me: I<br>&gt; think this is a very exiting proposal, but as it is right now, its not 100%<br>&gt; fleshed out. Chris and other already provided comments on a number of<br>&gt; points that also came to my mind. Specifically, I am not very keen on the<br>&gt; proposed v.[foo] syntax and also the declaration of behaviours looks off to<br>&gt; me as well (even though its elegant in its own right). I’d prefer something<br>&gt; like<br>&gt;<br>&gt; property behavior foo&lt;valueType: Value, instanceType: Self where …&gt; {<br>&gt;<br>&gt; }<br>&gt;<br>&gt; e.g. where we take the already available generics syntax and extend it<br>&gt; with arguments to signal that behaviours are generics over multiple<br>&gt; specific dimensions (this can be also used for a future extension of<br>&gt; generic types). Required initial value can be coded by a presence of a<br>&gt; constructor that takes mandatory argument, for example, or by an attribute<br>&gt; as Chris suggests.<br>&gt;<br>&gt; One potential problem with a feature like this is that it is very<br>&gt; fundamental —it affects many areas of the language, some of those in a<br>&gt; non-trivial way. These things are hard to get from the first go. I’d<br>&gt; suggest that one makes an experimental implementation first and lets a<br>&gt; bunch of people test-drive it for a couple of weeks or even months. I am<br>&gt; sure that there will be some subtle design decisions that one might regret<br>&gt; later.<br>&gt;<br>&gt; So yes, its a definitive +1 but of the kind “revise and resubmit”. Also,<br>&gt; sole real-world testing should be done before feature like this is be<br>&gt; accepted into the core language. I also believe that fundamental,<br>&gt; non-trivial features like these are best designed in a team.<br>&gt;<br>&gt;<br>&gt;    - Is the problem being addressed significant enough to warrant a<br>&gt;    change to Swift?<br>&gt;<br>&gt; Yes. it makes the language more consistent and flexible, while removing<br>&gt; idiosyncrazy. I am also sure that it will open up new possibilities for the<br>&gt; UI framework teams to come up with great APIs :)<br>&gt;<br>&gt;<br>&gt;    - Does this proposal fit well with the feel and direction of Swift?<br>&gt;<br>&gt; Yes, definitely<br>&gt;<br>&gt;<br>&gt;    - If you have used other languages or libraries with a similar<br>&gt;    feature, how do you feel that this proposal compares to those?<br>&gt;<br>&gt; I have used Python that has a very similar feature (property descriptors)<br>&gt; quite extensively, and I have implemented many different patterns using<br>&gt; this mechanism (such as property observing and binding). I have also<br>&gt; implemented something similar for R.  I believe that Joe’s proposal is much<br>&gt; better thought out and fits the overall theme of a strongly typed language<br>&gt; very well.<br>&gt;<br>&gt;<br>&gt;    - How much effort did you put into your review? A glance, a quick<br>&gt;    reading, or an in-depth study?<br>&gt;<br>&gt; A quick reading. I was also following the discussion, but its a bit<br>&gt; difficult to keep up — watching the swift-evolution list is more like a<br>&gt; full-time job :)<br>&gt;<br>&gt; — Taras<br>&gt;<br>&gt; On 11 Feb 2016, at 07:13, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Feb 10, 2016, at 2:00 PM, Douglas Gregor via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Proposal link:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md<br>&gt;<br>&gt; &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What<br>&gt; goes into a review?<br>&gt;<br>&gt; The goal of the review process is to improve the proposal under review<br>&gt; through constructive criticism and, eventually, determine the direction of<br>&gt; Swift. When writing your review, here are some questions you might want to<br>&gt; answer in your review:<br>&gt;<br>&gt;    - What is your evaluation of the proposal?<br>&gt;<br>&gt; I’m +1 on the feature.  I have some comments for discussion though, I’m<br>&gt; sorry I didn’t get these to you before the formal proposal went out:<br>&gt;<br>&gt;<br>&gt;<br>&gt; First, on the most obvious bikeshed, the surface level syntax proposed:<br>&gt;<br>&gt; var [lazy] foo = 1738<br>&gt; foo.[lazy].clear()<br>&gt;<br>&gt;<br>&gt; Given the recent trend to use # for compiler synthesized / macroish /<br>&gt; magic syntax, it is worth considering whether:<br>&gt;<br>&gt; var #lazy foo = 1738<br>&gt; foo.#lazy.clear()<br>&gt;<br>&gt; might make sense, or even:<br>&gt;<br>&gt;  #lazy var foo = 1738<br>&gt;<br>&gt; I think that something like this is a bit better aesthetically, since the<br>&gt; [] delimiters are heavily array/collection/subscript-centric (which is a<br>&gt; good thing).  OTOH, this would be giving users access to the “#” namespace,<br>&gt; which means that future conflicts would have to be resolved with backticks<br>&gt; - e.g. if they wanted a “line” behavior, they’d have to use &quot;var #`line`<br>&gt; foo = 1738”. I guess the fact that we already have a solution to the<br>&gt; imagined problem means that this isn’t a big concern in practice.<br>&gt;<br>&gt; In any case, I think we should just pick a syntax, land the feature, and<br>&gt; keep bikeshedding on it through the end of Swift 3 :-)<br>&gt;<br>&gt;<br>&gt;<br>&gt; What are the semantics of behaviors applied to var/let decls with<br>&gt; non-trivial patterns?  For example:<br>&gt;<br>&gt; var [lazy] (foo, bar) = qux()<br>&gt;<br>&gt; ?  While we could devise semantics for this in some cases, I think it is<br>&gt; reasonable to only allow behaviors on single-identifier patterns, and<br>&gt; reject the other cases as invalid.  If you agree, please loop that into the<br>&gt; proposal.<br>&gt;<br>&gt;<br>&gt;<br>&gt; I understand the need to specifying whether the getter/setter and other<br>&gt; random methods are mutating or not, but doesn’t this eliminate the<br>&gt; difference between a var/let behavior?  Couldn’t we just say that a<br>&gt; behavior with a nonmutating getter &amp; setter are valid on a “let”, and that<br>&gt; any other mutating members are unavailable on a let?  This seems like a<br>&gt; theoretical win, though I’m not sure whether it would actually be a win in<br>&gt; practice for any conceivable behaviors you’ve been thinking about.<br>&gt;<br>&gt;<br>&gt;<br>&gt; I like the approach of having a behavior decl, but am not excited about<br>&gt; the decl syntax itself:<br>&gt;<br>&gt; behavior var [lazy] _: Value = initialValue {<br>&gt;<br>&gt;<br>&gt; I understand that this is intended to provide a template-like construct,<br>&gt; but I have a few problems with this:<br>&gt;<br>&gt; 1) A number of the things here are actually totally invariant (e.g. the _,<br>&gt; the colon) or only serve to provide a name (Value, initialValue) but cannot<br>&gt; be expanded into general expressions, though they look like they are.<br>&gt;<br>&gt; 2) This is totally unprecedented in Swift.  We have a very regular<br>&gt; structure of “@attributes decl-modifiers introducer_keyword name” - we have<br>&gt; no declarations that look like this.  For example, while operator decls<br>&gt; could follow this structure, they don’t.<br>&gt;<br>&gt; 3) If you agree that we don’t need to differentiate between var/let then<br>&gt; “behavior var&quot; is providing potentially misleading info.<br>&gt;<br>&gt; IMO, the most regular decl structure would be:<br>&gt;<br>&gt; @initial_value_required      // or something like it.<br>&gt; property behavior lazy {      // could be “subscript behavior” at some<br>&gt; point in the future?<br>&gt;    var value: Self? = nil        // Self is the property type?  Seems<br>&gt; weird if it is the enclosing type.<br>&gt;    ...<br>&gt; }<br>&gt;<br>&gt; or perhaps:<br>&gt;<br>&gt; @initial_value_required<br>&gt; property behavior lazy&lt;PropertyType&gt; {  // specify the type of the<br>&gt; property as a generic constraint?<br>&gt;    var value: PropertyType? = nil<br>&gt;    ...<br>&gt; }<br>&gt;<br>&gt; though I agree that this would require us to take “behavior” as a<br>&gt; keyword.  Do we know whether or not this would be a problem in practice?<br>&gt; If so, going with “behavior var” and “behavior let” is probably ok.<br>&gt;<br>&gt;<br>&gt; Of course, @initial_value_required is also pretty gross.  The alternative<br>&gt; is to follow the precedent of operator decls, and introduce random syntax<br>&gt; in their body, such as:<br>&gt;<br>&gt; property behavior lazy&lt;PropertyType&gt; {<br>&gt;    initializer initValue<br>&gt;    var value: PropertyType? = nil<br>&gt;    …<br>&gt;        value = initValue<br>&gt;    ...<br>&gt; }<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;   // Behaviors can declare storage that backs the property.<br>&gt;   private var value: Value?<br>&gt;<br>&gt;<br>&gt; What is the full range of access control allowed here?  Is there any<br>&gt; reason to allow anything other than “public” (which would mean that the<br>&gt; entity is exposed at whatever the properties access control level is)?  If<br>&gt; so, why allow specifying internal?  For sake of exposition in the proposal,<br>&gt; it seems simplest to say:<br>&gt;<br>&gt; var value: Value?  // private by default<br>&gt;<br>&gt;<br>&gt; or something.<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;   // Behaviors can declare initialization logic for the storage.<br>&gt;   // (Stored properties can also be initialized in-line.)<br>&gt;   init() {<br>&gt;     value = nil<br>&gt;   }<br>&gt;<br>&gt;<br>&gt; If a behavior has an init() with no arguments, then are the semantics that<br>&gt; it is *always* run?  What if there are both an init() and an init(value :<br>&gt; Value)?<br>&gt;<br>&gt;<br>&gt;  // Inline initializers are also supported, so `var value: Value? = nil`<br>&gt;   // would work equivalently.<br>&gt;<br>&gt;<br>&gt; This example is using a stored property of type Optional&lt;Value&gt; which has<br>&gt; a default value of nil, does that count or is this a syntactic<br>&gt; requirement?  To me, it seems most natural to follow the existing rules we<br>&gt; have:<br>&gt;<br>&gt; 1) If you write any init, then you get what you write.<br>&gt; 2) If there are no init’s, and any stored property in a behavior is<br>&gt; non-default initializable, then it is an error.<br>&gt; 3) If there are no init’s, and all stored properties in a behavior are<br>&gt; default initializable, then you get init() implicitly.<br>&gt;<br>&gt;<br>&gt;<br>&gt; Typographical comment:<br>&gt;<br>&gt;     if let value = value {<br>&gt;       return value<br>&gt;     }<br>&gt;<br>&gt;<br>&gt; You have way too many “value”s floating around, for sake of clarity, how<br>&gt; about:<br>&gt;<br>&gt;     if let valuePresent = value {<br>&gt;       return valuePresent<br>&gt;     }<br>&gt;<br>&gt;<br>&gt;<br>&gt; In &quot;Resettable properties”, you have this:<br>&gt;<br>&gt;   // Reset the property to its original initialized value.<br>&gt;   mutating func reset() {<br>&gt;     value = initialValue<br>&gt;   }<br>&gt;<br>&gt;<br>&gt; This raises the question of how “initialValue” works:  Is it evaluated<br>&gt; once when the property is bound and the resultant value is stored somewhere<br>&gt; (evaluating any side effects exactly once) or is it an auto-closure-like<br>&gt; concept?  If it is autoclosure-like, what does it mean in terms of<br>&gt; requiring “self.&quot; qualification &amp; @noescape?<br>&gt;<br>&gt;<br>&gt; In the context of your @NSCopying-replacement example, I would want<br>&gt; something like this:<br>&gt;<br>&gt; class Foo {<br>&gt;   var [copying] myproperty : NSString<br>&gt;<br>&gt;   init(a : NSString) {<br>&gt;      myproperty = a<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; to work, where the behavior requires an initial value, but that value is<br>&gt; provided by a flow-sensitive initialization point by DI .  How does this<br>&gt; happen?<br>&gt;<br>&gt;<br>&gt;<br>&gt; &quot;This imposes an *initializer requirement* on the behavior. Any property<br>&gt; using the behavior must be declared with an initial value&quot;<br>&gt;<br>&gt; Ah, this gets to the @NSCopying replacement example.  This might be too<br>&gt; limiting, but so long as there is a path forward to generalize this, it<br>&gt; seems like a fine starting point.<br>&gt;<br>&gt; [[Coming back to this after reading to the end]] Ok, I see this is in the<br>&gt; future directions section.  I’m fine with punting this to a further<br>&gt; revision of the proposal, but I think that it is worthwhile to provide a<br>&gt; syntactic affordance to differentiate properties that “must have an<br>&gt; initializer expression” and “must be initialized by an &#39;init(v: Value)’<br>&gt; member on the behavior before otherwise used”.  @NSCopying replacement<br>&gt; seems like the later case.  I’m fine with pushing off the general case to a<br>&gt; later proposal, but we should carve out space for it to fit in.<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; public behavior var [changeObserved] _: Value = initialValue {<br>&gt;<br>&gt; ...<br>&gt;<br>&gt;     if oldValue != newValue {<br>&gt;<br>&gt;<br>&gt;<br>&gt; This makes me vaguely uncomfortable, given that “changeObserved” has<br>&gt; undeclared type requirements that are only diagnosed when the behavior is<br>&gt; instantiated.  I’d greatly prefer to see something like:<br>&gt;<br>&gt; @initial_value_required<br>&gt; property behavior changeObserved&lt;PropertyType : Equatable&gt; {  //<br>&gt; constraint specified!<br>&gt;<br>&gt; which would allow the behavior to be modularly type checked.<br>&gt;<br>&gt; [[later…]] ah, I see that you’re doing something similar but different in<br>&gt; the &quot;Synchronized Property Access” example.  I mostly care that we can<br>&gt; express and modularly check this, the exact syntax isn’t as important.<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; In detailed design:<br>&gt;<br>&gt; property-behavior-decl ::=<br>&gt;   attribute* decl-modifier*<br>&gt;   &#39;behavior&#39; &#39;var&#39; &#39;[&#39; identifier &#39;]&#39; // behavior name<br>&gt;   (identifier | &#39;_&#39;)                  // property name binding<br>&gt;<br>&gt; If you go with this declaration syntax, I’d suggest requiring _ for the<br>&gt; name, since the name isn’t otherwise used for anything.  Ah, it looks like<br>&gt; you say this later, maybe the grammar just needs to be updated?<br>&gt;<br>&gt;    - A _ placeholder is required in the name position. (A future<br>&gt;    extension of behaviors may allow the property name to be bound as a string<br>&gt;    literal here.)<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; &quot;Inside a behavior declaration, self is implicitly bound to the value<br>&gt; that contains the property instantiated using this behavior. For a<br>&gt; freestanding property at global or local scope, this will be the empty<br>&gt; tuple (), and for a static or class property, this will be the metatype.<br>&gt; Within the behavior declaration, the type of self is abstract and<br>&gt; represented by the implicit generic type parameter Self.&quot;<br>&gt;<br>&gt; This is somewhat strange to me.  Would it be reasonable to say that self<br>&gt; is bound iff the behavior has a classbound requirement on Self?<br>&gt; Alternatively, perhaps you could somehow declare/name the declcontext type,<br>&gt; and refer to it later by a name other than Self?<br>&gt;<br>&gt;   mutating func update(x: Int) {<br>&gt;     [foo].x = x // Disambiguate reference to behavior storage<br>&gt;   }<br>&gt;<br>&gt;<br>&gt; It would be really nice to be able to keep “self” referring to the<br>&gt; behavior, and require an explicit declaration for the enclosing declaration<br>&gt; if a behavior requires one (e.g. in the case of atomic).<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; &quot;Nested Types in Behaviors”<br>&gt;<br>&gt; This sounds great in the fullness of time, but it seems subsettable out of<br>&gt; the first implementation/proposal.  Lacking this, it can be easily worked<br>&gt; around with a private peer type.<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;     // Parameter gets the name &#39;bas&#39; from the accessor requirement<br>&gt;     // by default, as with built-in accessors today.<br>&gt;<br>&gt;<br>&gt;<br>&gt; Not really important for the v1 proposal, but it seems like a natural<br>&gt; direction to allow this to be controlled by “API names” in the accessor.<br>&gt; The default would be that there are no API names, but if a behavior<br>&gt; specified one, e.g.:<br>&gt;<br>&gt; willSet(newValue newValue : Value)<br>&gt;<br>&gt; then “newValue” would be the default name in the body of the accessor.  If<br>&gt; no “API name” were specified, then no name would be default injected.<br>&gt;<br>&gt;<br>&gt; Typographical comment w.r.t. the &quot;// Reinvent computed properties”<br>&gt; example, you refer to the behavior as both “foobar” and “computed” later, I<br>&gt; think the later reference is supposed to be &quot;var [foobar] bar: Int”?  Feel<br>&gt; free to find more diversity in your metasyntactic names here :-)<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; &quot;Accessor requirements cannot take visibility modifiers; they are always<br>&gt; as visible as the behavior itself.&quot;<br>&gt; Maybe I’m misinterpreting this, but I see accessors differently.  I see<br>&gt; them as “never being accessible to the code that declares a property using<br>&gt; the behavior”.  If you want this, you can define a method that wraps them<br>&gt; or something.  To a client of a behaviors, accessors are “implementation<br>&gt; only”.<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; Can property requirements in protocols have behaviors on them?<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;    - Is the problem being addressed significant enough to warrant a<br>&gt;    change to Swift?<br>&gt;<br>&gt; Yep.<br>&gt;<br>&gt;<br>&gt;    - Does this proposal fit well with the feel and direction of Swift?<br>&gt;<br>&gt; Yep, moving generalizing special case hacks and moving them out of the<br>&gt; compiler is a great direction.<br>&gt;<br>&gt;<br>&gt;    - If you have used other languages or libraries with a similar<br>&gt;    feature, how do you feel that this proposal compares to those?<br>&gt;<br>&gt; I have not.<br>&gt;<br>&gt;<br>&gt;    - How much effort did you put into your review? A glance, a quick<br>&gt;    reading, or an in-depth study?<br>&gt;<br>&gt; I’m spent a lot of time following the discussion and chatting with Joe<br>&gt; about this periodically, starting when Dmitri pointed out this possible<br>&gt; direction back in Dec 2014. :-)<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/b614ff44/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February 11, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Feb 10, 2016, at 10:13 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; On Feb 10, 2016, at 2:00 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Proposal link:<br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md&gt;<br>&gt;&gt;  &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What goes into a review?<br>&gt;&gt; <br>&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt; <br>&gt;&gt; What is your evaluation of the proposal?<br>&gt; I’m +1 on the feature.  I have some comments for discussion though, I’m sorry I didn’t get these to you before the formal proposal went out:<br>&gt; <br>&gt; <br>&gt; <br>&gt; First, on the most obvious bikeshed, the surface level syntax proposed:<br>&gt; <br>&gt; 	var [lazy] foo = 1738<br>&gt; 	foo.[lazy].clear()<br>&gt; <br>&gt; <br>&gt; Given the recent trend to use # for compiler synthesized / macroish / magic syntax, it is worth considering whether:<br>&gt; <br>&gt; 	var #lazy foo = 1738<br>&gt; 	foo.#lazy.clear()<br>&gt; <br>&gt; might make sense, or even:<br>&gt; <br>&gt; 	 #lazy var foo = 1738<br>&gt; <br>&gt; I think that something like this is a bit better aesthetically, since the [] delimiters are heavily array/collection/subscript-centric (which is a good thing).  OTOH, this would be giving users access to the “#” namespace, which means that future conflicts would have to be resolved with backticks - e.g. if they wanted a “line” behavior, they’d have to use &quot;var #`line` foo = 1738”. I guess the fact that we already have a solution to the imagined problem means that this isn’t a big concern in practice.<br></p><p>Doesn&#39;t seem like an obvious analogy to me, since there&#39;s potentially a runtime component to these. As you noted, it also introduces a naming collision problem until we have a proper general solution for what &#39;#&#39; means, and I don&#39;t think we want to just shovel stuff ad-hoc into that namespace without more of a plan. We already overload &#39;[]&#39; for other things like capture lists, which isn&#39;t necessarily an excuse to overload it further, but we aren&#39;t sacrificing some pure design principle either.<br></p><p>&gt; <br>&gt; In any case, I think we should just pick a syntax, land the feature, and keep bikeshedding on it through the end of Swift 3 :-)<br></p><p>Agreed.<br></p><p>&gt; <br>&gt; <br>&gt; What are the semantics of behaviors applied to var/let decls with non-trivial patterns?  For example:<br>&gt; <br>&gt; 	var [lazy] (foo, bar) = qux()<br>&gt; <br>&gt; ?  While we could devise semantics for this in some cases, I think it is reasonable to only allow behaviors on single-identifier patterns, and reject the other cases as invalid.  If you agree, please loop that into the proposal.<br></p><p>Yeah, it&#39;s impossible to do if the behavior binds the initial value expression. We could potentially support it for behaviors with DI-like initialization. I had mentioned this but accidentally cut it out while trying to simplify, thanks for the heads up.<br></p><p>&gt; I understand the need to specifying whether the getter/setter and other random methods are mutating or not, but doesn’t this eliminate the difference between a var/let behavior?  Couldn’t we just say that a behavior with a nonmutating getter &amp; setter are valid on a “let”, and that any other mutating members are unavailable on a let?  This seems like a theoretical win, though I’m not sure whether it would actually be a win in practice for any conceivable behaviors you’ve been thinking about.<br></p><p>I think we should subset &#39;let&#39; behaviors out for the same reason we don&#39;t yet allow computed &#39;let&#39; properties—right now &#39;let&#39; guarantees immutability, and we don&#39;t have a way in the language to enforce that for user code. It would definitely be nice to be able to declare &#39;let [delayed]&#39; and &#39;var [delayed]&#39;, though.<br></p><p>&gt; <br>&gt; <br>&gt; I like the approach of having a behavior decl, but am not excited about the decl syntax itself:<br>&gt; behavior var [lazy] _: Value = initialValue {<br>&gt; <br>&gt; I understand that this is intended to provide a template-like construct, but I have a few problems with this:<br>&gt; <br>&gt; 1) A number of the things here are actually totally invariant (e.g. the _, the colon) or only serve to provide a name (Value, initialValue) but cannot be expanded into general expressions, though they look like they are.<br>&gt; <br>&gt; 2) This is totally unprecedented in Swift.  We have a very regular structure of “@attributes decl-modifiers introducer_keyword name” - we have no declarations that look like this.  For example, while operator decls could follow this structure, they don’t.<br>&gt; <br>&gt; 3) If you agree that we don’t need to differentiate between var/let then “behavior var&quot; is providing potentially misleading info.<br>&gt; <br>&gt; IMO, the most regular decl structure would be:<br>&gt; <br>&gt; @initial_value_required      // or something like it.<br>&gt; property behavior lazy {      // could be “subscript behavior” at some point in the future?<br>&gt;    var value: Self? = nil        // Self is the property type?  Seems weird if it is the enclosing type.<br>&gt;    ...<br>&gt; }<br>&gt; <br>&gt; or perhaps:<br>&gt; <br>&gt; @initial_value_required<br>&gt; property behavior lazy&lt;PropertyType&gt; {  // specify the type of the property as a generic constraint?<br>&gt;    var value: PropertyType? = nil   <br>&gt;    ...<br>&gt; }<br>&gt; <br>&gt; though I agree that this would require us to take “behavior” as a keyword.  Do we know whether or not this would be a problem in practice?  If so, going with “behavior var” and “behavior let” is probably ok.<br>&gt; <br>&gt; <br>&gt; Of course, @initial_value_required is also pretty gross.  The alternative is to follow the precedent of operator decls, and introduce random syntax in their body, such as:<br>&gt; <br>&gt; property behavior lazy&lt;PropertyType&gt; {<br>&gt;    initializer initValue<br>&gt;    var value: PropertyType? = nil   <br>&gt;    …<br>&gt;        value = initValue<br>&gt;    ...<br>&gt; }<br>&gt; <br></p><p>Yeah, this is more like what I had proposed in previous drafts. If we go this route, I would rather use special contextual declarators like this than &#39;@initial_value_required&#39;-like attributes.<br></p><p><br>&gt; <br>&gt; <br>&gt; <br>&gt;   // Behaviors can declare storage that backs the property.<br>&gt;   private var value: Value?<br>&gt; <br>&gt; What is the full range of access control allowed here?  Is there any reason to allow anything other than “public” (which would mean that the entity is exposed at whatever the properties access control level is)?  If so, why allow specifying internal?  For sake of exposition in the proposal, it seems simplest to say:<br>&gt; <br>&gt; var value: Value?  // private by default<br>&gt; <br>&gt; or something.<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt;   // Behaviors can declare initialization logic for the storage.<br>&gt;   // (Stored properties can also be initialized in-line.)<br>&gt;   init() {<br>&gt;     value = nil<br>&gt;   }<br>&gt; <br>&gt; If a behavior has an init() with no arguments, then are the semantics that it is *always* run?  What if there are both an init() and an init(value : Value)?<br></p><p>As proposed there is no &#39;init(value: Value)&#39;; we can design that later. An &#39;init()&#39; with no arguments would always run at initialization time, as if:<br></p><p>var [behavior] x: Int<br></p><p>instantiated storage like:<br></p><p>var `x.[behavior].storage`: BehaviorStorage&lt;Int&gt; = `[behavior].init()`<br></p><p>&gt; <br>&gt;  // Inline initializers are also supported, so `var value: Value? = nil`<br>&gt;   // would work equivalently.<br>&gt; <br>&gt; This example is using a stored property of type Optional&lt;Value&gt; which has a default value of nil, does that count or is this a syntactic requirement?  To me, it seems most natural to follow the existing rules we have:<br>&gt; <br>&gt; 1) If you write any init, then you get what you write.<br>&gt; 2) If there are no init’s, and any stored property in a behavior is non-default initializable, then it is an error.<br>&gt; 3) If there are no init’s, and all stored properties in a behavior are default initializable, then you get init() implicitly.<br></p><p>I thought that was self-evident. I can make it explicit.<br></p><p>&gt; <br>&gt; <br>&gt; Typographical comment:<br>&gt;     if let value = value {<br>&gt;       return value<br>&gt;     }<br>&gt; <br>&gt; You have way too many “value”s floating around, for sake of clarity, how about:<br>&gt; <br>&gt;     if let valuePresent = value {<br>&gt;       return valuePresent<br>&gt;     }<br>&gt; <br>&gt; <br>&gt; In &quot;Resettable properties”, you have this:<br>&gt; <br>&gt;   // Reset the property to its original initialized value.<br>&gt;   mutating func reset() {<br>&gt;     value = initialValue<br>&gt;   }<br>&gt; <br>&gt; This raises the question of how “initialValue” works:  Is it evaluated once when the property is bound and the resultant value is stored somewhere (evaluating any side effects exactly once) or is it an auto-closure-like concept?  If it is autoclosure-like, what does it mean in terms of requiring “self.&quot; qualification &amp; @noescape?<br></p><p>In the proposal, I say it behaves like a get-only property—it evaluates every time it&#39;s loaded.<br></p><p>&gt; <br>&gt; In the context of your @NSCopying-replacement example, I would want something like this:<br>&gt; <br>&gt; class Foo {<br>&gt;   var [copying] myproperty : NSString<br>&gt; <br>&gt;   init(a : NSString) {<br>&gt;      myproperty = a<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; to work, where the behavior requires an initial value, but that value is provided by a flow-sensitive initialization point by DI .  How does this happen?<br></p><p>Yeah. DI-like initialization is one of the future directions.<br>&gt; <br>&gt; <br>&gt; &quot;This imposes an initializer requirement on the behavior. Any property using the behavior must be declared with an initial value&quot;<br>&gt; <br>&gt; Ah, this gets to the @NSCopying replacement example.  This might be too limiting, but so long as there is a path forward to generalize this, it seems like a fine starting point.<br>&gt; <br>&gt; [[Coming back to this after reading to the end]] Ok, I see this is in the future directions section.  I’m fine with punting this to a further revision of the proposal, but I think that it is worthwhile to provide a syntactic affordance to differentiate properties that “must have an initializer expression” and “must be initialized by an &#39;init(v: Value)’ member on the behavior before otherwise used”.  @NSCopying replacement seems like the later case.  I’m fine with pushing off the general case to a later proposal, but we should carve out space for it to fit in.<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; public behavior var [changeObserved] _: Value = initialValue {<br>&gt; ...<br>&gt;    <br>&gt;     if oldValue != newValue {<br>&gt; <br>&gt; <br>&gt; This makes me vaguely uncomfortable, given that “changeObserved” has undeclared type requirements that are only diagnosed when the behavior is instantiated.<br></p><p>That was an oversight. In reality you&#39;d have to declare:<br></p><p>public behavior var [changeObserved] _: Value = initialValue<br>  where Value: Equatable {<br></p><p>&gt; <br>&gt; <br>&gt; <br>&gt; In detailed design:<br>&gt; property-behavior-decl ::=<br>&gt;   attribute* decl-modifier*<br>&gt;   &#39;behavior&#39; &#39;var&#39; &#39;[&#39; identifier &#39;]&#39; // behavior name<br>&gt;   (identifier | &#39;_&#39;)                  // property name binding<br>&gt; If you go with this declaration syntax, I’d suggest requiring _ for the name, since the name isn’t otherwise used for anything.  Ah, it looks like you say this later, maybe the grammar just needs to be updated?<br>&gt; A _ placeholder is required in the name position. (A future extension of behaviors may allow the property name to be bound as a string literal here.)<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; &quot;Inside a behavior declaration, self is implicitly bound to the value that contains the property instantiated using this behavior. For a freestanding property at global or local scope, this will be the empty tuple (), and for a static or class property, this will be the metatype. Within the behavior declaration, the type of self is abstract and represented by the implicit generic type parameter Self.&quot;<br>&gt; <br>&gt; This is somewhat strange to me.  Would it be reasonable to say that self is bound iff the behavior has a classbound requirement on Self?  Alternatively, perhaps you could somehow declare/name the declcontext type, and refer to it later by a name other than Self?<br>&gt; <br>&gt;   mutating func update(x: Int) {<br>&gt;     [foo].x = x // Disambiguate reference to behavior storage<br>&gt;   }<br>&gt; <br>&gt; It would be really nice to be able to keep “self” referring to the behavior, and require an explicit declaration for the enclosing declaration if a behavior requires one (e.g. in the case of atomic).<br></p><p>Sure, we could take that approach. I don&#39;t think it makes sense to constrain access to the enclosing value to classes, though.<br></p><p>&gt; &quot;Nested Types in Behaviors”<br>&gt; <br>&gt; This sounds great in the fullness of time, but it seems subsettable out of the first implementation/proposal.  Lacking this, it can be easily worked around with a private peer type.<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt;     // Parameter gets the name &#39;bas&#39; from the accessor requirement<br>&gt;     // by default, as with built-in accessors today.<br>&gt; <br>&gt; <br>&gt; Not really important for the v1 proposal, but it seems like a natural direction to allow this to be controlled by “API names” in the accessor.  The default would be that there are no API names, but if a behavior specified one, e.g.:<br>&gt; <br>&gt; 		willSet(newValue newValue : Value)  <br>&gt; <br>&gt; then “newValue” would be the default name in the body of the accessor.  If no “API name” were specified, then no name would be default injected.<br>&gt; <br>&gt; <br>&gt; Typographical comment w.r.t. the &quot;// Reinvent computed properties” example, you refer to the behavior as both “foobar” and “computed” later, I think the later reference is supposed to be &quot;var [foobar] bar: Int”?  Feel free to find more diversity in your metasyntactic names here :-)<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; &quot;Accessor requirements cannot take visibility modifiers; they are always as visible as the behavior itself.&quot;<br>&gt; <br>&gt; Maybe I’m misinterpreting this, but I see accessors differently.  I see them as “never being accessible to the code that declares a property using the behavior”.  If you want this, you can define a method that wraps them or something.  To a client of a behaviors, accessors are “implementation only”.<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; Can property requirements in protocols have behaviors on them?<br>I think not.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/31fb4a73/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>February 11, 2016 at 12:00:00pm</p></header><div class="content"><p>On Feb 11, 2016, at 10:30 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; In any case, I think we should just pick a syntax, land the feature, and keep bikeshedding on it through the end of Swift 3 :-)<br>&gt; <br>&gt; Agreed.<br></p><p>WFM.<br></p><p>&gt; <br>&gt;&gt; I understand the need to specifying whether the getter/setter and other random methods are mutating or not, but doesn’t this eliminate the difference between a var/let behavior?  Couldn’t we just say that a behavior with a nonmutating getter &amp; setter are valid on a “let”, and that any other mutating members are unavailable on a let?  This seems like a theoretical win, though I’m not sure whether it would actually be a win in practice for any conceivable behaviors you’ve been thinking about.<br>&gt; <br>&gt; I think we should subset &#39;let&#39; behaviors out for the same reason we don&#39;t yet allow computed &#39;let&#39; properties—right now &#39;let&#39; guarantees immutability, and we don&#39;t have a way in the language to enforce that for user code. It would definitely be nice to be able to declare &#39;let [delayed]&#39; and &#39;var [delayed]&#39;, though.<br></p><p>Ok, I’m fine with starting small and generalizing over time.<br></p><p>&gt;&gt; Of course, @initial_value_required is also pretty gross.  The alternative is to follow the precedent of operator decls, and introduce random syntax in their body, such as:<br>&gt;&gt; <br>&gt;&gt; property behavior lazy&lt;PropertyType&gt; {<br>&gt;&gt;    initializer initValue<br>&gt;&gt;    var value: PropertyType? = nil   <br>&gt;&gt;    …<br>&gt;&gt;        value = initValue<br>&gt;&gt;    ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt; <br>&gt; Yeah, this is more like what I had proposed in previous drafts. If we go this route, I would rather use special contextual declarators like this than &#39;@initial_value_required&#39;-like attributes.<br></p><p>Agreed.  Where do you stand on taking behavior as a keyword?  Do you prefer something like the example above, or something like what you wrote in your proposal?<br></p><p>&gt;&gt; <br>&gt;&gt; If a behavior has an init() with no arguments, then are the semantics that it is *always* run?  What if there are both an init() and an init(value : Value)?<br>&gt; <br>&gt; As proposed there is no &#39;init(value: Value)&#39;; we can design that later. An &#39;init()&#39; with no arguments would always run at initialization time, as if:<br>&gt; <br>&gt; var [behavior] x: Int<br>&gt; <br>&gt; instantiated storage like:<br>&gt; <br>&gt; var `x.[behavior].storage`: BehaviorStorage&lt;Int&gt; = `[behavior].init()`<br></p><p>Makes sense!<br></p><p>&gt;&gt; In &quot;Resettable properties”, you have this:<br>&gt;&gt; <br>&gt;&gt;   // Reset the property to its original initialized value.<br>&gt;&gt;   mutating func reset() {<br>&gt;&gt;     value = initialValue<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; This raises the question of how “initialValue” works:  Is it evaluated once when the property is bound and the resultant value is stored somewhere (evaluating any side effects exactly once) or is it an auto-closure-like concept?  If it is autoclosure-like, what does it mean in terms of requiring “self.&quot; qualification &amp; @noescape?<br>&gt; <br>&gt; In the proposal, I say it behaves like a get-only property—it evaluates every time it&#39;s loaded.<br></p><p>Ok, that semantic makes sense to me.  Given that, a behavior can emulate any of the other semantics it wants.<br></p><p>&gt;&gt; <br>&gt;&gt; to work, where the behavior requires an initial value, but that value is provided by a flow-sensitive initialization point by DI .  How does this happen?<br>&gt; <br>&gt; Yeah. DI-like initialization is one of the future directions.<br></p><p>Ok.  That means that we can’t actually cut @NSCopying over to it yet, but I’m fine with tackling that later.<br></p><p>&gt;&gt; <br>&gt;&gt; This makes me vaguely uncomfortable, given that “changeObserved” has undeclared type requirements that are only diagnosed when the behavior is instantiated.<br>&gt; <br>&gt; That was an oversight. In reality you&#39;d have to declare:<br>&gt; <br>&gt; public behavior var [changeObserved] _: Value = initialValue<br>&gt;   where Value: Equatable {<br></p><p>Ok, great.<br></p><p>I’m very curious where you stand on the syntax of the behavior decl, because this decl (as one concrete example) seems like it would be *much* nicer as:<br></p><p>public var behavior changeObserved&lt;Value : Equatable&gt; {<br></p><p>&gt;&gt; Can property requirements in protocols have behaviors on them?<br>&gt; I think not.<br></p><p>Ok, please mention that, thanks!<br></p><p>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/9b5402d5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February 11, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Feb 11, 2016, at 12:53 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; I’m very curious where you stand on the syntax of the behavior decl, because this decl (as one concrete example) seems like it would be *much* nicer as:<br>&gt; <br>&gt; public var behavior changeObserved&lt;Value : Equatable&gt; {<br></p><p>I&#39;d prefer not to take it as a keyword. I think we can parse it contextually between &#39;var&#39; and another identifier, even though we don&#39;t do that anywhere else yet.<br></p><p>If we really want to keep the initial proposal modest, we could subset out the declaration syntax bikeshedding and start with the lazy implementer&#39;s approach, exposing the unpainted protocol underlying the behavior:<br></p><p>@property_behavior<br>protocol behavior {<br>  // Type of the property instantiating the behavior.<br>  associatedtype Value<br>  // Backing storage for the behavior.<br>  var storage: Value? { get set }<br>}<br>extension behavior {<br>  // Initializer for the instantiated storage.<br>  static func initStorage() -&gt; Value? {<br>    return nil<br>  }<br>  // Property implementation.<br>  var value: Value {<br>    get { ... }<br>    set { ... }<br>  }<br>}<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/2c70d854/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>February 11, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Feb 11, 2016, at 1:10 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 11, 2016, at 12:53 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I’m very curious where you stand on the syntax of the behavior decl, because this decl (as one concrete example) seems like it would be *much* nicer as:<br>&gt;&gt; <br>&gt;&gt; public var behavior changeObserved&lt;Value : Equatable&gt; {<br>&gt; <br>&gt; I&#39;d prefer not to take it as a keyword. I think we can parse it contextually between &#39;var&#39; and another identifier, even though we don&#39;t do that anywhere else yet.<br></p><p>Ok.<br></p><p>&gt; If we really want to keep the initial proposal modest, we could subset out the declaration syntax bikeshedding and start with the lazy implementer&#39;s approach, exposing the unpainted protocol underlying the behavior:<br></p><p>I’d prefer not to do that :-)<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/b03c1e78/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/df65d69ec35e73390ddd0e6a2c335737?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>James Hillhouse IV</string> &lt;jimhillhouse at me.com&gt;<p>February 11, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Feb 11, 2016, at 12:13 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; 	var [lazy] foo = 1738<br>&gt; 	foo.[lazy].clear()<br></p><p>-1 to the proposed use of the [] delimiters for property behaviors. <br></p><p>I think from a purely stylistic POV, further exceptions to the [] delimiters beyond current use for arrays, etc. amps-up ambiguity in Swift.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c40db4457ab2c91a0d8006da31b177c6?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Trent Nadeau</string> &lt;tanadeau at gmail.com&gt;<p>February 11, 2016 at 03:00:00pm</p></header><div class="content"><p>Where [lazy] is currently used, could the syntax instead be<br>#behavior(lazy)? That prevents a possible future naming clash, keeps the #<br>meaning compiler-magic, and doesn&#39;t use the [], which is contentious.<br></p><p>On Thu, Feb 11, 2016 at 3:34 PM, Jim Hillhouse via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; On Feb 11, 2016, at 12:13 AM, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;       var [lazy] foo = 1738<br>&gt; &gt;       foo.[lazy].clear()<br>&gt;<br>&gt; -1 to the proposed use of the [] delimiters for property behaviors.<br>&gt;<br>&gt; I think from a purely stylistic POV, further exceptions to the []<br>&gt; delimiters beyond current use for arrays, etc. amps-up ambiguity in Swift.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br></p><p>-- <br>Trent Nadeau<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/412a520e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February 11, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; Where [lazy] is currently used, could the syntax instead be #behavior(lazy)? That prevents a possible future naming clash, keeps the # meaning compiler-magic, and doesn&#39;t use the [], which is contentious.<br></p><p>I think that if we go down this road, @behavior(lazy) or just @lazy is strictly superior. We already have the @ sigil for attributes; we don&#39;t need to introduce another sigil for no apparent reason.<br></p><p>(But unless we&#39;re going to use the latter syntax and say &quot;all @s are behaviors, we just haven&#39;t formalized func/type/etc. behaviors yet&quot; so we finally have an idea of what @ means, I don&#39;t think either of these syntaxes is better than the one proposed.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c40db4457ab2c91a0d8006da31b177c6?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Trent Nadeau</string> &lt;tanadeau at gmail.com&gt;<p>February 11, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt;From what I&#39;ve seen @ is used for annotations, which apply to declarations.<br>I&#39;ve never seen them used as an attribute like foo. at bar.<br></p><p>foo.#behavior(lazy).clear() seems clearer than foo.[lazy].clear().<br></p><p>On Thu, Feb 11, 2016 at 4:36 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>wrote:<br></p><p>&gt; &gt; Where [lazy] is currently used, could the syntax instead be<br>&gt; #behavior(lazy)? That prevents a possible future naming clash, keeps the #<br>&gt; meaning compiler-magic, and doesn&#39;t use the [], which is contentious.<br>&gt;<br>&gt; I think that if we go down this road, @behavior(lazy) or just @lazy is<br>&gt; strictly superior. We already have the @ sigil for attributes; we don&#39;t<br>&gt; need to introduce another sigil for no apparent reason.<br>&gt;<br>&gt; (But unless we&#39;re going to use the latter syntax and say &quot;all @s are<br>&gt; behaviors, we just haven&#39;t formalized func/type/etc. behaviors yet&quot; so we<br>&gt; finally have an idea of what @ means, I don&#39;t think either of these<br>&gt; syntaxes is better than the one proposed.)<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt;<br></p><p><br>-- <br>Trent Nadeau<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/9e1bffc4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3e4acc351c34224514f9d58b08389390?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Myles Schultz</string> &lt;myleslschultz at icloud.com&gt;<p>February 11, 2016 at 09:00:00pm</p></header><div class="content"><p>I like the idea behind using protocols for behaviors, but the more I think about it, the more I&#39;m not in love with the way it is invoked. Having to use dot syntax every time doesn&#39;t feel right. When it comes to the having to use .clear(), that really doesn&#39;t feel right. Setting value to nil seemed so much cleaner and simpler. <br></p><p>Also, why can&#39;t we apply the behaviors described but keep the keyword where it is. <br></p><p>lazy var foo: Int<br></p><p>You would t have change so much code, it&#39;s familiar and I like the the keyword lazy seems to be modifying the var when it typed before it. It&#39;s acting like and adjective. Essentially, that&#39;s what the behavior protocols are doing--describing the behavior of a given property and acting like an adjective. <br></p><p>Does anyone else feel the same on these points?<br></p><p>Myles<br></p><p>Sent from my iPhone<br></p><p>&gt; On Feb 11, 2016, at 4:40 PM, Trent Nadeau via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; From what I&#39;ve seen @ is used for annotations, which apply to declarations. I&#39;ve never seen them used as an attribute like foo. at bar.<br>&gt; <br>&gt; foo.#behavior(lazy).clear() seems clearer than foo.[lazy].clear().<br>&gt; <br>&gt;&gt; On Thu, Feb 11, 2016 at 4:36 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt; &gt; Where [lazy] is currently used, could the syntax instead be #behavior(lazy)? That prevents a possible future naming clash, keeps the # meaning compiler-magic, and doesn&#39;t use the [], which is contentious.<br>&gt;&gt; <br>&gt;&gt; I think that if we go down this road, @behavior(lazy) or just @lazy is strictly superior. We already have the @ sigil for attributes; we don&#39;t need to introduce another sigil for no apparent reason.<br>&gt;&gt; <br>&gt;&gt; (But unless we&#39;re going to use the latter syntax and say &quot;all @s are behaviors, we just haven&#39;t formalized func/type/etc. behaviors yet&quot; so we finally have an idea of what @ means, I don&#39;t think either of these syntaxes is better than the one proposed.)<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Trent Nadeau<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/0c7b9f31/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>February 13, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On 12 Feb 2016, at 03:32, Myles Schultz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Having to use dot syntax every time doesn&#39;t feel right. When it comes to the having to use .clear(), that really doesn&#39;t feel right. Setting value to nil seemed so much cleaner and simpler. <br></p><p>1) behaviors exist for implementing more than lazy, so making an argument about the calling syntax for &#39;clear&#39; seems a bit too not picky for me.<br></p><p>2) In the case of lazy, the property&#39;s type is often not optional. So setting the value to nil is a non-sensical from a type-checker point of view.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3e4acc351c34224514f9d58b08389390?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Myles Schultz</string> &lt;myleslschultz at icloud.com&gt;<p>February 12, 2016 at 07:00:00pm</p></header><div class="content"><p>My apologies, I did not intend to be picky.  That case involving the use of .clear() just seemed like the most obvious.  My overall point was that if one has to reference the behavior every time the property is used, that becomes cumbersome and not really any better than what we have now.  So being able to apply property behaviors without have to<br></p><p>foo.[behavior].somethingHere()<br>foo.[behavior].instance = 1<br>etc. (pardon if I made any mistakes above, I was typing that from what I remembered from the proposal)<br></p><p>when we need to use them, would be more ideal.  In other words,<br></p><p>foo = 1<br>foo = nil<br>foo.doSomething()<br>etc.<br></p><p>I really like the idea of property behaviors, I just don’t like the syntax for how they are invoked.  That’s what I meant.  I really didn’t mean to mince words or be picky.  It was just a suggestion to help simplify the syntax if possible.<br></p><p>Myles<br></p><p><br>&gt; On Feb 12, 2016, at 6:22 PM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On 12 Feb 2016, at 03:32, Myles Schultz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Having to use dot syntax every time doesn&#39;t feel right. When it comes to the having to use .clear(), that really doesn&#39;t feel right. Setting value to nil seemed so much cleaner and simpler. <br>&gt; <br>&gt; 1) behaviors exist for implementing more than lazy, so making an argument about the calling syntax for &#39;clear&#39; seems a bit too not picky for me.<br>&gt; <br>&gt; 2) In the case of lazy, the property&#39;s type is often not optional. So setting the value to nil is a non-sensical from a type-checker point of view.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/73a38bb7bc9528e31098defe30e68ea4?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Jean-Daniel Dupas</string> &lt;mailing at xenonium.com&gt;<p>February 13, 2016 at 02:00:00pm</p></header><div class="content"><p>This kind of shortcut may be ambiguous. How do you handle the case where both the underlying type and the property declare the same method ?<br></p><p>How do you handle the case where a property has more than one behavior ?<br></p><p>If the underlying property is not an Optional, being able to set it to nil is confusing, and if it is Optional, how would you now that setting it to nil should clear the lazy behavior and not affect the value nil to the underlying property.<br></p><p>&gt; Le 13 févr. 2016 à 01:46, Myles La Verne Schultz via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; My apologies, I did not intend to be picky.  That case involving the use of .clear() just seemed like the most obvious.  My overall point was that if one has to reference the behavior every time the property is used, that becomes cumbersome and not really any better than what we have now.  So being able to apply property behaviors without have to<br>&gt; <br>&gt; foo.[behavior].somethingHere()<br>&gt; foo.[behavior].instance = 1<br>&gt; etc. (pardon if I made any mistakes above, I was typing that from what I remembered from the proposal)<br>&gt; <br>&gt; when we need to use them, would be more ideal.  In other words,<br>&gt; <br>&gt; foo = 1<br>&gt; foo = nil<br>&gt; foo.doSomething()<br>&gt; etc.<br>&gt; <br>&gt; I really like the idea of property behaviors, I just don’t like the syntax for how they are invoked.  That’s what I meant.  I really didn’t mean to mince words or be picky.  It was just a suggestion to help simplify the syntax if possible.<br>&gt; <br>&gt; Myles<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 12, 2016, at 6:22 PM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 12 Feb 2016, at 03:32, Myles Schultz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Having to use dot syntax every time doesn&#39;t feel right. When it comes to the having to use .clear(), that really doesn&#39;t feel right. Setting value to nil seemed so much cleaner and simpler. <br>&gt;&gt; <br>&gt;&gt; 1) behaviors exist for implementing more than lazy, so making an argument about the calling syntax for &#39;clear&#39; seems a bit too not picky for me.<br>&gt;&gt; <br>&gt;&gt; 2) In the case of lazy, the property&#39;s type is often not optional. So setting the value to nil is a non-sensical from a type-checker point of view.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3e4acc351c34224514f9d58b08389390?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Myles Schultz</string> &lt;myleslschultz at icloud.com&gt;<p>February 13, 2016 at 10:00:00am</p></header><div class="content"><p>You’re right, it may be too ambiguous, but you should know what behavior one of your properties has.  Ideally you know what is lazy.  When you forget, you can use Quicklook or look up the property declaration manually.  As far as setting a property to nil, that only makes sense for optional types.  Setting a non-optional Int to nil is an error--you can’t do it.  <br></p><p>var firstInt: Int = nil            // error, not an optional, regardless of behavior<br>var secondInt: Int? = nil    // ok<br></p><p>Thus, .clear() isn’t even applicable to the first case.  Even with the lazy case, setting the behavior to nil but the actual property to…0?  That doesn’t make sense either.<br></p><p>In regard to having multiple behaviors, the behaviors should be accessible like any other protocol conformance and automatically be made part of the properties possible function list.  You should not need to reference the behavior behavior because that should be understood just like the property being a var or a let should be understood.  So if a property is defined as being lazy, then the property automatically acquires all of the functions associated with lazy, if it has another behavior, it acquires those functions too.  Then .clear() or .doSomethingElse() become<br></p><p>foo.doSomething() or foo.doSomethingElse()<br></p><p>To me this makes more sense, but I guess it is just me.  If anyone else feels the way I do, I would appreciate their input or backing.  Perhaps having someone else explain it in their words would help?  I don’t know.  At any rate, it was just an idea.  I’m just trying to provide the syntax/thought process that feels more Swift.<br></p><p>Myles<br></p><p>&gt; On Feb 13, 2016, at 8:00 AM, Jean-Daniel Dupas &lt;mailing at xenonium.com&gt; wrote:<br>&gt; <br>&gt; This kind of shortcut may be ambiguous. How do you handle the case where both the underlying type and the property declare the same method ?<br>&gt; <br>&gt; How do you handle the case where a property has more than one behavior ?<br>&gt; <br>&gt; If the underlying property is not an Optional, being able to set it to nil is confusing, and if it is Optional, how would you now that setting it to nil should clear the lazy behavior and not affect the value nil to the underlying property.<br>&gt; <br>&gt;&gt; Le 13 févr. 2016 à 01:46, Myles La Verne Schultz via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; My apologies, I did not intend to be picky.  That case involving the use of .clear() just seemed like the most obvious.  My overall point was that if one has to reference the behavior every time the property is used, that becomes cumbersome and not really any better than what we have now.  So being able to apply property behaviors without have to<br>&gt;&gt; <br>&gt;&gt; foo.[behavior].somethingHere()<br>&gt;&gt; foo.[behavior].instance = 1<br>&gt;&gt; etc. (pardon if I made any mistakes above, I was typing that from what I remembered from the proposal)<br>&gt;&gt; <br>&gt;&gt; when we need to use them, would be more ideal.  In other words,<br>&gt;&gt; <br>&gt;&gt; foo = 1<br>&gt;&gt; foo = nil<br>&gt;&gt; foo.doSomething()<br>&gt;&gt; etc.<br>&gt;&gt; <br>&gt;&gt; I really like the idea of property behaviors, I just don’t like the syntax for how they are invoked.  That’s what I meant.  I really didn’t mean to mince words or be picky.  It was just a suggestion to help simplify the syntax if possible.<br>&gt;&gt; <br>&gt;&gt; Myles<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 12, 2016, at 6:22 PM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 12 Feb 2016, at 03:32, Myles Schultz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Having to use dot syntax every time doesn&#39;t feel right. When it comes to the having to use .clear(), that really doesn&#39;t feel right. Setting value to nil seemed so much cleaner and simpler. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1) behaviors exist for implementing more than lazy, so making an argument about the calling syntax for &#39;clear&#39; seems a bit too not picky for me.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2) In the case of lazy, the property&#39;s type is often not optional. So setting the value to nil is a non-sensical from a type-checker point of view.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/73a38bb7bc9528e31098defe30e68ea4?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Jean-Daniel Dupas</string> &lt;mailing at xenonium.com&gt;<p>February 13, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; Le 13 févr. 2016 à 16:57, Myles La Verne Schultz via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; You’re right, it may be too ambiguous, but you should know what behavior one of your properties has.  Ideally you know what is lazy.  When you forget, you can use Quicklook or look up the property declaration manually.  As far as setting a property to nil, that only makes sense for optional types.  Setting a non-optional Int to nil is an error--you can’t do it.  <br>&gt; <br>&gt; var firstInt: Int = nil            // error, not an optional, regardless of behavior<br>&gt; var secondInt: Int? = nil    // ok<br></p><p>-------<br>var lazy firstInt: Int?<br></p><p>firstInt = nil<br>-------<br>What setting it to nil is supposed to do ? Clear the lazy storage, or setting the value to nil ?<br></p><p>&gt; Thus, .clear() isn’t even applicable to the first case.  Even with the lazy case, setting the behavior to nil but the actual property to…0?  That doesn’t make sense either.<br>&gt; <br>&gt; In regard to having multiple behaviors, the behaviors should be accessible like any other protocol conformance and automatically be made part of the properties possible function list.  You should not need to reference the behavior behavior because that should be understood just like the property being a var or a let should be understood.  So if a property is defined as being lazy, then the property automatically acquires all of the functions associated with lazy, if it has another behavior, it acquires those functions too.  Then .clear() or .doSomethingElse() become<br>&gt; <br>&gt; foo.doSomething() or foo.doSomethingElse()<br>&gt; <br></p><p>-------<br>class MyClass {<br>  func doSomething() {}<br>}<br></p><p>behavior myBehavior {<br>  func doSomething() {}<br>}<br></p><p>var myBehavior prop : MyClass<br></p><p>prop.doSomething()<br>-------<br>What is this call supposed to do ? Invoking the behavior method, or the class method ? If a class exposed the clear() method, Is it supposed to be unusable with lazy ?<br></p><p>&gt; To me this makes more sense, but I guess it is just me.  If anyone else feels the way I do, I would appreciate their input or backing.  Perhaps having someone else explain it in their words would help?  I don’t know.  At any rate, it was just an idea.  I’m just trying to provide the syntax/thought process that feels more Swift.<br>&gt; <br>&gt; Myles<br>&gt; <br>&gt;&gt; On Feb 13, 2016, at 8:00 AM, Jean-Daniel Dupas &lt;mailing at xenonium.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This kind of shortcut may be ambiguous. How do you handle the case where both the underlying type and the property declare the same method ?<br>&gt;&gt; <br>&gt;&gt; How do you handle the case where a property has more than one behavior ?<br>&gt;&gt; <br>&gt;&gt; If the underlying property is not an Optional, being able to set it to nil is confusing, and if it is Optional, how would you now that setting it to nil should clear the lazy behavior and not affect the value nil to the underlying property.<br>&gt;&gt; <br>&gt;&gt;&gt; Le 13 févr. 2016 à 01:46, Myles La Verne Schultz via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My apologies, I did not intend to be picky.  That case involving the use of .clear() just seemed like the most obvious.  My overall point was that if one has to reference the behavior every time the property is used, that becomes cumbersome and not really any better than what we have now.  So being able to apply property behaviors without have to<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; foo.[behavior].somethingHere()<br>&gt;&gt;&gt; foo.[behavior].instance = 1<br>&gt;&gt;&gt; etc. (pardon if I made any mistakes above, I was typing that from what I remembered from the proposal)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; when we need to use them, would be more ideal.  In other words,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; foo = 1<br>&gt;&gt;&gt; foo = nil<br>&gt;&gt;&gt; foo.doSomething()<br>&gt;&gt;&gt; etc.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I really like the idea of property behaviors, I just don’t like the syntax for how they are invoked.  That’s what I meant.  I really didn’t mean to mince words or be picky.  It was just a suggestion to help simplify the syntax if possible.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Myles<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 12, 2016, at 6:22 PM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 12 Feb 2016, at 03:32, Myles Schultz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Having to use dot syntax every time doesn&#39;t feel right. When it comes to the having to use .clear(), that really doesn&#39;t feel right. Setting value to nil seemed so much cleaner and simpler. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1) behaviors exist for implementing more than lazy, so making an argument about the calling syntax for &#39;clear&#39; seems a bit too not picky for me.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2) In the case of lazy, the property&#39;s type is often not optional. So setting the value to nil is a non-sensical from a type-checker point of view.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8da0cba30fa0e47cf4fb26ebb968e552?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Jérôme Duquennoy</string> &lt;jerome+swift at duquennoy.fr&gt;<p>February 13, 2016 at 09:00:00pm</p></header><div class="content"><p>Hi everyone,<br></p><p>First, I&#39;m sorry, I have very few spare time currently, so I will only make a quick contribution to that topic.<br></p><p>I love this discussion, it is really an interesting feature, that could be very useful in some parts of my existing code.<br>I would like to raise a concern about the syntax : as Chris said, the square brackets are already heavily used for collections and subscript.<br>Given that swift might be used as a scripting language too, it will probably be written using a &quot;simple&quot; text editor like sublimeText, textMate, vi  or equivalent ones in many cases. Those editor does not use sourceKit or LLVM to apply syntax coloring. The analysis is much simpler, often based on regexp.<br>I think that re-using the square brackets here would make it hard for them to provide accurate coloring, thus lowering the ease of use and reducing the attractiveness of swift as a scripting language.<br></p><p>This feature is a +1 for me, but I would prefer an alternative syntax for it, like the @ prefix proposed in the review, or the # prefix proposed by Chris.<br></p><p>Jerome<br></p><p>&gt; Le 11 févr. 2016 à 07:13, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; I think that something like this is a bit better aesthetically, since the [] delimiters are heavily array/collection/subscript-centric (which is a good thing).  OTOH, this would be giving users access to the “#” namespace, which means that future conflicts would have to be resolved with backticks - e.g. if they wanted a “line” behavior, they’d have to use &quot;var #`line` foo = 1738”. I guess the fact that we already have a solution to the imagined problem means that this isn’t a big concern in practice.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160213/bef7bbea/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/73a38bb7bc9528e31098defe30e68ea4?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Jean-Daniel Dupas</string> &lt;mailing at xenonium.com&gt;<p>February 14, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; Le 13 févr. 2016 à 21:23, Jérôme Duquennoy via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Hi everyone,<br>&gt; <br>&gt; First, I&#39;m sorry, I have very few spare time currently, so I will only make a quick contribution to that topic.<br>&gt; <br>&gt; I love this discussion, it is really an interesting feature, that could be very useful in some parts of my existing code.<br>&gt; I would like to raise a concern about the syntax : as Chris said, the square brackets are already heavily used for collections and subscript.<br>&gt; Given that swift might be used as a scripting language too, it will probably be written using a &quot;simple&quot; text editor like sublimeText, textMate, vi  or equivalent ones in many cases. Those editor does not use sourceKit or LLVM to apply syntax coloring. The analysis is much simpler, often based on regexp.<br>&gt; I think that re-using the square brackets here would make it hard for them to provide accurate coloring, thus lowering the ease of use and reducing the attractiveness of swift as a scripting language.<br></p><p>I don’t think it is more complex to distinguish between subscript and behavior access (behavior as a leading dot), than between attribute or « macro » and behavior access (if we choose to use @ or # for behavior).<br></p><p>That said, I’m not found either of the bracket proposal, but don’t have anything to propose to replace it though.<br></p><p>&gt; This feature is a +1 for me, but I would prefer an alternative syntax for it, like the @ prefix proposed in the review, or the # prefix proposed by Chris.<br>&gt; <br>&gt; Jerome<br>&gt; <br>&gt;&gt; Le 11 févr. 2016 à 07:13, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; I think that something like this is a bit better aesthetically, since the [] delimiters are heavily array/collection/subscript-centric (which is a good thing).  OTOH, this would be giving users access to the “#” namespace, which means that future conflicts would have to be resolved with backticks - e.g. if they wanted a “line” behavior, they’d have to use &quot;var #`line` foo = 1738”. I guess the fact that we already have a solution to the imagined problem means that this isn’t a big concern in practice.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160214/f9cb6b25/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>February 14, 2016 at 11:00:00am</p></header><div class="content"><p>I guess there is an obvious response to a question left unanswered last year, but as seeing this<br></p><p>&gt; I think that something like this is a bit better aesthetically, since the [] delimiters are heavily array/collection/subscript-centric (which is a good thing).<br></p><p>I ask again:<br>What is wrong with arrow brackets?<br></p><p>var&lt;lazy&gt; foo<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160214/dfeaf153/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February 14, 2016 at 03:00:00am</p></header><div class="content"><p>&gt; I ask again:<br>&gt; What is wrong with arrow brackets?<br>&gt; <br>&gt; var&lt;lazy&gt; foo<br></p><p>	var&lt;lazy, synchronized&gt; foo: Dictionary&lt;Int, Set&lt;Optional&lt;String&gt;&gt;<br></p><p>So, two problems:<br></p><p>• Angle brackets already appear in var declarations for generic types; that means there are two different meanings for angle brackets in the same construct.<br></p><p>• When we eventually allow you to apply multiple behaviors to a single property, that will also mean that *commas* are used in both of those angle bracket constructs, but with different meanings (one means &quot;chain these&quot;, the other means &quot;fill these two slots&quot;).<br></p><p>These are not fatal errors, but they&#39;re also completely unforced—either `[]` or `{}` would not have this problem. So why choose the option that has the problem?<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>February 14, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; • Angle brackets already appear in var declarations for generic types; that means there are two different meanings for angle brackets in the same construct.<br>Isn&#39;t the same true when you declare an array (or a closure)?<br></p><p>&gt; • When we eventually allow you to apply multiple behaviors to a single property, that will also mean that *commas* are used in both of those angle bracket constructs, but with different meanings (one means &quot;chain these&quot;, the other means &quot;fill these two slots&quot;).<br>True, but imho also no deal breaker; I would like to have labeled generic parameters anyway ;-)<br>Afaics, it isn&#39;t decided how multiple behaviors will be handled yet.<br></p><p>&gt; These are not fatal errors, but they&#39;re also completely unforced—either `[]` or `{}` would not have this problem. So why choose the option that has the problem?<br>Because those have a similar (and imho bigger) problems:<br>Grouping blocks of code or declaring arrays are things that are tightly coupled with &quot;their&quot; braces, and for me, &quot;&lt;&gt;&quot; causes the smallest disruption… arrays, capture lists and blocks have little in common with behaviors, but property behaviors could be expressed using generics*<br></p><p>Tino<br></p><p>* thinking of something like<br></p><p>protocol Behavior {<br>	typealias ValueType<br>	var value: ValueType { get set }<br>}<br></p><p>class DefaultBehavior&lt;T&gt; {<br>	typealias ValueType = T<br></p><p>	var value: ValueType<br></p><p>	init(value: ValueType) {<br>		self.value = value<br>	}<br>}<br></p><p>class Sample {<br>	var&lt;DefaultBehavior&gt; content: Int?<br>}<br></p><p>Here, &quot;var&quot; would create a container whose behavior is determined by a generic parameter; access of &quot;content&quot; would be mapped to that container.<br>I know behaviors are supposed to work slightly different, but that doesn&#39;t destroy the mental model of a parameterized container.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160214/988670c0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2b19ddab2d7de4523412c875c258e278?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Matt Whiteside</string> &lt;mwhiteside.dev at gmail.com&gt;<p>February 14, 2016 at 09:00:00am</p></header><div class="content"><p>I’m sorry if this has already been discussed, but what are the drawbacks of putting the variable&#39;s behaviors before the ‘var’ keyword?  Like this:<br></p><p>lazy synchronized var x:SomeType<br></p><p>That seems pretty ideal from a readability standpoint.<br></p><p>Matt<br></p><p>&gt; On Feb 14, 2016, at 05:05, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; • Angle brackets already appear in var declarations for generic types; that means there are two different meanings for angle brackets in the same construct.<br>&gt; Isn&#39;t the same true when you declare an array (or a closure)?<br>&gt; <br>&gt;&gt; • When we eventually allow you to apply multiple behaviors to a single property, that will also mean that *commas* are used in both of those angle bracket constructs, but with different meanings (one means &quot;chain these&quot;, the other means &quot;fill these two slots&quot;).<br>&gt; True, but imho also no deal breaker; I would like to have labeled generic parameters anyway ;-)<br>&gt; Afaics, it isn&#39;t decided how multiple behaviors will be handled yet.<br>&gt; <br>&gt;&gt; These are not fatal errors, but they&#39;re also completely unforced—either `[]` or `{}` would not have this problem. So why choose the option that has the problem?<br>&gt; Because those have a similar (and imho bigger) problems:<br>&gt; Grouping blocks of code or declaring arrays are things that are tightly coupled with &quot;their&quot; braces, and for me, &quot;&lt;&gt;&quot; causes the smallest disruption… arrays, capture lists and blocks have little in common with behaviors, but property behaviors could be expressed using generics*<br>&gt; <br>&gt; Tino<br>&gt; <br>&gt; * thinking of something like<br>&gt; <br>&gt; protocol Behavior {<br>&gt; 	typealias ValueType<br>&gt; 	var value: ValueType { get set }<br>&gt; }<br>&gt; <br>&gt; class DefaultBehavior&lt;T&gt; {<br>&gt; 	typealias ValueType = T<br>&gt; <br>&gt; 	var value: ValueType<br>&gt; <br>&gt; 	init(value: ValueType) {<br>&gt; 		self.value = value<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; class Sample {<br>&gt; 	var&lt;DefaultBehavior&gt; content: Int?<br>&gt; }<br>&gt; <br>&gt; Here, &quot;var&quot; would create a container whose behavior is determined by a generic parameter; access of &quot;content&quot; would be mapped to that container.<br>&gt; I know behaviors are supposed to work slightly different, but that doesn&#39;t destroy the mental model of a parameterized container.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160214/4ecc6427/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February 14, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; I’m sorry if this has already been discussed, but what are the drawbacks of putting the variable&#39;s behaviors before the ‘var’ keyword?  Like this:<br>&gt; <br>&gt; lazy synchronized var x:SomeType<br></p><p>With no prefix at all, this limits our ability to introduce declaration modifiers in the future. For instance, if the people clamoring for a `local` access modifier win in Swift 4, anyone who wrote a behavior called `local` will be very sad.<br></p><p>The other problem is, with this declaration:<br></p><p>	lazy var array = [1, 2, 3]<br></p><p>It offers no way to disambiguate between the two meanings of `lazy`:<br></p><p>	array.lazy.reset()<br>	array.lazy.map { ... }<br></p><p>Personally, if we&#39;re not going to use the `[]` syntax, I think we should use the `@` prefix and think of all uses of `@` throughout the language as eventual targets for behavior-ization (even if we don&#39;t get around to most of them in Swift 3, or some of them ever). It would be nice to have a rational explanation for what `@` means. But I&#39;m reasonably happy with the `[]` syntax.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f15a0ff25ea6c5069404a53da49297e?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Aditya Vaidyam</string> &lt;avaidyam at purdue.edu&gt;<p>February 14, 2016 at 03:00:00pm</p></header><div class="content"><p>Hello,<br></p><p>It’s my first time using this mailing list, so please do let me know if I’m doing something wrong.<br></p><p>I personally agree with the `[]` syntax because it allows for something more like `[lazy, atomic]` without having to look a lot like Java annotations (which do something completely different). I think the `@` syntax should be reserved for compiler directives. The `[]` mechanism also could be expanded on like so:<br></p><p>```swift<br>/// abc is both lazy and atomic in behavior<br>var [lazy, atomic] abc: Int = 1234<br></p><p>/// ^ expands to:<br>var `abc.lazy` = LazyBehavior&lt;Int&gt; { 1234 }<br>var `abc.atomic`: AtomicBehavior&lt;Int&gt; { `abc.lazy` }<br>var abc: Int {<br>	get { return `abc.atomic`.get() }<br>	set(val) { `abc.atomic`.set(val) }<br>}<br>```<br></p><p>That is, in the order of appearance of the behaviors within the brackets, their behaviors will become a composed chain. Now this also means that some behaviors can only be initial or terminal, which must be specified through other syntactical means. In addition:<br></p><p>```swift<br>/// abc has behavior `myBehavior` which requires a parameter<br>var [myBehavior(parameter: true)] abc: Int = 1234<br>```<br></p><p>Again, this also further increases complexity, and possibly the need for a separate `behavior` declaration, instead of piggybacking on `protocol` (it could possibly be similar to `operator` syntax?).<br></p><p>--<br>Aditya Vaidyam<br></p><p>Purdue University<br>College of Science ‘17<br>Neurobiology and Physiology, Computer Science, Pre-medicine<br></p><p>&gt; On Feb 14, 2016, at 3:36 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; I’m sorry if this has already been discussed, but what are the drawbacks of putting the variable&#39;s behaviors before the ‘var’ keyword?  Like this:<br>&gt;&gt; <br>&gt;&gt; lazy synchronized var x:SomeType<br>&gt; <br>&gt; With no prefix at all, this limits our ability to introduce declaration modifiers in the future. For instance, if the people clamoring for a `local` access modifier win in Swift 4, anyone who wrote a behavior called `local` will be very sad.<br>&gt; <br>&gt; The other problem is, with this declaration:<br>&gt; <br>&gt; 	lazy var array = [1, 2, 3]<br>&gt; <br>&gt; It offers no way to disambiguate between the two meanings of `lazy`:<br>&gt; <br>&gt; 	array.lazy.reset()<br>&gt; 	array.lazy.map { ... }<br>&gt; <br>&gt; Personally, if we&#39;re not going to use the `[]` syntax, I think we should use the `@` prefix and think of all uses of `@` throughout the language as eventual targets for behavior-ization (even if we don&#39;t get around to most of them in Swift 3, or some of them ever). It would be nice to have a rational explanation for what `@` means. But I&#39;m reasonably happy with the `[]` syntax.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160214/e9a580d8/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2b19ddab2d7de4523412c875c258e278?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Matt Whiteside</string> &lt;mwhiteside.dev at gmail.com&gt;<p>February 14, 2016 at 02:00:00pm</p></header><div class="content"><p>Thanks for explaining.  I forgot about access modifiers.<br></p><p>&gt; On Feb 14, 2016, at 12:36, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; I’m sorry if this has already been discussed, but what are the drawbacks of putting the variable&#39;s behaviors before the ‘var’ keyword?  Like this:<br>&gt;&gt; <br>&gt;&gt; lazy synchronized var x:SomeType<br>&gt; <br>&gt; With no prefix at all, this limits our ability to introduce declaration modifiers in the future. For instance, if the people clamoring for a `local` access modifier win in Swift 4, anyone who wrote a behavior called `local` will be very sad.<br>&gt; <br>&gt; The other problem is, with this declaration:<br>&gt; <br>&gt; 	lazy var array = [1, 2, 3]<br>&gt; <br>&gt; It offers no way to disambiguate between the two meanings of `lazy`:<br>&gt; <br>&gt; 	array.lazy.reset()<br>&gt; 	array.lazy.map { ... }<br>&gt; <br>&gt; Personally, if we&#39;re not going to use the `[]` syntax, I think we should use the `@` prefix and think of all uses of `@` throughout the language as eventual targets for behavior-ization (even if we don&#39;t get around to most of them in Swift 3, or some of them ever). It would be nice to have a rational explanation for what `@` means. But I&#39;m reasonably happy with the `[]` syntax.<br></p><p>Yes, the ‘@‘ seems worth thinking about here.<br></p><p>Matt<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e7e554db1f80d7d6041d92edd5145698?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Hooman Mehr</string> &lt;hooman at mac.com&gt;<p>February 18, 2016 at 10:00:00pm</p></header><div class="content"><p>How about this:<br></p><p>Assuming behaviors are extensions of var (and maybe let in the future) and showing these extensions, just like file extensions appended with dot:<br></p><p>var.lazy foo = 1738<br></p><p>var extension lazy&lt;Value&gt; = initialValue {<br>  var value: Value? = nil<br></p><p>  mutating get {<br>    if let value = value {<br>      return value<br>    }<br>    let initial = initialValue<br>    value = initial<br>    return initial<br>  }<br>  set {<br>    value = newValue<br>  }<br>}<br></p><p>var extension resettable&lt;Value&gt; = initialValue {<br></p><p>  //...<br>  func reset() { /**/ }<br></p><p>}<br></p><p>// Declare valid composition, enforcing order or composition:<br>var.resettable extension lazy&lt;Value&gt; = initialValue {<br></p><p>  var.resettable value: Value? = nil<br>  //...<br>  override func reset() { /**/ }<br></p><p>}<br></p><p>var.lazy.resettable property1: Double = 3.1415927<br>var.resettable property2: Int = 123<br></p><p>property1.var.reset() // Not shadowed<br>property2.var.reset() // Not shadowed<br></p><p>property1.var.lazy.resettable.reset() // Full Path<br>property1.var.resettable.reset() // Full Path<br></p><p>property1.var._.resettable.reset() // Wild-card path<br>property2.var._.resettable.reset() // Wild-card path<br></p><p><br>This way we don’t have any new keywords or overloading symbols like # and @ with new meanings. The use of dot, I think seems the most natural. property.var.* creates a distinct namespace and since var is already a keyword, does not collide with anything. <br></p><p>The same logic may also work for defining function decorators as func extension remote… (decorator/behavior declaration) and func.remote f() (function declaration) f.func.connect() (member invocation)<br></p><p>&gt; On Feb 14, 2016, at 12:36 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; I’m sorry if this has already been discussed, but what are the drawbacks of putting the variable&#39;s behaviors before the ‘var’ keyword?  Like this:<br>&gt;&gt; <br>&gt;&gt; lazy synchronized var x:SomeType<br>&gt; <br>&gt; With no prefix at all, this limits our ability to introduce declaration modifiers in the future. For instance, if the people clamoring for a `local` access modifier win in Swift 4, anyone who wrote a behavior called `local` will be very sad.<br>&gt; <br>&gt; The other problem is, with this declaration:<br>&gt; <br>&gt; 	lazy var array = [1, 2, 3]<br>&gt; <br>&gt; It offers no way to disambiguate between the two meanings of `lazy`:<br>&gt; <br>&gt; 	array.lazy.reset()<br>&gt; 	array.lazy.map { ... }<br>&gt; <br>&gt; Personally, if we&#39;re not going to use the `[]` syntax, I think we should use the `@` prefix and think of all uses of `@` throughout the language as eventual targets for behavior-ization (even if we don&#39;t get around to most of them in Swift 3, or some of them ever). It would be nice to have a rational explanation for what `@` means. But I&#39;m reasonably happy with the `[]` syntax.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160218/0f551fab/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>February 14, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On 14 Feb 2016, at 11:08, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; I ask again:<br>&gt;&gt; What is wrong with arrow brackets?<br>&gt;&gt; <br>&gt;&gt; var&lt;lazy&gt; foo<br>&gt; <br>&gt; 	var&lt;lazy, synchronized&gt; foo: Dictionary&lt;Int, Set&lt;Optional&lt;String&gt;&gt;<br>&gt; <br>&gt; So, two problems:<br>&gt; <br>&gt; • Angle brackets already appear in var declarations for generic types; that means there are two different meanings for angle brackets in the same construct.<br>&gt; <br>&gt; • When we eventually allow you to apply multiple behaviors to a single property, that will also mean that *commas* are used in both of those angle bracket constructs, but with different meanings (one means &quot;chain these&quot;, the other means &quot;fill these two slots&quot;).<br>&gt; <br>&gt; These are not fatal errors, but they&#39;re also completely unforced—either `[]` or `{}` would not have this problem. So why choose the option that has the problem?<br></p><p>Do we need braces and commas at all? It seems to me that you can just do:<br></p><p>	var lazy synchronized foo: Dictionary&lt;Int, Set&lt;Optional&lt;String&gt;&gt;&gt;<br></p><p>The name is always the one right before the colon, so this actually seems fine to me. If Xcode can colour them differently then it shouldn’t be hard to follow IMO. The order implies the order in which they are resolved where relevant, i.e- foo is mutable, then lazy, then synchronised.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2969f67fc010e956c71442148f3f6fc0?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Wallacy</string> &lt;wallacyf at gmail.com&gt;<p>February 14, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt;<br>https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md<br></p><p>As for the proposal itself:<br></p><p>&gt;       • What is your evaluation of the proposal?<br></p><p>+1.<br></p><p>However, like Brent says: &quot;this proposal is a good core for property<br>behaviors, but alone, I don&#39;t think it carries its own weight. It will need<br>at least a couple of the items in &quot;Future Directions&quot; section before it&#39;s<br>really worth having.&quot;<br></p><p>In the fact, i prefer the first version of the proposal, the first version<br>is more &quot;must do&quot;, this one is &quot;just nice&quot;.<br></p><p>And i&#39;m not convincing of the syntax to, i prefer something like that:<br>Pipe ( | | ) operator instead `[ ]`, `{ }` or `&lt; &gt;`<br></p><p>var |lazy| a = ...<br>var |observable| b = ...<br></p><p>and this to access:<br></p><p>a*#*clear() // yes, without the dot.<br>b*#*addObserver()<br></p><p>&quot;[] delimiters are heavily array/collection/subscript-centric&quot; (Chris)<br></p><p>&gt;       • Is the problem being addressed significant enough to warrant a<br>change to Swift?<br></p><p>Yes. Sure, i love the entire idea behind this proposal, i think this will<br>very beneficial for the language.<br></p><p>&gt;       • Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes.<br></p><p>&gt;       • If you have used other languages or libraries with a similar<br>feature, how do you feel that this proposal compares to those?<br></p><p>Just some &quot;hacks&quot; in Objective-C.<br></p><p>&gt;       • How much effort did you put into your review? A glance, a quick<br>reading, or an in-depth study?<br></p><p>I participated in the preliminary discussions re-read all variants of this<br>proposal a lot of times.<br></p><p><br>Em dom, 14 de fev de 2016 às 20:35, Haravikk via swift-evolution &lt;<br>swift-evolution at swift.org&gt; escreveu:<br></p><p>&gt;<br>&gt; &gt; On 14 Feb 2016, at 11:08, Brent Royal-Gordon via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt; I ask again:<br>&gt; &gt;&gt; What is wrong with arrow brackets?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; var&lt;lazy&gt; foo<br>&gt; &gt;<br>&gt; &gt;       var&lt;lazy, synchronized&gt; foo: Dictionary&lt;Int, Set&lt;Optional&lt;String&gt;&gt;<br>&gt; &gt;<br>&gt; &gt; So, two problems:<br>&gt; &gt;<br>&gt; &gt; • Angle brackets already appear in var declarations for generic types;<br>&gt; that means there are two different meanings for angle brackets in the same<br>&gt; construct.<br>&gt; &gt;<br>&gt; &gt; • When we eventually allow you to apply multiple behaviors to a single<br>&gt; property, that will also mean that *commas* are used in both of those angle<br>&gt; bracket constructs, but with different meanings (one means &quot;chain these&quot;,<br>&gt; the other means &quot;fill these two slots&quot;).<br>&gt; &gt;<br>&gt; &gt; These are not fatal errors, but they&#39;re also completely unforced—either<br>&gt; `[]` or `{}` would not have this problem. So why choose the option that has<br>&gt; the problem?<br>&gt;<br>&gt; Do we need braces and commas at all? It seems to me that you can just do:<br>&gt;<br>&gt;         var lazy synchronized foo: Dictionary&lt;Int, Set&lt;Optional&lt;String&gt;&gt;&gt;<br>&gt;<br>&gt; The name is always the one right before the colon, so this actually seems<br>&gt; fine to me. If Xcode can colour them differently then it shouldn’t be hard<br>&gt; to follow IMO. The order implies the order in which they are resolved where<br>&gt; relevant, i.e- foo is mutable, then lazy, then synchronised.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160214/567c8d18/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc045f9bdc3bd1885767f2a2ba8af458?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Jonathan Tang</string> &lt;jonathan.d.tang at gmail.com&gt;<p>February 11, 2016 at 02:00:00am</p></header><div class="content"><p>On Wed, Feb 10, 2016 at 2:00 PM, Douglas Gregor via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hello Swift community,<br>&gt;<br>&gt; The review of SE-0030 &quot;Property Behaviors&quot; begins now and runs through<br>&gt; February, 2016. The proposal is available here:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md<br>&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-proposal.md&gt;<br>&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt; should be sent to the swift-evolution mailing list at<br>&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the<br>&gt; review manager. When replying, please try to keep the proposal link at the<br>&gt; top of the message:<br>&gt;<br>&gt; Proposal link:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md<br>&gt;<br>&gt; Reply text<br>&gt;<br>&gt; Other replies<br>&gt;<br>&gt; &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What<br>&gt; goes into a review?<br>&gt;<br>&gt; The goal of the review process is to improve the proposal under review<br>&gt; through constructive criticism and, eventually, determine the direction of<br>&gt; Swift. When writing your review, here are some questions you might want to<br>&gt; answer in your review:<br>&gt;<br>&gt;    - What is your evaluation of the proposal?<br>&gt;<br>&gt; Would it be out-of-scope to propose extending this to functions?  I can<br>think of several use-cases:<br></p><p>1.) Providing both static &amp; singleton accessors, for the convenience of<br>users of your library.  In a library I&#39;ve been writing, I&#39;ve found that all<br>my configuration calls take this form:<br></p><p>public static func useCoreData() -&gt; Self { return<br>sharedInstance().useCoreData() }<br>public func useCoreData() { /* Code here; */ return self }<br></p><p>public static func useNotifications() -&gt; Self { return<br>sharedInstance().useNotifications() }<br>public func useNotifications() { /* Code here; */ return self }<br></p><p>I&#39;d love to be able to do (using the ... syntax for the proposed splat<br>operator being discussed in another thread):<br></p><p>public behavior func [StaticChainable] name(...ArgumentType) -&gt; ResultType {<br>  public static func name(...args) -&gt; Self { return<br>sharedInstance().name(...args) }<br>  public func name() { body; return self }<br>}<br></p><p>public func [StaticChainable] useCoreData() { /* Code here */ }<br>public func [StaticChainable] useNotifications() { /* Code here */ }<br></p><p>2.) Providing both &quot;whole&quot; and &quot;parts&quot; versions of Composite Pattern<br>methods.  Very often, you might have a tree structure where each element<br>has the same type (or conforms to the same protocol).  You want a method<br>with an optional first arg to specify which element you&#39;re operating on:<br></p><p>public func move(toElement: DOMElement, edge: EdgeType) { /* Code here */ }<br>public func move(childWithID id: String, toElement elem: DOMElement, edge:<br>EdgeType {<br>  children[id].move(toElement: elem, edge: edge)<br>}<br></p><p>public func hide() { /* Code here */ }<br>public func hide(childWithID id: String) { children[id].hide() }<br></p><p>public func show() { /* Code here */}<br>public func show(childWithID id: String) { children[id].show() }<br></p><p>vs.<br></p><p>public behavior func [Composite] name(...ArgumentType) -&gt; ResultType where<br>Self: HasChildren {<br>  public func name(...args) { body }<br>  public func name(childWithID id: String, ...args) {<br>self.children[id].name(...args) }<br>}<br></p><p>public func [Composite] move(toElement: DOMElement, edge: EdgeType) { /*<br>Code here */ }<br>public func [Composite] show() { /* Code here */ }<br>public func [Composite] hide() { /* Code here */ }<br></p><p>3.) Or you have a number of convenience functions that differ only in what<br>helpers they invoke:<br></p><p>public func remove(elementAtIndex i: Index) { /* Code here */ }<br>public func remove(element: Generator.Element) { remove(elementAtIndex:<br>indexOf(element)) }<br>public func remove(firstMatchingPredicate pred: Generator.Element throws -&gt;<br>Bool) {<br>   remove(elementAtIndex: indexOf(pred))<br>}<br></p><p>public func insertAfter(elementAtIndex i: Index, newElement:<br>Generator.Element) { /* Code here */ }<br>public func insertAfter(element: Generator.Element, newElement:<br>Generator.Element) {<br>   remove(elementAtIndex: indexOf(element))<br>}<br>public func insertAfter(firstMatchingPredicate pred: Generator.Element<br>throws -&gt; Bool, newElement: Generator.Element) {<br>   remove(elementAtIndex: indexOf(pred))<br>}<br></p><p>public func insertBefore(elementAtIndex i: Index, newElement:<br>Generator.Element) { /* Code here */ }<br>public func insertBefore(element: Generator.Element, newElement:<br>Generator.Element) {<br>   remove(elementAtIndex: indexOf(element))<br>}<br>public func insertBefore(firstMatchingPredicate pred: Generator.Element<br>throws -&gt; Bool, newElement: Generator.Element) {<br>   remove(elementAtIndex: indexOf(pred))<br>}<br></p><p>4.) Sometimes you need to define a combination of functions and related<br>properties, like in the Builder Pattern.  (Note the usage of &quot;return self&quot;<br>here - that&#39;s why this is not done with straight settable properties, it&#39;s<br>so the user can chain set calls together and avoid repeating the object<br>name):<br></p><p>private var foo : String<br>public func setFoo(newValue: String) -&gt; Self { foo = newValue; return self }<br></p><p>private var bar : String<br>public func setBar(newValue: String) -&gt; Self { bar = newValue; return self }<br></p><p>private var baz : String<br>public func setBaz(newValue: String) -&gt; Self { baz = newValue; return self }<br></p><p>(Also this is a good opportunity to use the &quot;set once&quot; behavior mentioned<br>in the proposal, but I won&#39;t repeat that code here.)<br></p><p>public behavior var [Builder] name: Type = initialValue {<br>  private var name: Type = initialValue<br>  public func set##name(newValue: Type) -&gt; Self { name = newValue; return<br>self }<br>}<br></p><p>public var [Builder] foo: String<br>public var [Builder] bar: String<br>public var [Builder] baz: String<br></p><p>Notice that this is a &quot;var&quot; behavior rather than a &quot;func&quot; behavior...I&#39;d<br>envision the keyword matching the type of entity you *decorate*, not the<br>type of entity generated.  The declarations are public because the access<br>modifier of the declaration should set a *maximum* visibility, not a<br>minimum (i.e. you can always make individual instances of a behavior more<br>restrictive).  ## is a token-pasting operation similar to the C<br>preprocessor; it lets you construct a new name out of identifiers.  I&#39;d<br>assume it would do automatic capitalization of the second argument to<br>preserve camelCasing.<br></p><p>5.) Sometimes you need a whole suite of classes, functions, and variables.<br>For example, think of event handlers:<br></p><p>public behavior class [Event] name {<br>  public class name##Event : Event {<br>    body<br></p><p>    func preventDefault() { ... }<br>  }<br></p><p>  public protocol name##Listener {<br>    public func on##name(event: name##Event)<br>  }<br></p><p>  private var listeners = [name##Listener]()<br>  public func add##name##Listener(listener: name##Listener) {<br>    listeners.append(listener)<br>  }<br>  public func remove##name##Listener(listener: name##Listener) {<br>    listeners.remove(atIndex: listeners.indexOf(listener))<br>  }<br></p><p>  func fire##name##Event(event: name##Event) {<br>    for listener in listeners {<br>      listener(event)<br>    }<br>  }<br>}<br></p><p>class [Event] Click {<br>  let windowCoordinates: Point<br>  let viewCoordinates: Point<br>}<br></p><p>class [Event] TouchDown {<br>  struct Touch {<br>    let coordinates: Point<br>    let force: Double<br>  }<br>  let touches: [Touch]<br>}<br></p><p><br>The way I&#39;d envision this extension working is that the &quot;behavior&quot; keyword<br>could be followed by any top-level entity: let/var, func, class, struct,<br>enum.  The behavior then forms a template for entities to be generated and<br>expanded in place.  &#39;name&#39; is bound to the name of the entity, &#39;body&#39; to<br>the statement body from the grammar.  Functions can define individual<br>arguments, types, and a result type, or can use whatever the outcome of the<br>splatting discussion is as &quot;all remaining arguments, taken from the<br>instantiating func declaration.&quot;  Classes can also bind the supertype and<br>associated types.  I don&#39;t think it&#39;s necessary to be able to reach into<br>the body and parse it for individual statements; at least, none of the<br>use-cases I thought of require this.<br></p><p>All the scoping &amp; storage concerns are as per the original proposal.  Code<br>within the body is not allowed to access code inside the behavior (beyond -<br>possibly? - calling public member functions or properties that are defined<br>by the behavior).  When generating names from behavior expansion, the<br>compiler checks for name conflicts with any other symbols.  Code within the<br>behavior is not allowed to inspect or destructure the body beyond the<br>bindings already described, but may call other methods either within the<br>behavior or within the hosting class if the class conforms to a protocol<br>(as per the existing proposal).  (Perhaps some form of limited<br>destructuring could be allowed as a generalization of accessor<br>requirements; allow binding names to functions with the &#39;func&#39; keyword in<br>classes, binding to variables with &#39;let&#39; in function bodies, etc.  Haven&#39;t<br>really thought this through, may end up being too complicated.)<br></p><p>A couple features of the existing proposal can be removed under this<br>generalization.  The syntax for calling a method of a property isn&#39;t<br>necessary; instead of x.[lazy].clear, define &quot;func clear##name&quot; inside the<br>behavior and call it as clearX().  (This also eliminates the need to have<br>debates over what that syntax should be. :-))  It also lifts the<br>restriction on &#39;let&#39; parameters, as these are just another top-level entity<br>that could be expanded to a set of other entities.  They wouldn&#39;t allow<br>accessors or get/set blocks, however; the purpose of this would not be to<br>allow computed &#39;let&#39; properties, it would be to fold in additional<br>functionality into these declarations.  One could imagine libraries that<br>allow clients to auto-delegate all method calls in a protocol to a<br>sub-object, for example:<br></p><p>public behavior let [DelegateCNContactPicker] name: Type = initialValue<br>      where Type: CNContactPickerDelegate, Self: CNContactPickerDelegate,  {<br>  public func contactPickerDidCancel(...args) {<br>name.contactPickerDidCancel(...args) }<br>  public func contactPicker(...args) { name.contactPicker(...args)<br>  // Should it include overloads implicitly with ...args?  Or should each<br>be overridden explicitly?<br>}<br></p><p>and then its use:<br></p><p>class MyViewController: CNContactPickerDelegate {<br>  private let [DelegateCNContactPicker] myObjectThatReallyHandlesIt =<br>MyContactPickerDelegate()<br>  // No forwarding methods needed, and no need to expose<br>myObjectThatReallyHandlesIt to the outside world.<br>}<br></p><p>I think this mechanism may also be able to subsume default methods on<br>protocols - instead of using an extension, you could use a behavior with a<br>protocol constraint.  I haven&#39;t really thought through the implications of<br>this, though, in particular the possibility of protocols with storage.  May<br>not be possible, in which case we wouldn&#39;t want to allow behaviors on<br>protocols.<br></p><p><br>&gt;<br>&gt;    - Is the problem being addressed significant enough to warrant a<br>&gt;    change to Swift?<br>&gt;<br>&gt; Yes.  There are a number of use-cases here, and it generalizes several<br>special-case features that are currently baked into the compiler.<br></p><p><br>&gt;<br>&gt;    - Does this proposal fit well with the feel and direction of Swift?<br>&gt;<br>&gt; I think so, but I&#39;ll let people with a better sense of the feel and<br>direction of Swift make that decision.<br></p><p><br>&gt;<br>&gt;    - If you have used other languages or libraries with a similar<br>&gt;    feature, how do you feel that this proposal compares to those?<br>&gt;<br>&gt; It reminds me a lot of Lisp macros, and in particular the ability to<br>define many entities at once or intercept the definition of those entities<br>(used to good effect in CLOS).  This is one of the best features of Lisp;<br>it lets you eliminate much of the boilerplate that shows up in<br>production-quality libraries for Java, C#, C++, etc.<br></p><p>Behaviors let you side-step many of the hygiene/gensym issues of Lisp<br>because they can&#39;t appear in unrestricted contexts the way Lisp macros<br>can.  Even generalized to allow function &amp; class bodies, the set of symbols<br>that may be visible inside the behavior body is limited to keywords &amp;<br>argument lists in the language definition itself; you don&#39;t need to build a<br>whole symbol table to see which symbols are visible inside the behavior,<br>and you don&#39;t need to worry about inserting arbitrary blocks of code into<br>arbitrary insertion points.  This limits the flexibility of behaviors a bit<br>(eg. you could never do something like loop or destructuring-bind as a<br>behavior), but it still seems like they cover a lot of the most annoying<br>boilerplate cases.<br></p><p>It&#39;s also somewhat similar to aspect-oriented programming, and to Python<br>decorators.  Seems to be both more and less powerful than these - more<br>powerful in that you can define multiple get/set/accessors at once and<br>scope any code required by them, and less powerful because as it currently<br>stands you can&#39;t intercept functions.<br></p><p><br>&gt;<br>&gt;    - How much effort did you put into your review? A glance, a quick<br>&gt;    reading, or an in-depth study?<br>&gt;<br>&gt;<br>Read through the proposal fully, skimmed some of the responses, wrote up a<br>lot of examples.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/ce2f9d65/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>February 11, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Feb 11, 2016, at 2:12 AM, Jonathan Tang &lt;jonathan.d.tang at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Wed, Feb 10, 2016 at 2:00 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of SE-0030 &quot;Property Behaviors&quot; begins now and runs through February, 2016. The proposal is available here:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-proposal.md&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br>&gt; <br>&gt; Proposal link:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md&gt;<br>&gt; Reply text<br>&gt; <br>&gt; Other replies<br>&gt;  &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; What is your evaluation of the proposal?<br>&gt; Would it be out-of-scope to propose extending this to functions? [snip]<br></p><p>I just want to weigh in on this about expansions of the proposal. I think large expansions of the proposal are out-of-scope and should be handled in follow-on discussions, particularly in cases where the proposal is already fairly large. The big exception here is if the feature as proposed doesn’t stand well on its own: for example, it’s not actually useful without some particular expansion, so it shouldn’t be accepted. From reading the rest of your review, I don’t think you believe that expansion to functions is necessary for behaviors to be useful—but that behaviors could be better if they were extended to functions. In that case, I’d call it a follow-on discussion.<br></p><p>	- Doug<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/2052d964/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc045f9bdc3bd1885767f2a2ba8af458?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Jonathan Tang</string> &lt;jonathan.d.tang at gmail.com&gt;<p>February 11, 2016 at 11:00:00am</p></header><div class="content"><p>On Thu, Feb 11, 2016 at 11:05 AM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Feb 11, 2016, at 2:12 AM, Jonathan Tang &lt;jonathan.d.tang at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Wed, Feb 10, 2016 at 2:00 PM, Douglas Gregor via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Hello Swift community,<br>&gt;&gt;<br>&gt;&gt; The review of SE-0030 &quot;Property Behaviors&quot; begins now and runs through<br>&gt;&gt; February, 2016. The proposal is available here:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md<br>&gt;&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-proposal.md&gt;<br>&gt;&gt;<br>&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt;&gt; should be sent to the swift-evolution mailing list at<br>&gt;&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; or, if you would like to keep your feedback private, directly to the<br>&gt;&gt; review manager. When replying, please try to keep the proposal link at the<br>&gt;&gt; top of the message:<br>&gt;&gt;<br>&gt;&gt; Proposal link:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md<br>&gt;&gt;<br>&gt;&gt; Reply text<br>&gt;&gt;<br>&gt;&gt; Other replies<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What<br>&gt;&gt; goes into a review?<br>&gt;&gt;<br>&gt;&gt; The goal of the review process is to improve the proposal under review<br>&gt;&gt; through constructive criticism and, eventually, determine the direction of<br>&gt;&gt; Swift. When writing your review, here are some questions you might want to<br>&gt;&gt; answer in your review:<br>&gt;&gt;<br>&gt;&gt;    - What is your evaluation of the proposal?<br>&gt;&gt;<br>&gt;&gt; Would it be out-of-scope to propose extending this to functions? [snip]<br>&gt;<br>&gt;<br>&gt; I just want to weigh in on this about expansions of the proposal. I think<br>&gt; large expansions of the proposal are out-of-scope and should be handled in<br>&gt; follow-on discussions, particularly in cases where the proposal is already<br>&gt; fairly large. The big exception here is if the feature as proposed doesn’t<br>&gt; stand well on its own: for example, it’s not actually useful without some<br>&gt; particular expansion, so it shouldn’t be accepted. From reading the rest of<br>&gt; your review, I don’t think you believe that expansion to functions is<br>&gt; necessary for behaviors to be useful—but that behaviors could be better if<br>&gt; they were extended to functions. In that case, I’d call it a follow-on<br>&gt; discussion.<br>&gt;<br>&gt; - Doug<br>&gt;<br>&gt;<br>How about contractions of the proposal then? :-)<br></p><p>The only part of the existing proposal that my brainstorm last night<br>actually changed (as opposed to extended) was the need for behavior-added<br>methods on properties and a syntax for calling them (the foo.[lazy].clear()<br>case).  This also seems to be one of the more contentious parts in the<br>discussion here, and appears to be non-critical in the use-cases listed in<br>the proposal.  So +1 to the proposal itself, -1 to the ability to add<br>methods to properties and call them, with the latter perhaps separated out<br>into a future extension.  +1 for keeping the underbar in the behavior<br>definition syntax, or even explicitly binding it to a string literal; it<br>seems quite likely this will be useful.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/f0455725/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February 11, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Feb 11, 2016, at 11:26 AM, Jonathan Tang via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; How about contractions of the proposal then? :-)<br>&gt; <br>&gt; The only part of the existing proposal that my brainstorm last night actually changed (as opposed to extended) was the need for behavior-added methods on properties and a syntax for calling them (the foo.[lazy].clear() case).  This also seems to be one of the more contentious parts in the discussion here, and appears to be non-critical in the use-cases listed in the proposal.  So +1 to the proposal itself, -1 to the ability to add methods to properties and call them, with the latter perhaps separated out into a future extension.  +1 for keeping the underbar in the behavior definition syntax, or even explicitly binding it to a string literal; it seems quite likely this will be useful.<br></p><p>Sure, that&#39;s definitely a suite of functionality that could be factored into its own discussion.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/df865853/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>February 14, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; What is your evaluation of the proposal?<br></p><p>I think property behaviors are a nice idea. But I feel the current proposal is trying to handle too many disparate use cases using an approach that doesn&#39;t work that well for all of them.<br></p><p>I already expressed my view of this in pre-review, and I&#39;m a bit disappointed to see no mention of my suggestions in the &quot;Alternatives considered&quot; section. Basically I think this proposal should be broken in three or four separate smaller features that can each stand on their own:<br></p><p>1. the ability to add `func`, `var`, and `let` inside any property declaration to handle metadata and meta-operations. For instance:<br></p><p>	var count: Int {<br>		func reset() { count = 0 }<br>	}<br></p><p>	count::reset() // or some other syntax<br></p><p>	var root: NSObject {<br>		var lastModified: NSDate? = nil<br>		didSet { lastModified = NSDate() }<br>	}<br></p><p>	print(root::lastAccess)<br></p><p>	var lang: String {<br>		let xmlName = &quot;xml:lang&quot;<br>	}<br></p><p>	element.addAttribute(name: lang::xmlName, value: lang)<br></p><p>2. the ability to encapsulate those `func` and `var` inside a behaviour for reuse:<br></p><p>	behavior resettable&lt;T&gt;: T {<br>		func reset() { currentValue = initValue }<br>	}<br>	var [resettable] count: Int<br></p><p>	count::reset() // or some other syntax<br></p><p>	behavior changeMonitored&lt;T&gt;: T {<br>		var lastModified: NSDate? = nil<br>		didSet { lastModified = NSDate() }<br>	}<br>	var [changeMonitored] root: NSObject<br></p><p>	print(root::lastModified)<br></p><p>3. the ability for the behavior (extending point 2) to change the base storage type of the property:<br></p><p>	behavior synchronized&lt;T&gt;: Synchronized&lt;T&gt; {<br>		get { return currentValue.value }<br>		set { currentValue.value = newValue }<br>	}<br></p><p>	var [synchronized] count: Int<br></p><p>	count = 1<br></p><p>4. a way to define property observers such as `willSet` globally, with no need to attach a particular behavior to a variable:<br></p><p>	observer willSet&lt;T&gt;(newValue: T) {<br>		set {<br>			willSet(newValue)<br>			currentValue = newValue<br>		}<br>	}<br></p><p>	var count: Int {<br>		willSet {<br>			print(&quot;\(count) will become \(newValue)&quot;)<br>		}<br>	}<br></p><p>I don&#39;t have a fully formed proposal, but there&#39;s a bit more details in a relatively recent discussion here (I changed the syntax a bit since then):<br></p><p>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160118/007194.html<br>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160118/007238.html<br>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160118/007295.html<br></p><p><br>&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p><br>There are many disparate problems this proposal is trying to address.<br></p><p>Some of the problems illustrated in the proposal would benefit from it, but not all. In some cases, such as the `observed` behavior, it makes things worse because your observer functions have to be tied to a behavior attached to the variable.<br></p><p><br>&gt; Does this proposal fit well with the feel and direction of Swift?<br></p><p>Accessing functions inside behaviors such as `resettable` adds two layers of metadata/meta-operations to the property (one is the behavior name, the other is the `reset()` function). I would argue that including `resettable` before calling a `reset()` function is redundant. It is also against the principles of separation between the interface and the implementation since you might want to define `reset()` in your own way for some variables, which would entail the creation of a separate behavior with a different name, which would change the way you make your `reset()` call. To me, the way you can call behavior functions seems rather heavyweight and inflexible.<br></p><p>Swift currently lets you add `willSet` and `didSet` observers without having to opt-in through some special syntax. Requiring that a behavior be added, such as `observed` before being able to use these or other custom kinds of observers seems like a step in the wrong direction to me.<br></p><p>That&#39;s the two main points that I think don&#39;t work well in the current proposal when compared to the rest of Swift.<br></p><p><br>&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>I haven&#39;t.<br></p><p>Though the syntax `property.[behavior].func()` reminds be a bit of how you select an axis when accessing nodes in XPath.<br></p><p><br>&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I followed and participated to the discussions pre-review. I have less time to follow it now, so I might have missed recent developments.<br></p><p><br>-- <br>Michel Fortin<br>https://michelf.ca<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3e4acc351c34224514f9d58b08389390?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Myles Schultz</string> &lt;myleslschultz at icloud.com&gt;<p>February 14, 2016 at 02:00:00pm</p></header><div class="content"><p>+1 for this review. I feel the same in regard to the clunky interface. It feels redundant and an extension instead of part of the property. One could argue that that is what was I ended, but...<br></p><p>On Feb 14, 2016, at 12:16 PM, Michel Fortin via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; There are many disparate problems this proposal is trying to address.<br>&gt; <br>&gt; Some of the problems illustrated in the proposal would benefit from it, but not all. In some cases, such as the `observed` behavior, it makes things worse because your observer functions have to be tied to a behavior attached to the variable.<br>&gt; <br>This is what I have been trying to say. One shouldn&#39;t have to invoke the behavior to get the behavior. It should be understood from declaration the a given property has a given set of behaviors. <br>&gt; <br>&gt;&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt; <br>&gt; Accessing functions inside behaviors such as `resettable` adds two layers of metadata/meta-operations to the property (one is the behavior name, the other is the `reset()` function). I would argue that including `resettable` before calling a `reset()` function is redundant.<br></p><p>Again, what Have been trying to say:  you shouldn&#39;t need to say, &quot;property, I&#39;m going to use this behavior I gave you. Behavior please do ____&quot;. It&#39;s clunky and makes you feel like your now dealing with the property, but a third party. It&#39;s like HIPPA when you have a patient with dementia--&quot;I&#39;m going to discuss some things with your family unless you don&#39;t have any other questions. Family ... &quot; (forgive me, I&#39;m a physician, so this analogy makes sense to me). <br></p><p>&gt; It is also against the principles of separation between the interface and the implementation since you might want to define `reset()` in your own way for some variables, which would entail the creation of a separate behavior with a different name, which would change the way you make your `reset()` call. To me, the way you can call behavior functions seems rather heavyweight and inflexible.<br></p><p>This was pointed out to me that if the property and the behavior have a function with the same name, the problem of which to choose begins. I agree that this should be a non-issue. This leaves too much of the language implementation exposed to user of the language. To me the ideal would be to state that a property has some behavior and then everything &quot;just works&quot; from there with having to micromanage the behavior. We don&#39;t tell ARC what to do. Maybe that&#39;s a poor example, but it seems like it is on the same level. <br>&gt; <br>&gt; Swift currently lets you add `willSet` and `didSet` observers without having to opt-in through some special syntax. Requiring that a behavior be added, such as `observed` before being able to use these or other custom kinds of observers seems like a step in the wrong direction to me.<br></p><p>I really didn&#39;t like this part of the proposal, but you take the good with the bad. I like that property over are available from the get go. You don&#39;t have to manually say, &quot;property, I grant you the ability to observe&quot;.<br></p><p>&gt; <br>&gt; -- <br>&gt; Michel Fortin<br>&gt; https://michelf.ca<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>February 15, 2016 at 06:00:00am</p></header><div class="content"><p>I like this alternative proposal and would like to see it discussed more deeply, as it seems to be very lightweight and natural.<br></p><p>-Thorsten <br></p><p>Am 14.02.2016 um 18:16 schrieb Michel Fortin via swift-evolution &lt;swift-evolution at swift.org&gt;:<br></p><p>&gt;&gt; What is your evaluation of the proposal?<br>&gt; <br>&gt; I think property behaviors are a nice idea. But I feel the current proposal is trying to handle too many disparate use cases using an approach that doesn&#39;t work that well for all of them.<br>&gt; <br>&gt; I already expressed my view of this in pre-review, and I&#39;m a bit disappointed to see no mention of my suggestions in the &quot;Alternatives considered&quot; section. Basically I think this proposal should be broken in three or four separate smaller features that can each stand on their own:<br>&gt; <br>&gt; 1. the ability to add `func`, `var`, and `let` inside any property declaration to handle metadata and meta-operations. For instance:<br>&gt; <br>&gt;    var count: Int {<br>&gt;        func reset() { count = 0 }<br>&gt;    }<br>&gt; <br>&gt;    count::reset() // or some other syntax<br>&gt; <br>&gt;    var root: NSObject {<br>&gt;        var lastModified: NSDate? = nil<br>&gt;        didSet { lastModified = NSDate() }<br>&gt;    }<br>&gt; <br>&gt;    print(root::lastAccess)<br>&gt; <br>&gt;    var lang: String {<br>&gt;        let xmlName = &quot;xml:lang&quot;<br>&gt;    }<br>&gt; <br>&gt;    element.addAttribute(name: lang::xmlName, value: lang)<br>&gt; <br>&gt; 2. the ability to encapsulate those `func` and `var` inside a behaviour for reuse:<br>&gt; <br>&gt;    behavior resettable&lt;T&gt;: T {<br>&gt;        func reset() { currentValue = initValue }<br>&gt;    }<br>&gt;    var [resettable] count: Int<br>&gt; <br>&gt;    count::reset() // or some other syntax<br>&gt; <br>&gt;    behavior changeMonitored&lt;T&gt;: T {<br>&gt;        var lastModified: NSDate? = nil<br>&gt;        didSet { lastModified = NSDate() }<br>&gt;    }<br>&gt;    var [changeMonitored] root: NSObject<br>&gt; <br>&gt;    print(root::lastModified)<br>&gt; <br>&gt; 3. the ability for the behavior (extending point 2) to change the base storage type of the property:<br>&gt; <br>&gt;    behavior synchronized&lt;T&gt;: Synchronized&lt;T&gt; {<br>&gt;        get { return currentValue.value }<br>&gt;        set { currentValue.value = newValue }<br>&gt;    }<br>&gt; <br>&gt;    var [synchronized] count: Int<br>&gt; <br>&gt;    count = 1<br>&gt; <br>&gt; 4. a way to define property observers such as `willSet` globally, with no need to attach a particular behavior to a variable:<br>&gt; <br>&gt;    observer willSet&lt;T&gt;(newValue: T) {<br>&gt;        set {<br>&gt;            willSet(newValue)<br>&gt;            currentValue = newValue<br>&gt;        }<br>&gt;    }<br>&gt; <br>&gt;    var count: Int {<br>&gt;        willSet {<br>&gt;            print(&quot;\(count) will become \(newValue)&quot;)<br>&gt;        }<br>&gt;    }<br>&gt; <br>&gt; I don&#39;t have a fully formed proposal, but there&#39;s a bit more details in a relatively recent discussion here (I changed the syntax a bit since then):<br>&gt; <br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160118/007194.html<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160118/007238.html<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160118/007295.html<br>&gt; <br>&gt; <br>&gt;&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; <br>&gt; <br>&gt; There are many disparate problems this proposal is trying to address.<br>&gt; <br>&gt; Some of the problems illustrated in the proposal would benefit from it, but not all. In some cases, such as the `observed` behavior, it makes things worse because your observer functions have to be tied to a behavior attached to the variable.<br>&gt; <br>&gt; <br>&gt;&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt; <br>&gt; Accessing functions inside behaviors such as `resettable` adds two layers of metadata/meta-operations to the property (one is the behavior name, the other is the `reset()` function). I would argue that including `resettable` before calling a `reset()` function is redundant. It is also against the principles of separation between the interface and the implementation since you might want to define `reset()` in your own way for some variables, which would entail the creation of a separate behavior with a different name, which would change the way you make your `reset()` call. To me, the way you can call behavior functions seems rather heavyweight and inflexible.<br>&gt; <br>&gt; Swift currently lets you add `willSet` and `didSet` observers without having to opt-in through some special syntax. Requiring that a behavior be added, such as `observed` before being able to use these or other custom kinds of observers seems like a step in the wrong direction to me.<br>&gt; <br>&gt; That&#39;s the two main points that I think don&#39;t work well in the current proposal when compared to the rest of Swift.<br>&gt; <br>&gt; <br>&gt;&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; <br>&gt; I haven&#39;t.<br>&gt; <br>&gt; Though the syntax `property.[behavior].func()` reminds be a bit of how you select an axis when accessing nodes in XPath.<br>&gt; <br>&gt; <br>&gt;&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; I followed and participated to the discussions pre-review. I have less time to follow it now, so I might have missed recent developments.<br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Michel Fortin<br>&gt; https://michelf.ca<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February 15, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Feb 14, 2016, at 9:16 AM, Michel Fortin via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; What is your evaluation of the proposal?<br>&gt; <br>&gt; I think property behaviors are a nice idea. But I feel the current proposal is trying to handle too many disparate use cases using an approach that doesn&#39;t work that well for all of them.<br>&gt; <br>&gt; I already expressed my view of this in pre-review, and I&#39;m a bit disappointed to see no mention of my suggestions in the &quot;Alternatives considered&quot; section. Basically I think this proposal should be broken in three or four separate smaller features that can each stand on their own:<br>&gt; <br>&gt; 1. the ability to add `func`, `var`, and `let` inside any property declaration to handle metadata and meta-operations. For instance:<br>&gt; <br>&gt; 	var count: Int {<br>&gt; 		func reset() { count = 0 }<br>&gt; 	}<br>&gt; <br>&gt; 	count::reset() // or some other syntax<br>&gt; <br>&gt; 	var root: NSObject {<br>&gt; 		var lastModified: NSDate? = nil<br>&gt; 		didSet { lastModified = NSDate() }<br>&gt; 	}<br>&gt; <br>&gt; 	print(root::lastAccess)<br>&gt; <br>&gt; 	var lang: String {<br>&gt; 		let xmlName = &quot;xml:lang&quot;<br>&gt; 	}<br>&gt; <br>&gt; 	element.addAttribute(name: lang::xmlName, value: lang)<br>&gt; <br>&gt; 2. the ability to encapsulate those `func` and `var` inside a behaviour for reuse:<br>&gt; <br>&gt; 	behavior resettable&lt;T&gt;: T {<br>&gt; 		func reset() { currentValue = initValue }<br>&gt; 	}<br>&gt; 	var [resettable] count: Int<br>&gt; <br>&gt; 	count::reset() // or some other syntax<br>&gt; <br>&gt; 	behavior changeMonitored&lt;T&gt;: T {<br>&gt; 		var lastModified: NSDate? = nil<br>&gt; 		didSet { lastModified = NSDate() }<br>&gt; 	}<br>&gt; 	var [changeMonitored] root: NSObject<br>&gt; <br>&gt; 	print(root::lastModified)<br></p><p>I think the whole space of out-of-band meta-operations deserves its own separate discussion. In addition to your concerns, exposing metaoperations as interface also introduces bigger concerns about resilience, protocol conformance, etc. that deserve deeper consideration.<br></p><p>&gt; 3. the ability for the behavior (extending point 2) to change the base storage type of the property:<br>&gt; <br>&gt; 	behavior synchronized&lt;T&gt;: Synchronized&lt;T&gt; {<br>&gt; 		get { return currentValue.value }<br>&gt; 		set { currentValue.value = newValue }<br>&gt; 	}<br>&gt; <br>&gt; 	var [synchronized] count: Int<br>&gt; <br>&gt; 	count = 1<br>&gt; <br>&gt; 4. a way to define property observers such as `willSet` globally, with no need to attach a particular behavior to a variable:<br>&gt; <br>&gt; 	observer willSet&lt;T&gt;(newValue: T) {<br>&gt; 		set {<br>&gt; 			willSet(newValue)<br>&gt; 			currentValue = newValue<br>&gt; 		}<br>&gt; 	}<br>&gt; <br>&gt; 	var count: Int {<br>&gt; 		willSet {<br>&gt; 			print(&quot;\(count) will become \(newValue)&quot;)<br>&gt; 		}<br>&gt; 	}<br>&gt; <br>&gt; I don&#39;t have a fully formed proposal, but there&#39;s a bit more details in a relatively recent discussion here (I changed the syntax a bit since then):<br>&gt; <br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160118/007194.html<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160118/007238.html<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160118/007295.htm<br></p><p>As I noted in your pre-review comments, trying to separate storage control from observers doesn&#39;t seem like a net simplification to me. If you try to extend either feature on its own, you end up encroaching in the other&#39;s space. A behavior that manipulates storage may need per-declaration hooks, which accessor provides. An accessor may need to introduce bookkeeping storage.<br></p><p>Perhaps we could support inferring behaviors from accessor names, so that you can write `var foo: Int { didSet { ... } }` instead of `var [observed] foo: Int { didSet { ... } }`, but that seems like syntactic sugar over the basic functionality.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>February 20, 2016 at 12:00:00am</p></header><div class="content"><p>Le 15 févr. 2016 à 17:55, Joe Groff &lt;jgroff at apple.com&gt; a écrit :<br>&gt; <br>&gt; I think the whole space of out-of-band meta-operations deserves its own separate discussion. In addition to your concerns, exposing metaoperations as interface also introduces bigger concerns about resilience, protocol conformance, etc. that deserve deeper consideration.<br></p><p>The way I see it, those meta-operations are just functions enclosed inside the variable&#39;s namespace. So in a protocol, and from an API point of view, they&#39;d look like this:<br></p><p>	protocol MyCounter {<br>		var count: Int {<br>			get<br>			set<br>			func reset()<br>		}<br>	}<br></p><p>Here, you don&#39;t need to know that `reset` is provided by a particular behavior. That is just an implementation detail.<br></p><p>I find your behavior proposal lacking in that regard. A behavior contains both the interface and the implementation of those meta-operations. It shouldn&#39;t. If you want to implement @resettable differently for one of the variables, that should not be visible to the outside world. The default implementation of @resettable shouldn&#39;t be the only one allowed.<br></p><p>It&#39;s interesting that your current implementation uses a protocol with a protocol extension to define behaviors, because the more I think about behaviors the more I believe they should be like a protocol and provide only the interface. The above could be reformulated like this:<br></p><p>	protocol Resettable {<br>		func reset()<br>	}<br>	protocol MyCounter {<br>		@Resettable var count: Int { get set }<br>	}<br></p><p><br>&gt; As I noted in your pre-review comments, trying to separate storage control from observers doesn&#39;t seem like a net simplification to me. If you try to extend either feature on its own, you end up encroaching in the other&#39;s space. A behavior that manipulates storage may need per-declaration hooks, which accessor provides. An accessor may need to introduce bookkeeping storage.<br></p><p>An &quot;accessor hook&quot; is not at all the same thing as an &quot;observer&quot; like `willSet` in my mind. A hook from a behavior is more like requirement of something that must be provided. You are proposing that this requirement be expressed using a syntax similar observers like `willSet`, but I&#39;m not sure reusing the same syntax it&#39;s the right thing to do.<br></p><p>If a behavior was a protocol, it could do what a protocol is good at: define requirements (hooks) and leave those requirements to be implemented by the property definition. You could then implement them in the property definition itself:<br></p><p>	protocol Resettable {<br>		func reset()<br>	}<br>	@Resettable var count: Int {<br>		func reset() { count = 0 }<br>	}<br></p><p>And if a behavior was a protocol, then you could also provide a default implemenation as a protocol extension. Here I&#39;ll make the protocol conform to a magic `eager var` protocol that makes available the init value for protocol extensions:<br></p><p>	protocol Resettable: eager var {<br>		func reset()<br>	}<br>	extension Resettable {<br>		// `value` accessible because this protocol inherits from `var`<br>		// `evalInitValue` accessible here because this protocol inherits from `eager var`<br>		func reset() { value = evalInitValue() }<br>	}<br>	@Resettable var count: Int<br></p><p>And you could allow the behavior to be something else than a protocol too. For instance, allow it to be a struct if you need to implement your own storage:<br></p><p>	struct DelayedStorage&lt;Value&gt; {<br>		var storage: Value?<br>		var value: Value {<br>			get {<br>				guard let theValue = storage else {<br>					fatalError(&quot;delayedImmutable property read before initialization&quot;)<br>				}<br>				return theValue<br>			}<br>			set {<br>				guard storage == nil else {<br>					fatalError(&quot;delayedImmutable property rewritten after initialization&quot;)<br>				}<br>				storage = newValue<br>			}<br>		}<br></p><p>		init() {<br>			storage = nil<br>		}<br>	}<br>	@DelayedStorage var outlet: UIView<br></p><p>And if you need access to the initial value within the struct, you can make the struct inherit from `deferred var` or `eager var` which would make the initial value accessible as an inherited member:<br></p><p>	struct Lazy&lt;Value&gt;: deferred var {<br>		var storage: Value?<br>		var value: Value {<br>			mutating get {<br>				guard let theValue = storage else {<br>					// evalInitValue accessible because this struct inherits from `eager var`<br>					storage = evalInitValue()<br>				}<br>				return theValue<br>			}<br>			set {<br>				storage = newValue<br>			}<br>		}<br></p><p>		// does not allow initialization with a value (no constructor for it)<br>		init() {<br>			storage = nil<br>		}<br>	}<br>	@Lazy var processorCount: Int = NSProcessInfo.processInfo().processorCount<br></p><p>If a struct or a protocol inherit from `var`, then its methods have access to the outer context (the scope the var lives in if it&#39;s a struct or a class). That scope would be exposed through the `context` member also inherited from `var`. And to better make use of it, you should also be able to constrain the context the `var` lives in:<br></p><p>	protocol Synchronizable {<br>		func withLock&lt;T&gt;(@noescape task: () -&gt; T) -&gt; T<br>	}<br>	struct Synchronized&lt;Value&gt;: var in Synchronizable {<br>		var storage: Value<br>		var value: Value {<br>			get {<br>				context.withLock {<br>					return storage<br>				}<br>			}<br>			set {<br>				context.withLock {<br>					storage = newValue<br>				}<br>			}<br>		}<br></p><p>		init(_ initValue: Value) {<br>			storage = initValue<br>		}<br>	}<br>	@Synchronized var faultCount: Int = 0<br></p><p>Using a mix of protocols and structs for behaviors allows protocols to define the interface while a struct and/or extensions and/or the property declaration can provide the implementation. All this gives a lot of flexibility in how to implement what is exposed in the interface.<br></p><p><br>So, to summarize, that would decompose property behaviors in a couple of smaller features:<br></p><p>1.	The ability to use a struct as a wrapper for a property&#39;s value: the `value` property of the struct becomes the property&#39;s value and other members are accessible using an out-of-band member access operator.<br>2. 	The ability for a property to define out-of-band members (`var`s `let`s, and `func`s) inline inside the property declaration (like a custom `reset` function) that can be accessed using the out-of-band member access operator.<br>3.	The ability to have a property conform to a protocol that either the storage struct, a protocol extension, or the inline out-of-band members defined in the property must implement.<br>4.	The ability for a protocol or struct to inherit from `var`, which would add the `value` and `context` members. The `evalInitValue` member would only be available for `deferred var` or `eager var`, and in the case of `deferred var` not available in the constructor (because it might require `self` from the outer context).<br>5.	Observers, like `willSet`, `willChange`, etc. can be implemented as a separate `observer` construct that can be used on any property simply by writing the observer inside the property declaration. (As discussed in my previous email.)<br></p><p>There&#39;s something else interesting with this type-based approach. Take note of how the `DelayedStorage` struct above does not inherit from `var`. That&#39;s because DelayedStorage does not need access to the outer context or `evalInitValue()`. And this makes `DelayedStorage` a perfectly valid struct to use elsewhere, such as:<br></p><p>	var delayedObjects: [DelayedStorage&lt;NSObject&gt;]<br></p><p>You could implement Atomic, NSCopying, and many other behaviors this way and be able to reuse them elsewhere.<br></p><p>And, just teasing... but maybe there&#39;s a way a behavior could be attached as a type modifier instead of a property modifier. This would allow you to write `var delayedObjects: [@DelayedStorage NSObject]` and not have to access the value by appending `.value` every time.<br></p><p><br>-- <br>Michel Fortin<br>https://michelf.ca<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February 19, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; For instance, allow it to be a struct if you need to implement your own storage:<br>&gt; <br>&gt; 	struct DelayedStorage&lt;Value&gt; {<br>&gt; 		var storage: Value?<br>&gt; 		var value: Value {<br>&gt; 			get {<br>&gt; 				guard let theValue = storage else {<br>&gt; 					fatalError(&quot;delayedImmutable property read before initialization&quot;)<br>&gt; 				}<br>&gt; 				return theValue<br>&gt; 			}<br>&gt; 			set {<br>&gt; 				guard storage == nil else {<br>&gt; 					fatalError(&quot;delayedImmutable property rewritten after initialization&quot;)<br>&gt; 				}<br>&gt; 				storage = newValue<br>&gt; 			}<br>&gt; 		}<br>&gt; <br>&gt; 		init() {<br>&gt; 			storage = nil<br>&gt; 		}<br>&gt; 	}<br>&gt; 	@DelayedStorage var outlet: UIView<br></p><p>Some of the points in the &quot;Using a protocol (formal or not) instead of a new declaration&quot; alternative discussed in the proposal (https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md#using-a-protocol-formal-or-not-instead-of-a-new-declaration) are relevant to this suggestion too:<br></p><p>&gt; 	• Behaviors would pollute the namespace, potentially with multiple global functions and/or types.<br>&gt; 	• In practice, it would require every behavior to be implemented using a new (usually generic) type, which introduces runtime overhead for the type&#39;s metadata structures.<br>&gt; 	• The property behavior logic ends up less clear, being encoded in unspecialized language constructs.<br></p><p><br>In particular, note the point about runtime overhead. Behaviors are carefully designed to be basically equivalent to writing the same code yourself every time you need that semantic. If we weren&#39;t aiming for that, the design would be much simpler: we&#39;d have an `init(initialValue:)` that could handle deferred initialization by using an `@autoclosure` and storing it in a property, for instance. But compared to writing the same thing yourself, that would waste memory on an extra property to store the closure, so we don&#39;t want to do that.<br></p><p>&gt; And, just teasing... but maybe there&#39;s a way a behavior could be attached as a type modifier instead of a property modifier. This would allow you to write `var delayedObjects: [@DelayedStorage NSObject]` and not have to access the value by appending `.value` every time.<br></p><p>I think this is fraught with difficulties that will make it impractical at best.<br></p><p>Suppose you have a property `var foo: @Lazy Foo`, and you assign it to a variable like so: `let bar = foo`. What is the type of `bar`? Does `@Lazy` follow it somehow? What does it even mean if it does?<br></p><p>Suppose you have an `Array&lt;@DelayedStorage NSObject&gt;` and a method which expects an `Array&lt;NSObject&gt;`. Can you pass the array to the method? Is this answer correct for all possible behaviors?<br></p><p>Suppose you have an `Array&lt;NSObject&gt;` and a property which contains an `Array&lt;@DelayedStorage NSObject&gt;`. Can you assign the array to the property? Is this answer correct for all possible behaviors?<br></p><p>Suppose you have an `Array&lt;@DelayedStorage NSObject&gt;`. What type should `Element` be in each of these Array members? What is the algorithm by which you can produce the correct result for each one programmatically, or the syntax by which you could annotate them to get the correct result?<br></p><p>	subscript(index: Int) -&gt; Element { get set }<br>	var first: Element?<br>	func indexOf(element: Element) -&gt; Int?<br>	mutating func append(newElement: Element)<br>	mutating func removeLast() -&gt; Element<br>	func minElement(@noescape isOrderedBefore: (Element, Element) throws -&gt; Bool) rethrows -&gt; Element?<br>	mutating func replaceRange&lt;C : CollectionType where C.Generator.Element == Element&gt;(subRange: Range&lt;Int&gt;, with newElements: C)<br>	mutating func withUnsafeMutableBufferPointer&lt;R&gt;(@noescape body: (inout UnsafeMutableBufferPointer&lt;Element&gt;) throws -&gt; R) rethrows -&gt; R<br></p><p>Ultimately, my sense is that trying to make behaviors-as-implicit-types in this fashion ends up with a lot of the problems of implicitly unwrapped optionals: essentially, it&#39;s hard to tell how far type inference will propagate the implicit types, or when the special implicit logic is invoked. We want less of that, not more.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>February 20, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; Le 20 févr. 2016 à 1:16, Brent Royal-Gordon &lt;brent at architechies.com&gt; a écrit :<br>&gt; <br>&gt;&gt; For instance, allow it to be a struct if you need to implement your own storage:<br>&gt;&gt; <br>&gt;&gt; 	struct DelayedStorage&lt;Value&gt; {<br>&gt;&gt; 		var storage: Value?<br>&gt;&gt; 		var value: Value {<br>&gt;&gt; 			get {<br>&gt;&gt; 				guard let theValue = storage else {<br>&gt;&gt; 					fatalError(&quot;delayedImmutable property read before initialization&quot;)<br>&gt;&gt; 				}<br>&gt;&gt; 				return theValue<br>&gt;&gt; 			}<br>&gt;&gt; 			set {<br>&gt;&gt; 				guard storage == nil else {<br>&gt;&gt; 					fatalError(&quot;delayedImmutable property rewritten after initialization&quot;)<br>&gt;&gt; 				}<br>&gt;&gt; 				storage = newValue<br>&gt;&gt; 			}<br>&gt;&gt; 		}<br>&gt;&gt; <br>&gt;&gt; 		init() {<br>&gt;&gt; 			storage = nil<br>&gt;&gt; 		}<br>&gt;&gt; 	}<br>&gt;&gt; 	@DelayedStorage var outlet: UIView<br>&gt; <br>&gt; Some of the points in the &quot;Using a protocol (formal or not) instead of a new declaration&quot; alternative discussed in the proposal (https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md#using-a-protocol-formal-or-not-instead-of-a-new-declaration) are relevant to this suggestion too:<br>&gt; <br>&gt;&gt; 	• Behaviors would pollute the namespace, potentially with multiple global functions and/or types.<br></p><p>That&#39;s only a problem if those names are *only* useful as behaviors. This `DelayedStorage` struct is useful as a regular type too. The `Resettable` protocol can be implemented by types too. The way I&#39;m defining things, many behaviors are going to be useful as a type, so it&#39;s logical that they use the same namespace.<br></p><p>In the end, I don&#39;t really mind if behaviors are in a different namespace or not. The separate namespace just felt unnecessary in my specific case.<br></p><p><br>&gt;&gt; 	• In practice, it would require every behavior to be implemented using a new (usually generic) type, which introduces runtime overhead for the type&#39;s metadata structures.<br></p><p>That might be a problem. Although I believe there is much less indirections with the way I propose things than by having a function that returns a type that conforms to a protocol like what was analyzed there. So I&#39;m not sure how much of the analysis still applies.<br></p><p><br>&gt;&gt; 	• The property behavior logic ends up less clear, being encoded in unspecialized language constructs.<br></p><p>The same could be said about the current proposal: it attempts to unite all loosely related kinds of behaviors under a single unspecialized declaration syntax. We don&#39;t have one `type` declaration for types: instead we have `struct`, `class`, `enum`, and `protocol` which are different kinds of types with slightly different semantics.<br></p><p>With my proposal a property behavior behaves pretty much as a type, and will often be perfectly usable as a standalone type, so I felt things would end up being clearer as types rather than almost-type things. Not that I would really mind making them non-types on as separate namespace.<br></p><p><br>&gt; In particular, note the point about runtime overhead. Behaviors are carefully designed to be basically equivalent to writing the same code yourself every time you need that semantic. If we weren&#39;t aiming for that, the design would be much simpler: we&#39;d have an `init(initialValue:)` that could handle deferred initialization by using an `@autoclosure` and storing it in a property, for instance. But compared to writing the same thing yourself, that would waste memory on an extra property to store the closure, so we don&#39;t want to do that.<br></p><p>Which is why I added this optional `var` inheritance/conformance thing:<br></p><p>	struct Something&lt;Value&gt;: var {}<br></p><p>Here&#39;s how it works: a struct or protocol that conforms to `var` has access to the outer `context`, which is passed as a second hidden argument to all of the methods (second after `self`). A struct or protocol that inherits from `eager var` or `deferred var` has access to a `evalInitValue` closure provided as a third hidden argument. Syntactically, it just look like additional inherited members though.<br></p><p>A struct or protocol that does not inherit from `var` is just a regular struct or protocol: methods have no access to the outer context and the init value is only made available as an argument to the struct constructor.<br></p><p>Perhaps this mechanism is a bit too convoluted?<br></p><p>The only place I can find where this breaks is if the storage behavior needs some hooks. I had not realized this at first because hooks work really well with protocols used as behaviors, but structs cannot define abstract members. So that&#39;s a downside of this approach. It could be alleviated by making the struct declaration require that the inherited `var` implements a protocol:<br></p><p>	protocol DefaultValueProvider {<br>		associatedType Value<br>		var defaultValue: Value<br>	}<br>	struct Resettable&lt;Value&gt;: var&lt;DefaultValueProvider&gt; {<br>		var value: Value<br>		init() { value = defaultValue }<br>		func reset() { value = defaultValue }<br>	}<br></p><p>but I&#39;m not sure how the underlying implementation would work here. It&#39;s also becoming a bit messy syntactically. That&#39;s perhaps a sign that we need a better dedicated construct to deal with this.<br></p><p><br></p><p>&gt;&gt; And, just teasing... but maybe there&#39;s a way a behavior could be attached as a type modifier instead of a property modifier. This would allow you to write `var delayedObjects: [@DelayedStorage NSObject]` and not have to access the value by appending `.value` every time.<br>&gt; <br>&gt; I think this is fraught with difficulties that will make it impractical at best.<br>&gt; <br>&gt; Suppose you have a property `var foo: @Lazy Foo`, and you assign it to a variable like so: `let bar = foo`. What is the type of `bar`? Does `@Lazy` follow it somehow? What does it even mean if it does?<br></p><p>First, `@Lazy` cannot be used as a type modifier. It is defined as conforming to/inheriting from `deferred var` which means it applies only to `var`. That&#39;s needed for it to access `evalInitValue`. (You could redefine `Lazy` to store a closure, which is suboptimal in many ways but that would make it work as a type behavior. Let&#39;s assume this for the rest of the discussion.)<br></p><p>What is the type of `bar`. Quite simple, the type of bar is the type of `foo::value`. The general idea is that referencing to the property without the out-of-band member access operator (I&#39;m using `::` for that) is equivalent to appending `::value`:<br></p><p>	foo = bar<br>	// is the same as<br>	foo = bar::value<br></p><p>If you used `Lazy&lt;Foo&gt;` instead of `@Lazy Foo`, then you&#39;d have to add the `.value` yourself, and `bar = foo` would make `bar` of type `Lazy&lt;Foo&gt;` instead of `Foo`.<br></p><p><br>&gt; Suppose you have an `Array&lt;@DelayedStorage NSObject&gt;` and a method which expects an `Array&lt;NSObject&gt;`. Can you pass the array to the method? Is this answer correct for all possible behaviors?<br></p><p>That&#39;s not possible because the memory layout is different. We have the same problem with protocols: you can&#39;t convert `Array&lt;SomeObject&gt;` to `Array&lt;SomeProtocol&gt;` in the general case where `SomeObject` conforms to `SomeProtocol`.<br></p><p><br>&gt; Suppose you have an `Array&lt;NSObject&gt;` and a property which contains an `Array&lt;@DelayedStorage NSObject&gt;`. Can you assign the array to the property? Is this answer correct for all possible behaviors?<br></p><p>Again no. Same problem as above.<br></p><p><br>&gt; Suppose you have an `Array&lt;@DelayedStorage NSObject&gt;`. What type should `Element` be in each of these Array members?<br></p><p>I get your point here. The type of `Element` has to be `NSObject`, not `@DelayedStorage NSObject` for all the functions and methods to work as intended. There&#39;s one way to &quot;fix&quot; this: parametrize the behavior type separately in the declaration of a generic:<br></p><p>	struct Array&lt;@B T&gt; { ... }<br></p><p>and here the array could reuse `@B T` for its storage, but just `T` elsewhere:<br></p><p>	var x: @B T // using the generic behavior<br>	var y: T // not using the generic behavior<br></p><p>That means that generics would need to opt-in in order to allow a type behavior in their type arguments, and then carefully decide where to use the behavior and when not to use it. I think that&#39;s an interesting concept, but it complicates things a bit more than I expected, perhaps to a point where it&#39;s not worth it.<br></p><p><br>&gt; Ultimately, my sense is that trying to make behaviors-as-implicit-types in this fashion ends up with a lot of the problems of implicitly unwrapped optionals: essentially, it&#39;s hard to tell how far type inference will propagate the implicit types, or when the special implicit logic is invoked. We want less of that, not more.<br></p><p>Implicitly unwrapped optionals are indeed an apt comparison.<br></p><p><br>-- <br>Michel Fortin<br>https://michelf.ca<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>February 22, 2016 at 07:00:00pm</p></header><div class="content"><p>I waned to write only a quick note, but in the end it became to verbose, so I will reiterate main points here for clarity, and point to the bottom of this mail for my original messy text with more details<br></p><p>1. I believe that property behaviors should support static data storage. This data storage exists per declared property (as opposed for per host instance for normal storage). This has clear use cases: space data storage using weak tables etc. <br></p><p>2. The magic status of ‘initialValue’ can be resolved by introducing a per-declaration initialiser that captures the initialisation expression in a static (per-property) closure. This way, everything stays explicit, there is no per-instance overhead and also no magic. However, it is questionable whether this would actually be useful in practice. <br></p><p>3. Should ‘initialValue’ remain ‘magical’, I’d prefer if it had similar treatment to other compiler directives. We already have #line etc, so why not also #initialValue? That will make it clear that compiler is inserting something for you. <br></p><p>&gt; On 20 Feb 2016, at 07:16, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; In particular, note the point about runtime overhead. Behaviors are carefully designed to be basically equivalent to writing the same code yourself every time you need that semantic. If we weren&#39;t aiming for that, the design would be much simpler: we&#39;d have an `init(initialValue:)` that could handle deferred initialization by using an `@autoclosure` and storing it in a property, for instance. But compared to writing the same thing yourself, that would waste memory on an extra property to store the closure, so we don&#39;t want to do that.<br></p><p>Just a quick note about this: I think the overhead can be avoided if the closure is stored once per property declaration rather then per object instance. This is how Python does it, for instance: properties are simply objects that define two magic methods for getting and setting values on the instance. The property object itself is instantiated only once and stored as part of the class attribute list. I can imagine that something like this could be done for Swift property behavior as well. E.g.<br></p><p>var behavior lazy&lt;Value&gt;:Value {<br>  var value: Value? = nil<br>  static let initialValue: ()-&gt;Value  <br></p><p>  // executed once per property declaration<br>  static declare(@autoclosure initialiser: ()-&gt;Value) { <br>    // can only access static variables here<br>    initialValue = initialiser<br>  }<br></p><p>  // optional, executed once per property host instantiation<br> init() {<br> }<br>}<br></p><p>In a way, Joe’s proposal already does this, albeit implicitly. A refinement to make this more explicit removes the magic and gives the programmer more control.  <br></p><p>The question of course whether this mechanism will be useful at all, that is, whether everyone would just use the same boilerplate to capture their initialValues or whether that is some legitimate use case for this. I do not know :) If it is deemed that this is not useful, then I’d prefer if initialValue were a ‘magic’ compiler directive, e.g. #initialValue to mirror its similar status to #file and friends. <br></p><p>Nevertheless, I think that static properties should be allowed for behaviors. That could enable some very powerful features, e.g. using weak dictionaries for sparse data allocation or enumeration of all objects that have particular features).<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February 22, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Feb 22, 2016, at 10:04 AM, Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I waned to write only a quick note, but in the end it became to verbose, so I will reiterate main points here for clarity, and point to the bottom of this mail for my original messy text with more details<br>&gt; <br>&gt; 1. I believe that property behaviors should support static data storage. This data storage exists per declared property (as opposed for per host instance for normal storage). This has clear use cases: space data storage using weak tables etc. <br>&gt; <br>&gt; 2. The magic status of ‘initialValue’ can be resolved by introducing a per-declaration initialiser that captures the initialisation expression in a static (per-property) closure. This way, everything stays explicit, there is no per-instance overhead and also no magic. However, it is questionable whether this would actually be useful in practice. <br>&gt; <br>&gt; 3. Should ‘initialValue’ remain ‘magical’, I’d prefer if it had similar treatment to other compiler directives. We already have #line etc, so why not also #initialValue? That will make it clear that compiler is inserting something for you. <br></p><p>With behavior-controlled static storage and initialization, I don&#39;t think we&#39;d need `initialValue` at all. The interesting variations of initialization could all be encoded as different combinations of static and instance init with @autoclosure:<br></p><p>// Bind an initial value evaluated at declaration time<br>var behavior eagerInLine {<br>  static init(initialValue: Value)<br>}<br>// Bind an initial value evaluated later<br>var behavior deferredInLine {<br>  static init(@autoclosure initialValue: () -&gt; Value)<br>}<br>// Bind an initial value assigned during instance initialization<br>var behavior eagerInstance {<br>  init(initialValue: Value)<br>}<br></p><p>User-definable static storage opens up other potential use cases too, as you&#39;ve noted.<br></p><p>&gt;&gt; On 20 Feb 2016, at 07:16, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; In particular, note the point about runtime overhead. Behaviors are carefully designed to be basically equivalent to writing the same code yourself every time you need that semantic. If we weren&#39;t aiming for that, the design would be much simpler: we&#39;d have an `init(initialValue:)` that could handle deferred initialization by using an `@autoclosure` and storing it in a property, for instance. But compared to writing the same thing yourself, that would waste memory on an extra property to store the closure, so we don&#39;t want to do that.<br>&gt; <br>&gt; Just a quick note about this: I think the overhead can be avoided if the closure is stored once per property declaration rather then per object instance. This is how Python does it, for instance: properties are simply objects that define two magic methods for getting and setting values on the instance. The property object itself is instantiated only once and stored as part of the class attribute list. I can imagine that something like this could be done for Swift property behavior as well.<br></p><p>You could say my prototype implementation does this, though the &quot;property object&quot; is a protocol conformance rather than a first-class object.<br></p><p>-Joe<br></p><p>&gt; E.g.<br>&gt; <br>&gt; var behavior lazy&lt;Value&gt;:Value {<br>&gt;  var value: Value? = nil<br>&gt;  static let initialValue: ()-&gt;Value  <br>&gt; <br>&gt;  // executed once per property declaration<br>&gt;  static declare(@autoclosure initialiser: ()-&gt;Value) { <br>&gt;    // can only access static variables here<br>&gt;    initialValue = initialiser<br>&gt;  }<br>&gt; <br>&gt;  // optional, executed once per property host instantiation<br>&gt; init() {<br>&gt; }<br>&gt; }<br>&gt; <br>&gt; In a way, Joe’s proposal already does this, albeit implicitly. A refinement to make this more explicit removes the magic and gives the programmer more control.  <br>&gt; <br>&gt; The question of course whether this mechanism will be useful at all, that is, whether everyone would just use the same boilerplate to capture their initialValues or whether that is some legitimate use case for this. I do not know :) If it is deemed that this is not useful, then I’d prefer if initialValue were a ‘magic’ compiler directive, e.g. #initialValue to mirror its similar status to #file and friends. <br>&gt; <br>&gt; Nevertheless, I think that static properties should be allowed for behaviors. That could enable some very powerful features, e.g. using weak dictionaries for sparse data allocation or enumeration of all objects that have particular features). <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February 22, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Feb 19, 2016, at 9:02 PM, Michel Fortin &lt;michel.fortin at michelf.ca&gt; wrote:<br>&gt; <br>&gt; Le 15 févr. 2016 à 17:55, Joe Groff &lt;jgroff at apple.com&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; I think the whole space of out-of-band meta-operations deserves its own separate discussion. In addition to your concerns, exposing metaoperations as interface also introduces bigger concerns about resilience, protocol conformance, etc. that deserve deeper consideration.<br>&gt; <br>&gt; The way I see it, those meta-operations are just functions enclosed inside the variable&#39;s namespace. So in a protocol, and from an API point of view, they&#39;d look like this:<br>&gt; <br>&gt; 	protocol MyCounter {<br>&gt; 		var count: Int {<br>&gt; 			get<br>&gt; 			set<br>&gt; 			func reset()<br>&gt; 		}<br>&gt; 	}<br>&gt; <br>&gt; Here, you don&#39;t need to know that `reset` is provided by a particular behavior. That is just an implementation detail.<br>&gt; <br>&gt; I find your behavior proposal lacking in that regard. A behavior contains both the interface and the implementation of those meta-operations. It shouldn&#39;t. If you want to implement @resettable differently for one of the variables, that should not be visible to the outside world. The default implementation of @resettable shouldn&#39;t be the only one allowed.<br></p><p>Yeah, I agree that meta-operations, when they exist, probably make sense as interfaces decoupled from any concrete implementation. Without that feature, though, behaviors as I&#39;ve proposed are purely an implementation detail of the properties that use them. It makes sense to consider meta-operations as a separate feature for that reason.<br></p><p>&gt; <br>&gt; It&#39;s interesting that your current implementation uses a protocol with a protocol extension to define behaviors, because the more I think about behaviors the more I believe they should be like a protocol and provide only the interface. The above could be reformulated like this:<br>&gt; <br>&gt; 	protocol Resettable {<br>&gt; 		func reset()<br>&gt; 	}<br>&gt; 	protocol MyCounter {<br>&gt; 		@Resettable var count: Int { get set }<br>&gt; 	}<br>&gt; <br>&gt; <br>&gt;&gt; As I noted in your pre-review comments, trying to separate storage control from observers doesn&#39;t seem like a net simplification to me. If you try to extend either feature on its own, you end up encroaching in the other&#39;s space. A behavior that manipulates storage may need per-declaration hooks, which accessor provides. An accessor may need to introduce bookkeeping storage.<br>&gt; <br>&gt; An &quot;accessor hook&quot; is not at all the same thing as an &quot;observer&quot; like `willSet` in my mind. A hook from a behavior is more like requirement of something that must be provided. You are proposing that this requirement be expressed using a syntax similar observers like `willSet`, but I&#39;m not sure reusing the same syntax it&#39;s the right thing to do.<br></p><p>Observers, like other behaviors, are allowing a property declaration to provide a block of code that fills in customization points in an otherwise pre-fab property implementation. From an implementation perspective that&#39;s not so different from a lazy property binding the initializer value.<br></p><p>&gt; <br>&gt; If a behavior was a protocol, it could do what a protocol is good at: define requirements (hooks) and leave those requirements to be implemented by the property definition. You could then implement them in the property definition itself:<br>&gt; <br>&gt; 	protocol Resettable {<br>&gt; 		func reset()<br>&gt; 	}<br>&gt; 	@Resettable var count: Int {<br>&gt; 		func reset() { count = 0 }<br>&gt; 	}<br>&gt; <br>&gt; And if a behavior was a protocol, then you could also provide a default implemenation as a protocol extension. Here I&#39;ll make the protocol conform to a magic `eager var` protocol that makes available the init value for protocol extensions:<br>&gt; <br>&gt; 	protocol Resettable: eager var {<br>&gt; 		func reset()<br>&gt; 	}<br>&gt; 	extension Resettable {<br>&gt; 		// `value` accessible because this protocol inherits from `var`<br>&gt; 		// `evalInitValue` accessible here because this protocol inherits from `eager var`<br>&gt; 		func reset() { value = evalInitValue() }<br>&gt; 	}<br>&gt; 	@Resettable var count: Int<br>&gt; <br>&gt; And you could allow the behavior to be something else than a protocol too. For instance, allow it to be a struct if you need to implement your own storage:<br>&gt; <br>&gt; 	struct DelayedStorage&lt;Value&gt; {<br>&gt; 		var storage: Value?<br>&gt; 		var value: Value {<br>&gt; 			get {<br>&gt; 				guard let theValue = storage else {<br>&gt; 					fatalError(&quot;delayedImmutable property read before initialization&quot;)<br>&gt; 				}<br>&gt; 				return theValue<br>&gt; 			}<br>&gt; 			set {<br>&gt; 				guard storage == nil else {<br>&gt; 					fatalError(&quot;delayedImmutable property rewritten after initialization&quot;)<br>&gt; 				}<br>&gt; 				storage = newValue<br>&gt; 			}<br>&gt; 		}<br>&gt; <br>&gt; 		init() {<br>&gt; 			storage = nil<br>&gt; 		}<br>&gt; 	}<br>&gt; 	@DelayedStorage var outlet: UIView<br>&gt; <br>&gt; And if you need access to the initial value within the struct, you can make the struct inherit from `deferred var` or `eager var` which would make the initial value accessible as an inherited member:<br>&gt; <br>&gt; 	struct Lazy&lt;Value&gt;: deferred var {<br>&gt; 		var storage: Value?<br>&gt; 		var value: Value {<br>&gt; 			mutating get {<br>&gt; 				guard let theValue = storage else {<br>&gt; 					// evalInitValue accessible because this struct inherits from `eager var`<br>&gt; 					storage = evalInitValue()<br>&gt; 				}<br>&gt; 				return theValue<br>&gt; 			}<br>&gt; 			set {<br>&gt; 				storage = newValue<br>&gt; 			}<br>&gt; 		}<br>&gt; <br>&gt; 		// does not allow initialization with a value (no constructor for it)<br>&gt; 		init() {<br>&gt; 			storage = nil<br>&gt; 		}<br>&gt; 	}<br>&gt; 	@Lazy var processorCount: Int = NSProcessInfo.processInfo().processorCount<br>&gt; <br>&gt; If a struct or a protocol inherit from `var`, then its methods have access to the outer context (the scope the var lives in if it&#39;s a struct or a class). That scope would be exposed through the `context` member also inherited from `var`. And to better make use of it, you should also be able to constrain the context the `var` lives in:<br>&gt; <br>&gt; 	protocol Synchronizable {<br>&gt; 		func withLock&lt;T&gt;(@noescape task: () -&gt; T) -&gt; T<br>&gt; 	}<br>&gt; 	struct Synchronized&lt;Value&gt;: var in Synchronizable {<br>&gt; 		var storage: Value<br>&gt; 		var value: Value {<br>&gt; 			get {<br>&gt; 				context.withLock {<br>&gt; 					return storage<br>&gt; 				}<br>&gt; 			}<br>&gt; 			set {<br>&gt; 				context.withLock {<br>&gt; 					storage = newValue<br>&gt; 				}<br>&gt; 			}<br>&gt; 		}<br>&gt; <br>&gt; 		init(_ initValue: Value) {<br>&gt; 			storage = initValue<br>&gt; 		}<br>&gt; 	}<br>&gt; 	@Synchronized var faultCount: Int = 0<br>&gt; <br>&gt; Using a mix of protocols and structs for behaviors allows protocols to define the interface while a struct and/or extensions and/or the property declaration can provide the implementation. All this gives a lot of flexibility in how to implement what is exposed in the interface.<br></p><p>That&#39;s an interesting approach. A similar effect can be achieved with protocols and protocol extensions alone, though. You could have a fully abstract behavior protocol &quot;resetting&quot; that declares the interface of a property with a `reset` metaoperation, and declare that as API, while satisfying the implementation with a refined protocol &quot;resetToConstant&quot; that provides the concrete implementation in an extension. I think that keeping the feature tied to protocols (sugared or not) keeps the model simpler. I also have trouble seeing how most behaviors would be useful as standalone types by themselves.<br></p><p>-Joe<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>February 14, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; What is your evaluation of the proposal?<br>It’s “ok”. It is obviously scaled-back from earlier attempts, enough to be useful but not enough to be exciting.<br></p><p>The main shortcoming here is the complete lack of composability. I understand why behavior composition got cut, but I’m not convinced it was the right decision.<br></p><p>As far as I have followed it, it does seem that it’s only `synchronized`-style behaviors that are fundamentally-problematic under composition; that is, using the terminology in the proposal, linear behavior composition would work fine, and to my eyes most behaviors are “linear”.<br></p><p>If it’s actually the case that almost all behaviors would compose reasonably (being “linear”), what’s the actual harm in going back to the more-composable earlier proposals and simply accepting that although one *can* write `synchronized`-style behaviors, they’re going to be fragile and doing so will thus be ill-advised?<br></p><p>It feels like a lot of useful functionality has been given-up upon merely to avoid *potential* problems with a specific few, IMHO questionable, behaviors (like property-level `synchronized`).<br></p><p>&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>A good version of a feature like this will lead to huge robustness-of-implementation improvements.<br></p><p>&gt; Does this proposal fit well with the feel and direction of Swift?<br>The general idea very much so. The proposed behavior declaration syntax is odd, and only seems justifiable to me if a specific flavor of behavior composition winds up being the feature&#39;s future.<br></p><p>&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>A lot of thought towards earlier proposals, a skim of this one.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160214/d0065b73/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>February 14, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; The main shortcoming here is the complete lack of composability. I understand why behavior composition got cut, but I’m not convinced it was the right decision.<br>I agree that a deliberate solution should include composition of behaviors, but I doubt that the practical value of this feature is big:<br>Most likely, there won&#39;t be many different behaviors, and I expect that each of those will be small (in terms of code size). Both assumptions may be wrong in some cases, but all examples that have been discussed so far could easily be combined by simply writing a new behavior.<br></p><p>This isn&#39;t elegant, but without a clear distinction between &quot;decorating&quot; behaviors and those that provide actual storage, many possible combinations would make no sense at all (that&#39;s no argument against composition, though)<br></p><p>Tino<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160214/cda1daa4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>February 14, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Feb 14, 2016, at 4:15 PM, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; The main shortcoming here is the complete lack of composability. I understand why behavior composition got cut, but I’m not convinced it was the right decision.<br>&gt; I agree that a deliberate solution should include composition of behaviors, but I doubt that the practical value of this feature is big:<br>&gt; Most likely, there won&#39;t be many different behaviors, and I expect that each of those will be small (in terms of code size). Both assumptions may be wrong in some cases, but all examples that have been discussed so far could easily be combined by simply writing a new behavior.<br></p><p>I think you’re half right about behaviors; there’s certainly a core group that’s going to be the most common.<br></p><p>The other use for behaviors is as something like a weak macro, e.g. just for views/view-controllers/etc., where there are a lot of minor things you can streamline via behaviors:<br></p><p>- main-queue-only<br>- must-be-non-nil-after-viewDidLoad<br>- invalidates-intrinsic-content-size<br>- requires-display-on-update<br></p><p>…and so on (I brought some of these up in the earlier discussions, just listing them again as examples).<br></p><p>Composability here would be nice, although not entirely necessary (e.g. using custom accessors affords a lot of room for consolidation).<br></p><p>&gt; <br>&gt; This isn&#39;t elegant, but without a clear distinction between &quot;decorating&quot; behaviors and those that provide actual storage, many possible combinations would make no sense at all (that&#39;s no argument against composition, though)<br></p><p>I think you can draw a pretty nice distinction if you want; suppose that a decorator:<br></p><p>- *would* be able to access its container (like a behavior)<br>- *would not* have to deal with property storage (that’s for behaviors only)<br>- *perhaps* has maps sending accessor closures to closures, e.g.<br>  - get-decorator: (() -&gt; T) -&gt; (() -&gt; T)<br>  - set-decorator: ((T) -&gt; ()) -&gt; ((T) -&gt; ())<br></p><p>…which isn’t a real proposal (and e.g. doesn’t address a few major issues , like “how do we handle custom accessors (e.g. from behaviors)”), but illustrates one way one *could* make such a distinction.<br></p><p>&gt; <br>&gt; Tino<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160214/524bc7fa/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>February 15, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Feb 14, 2016, at 12:02 PM, plx via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; What is your evaluation of the proposal?<br>&gt; It’s “ok”. It is obviously scaled-back from earlier attempts, enough to be useful but not enough to be exciting.<br>&gt; <br>&gt; The main shortcoming here is the complete lack of composability. I understand why behavior composition got cut, but I’m not convinced it was the right decision.<br></p><p>General comment: you should look at proposals as steps along the way.  Things that got subset out for the basic proposal may still be added back after the dust settles on the first pass.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160215/cdd5c925/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February 15, 2016 at 02:00:00pm</p></header><div class="content"><p>On Feb 14, 2016, at 12:02 PM, plx via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; As far as I have followed it, it does seem that it’s only `synchronized`-style behaviors that are fundamentally-problematic under composition; that is, using the terminology in the proposal, linear behavior composition would work fine, and to my eyes most behaviors are “linear”.<br></p><p>Behaviors that make synchronization promises are an obvious problem with composition, but there are also subtle issues with other compositions. Consider the composition of `lazy` with `didSet`—if you apply `didSet` inside `lazy`, you&#39;ll observe the lazy initialization as a &quot;set&quot; of the lazy storage, whereas you won&#39;t if you apply `lazy` inside `didSet`.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160215/ee3c0db3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>February 15, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Feb 15, 2016, at 4:45 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; On Feb 14, 2016, at 12:02 PM, plx via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; As far as I have followed it, it does seem that it’s only `synchronized`-style behaviors that are fundamentally-problematic under composition; that is, using the terminology in the proposal, linear behavior composition would work fine, and to my eyes most behaviors are “linear”.<br>&gt; <br>&gt; Behaviors that make synchronization promises are an obvious problem with composition, but there are also subtle issues with other compositions. Consider the composition of `lazy` with `didSet`—if you apply `didSet` inside `lazy`, you&#39;ll observe the lazy initialization as a &quot;set&quot; of the lazy storage, whereas you won&#39;t if you apply `lazy` inside `didSet`.<br></p><p>I see what you mean, but I’m curious: <br></p><p>Is there some fundamental implementation challenge here (e.g. `didSet` seeing an `oldValue` that might be initialized, unexpectedly-nil, or similar…)?<br></p><p>Or it this more of a “there’s too much room for confusion here”-style concern?<br></p><p>&gt; <br>&gt; -Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160215/2dc4b2d7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February 15, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Feb 15, 2016, at 3:09 PM, plx via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 15, 2016, at 4:45 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Feb 14, 2016, at 12:02 PM, plx via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As far as I have followed it, it does seem that it’s only `synchronized`-style behaviors that are fundamentally-problematic under composition; that is, using the terminology in the proposal, linear behavior composition would work fine, and to my eyes most behaviors are “linear”.<br>&gt;&gt; <br>&gt;&gt; Behaviors that make synchronization promises are an obvious problem with composition, but there are also subtle issues with other compositions. Consider the composition of `lazy` with `didSet`—if you apply `didSet` inside `lazy`, you&#39;ll observe the lazy initialization as a &quot;set&quot; of the lazy storage, whereas you won&#39;t if you apply `lazy` inside `didSet`.<br>&gt; <br>&gt; I see what you mean, but I’m curious: <br>&gt; <br>&gt; Is there some fundamental implementation challenge here (e.g. `didSet` seeing an `oldValue` that might be initialized, unexpectedly-nil, or similar…)?<br>&gt; <br>&gt; Or it this more of a “there’s too much room for confusion here”-style concern?<br></p><p>Linear composition is easy from an implementation point of view, so my concern is definitely in the &quot;room-for-confusion&quot; realm, especially since the potential for confusion is in the realm of things that are easy to miss in testing, such as race conditions.<br></p><p>-Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160215/897f50a3/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b1fc4ed1ed8e138ef0a87fd3e91c83a4?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0030 Property Behaviors</strong> from <string>Ricardo Parada</string> &lt;rparada at mac.com&gt;<p>February 14, 2016 at 07:00:00pm</p></header><div class="content"><p>Proposal link:<br></p><p>https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md<br></p><p>What is your evaluation of the proposal?<br>+1<br></p><p>Is the problem being addressed significant enough to warrant a change to Swift?<br>I think it has enough features to implement the typical patterns as discussed in the proposal and that seems like a good start. <br></p><p>Does this proposal fit well with the feel and direction of Swift?<br>Yes. It seems a powerful elegant addition that will allow boilerplate regarding properties to be moved out of the compiler and into libraries. <br></p><p>If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>I don&#39;t recall having seen this in other languages. <br></p><p>I think it opens up some interesting possibilities and could help solve some problems more elegantly than what I have seen solved through other means.  For example managed properties and object/array faulting in Core Data and Enterprise Objects Frameworks for mapping objects to relational data bases. It would be interesting to see if property behaviors could be used to solve these problems. <br></p><p>I think it would help if property behaviors had the name binding to get a hold of the property name. That was mentioned as a future enhancement though.  It will be nice to get that. <br></p><p>How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>I have been following the discussions in the mailing list and I have read the entire proposal. No in-depth study though.  <br></p><p><br></p><p><br></p><p>&gt; On Feb 10, 2016, at 5:00 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of SE-0030 &quot;Property Behaviors&quot; begins now and runs through February, 2016. The proposal is available here:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md<br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br>&gt; <br>&gt; Proposal link:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md<br>&gt; Reply text<br>&gt; <br>&gt; Other replies<br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; What is your evaluation of the proposal?<br>&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; Thank you,<br>&gt; <br>&gt; Doug Gregor<br>&gt; <br>&gt; Review Manager<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution-announce mailing list<br>&gt; swift-evolution-announce at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution-announce<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160214/52f716db/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05e222e6ef4d84013bb3baeb0e25c90b?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0030 Property Behaviors</strong> from <string>Patrick Gili</string> &lt;gili.patrick.r at gili-labs.com&gt;<p>February 15, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Feb 10, 2016, at 5:00 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of SE-0030 &quot;Property Behaviors&quot; begins now and runs through February, 2016. The proposal is available here:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-proposal.md&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br>&gt; <br>&gt; Proposal link:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md&gt;<br>&gt; Reply text<br>&gt; <br>&gt; Other replies<br>&gt;  &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; What is your evaluation of the proposal?<br>I think this proposal not only has great merit, but it is well thought out. I followed the evolution of this proposal and thought Joe did a great job adapting the original concept to the community&#39;s concerns. I&#39;m anxious to start using this feature and future enhancements based on this proposal.<br></p><p>&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>Yes.<br></p><p>&gt; Does this proposal fit well with the feel and direction of Swift?<br>Yes.<br></p><p>&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>The only languages I know of that has anything similar to this feature is Python and Drupal.<br></p><p>&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>Given the length of the proposal, I really studied it and went back to review the threads it was based on.<br></p><p>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt; Thank you,<br>&gt; <br>&gt; Doug Gregor<br>&gt; <br>&gt; Review Manager<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution-announce mailing list<br>&gt; swift-evolution-announce at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution-announce<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160215/39c5e3e9/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0030 Property Behaviors</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>February 15, 2016 at 05:00:00pm</p></header><div class="content"><p>I&#39;ve been meaning to review this one.<br></p><p>&gt; What is your evaluation of the proposal?<br>This is an excellent proposal.<br></p><p>&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>Yes.  Actually, the &quot;examples&quot; within the proposal itself really only scratches the surface of the places I want to use this feature.<br></p><p>Swift&#39;s reflection system is pretty poor, supporting only read-only access.  If I was writing a library to parse the options to `swiftc` for example, an application might want to declare a structure like<br></p><p>struct Options: String {<br>	let applicationExtension : Bool<br>        let assertConfig: Bool<br>        let embedBitcodeMarker: Bool<br>        let emitBitcode: Bool<br>       //etc<br>}<br></p><p>...and use this application-provided structure as part of the API itself.  With clever use of Mirror, a library can reflect this structure, re-interpret the names under command-line-case-rules, and generate a parser that can read &quot;-application-extension&quot; &quot;-assert-config&quot; &quot;embed-bitcode-marker&quot; and so on.<br></p><p>However, while a library can understand this structure, it cannot set the values back on the structure defined by the application.  Thus the application is doomed to work with a parse result object that has poor type information (such as a stringly-typed result).  This basically negates the benefit of declaring a structure like this to begin with.<br></p><p>After this proposal, I can define a property behavior that relocates the variable storage to a stringly-typed underlying mechanism.  As a result, I can construct a full-duplex bridge between &quot;stringly-typed&quot; access patterns and &quot;statically-typed&quot; access patterns, allowing me to alternate between one and the other as necessary.  I can also get &quot;writeable&quot; reflection behavior.  <br></p><p>I think the benefits of such a scheme (particularly as an opt-in mechanism, so as not to impact performance in general) is pretty endless.  The API that I describe seems &quot;obviously&quot; the optimal API for practically any parse problem that terminates in a strongly typed structure (which is the case for most JSON, YAML, XML, CSV, CLI, and RPC-type application-layer problems), and under this proposal it becomes achievable.<br></p><p>One obvious extension I would like to see is &quot;function behaviors&quot; (a.k.a. decorators), but that is obviously a story for another proposal.  Still, I would be really interested in studying in that direction in future proposals.<br></p><p>As others have mentioned, composeability is also interesting, but may not be entirely necessary for an initial pass at the feature.  This seems like something that should be evaluated in the context of &quot;so now we have two different libraries that each want their behavior on a property,&quot; which is a circumstance far removed from the present.<br></p><p>&gt; Does this proposal fit well with the feel and direction of Swift?<br>As explained above, the proposal can bridge an important problem; namely allowing dynamic behavior in a static type system.  I think that this would allow clever library authors to design more Swift-like APIs.<br></p><p>&gt; 	• If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>I am familiar with function decorators in Python, which are a generalization of this scheme (they&#39;re composeable and they also work for functions).  I miss decorators terribly in Swift.  These are not quite as good, but they&#39;re a step.<br></p><p>&gt; 	• How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I&#39;ve tried to get to the meat of the proposal.<br></p><p>I&#39;m deliberately avoiding the syntax bikeshed here–I&#39;m much more interested in the behavior this proposal unlocks than the color of the paint.  Paint the damn thing any color you like, but the underlying idea here is a really important step towards more dynamic kinds of runtime behaviors.<br></p><p>Drew<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160215/c7949d89/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2969f67fc010e956c71442148f3f6fc0?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0030 Property Behaviors</strong> from <string>Wallacy</string> &lt;wallacyf at gmail.com&gt;<p>February 16, 2016 at 01:00:00am</p></header><div class="content"><p>In the last mail a mean, this:<br>a*#lazy.*clear()<br>b*#observable.*addObserver()<br></p><p>I forgot the name of the behavior. ;)<br>Syntax can be discussed in another thread anyway.<br></p><p>__<br></p><p>Just a question, there any plan to discuss some candidates as &quot;default&quot;<br>behaviour on Swift 3 time-frame? Like &#39;lazy&#39;, &#39;observable&#39;, etc?<br></p><p>And some this &quot;future work&quot; like &quot;Composing behaviors&quot;?<br></p><p>I ask this because, knowing that we can use some of the functionality in<br>time to propose improvements even before finalizing the version will help<br>us suggest adjustments and reinforces the idea of a very simple initial<br>proposal.<br></p><p><br>Em seg, 15 de fev de 2016 às 21:26, Drew Crawford via swift-evolution &lt;<br>swift-evolution at swift.org&gt; escreveu:<br></p><p>&gt; I&#39;ve been meaning to review this one.<br>&gt;<br>&gt;<br>&gt;    - What is your evaluation of the proposal?<br>&gt;<br>&gt; This is an excellent proposal.<br>&gt;<br>&gt;<br>&gt;    - Is the problem being addressed significant enough to warrant a<br>&gt;    change to Swift?<br>&gt;<br>&gt; Yes.  Actually, the &quot;examples&quot; within the proposal itself really only<br>&gt; scratches the surface of the places I want to use this feature.<br>&gt;<br>&gt; Swift&#39;s reflection system is pretty poor, supporting only read-only<br>&gt; access.  If I was writing a library to parse the options to `swiftc` for<br>&gt; example, an application might want to declare a structure like<br>&gt;<br>&gt; struct Options: String {<br>&gt; let applicationExtension : Bool<br>&gt;         let assertConfig: Bool<br>&gt;         let embedBitcodeMarker: Bool<br>&gt;         let emitBitcode: Bool<br>&gt;        //etc<br>&gt; }<br>&gt;<br>&gt;<br>&gt; ...and use this application-provided structure as part of the API itself.<br>&gt; With clever use of Mirror, a library can reflect this structure,<br>&gt; re-interpret the names under command-line-case-rules, and generate a parser<br>&gt; that can read &quot;-application-extension&quot; &quot;-assert-config&quot;<br>&gt; &quot;embed-bitcode-marker&quot; and so on.<br>&gt;<br>&gt; However, while a library can *understand* this structure, it cannot *set<br>&gt; the values* back on the structure defined by the application.  Thus the<br>&gt; application is doomed to work with a parse result object that has poor type<br>&gt; information (such as a stringly-typed result).  This basically negates the<br>&gt; benefit of declaring a structure like this to begin with.<br>&gt;<br>&gt; After this proposal, I can define a property behavior that relocates the<br>&gt; variable storage to a stringly-typed underlying mechanism.  As a result, I<br>&gt; can construct a full-duplex bridge between &quot;stringly-typed&quot; access patterns<br>&gt; and &quot;statically-typed&quot; access patterns, allowing me to alternate between<br>&gt; one and the other as necessary.  I can also get &quot;writeable&quot; reflection<br>&gt; behavior.<br>&gt;<br>&gt; I think the benefits of such a scheme (particularly as an opt-in<br>&gt; mechanism, so as not to impact performance in general) is pretty endless.<br>&gt; The API that I describe seems &quot;obviously&quot; the optimal API for practically<br>&gt; any parse problem that terminates in a strongly typed structure (which is<br>&gt; the case for most JSON, YAML, XML, CSV, CLI, and RPC-type application-layer<br>&gt; problems), and under this proposal it becomes achievable.<br>&gt;<br>&gt; One obvious extension I would like to see is &quot;function behaviors&quot; (a.k.a.<br>&gt; decorators), but that is obviously a story for another proposal.  Still, I<br>&gt; would be really interested in studying in that direction in future<br>&gt; proposals.<br>&gt;<br>&gt; As others have mentioned, composeability is also interesting, but may not<br>&gt; be entirely necessary for an initial pass at the feature.  This seems like<br>&gt; something that should be evaluated in the context of &quot;so now we have two<br>&gt; different libraries that each want their behavior on a property,&quot; which is<br>&gt; a circumstance far removed from the present.<br>&gt;<br>&gt;<br>&gt;    - Does this proposal fit well with the feel and direction of Swift?<br>&gt;<br>&gt; As explained above, the proposal can bridge an important problem; namely<br>&gt; allowing dynamic behavior in a static type system.  I think that this would<br>&gt; allow clever library authors to design more Swift-like APIs.<br>&gt;<br>&gt; • If you have used other languages or libraries with a similar feature,<br>&gt; how do you feel that this proposal compares to those?<br>&gt;<br>&gt;<br>&gt; I am familiar with function decorators in Python, which are a<br>&gt; generalization of this scheme (they&#39;re composeable and they also work for<br>&gt; functions).  I miss decorators terribly in Swift.  These are not quite as<br>&gt; good, but they&#39;re a step.<br>&gt;<br>&gt; • How much effort did you put into your review? A glance, a quick reading,<br>&gt; or an in-depth study?<br>&gt;<br>&gt;<br>&gt; I&#39;ve tried to get to the meat of the proposal.<br>&gt;<br>&gt; I&#39;m deliberately avoiding the syntax bikeshed here–I&#39;m much more<br>&gt; interested in the behavior this proposal unlocks than the color of the<br>&gt; paint.  Paint the damn thing any color you like, but the underlying idea<br>&gt; here is a really important step towards more dynamic kinds of runtime<br>&gt; behaviors.<br>&gt;<br>&gt; Drew<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160216/d5b0ea08/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3e4acc351c34224514f9d58b08389390?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0030 Property Behaviors</strong> from <string>Myles Schultz</string> &lt;myleslschultz at icloud.com&gt;<p>February 16, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Feb 15, 2016, at 8:04 PM, Wallacy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; In the last mail a mean, this:<br>&gt; a#lazy.clear()<br>&gt; b#observable.addObserver()<br>&gt; <br>&gt; I forgot the name of the behavior. ;)<br></p><p>Maybe that is a bad prognosis for this feature. The more the discussion progresses, the complex it becomes and the worse the syntax becomes. <br></p><p>Myles<br></p><p>&gt; Syntax can be discussed in another thread anyway.<br>&gt; <br>&gt; __<br>&gt; <br>&gt; Just a question, there any plan to discuss some candidates as &quot;default&quot; behaviour on Swift 3 time-frame? Like &#39;lazy&#39;, &#39;observable&#39;, etc?<br>&gt; <br>&gt; And some this &quot;future work&quot; like &quot;Composing behaviors&quot;?<br>&gt; <br>&gt; I ask this because, knowing that we can use some of the functionality in time to propose improvements even before finalizing the version will help us suggest adjustments and reinforces the idea of a very simple initial proposal.<br>&gt; <br>&gt; <br>&gt;&gt; Em seg, 15 de fev de 2016 às 21:26, Drew Crawford via swift-evolution &lt;swift-evolution at swift.org&gt; escreveu:<br>&gt;&gt; I&#39;ve been meaning to review this one.<br>&gt;&gt; <br>&gt;&gt;&gt; What is your evaluation of the proposal?<br>&gt;&gt; <br>&gt;&gt; This is an excellent proposal.<br>&gt;&gt; <br>&gt;&gt;&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt; <br>&gt;&gt; Yes.  Actually, the &quot;examples&quot; within the proposal itself really only scratches the surface of the places I want to use this feature.<br>&gt;&gt; <br>&gt;&gt; Swift&#39;s reflection system is pretty poor, supporting only read-only access.  If I was writing a library to parse the options to `swiftc` for example, an application might want to declare a structure like<br>&gt;&gt; <br>&gt;&gt; struct Options: String {<br>&gt;&gt; 	let applicationExtension : Bool<br>&gt;&gt;         let assertConfig: Bool<br>&gt;&gt;         let embedBitcodeMarker: Bool<br>&gt;&gt;         let emitBitcode: Bool<br>&gt;&gt;        //etc<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; ...and use this application-provided structure as part of the API itself.  With clever use of Mirror, a library can reflect this structure, re-interpret the names under command-line-case-rules, and generate a parser that can read &quot;-application-extension&quot; &quot;-assert-config&quot; &quot;embed-bitcode-marker&quot; and so on.<br>&gt;&gt; <br>&gt;&gt; However, while a library can understand this structure, it cannot set the values back on the structure defined by the application.  Thus the application is doomed to work with a parse result object that has poor type information (such as a stringly-typed result).  This basically negates the benefit of declaring a structure like this to begin with.<br>&gt;&gt; <br>&gt;&gt; After this proposal, I can define a property behavior that relocates the variable storage to a stringly-typed underlying mechanism.  As a result, I can construct a full-duplex bridge between &quot;stringly-typed&quot; access patterns and &quot;statically-typed&quot; access patterns, allowing me to alternate between one and the other as necessary.  I can also get &quot;writeable&quot; reflection behavior.  <br>&gt;&gt; <br>&gt;&gt; I think the benefits of such a scheme (particularly as an opt-in mechanism, so as not to impact performance in general) is pretty endless.  The API that I describe seems &quot;obviously&quot; the optimal API for practically any parse problem that terminates in a strongly typed structure (which is the case for most JSON, YAML, XML, CSV, CLI, and RPC-type application-layer problems), and under this proposal it becomes achievable.<br>&gt;&gt; <br>&gt;&gt; One obvious extension I would like to see is &quot;function behaviors&quot; (a.k.a. decorators), but that is obviously a story for another proposal.  Still, I would be really interested in studying in that direction in future proposals.<br>&gt;&gt; <br>&gt;&gt; As others have mentioned, composeability is also interesting, but may not be entirely necessary for an initial pass at the feature.  This seems like something that should be evaluated in the context of &quot;so now we have two different libraries that each want their behavior on a property,&quot; which is a circumstance far removed from the present.<br>&gt;&gt; <br>&gt;&gt;&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt; <br>&gt;&gt; As explained above, the proposal can bridge an important problem; namely allowing dynamic behavior in a static type system.  I think that this would allow clever library authors to design more Swift-like APIs.<br>&gt;&gt; <br>&gt;&gt;&gt; 	• If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt; <br>&gt;&gt; I am familiar with function decorators in Python, which are a generalization of this scheme (they&#39;re composeable and they also work for functions).  I miss decorators terribly in Swift.  These are not quite as good, but they&#39;re a step.<br>&gt;&gt; <br>&gt;&gt;&gt; 	• How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt; <br>&gt;&gt; I&#39;ve tried to get to the meat of the proposal.<br>&gt;&gt; <br>&gt;&gt; I&#39;m deliberately avoiding the syntax bikeshed here–I&#39;m much more interested in the behavior this proposal unlocks than the color of the paint.  Paint the damn thing any color you like, but the underlying idea here is a really important step towards more dynamic kinds of runtime behaviors.<br>&gt;&gt; <br>&gt;&gt; Drew<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160216/1ee8a5c0/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February 17, 2016 at 11:00:00am</p></header><div class="content"><p>If anyone wants to start playing with the feature, I now have some of the core functionality working in a branch:<br></p><p>https://github.com/apple/swift/pull/1297<br></p><p>I didn&#39;t want to waste time parsing a behavior declaration syntax while we&#39;re still painting the bikeshed, so behaviors are currently exposed as protocols with extension methods following a convention:<br></p><p>protocol delayedImmutable {<br>  // Type of the property.<br>  associatedtype Value<br>  // Storage required by the property.<br>  var storage: Value? { get set }<br>}<br>extension delayedImmutable {<br>  // Implementation of the property.<br>  var value: Value {<br>    // The property can only be read after it&#39;s been initialized.<br>    get {<br>      guard let theValue = storage else {<br>        fatalError(&quot;delayedImmutable property read before initialization&quot;)<br>      }<br>      return theValue<br>    }<br>    <br>    // The property can only be written once to initialize it.<br>    set {<br>      guard storage == nil else {<br>        fatalError(&quot;delayedImmutable property rewritten after initialization&quot;)<br>      }<br>      storage = newValue<br>    }<br>  }<br></p><p>  // Initialization logic for the property storage.<br>  static func initStorage() -&gt; Value? {<br>    return nil<br>  }<br>}<br></p><p>Custom accessors and initializer expression bindings aren&#39;t handled yet, but there&#39;s enough there now to implement `delayed` initialization. Here&#39;s an example test case:<br></p><p>https://github.com/jckarter/swift/commit/9da36f8e1e45564a61da4cfc9ed5327bf57862df<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160217/5eecaf35/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>February 18, 2016 at 06:00:00pm</p></header><div class="content"><p>I&#39;m surprised no one has said this yet, but nice work Joe for getting a<br>partial implementation we can start to play with! :)<br></p><p>I&#39;m sure it will help to better understand the impact of the proposal and<br>how it relates to our code in a more concrete/practical way.<br></p><p>- *What is your evaluation of the proposal?*+1<br>- *Is the problem being addressed significant enough to warrant a change to<br>Swift?*Yes, I&#39;m excited by the potential here, and once the idea has had<br>some real-world use I would like to see this pattern applied to more things.<br>- *Does this proposal fit well with the feel and direction of Swift?*Yes.<br>- *If you have used other languages or libraries with a similar feature,<br>how do you feel that this proposal compares to those?*C# and Java have some<br>annotation systems, they are loosely related. I&#39;ve used them and found they<br>add a lot of power to those languages, I&#39;ve not tried to implement them<br>though so I cannot comment on that.<br>- *How much effort did you put into your review? A glance, a quick reading,<br>or an in-depth study?*Only a brief look unfortunately, I&#39;ve been skimming<br>the new posts, but other than reading the proposal I haven&#39;t had time to<br>look more thoroughly.<br></p><p><br>On Thu, Feb 18, 2016 at 4:18 AM, Joe Groff via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; If anyone wants to start playing with the feature, I now have some of the<br>&gt; core functionality working in a branch:<br>&gt;<br>&gt; https://github.com/apple/swift/pull/1297<br>&gt;<br>&gt;<br>&gt; I didn&#39;t want to waste time parsing a behavior declaration syntax while<br>&gt; we&#39;re still painting the bikeshed, so behaviors are currently exposed as<br>&gt; protocols with extension methods following a convention:<br>&gt;<br>&gt; protocol delayedImmutable {<br>&gt;   // Type of the property.<br>&gt;   associatedtype Value<br>&gt;   // Storage required by the property.<br>&gt;   var storage: Value? { get set }<br>&gt; }<br>&gt; extension delayedImmutable {<br>&gt;   // Implementation of the property.<br>&gt;   var value: Value {<br>&gt;     // The property can only be read after it&#39;s been initialized.<br>&gt;     get {<br>&gt;       guard let theValue = storage else {<br>&gt;         fatalError(&quot;delayedImmutable property read before initialization&quot;)<br>&gt;       }<br>&gt;       return theValue<br>&gt;     }<br>&gt;<br>&gt;     // The property can only be written once to initialize it.<br>&gt;     set {<br>&gt;       guard storage == nil else {<br>&gt;         fatalError(&quot;delayedImmutable property rewritten after<br>&gt; initialization&quot;)<br>&gt;       }<br>&gt;       storage = newValue<br>&gt;     }<br>&gt;   }<br>&gt;<br>&gt;   // Initialization logic for the property storage.<br>&gt;   static func initStorage() -&gt; Value? {<br>&gt;     return nil<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Custom accessors and initializer expression bindings aren&#39;t handled yet,<br>&gt; but there&#39;s enough there now to implement `delayed` initialization. Here&#39;s<br>&gt; an example test case:<br>&gt;<br>&gt;<br>&gt; https://github.com/jckarter/swift/commit/9da36f8e1e45564a61da4cfc9ed5327bf57862df<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160218/48eaf42b/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>February 17, 2016 at 09:00:00pm</p></header><div class="content"><p>- What is your evaluation of the proposal?<br>+1<br>- Is the problem being addressed significant enough to warrant a change to<br>Swift?Yes. It is &#39;only&#39; a starting point but it does move some magic out of<br>the compiler and into the language and open up possibilities.<br>- Does this proposal fit well with the feel and direction of Swift?<br>Yes. Definitely<br>- If you have used other languages or libraries with a similar feature, how<br>do you feel that this proposal compares to those?I have not.<br>- How much effort did you put into your review? A glance, a quick reading,<br>or an in-depth study?I&#39;ve been following along since the first proposal. I<br>lost quite a few details when things became more active but I have kept up<br>as best as I could.<br></p><p><br></p><p><br></p><p>On Wed, Feb 10, 2016 at 5:00 PM, Douglas Gregor via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hello Swift community,<br>&gt;<br>&gt; The review of SE-0030 &quot;Property Behaviors&quot; begins now and runs through<br>&gt; February, 2016. The proposal is available here:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md<br>&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-proposal.md&gt;<br>&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt; should be sent to the swift-evolution mailing list at<br>&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the<br>&gt; review manager. When replying, please try to keep the proposal link at the<br>&gt; top of the message:<br>&gt;<br>&gt; Proposal link:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md<br>&gt;<br>&gt; Reply text<br>&gt;<br>&gt; Other replies<br>&gt;<br>&gt; &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What<br>&gt; goes into a review?<br>&gt;<br>&gt; The goal of the review process is to improve the proposal under review<br>&gt; through constructive criticism and, eventually, determine the direction of<br>&gt; Swift. When writing your review, here are some questions you might want to<br>&gt; answer in your review:<br>&gt;<br>&gt;    - What is your evaluation of the proposal?<br>&gt;    - Is the problem being addressed significant enough to warrant a<br>&gt;    change to Swift?<br>&gt;    - Does this proposal fit well with the feel and direction of Swift?<br>&gt;    - If you have used other languages or libraries with a similar<br>&gt;    feature, how do you feel that this proposal compares to those?<br>&gt;    - How much effort did you put into your review? A glance, a quick<br>&gt;    reading, or an in-depth study?<br>&gt;<br>&gt; More information about the Swift evolution process is available at<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;<br>&gt; Thank you,<br>&gt;<br>&gt; Doug Gregor<br>&gt;<br>&gt; Review Manager<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160217/6cf0d75d/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February 18, 2016 at 06:00:00pm</p></header><div class="content"><p>Based on review feedback, I&#39;ve revised the declaration syntax proposal for property behaviors to be more in line with our other declaration forms, reverting to the earlier pre-review &quot;var behavior&quot; proposal. I&#39;ve updated the proposal in swift-evolution:<br></p><p>https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md<br></p><p>In discussion with the core team, we&#39;ve also strongly come in favor of applying behaviors to properties using attribute syntax, e.g.:<br></p><p>@lazy var x = 111<br>@delayed var x: Int<br></p><p>They&#39;re definitely attribute-like, and we think it makes sense for behaviors to be the first of hopefully many kinds of user-defined behaviors. What do you all think of this direction?<br></p><p>-Joe<br></p><p>&gt; On Feb 10, 2016, at 2:00 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of SE-0030 &quot;Property Behaviors&quot; begins now and runs through February, 2016. The proposal is available here:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-proposal.md&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br>&gt; <br>&gt; Proposal link:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md&gt;<br>&gt; Reply text<br>&gt; <br>&gt; Other replies<br>&gt;  &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; What is your evaluation of the proposal?<br>&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt; Thank you,<br>&gt; <br>&gt; Doug Gregor<br>&gt; <br>&gt; Review Manager<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160218/61cf8b99/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>February 18, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; <br>&gt; In discussion with the core team, we&#39;ve also strongly come in favor of applying behaviors to properties using attribute syntax, e.g.:<br>&gt; <br>&gt; @lazy var x = 111<br>&gt; @delayed var x: Int<br>&gt; <br>&gt; They&#39;re definitely attribute-like, and we think it makes sense for behaviors to be the first of hopefully many kinds of user-defined behaviors. What do you all think of this direction?<br></p><p>Seems like a good idea.<br></p><p>It would be great if we could eventually nail down &#39;recommended semantics&#39; for symbols like @, #, &amp;, etc, and then normalize the language syntax to match. We have a couple of informal conventions emerging, but I find that (e.g.) trying to figure out why Language Feature X has a leading &#39;@&#39; rather than being a keyword is still rather difficult.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160218/6d910670/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3679b974d53f17b3b684fc9cadb99fa3?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Kyle Sherman</string> &lt;kyledsherman at gmail.com&gt;<p>February 18, 2016 at 08:00:00pm</p></header><div class="content"><p>+1 for the changes and to what Austin said. <br></p><p>Sent from my iPhone<br></p><p>&gt; On Feb 18, 2016, at 8:03 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; In discussion with the core team, we&#39;ve also strongly come in favor of applying behaviors to properties using attribute syntax, e.g.:<br>&gt; <br>&gt; @lazy var x = 111<br>&gt; @delayed var x: Int<br>&gt; <br>&gt; They&#39;re definitely attribute-like, and we think it makes sense for behaviors to be the first of hopefully many kinds of user-defined behaviors. What do you all think of this direction?<br></p><p>Seems like a good idea.<br></p><p>It would be great if we could eventually nail down &#39;recommended semantics&#39; for symbols like @, #, &amp;, etc, and then normalize the language syntax to match. We have a couple of informal conventions emerging, but I find that (e.g.) trying to figure out why Language Feature X has a leading &#39;@&#39; rather than being a keyword is still rather difficult.<br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160218/43497b21/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February 19, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; It would be great if we could eventually nail down &#39;recommended semantics&#39; for symbols like @, #, &amp;, etc, and then normalize the language syntax to match. We have a couple of informal conventions emerging, but I find that (e.g.) trying to figure out why Language Feature X has a leading &#39;@&#39; rather than being a keyword is still rather difficult.<br></p><p>I think we&#39;re doing fine on that, actually:<br></p><p>* &amp; marks unusual parameter passing semantics.<br></p><p>* @ marks attributes, and should only be attached to declarations. (And perhaps also used when accessing data associated with an attribute, like `foo.bar at resettable.reset()`.)<br></p><p>* # is for two things: either expressions with a certain amount of compiler magic involved, or commands that affect large-scale code structure.<br></p><p>Personally, I think of # as the prefix on all Swift 4 macros and @ as the prefix on all Swift N behaviors. The full features aren&#39;t here yet, but we&#39;ve brought some specific use cases back from the future.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>February 20, 2016 at 06:00:00pm</p></header><div class="content"><p>+1 for both the revised proposal and Austin&#39;s comments re @ and #. I was<br>giving a talk about Swift Evolution at the local Cocoa Heads meet up and a<br>question from the floor was what was the difference between @ and #? I<br>foundered a bit answering the question which shows I don&#39;t know the answer.<br>So clarity would be good for me.<br></p><p>On Friday, 19 February 2016, Austin Zheng via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; In discussion with the core team, we&#39;ve also strongly come in favor of<br>&gt; applying behaviors to properties using attribute syntax, e.g.:<br>&gt;<br>&gt; @lazy var x = 111<br>&gt; @delayed var x: Int<br>&gt;<br>&gt; They&#39;re definitely attribute-like, and we think it makes sense for<br>&gt; behaviors to be the first of hopefully many kinds of user-defined<br>&gt; behaviors. What do you all think of this direction?<br>&gt;<br>&gt;<br>&gt; Seems like a good idea.<br>&gt;<br>&gt; It would be great if we could eventually nail down &#39;recommended semantics&#39;<br>&gt; for symbols like @, #, &amp;, etc, and then normalize the language syntax to<br>&gt; match. We have a couple of informal conventions emerging, but I find that<br>&gt; (e.g.) trying to figure out why Language Feature X has a leading &#39;@&#39; rather<br>&gt; than being a keyword is still rather difficult.<br>&gt;<br></p><p><br>-- <br>-- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160220/6f373907/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/446db4307ac0d39e08cd818906ad7af8?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Curt Clifton</string> &lt;curt at curtclifton.net&gt;<p>February 18, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Feb 18, 2016, at 6:56 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Based on review feedback, I&#39;ve revised the declaration syntax proposal for property behaviors to be more in line with our other declaration forms, reverting to the earlier pre-review &quot;var behavior&quot; proposal. I&#39;ve updated the proposal in swift-evolution:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md&gt;<br>The updated behavior declaration form is largely an improvement. <br></p><p>With the placeholder for binding the name of the attributed property gone from the grammar, I wonder if you’ve given any thought to how that binding might be done. I recognize that the binding is left for future work, but would hate to see my pet feature painted into a corner.<br></p><p>I find the naked `initialValue` “declaration&quot; quite odd. It’s not exactly a declaration even. What are the implications for parsing? If we’re already willing to special case`initialValue` in the parser in this context, perhaps we could introduce a binding list instead, like:<br></p><p>```<br>public var behavior lazy&lt;Value&gt;: Value {<br>  // Behaviors can bind the property&#39;s initializer expression with a<br>  // binding declaration.<br>  bind initialValue<br>  …<br>```<br>Besides eliminating the odd naked “declaration”, this has the added advantage that it could be extended to `bind initialValue, propertyName`. :-)<br></p><p>Also, the initialValue in the “Proposed Solution” section doesn’t match the naked syntax used throughout the Examples section.<br></p><p>&gt; In discussion with the core team, we&#39;ve also strongly come in favor of applying behaviors to properties using attribute syntax, e.g.:<br>&gt; <br>&gt; @lazy var x = 111<br>&gt; @delayed var x: Int<br>&gt; <br>&gt; They&#39;re definitely attribute-like, and we think it makes sense for behaviors to be the first of hopefully many kinds of user-defined behaviors. What do you all think of this direction?<br></p><p>I think this is an excellent direction. Would we also use @ syntax for accessing property-supplied members, like `a at runcible.x`?<br></p><p>Cheers,<br></p><p>Curt<br>-----------------------------------------------------------------------------<br>Curt Clifton, PhD<br>Software Engineer<br>The Omni Group<br>www.curtclifton.net<br></p><p><br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160218/00aec368/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>February 19, 2016 at 06:00:00am</p></header><div class="content"><p>&gt; Am 19.02.2016 um 06:01 schrieb Curt Clifton via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt;&gt; In discussion with the core team, we&#39;ve also strongly come in favor of applying behaviors to properties using attribute syntax, e.g.:<br>&gt;&gt; <br>&gt;&gt; @lazy var x = 111<br>&gt;&gt; @delayed var x: Int<br>&gt;&gt; <br>&gt;&gt; They&#39;re definitely attribute-like, and we think it makes sense for behaviors to be the first of hopefully many kinds of user-defined behaviors. What do you all think of this direction?<br>&gt; <br>&gt; I think this is an excellent direction. Would we also use @ syntax for accessing property-supplied members, like `a at runcible.x`?<br></p><p>I would like that.<br></p><p>-Thorsten <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160219/49aec38b/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>February 19, 2016 at 07:00:00am</p></header><div class="content"><p>&gt;&gt; Am 19.02.2016 um 06:01 schrieb Curt Clifton via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; On Feb 18, 2016, at 6:56 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Based on review feedback, I&#39;ve revised the declaration syntax proposal for property behaviors to be more in line with our other declaration forms, reverting to the earlier pre-review &quot;var behavior&quot; proposal. I&#39;ve updated the proposal in swift-evolution:<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md<br>&gt; <br>&gt; The updated behavior declaration form is largely an improvement. <br></p><p>Yes, I prefer it as well.<br></p><p>&gt; With the placeholder for binding the name of the attributed property gone from the grammar, I wonder if you’ve given any thought to how that binding might be done. I recognize that the binding is left for future work, but would hate to see my pet feature painted into a corner.<br>&gt; <br>&gt; I find the naked `initialValue` “declaration&quot; quite odd. It’s not exactly a declaration<br></p><p>This might be an editing problem with th examples. In the Proposed Solution the syntax is<br></p><p>public var behavior lazy&lt;Value&gt; = initialValue { ... }<br></p><p>which makes sense to me (though it is missing the type declaration (: Value) here.<br></p><p><br>&gt; even. What are the implications for parsing? If we’re already willing to special case`initialValue` in the parser in this context, perhaps we could introduce a binding list instead, like:<br>&gt; <br>&gt; ```<br>&gt; public var behavior lazy&lt;Value&gt;: Value {<br>&gt;   // Behaviors can bind the property&#39;s initializer expression with a<br>&gt;   // binding declaration.<br>&gt;   bind initialValue<br>&gt;   …<br>&gt; ```<br>&gt; Besides eliminating the odd naked “declaration”, this has the added advantage that it could be extended to `bind initialValue, propertyName`. :-)<br></p><p>Couldn&#39;t we just add a name by introducing an accessor to be implemented by the user of a property?<br>Alternatively the syntax could be extended to<br></p><p>public var behavior(name: String) lazy&lt;Value&gt;...<br></p><p>but I don&#39;t think that is necessary.<br></p><p>-Thorsten <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160219/2bc2b18c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/446db4307ac0d39e08cd818906ad7af8?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Curt Clifton</string> &lt;curt at curtclifton.net&gt;<p>February 18, 2016 at 11:00:00pm</p></header><div class="content"><p>On Feb 18, 2016, at 10:09 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br></p><p>&gt;&gt; Besides eliminating the odd naked “declaration”, this has the added advantage that it could be extended to `bind initialValue, propertyName`. :-)<br>&gt; <br>&gt; Couldn&#39;t we just add a name by introducing an accessor to be implemented by the user of a property?<br></p><p>What would that look like? Would the programmer have to give the name of the property twice? Like so:<br></p><p>```<br>@plistBacked var warningTextColor: NSColor {<br>  name {<br>    return warningTextColor<br>  }<br>}<br>```<br></p><p>While that works as a stop gap, the repetition is an invitation to error. It would be much better to just write:<br></p><p>```<br>@plistBacked var warningTextColor: NSColor<br>```<br></p><p>and make the property&#39;s name available to the behavior&#39;s implementation, much as the property&#39;s declaring type is exposed as `self`.<br></p><p>But this is also largely off-topic for the thread. I was arguing for a better way to declare that initialValue should be bound and suggesting that a `bind` construct might be an approach that is extensible in the future.<br></p><p>Cheers,<br></p><p>Curt<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February 19, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Feb 18, 2016, at 10:09 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; This might be an editing problem with th examples. In the Proposed Solution the syntax is<br>&gt; <br>&gt; public var behavior lazy&lt;Value&gt; = initialValue { ... }<br>&gt; <br>&gt; which makes sense to me (though it is missing the type declaration (: Value) here.<br></p><p>That was a botched update on my part; I did intend to move the initialValue requirement declaration into the body:<br></p><p>public var behavior lazy&lt;Value&gt;:Value { initialValue; ... }<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160219/997630a6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b1fc4ed1ed8e138ef0a87fd3e91c83a4?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Ricardo Parada</string> &lt;rparada at mac.com&gt;<p>February 19, 2016 at 03:00:00pm</p></header><div class="content"><p>Hi Joe,<br></p><p>Why would we want to move the initialValue declaration into the body?  I personally like it outside because it mirrors the declaration of the actual property.  <br></p><p>Also, I know the current proposal does not have a binding to get a hold of the property name.  But let’s suppose that we wanted to add one as in the behavior declaration below.  Notice that the right hand side of the behavior declaration (in bold) mirrors the property name, the value type and initial value respectively of a var declaration.  Based on this, I find it intuitive to make the connection and understand what name, Value and initialValue are referring to.  No need to have special declarations in the body of the behavior.  <br></p><p>At some point you had provided an “echo” property that showed the use of the name binding to get a hold of the property name.  Then in subsequent proposals you had an _ for the place of the property name in the behavior declaration.  Now I see that it’s been completely dropped.  I personally liked it and think it could be useful.  I probably missed in past discussions the reason why the binding for the property name was dropped.  Do you see it coming back, perhaps in a separate proposal?<br></p><p>As far as @lazy, etc. to annotate var declarations and have them use property behaviors, I cannot think of any reasons why not. It could also be @behavior(lazy) but it seems more verbose.<br></p><p>public var behavior changeObserved&lt;Value: Equatable&gt; name: Value = initialValue {<br></p><p>  var value = initialValue<br></p><p>  mutating accessor didChange(oldValue: Value) { }<br></p><p>  get {<br>    return value<br>  }<br>  set {<br>    let oldValue = value<br>    value = newValue<br>    if oldValue != newValue {<br>      didChange(oldValue)<br>    }<br>  }<br>}<br></p><p>Thank you<br>Ricardo Parada<br></p><p><br></p><p>&gt; On Feb 19, 2016, at 1:36 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 18, 2016, at 10:09 PM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This might be an editing problem with th examples. In the Proposed Solution the syntax is<br>&gt;&gt; <br>&gt;&gt; public var behavior lazy&lt;Value&gt; = initialValue { ... }<br>&gt;&gt; <br>&gt;&gt; which makes sense to me (though it is missing the type declaration (: Value) here.<br>&gt; <br>&gt; That was a botched update on my part; I did intend to move the initialValue requirement declaration into the body:<br>&gt; <br>&gt; public var behavior lazy&lt;Value&gt;:Value { initialValue; ... }<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160219/6ebe90a2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February 19, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; public var behavior changeObserved&lt;Value: Equatable&gt; name: Value = initialValue <br>&gt; {<br></p><p>This is very similar to the last version of the proposal. The core team didn&#39;t like it; that sort of &quot;template-like&quot; style isn&#39;t used in other Swift declarations. So in response to those complaints, Joe changed the declaration syntax in this draft.<br></p><p>(Personally, I liked this style, but that&#39;s beside the point...)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February 19, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Feb 18, 2016, at 9:01 PM, Curt Clifton &lt;curt at curtclifton.net&gt; wrote:<br>&gt; <br>&gt; I find the naked `initialValue` “declaration&quot; quite odd. It’s not exactly a declaration even. What are the implications for parsing? If we’re already willing to special case`initialValue` in the parser in this context, perhaps we could introduce a binding list instead, like:<br>&gt; <br>&gt; ```<br>&gt; public var behavior lazy&lt;Value&gt;: Value {<br>&gt;   // Behaviors can bind the property&#39;s initializer expression with a<br>&gt;   // binding declaration.<br>&gt;   bind initialValue<br>&gt;   …<br>&gt; ```<br>&gt; Besides eliminating the odd naked “declaration”, this has the added advantage that it could be extended to `bind initialValue, propertyName`. :-)<br></p><p>Yeah, I&#39;m not happy with it either. An alternative might be to bless a specifically-named `accessor` declaration, e.g.:<br></p><p>var behavior lazy&lt;Value&gt;: Value {<br>  accessor initialValue() -&gt; Value<br>}<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160219/f6bfbac0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d04f3c48ab68a1dd3e712dcab04004ce?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Curt Clifton</string> &lt;curt at omnigroup.com&gt;<p>February 19, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Feb 19, 2016, at 10:21 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 18, 2016, at 9:01 PM, Curt Clifton &lt;curt at curtclifton.net&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I find the naked `initialValue` “declaration&quot; quite odd. It’s not exactly a declaration even. What are the implications for parsing? If we’re already willing to special case`initialValue` in the parser in this context, perhaps we could introduce a binding list instead, like:<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; public var behavior lazy&lt;Value&gt;: Value {<br>&gt;&gt;   // Behaviors can bind the property&#39;s initializer expression with a<br>&gt;&gt;   // binding declaration.<br>&gt;&gt;   bind initialValue<br>&gt;&gt;   …<br>&gt;&gt; ```<br>&gt;&gt; Besides eliminating the odd naked “declaration”, this has the added advantage that it could be extended to `bind initialValue, propertyName`. :-)<br>&gt; <br>&gt; Yeah, I&#39;m not happy with it either. An alternative might be to bless a specifically-named `accessor` declaration, e.g.:<br>&gt; <br>&gt; var behavior lazy&lt;Value&gt;: Value {<br>&gt;   accessor initialValue() -&gt; Value<br>&gt; }<br>&gt; <br></p><p>Maybe we&#39;re approaching this from the wrong direction. We already have some magic identifiers within behavior declarations as described in Bindings within Behavior Declarations: `Self` for the property&#39;s host type, `self` for the property&#39;s host instance, and `newValue` as the r-value in the implementation of the `set` core accessor.<br></p><p>What&#39;s to keep us from just treating `initialValue` as similar magic within a behavior declaration? Is it a matter of not wanting to use additional storage if the initial value isn&#39;t referenced? If so, it seems like that could be treated as a post-hoc optimization. (Hmm, I suppose this might have resilience issues since changing implementation would change requirements, unless &quot;we consider behaviors to be essentially always fragile&quot; as mentioned in Future Directions.)<br></p><p>Or is the concern that we must communicate to users of the behavior that a property so annotated must have an in-line initializer? That&#39;s implied by the formal grammar in the proposal, where the declaration is named `initial-value-requirement-decl`. If that&#39;s the case, then I&#39;d take the blessed accessor alternative over a naked `initialValue` declaration. For regularity, in that world it seems like properties should be able to implement the accessor directly. That is:<br></p><p>	@lazy var foo: Int = 4<br></p><p>and<br></p><p>	@lazy var foo {<br>	  initialValue { return 4 }<br>	}<br></p><p>should be equivalent.<br></p><p>If that&#39;s distasteful, I&#39;d make a pitch for:<br></p><p>	initial-value-requirement-decl ::= &#39;requires&#39; &#39;initialValue&#39;<br></p><p>But I&#39;ll try to stop bike shedding this syntax now. I continued to be thrilled with the proposal and the directions in which behaviors can evolve.<br></p><p>Cheers,<br></p><p>Curt<br></p><p><br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160219/0742a3be/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February 19, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; What&#39;s to keep us from just treating `initialValue` as similar magic within a behavior declaration? Is it a matter of not wanting to use additional storage if the initial value isn&#39;t referenced?<br></p><p>The issue is that some behaviors want to initialize an internal property with an initial value (most of them, but let&#39;s use `@synchronized` as an example), some want to re-initialize from that value later (`@lazy`), and some don&#39;t want an initial value at all (`@deferred`). Unless we&#39;re going to scan the behavior&#39;s implementation and try to guess the semantics it wants, we&#39;re going to need to declare the desired semantics explicitly. And that means we need a syntax to declare the initial value semantic.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February 20, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Feb 19, 2016, at 9:07 PM, Curt Clifton &lt;curt at omnigroup.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; On Feb 19, 2016, at 10:21 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 18, 2016, at 9:01 PM, Curt Clifton &lt;curt at curtclifton.net &lt;mailto:curt at curtclifton.net&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I find the naked `initialValue` “declaration&quot; quite odd. It’s not exactly a declaration even. What are the implications for parsing? If we’re already willing to special case`initialValue` in the parser in this context, perhaps we could introduce a binding list instead, like:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; public var behavior lazy&lt;Value&gt;: Value {<br>&gt;&gt;&gt;   // Behaviors can bind the property&#39;s initializer expression with a<br>&gt;&gt;&gt;   // binding declaration.<br>&gt;&gt;&gt;   bind initialValue<br>&gt;&gt;&gt;   …<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; Besides eliminating the odd naked “declaration”, this has the added advantage that it could be extended to `bind initialValue, propertyName`. :-)<br>&gt;&gt; <br>&gt;&gt; Yeah, I&#39;m not happy with it either. An alternative might be to bless a specifically-named `accessor` declaration, e.g.:<br>&gt;&gt; <br>&gt;&gt; var behavior lazy&lt;Value&gt;: Value {<br>&gt;&gt;   accessor initialValue() -&gt; Value<br>&gt;&gt; }<br>&gt;&gt; <br>&gt; <br>&gt; Maybe we&#39;re approaching this from the wrong direction. We already have some magic identifiers within behavior declarations as described in Bindings within Behavior Declarations: `Self` for the property&#39;s host type, `self` for the property&#39;s host instance, and `newValue` as the r-value in the implementation of the `set` core accessor.<br>&gt; <br>&gt; What&#39;s to keep us from just treating `initialValue` as similar magic within a behavior declaration? Is it a matter of not wanting to use additional storage if the initial value isn&#39;t referenced? If so, it seems like that could be treated as a post-hoc optimization. (Hmm, I suppose this might have resilience issues since changing implementation would change requirements, unless &quot;we consider behaviors to be essentially always fragile&quot; as mentioned in Future Directions.)<br>&gt; <br>&gt; Or is the concern that we must communicate to users of the behavior that a property so annotated must have an in-line initializer? That&#39;s implied by the formal grammar in the proposal, where the declaration is named `initial-value-requirement-decl`. If that&#39;s the case, then I&#39;d take the blessed accessor alternative over a naked `initialValue` declaration. For regularity, in that world it seems like properties should be able to implement the accessor directly. That is:<br>&gt; <br>&gt; 	@lazy var foo: Int = 4<br>&gt; <br>&gt; and<br>&gt; <br>&gt; 	@lazy var foo {<br>&gt; 	  initialValue { return 4 }<br>&gt; 	}<br>&gt; <br>&gt; should be equivalent.<br>&gt; <br>&gt; If that&#39;s distasteful, I&#39;d make a pitch for:<br>&gt; <br>&gt; 	initial-value-requirement-decl ::= &#39;requires&#39; &#39;initialValue&#39;<br>&gt; <br>&gt; But I&#39;ll try to stop bike shedding this syntax now. I continued to be thrilled with the proposal and the directions in which behaviors can evolve.<br></p><p>We could conceivably infer the intended initial value semantics from the behavior&#39;s implementation, but in Swift we generally try to keep interfaces explicit. Whether an initial value is required and when it&#39;s evaluated are important parts of how you use the behavior. Even if we inferred the initial value semantics from the implementation, we would still need a way to express the semantics in the behavior&#39;s interface when it&#39;s printed from other modules.<br></p><p>-Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160220/4182bdee/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February 19, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; Based on review feedback, I&#39;ve revised the declaration syntax proposal for property behaviors to be more in line with our other declaration forms, reverting to the earlier pre-review &quot;var behavior&quot; proposal. I&#39;ve updated the proposal in swift-evolution:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md<br>&gt; <br>&gt; In discussion with the core team, we&#39;ve also strongly come in favor of applying behaviors to properties using attribute syntax, e.g.:<br>&gt; <br>&gt; @lazy var x = 111<br>&gt; @delayed var x: Int<br>&gt; <br>&gt; They&#39;re definitely attribute-like, and we think it makes sense for behaviors to be the first of hopefully many kinds of user-defined behaviors. What do you all think of this direction?<br></p><p>I like all of this overall. Discussion in a few parts below.<br></p><p>***<br></p><p>I&#39;m fine with the new declaration syntax. I thought the declaration-follows-use syntax was unusually well suited to this feature since it more or less acts as a template for code surrounding a property, but there&#39;s nothing wrong with this new alternative.<br></p><p>I think the one part I don&#39;t really like is the first three words. It&#39;s a little odd having so many lowercase keywords in a row without any punctuation; I&#39;d prefer a syntax with more texture. More worryingly, though, it appears that Apple frameworks have at least four public classes with properties called `behavior`, including `NSPopover`; these could be mistaken for behavior declarations. I see a few potential solutions here:<br></p><p>1. Disambiguate on the absence of punctuation; `var behavior` without a `:` or `=` after it can&#39;t be a property, so it must be a variable behavior. This seems mistake-prone, though:<br>	var behavior NSPopoverBehavior<br>	<br>2. Require backticks if you&#39;re declaring a property. This is the simplest solution, but kind of ugly.<br>	var `behavior`: NSPopoverBehavior<br></p><p>3. Reverse the order of the keywords, yielding `behavior var`. This avoids ambiguity, but it doesn&#39;t read as well:<br>	behavior var lazy&lt;Value&gt;: Value<br></p><p>4. Require the usage punctuation, whatever it is, at the declaration site. (I&#39;ll assume `@`.) `:` or `=` is a property named &quot;behavior&quot;; `@` is a property behavior; anything else is an error. This also gives the declaration some of that missing texture I was complaining about.<br>	var behavior @lazy&lt;Value&gt;: Value<br></p><p>(Technically, the `behavior` keyword is redundant in option 4, but I think it&#39;s valuable as something you can search for when you see `var @lazy` and have no idea what that means.)<br></p><p>***<br></p><p>One thing I don&#39;t like about this new syntax is the standalone `initialValue` keyword (nor the similar `name` keyword in Future Directions, which has a type attached for additional weirdness). I&#39;m wondering if instead, we can have the user declare an accessor named `initialValue`:<br></p><p>	var behavior lazy&lt;Value&gt;: Value {<br>		accessor initialValue() -&gt; Value<br>		<br>		private var value: Value?<br>		<br>		mutating get {<br>			value ??= initialValue()	// Borrowing syntax from SE-0024: Optional Value Setter<br>			return value!<br>		}<br>	}<br></p><p>This turns the computed property into a function, but I don&#39;t think that&#39;s necessarily a bad thing. But if you want it to remain a computed property, I do have another option for you.<br></p><p>Suppose we allow accessors to be either methods *or* readonly computed properties. In the past, we&#39;ve discussed parameterizing behaviors; this would be a way to do it. For example:<br></p><p>	var behavior json&lt;Value: JSONRepresentable where Self: JSONObject&gt;: Value {<br>		// Accessor methods now carry an additional `func` keyword:<br>		accessor func toJSON(value: Value) -&gt; JSONValue {<br>			return value.json<br>		}<br>		accessor func fromJSON(json: JSONValue) -&gt; Value {<br>			return Value(json: json as! Value.JSONRepresentation)<br>		}<br>		<br>		// And we can now say:<br>		<br>		accessor var key: String<br>		<br>		// `key` is a readonly computed property which is bound to the expression provided <br>		// when the behavior is applied to the property.<br>		// <br>		// Just as you can provide an accessor method with a default implementation, so you <br>		// can provide an accessor property with a default value. For instance, if `#name` were<br>		// the syntax to access the property name, the above could be:<br>		// <br>		//	accessor var key = #name<br>		<br>		get {<br>			return fromJSON(self.json[key])<br>		}<br>		set {<br>			self.json[key] = toJSON(newValue)<br>		}<br>	}<br>	<br>	struct Person: JSONObject {<br>		var json: [String: JSONValue]<br>		<br>		// I have two different ideas for the syntax at the application site.<br>		<br>		// Option 1:<br>		@json var identifier: String { key = &quot;id&quot; }<br>		<br>		// Option 2:<br>		@json(key=&quot;id&quot;) var identifier: String<br></p><p>		// Note: The `=` in Option 2 would become a `:` if Erica Sadun&#39;s draft proposal on using <br>		// colons in attributes is accepted.<br>	}<br></p><p>(If we take option 2, there are all sorts of things we can consider doing to bring behavior accessor vars in line with the things we currently see in attribute parameters. For instance, we could allow boolean accessor vars to be set by the presence or absence of their name in the list, without a `true` value being included. We might also allow you to give an accessor var an external name of _ to indicate that no label is needed. If we make this sophisticated enough, we might be able to turn many attributes into empty behaviors that the compiler knows are magic. For instance, if we&#39;re willing to turn @objc(foo) into @objc(&quot;foo&quot;):<br></p><p>	// `Value: @objc` is imaginary syntax for &quot;any Objective-C-compatible type&quot;.<br>	var behavior objc&lt;Value: @objc&gt;: Value {<br>		accessor var _ objCName: StaticString = #name<br>		<br>		var value: Value<br>		get { return value }<br>		set { value = newValue }<br>		<br>		// The compiler knows about this behavior and looks in its `objCName` <br>		// when it&#39;s writing the Objective-C metadata.<br>	}<br></p><p>But I&#39;m digressing.)<br></p><p>With the basic accessor var feature in place—no fancy parameter syntax extensions needed—`initialValue` could be declared as an accessor var:<br></p><p>	var behavior lazy&lt;Value&gt;: Value {<br>		accessor var initialValue: Value<br>		<br>		private var value: Value?<br>		<br>		mutating get {<br>			value ??= initialValue()<br>			return value!<br>		}<br>	}<br>	<br>	@lazy var foo = Bar()<br>	// Exactly equivalent to:<br>	@lazy var foo: Bar {<br>		initialValue = Bar()<br>	}<br>	// Or:<br>	@lazy(initialValue=Bar()) var foo: Bar<br></p><p>If we take this course, then when the time comes to do names, we could of course use another magic `accessor var`:<br></p><p>	var behavior json&lt;Value: JSONRepresentable where Self: JSONObject&gt;: Value {<br>		accessor var name: String<br>		accessor var key: String = name<br>		…<br></p><p>That seems like it might be a feature worth having.<br></p><p>***<br></p><p>On the `@runcible` syntax, I believe I recommended using it pretty early on, so obviously I approve. :^) The proposal currently still shows the `[runcible]` syntax; I take it that just hasn&#39;t been updated? <br></p><p>(I previously had a big section here talking about how to adapt behavior composition to this new syntax, but it grew into a horrendous monster inside an already long email, so I&#39;ve cut it out to avoid cluttering the review. I&#39;ll send it to the list as a new thread.)<br></p><p>***<br></p><p>Incidentally, while I was writing up the JSON example, I thought of another item for the Future Directions list: behavior extensions. It&#39;d be nice if I could do something like this:<br></p><p>	var behavior json&lt;Value where Self: JSONObject&gt;: Value {<br>		accessor var key: String<br>		<br>		accessor func toJSON(value: Value) -&gt; JSONValue<br>		accessor func fromJSON(json: JSONValue) -&gt; Value<br></p><p>		get {<br>			return fromJSON(self.json[key])<br>		}<br>		set {<br>			self.jsonObject[key] = toJSON(newValue)<br>		}<br>	}<br></p><p>	extension var behavior json where Value: JSONRepresentable {<br>		accessor func toJSON(value: Value) -&gt; JSONValue {<br>			return value.json<br>		}<br>		accessor func fromJSON(json: JSONValue) -&gt; Value {<br>			return Value(json: json as! Value.JSONRepresentation)<br>		}<br>	}<br></p><p>Behavior extensions would probably only be able to add accessor defaults and *maybe* methods and computed properties. I don&#39;t think they could add a setter, stored properties, initializers, or new accessors.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05e222e6ef4d84013bb3baeb0e25c90b?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Patrick Gili</string> &lt;gili.patrick.r at gili-labs.com&gt;<p>February 19, 2016 at 08:00:00am</p></header><div class="content"><p>Hi Joe,<br></p><p>What you have presented below looks good to me. However, I don&#39;t see changes to your proposal on GitHub. I&#39;m curious what happens to accessors.<br></p><p>Cheers,<br>-Patrick<br></p><p>&gt; On Feb 18, 2016, at 9:56 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Based on review feedback, I&#39;ve revised the declaration syntax proposal for property behaviors to be more in line with our other declaration forms, reverting to the earlier pre-review &quot;var behavior&quot; proposal. I&#39;ve updated the proposal in swift-evolution:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md&gt;<br>&gt; <br>&gt; In discussion with the core team, we&#39;ve also strongly come in favor of applying behaviors to properties using attribute syntax, e.g.:<br>&gt; <br>&gt; @lazy var x = 111<br>&gt; @delayed var x: Int<br>&gt; <br>&gt; They&#39;re definitely attribute-like, and we think it makes sense for behaviors to be the first of hopefully many kinds of user-defined behaviors. What do you all think of this direction?<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; On Feb 10, 2016, at 2:00 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello Swift community,<br>&gt;&gt; <br>&gt;&gt; The review of SE-0030 &quot;Property Behaviors&quot; begins now and runs through February, 2016. The proposal is available here:<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-proposal.md&gt;<br>&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt; <br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br>&gt;&gt; <br>&gt;&gt; Proposal link:<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md&gt;<br>&gt;&gt; Reply text<br>&gt;&gt; <br>&gt;&gt; Other replies<br>&gt;&gt;  &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What goes into a review?<br>&gt;&gt; <br>&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt; <br>&gt;&gt; What is your evaluation of the proposal?<br>&gt;&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt;&gt; Thank you,<br>&gt;&gt; <br>&gt;&gt; Doug Gregor<br>&gt;&gt; <br>&gt;&gt; Review Manager<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160219/9ac859ba/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>February 19, 2016 at 05:00:00pm</p></header><div class="content"><p>First a general question: Are these behaviors also allowed on normal variables in function bodies (regarding the current proposal)?<br></p><p>----------<br></p><p>The &quot;initialValue&quot; should be exposed as closure/function since it can introduce side effects:<br></p><p>        var [resettable] y = functionWithSideEffects()<br></p><p>According to your proposal: &quot;If the behavior includes an initial value requirement declaration, then the identifier initialValue is bound as a get-only computed property that evaluates the initial value expression for the property&quot;<br></p><p>So if I understand it right if I reset &quot;y&quot; &quot;functionWithSideEffects&quot; gets executed.<br></p><p>------------<br></p><p>Can you explain what is the difference between &quot;Self&quot; and &quot;Value&quot; in the following example?:<br></p><p>protocol Fungible {<br>        typealias Fungus<br>        func funge() -&gt; Fungus<br>}<br></p><p>var behavior runcible&lt;Value where Self: Fungible, Self.Fungus == Value&gt;: Value {<br>        get {<br>                return self.funge()<br>        }<br>}<br></p><p>Isn&#39;t &quot;Self&quot; the same as &quot;Value&quot;? So it can be rewritten to:<br></p><p>var behavior runcible&lt;Value: Fungible, Value.Fungus == Value&gt;: Value {<br>        get {<br>                return self.funge()<br>        }<br>}<br></p><p>----------<br></p><p>You&#39;ve wrote that behaviors shouldn&#39;t be types/type-like e.g. &quot;var x: lazy&lt;Int&gt;&quot;.<br>Can you mention some disadvantages?<br></p><p>I can&#39;t see huge ones. However I don&#39;t see any advantages.<br></p><p>Is there any advantage regarding a type-like behavior?<br></p><p>---------<br></p><p>I just remembered recursive value types...<br>We can even eliminate another keyword: &quot;indirect&quot;<br></p><p>implementation:<br></p><p>var behavior indirect&lt;Value&gt;: Value {<br>        class Ref&lt;T&gt; {<br>                var value: T<br>                init(_ value: T) { self.value = value }<br>        }<br></p><p>        var reference: Ref&lt;Value&gt; = Ref(initialValue())<br>        get { return reference.value }<br>        set { reference.value = newValue }<br>}<br></p><p><br>I&#39;m glad you made it so far :)<br>- Maximilian<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160219/76a43776/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February 19, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Feb 19, 2016, at 8:17 AM, Maximilian Hünenberger &lt;m.huenenberger at me.com&gt; wrote:<br>&gt; <br>&gt; First a general question: Are these behaviors also allowed on normal variables in function bodies (regarding the current proposal)?<br>&gt; <br>&gt; ----------<br>&gt; <br>&gt; The &quot;initialValue&quot; should be exposed as closure/function since it can introduce side effects:<br>&gt; <br>&gt;         var [resettable] y = functionWithSideEffects()<br>&gt; <br>&gt; According to your proposal: &quot;If the behavior includes an initial value requirement declaration, then the identifier initialValue is bound as a get-only computed property that evaluates the initial value expression for the property&quot;<br>&gt; <br>&gt; So if I understand it right if I reset &quot;y&quot; &quot;functionWithSideEffects&quot; gets executed.<br></p><p>Perhaps. It would be reasonable to consider initialValue a special accessor.<br></p><p>&gt; <br>&gt; ------------<br>&gt; <br>&gt; Can you explain what is the difference between &quot;Self&quot; and &quot;Value&quot; in the following example?:<br>&gt; <br>&gt; protocol Fungible {<br>&gt;         typealias Fungus<br>&gt;         func funge() -&gt; Fungus<br>&gt; }<br>&gt; <br>&gt; var behavior runcible&lt;Value where Self: Fungible, Self.Fungus == Value&gt;: Value {<br>&gt;         get {<br>&gt;                 return self.funge()<br>&gt;         }<br>&gt; }<br>&gt; <br>&gt; Isn&#39;t &quot;Self&quot; the same as &quot;Value&quot;? So it can be rewritten to:<br>&gt; <br>&gt; var behavior runcible&lt;Value: Fungible, Value.Fungus == Value&gt;: Value {<br>&gt;         get {<br>&gt;                 return self.funge()<br>&gt;         }<br>&gt; }<br></p><p>`Self` is the type that contains the property. `Value` is the type of the property itself. If you have:<br></p><p>class Foo {<br>  var [behavior] x: Bar<br>}<br></p><p>then behavior&#39;s implementation will see Self == Foo and Value == Bar.<br></p><p>&gt; <br>&gt; ----------<br>&gt; <br>&gt; You&#39;ve wrote that behaviors shouldn&#39;t be types/type-like e.g. &quot;var x: lazy&lt;Int&gt;&quot;.<br>&gt; Can you mention some disadvantages?<br>&gt; <br>A few:<br></p><p>- If the property formally has type `lazy&lt;Int&gt;`, then that impacts overload resolution and method lookup under the property. Even if we introduced implicit conversions, there would inevitably be differences in behavior from a pure `Int` property. It also wouldn&#39;t be ABI-resilient to change a property&#39;s implementation to be lazy, or to use a different behavior, or to not use a behavior at all.<br></p><p>- Types aren&#39;t quite zero-cost abstractions in Swift today. Unspecialized code would generate type metadata records for every lazy&lt;T&gt; it instantiated at runtime.<br></p><p>- A purely type-encapsulated property delegate design like Kotlin&#39;s requires the property delegate instance to carry any information about the declaration it may need for later inside the instance itself; for instance, for a lazy property, the closure that evaluates the initial value would have to be stored in-line inside every instance of every property. The <br></p><p>&gt; I can&#39;t see huge ones. However I don&#39;t see any advantages.<br>&gt; <br>&gt; Is there any advantage regarding a type-like behavior?<br></p><p>A type-like behavior could provide an arguably simpler user model, possibly with less impact on the language as a whole.<br></p><p>&gt; <br>&gt; ---------<br>&gt; <br>&gt; I just remembered recursive value types...<br>&gt; We can even eliminate another keyword: &quot;indirect&quot;<br>&gt; <br>&gt; implementation:<br>&gt; <br>&gt; var behavior indirect&lt;Value&gt;: Value {<br>&gt;         class Ref&lt;T&gt; {<br>&gt;                 var value: T<br>&gt;                 init(_ value: T) { self.value = value }<br>&gt;         }<br>&gt; <br>&gt;         var reference: Ref&lt;Value&gt; = Ref(initialValue())<br>&gt;         get { return reference.value }<br>&gt;         set { reference.value = newValue }<br>&gt; }<br>&gt; <br></p><p>Yeah, indirect would be another good use for property behaviors.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160219/f20d09ac/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>February 19, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On 19 Feb 2016, at 02:56, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; In discussion with the core team, we&#39;ve also strongly come in favor of applying behaviors to properties using attribute syntax, e.g.:<br>&gt; <br>&gt; @lazy var x = 111<br>&gt; @delayed var x: Int<br>&gt; <br>&gt; They&#39;re definitely attribute-like, and we think it makes sense for behaviors to be the first of hopefully many kinds of user-defined behaviors. What do you all think of this direction?<br></p><p>Are they though? We’ve been discussing this a lot in the thread on enforcing super method requirements; while my preference in that case is for an attribute, I feel it is appropriate there because they’re more like directives and informative, and will generate warnings (and possibly errors too) in the same way as @warn_unused_result does. A lot of other attributes are either informational or are produce some kind of restriction that the compiler warns us about (or errors on).<br></p><p>However, property behaviours are more like defining protocols for properties, which is clearly very different from an attribute, and IMO not really compiler magic either. I think a keyword makes most sense, such as behaviour(lazy), though personally I don’t see why we can’t just include the names directly, i.e:<br></p><p>	var lazy x = 111<br></p><p>Isn’t ambiguous, because the right most token (x) is used as the name, var is an explicitly defined keyword, therefore everything else (lazy) can be looked up as a behaviour, in much the same way as types would be. I know there’s some risk of naming collision, but I don’t think it’s all that high, and if property behaviours are functional enough there should be no reason to add any new keywords for use on properties in future as they will be added as behaviours in the standard library. So long as they’re a way to disambiguate your property behaviours from any in the standard library (which will be needed anyway) then I think it’s fine, even when you’re dealing with stuff like:<br></p><p>	static final internal var lazy synchronized x = 111<br></p><p>If we require the order to be:<br></p><p>	[static, final, private|internal|public] [var|let] [behaviours…] [name]<br></p><p>Then I don’t think there should be any real problems. This may even already be how it is, I’m not sure as this is how I structure them anyway.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160219/73413e30/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2b19ddab2d7de4523412c875c258e278?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Matt Whiteside</string> &lt;mwhiteside.dev at gmail.com&gt;<p>February 19, 2016 at 08:00:00am</p></header><div class="content"><p>Response inline below...<br></p><p>&gt; On Feb 19, 2016, at 06:14, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 19 Feb 2016, at 02:56, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; In discussion with the core team, we&#39;ve also strongly come in favor of applying behaviors to properties using attribute syntax, e.g.:<br>&gt;&gt; <br>&gt;&gt; @lazy var x = 111<br>&gt;&gt; @delayed var x: Int<br>&gt;&gt; <br>&gt;&gt; They&#39;re definitely attribute-like, and we think it makes sense for behaviors to be the first of hopefully many kinds of user-defined behaviors. What do you all think of this direction?<br>&gt; <br>&gt; Are they though? We’ve been discussing this a lot in the thread on enforcing super method requirements; while my preference in that case is for an attribute, I feel it is appropriate there because they’re more like directives and informative, and will generate warnings (and possibly errors too) in the same way as @warn_unused_result does. A lot of other attributes are either informational or are produce some kind of restriction that the compiler warns us about (or errors on).<br></p><p>I think Haravikk makes a good point here.  Currently, the `@` symbol seems like a holding ground for miscellaneous compiler directives and backwards compatibility issues (e.g., @objc, @IBOutlet).  So from this view, putting behaviors, which are a forward looking, swift native idea, under the ‘@‘ symbol, seems debatable.<br></p><p>The syntax Haravikk proposes below makes sense to me.  Does it cause big problems from a compiler implementer’s standpoint?<br></p><p>Matt<br></p><p>&gt; <br>&gt; However, property behaviours are more like defining protocols for properties, which is clearly very different from an attribute, and IMO not really compiler magic either. I think a keyword makes most sense, such as behaviour(lazy), though personally I don’t see why we can’t just include the names directly, i.e:<br>&gt; <br>&gt; 	var lazy x = 111<br>&gt; <br>&gt; Isn’t ambiguous, because the right most token (x) is used as the name, var is an explicitly defined keyword, therefore everything else (lazy) can be looked up as a behaviour, in much the same way as types would be. I know there’s some risk of naming collision, but I don’t think it’s all that high, and if property behaviours are functional enough there should be no reason to add any new keywords for use on properties in future as they will be added as behaviours in the standard library. So long as they’re a way to disambiguate your property behaviours from any in the standard library (which will be needed anyway) then I think it’s fine, even when you’re dealing with stuff like:<br>&gt; <br>&gt; 	static final internal var lazy synchronized x = 111<br>&gt; <br>&gt; If we require the order to be:<br>&gt; <br>&gt; 	[static, final, private|internal|public] [var|let] [behaviours…] [name]<br>&gt; <br>&gt; Then I don’t think there should be any real problems. This may even already be how it is, I’m not sure as this is how I structure them anyway.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160219/d49f682c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February 19, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Feb 19, 2016, at 8:30 AM, Matt Whiteside &lt;mwhiteside.dev at gmail.com&gt; wrote:<br>&gt; <br>&gt; Response inline below...<br>&gt; <br>&gt;&gt; On Feb 19, 2016, at 06:14, Haravikk via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 19 Feb 2016, at 02:56, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In discussion with the core team, we&#39;ve also strongly come in favor of applying behaviors to properties using attribute syntax, e.g.:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; @lazy var x = 111<br>&gt;&gt;&gt; @delayed var x: Int<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; They&#39;re definitely attribute-like, and we think it makes sense for behaviors to be the first of hopefully many kinds of user-defined behaviors. What do you all think of this direction?<br>&gt;&gt; <br>&gt;&gt; Are they though? We’ve been discussing this a lot in the thread on enforcing super method requirements; while my preference in that case is for an attribute, I feel it is appropriate there because they’re more like directives and informative, and will generate warnings (and possibly errors too) in the same way as @warn_unused_result does. A lot of other attributes are either informational or are produce some kind of restriction that the compiler warns us about (or errors on).<br>&gt; <br>&gt; I think Haravikk makes a good point here.  Currently, the `@` symbol seems like a holding ground for miscellaneous compiler directives and backwards compatibility issues (e.g., @objc, @IBOutlet).  So from this view, putting behaviors, which are a forward looking, swift native idea, under the ‘@‘ symbol, seems debatable.<br></p><p>I don&#39;t think that was ever our long term intent for `@`. We always intended to open the space up to user annotations at some point. <br></p><p>&gt; The syntax Haravikk proposes below makes sense to me.  Does it cause big problems from a compiler implementer’s standpoint?<br></p><p>It could be made to work today. &#39;var&#39; &lt;identifier&gt; &lt;pattern&gt;&#39; isn&#39;t currently a valid production. It would however interfere with the potential future ability to destructure structs or classes in &#39;var&#39; bindings; we could conceivably allow `var CGPoint(x: x, y: y) = point` or something like it in the broad future.<br></p><p>-Joe<br></p><p>&gt; Matt<br>&gt; <br>&gt;&gt; <br>&gt;&gt; However, property behaviours are more like defining protocols for properties, which is clearly very different from an attribute, and IMO not really compiler magic either. I think a keyword makes most sense, such as behaviour(lazy), though personally I don’t see why we can’t just include the names directly, i.e:<br>&gt;&gt; <br>&gt;&gt; 	var lazy x = 111<br>&gt;&gt; <br>&gt;&gt; Isn’t ambiguous, because the right most token (x) is used as the name, var is an explicitly defined keyword, therefore everything else (lazy) can be looked up as a behaviour, in much the same way as types would be. I know there’s some risk of naming collision, but I don’t think it’s all that high, and if property behaviours are functional enough there should be no reason to add any new keywords for use on properties in future as they will be added as behaviours in the standard library. So long as they’re a way to disambiguate your property behaviours from any in the standard library (which will be needed anyway) then I think it’s fine, even when you’re dealing with stuff like:<br>&gt;&gt; <br>&gt;&gt; 	static final internal var lazy synchronized x = 111<br>&gt;&gt; <br>&gt;&gt; If we require the order to be:<br>&gt;&gt; <br>&gt;&gt; 	[static, final, private|internal|public] [var|let] [behaviours…] [name]<br>&gt;&gt; <br>&gt;&gt; Then I don’t think there should be any real problems. This may even already be how it is, I’m not sure as this is how I structure them anyway.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160219/c05a9161/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2b19ddab2d7de4523412c875c258e278?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Matt Whiteside</string> &lt;mwhiteside.dev at gmail.com&gt;<p>February 19, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Feb 19, 2016, at 10:53, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Feb 19, 2016, at 8:30 AM, Matt Whiteside &lt;mwhiteside.dev at gmail.com &lt;mailto:mwhiteside.dev at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Response inline below...<br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 19, 2016, at 06:14, Haravikk via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 19 Feb 2016, at 02:56, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In discussion with the core team, we&#39;ve also strongly come in favor of applying behaviors to properties using attribute syntax, e.g.:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; @lazy var x = 111<br>&gt;&gt;&gt;&gt; @delayed var x: Int<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; They&#39;re definitely attribute-like, and we think it makes sense for behaviors to be the first of hopefully many kinds of user-defined behaviors. What do you all think of this direction?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Are they though? We’ve been discussing this a lot in the thread on enforcing super method requirements; while my preference in that case is for an attribute, I feel it is appropriate there because they’re more like directives and informative, and will generate warnings (and possibly errors too) in the same way as @warn_unused_result does. A lot of other attributes are either informational or are produce some kind of restriction that the compiler warns us about (or errors on).<br>&gt;&gt; <br>&gt;&gt; I think Haravikk makes a good point here.  Currently, the `@` symbol seems like a holding ground for miscellaneous compiler directives and backwards compatibility issues (e.g., @objc, @IBOutlet).  So from this view, putting behaviors, which are a forward looking, swift native idea, under the ‘@‘ symbol, seems debatable.<br>&gt; <br>&gt; I don&#39;t think that was ever our long term intent for `@`. We always intended to open the space up to user annotations at some point. <br>&gt; <br>&gt;&gt; The syntax Haravikk proposes below makes sense to me.  Does it cause big problems from a compiler implementer’s standpoint?<br>&gt; <br>&gt; It could be made to work today. &#39;var&#39; &lt;identifier&gt; &lt;pattern&gt;&#39; isn&#39;t currently a valid production. It would however interfere with the potential future ability to destructure structs or classes in &#39;var&#39; bindings; we could conceivably allow `var CGPoint(x: x, y: y) = point` or something like it in the broad future.<br></p><p>Thanks for explaining this.  I hadn’t thought of that use case.  <br></p><p>I’m not so much concerned with whether the `@` symbol is internal to the compiler, but rather with lumping together behaviors, which I could see becoming a very mainstream feature relevant to application code, with stuff like @inline, @asmname, @transparent, and other somewhat obscure compiler hints.<br></p><p>Matt<br> <br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; Matt<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; However, property behaviours are more like defining protocols for properties, which is clearly very different from an attribute, and IMO not really compiler magic either. I think a keyword makes most sense, such as behaviour(lazy), though personally I don’t see why we can’t just include the names directly, i.e:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	var lazy x = 111<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Isn’t ambiguous, because the right most token (x) is used as the name, var is an explicitly defined keyword, therefore everything else (lazy) can be looked up as a behaviour, in much the same way as types would be. I know there’s some risk of naming collision, but I don’t think it’s all that high, and if property behaviours are functional enough there should be no reason to add any new keywords for use on properties in future as they will be added as behaviours in the standard library. So long as they’re a way to disambiguate your property behaviours from any in the standard library (which will be needed anyway) then I think it’s fine, even when you’re dealing with stuff like:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	static final internal var lazy synchronized x = 111<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If we require the order to be:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	[static, final, private|internal|public] [var|let] [behaviours…] [name]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Then I don’t think there should be any real problems. This may even already be how it is, I’m not sure as this is how I structure them anyway.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160219/72ad116b/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>February 22, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; Am 19.02.2016 um 19:53 schrieb Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Feb 19, 2016, at 8:30 AM, Matt Whiteside &lt;mwhiteside.dev at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Response inline below...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 19, 2016, at 06:14, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 19 Feb 2016, at 02:56, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In discussion with the core team, we&#39;ve also strongly come in favor of applying behaviors to properties using attribute syntax, e.g.:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; @lazy var x = 111<br>&gt;&gt;&gt;&gt; @delayed var x: Int<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; They&#39;re definitely attribute-like, and we think it makes sense for behaviors to be the first of hopefully many kinds of user-defined behaviors. What do you all think of this direction?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Are they though? We’ve been discussing this a lot in the thread on enforcing super method requirements; while my preference in that case is for an attribute, I feel it is appropriate there because they’re more like directives and informative, and will generate warnings (and possibly errors too) in the same way as @warn_unused_result does. A lot of other attributes are either informational or are produce some kind of restriction that the compiler warns us about (or errors on).<br>&gt;&gt; <br>&gt;&gt; I think Haravikk makes a good point here.  Currently, the `@` symbol seems like a holding ground for miscellaneous compiler directives and backwards compatibility issues (e.g., @objc, @IBOutlet).  So from this view, putting behaviors, which are a forward looking, swift native idea, under the ‘@‘ symbol, seems debatable.<br>&gt; <br>&gt; I don&#39;t think that was ever our long term intent for `@`. We always intended to open the space up to user annotations at some point. <br>&gt; <br>&gt;&gt; The syntax Haravikk proposes below makes sense to me.  Does it cause big problems from a compiler implementer’s standpoint?<br>&gt; <br>&gt; It could be made to work today. &#39;var&#39; &lt;identifier&gt; &lt;pattern&gt;&#39; isn&#39;t currently a valid production. It would however interfere with the potential future ability to destructure structs or classes in &#39;var&#39; bindings; we could conceivably allow `var CGPoint(x: x, y: y) = point` or something like it in the broad future.<br></p><p>As that&#39;s something I&#39;d like to have sometime, I wouldn&#39;t want to block that path.<br></p><p>-Thorsten <br></p><p><br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; Matt<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; However, property behaviours are more like defining protocols for properties, which is clearly very different from an attribute, and IMO not really compiler magic either. I think a keyword makes most sense, such as behaviour(lazy), though personally I don’t see why we can’t just include the names directly, i.e:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	var lazy x = 111<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Isn’t ambiguous, because the right most token (x) is used as the name, var is an explicitly defined keyword, therefore everything else (lazy) can be looked up as a behaviour, in much the same way as types would be. I know there’s some risk of naming collision, but I don’t think it’s all that high, and if property behaviours are functional enough there should be no reason to add any new keywords for use on properties in future as they will be added as behaviours in the standard library. So long as they’re a way to disambiguate your property behaviours from any in the standard library (which will be needed anyway) then I think it’s fine, even when you’re dealing with stuff like:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	static final internal var lazy synchronized x = 111<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If we require the order to be:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	[static, final, private|internal|public] [var|let] [behaviours…] [name]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Then I don’t think there should be any real problems. This may even already be how it is, I’m not sure as this is how I structure them anyway.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160222/282e5134/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>February 19, 2016 at 04:00:00pm</p></header><div class="content"><p>I&#39;m having trouble wrapping my head around the difference between accessors and methods defined by a property: AFAIU accessors are like abstract methods if required and just like methods if not, whereas methods are like final methods as they cannot be overridden in a property use site.<br>If I did understand this correctly then I&#39;d prefer that instead of &quot;accessor&quot; we would just use &quot;func&quot; and introduce a new keyword &quot;abstract&quot;. The latter can then be extended to  classes in another proposal.<br></p><p>-Thorsten <br></p><p>&gt; Am 19.02.2016 um 03:56 schrieb Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Based on review feedback, I&#39;ve revised the declaration syntax proposal for property behaviors to be more in line with our other declaration forms, reverting to the earlier pre-review &quot;var behavior&quot; proposal. I&#39;ve updated the proposal in swift-evolution:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md<br>&gt; <br>&gt; In discussion with the core team, we&#39;ve also strongly come in favor of applying behaviors to properties using attribute syntax, e.g.:<br>&gt; <br>&gt; @lazy var x = 111<br>&gt; @delayed var x: Int<br>&gt; <br>&gt; They&#39;re definitely attribute-like, and we think it makes sense for behaviors to be the first of hopefully many kinds of user-defined behaviors. What do you all think of this direction?<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; On Feb 10, 2016, at 2:00 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello Swift community,<br>&gt;&gt; <br>&gt;&gt; The review of SE-0030 &quot;Property Behaviors&quot; begins now and runs through February, 2016. The proposal is available here:<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md<br>&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt; <br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br>&gt;&gt; <br>&gt;&gt; Proposal link:<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md<br>&gt;&gt; Reply text<br>&gt;&gt; <br>&gt;&gt; Other replies<br>&gt;&gt; What goes into a review?<br>&gt;&gt; <br>&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt; <br>&gt;&gt; What is your evaluation of the proposal?<br>&gt;&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt; Thank you,<br>&gt;&gt; <br>&gt;&gt; Doug Gregor<br>&gt;&gt; <br>&gt;&gt; Review Manager<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160219/817421ac/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February 19, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Feb 19, 2016, at 7:39 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; I&#39;m having trouble wrapping my head around the difference between accessors and methods defined by a property: AFAIU accessors are like abstract methods if required and just like methods if not, whereas methods are like final methods as they cannot be overridden in a property use site.<br></p><p>Accessors are provided by the var declaration using the behavior. Methods are fixed implementations.<br></p><p>-Joe<br></p><p>&gt; If I did understand this correctly then I&#39;d prefer that instead of &quot;accessor&quot; we would just use &quot;func&quot; and introduce a new keyword &quot;abstract&quot;. The latter can then be extended to  classes in another proposal.<br>&gt; <br>&gt; -Thorsten <br>&gt; <br>&gt; Am 19.02.2016 um 03:56 schrieb Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; <br>&gt;&gt; Based on review feedback, I&#39;ve revised the declaration syntax proposal for property behaviors to be more in line with our other declaration forms, reverting to the earlier pre-review &quot;var behavior&quot; proposal. I&#39;ve updated the proposal in swift-evolution:<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md&gt;<br>&gt;&gt; <br>&gt;&gt; In discussion with the core team, we&#39;ve also strongly come in favor of applying behaviors to properties using attribute syntax, e.g.:<br>&gt;&gt; <br>&gt;&gt; @lazy var x = 111<br>&gt;&gt; @delayed var x: Int<br>&gt;&gt; <br>&gt;&gt; They&#39;re definitely attribute-like, and we think it makes sense for behaviors to be the first of hopefully many kinds of user-defined behaviors. What do you all think of this direction?<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 10, 2016, at 2:00 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The review of SE-0030 &quot;Property Behaviors&quot; begins now and runs through February, 2016. The proposal is available here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-proposal.md&gt;<br>&gt;&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposal link:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md&gt;<br>&gt;&gt;&gt; Reply text<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Other replies<br>&gt;&gt;&gt;  &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What goes into a review?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What is your evaluation of the proposal?<br>&gt;&gt;&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt;&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt;&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt;&gt;&gt; Thank you,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Doug Gregor<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Review Manager<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160219/135590c3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>February 22, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; Am 19.02.2016 um 19:39 schrieb Joe Groff &lt;jgroff at apple.com&gt;:<br>&gt; <br>&gt;&gt; On Feb 19, 2016, at 7:39 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;m having trouble wrapping my head around the difference between accessors and methods defined by a property: AFAIU accessors are like abstract methods if required and just like methods if not, whereas methods are like final methods as they cannot be overridden in a property use site.<br>&gt; <br>&gt; Accessors are provided by the var declaration using the behavior. Methods are fixed implementations.<br></p><p>Thanks! So accessors are indeed like abstract methods (if required) and methods are like final methods.<br></p><p>&gt;&gt; If I did understand this correctly then I&#39;d prefer that instead of &quot;accessor&quot; we would just use &quot;func&quot; and introduce a new keyword &quot;abstract&quot;. The latter can then be extended to  classes in another proposal.<br></p><p>i.e. instead of a required &quot;accessor&quot; we would use &quot;abstract func&quot; and instead of an &quot;accessor&quot; with a default implementation we would use &quot;func&quot;.<br>Instead of &quot;func&quot; for methods we would use &quot;final func&quot;.<br></p><p>Then the only new concept would be &quot;abstract&quot; instead of &quot;accessor&quot; and we could extend it to normal methods which would be welcome.<br></p><p>-Thorsten <br></p><p><br> <br>&gt;&gt; <br>&gt;&gt;&gt; Am 19.02.2016 um 03:56 schrieb Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Based on review feedback, I&#39;ve revised the declaration syntax proposal for property behaviors to be more in line with our other declaration forms, reverting to the earlier pre-review &quot;var behavior&quot; proposal. I&#39;ve updated the proposal in swift-evolution:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In discussion with the core team, we&#39;ve also strongly come in favor of applying behaviors to properties using attribute syntax, e.g.:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; @lazy var x = 111<br>&gt;&gt;&gt; @delayed var x: Int<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; They&#39;re definitely attribute-like, and we think it makes sense for behaviors to be the first of hopefully many kinds of user-defined behaviors. What do you all think of this direction?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 10, 2016, at 2:00 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The review of SE-0030 &quot;Property Behaviors&quot; begins now and runs through February, 2016. The proposal is available here:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md<br>&gt;&gt;&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Proposal link:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md<br>&gt;&gt;&gt;&gt; Reply text<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Other replies<br>&gt;&gt;&gt;&gt; What goes into a review?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt;&gt;&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt;&gt;&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt;&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt;&gt;&gt; Thank you,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Doug Gregor<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Review Manager<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160222/61fa8af1/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February 19, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; I&#39;m having trouble wrapping my head around the difference between accessors and methods defined by a property: AFAIU accessors are like abstract methods if required and just like methods if not, whereas methods are like final methods as they cannot be overridden in a property use site.<br></p><p>Accessors are more like property requirements: they&#39;re meant to be customization points, but you can provide a default implementation. Methods defined in a property are for (a) code organization and (b) eventually, exposing additional functionality related to the property to users. No customization allowed.<br></p><p>&gt; If I did understand this correctly then I&#39;d prefer that instead of &quot;accessor&quot; we would just use &quot;func&quot; and introduce a new keyword &quot;abstract&quot;. The latter can then be extended to  classes in another proposal.<br></p><p>I don&#39;t think &quot;abstract&quot; is the right keyword to use, but I do agree that &quot;accessor&quot; might not be the perfect term for this feature. Not sure what would be better, though.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>February 22, 2016 at 04:00:00pm</p></header><div class="content"><p>Am 19.02.2016 um 21:34 schrieb Brent Royal-Gordon &lt;brent at architechies.com&gt;:<br></p><p>&gt;&gt; I&#39;m having trouble wrapping my head around the difference between accessors and methods defined by a property: AFAIU accessors are like abstract methods if required and just like methods if not, whereas methods are like final methods as they cannot be overridden in a property use site.<br>&gt; <br>&gt; Accessors are more like property requirements: they&#39;re meant to be customization points, but you can provide a default implementation. Methods defined in a property are for (a) code organization and (b) eventually, exposing additional functionality related to the property to users. No customization allowed.<br>&gt; <br>&gt;&gt; If I did understand this correctly then I&#39;d prefer that instead of &quot;accessor&quot; we would just use &quot;func&quot; and introduce a new keyword &quot;abstract&quot;. The latter can then be extended to  classes in another proposal.<br>&gt; <br>&gt; I don&#39;t think &quot;abstract&quot; is the right keyword to use, but I do agree that &quot;accessor&quot; might not be the perfect term for this feature. Not sure what would be better, though.<br></p><p>Why? &quot;abstract&quot; is quite common for denoting a method requirement, so I think it is quite appropriate here.<br></p><p>-Thorsten <br></p><p>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February 22, 2016 at 05:00:00pm</p></header><div class="content"><p>(Resending due to the issue with the lists this afternoon.)<br></p><p>&gt;&gt; I don&#39;t think &quot;abstract&quot; is the right keyword to use, but I do agree that &quot;accessor&quot; might not be the perfect term for this feature. Not sure what would be better, though.<br>&gt; <br>&gt; Why? &quot;abstract&quot; is quite common for denoting a method requirement, so I think it is quite appropriate here.<br></p><p>Except in Swift, which has no abstract members at all; it instead leaves that job to protocols.<br></p><p>Unfortunately, constructing an analogy to protocols doesn&#39;t give you a good keyword to use. `protocol` won&#39;t do, because that&#39;s the name for the whole, not the parts. The individual parts are called requirements, but the `required` keyword actually serves a different role, and it would be misleading here because many accessors are defaulted.<br></p><p>Actually, if I had to pick a word, it might be &quot;delegate&quot;. This is essentially a delegation pattern: we&#39;re calling back into the type applying the property to ask it what to do. Call the block a property delegate:<br></p><p>	@json var foo: Foo? {<br>		// This thing is now the &quot;property delegate&quot;<br>		toJSON {<br>			// This is a &quot;delegate method&quot;<br>			return value.json<br>		}<br>		fromJSON {<br>			// So is this<br>			return Foo(JSON: json)<br>		}<br>	}<br></p><p>And then mark each method to be provided by it with the `delegate` keyword:<br></p><p>	delegate toJSON(value: Value) -&gt; JSONValue<br>	delegate fromJSON(json: JSONValue) -&gt; Value<br>	// Or<br>	delegate func toJSON(value: Value) -&gt; JSONValue<br>	delegate func fromJSON(json: JSONValue) -&gt; Value<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February 19, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Feb 18, 2016, at 6:56 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Based on review feedback, I&#39;ve revised the declaration syntax proposal for property behaviors to be more in line with our other declaration forms, reverting to the earlier pre-review &quot;var behavior&quot; proposal. I&#39;ve updated the proposal in swift-evolution:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md&gt;<br>&gt; <br>&gt; In discussion with the core team, we&#39;ve also strongly come in favor of applying behaviors to properties using attribute syntax, e.g.:<br>&gt; <br>&gt; @lazy var x = 111<br>&gt; @delayed var x: Int<br>&gt; <br>&gt; They&#39;re definitely attribute-like, and we think it makes sense for behaviors to be the first of hopefully many kinds of user-defined behaviors<br></p><p>Sorry, that should have read, &quot;hopefully many kinds of user-defined *attributes*&quot;.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160219/31e437b6/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>February 19, 2016 at 11:00:00pm</p></header><div class="content"><p>On Thu, Feb 18, 2016 at 6:56 PM, Joe Groff via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Based on review feedback, I&#39;ve revised the declaration syntax proposal for<br>&gt; property behaviors to be more in line with our other declaration forms,<br>&gt; reverting to the earlier pre-review &quot;var behavior&quot; proposal. I&#39;ve updated<br>&gt; the proposal in swift-evolution:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md<br>&gt;<br>&gt; In discussion with the core team, we&#39;ve also strongly come in favor of<br>&gt; applying behaviors to properties using attribute syntax, e.g.:<br>&gt;<br>&gt; @lazy var x = 111<br>&gt; @delayed var x: Int<br>&gt;<br>&gt; They&#39;re definitely attribute-like, and we think it makes sense for<br>&gt; behaviors to be the first of hopefully many kinds of user-defined<br>&gt; behaviors. What do you all think of this direction?<br>&gt;<br>&gt; -Joe<br>&gt;<br></p><p>I think this is a good direction, however I&#39;m concerned about possible<br>namespace conflicts here. Does user code break if someone defines an<br>attribute which becomes part of the standard library in a future Swift<br>version? Can multiple modules declare attributes with the same name? Maybe<br>they can be qualified as &quot;@MyModule.lazy var x&quot; — although this would also<br>conflict with syntax like &quot;x. at lazy.foo&quot; (is this a &quot;lazy&quot; attribute or a<br>&quot;foo&quot; attribute in a &quot;lazy&quot; module?).<br></p><p>Jacob<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160219/80aa60fd/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February 20, 2016 at 06:00:00pm</p></header><div class="content"><p>I&#39;ve merged my prototype implementation into the Swift 3 master branch. It&#39;s conditionally enabled behind a frontend flag—use `swiftc -Xfrontend -enable-experimental-property-behaviors` to enable the prototype implementation.<br></p><p>-Joe<br></p><p><br>&gt; On Feb 10, 2016, at 2:00 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of SE-0030 &quot;Property Behaviors&quot; begins now and runs through February, 2016. The proposal is available here:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-proposal.md&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br>&gt; <br>&gt; Proposal link:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md&gt;<br>&gt; Reply text<br>&gt; <br>&gt; Other replies<br>&gt;  &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; What is your evaluation of the proposal?<br>&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt; Thank you,<br>&gt; <br>&gt; Doug Gregor<br>&gt; <br>&gt; Review Manager<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160220/d362f40f/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Review] SE-0030 Property Behaviors</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>February 22, 2016 at 12:00:00pm</p></header><div class="content"><p>I&#39;m still very torn on this proposal, and I think a final evaluation should take into account the long-term goal of &quot;hygienic macros&quot;:<br>Right now, I haven&#39;t seen anything concrete on this topic, as it is somewhat out of scope now — but there are soaring dreams for meta programming in Swift, and behaviors could be solved that way as well.<br></p><p>It is common practice to ask the question &quot;would we add this feature now if we didn&#39;t already have it?&quot; when it is about deprecating elements of the language; I fear that property behaviors might become to important to be removed once they are integrated, so I&#39;m asking myself:<br>Would I add this feature if I could do something like<br></p><p>#Self.addProperty(&quot;age&quot;, type: Int, behavior: Lazy { return Date().year - self.birthday.year })<br></p><p>instead?<br>(this all is highly speculative, and so is the syntax — but I hope the intention is of that line is clear)<br></p><p>As the evolution process favors small steps, it is somewhat unfair to challenge a proposal this way, but imho sometimes it is important to step back and consider the &quot;big picture&quot; — which, btw, may as well lead to the conclusion that macros shouldn&#39;t be able to add behaviors, or that the feature deserves a special syntax anyways...<br></p><p>- Tino<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
