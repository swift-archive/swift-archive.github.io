<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Review] SE-0006 Apply API Guidelines to the Standard Library</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>January 27, 2016 at 10:00:00pm</p></header><div class="content"><p>on Wed Jan 27 2016, Dave &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Huh… Yeah, you’re right. I guess I saw “CollectionType” and<br>&gt; “CustomStringConvertible” or something and made a connection that<br>&gt; wasn’t there.<br>&gt; Well, FWIW, that convention (plus the occasional “HasNoun”, and<br>&gt; -ableType for constraining the element of custom collections) tends to<br>&gt; work well for me.<br>&gt;<br>&gt; What’s been the deciding factor between -Type and -able so far?<br></p><p>When there&#39;s no reasonable -able or -ible name, use -Type.<br></p><p>&gt; - Dave Sweeris<br>&gt;<br>&gt;&gt; On Jan 27, 2016, at 00:49, Dave Abrahams via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Tue Jan 26 2016, Dave &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 25, 2016, at 07:40, Radosław Pietruszewski via<br>&gt;&gt;&gt;&gt; swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; == Removed Type from protocol names ==<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Perhaps I’ve missed some discussion about this and I don’t see the<br>&gt;&gt;&gt;&gt; context, but I’m not sure this is a positive change.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I fear this might be confusing in practice, at least in some<br>&gt;&gt;&gt;&gt; contexts. For example, there&#39;s nothing signifying that &quot;Boolean&quot; or<br>&gt;&gt;&gt;&gt; &quot;Integer&quot; are protocols and not actual types. Same with “Sequence”,<br>&gt;&gt;&gt;&gt; “OptionSet”, etc. Perhaps it doesn&#39;t matter because everyone will<br>&gt;&gt;&gt;&gt; naturally go for `Bool`, `Int`, and `Array` anyway. But I can<br>&gt;&gt;&gt;&gt; imagine a lot of confusion if someone tried that anyway, or perhaps<br>&gt;&gt;&gt;&gt; saw that in the autocompletion, or the standard library browser<br>&gt;&gt;&gt;&gt; (with no intention of using the protocol).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m all for removing unnecessary noise and verbosity, but I think I<br>&gt;&gt;&gt;&gt; would err on explicitness side here. It seemed like the -able/-Type<br>&gt;&gt;&gt;&gt; convention did a good job disambiguating types you can actually<br>&gt;&gt;&gt;&gt; instantiate from protocols, with very little “verbosity cost”.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Same here… I like -Type for protocols that can only be used a generic<br>&gt;&gt;&gt; constraint, and -able/-ible for protocols that can be “concrete”<br>&gt;&gt;&gt; types.<br>&gt;&gt; <br>&gt;&gt; But that&#39;s not how they&#39;re used.  I&#39;d have to rename Equatable and<br>&gt;&gt; Comparable to follow that convention.<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Review] SE-0006 Apply API Guidelines to the Standard Library</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>January 28, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jan 27, 2016, at 11:42 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Wed Jan 27 2016, Dave &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Huh… Yeah, you’re right. I guess I saw “CollectionType” and<br>&gt;&gt; “CustomStringConvertible” or something and made a connection that<br>&gt;&gt; wasn’t there.<br>&gt;&gt; Well, FWIW, that convention (plus the occasional “HasNoun”, and<br>&gt;&gt; -ableType for constraining the element of custom collections) tends to<br>&gt;&gt; work well for me.<br>&gt;&gt; <br>&gt;&gt; What’s been the deciding factor between -Type and -able so far?<br>&gt; <br>&gt; When there&#39;s no reasonable -able or -ible name, use -Type.<br></p><p>This is where I never know whether to keep my nose out of things or just jump in. I find there are generally two kinds of protocols: verby-ones (&quot;this is how this thing works&quot;) and nouny-ones (&quot;this is what this thing is&quot;). Here&#39;s the guidance I&#39;ve been giving:<br></p><p>Swift protocols describe the surface that connect a feature provider API with its consumer. Protocols establish a communication contract. They ensure a fit between each required member and the provider’s implementation. It’s like whether a virus can attach to a host cell’s receptors, or whatever the actual biological equivalent is. The standard library describes protocols using nouns (typically ending in Type, e.g. MirrorPathType, MutableCollectionType, ErrorType) and adjectives (typically ending in ble, like Streamable, Strideable, ArrayLiteralConvertible). The former more commonly discuss what a conforming type is and the latter what it does.  <br></p><p>When naming a protocol, you’re not limited to Type and ble endings. Your protocol can be, for example, a DataProvider or a FloatConsumer. A protocol can describe a relationship DownloadProcessingDelegate or ListViewDataSource. You may implement an OutputDestination or an IntegerSink. The current API Design guidelines say &quot;omit needless words&quot;, so you might prefer to go with DataProvider over DataProviderType or  MirrorPath over MirrorPathType, but I wouldn&#39;t give much more constraint to naming beyond that.<br></p><p>For example, for &quot;HasNoun&quot;, I&#39;d go with something more like NounContainingType or NounSupplier.<br></p><p>Non-Abrahams Dave writes: &quot;I like -Type for protocols that can only be used a generic constraint, and -able/-ible for protocols that can be “concrete” types.<br></p><p>And Canonical Dave replies: &quot;But that&#39;s not how they&#39;re used.  I&#39;d have to rename Equatable and Comparable to follow that convention.&quot;<br></p><p>I agree in that I&#39;m not convinced it&#39;s the role of a protocol to describe implementation details. (I&#39;d say the same for method names, but that&#39;s different thread about mutability and side effects, etc). Going that way leads you to over-designated hungarian-esque guidelines that I&#39;d rather keep loose, friendly, and sensible.<br></p><p>-- Erica<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/ef1d766a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Review] SE-0006 Apply API Guidelines to the Standard Library</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January 29, 2016 at 03:00:00pm</p></header><div class="content"><p>For protocols named XXXble I think they should have a main method named<br>XXX. If this were adopted then many protocol names would change, e.g.:<br></p><p>    1. ForwardIndexType would be Advanceable because it has advance methods<br>and method successor() would be renamed advance().<br>    2. Indexable would be Subscriptable because it has a subscript method.<br>    3. Etc.<br></p><p>On 29 January 2016 at 05:03, Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Jan 27, 2016, at 11:42 PM, Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; on Wed Jan 27 2016, Dave &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Huh… Yeah, you’re right. I guess I saw “CollectionType” and<br>&gt; “CustomStringConvertible” or something and made a connection that<br>&gt; wasn’t there.<br>&gt; Well, FWIW, that convention (plus the occasional “HasNoun”, and<br>&gt; -ableType for constraining the element of custom collections) tends to<br>&gt; work well for me.<br>&gt;<br>&gt; What’s been the deciding factor between -Type and -able so far?<br>&gt;<br>&gt;<br>&gt; When there&#39;s no reasonable -able or -ible name, use -Type.<br>&gt;<br>&gt;<br>&gt; This is where I never know whether to keep my nose out of things or just<br>&gt; jump in. I find there are generally two kinds of protocols: verby-ones<br>&gt; (&quot;this is how this thing works&quot;) and nouny-ones (&quot;this is what this thing<br>&gt; is&quot;). Here&#39;s the guidance I&#39;ve been giving:<br>&gt;<br>&gt; *Swift protocols describe the surface that connect a feature provider API<br>&gt; with its consumer. Protocols establish a communication contract. They<br>&gt; ensure a fit between each required member and the provider’s<br>&gt; implementation. It’s like whether a virus can attach to a host cell’s<br>&gt; receptors, or whatever the actual biological equivalent is. **The<br>&gt; standard library describes protocols using nouns (typically ending in Type,<br>&gt; e.g. MirrorPathType, MutableCollectionType, ErrorType) and adjectives<br>&gt; (typically ending in ble, like Streamable, Strideable,<br>&gt; ArrayLiteralConvertible). The former more commonly discuss what a<br>&gt; conforming type is and the latter what it does.  *<br>&gt;<br>&gt; *When naming a protocol, you’re not limited to Type and ble endings. Your<br>&gt; protocol can be, for example, a DataProvider or a FloatConsumer. A protocol<br>&gt; can describe a relationship DownloadProcessingDelegate or<br>&gt; ListViewDataSource. You may implement an OutputDestination or an<br>&gt; IntegerSink. The current API Design guidelines say &quot;omit needless words&quot;,<br>&gt; so you might prefer to go with DataProvider over DataProviderType or<br>&gt;  MirrorPath over MirrorPathType, but I wouldn&#39;t give much more constraint<br>&gt; to naming beyond that.*<br>&gt;<br>&gt; For example, for &quot;HasNoun&quot;, I&#39;d go with something more like<br>&gt; NounContainingType or NounSupplier.<br>&gt;<br>&gt; Non-Abrahams Dave writes: &quot;I like -Type for protocols that can only be<br>&gt; used a generic constraint, and -able/-ible for protocols that can be<br>&gt; “concrete” types.<br>&gt;<br>&gt; And Canonical Dave replies: &quot;But that&#39;s not how they&#39;re used.  I&#39;d have to<br>&gt; rename Equatable and Comparable to follow that convention.&quot;<br>&gt;<br>&gt; I agree in that I&#39;m not convinced it&#39;s the role of a protocol to describe<br>&gt; implementation details. (I&#39;d say the same for method names, but that&#39;s<br>&gt; different thread about mutability and side effects, etc). Going that way<br>&gt; leads you to over-designated hungarian-esque guidelines that I&#39;d rather<br>&gt; keep loose, friendly, and sensible.<br>&gt;<br>&gt; -- Erica<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p><p><br>-- <br>  -- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/53ca3d67/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Review] SE-0006 Apply API Guidelines to the Standard Library</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>January 29, 2016 at 08:00:00am</p></header><div class="content"><p>This is very cute but limited in terms of application. Recall that there are several members that can be described in protocols, not just method members, such as initializers, subscripts, etc. This is a nice rule to have in a personal style guide, but I think it&#39;s far too narrow for Apple-sourced guidance.<br></p><p>-- E<br></p><p>&gt; On Jan 28, 2016, at 9:33 PM, Howard Lovatt &lt;howard.lovatt at gmail.com&gt; wrote:<br>&gt; <br>&gt; For protocols named XXXble I think they should have a main method named XXX. If this were adopted then many protocol names would change, e.g.:<br>&gt; <br>&gt;     1. ForwardIndexType would be Advanceable because it has advance methods and method successor() would be renamed advance().<br>&gt;     2. Indexable would be Subscriptable because it has a subscript method.<br>&gt;     3. Etc.<br>&gt; <br>&gt; On 29 January 2016 at 05:03, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 27, 2016, at 11:42 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Wed Jan 27 2016, Dave &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Huh… Yeah, you’re right. I guess I saw “CollectionType” and<br>&gt;&gt;&gt; “CustomStringConvertible” or something and made a connection that<br>&gt;&gt;&gt; wasn’t there.<br>&gt;&gt;&gt; Well, FWIW, that convention (plus the occasional “HasNoun”, and<br>&gt;&gt;&gt; -ableType for constraining the element of custom collections) tends to<br>&gt;&gt;&gt; work well for me.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What’s been the deciding factor between -Type and -able so far?<br>&gt;&gt; <br>&gt;&gt; When there&#39;s no reasonable -able or -ible name, use -Type.<br>&gt; <br>&gt; This is where I never know whether to keep my nose out of things or just jump in. I find there are generally two kinds of protocols: verby-ones (&quot;this is how this thing works&quot;) and nouny-ones (&quot;this is what this thing is&quot;). Here&#39;s the guidance I&#39;ve been giving:<br>&gt; <br>&gt; Swift protocols describe the surface that connect a feature provider API with its consumer. Protocols establish a communication contract. They ensure a fit between each required member and the provider’s implementation. It’s like whether a virus can attach to a host cell’s receptors, or whatever the actual biological equivalent is. The standard library describes protocols using nouns (typically ending in Type, e.g. MirrorPathType, MutableCollectionType, ErrorType) and adjectives (typically ending in ble, like Streamable, Strideable, ArrayLiteralConvertible). The former more commonly discuss what a conforming type is and the latter what it does.  <br>&gt; <br>&gt; When naming a protocol, you’re not limited to Type and ble endings. Your protocol can be, for example, a DataProvider or a FloatConsumer. A protocol can describe a relationship DownloadProcessingDelegate or ListViewDataSource. You may implement an OutputDestination or an IntegerSink. The current API Design guidelines say &quot;omit needless words&quot;, so you might prefer to go with DataProvider over DataProviderType or  MirrorPath over MirrorPathType, but I wouldn&#39;t give much more constraint to naming beyond that.<br>&gt; <br>&gt; For example, for &quot;HasNoun&quot;, I&#39;d go with something more like NounContainingType or NounSupplier.<br>&gt; <br>&gt; Non-Abrahams Dave writes: &quot;I like -Type for protocols that can only be used a generic constraint, and -able/-ible for protocols that can be “concrete” types.<br>&gt; <br>&gt; And Canonical Dave replies: &quot;But that&#39;s not how they&#39;re used.  I&#39;d have to rename Equatable and Comparable to follow that convention.&quot;<br>&gt; <br>&gt; I agree in that I&#39;m not convinced it&#39;s the role of a protocol to describe implementation details. (I&#39;d say the same for method names, but that&#39;s different thread about mutability and side effects, etc). Going that way leads you to over-designated hungarian-esque guidelines that I&#39;d rather keep loose, friendly, and sensible.<br>&gt; <br>&gt; -- Erica<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt;   -- Howard.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/78c4a7e6/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
