<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>Proposal: Auto-convert for numbers when safe</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>December  5, 2015 at 04:00:00am</p></header><div class="content"><p>I understand why you can’t auto-convert from a Double to a Float or Int32 to Int8.  It is good that we have to add the cast explicitly and think though the implications.<br></p><p>…but I don’t think through the implications because we currently have a boy who cried wolf situation where we have to explicitly cast everything (even the safe stuff).<br></p><p><br>I think all of the numeric types should be able to auto-convert if the conversion is safe (without loss of precision or overflow).<br></p><p>For example:<br>• If an Int is casting to a larger size (Int16 -&gt; Int32)<br>• Float -&gt; Double<br>• Float -&gt; CGFloat<br>• Int -&gt; Float, Double, or CGFloat (but not the other way)<br></p><p>I don’t see why these aren’t allowed. The forced casts make my code much less readable.  Are the casts above dangerous in a way I am not aware of?<br></p><p>On a side note, can we get a version of floor() which returns an Int (or have I missed that somewhere)?<br></p><p>Thanks,<br>Jon<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>Proposal: Auto-convert for numbers when safe</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>December  5, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; On 05 Dec 2015, at 14:27, Jonathan Hull &lt;jhull at gbis.com&gt; wrote:<br>&gt; <br>&gt; For example:<br>&gt; • Int -&gt; Float, Double, or CGFloat (but not the other way)<br></p><p>These are not &quot;safe&quot; conversions in general. A Float can only hold integral values up to 2^24, and Double a only up to 2^53. Neither can fit 64-bit integers and the former not even Int32.<br></p><p>&gt; On a side note, can we get a version of floor() which returns an Int (or have I missed that somewhere)?<br></p><p><br>This would be nice. As would be similar versions of ceil and round.<br></p><p>— Pyry Jahkola<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/0c738563/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 842 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/0c738563/attachment.sig&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Proposal: Auto-convert for numbers when safe</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December  5, 2015 at 05:00:00am</p></header><div class="content"><p>&gt; I understand why you can’t auto-convert from a Double to a Float or Int32 to Int8.  It is good that we have to add the cast explicitly and think though the implications.<br>&gt; <br>&gt; …but I don’t think through the implications because we currently have a boy who cried wolf situation where we have to explicitly cast everything (even the safe stuff).<br>&gt; <br>&gt; <br>&gt; I think all of the numeric types should be able to auto-convert if the conversion is safe (without loss of precision or overflow).<br>&gt; <br>&gt; For example:<br>&gt; • If an Int is casting to a larger size (Int16 -&gt; Int32)<br>&gt; • Float -&gt; Double<br>&gt; • Float -&gt; CGFloat<br>&gt; • Int -&gt; Float, Double, or CGFloat (but not the other way)<br>&gt; <br>&gt; I don’t see why these aren’t allowed. The forced casts make my code much less readable.  Are the casts above dangerous in a way I am not aware of?<br></p><p>Well, certain large Ints may not have a corresponding Float, and very large ones (on 64-bit platforms) might not have an exact Double. In fact, even Float -&gt; Double conversions can go subtly wrong, as I recall. <br></p><p>One reason not to do this is that I suspect it may slow down type inference, and thus the compiler. If every numeric type can be implicitly converted to a long list of larger types, that’s a lot more types for the compiler to think about every time you add two numbers.<br></p><p>Another is simply that it’s not clear how you would express to the type system which conversions could be done implicitly and which were verboten. Remember, Int and friends are all ordinary Swift structs; we don’t want to give them magical powers that aren’t available to other types. (I seem to recall that in the early Swift betas, there was a magic _convert() method or something that you could overload, but this was dropped as the language was redesigned. Perhaps the people who actually did the dropping could explain that one.)<br></p><p>A third is that conversions can, in some cases, cost time. Usually not much, but in a tight arithmetic loop it might matter.<br></p><p>A fourth: your code should probably not be using so many numeric types. There’s rarely a good reason to use an explicitly-sized integer, an unsigned integer, or a Float. That means most of your code should be using only Int, Double, and CGFloat (which is unavoidable). If you’re converting because an awkwardly-bridged API uses an explicitly sized type, overload the API with a wrapper that’s correctly typed. If you’re converting because you’re doing bit-twiddling, you probably need fine control over when values are resized.<br></p><p>Finally, if all that fails and you do need to convert, I prefer the strategy of marking your conversion sites explicitly. This (old, possibly out-of-date) code sample shows what I mean: &lt;https://gist.github.com/brentdax/f85ede7dd7b26c6e716e&gt; Marking conversions explicitly with a low-visual-impact operator which only allows widening conversions gets you the same safety as your proposal and nearly the same convenience, but also makes your meaning explicit, is kinder to the type checker, and doesn’t require any new features to be added to the type system.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: Auto-convert for numbers when safe</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December  5, 2015 at 11:00:00pm</p></header><div class="content"><p>On Dec 5, 2015, at 4:27 AM, Jonathan Hull &lt;jhull at gbis.com&gt; wrote:<br>&gt; I understand why you can’t auto-convert from a Double to a Float or Int32 to Int8.  It is good that we have to add the cast explicitly and think though the implications.<br>&gt; <br>&gt; …but I don’t think through the implications because we currently have a boy who cried wolf situation where we have to explicitly cast everything (even the safe stuff).<br>&gt; <br>&gt; <br>&gt; I think all of the numeric types should be able to auto-convert if the conversion is safe (without loss of precision or overflow).<br>&gt; <br>&gt; For example:<br>&gt; • If an Int is casting to a larger size (Int16 -&gt; Int32)<br>&gt; • Float -&gt; Double<br>&gt; • Float -&gt; CGFloat<br>&gt; • Int -&gt; Float, Double, or CGFloat (but not the other way)<br>&gt; <br>&gt; I don’t see why these aren’t allowed. The forced casts make my code much less readable.  Are the casts above dangerous in a way I am not aware of?<br></p><p>I agree that the current Swift numerics model is suboptimal, I personally would like to see small integers implicitly promote to large integers (when they are known lossless), have Float promote to Double, and have both Float and Double promote to CGFloat (yes, I know that the Double -&gt; CGFloat promotion would be lossy on 32-bit apple platforms).  I personally don’t think that integer -&gt; floating point promotions are a good idea even if value preserving, since their domains are so different.<br></p><p>The problem with doing this today is that there are a lot of dependencies we need to get resolved first.<br></p><p>1. The type checker is really slow, partially because of too-many and too-crazy implicit conversions.  We also get very surprising behavior when they kick in. Specifically, IMO, we need to reevaluate the T! &lt;-&gt; T and T to T? conversions.  We have thoughts on this, but should be discussed in a separate thread if you’re interested.<br></p><p>2. These promotions should be expressible in the library, not hard coded into the compiler.  This means that we would need a language feature to (e.g.) be able to define subtype relationships between structs.  Such a feature would be generally useful and could allow us to push some of our existing compiler magic out to the stdlib.<br></p><p>3. We want the existing work to revise the numerics protocols to be better understood and hopefully implemented.<br></p><p>There are also a ton of unrelated specific problems that should be addressed in various ways: e.g. macros like M_PI get imported as Double instead of a typeless literal, forcing tons of casts in code that wants to use it (e.g.) with Floats.  These issues are separable, and blocked on things like generic properties not being in place.<br></p><p>It would be great for interested contributors to start pushing on any of the above issues to help unblock progress on improving the numerics model.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6f13bb8ea87a42e72699d1c78dc06464?s=50"></div><header><strong>Proposal: Auto-convert for numbers when safe</strong> from <string>Manav Gabhawala</string> &lt;manav1907 at gmail.com&gt;<p>December  6, 2015 at 02:00:00am</p></header><div class="content"><p>One suggestion of a way to get around the problem of promotions could be implicit initializers. So you could have one parameter initializers that can be marked with a keyword/attribute like implicit and the compiler can automatically insert the right the initializer in place (kind of like C++ does it except the keyword implicit would be an antonym to the explicit keyword in C++). This could potentially solve the type checker speed and also allow you to move this implementation to the stdlib. It could also potentially have some interesting use cases outside of the std library too. We would also have to consider whether implicit initializers could throw errors and whether they could be failable or not.<br>IMO implicit initializers should not be able to throw but should be allowed to be failable. For instance, one could have an implicit initializer from a String to NSURL but have it failable too and use a guard let/if let to bind to it (see example later)<br></p><p>So something along the lines of:<br></p><p>		<br>class Double {<br>	implicit init(_ f: Float) {<br>		// initializes a double from a float.<br>	}<br>}<br></p><p>// For the String -&gt; NSURL<br>class NSURL { <br>	implicit init?(_ str: String) {<br>		// initializes the usual way.<br>	}<br>}<br>// And then in at the call site<br>guard let URL : NSURL = someString<br>else { return  }<br>// Do something with someString.<br></p><p><br>However, because of how Swift is structured and its emphasis on being explicit (which is a great thing), this should only be used sparingly and should be discouraged unless it absolutely makes sense.<br></p><p>Regards,<br>Manav Gabhawala<br></p><p>On December 6, 2015 at 2:02:51 AM, Chris Lattner via swift-evolution (swift-evolution at swift.org) wrote:<br></p><p>On Dec 5, 2015, at 4:27 AM, Jonathan Hull &lt;jhull at gbis.com&gt; wrote:<br>&gt; I understand why you can’t auto-convert from a Double to a Float or Int32 to Int8. It is good that we have to add the cast explicitly and think though the implications.<br>&gt;  <br>&gt; …but I don’t think through the implications because we currently have a boy who cried wolf situation where we have to explicitly cast everything (even the safe stuff).<br>&gt;  <br>&gt;  <br>&gt; I think all of the numeric types should be able to auto-convert if the conversion is safe (without loss of precision or overflow).<br>&gt;  <br>&gt; For example:<br>&gt; • If an Int is casting to a larger size (Int16 -&gt; Int32)<br>&gt; • Float -&gt; Double<br>&gt; • Float -&gt; CGFloat<br>&gt; • Int -&gt; Float, Double, or CGFloat (but not the other way)<br>&gt;  <br>&gt; I don’t see why these aren’t allowed. The forced casts make my code much less readable. Are the casts above dangerous in a way I am not aware of?<br></p><p>I agree that the current Swift numerics model is suboptimal, I personally would like to see small integers implicitly promote to large integers (when they are known lossless), have Float promote to Double, and have both Float and Double promote to CGFloat (yes, I know that the Double -&gt; CGFloat promotion would be lossy on 32-bit apple platforms). I personally don’t think that integer -&gt; floating point promotions are a good idea even if value preserving, since their domains are so different.<br></p><p>The problem with doing this today is that there are a lot of dependencies we need to get resolved first.<br></p><p>1. The type checker is really slow, partially because of too-many and too-crazy implicit conversions. We also get very surprising behavior when they kick in. Specifically, IMO, we need to reevaluate the T! &lt;-&gt; T and T to T? conversions. We have thoughts on this, but should be discussed in a separate thread if you’re interested.<br></p><p>2. These promotions should be expressible in the library, not hard coded into the compiler. This means that we would need a language feature to (e.g.) be able to define subtype relationships between structs. Such a feature would be generally useful and could allow us to push some of our existing compiler magic out to the stdlib.<br></p><p>3. We want the existing work to revise the numerics protocols to be better understood and hopefully implemented.<br></p><p>There are also a ton of unrelated specific problems that should be addressed in various ways: e.g. macros like M_PI get imported as Double instead of a typeless literal, forcing tons of casts in code that wants to use it (e.g.) with Floats. These issues are separable, and blocked on things like generic properties not being in place.<br></p><p>It would be great for interested contributors to start pushing on any of the above issues to help unblock progress on improving the numerics model.<br></p><p>-Chris<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/ecb33bfa/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: Auto-convert for numbers when safe</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December  5, 2015 at 11:00:00pm</p></header><div class="content"><p>&gt; On Dec 5, 2015, at 11:21 PM, Manav Gabhawala &lt;manav1907 at gmail.com&gt; wrote:<br>&gt; <br>&gt; One suggestion of a way to get around the problem of promotions could be implicit initializers.<br></p><p>Swift has already had a feature to support arbitrary implicit conversion between types: it was madness and got ripped out :-)<br></p><p>I’m not opposed to allowing user-defined implicit conversions, but IMO they need to be limited to a DAG of subtype relationships.<br></p><p>-Chris<br></p><p><br>&gt; So you could have one parameter initializers that can be marked with a keyword/attribute like implicit and the compiler can automatically insert the right the initializer in place (kind of like C++ does it except the keyword implicit would be an antonym to the explicit keyword in C++). This could potentially solve the type checker speed and also allow you to move this implementation to the stdlib. It could also potentially have some interesting use cases outside of the std library too. We would also have to consider whether implicit initializers could throw errors and whether they could be failable or not.<br>&gt; IMO implicit initializers should not be able to throw but should be allowed to be failable. For instance, one could have an implicit initializer from a String to NSURL but have it failable too and use a guard let/if let to bind to it (see example later)<br>&gt; <br>&gt; So something along the lines of:<br>&gt; <br>&gt; 	<br>&gt; class Double {<br>&gt; 	implicit init(_ f: Float) {<br>&gt; 		// initializes a double from a float.<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; // For the String -&gt; NSURL<br>&gt; class NSURL { <br>&gt; 	implicit init?(_ str: String) {<br>&gt; 		// initializes the usual way.<br>&gt; 	}<br>&gt; }<br>&gt; // And then in at the call site<br>&gt; guard let URL : NSURL = someString<br>&gt; else { return  }<br>&gt; // Do something with someString.<br>&gt; <br>&gt; <br>&gt; However, because of how Swift is structured and its emphasis on being explicit (which is a great thing), this should only be used sparingly and should be discouraged unless it absolutely makes sense.<br>&gt; <br>&gt; Regards,<br>&gt; Manav Gabhawala<br>&gt; <br>&gt; On December 6, 2015 at 2:02:51 AM, Chris Lattner via swift-evolution (swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;) wrote:<br>&gt; <br>&gt;&gt; On Dec 5, 2015, at 4:27 AM, Jonathan Hull &lt;jhull at gbis.com &lt;mailto:jhull at gbis.com&gt;&gt; wrote:<br>&gt;&gt; &gt; I understand why you can’t auto-convert from a Double to a Float or Int32 to Int8. It is good that we have to add the cast explicitly and think though the implications.<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; …but I don’t think through the implications because we currently have a boy who cried wolf situation where we have to explicitly cast everything (even the safe stuff).<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; <br>&gt;&gt; &gt; I think all of the numeric types should be able to auto-convert if the conversion is safe (without loss of precision or overflow).<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; For example:<br>&gt;&gt; &gt; • If an Int is casting to a larger size (Int16 -&gt; Int32)<br>&gt;&gt; &gt; • Float -&gt; Double<br>&gt;&gt; &gt; • Float -&gt; CGFloat<br>&gt;&gt; &gt; • Int -&gt; Float, Double, or CGFloat (but not the other way)<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; I don’t see why these aren’t allowed. The forced casts make my code much less readable. Are the casts above dangerous in a way I am not aware of?<br>&gt;&gt; <br>&gt;&gt; I agree that the current Swift numerics model is suboptimal, I personally would like to see small integers implicitly promote to large integers (when they are known lossless), have Float promote to Double, and have both Float and Double promote to CGFloat (yes, I know that the Double -&gt; CGFloat promotion would be lossy on 32-bit apple platforms). I personally don’t think that integer -&gt; floating point promotions are a good idea even if value preserving, since their domains are so different.<br>&gt;&gt; <br>&gt;&gt; The problem with doing this today is that there are a lot of dependencies we need to get resolved first.<br>&gt;&gt; <br>&gt;&gt; 1. The type checker is really slow, partially because of too-many and too-crazy implicit conversions. We also get very surprising behavior when they kick in. Specifically, IMO, we need to reevaluate the T! &lt;-&gt; T and T to T? conversions. We have thoughts on this, but should be discussed in a separate thread if you’re interested.<br>&gt;&gt; <br>&gt;&gt; 2. These promotions should be expressible in the library, not hard coded into the compiler. This means that we would need a language feature to (e.g.) be able to define subtype relationships between structs. Such a feature would be generally useful and could allow us to push some of our existing compiler magic out to the stdlib.<br>&gt;&gt; <br>&gt;&gt; 3. We want the existing work to revise the numerics protocols to be better understood and hopefully implemented.<br>&gt;&gt; <br>&gt;&gt; There are also a ton of unrelated specific problems that should be addressed in various ways: e.g. macros like M_PI get imported as Double instead of a typeless literal, forcing tons of casts in code that wants to use it (e.g.) with Floats. These issues are separable, and blocked on things like generic properties not being in place.<br>&gt;&gt; <br>&gt;&gt; It would be great for interested contributors to start pushing on any of the above issues to help unblock progress on improving the numerics model.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/f96f8409/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
