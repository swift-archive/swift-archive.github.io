<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Delegate Method Conventions (was:[Review] SE-0023 API Design Guidelines)</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>January 24, 2016 at 03:00:00pm</p></header><div class="content"><p>on Sat Jan 23 2016, plx &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; On Jan 23, 2016, at 2:33 PM, Dave Abrahams via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Sat Jan 23 2016, plx<br>&gt;<br>&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 22, 2016, at 6:12 PM, Ross O&#39;Brien via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; How would we apply this to delegate patterns?<br>&gt;&gt;&gt;&gt; For example, would we keep<br>&gt;&gt;&gt;&gt; tableview(tableView:cellForRowAtIndexPath:), or would we switch to<br>&gt;&gt;&gt;&gt; delegate(tableView:cellForRowAtIndexPath:) ?<br>&gt;&gt;&gt;&gt; Or perhaps better, for clarity over which protocol is being<br>&gt;&gt;&gt;&gt; conformed to / which property of the delegator is calling the<br>&gt;&gt;&gt;&gt; function:<br>&gt;&gt;&gt;&gt; dataSource(tableView:cellForRowAtIndexPath:),<br>&gt;&gt;&gt;&gt; delegate(tableView:didSelectRowAtIndexPath:)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; FWIW, I am personally favorable to a more radical-renaming for delegate methods, roughly the below:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func numberOfSections(inTableView tableView: UITableView) -&gt; Int // &lt;- against guidelines, but symmetric<br>&gt;&gt;&gt; func numberOfRows(inTableView tableView: UITableView, forSection section: Int) -&gt; Int<br>&gt;&gt;&gt; func cellForRow(inTableView tableView: UITableView, atIndexPath indexPath: NSIndexPath) -&gt; UITableView<br>&gt;&gt; <br>&gt;&gt; The interesting thing about delegate methods is that, for the most part,<br>&gt;&gt; use-sites don&#39;t appear in user code.  So *if* you&#39;re going to come up with<br>&gt;&gt; special conventions just for delegate methods you&#39;d want to serve the<br>&gt;&gt; declaration site.  I don&#39;t know what these things *ought* to look like,<br>&gt;&gt; but the declarations above look to me like they&#39;ve got an awful lot of<br>&gt;&gt; redundancy that doesn&#39;t help readability.<br>&gt;<br>&gt; Most of what follows should really be in the discussion about the<br>&gt; Objective-C import, not here, but I’ll respond here with the parts<br>&gt; relevant to the guidelines.<br>&gt;<br>&gt; It seems self-evident that imported delegate methods violate the<br>&gt; spirit of Swift’s API guidelines; in particular, the rule that<br>&gt; “Methods can share a base name when they share the same basic meaning<br>&gt; but operate on different types, or are in different domains” seems<br>&gt; relevant. <br></p><p>That&#39;s quite true.<br></p><p>&gt; It’s thus been a bit surprising to me that delegate-style methods<br>&gt; haven’t *already* gotten some special treatment; <br></p><p>Well, it&#39;s a fact of life that major efforts like this one (probably<br>property behaviors are the same bucket) are going to have to land<br>without solving all the problems they are related to.  I believe<br>strongly that we should do *something* about delegate methods.  I also<br>believe they&#39;re a separable problem and we should be able to evaluate<br>the current direction without working out all the details of how we&#39;re<br>going to handle them.  That&#39;s why I changed the subject line: I&#39;d like<br>to agree that special treatment for delegate methods in the importer is<br>out-of-scope in this review.<br></p><p>&gt; what I had isn’t great, but put it and some variants up against the<br>&gt; original, like so:<br>&gt;<br>&gt; func numberOfRows(in tableView: UITableView, forSection section: Int) -&gt; Int<br>&gt; func numberOfRowsIn(tableView: UITableView, forSection section: Int) -&gt; Int<br>&gt; func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int<br>&gt; func numberOfRows(inTableView tableView: UITableView, forSection section: Int) -&gt; Int<br></p><p>I assume you mean the 3rd one to be &quot;the original?&quot;<br></p><p>&gt; …(note the longest is only ~10 characters longer than the shortest!). <br></p><p>Sorry, I don&#39;t see why that is relevant.  Care to explain?<br></p><p>&gt; Although there might be an as-yet unseen option that’s superior to all<br>&gt; of the above, just out of those 4 it’s hard to see how you can justify<br>&gt; option #3 using the API guidelines; <br>&gt; it also seems hard to envision a self-consistent expansion of the<br>&gt; guidelines that’d lead to favoring #3.<br></p><p>You can&#39;t.<br></p><p>&gt; As already noted this is really more-relevant to the “objective-c<br>&gt; import revision”, but you can frame my points as obliquely asking “to<br>&gt; what extent should the Swift API guidelines actually matter when doing<br>&gt; the big Objective-C import?”<br></p><p>We&#39;re willing to accept that some imported APIs will not follow the<br>guidelines.<br></p><p>&gt; I also question your sense of real-world use of delegate protocols;<br>&gt; just taking inventory of the most recent project I completed, it looks<br>&gt; like it had 5 custom delegate-style protocols. Of these, 4 had exactly<br>&gt; one implementation each, and 1 had exactly 2 implementations; <br></p><p>And how many use-sites were there?<br></p><p>&gt; I don’t think this is that untypical. If you accept it as not too<br>&gt; atypical,<br></p><p>I do.<br></p><p>&gt; it suggests a more uniform balance between defining a delegate<br>&gt; protocol, using said protocol, and implementing said protocol.<br></p><p>Not necessarily.  How many times did this project implement delegate<br>protocols that were defined elsewhere?  <br></p><p>In any case, for what it&#39;s worth, I personally think the direction<br>you&#39;re going with those delegate APIs is great, and it has the benefit<br>of bringing them into conformance with other guidelines.  My only point<br>in saying that the declaration site is more important with delegate<br>methods than with others is that there&#39;s more type information at the<br>declaration site of a method than at its use site, so there&#39;s definitely<br>no reason to make them more verbose than others.  Making them simply<br>follow the existing guidelines exactly is a simple solution that IMO<br>leads to good code, and one I would support.<br></p><p>However, what Cocoa guys like Tony Parker say about the eventual<br>direction of delegate APIs should probably carry a lot more weight than<br>what I say.<br></p><p>&gt; To wind this digression down now, the API guidelines’ attitude towards<br>&gt; redundancy seems somewhat troubling; no one wants needless redundancy,<br>&gt; but natural languages tend towards redundancy (cf<br>&gt; agreement/pleonasm/etc) and it’s not at all self-evident that less<br>&gt; redundancy always implies increased readability (which you may or may<br>&gt; not be intending to imply; I can’t tell)…especially when it’s easy to<br>&gt; get fooled by increased speed-of-reading.<br></p><p>This seems like a pretty vague concern.  Let&#39;s see concrete examples of<br>problems you think the guidelines&#39; attitude toward redundancy will<br>cause.  FWIW, &quot;omit needless words&quot; isn&#39;t something we just came<br>up with ourselves: it&#39;s a time-honored principle of clear English<br>writing (google it).<br></p><p><br>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>Delegate Method Conventions (was:[Review] SE-0023 API Design Guidelines)</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>January 26, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Jan 24, 2016, at 5:57 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Sat Jan 23 2016, plx &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Jan 23, 2016, at 2:33 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Sat Jan 23 2016, plx<br>&gt;&gt; <br>&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 22, 2016, at 6:12 PM, Ross O&#39;Brien via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; How would we apply this to delegate patterns?<br>&gt;&gt;&gt;&gt;&gt; For example, would we keep<br>&gt;&gt;&gt;&gt;&gt; tableview(tableView:cellForRowAtIndexPath:), or would we switch to<br>&gt;&gt;&gt;&gt;&gt; delegate(tableView:cellForRowAtIndexPath:) ?<br>&gt;&gt;&gt;&gt;&gt; Or perhaps better, for clarity over which protocol is being<br>&gt;&gt;&gt;&gt;&gt; conformed to / which property of the delegator is calling the<br>&gt;&gt;&gt;&gt;&gt; function:<br>&gt;&gt;&gt;&gt;&gt; dataSource(tableView:cellForRowAtIndexPath:),<br>&gt;&gt;&gt;&gt;&gt; delegate(tableView:didSelectRowAtIndexPath:)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; FWIW, I am personally favorable to a more radical-renaming for delegate methods, roughly the below:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func numberOfSections(inTableView tableView: UITableView) -&gt; Int // &lt;- against guidelines, but symmetric<br>&gt;&gt;&gt;&gt; func numberOfRows(inTableView tableView: UITableView, forSection section: Int) -&gt; Int<br>&gt;&gt;&gt;&gt; func cellForRow(inTableView tableView: UITableView, atIndexPath indexPath: NSIndexPath) -&gt; UITableView<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The interesting thing about delegate methods is that, for the most part,<br>&gt;&gt;&gt; use-sites don&#39;t appear in user code.  So *if* you&#39;re going to come up with<br>&gt;&gt;&gt; special conventions just for delegate methods you&#39;d want to serve the<br>&gt;&gt;&gt; declaration site.  I don&#39;t know what these things *ought* to look like,<br>&gt;&gt;&gt; but the declarations above look to me like they&#39;ve got an awful lot of<br>&gt;&gt;&gt; redundancy that doesn&#39;t help readability.<br>&gt;&gt; <br>&gt;&gt; Most of what follows should really be in the discussion about the<br>&gt;&gt; Objective-C import, not here, but I’ll respond here with the parts<br>&gt;&gt; relevant to the guidelines.<br>&gt;&gt; <br>&gt;&gt; It seems self-evident that imported delegate methods violate the<br>&gt;&gt; spirit of Swift’s API guidelines; in particular, the rule that<br>&gt;&gt; “Methods can share a base name when they share the same basic meaning<br>&gt;&gt; but operate on different types, or are in different domains” seems<br>&gt;&gt; relevant. <br>&gt; <br>&gt; That&#39;s quite true.<br>&gt; <br>&gt;&gt; It’s thus been a bit surprising to me that delegate-style methods<br>&gt;&gt; haven’t *already* gotten some special treatment; <br>&gt; <br>&gt; Well, it&#39;s a fact of life that major efforts like this one (probably<br>&gt; property behaviors are the same bucket) are going to have to land<br>&gt; without solving all the problems they are related to.  I believe<br>&gt; strongly that we should do *something* about delegate methods.  I also<br>&gt; believe they&#39;re a separable problem and we should be able to evaluate<br>&gt; the current direction without working out all the details of how we&#39;re<br>&gt; going to handle them.  That&#39;s why I changed the subject line: I&#39;d like<br>&gt; to agree that special treatment for delegate methods in the importer is<br>&gt; out-of-scope in this review.<br>&gt; <br>&gt;&gt; what I had isn’t great, but put it and some variants up against the<br>&gt;&gt; original, like so:<br>&gt;&gt; <br>&gt;&gt; func numberOfRows(in tableView: UITableView, forSection section: Int) -&gt; Int<br>&gt;&gt; func numberOfRowsIn(tableView: UITableView, forSection section: Int) -&gt; Int<br>&gt;&gt; func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int<br>&gt;&gt; func numberOfRows(inTableView tableView: UITableView, forSection section: Int) -&gt; Int<br>&gt; <br>&gt; I assume you mean the 3rd one to be &quot;the original?”<br></p><p>Yes, here: tableView(_:numberOfRowsInSection:) &lt;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UITableViewDataSource_Protocol/#//apple_ref/occ/intfm/UITableViewDataSource/tableView:numberOfRowsInSection:&gt;<br>&gt; <br>&gt;&gt; …(note the longest is only ~10 characters longer than the shortest!). <br>&gt; <br>&gt; Sorry, I don&#39;t see why that is relevant.  Care to explain?<br></p><p>I did not make the intention clear; apologies. I was intending to illustrate that although all of the examples contain redundancies, none of them are egregiously worse than the others (including the original); the worst case is only moderately more-redundant than the best case.<br></p><p>&gt; <br>&gt;&gt; Although there might be an as-yet unseen option that’s superior to all<br>&gt;&gt; of the above, just out of those 4 it’s hard to see how you can justify<br>&gt;&gt; option #3 using the API guidelines; <br>&gt;&gt; it also seems hard to envision a self-consistent expansion of the<br>&gt;&gt; guidelines that’d lead to favoring #3.<br>&gt; <br>&gt; You can&#39;t.<br>&gt; <br>&gt;&gt; As already noted this is really more-relevant to the “objective-c<br>&gt;&gt; import revision”, but you can frame my points as obliquely asking “to<br>&gt;&gt; what extent should the Swift API guidelines actually matter when doing<br>&gt;&gt; the big Objective-C import?”<br>&gt; <br>&gt; We&#39;re willing to accept that some imported APIs will not follow the<br>&gt; guidelines.<br>&gt; <br>&gt;&gt; I also question your sense of real-world use of delegate protocols;<br>&gt;&gt; just taking inventory of the most recent project I completed, it looks<br>&gt;&gt; like it had 5 custom delegate-style protocols. Of these, 4 had exactly<br>&gt;&gt; one implementation each, and 1 had exactly 2 implementations; <br>&gt; <br>&gt; And how many use-sites were there?<br></p><p>5, just counting “classes using said delegates”; 14 if you go by individual method use. <br></p><p>&gt; <br>&gt;&gt; I don’t think this is that untypical. If you accept it as not too<br>&gt;&gt; atypical,<br>&gt; <br>&gt; I do.<br>&gt; <br>&gt;&gt; it suggests a more uniform balance between defining a delegate<br>&gt;&gt; protocol, using said protocol, and implementing said protocol.<br>&gt; <br>&gt; Not necessarily.  How many times did this project implement delegate<br>&gt; protocols that were defined elsewhere?  <br></p><p>Looks like 12, for implementations; “a lot”, going by by the method count.<br></p><p>In any case I don’t dispute the general point, just perhaps the exit.<br></p><p>&gt; <br>&gt; In any case, for what it&#39;s worth, I personally think the direction<br>&gt; you&#39;re going with those delegate APIs is great, and it has the benefit<br>&gt; of bringing them into conformance with other guidelines.  My only point<br>&gt; in saying that the declaration site is more important with delegate<br>&gt; methods than with others is that there&#39;s more type information at the<br>&gt; declaration site of a method than at its use site, so there&#39;s definitely<br>&gt; no reason to make them more verbose than others.  Making them simply<br>&gt; follow the existing guidelines exactly is a simple solution that IMO<br>&gt; leads to good code, and one I would support.<br>&gt; <br>&gt; However, what Cocoa guys like Tony Parker say about the eventual<br>&gt; direction of delegate APIs should probably carry a lot more weight than<br>&gt; what I say.<br>&gt; <br>&gt;&gt; To wind this digression down now, the API guidelines’ attitude towards<br>&gt;&gt; redundancy seems somewhat troubling; no one wants needless redundancy,<br>&gt;&gt; but natural languages tend towards redundancy (cf<br>&gt;&gt; agreement/pleonasm/etc) and it’s not at all self-evident that less<br>&gt;&gt; redundancy always implies increased readability (which you may or may<br>&gt;&gt; not be intending to imply; I can’t tell)…especially when it’s easy to<br>&gt;&gt; get fooled by increased speed-of-reading.<br>&gt; <br>&gt; This seems like a pretty vague concern.  Let&#39;s see concrete examples of<br>&gt; problems you think the guidelines&#39; attitude toward redundancy will<br>&gt; cause.  FWIW, &quot;omit needless words&quot; isn&#39;t something we just came<br>&gt; up with ourselves: it&#39;s a time-honored principle of clear English<br>&gt; writing (google it).<br></p><p>Sure, sure, but if you’ll forgive a cheap shot I’d point out Strunk would’ve tut-tutted here and suggested, perhaps, “we didn’t invent ‘omit needless words’”. The tricky part of that rule is that what’s needless is highly contextual, and to be *understood* when writing in a highly-condensed style usually requires a large amount of shared context.<br></p><p>Which need-for-context is at the root of my admittedly-vague concern; I’ve done my best to come up with a concrete-ish example, but it’s a bit contrived and not as strong as I’d like, either. It’s more of an &quot;ecosystem concern”, too.<br></p><p>Here are *six* functions that could conceivably be named `min` under the guidelines:<br></p><p>func min() -&gt; Generator.Element? // obviously only where `Generator.Element` is `Comparable`<br>func min(isLessThan comparator: (Generator.Element,Generator.Element) -&gt; Bool) -&gt; Generator.Element?<br>func min&lt;K:Comparable&gt;(extractor: (Generator.Element) -&gt; K) -&gt; K?<br>func min&lt;K:Comparable&gt;(extractor: (Generator.Element) -&gt; K?) -&gt; K?<br>func min&lt;T&gt;(extractor: (Generator.Element) -&gt; T, isLessThan comparator: (T,T) -&gt; Bool) -&gt; T?<br>func min&lt;T&gt;(extractor: (Generator.Element) -&gt; T?, isLessThan comparator: (T,T) -&gt; Bool) -&gt; T?<br></p><p>…and perhaps they *all* should be named `min` (and we simply let context and type information sort it all out for us).<br></p><p>But if the names should be different, what’re good choices?<br></p><p>My vague concern is that having “maximally-terse” names for the standard library functions makes it trickier to choose &quot;non-misleading” names for such closely-related variants.<br></p><p>EG: if you go with `minValue` for the variants, to a casual reader there’s room for confusion vis-a-vis `min` (I suspect many would initially guess that `minValue` does what `minElement` does today, but would guess the behavior correctly if given a choice between `minElement` and `minValue`).<br></p><p>Unfortunately for my case, I think `minFor` is a perfectly-reasonable choice here, which undermines my concrete example (I warned you the case wasn’t going to be very convincing).<br></p><p>But that’s the kind of vague concern I have here: that a “maximally-terse” naming convention can be harder to extend in a way that’s both self-consistent and not-potentially-misleading. <br></p><p>But I don’t have a great suggestion for an additional guideline, and there may be nothing serious to worry about here, either.<br></p><p>&gt; <br>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160126/ba42ae0a/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
