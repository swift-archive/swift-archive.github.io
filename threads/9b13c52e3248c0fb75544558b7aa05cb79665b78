<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Review] SE-0054: Abolish ImplicitlyUnwrappedOptional type</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>March 25, 2016 at 08:00:00am</p></header><div class="content"><p>Hello Swift community,<br></p><p>The review of &quot;Abolish ImplicitlyUnwrappedOptional type&quot; begins now and runs through March 30th. The proposal is available here:<br></p><p>	https://github.com/apple/swift-evolution/blob/master/proposals/0054-abolish-iuo.md<br></p><p>Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at:<br>	https://lists.swift.org/mailman/listinfo/swift-evolution<br>or, if you would like to keep your feedback private, directly to the review manager.<br></p><p><br>What goes into a review?<br></p><p>The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br></p><p>	* What is your evaluation of the proposal?<br>	* Is the problem being addressed significant enough to warrant a change to Swift?<br>	* Does this proposal fit well with the feel and direction of Swift?<br>	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>More information about the Swift evolution process is available at<br></p><p>	https://github.com/apple/swift-evolution/blob/master/process.md<br></p><p>Thank you,<br></p><p>-Chris Lattner<br>Review Manager<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9df2c06d044639a33128b3b66f0b6509?s=50"></div><header><strong>[Review] SE-0054: Abolish ImplicitlyUnwrappedOptional type</strong> from <string>Juan Ignacio Laube</string> &lt;juanignaciolaube at gmail.com&gt;<p>March 25, 2016 at 01:00:00pm</p></header><div class="content"><p>* What is your evaluation of the proposal?<br>+1. I agree that ImplicitlyUnwrappedOptional are a transition technology. And therefore, its usage should be limited.<br></p><p>* Is the problem being addressed significant enough to warrant a change to Swift?<br>Yes.<br></p><p>* Does this proposal fit well with the feel and direction of Swift?<br>Yes. And I agree this should be shipped with Swift 3.<br></p><p>* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>I think Rust has this kind of null safety already using an Optional type to indicate the absence of a value.<br></p><p>* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>Read the review and followed the discussion in swift-evolution.<br></p><p><br>&gt; On Mar 25, 2016, at 12:24 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;Abolish ImplicitlyUnwrappedOptional type&quot; begins now and runs through March 30th. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0054-abolish-iuo.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at:<br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5818a8a9211c31af95d6db8974457683?s=50"></div><header><strong>[Review] SE-0054: Abolish ImplicitlyUnwrappedOptional type</strong> from <string>Joseph Lord</string> &lt;joseph at human-friendly.com&gt;<p>March 25, 2016 at 08:00:00pm</p></header><div class="content"><p>On 25/03/2016 15:24, Chris Lattner via swift-evolution wrote:<br>&gt; Hello Swift community,<br>&gt;<br>&gt; The review of &quot;Abolish ImplicitlyUnwrappedOptional type&quot; begins now and runs through March 30th. The proposal is available here:<br>&gt;<br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0054-abolish-iuo.md<br>&gt;<br></p><p>As I don&#39;t use IUO optionals I&#39;m really fairly neutral on the proposal. <br>I just wanted to mention with the powerful tools we have for dealing <br>with optionals (optional, chaining, nil-coalescing, map, flatmap, guard, <br>and let - thanks Chris and team) it really would be quite feasible to do <br>away with IUOs completely. I don&#39;t think the community is ready for that <br>yet so I&#39;m not proposing that course of action at this time but such a <br>proposal wouldn&#39;t get a universally hostile response.<br></p><p>Even force unwrap is something that I only do test code since flatmap <br>was added to the Standard Library (I used to have my own implementation <br>of flatmap with a force unwrap after a filter which was the only <br>production use I&#39;ve put force unwrap to).<br></p><p>Joseph<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Review] SE-0054: Abolish ImplicitlyUnwrappedOptional type</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>March 25, 2016 at 03:00:00pm</p></header><div class="content"><p>I’m pretty sure I only use them with `@IBOutlet` vars.<br></p><p>One of the alternatives list is: <br>• Remove IUOs completely. Untenable due to the prevalence of deferred initialization and unannotated Objective-C API in today&#39;s Swift ecosystem.<br></p><p>What about leaving IUOs in the compiler, but disallowing them unless the code is marked @objc (and treating them as `T?` in code that isn’t)? The stated motivation is &quot;This proposal seeks to limit the adoption of IUOs to places where they are actually required, and put the Swift language on the path to removing implicitly unwrapped optionals from the system entirely when other technologies render them unnecessary.”… If they’re only intended to be used with C/Obj-C code, seems like that’s something that’d be possible for the compiler to enforce.<br></p><p>Having typed this all out, I’m starting to suspect it might be more complicated than what we have now… Hmm… I’ll hit send anyway, in case I’m wrong.<br></p><p>- Dave Sweeris<br></p><p>&gt; On Mar 25, 2016, at 3:10 PM, Joseph Lord via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On 25/03/2016 15:24, Chris Lattner via swift-evolution wrote:<br>&gt;&gt; Hello Swift community,<br>&gt;&gt; <br>&gt;&gt; The review of &quot;Abolish ImplicitlyUnwrappedOptional type&quot; begins now and runs through March 30th. The proposal is available here:<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0054-abolish-iuo.md<br>&gt;&gt; <br>&gt; <br>&gt; As I don&#39;t use IUO optionals I&#39;m really fairly neutral on the proposal. I just wanted to mention with the powerful tools we have for dealing with optionals (optional, chaining, nil-coalescing, map, flatmap, guard, and let - thanks Chris and team) it really would be quite feasible to do away with IUOs completely. I don&#39;t think the community is ready for that yet so I&#39;m not proposing that course of action at this time but such a proposal wouldn&#39;t get a universally hostile response.<br>&gt; <br>&gt; Even force unwrap is something that I only do test code since flatmap was added to the Standard Library (I used to have my own implementation of flatmap with a force unwrap after a filter which was the only production use I&#39;ve put force unwrap to).<br>&gt; <br>&gt; Joseph<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d9dbc0dfeb74eab8dd9bbd9cbd84680?s=50"></div><header><strong>[Review] SE-0054: Abolish ImplicitlyUnwrappedOptional type</strong> from <string>Jose Cheyo Jimenez</string> &lt;cheyo at masters3d.com&gt;<p>March 25, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt;    * What is your evaluation of the proposal?<br>This is a great idea. I actually feel that I understand IUO much better in this proposal than in the previous model. I do have a question. <br></p><p>let x: Int! = 5<br>let y = x<br></p><p>let a = x ?? 1 // would this still work? <br>Or would it auto unwrapping always? meaning when .some `a = 5` or crash when .none? <br>I am assuming that x is `Int?` that autounwraps. Just curious if autounwraps only happen on assignment like in `y = x`<br></p><p>&gt;    * Is the problem being addressed significant enough to warrant a change to Swift?<br>I believe so, it makes IUO feel more like an automatic behavior on regular optionals. <br>&gt;    * Does this proposal fit well with the feel and direction of Swift?<br>Yes embracing change while still supporting portable code. <br>&gt;    * If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>I&#39;ve only used this with swift. <br>&gt;    * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>Read the proposal and followed tread<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Review] SE-0054: Abolish ImplicitlyUnwrappedOptional type</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March 25, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; I do have a question. <br>&gt; <br>&gt; let x: Int! = 5<br>&gt; let y = x<br>&gt; <br>&gt; let a = x ?? 1 // would this still work? <br>&gt; Or would it auto unwrapping always? meaning when .some `a = 5` or crash when .none? <br>&gt; I am assuming that x is `Int?` that autounwraps. Just curious if autounwraps only happen on assignment like in `y = x`<br></p><p>I believe that, in this example, `y` is of type `Int?`, that is, a non-autounwrapped optional. An autounwrapped optional is only unwrapped if Swift cannot make the code type-check without unwrapping it.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d9dbc0dfeb74eab8dd9bbd9cbd84680?s=50"></div><header><strong>[Review] SE-0054: Abolish ImplicitlyUnwrappedOptional type</strong> from <string>Jose Cheyo Jimenez</string> &lt;cheyo at masters3d.com&gt;<p>March 25, 2016 at 06:00:00pm</p></header><div class="content"><p>Ah got it. I missed that part. [1]<br></p><p>&gt; On Mar 25, 2016, at 4:16 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; I do have a question. <br>&gt;&gt; <br>&gt;&gt; let x: Int! = 5<br>&gt;&gt; let y = x<br>&gt;&gt; <br>&gt;&gt; let a = x ?? 1 // would this still work? <br></p><p>This should work then. I guess I never thought about safely “unwrapping&quot; an IUO in swift2 but it works. <br></p><p>Thanks!<br></p><p>&gt;&gt; Or would it auto unwrapping always? meaning when .some `a = 5` or crash when .none? <br>&gt;&gt; I am assuming that x is `Int?` that autounwraps. Just curious if autounwraps only happen on assignment like in `y = x`<br>&gt; <br>&gt; I believe that, in this example, `y` is of type `Int?`, that is, a non-autounwrapped optional. An autounwrapped optional is only unwrapped if Swift cannot make the code type-check without unwrapping it.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>[1] “x is declared as an IUO, but because the initializer for y type checks correctly as an optional, y will be bound as typeInt?. However, the initializer for z does not type check with x declared as an optional (there&#39;s no overload of + that takes an optional), so the compiler forces the optional and type checks the initializer as Int.&quot;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160325/545d7f30/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: PastedGraphic-4.png<br>Type: image/png<br>Size: 13693 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160325/545d7f30/attachment.png&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>[Review] SE-0054: Abolish ImplicitlyUnwrappedOptional type</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>March 25, 2016 at 04:00:00pm</p></header><div class="content"><p>+1 on this proposal from me. It seems like a good step on the way to removing IUOs entirely. <br></p><p><br>Russ<br></p><p>&gt; On Mar 25, 2016, at 8:24 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;Abolish ImplicitlyUnwrappedOptional type&quot; begins now and runs through March 30th. The proposal is available here:<br>&gt; <br>&gt;    https://github.com/apple/swift-evolution/blob/master/proposals/0054-abolish-iuo.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at:<br>&gt;    https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt;    * What is your evaluation of the proposal?<br>&gt;    * Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;    * Does this proposal fit well with the feel and direction of Swift?<br>&gt;    * If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;    * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt;    https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Review] SE-0054: Abolish ImplicitlyUnwrappedOptional type</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March 25, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; 	* What is your evaluation of the proposal?<br></p><p>I am very much in favor overall, but I do have some minor quibbles.<br></p><p>Firstly, the list of places where you can use autounwrapping is kind of vague:<br></p><p>&gt; 	• property and variable declarations<br>&gt; 	• initializer declarations<br>&gt; 	• function and method declarations<br>&gt; 	• subscript declarations<br>&gt; 	• parameter declarations (with the exception of vararg parameters)<br></p><p><br>I assume that the &quot;function and method declarations&quot; and &quot;subscript declarations&quot; entries mean that you can mark their return values as autounwrapped. The separate &quot;parameter declarations&quot; entry means you can also mark initializer, function, method, and subscript parameters as autounwrapped. Is that correct, or do you mean something else?<br></p><p>If so, is the presence or absence of autounwrapping a part of the function&#39;s signature? Do closures derived from that function keep the same autounwrapping behavior? Can a closure be explicitly defined to have autounwrapped parameters or return values?<br></p><p>And if so, why aren&#39;t you allowed to make a `typealias` for a closure type which has autounwrapped properties or return values? I understand the rule against having a plain type in a `typealias`; many uses won&#39;t actually be able to apply the autounwrapping. But the same won&#39;t be true for closures.<br></p><p>Secondly, I continue to believe that the notional @_autounwrapped attribute should be an actual, utterable @autounwrapped attribute, for a couple of reasons.<br></p><p>The first reason is for teaching. (I don&#39;t do any formal teaching, but I&#39;m sort of the Swift expert in my local circle of programmers, and frequently give demos and explain things to people.) Complicated sugar benefits from having a simpler, clearer desugared form; it makes the various parts of the sugar&#39;s semantics much easier to explain. As an example, consider closure syntax. I never use the fully specified syntax for the closure signature before the `in` keyword *except* when teaching. In teaching contexts, though, it&#39;s really useful to be able to start with the full syntax and then strip elements of it away to demonstrate how Swift infers things.<br></p><p>Similarly, I think this feature will benefit immensely from allowing you to strip a `T!` declaration down into more atomic parts. The proposal itself itself benefited immensely from giving the semantic the name `@_autounwrapped`; every book, tutorial, and demo on Swift 3+ which takes on the `T!` syntax will similarly benefit from having a name for the thing. Particularly, I think it&#39;s valuable to be able to write both the sugared and desugared forms as executable playground code so users can see that they&#39;re equivalent.<br></p><p>The second reason I think `@autounwrapped` should be utterable is that I keep noticing places where you don&#39;t have an opportunity to change a regular optional to an autounwrapped one. I already discussed this case:<br></p><p>	@autounwrapped var y = x<br></p><p>But typealiases are another one:<br></p><p>	typealias Delegate = FooDelegate?<br>	@autounwrapped var delegate: Delegate<br></p><p>Admittedly, neither of these is extremely compelling, but we will only find more, and I worry that some of them might be more serious.<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes. ImplicitlyUnwrappedOptional has been a problem from the start. The autounwrapped approach is tremendously more rational.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes. Swift usually tries to reduce and contain magic; autounwrapped optionals fit those goals a lot better.<br></p><p>&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>N/A.<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>Read the proposal, participated pretty heavily in previous discussions.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>[Review] SE-0054: Abolish ImplicitlyUnwrappedOptional type</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>March 25, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; * What is your evaluation of the proposal?<br></p><p>I don&#39;t like that proposal as it stands currently.<br></p><p>By the way, I don&#39;t use any IUO in my code, except sometime for @IBOutlets. I do encounter them sometime with external APIs, but the way they work in Swift 2 isn&#39;t causing me any problem. They are also very easy to reason about being types like regular optionals using a very similar syntax.<br></p><p><br>&gt; * Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>It&#39;s hard to form a good opinion on the problem when there is no description of the problem.<br></p><p>The Motivation part of the proposal is basically a statement of intent:<br></p><p>• IUOs are a transitional technology<br>• we would like to limit their usage moving forward<br></p><p>Swift is expanding to Linux which has many unannotated APIs; so to me it seems the &quot;transition&quot; is still in progress, and will always be.<br></p><p>The same Motivation part says that IUOs are a valuable tool for importing external APIs and they are convenient in other places. There is not the slightest explanation of when or why they are inconvenient. There is surprisingly no mention of type propagation.<br></p><p><br>&gt; * Does this proposal fit well with the feel and direction of Swift?<br></p><p>I don&#39;t like the syntax. In the current Swift, `T!` being the implicitly-unwrapped variant of type `T?` is something that is easy to understand. They look similar and have similar propagation behaviors since the two are types, so they are predictable.<br></p><p>This proposal proposes to change it to a declaration attribute while keeping the same syntax. The resulting concept is a hybrid declaration attribute/type modifier that changes the type from `T` to `T?` and allows implicit unwrap. What you actually see when reading the code is a pseudo-IUO `T!` type that isn&#39;t really a type and transform to `T?` when it propagates. I find it a bit strange and unsettling: if it&#39;s not a type, it shouldn&#39;t look like one. And if the type is a regular optional, that should be the type visible in the declaration. Otherwise it&#39;s confusing.<br></p><p>So I can&#39;t see a justification for replacing IUOs with this hard to describe part-type/part-attribute thing. I&#39;m pretty sure we&#39;d just be trading one problem (unwanted IUO propagation) for another (hard to grasp semantics).<br></p><p> - - -<br></p><p>On a more general note, it seems to me that if the problem to solve is the silent propagation of IUOs, the compiler could simply require the propagation to be explicit by forcing the user to declare the type of every IUO variable:<br></p><p>	let x: Int! = nil<br>	let y = x       // error: must explicitly declare type Int!<br>	let z: Int! = x // ok<br></p><p>And that could work for generics too:<br></p><p>	let a = Array(x) // error: must explicitly declare type [Int!]<br>	let b: [Int!] = Array(x) // ok<br></p><p><br>&gt; * If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>N/A<br></p><p><br>&gt; * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I read the proposal and some mails on the list that lead to that proposal.<br></p><p><br>-- <br>Michel Fortin<br>https://michelf.ca<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5db80630abdbef749e968ed6efd7cfe9?s=50"></div><header><strong>[Review] SE-0054: Abolish ImplicitlyUnwrappedOptional type</strong> from <string>jazzbox)</string> &lt;jazzbox at 7zz.de (Bernd Ohr&gt;<p>March 26, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; * What is your evaluation of the proposal?<br></p><p>I don’t like the proposal.<br></p><p>&gt; * Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>I don&#39;t agree that IUOs are a transitional technology as long as there is an import of C libraries.<br></p><p>The only problem I see that IUO’s are being used where it is not necessary, either out of ignorance or convenience.<br></p><p>My counter proposal: IUO’s are only allowed (in pure Swift files) with private scope (filePrivate) and not with internal or public scope! In this way the uncontrolled spread of IUO’s can be most easily prevented.<br></p><p>An additional restriction could be that IUO’s are only allowed in files that import C or ObjC libraries.<br></p><p>&gt; * Does this proposal fit well with the feel and direction of Swift?<br></p><p>No, because it makes the use of IUO’s much harder (IMHO) where it is really necessary.<br></p><p>&gt; * If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>N/A<br></p><p>&gt; * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I read the proposal and had a look at some of my code that uses IUO’s<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0054: Abolish ImplicitlyUnwrappedOptional type</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>March 26, 2016 at 11:00:00am</p></header><div class="content"><p>* What is your evaluation of the proposal?<br>I think this is a positive step in the right direction but I think there still needs to be more amendments. So a +1 if address the issues I&#39;m about to outline.<br>Anything not annotated should be imported as an optional not a IUO, this makes it safer to handle the nil case with legacy code. <br>This is also truer to the intent of the original objective c code.<br>The proposal so far agrees with this, however there is one part I think could make clearer.<br>This:<br>Let x: Int! = 5Let y = x <br>It&#39;s not clear to me that y would be converted to an optional or that it would crash if it couldn&#39;t be type converted. This is a huge departure from the existing swift.<br>I think it would be better to have what I call Optional Type Confermence.<br>If I want y to be a Int! I can refer to x with a ! :<br>Let x:Int! = 5Let y = x!<br>That way if x is nil the app will trap and this provides a path for existing code to still use this behaviour plus it&#39;s now obvious that x will be treated like an unwrapped optional.<br>If you wanted x to be treated like an optional you would use ? <br>Let x: Int! = 5Let y = x?<br>This would make the behaviour the proposal is proposing much clearer.	* Is the problem being addressed significant enough to warrant a change to Swift?Although the proposal doesn&#39;t outline a problem, I do believe the optional system in swift today isn&#39;t safe enough. Indeed I released an app that crashed due to swift importing an unannotated piece of objective c code that wasn&#39;t clear about how it was an IUO and crashed.Anything that improves this visibility of IUOs and reduces the need of them I am for.<br>	* Does this proposal fit well with the feel and direction of Swift?This fits with Swift 3s simplification of the APIs	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?I don&#39;t have any experience in other languages.	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>In depth study.<br></p><p>More information about the Swift evolution process is available at<br></p><p>	https://github.com/apple/swift-evolution/blob/master/process.md<br></p><p>Thank you,<br></p><p>-Chris Lattner<br>Review Manager<br></p><p><br></p><p>_______________________________________________<br>swift-evolution-announce mailing list<br>swift-evolution-announce at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution-announce<br></p><p><br></p><p>  <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160326/ca1849fd/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05e222e6ef4d84013bb3baeb0e25c90b?s=50"></div><header><strong>[Review] SE-0054: Abolish ImplicitlyUnwrappedOptional type</strong> from <string>Patrick Gili</string> &lt;gili.patrick.r at gili-labs.com&gt;<p>March 26, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br></p><p>The IUO is not a transitional technology, as it is essential to bridge from languages from which Swift evolved, such as C and Objective-C. The proposal doesn&#39;t give much consideration to this application of IUOs, and hence, I cannot support the proposal in its current state.<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Grant it, the use of IUO outside of bridging is strange and probably a poor practice. However, there seems to exist a requirement and this proposal would make satisfying this requirement more difficult.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>No.<br></p><p>&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>Not applicable.<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>In-depth study.<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
