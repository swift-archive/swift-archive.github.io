<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>#available has a huge anti-pattern.</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>February  2, 2016 at 10:00:00am</p></header><div class="content"><p>Coming from a web background (before my iOS career) to me #avaliable has<br>huge problem. It encourages fragility.<br></p><p>In my eyes we should encourage two types of detection: Features to make<br>code more adaptable to different environments and language version<br>detection: so we can understand the actual code.<br></p><p>See this example below:<br></p><p>func magic(object: Object)<br>{<br>  if(#avaliable(9.0, 10))<br> {<br>  object.foo()<br> }<br>}<br></p><p>Ideally for me I would love to check if the foo function exists like so:<br></p><p>func iOS9OnlyProtocolFunction(object: Object)<br>{<br>  if(#avaliable(Object.foo))<br> {<br>    object.foo()<br> }<br>else<br>{<br>  object.baz()<br> }<br>}<br></p><p>I think this encourages feature detection which results in less fragile<br>code. What I would love to do is also to extend this to extensions so we<br>could encourage polyfills.<br></p><p>extend object where not_avaliable(Object.foo)<br>{<br>  func foo()<br> {<br>   //Polyfill for platforms which don&#39;t support the Object.foo method<br> }<br>}<br></p><p>Not sure about compiler details but being able to polyfill the function<br>results in much cleaner code for me. I love this approach from the web, so<br>I created my own Objective-C Library to do this:<br></p><p>https://github.com/jcampbell05/Polly<br></p><p>*___________________________________*<br></p><p>*James⎥Lead Engineer*<br></p><p>*james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com &lt;http://supmenow.com&gt;*<br></p><p>*Sup*<br></p><p>*Runway East *<br></p><p>*10 Finsbury Square*<br></p><p>*London*<br></p><p>* EC2A 1AF *<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160202/c90334f4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>#available has a huge anti-pattern.</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February  2, 2016 at 08:00:00am</p></header><div class="content"><p>Polyfills have their own tradeoffs; they tend to encourage constant accretion of glue code as new versions get added if there&#39;s no pressure to drop old versions, leading to a significant amount of the multi-megabyte Javascript framework downloads we all complain about these days. That said, you might be able to use the related `@available` attribute to introduce backfill extensions that are only available on older systems.<br></p><p>-Joe<br></p><p>&gt; On Feb 2, 2016, at 2:03 AM, James Campbell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Coming from a web background (before my iOS career) to me #avaliable has huge problem. It encourages fragility.<br>&gt; <br>&gt; In my eyes we should encourage two types of detection: Features to make code more adaptable to different environments and language version detection: so we can understand the actual code.<br>&gt; <br>&gt; See this example below:<br>&gt; <br>&gt; func magic(object: Object)<br>&gt; {<br>&gt;   if(#avaliable(9.0, 10))<br>&gt;  {<br>&gt;   object.foo()<br>&gt;  }<br>&gt; }<br>&gt; <br>&gt; Ideally for me I would love to check if the foo function exists like so:<br>&gt; <br>&gt; func iOS9OnlyProtocolFunction(object: Object)<br>&gt; {<br>&gt;   if(#avaliable(Object.foo))<br>&gt;  {<br>&gt;     object.foo()<br>&gt;  }<br>&gt; else <br>&gt; {<br>&gt;   object.baz()<br>&gt;  }<br>&gt; }<br>&gt; <br>&gt; I think this encourages feature detection which results in less fragile code. What I would love to do is also to extend this to extensions so we could encourage polyfills.<br>&gt; <br>&gt; extend object where not_avaliable(Object.foo) <br>&gt; {<br>&gt;   func foo() <br>&gt;  {<br>&gt;    //Polyfill for platforms which don&#39;t support the Object.foo method<br>&gt;  }<br>&gt; }<br>&gt; <br>&gt; Not sure about compiler details but being able to polyfill the function results in much cleaner code for me. I love this approach from the web, so I created my own Objective-C Library to do this:<br>&gt; <br>&gt; https://github.com/jcampbell05/Polly &lt;https://github.com/jcampbell05/Polly&gt;<br>&gt; ___________________________________<br>&gt; <br>&gt; James⎥Lead Engineer<br>&gt; <br>&gt; james at supmenow.com &lt;mailto:james at supmenow.com&gt;⎥supmenow.com &lt;http://supmenow.com/&gt;<br>&gt; Sup<br>&gt; <br>&gt; Runway East &gt; <br>&gt; <br>&gt; 10 Finsbury Square<br>&gt; <br>&gt; London<br>&gt; <br>&gt;  &gt; EC2A 1AF <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160202/15be316d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>#available has a huge anti-pattern.</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>February  2, 2016 at 06:00:00pm</p></header><div class="content"><p>Awesome :)<br></p><p>*___________________________________*<br></p><p>*James⎥Lead Engineer*<br></p><p>*james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com &lt;http://supmenow.com&gt;*<br></p><p>*Sup*<br></p><p>*Runway East *<br></p><p>*10 Finsbury Square*<br></p><p>*London*<br></p><p>* EC2A 1AF *<br></p><p>On Tue, Feb 2, 2016 at 4:26 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br></p><p>&gt; Polyfills have their own tradeoffs; they tend to encourage constant<br>&gt; accretion of glue code as new versions get added if there&#39;s no pressure to<br>&gt; drop old versions, leading to a significant amount of the multi-megabyte<br>&gt; Javascript framework downloads we all complain about these days. That said,<br>&gt; you might be able to use the related `@available` attribute to introduce<br>&gt; backfill extensions that are only available on older systems.<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt; On Feb 2, 2016, at 2:03 AM, James Campbell via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Coming from a web background (before my iOS career) to me #avaliable has<br>&gt; huge problem. It encourages fragility.<br>&gt;<br>&gt; In my eyes we should encourage two types of detection: Features to make<br>&gt; code more adaptable to different environments and language version<br>&gt; detection: so we can understand the actual code.<br>&gt;<br>&gt; See this example below:<br>&gt;<br>&gt; func magic(object: Object)<br>&gt; {<br>&gt;   if(#avaliable(9.0, 10))<br>&gt;  {<br>&gt;   object.foo()<br>&gt;  }<br>&gt; }<br>&gt;<br>&gt; Ideally for me I would love to check if the foo function exists like so:<br>&gt;<br>&gt; func iOS9OnlyProtocolFunction(object: Object)<br>&gt; {<br>&gt;   if(#avaliable(Object.foo))<br>&gt;  {<br>&gt;     object.foo()<br>&gt;  }<br>&gt; else<br>&gt; {<br>&gt;   object.baz()<br>&gt;  }<br>&gt; }<br>&gt;<br>&gt; I think this encourages feature detection which results in less fragile<br>&gt; code. What I would love to do is also to extend this to extensions so we<br>&gt; could encourage polyfills.<br>&gt;<br>&gt; extend object where not_avaliable(Object.foo)<br>&gt; {<br>&gt;   func foo()<br>&gt;  {<br>&gt;    //Polyfill for platforms which don&#39;t support the Object.foo method<br>&gt;  }<br>&gt; }<br>&gt;<br>&gt; Not sure about compiler details but being able to polyfill the function<br>&gt; results in much cleaner code for me. I love this approach from the web, so<br>&gt; I created my own Objective-C Library to do this:<br>&gt;<br>&gt; https://github.com/jcampbell05/Polly<br>&gt;<br>&gt; *___________________________________*<br>&gt;<br>&gt; *James⎥Lead Engineer*<br>&gt;<br>&gt; *james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com<br>&gt; &lt;http://supmenow.com/&gt;*<br>&gt;<br>&gt; *Sup*<br>&gt;<br>&gt; *Runway East *<br>&gt;<br>&gt; *10 Finsbury Square*<br>&gt;<br>&gt; *London*<br>&gt;<br>&gt; * EC2A 1AF *<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160202/f00f5b9a/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76eb9711d45c1c9a71c0f24004072a22?s=50"></div><header><strong>#available has a huge anti-pattern.</strong> from <string>Zach Waldowski</string> &lt;zach at waldowski.me&gt;<p>February  3, 2016 at 04:00:00pm</p></header><div class="content"><p>Joe —<br></p><p>Is this intended to be a supported behavior? I was all excited the other<br>day to discover this behavior, using it to backport iOS 9&#39;s<br>NSLayoutConstraint  DSL. It mostly works, but as soon as an expression<br>gets relatively complex (array literals &gt;5 or so) or has any sort of<br>error in it, Swift falls back to reporting an availability error.<br></p><p>Zach Waldowski zach at waldowski.me<br></p><p>On Tue, Feb 2, 2016, at 11:26 AM, Joe Groff via swift-evolution wrote:<br>&gt; Polyfills have their own tradeoffs; they tend to encourage constant<br>&gt; accretion of glue code as new versions get added if there&#39;s no<br>&gt; pressure to drop old versions, leading to a significant amount of the<br>&gt; multi-megabyte Javascript framework downloads we all complain about<br>&gt; these days. That said, you might be able to use the related<br>&gt; `@available` attribute to introduce backfill extensions that are only<br>&gt; available on older systems.<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt;&gt; On Feb 2, 2016, at 2:03 AM, James Campbell via swift-evolution &lt;swift-<br>&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Coming from a web background (before my iOS career) to me #avaliable<br>&gt;&gt; has huge problem. It encourages fragility.<br>&gt;&gt;<br>&gt;&gt; In my eyes we should encourage two types of detection: Features to<br>&gt;&gt; make code more adaptable to different environments and language<br>&gt;&gt; version detection: so we can understand the actual code.<br>&gt;&gt;<br>&gt;&gt; See this example below:<br>&gt;&gt;<br>&gt;&gt; func magic(object: Object) {  if(#avaliable(9.0, 10)) {<br>&gt;&gt; object.foo() } }<br>&gt;&gt;<br>&gt;&gt; Ideally for me I would love to check if the foo function exists<br>&gt;&gt; like so:<br>&gt;&gt;<br>&gt;&gt; func iOS9OnlyProtocolFunction(object: Object) {<br>&gt;&gt; if(#avaliable(Object.foo)) {    object.foo() } else {<br>&gt;&gt; object.baz() } }<br>&gt;&gt;<br>&gt;&gt; I think this encourages feature detection which results in less<br>&gt;&gt; fragile code. What I would love to do is also to extend this to<br>&gt;&gt; extensions so we could encourage polyfills.<br>&gt;&gt;<br>&gt;&gt; extend object where not_avaliable(Object.foo) {  func foo() {<br>&gt;&gt; //Polyfill for platforms which don&#39;t support the Object.foo<br>&gt;&gt; method } }<br>&gt;&gt;<br>&gt;&gt; Not sure about compiler details but being able to polyfill the<br>&gt;&gt; function results in much cleaner code for me. I love this approach<br>&gt;&gt; from the web, so I created my own Objective-C Library to do this:<br>&gt;&gt;<br>&gt;&gt; https://github.com/jcampbell05/Polly<br>&gt;&gt; *___________________________________*<br></p><p><br>&gt;&gt; *James⎥Lead Engineer*<br></p><p><br>&gt;&gt; *james at supmenow.com⎥supmenow.com[1]*<br></p><p><br>&gt;&gt; *Sup*<br></p><p><br>&gt;&gt; *Runway East *<br></p><p><br>&gt;&gt; *10 Finsbury Square*<br></p><p><br>&gt;&gt; *London*<br></p><p><br>&gt;&gt; * EC2A 1AF *<br></p><p><br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br></p><p>Links:<br></p><p>  1. http://supmenow.com/<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/6bbe5dc5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>#available has a huge anti-pattern.</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February  3, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Feb 3, 2016, at 1:20 PM, Zach Waldowski via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Joe —<br>&gt;  <br>&gt; Is this intended to be a supported behavior? I was all excited the other day to discover this behavior, using it to backport iOS 9&#39;s NSLayoutConstraint DSL. It mostly works, but as soon as an expression gets relatively complex (array literals &gt;5 or so) or has any sort of error in it, Swift falls back to reporting an availability error.<br></p><p>That sounds like a diagnostic bug. Got an example you can file in a bug report?<br></p><p>-Joe<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>#available has a huge anti-pattern.</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>February  4, 2016 at 04:00:00pm</p></header><div class="content"><p>How do you introduce backfill extensions only for older systems? I just tested this with<br></p><p>extension String {<br>    @available(iOS, obsoleted=9.0)<br>    func localizedStandardContainsString(str: String) -&gt; Bool {<br>        NSLog(&quot;calling %@&quot;, __FUNCTION__)<br>        return rangeOfString(str, options: [.CaseInsensitiveSearch, .DiacriticInsensitiveSearch], locale: NSLocale.currentLocale()) != nil<br>    }<br>}<br></p><p>but despite the `obsoleted=9.0`, my implementation here is in fact invoked from the code `&quot;foobarbaz&quot;.localizedStandardContainsString(&quot;bar&quot;)` when running in the iOS 9.2 Simulator.<br></p><p>This behavior isn&#39;t really all that surprising, but since there&#39;s no way within that method to explicitly invoke the &quot;real&quot; method (since I&#39;ve shadowed it so there&#39;s no way to refer to the framework-provided one), I can&#39;t even introduce my own #available() check within the method.<br></p><p>What you can do is introduce a different API that uses #available() to call the real API or fall back to a compatibility implementation, but I wouldn&#39;t call that a &quot;backfill&quot; since it&#39;s a different API.<br></p><p>-Kevin Ballard<br></p><p>On Tue, Feb 2, 2016, at 08:26 AM, Joe Groff via swift-evolution wrote:<br>&gt; Polyfills have their own tradeoffs; they tend to encourage constant accretion of glue code as new versions get added if there&#39;s no pressure to drop old versions, leading to a significant amount of the multi-megabyte Javascript framework downloads we all complain about these days. That said, you might be able to use the related `@available` attribute to introduce backfill extensions that are only available on older systems.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; On Feb 2, 2016, at 2:03 AM, James Campbell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Coming from a web background (before my iOS career) to me #avaliable has huge problem. It encourages fragility.<br>&gt;&gt; <br>&gt;&gt; In my eyes we should encourage two types of detection: Features to make code more adaptable to different environments and language version detection: so we can understand the actual code.<br>&gt;&gt; <br>&gt;&gt; See this example below:<br>&gt;&gt; <br>&gt;&gt; func magic(object: Object)<br>&gt;&gt; {<br>&gt;&gt;   if(#avaliable(9.0, 10))<br>&gt;&gt;  {<br>&gt;&gt;   object.foo()<br>&gt;&gt;  }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Ideally for me I would love to check if the foo function exists like so:<br>&gt;&gt; <br>&gt;&gt; func iOS9OnlyProtocolFunction(object: Object)<br>&gt;&gt; {<br>&gt;&gt;   if(#avaliable(Object.foo))<br>&gt;&gt;  {<br>&gt;&gt;     object.foo()<br>&gt;&gt;  }<br>&gt;&gt; else <br>&gt;&gt; {<br>&gt;&gt;   object.baz()<br>&gt;&gt;  }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I think this encourages feature detection which results in less fragile code. What I would love to do is also to extend this to extensions so we could encourage polyfills.<br>&gt;&gt; <br>&gt;&gt; extend object where not_avaliable(Object.foo) <br>&gt;&gt; {<br>&gt;&gt;   func foo() <br>&gt;&gt;  {<br>&gt;&gt;    //Polyfill for platforms which don&#39;t support the Object.foo method<br>&gt;&gt;  }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Not sure about compiler details but being able to polyfill the function results in much cleaner code for me. I love this approach from the web, so I created my own Objective-C Library to do this:<br>&gt;&gt; <br>&gt;&gt; https://github.com/jcampbell05/Polly<br>&gt;&gt; *___________________________________*<br></p><p><br>&gt;&gt; *James⎥Lead Engineer*<br></p><p><br>&gt;&gt; *james at supmenow.com⎥supmenow.com*<br></p><p><br>&gt;&gt; *Sup*<br></p><p><br>&gt;&gt; *Runway East *<br></p><p><br>&gt;&gt; *10 Finsbury Square*<br></p><p><br>&gt;&gt; *London*<br></p><p><br>&gt;&gt; * EC2A 1AF *<br></p><p><br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>#available has a huge anti-pattern.</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>February  4, 2016 at 08:00:00pm</p></header><div class="content"><p>I’m not sure you could backfill extensions in all cases anyway, as those selectors may be on the particular objc objects as private API.<br></p><p>-DW<br></p><p>&gt; On Feb 4, 2016, at 5:55 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; How do you introduce backfill extensions only for older systems? I just tested this with<br>&gt; <br>&gt; extension String {<br>&gt;    @available(iOS, obsoleted=9.0)<br>&gt;    func localizedStandardContainsString(str: String) -&gt; Bool {<br>&gt;        NSLog(&quot;calling %@&quot;, __FUNCTION__)<br>&gt;        return rangeOfString(str, options: [.CaseInsensitiveSearch, .DiacriticInsensitiveSearch], locale: NSLocale.currentLocale()) != nil<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; but despite the `obsoleted=9.0`, my implementation here is in fact invoked from the code `&quot;foobarbaz&quot;.localizedStandardContainsString(&quot;bar&quot;)` when running in the iOS 9.2 Simulator.<br>&gt; <br>&gt; This behavior isn&#39;t really all that surprising, but since there&#39;s no way within that method to explicitly invoke the &quot;real&quot; method (since I&#39;ve shadowed it so there&#39;s no way to refer to the framework-provided one), I can&#39;t even introduce my own #available() check within the method.<br>&gt; <br>&gt; What you can do is introduce a different API that uses #available() to call the real API or fall back to a compatibility implementation, but I wouldn&#39;t call that a &quot;backfill&quot; since it&#39;s a different API.<br>&gt; <br>&gt; -Kevin Ballard<br>&gt; <br>&gt; On Tue, Feb 2, 2016, at 08:26 AM, Joe Groff via swift-evolution wrote:<br>&gt;&gt; Polyfills have their own tradeoffs; they tend to encourage constant accretion of glue code as new versions get added if there&#39;s no pressure to drop old versions, leading to a significant amount of the multi-megabyte Javascript framework downloads we all complain about these days. That said, you might be able to use the related `@available` attribute to introduce backfill extensions that are only available on older systems.<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 2, 2016, at 2:03 AM, James Campbell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Coming from a web background (before my iOS career) to me #avaliable has huge problem. It encourages fragility.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In my eyes we should encourage two types of detection: Features to make code more adaptable to different environments and language version detection: so we can understand the actual code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; See this example below:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func magic(object: Object)<br>&gt;&gt;&gt; {<br>&gt;&gt;&gt;   if(#avaliable(9.0, 10))<br>&gt;&gt;&gt;  {<br>&gt;&gt;&gt;   object.foo()<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Ideally for me I would love to check if the foo function exists like so:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func iOS9OnlyProtocolFunction(object: Object)<br>&gt;&gt;&gt; {<br>&gt;&gt;&gt;   if(#avaliable(Object.foo))<br>&gt;&gt;&gt;  {<br>&gt;&gt;&gt;     object.foo()<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; else<br>&gt;&gt;&gt; {<br>&gt;&gt;&gt;   object.baz()<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think this encourages feature detection which results in less fragile code. What I would love to do is also to extend this to extensions so we could encourage polyfills.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extend object where not_avaliable(Object.foo)<br>&gt;&gt;&gt; {<br>&gt;&gt;&gt;   func foo()<br>&gt;&gt;&gt;  {<br>&gt;&gt;&gt;    //Polyfill for platforms which don&#39;t support the Object.foo method<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Not sure about compiler details but being able to polyfill the function results in much cleaner code for me. I love this approach from the web, so I created my own Objective-C Library to do this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/jcampbell05/Polly<br>&gt;&gt;&gt; *___________________________________*<br>&gt; <br>&gt; <br>&gt;&gt;&gt; *James⎥Lead Engineer*<br>&gt; <br>&gt; <br>&gt;&gt;&gt; *james at supmenow.com⎥supmenow.com*<br>&gt; <br>&gt; <br>&gt;&gt;&gt; *Sup*<br>&gt; <br>&gt; <br>&gt;&gt;&gt; *Runway East<br>&gt; *<br>&gt; <br>&gt; <br>&gt;&gt;&gt; *10 Finsbury Square*<br>&gt; <br>&gt; <br>&gt;&gt;&gt; *London*<br>&gt; <br>&gt; <br>&gt;&gt;&gt; *<br>&gt; EC2A 1AF *<br>&gt; <br>&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _________________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 496 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160204/fa426847/attachment.sig&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/73a38bb7bc9528e31098defe30e68ea4?s=50"></div><header><strong>#available has a huge anti-pattern.</strong> from <string>Jean-Daniel Dupas</string> &lt;mailing at xenonium.com&gt;<p>February  5, 2016 at 08:00:00am</p></header><div class="content"><p>I think you can workaround the private selector issue by using the compiler knowledge of the availability version.<br></p><p>The compiler can mangle the polyfill symbol differently (even if it is a selector), and perform a version check at call site.<br></p><p><br>&gt; Le 5 févr. 2016 à 04:06, David Waite via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; I’m not sure you could backfill extensions in all cases anyway, as those selectors may be on the particular objc objects as private API.<br>&gt; <br>&gt; -DW<br>&gt; <br>&gt;&gt; On Feb 4, 2016, at 5:55 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; How do you introduce backfill extensions only for older systems? I just tested this with<br>&gt;&gt; <br>&gt;&gt; extension String {<br>&gt;&gt;   @available(iOS, obsoleted=9.0)<br>&gt;&gt;   func localizedStandardContainsString(str: String) -&gt; Bool {<br>&gt;&gt;       NSLog(&quot;calling %@&quot;, __FUNCTION__)<br>&gt;&gt;       return rangeOfString(str, options: [.CaseInsensitiveSearch, .DiacriticInsensitiveSearch], locale: NSLocale.currentLocale()) != nil<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; but despite the `obsoleted=9.0`, my implementation here is in fact invoked from the code `&quot;foobarbaz&quot;.localizedStandardContainsString(&quot;bar&quot;)` when running in the iOS 9.2 Simulator.<br>&gt;&gt; <br>&gt;&gt; This behavior isn&#39;t really all that surprising, but since there&#39;s no way within that method to explicitly invoke the &quot;real&quot; method (since I&#39;ve shadowed it so there&#39;s no way to refer to the framework-provided one), I can&#39;t even introduce my own #available() check within the method.<br>&gt;&gt; <br>&gt;&gt; What you can do is introduce a different API that uses #available() to call the real API or fall back to a compatibility implementation, but I wouldn&#39;t call that a &quot;backfill&quot; since it&#39;s a different API.<br>&gt;&gt; <br>&gt;&gt; -Kevin Ballard<br>&gt;&gt; <br>&gt;&gt; On Tue, Feb 2, 2016, at 08:26 AM, Joe Groff via swift-evolution wrote:<br>&gt;&gt;&gt; Polyfills have their own tradeoffs; they tend to encourage constant accretion of glue code as new versions get added if there&#39;s no pressure to drop old versions, leading to a significant amount of the multi-megabyte Javascript framework downloads we all complain about these days. That said, you might be able to use the related `@available` attribute to introduce backfill extensions that are only available on older systems.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 2, 2016, at 2:03 AM, James Campbell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Coming from a web background (before my iOS career) to me #avaliable has huge problem. It encourages fragility.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In my eyes we should encourage two types of detection: Features to make code more adaptable to different environments and language version detection: so we can understand the actual code.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; See this example below:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func magic(object: Object)<br>&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;  if(#avaliable(9.0, 10))<br>&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;  object.foo()<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Ideally for me I would love to check if the foo function exists like so:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func iOS9OnlyProtocolFunction(object: Object)<br>&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;  if(#avaliable(Object.foo))<br>&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;    object.foo()<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; else<br>&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;  object.baz()<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think this encourages feature detection which results in less fragile code. What I would love to do is also to extend this to extensions so we could encourage polyfills.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extend object where not_avaliable(Object.foo)<br>&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;  func foo()<br>&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;   //Polyfill for platforms which don&#39;t support the Object.foo method<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Not sure about compiler details but being able to polyfill the function results in much cleaner code for me. I love this approach from the web, so I created my own Objective-C Library to do this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://github.com/jcampbell05/Polly<br>&gt;&gt;&gt;&gt; *___________________________________*<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; *James⎥Lead Engineer*<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; *james at supmenow.com⎥supmenow.com*<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; *Sup*<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; *Runway East<br>&gt;&gt; *<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; *10 Finsbury Square*<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; *London*<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; *<br>&gt;&gt; EC2A 1AF *<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; _________________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/73a38bb7bc9528e31098defe30e68ea4?s=50"></div><header><strong>#available has a huge anti-pattern.</strong> from <string>Jean-Daniel Dupas</string> &lt;mailing at xenonium.com&gt;<p>February  3, 2016 at 02:00:00pm</p></header><div class="content"><p>Using function availability has proven fragile in the past too. A function may be present but private on older system, and have a slightly different behavior or crash, and so should not be used.<br></p><p><br>&gt; Le 2 févr. 2016 à 11:03, James Campbell via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Coming from a web background (before my iOS career) to me #avaliable has huge problem. It encourages fragility.<br>&gt; <br>&gt; In my eyes we should encourage two types of detection: Features to make code more adaptable to different environments and language version detection: so we can understand the actual code.<br>&gt; <br>&gt; See this example below:<br>&gt; <br>&gt; func magic(object: Object)<br>&gt; {<br>&gt;   if(#avaliable(9.0, 10))<br>&gt;  {<br>&gt;   object.foo()<br>&gt;  }<br>&gt; }<br>&gt; <br>&gt; Ideally for me I would love to check if the foo function exists like so:<br>&gt; <br>&gt; func iOS9OnlyProtocolFunction(object: Object)<br>&gt; {<br>&gt;   if(#avaliable(Object.foo))<br>&gt;  {<br>&gt;     object.foo()<br>&gt;  }<br>&gt; else <br>&gt; {<br>&gt;   object.baz()<br>&gt;  }<br>&gt; }<br>&gt; <br>&gt; I think this encourages feature detection which results in less fragile code. What I would love to do is also to extend this to extensions so we could encourage polyfills.<br>&gt; <br>&gt; extend object where not_avaliable(Object.foo) <br>&gt; {<br>&gt;   func foo() <br>&gt;  {<br>&gt;    //Polyfill for platforms which don&#39;t support the Object.foo method<br>&gt;  }<br>&gt; }<br>&gt; <br>&gt; Not sure about compiler details but being able to polyfill the function results in much cleaner code for me. I love this approach from the web, so I created my own Objective-C Library to do this:<br>&gt; <br>&gt; https://github.com/jcampbell05/Polly &lt;https://github.com/jcampbell05/Polly&gt;<br>&gt; ___________________________________<br>&gt; <br>&gt; James⎥Lead Engineer<br>&gt; <br>&gt; james at supmenow.com &lt;mailto:james at supmenow.com&gt;⎥supmenow.com &lt;http://supmenow.com/&gt;<br>&gt; Sup<br>&gt; <br>&gt; Runway East &gt; <br>&gt; <br>&gt; 10 Finsbury Square<br>&gt; <br>&gt; London<br>&gt; <br>&gt;  &gt; EC2A 1AF <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/a4944cb1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>#available has a huge anti-pattern.</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>February  3, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Feb 3, 2016, at 5:10 AM, Jean-Daniel Dupas via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Using function availability has proven fragile in the past too. A function may be present but private on older system, and have a slightly different behavior or crash, and so should not be used.<br></p><p>This is a failing of the -respondsToSelector: idiom for checking availability. Swift’s #available feature checks the actual OS version, so it doesn’t suffer from this problem.<br></p><p>	- Doug<br></p><p>&gt; <br>&gt; <br>&gt;&gt; Le 2 févr. 2016 à 11:03, James Campbell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; Coming from a web background (before my iOS career) to me #avaliable has huge problem. It encourages fragility.<br>&gt;&gt; <br>&gt;&gt; In my eyes we should encourage two types of detection: Features to make code more adaptable to different environments and language version detection: so we can understand the actual code.<br>&gt;&gt; <br>&gt;&gt; See this example below:<br>&gt;&gt; <br>&gt;&gt; func magic(object: Object)<br>&gt;&gt; {<br>&gt;&gt;   if(#avaliable(9.0, 10))<br>&gt;&gt;  {<br>&gt;&gt;   object.foo()<br>&gt;&gt;  }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Ideally for me I would love to check if the foo function exists like so:<br>&gt;&gt; <br>&gt;&gt; func iOS9OnlyProtocolFunction(object: Object)<br>&gt;&gt; {<br>&gt;&gt;   if(#avaliable(Object.foo))<br>&gt;&gt;  {<br>&gt;&gt;     object.foo()<br>&gt;&gt;  }<br>&gt;&gt; else <br>&gt;&gt; {<br>&gt;&gt;   object.baz()<br>&gt;&gt;  }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I think this encourages feature detection which results in less fragile code. What I would love to do is also to extend this to extensions so we could encourage polyfills.<br>&gt;&gt; <br>&gt;&gt; extend object where not_avaliable(Object.foo) <br>&gt;&gt; {<br>&gt;&gt;   func foo() <br>&gt;&gt;  {<br>&gt;&gt;    //Polyfill for platforms which don&#39;t support the Object.foo method<br>&gt;&gt;  }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Not sure about compiler details but being able to polyfill the function results in much cleaner code for me. I love this approach from the web, so I created my own Objective-C Library to do this:<br>&gt;&gt; <br>&gt;&gt; https://github.com/jcampbell05/Polly &lt;https://github.com/jcampbell05/Polly&gt;<br>&gt;&gt; ___________________________________<br>&gt;&gt; <br>&gt;&gt; James⎥Lead Engineer<br>&gt;&gt; <br>&gt;&gt; james at supmenow.com &lt;mailto:james at supmenow.com&gt;⎥supmenow.com &lt;http://supmenow.com/&gt;<br>&gt;&gt; Sup<br>&gt;&gt; <br>&gt;&gt; Runway East &gt;&gt; <br>&gt;&gt; <br>&gt;&gt; 10 Finsbury Square<br>&gt;&gt; <br>&gt;&gt; London<br>&gt;&gt; <br>&gt;&gt;  &gt;&gt; EC2A 1AF <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/9caf3f75/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>#available has a huge anti-pattern.</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>February  3, 2016 at 04:00:00pm</p></header><div class="content"><p>Won&#39;t it be a concern with a cross-platform Swift?<br></p><p>Félix<br></p><p>&gt; Le 3 févr. 2016 à 15:47:15, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Feb 3, 2016, at 5:10 AM, Jean-Daniel Dupas via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Using function availability has proven fragile in the past too. A function may be present but private on older system, and have a slightly different behavior or crash, and so should not be used.<br>&gt; <br>&gt; This is a failing of the -respondsToSelector: idiom for checking availability. Swift’s #available feature checks the actual OS version, so it doesn’t suffer from this problem.<br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Le 2 févr. 2016 à 11:03, James Campbell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Coming from a web background (before my iOS career) to me #avaliable has huge problem. It encourages fragility.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In my eyes we should encourage two types of detection: Features to make code more adaptable to different environments and language version detection: so we can understand the actual code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; See this example below:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func magic(object: Object)<br>&gt;&gt;&gt; {<br>&gt;&gt;&gt;   if(#avaliable(9.0, 10))<br>&gt;&gt;&gt;  {<br>&gt;&gt;&gt;   object.foo()<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Ideally for me I would love to check if the foo function exists like so:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func iOS9OnlyProtocolFunction(object: Object)<br>&gt;&gt;&gt; {<br>&gt;&gt;&gt;   if(#avaliable(Object.foo))<br>&gt;&gt;&gt;  {<br>&gt;&gt;&gt;     object.foo()<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; else <br>&gt;&gt;&gt; {<br>&gt;&gt;&gt;   object.baz()<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think this encourages feature detection which results in less fragile code. What I would love to do is also to extend this to extensions so we could encourage polyfills.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extend object where not_avaliable(Object.foo) <br>&gt;&gt;&gt; {<br>&gt;&gt;&gt;   func foo() <br>&gt;&gt;&gt;  {<br>&gt;&gt;&gt;    //Polyfill for platforms which don&#39;t support the Object.foo method<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Not sure about compiler details but being able to polyfill the function results in much cleaner code for me. I love this approach from the web, so I created my own Objective-C Library to do this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/jcampbell05/Polly &lt;https://github.com/jcampbell05/Polly&gt;<br>&gt;&gt;&gt; ___________________________________<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; James⎥Lead Engineer<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; james at supmenow.com &lt;mailto:james at supmenow.com&gt;⎥supmenow.com &lt;http://supmenow.com/&gt;<br>&gt;&gt;&gt; Sup<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Runway East &gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 10 Finsbury Square<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; London<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &gt;&gt;&gt; EC2A 1AF <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/75569d6f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>#available has a huge anti-pattern.</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>February  3, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Feb 3, 2016, at 1:02 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt; <br>&gt; Won&#39;t it be a concern with a cross-platform Swift?<br></p><p>#available is currently only implemented for Apple platforms. If someone wants to extend it to another platform, they need to do so in a manner that gives it consistent semantics.<br></p><p>	- Doug<br></p><p>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 3 févr. 2016 à 15:47:15, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Feb 3, 2016, at 5:10 AM, Jean-Daniel Dupas via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Using function availability has proven fragile in the past too. A function may be present but private on older system, and have a slightly different behavior or crash, and so should not be used.<br>&gt;&gt; <br>&gt;&gt; This is a failing of the -respondsToSelector: idiom for checking availability. Swift’s #available feature checks the actual OS version, so it doesn’t suffer from this problem.<br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Le 2 févr. 2016 à 11:03, James Campbell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Coming from a web background (before my iOS career) to me #avaliable has huge problem. It encourages fragility.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In my eyes we should encourage two types of detection: Features to make code more adaptable to different environments and language version detection: so we can understand the actual code.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; See this example below:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func magic(object: Object)<br>&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;   if(#avaliable(9.0, 10))<br>&gt;&gt;&gt;&gt;  {<br>&gt;&gt;&gt;&gt;   object.foo()<br>&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Ideally for me I would love to check if the foo function exists like so:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func iOS9OnlyProtocolFunction(object: Object)<br>&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;   if(#avaliable(Object.foo))<br>&gt;&gt;&gt;&gt;  {<br>&gt;&gt;&gt;&gt;     object.foo()<br>&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt; else <br>&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;   object.baz()<br>&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think this encourages feature detection which results in less fragile code. What I would love to do is also to extend this to extensions so we could encourage polyfills.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extend object where not_avaliable(Object.foo) <br>&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;   func foo() <br>&gt;&gt;&gt;&gt;  {<br>&gt;&gt;&gt;&gt;    //Polyfill for platforms which don&#39;t support the Object.foo method<br>&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Not sure about compiler details but being able to polyfill the function results in much cleaner code for me. I love this approach from the web, so I created my own Objective-C Library to do this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://github.com/jcampbell05/Polly &lt;https://github.com/jcampbell05/Polly&gt;<br>&gt;&gt;&gt;&gt; ___________________________________<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; James⎥Lead Engineer<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; james at supmenow.com &lt;mailto:james at supmenow.com&gt;⎥supmenow.com &lt;http://supmenow.com/&gt;<br>&gt;&gt;&gt;&gt; Sup<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Runway East &gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 10 Finsbury Square<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; London<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  &gt;&gt;&gt;&gt; EC2A 1AF <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/ad8779e6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>#available has a huge anti-pattern.</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>February  3, 2016 at 09:00:00pm</p></header><div class="content"><p>I think if we did feature detection it should ignore private methods not<br>accessible by the code querying its accesbility. Additionally we really do<br>need proper support across platforms.<br></p><p>*___________________________________*<br></p><p>*James⎥Lead Engineer*<br></p><p>*james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com &lt;http://supmenow.com&gt;*<br></p><p>*Sup*<br></p><p>*Runway East *<br></p><p>*10 Finsbury Square*<br></p><p>*London*<br></p><p>* EC2A 1AF *<br></p><p>On Wed, Feb 3, 2016 at 9:03 PM, Douglas Gregor via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Feb 3, 2016, at 1:02 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt;<br>&gt; Won&#39;t it be a concern with a cross-platform Swift?<br>&gt;<br>&gt;<br>&gt; #available is currently only implemented for Apple platforms. If someone<br>&gt; wants to extend it to another platform, they need to do so in a manner that<br>&gt; gives it consistent semantics.<br>&gt;<br>&gt; - Doug<br>&gt;<br>&gt;<br>&gt; Félix<br>&gt;<br>&gt; Le 3 févr. 2016 à 15:47:15, Douglas Gregor via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;<br>&gt;<br>&gt; On Feb 3, 2016, at 5:10 AM, Jean-Daniel Dupas via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Using function availability has proven fragile in the past too. A function<br>&gt; may be present but private on older system, and have a slightly different<br>&gt; behavior or crash, and so should not be used.<br>&gt;<br>&gt;<br>&gt; This is a failing of the -respondsToSelector: idiom for checking<br>&gt; availability. Swift’s #available feature checks the actual OS version, so<br>&gt; it doesn’t suffer from this problem.<br>&gt;<br>&gt; - Doug<br>&gt;<br>&gt;<br>&gt;<br>&gt; Le 2 févr. 2016 à 11:03, James Campbell via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;<br>&gt; Coming from a web background (before my iOS career) to me #avaliable has<br>&gt; huge problem. It encourages fragility.<br>&gt;<br>&gt; In my eyes we should encourage two types of detection: Features to make<br>&gt; code more adaptable to different environments and language version<br>&gt; detection: so we can understand the actual code.<br>&gt;<br>&gt; See this example below:<br>&gt;<br>&gt; func magic(object: Object)<br>&gt; {<br>&gt;   if(#avaliable(9.0, 10))<br>&gt;  {<br>&gt;   object.foo()<br>&gt;  }<br>&gt; }<br>&gt;<br>&gt; Ideally for me I would love to check if the foo function exists like so:<br>&gt;<br>&gt; func iOS9OnlyProtocolFunction(object: Object)<br>&gt; {<br>&gt;   if(#avaliable(Object.foo))<br>&gt;  {<br>&gt;     object.foo()<br>&gt;  }<br>&gt; else<br>&gt; {<br>&gt;   object.baz()<br>&gt;  }<br>&gt; }<br>&gt;<br>&gt; I think this encourages feature detection which results in less fragile<br>&gt; code. What I would love to do is also to extend this to extensions so we<br>&gt; could encourage polyfills.<br>&gt;<br>&gt; extend object where not_avaliable(Object.foo)<br>&gt; {<br>&gt;   func foo()<br>&gt;  {<br>&gt;    //Polyfill for platforms which don&#39;t support the Object.foo method<br>&gt;  }<br>&gt; }<br>&gt;<br>&gt; Not sure about compiler details but being able to polyfill the function<br>&gt; results in much cleaner code for me. I love this approach from the web, so<br>&gt; I created my own Objective-C Library to do this:<br>&gt;<br>&gt; https://github.com/jcampbell05/Polly<br>&gt;<br>&gt; *___________________________________*<br>&gt;<br>&gt; *James⎥Lead Engineer*<br>&gt;<br>&gt; *james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com<br>&gt; &lt;http://supmenow.com/&gt;*<br>&gt;<br>&gt; *Sup*<br>&gt;<br>&gt; *Runway East *<br>&gt;<br>&gt; *10 Finsbury Square*<br>&gt;<br>&gt; *London*<br>&gt;<br>&gt; * EC2A 1AF *<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/93b69441/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>#available has a huge anti-pattern.</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>February  3, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Feb 3, 2016, at 3:07 PM, James Campbell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I think if we did feature detection it should ignore private methods not accessible by the code querying its accesbility. Additionally we really do need proper support across platforms.<br></p><p>How is that going to work, though? Most of the system APIs are in Objective-C, which has no distinction between private and public methods at runtime.<br></p><p>I think #available is fine as-is, especially since the compiler is able to detect if you’re using an API that’s not appropriate for the OS X version you’re specifying.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/428aeee6/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>#available has a huge anti-pattern.</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>February  3, 2016 at 04:00:00pm</p></header><div class="content"><p>But isn&#39;t it exactly across platforms that feature detection is the most important?<br></p><p>Félix<br></p><p>&gt; Le 3 févr. 2016 à 16:03:28, Douglas Gregor &lt;dgregor at apple.com&gt; a écrit :<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 3, 2016, at 1:02 PM, Félix Cloutier &lt;felixcca at yahoo.ca &lt;mailto:felixcca at yahoo.ca&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Won&#39;t it be a concern with a cross-platform Swift?<br>&gt; <br>&gt; #available is currently only implemented for Apple platforms. If someone wants to extend it to another platform, they need to do so in a manner that gives it consistent semantics.<br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Félix<br>&gt;&gt; <br>&gt;&gt;&gt; Le 3 févr. 2016 à 15:47:15, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 3, 2016, at 5:10 AM, Jean-Daniel Dupas via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Using function availability has proven fragile in the past too. A function may be present but private on older system, and have a slightly different behavior or crash, and so should not be used.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a failing of the -respondsToSelector: idiom for checking availability. Swift’s #available feature checks the actual OS version, so it doesn’t suffer from this problem.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Le 2 févr. 2016 à 11:03, James Campbell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Coming from a web background (before my iOS career) to me #avaliable has huge problem. It encourages fragility.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In my eyes we should encourage two types of detection: Features to make code more adaptable to different environments and language version detection: so we can understand the actual code.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; See this example below:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func magic(object: Object)<br>&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;   if(#avaliable(9.0, 10))<br>&gt;&gt;&gt;&gt;&gt;  {<br>&gt;&gt;&gt;&gt;&gt;   object.foo()<br>&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Ideally for me I would love to check if the foo function exists like so:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func iOS9OnlyProtocolFunction(object: Object)<br>&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;   if(#avaliable(Object.foo))<br>&gt;&gt;&gt;&gt;&gt;  {<br>&gt;&gt;&gt;&gt;&gt;     object.foo()<br>&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt; else <br>&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;   object.baz()<br>&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think this encourages feature detection which results in less fragile code. What I would love to do is also to extend this to extensions so we could encourage polyfills.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; extend object where not_avaliable(Object.foo) <br>&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;   func foo() <br>&gt;&gt;&gt;&gt;&gt;  {<br>&gt;&gt;&gt;&gt;&gt;    //Polyfill for platforms which don&#39;t support the Object.foo method<br>&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Not sure about compiler details but being able to polyfill the function results in much cleaner code for me. I love this approach from the web, so I created my own Objective-C Library to do this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; https://github.com/jcampbell05/Polly &lt;https://github.com/jcampbell05/Polly&gt;<br>&gt;&gt;&gt;&gt;&gt; ___________________________________<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; James⎥Lead Engineer<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; james at supmenow.com &lt;mailto:james at supmenow.com&gt;⎥supmenow.com &lt;http://supmenow.com/&gt;<br>&gt;&gt;&gt;&gt;&gt; Sup<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Runway East &gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 10 Finsbury Square<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; London<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  &gt;&gt;&gt;&gt;&gt; EC2A 1AF <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/8baecc17/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e5c8f8a0f3a55288779498396d6f4a04?s=50"></div><header><strong>#available has a huge anti-pattern.</strong> from <string>Devin Coughlin</string> &lt;dcoughlin at apple.com&gt;<p>February  4, 2016 at 01:00:00pm</p></header><div class="content"><p>James,<br></p><p>We did consider an availability model with feature detection similar to the one you proposed. This is essentially the model that Objective-C has. We’ve found that there are significant drawbacks to that model and believe that version checks + compile-time checking offer a better user experience.<br></p><p>* Compile-time checking of availability makes version checking less fragile.<br></p><p>A key component of Swift’s availability model is that — unlike in Objective-C or JavaScript — any use of an API element is verified for availability by the compiler. This eliminates the main source of fragility in the version checking model: getting a version check wrong and calling the API anyway. The compiler makes the strong guarantee that it will detect this and inform the developer that they have made a mistake.<br></p><p><br>* Feature detection checks are hard to reason about and test.<br></p><p>With version checks it is is immediately obvious on what environment the code will execute. This makes it easy to reason about, for example, how to test the given class/method/branch. In contrast, with feature detection even determining when a given branch of an availability check will execute requires a trip to the documentation. A polyfill model would make this even more challenging because the feature could be available earlier than the documentation states!<br></p><p><br>* SPI and direct feature detection. <br></p><p>Apple sometimes adds features first as SPI and only later makes them available as API, potentially changing behavior when doing so. This means that a naive check for the presence of, say, a class or method, does not necessarily make it safe to call. For example, Apple added UINib as API in iOS 4, but earlier versions used an incompatible class with the same name. In this case, the Objective-C idiom checking for the feature effectively “lied” about UINib’s availability. When it comes to API, the run-time checks for #available need to allow symbols to be present but still not considered available. Version checks (either OS versions or library versions) are one mechanism to do this.<br></p><p><br>* Dead check detection<br></p><p>One nice aspect of version checks is that it gives the compiler the ability to detect availability checks that are no longer needed because the application is being deployed only on versions of the OS on which the check would always succeed. This is not possible with a direct feature detection model alone (it still needs APIs to be annotated with their versions) and would help prevent older codebases from being littered with feature checks falling back to effectively dead code that no one knows whether it is safe to remove or not.<br></p><p><br>* Overloading makes it verbose to check for a feature.<br></p><p>Swift’s support for function and method overloads makes it quite verbose to check for existence of a feature. Unambiguously identifying a method in a #available check would require specifying its parameter types and even constraints on generic type parameters.<br></p><p><br>* Features are often correlated.<br></p><p>In Objective-C codebases we find that developers often make implicit assumption about OS versions even when using direct feature checks. For example, a developer will often check for the existence of one method and then perform an unguarded use of another method that was introduced in the same version. With a direct feature detection model, the developer would have to check for each of these features separately — even though they know they were introduced in the same OS version! The fact that Objective-C developers are already skipping checks for correlated features shows that their mental model is already based on versions, so it makes sense to match that model in the affordances exposed by the language.<br></p><p><br>All that said, polyfill is a widely used technique and it would be interesting to see what it would take to *safely* integrate into Swift. In my view, the two key challenges there are (1) compatibility (whose polyfill wins when two libraries try to polyfill the same thing?) and (2) how to make assume-guarantee @available() annotations with polyfill/feature detection safe at compile time and efficient without leaking implementation details to clients (we don’t want every function to have to list all the functions it calls [and all the functions they call, etc.] in its @available() annotation!).<br></p><p><br>Devin<br></p><p><br></p><p>&gt; On Feb 2, 2016, at 2:03 AM, James Campbell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Coming from a web background (before my iOS career) to me #avaliable has huge problem. It encourages fragility.<br>&gt; <br>&gt; In my eyes we should encourage two types of detection: Features to make code more adaptable to different environments and language version detection: so we can understand the actual code.<br>&gt; <br>&gt; See this example below:<br>&gt; <br>&gt; func magic(object: Object)<br>&gt; {<br>&gt;   if(#avaliable(9.0, 10))<br>&gt;  {<br>&gt;   object.foo()<br>&gt;  }<br>&gt; }<br>&gt; <br>&gt; Ideally for me I would love to check if the foo function exists like so:<br>&gt; <br>&gt; func iOS9OnlyProtocolFunction(object: Object)<br>&gt; {<br>&gt;   if(#avaliable(Object.foo))<br>&gt;  {<br>&gt;     object.foo()<br>&gt;  }<br>&gt; else <br>&gt; {<br>&gt;   object.baz()<br>&gt;  }<br>&gt; }<br>&gt; <br>&gt; I think this encourages feature detection which results in less fragile code. What I would love to do is also to extend this to extensions so we could encourage polyfills.<br>&gt; <br>&gt; extend object where not_avaliable(Object.foo) <br>&gt; {<br>&gt;   func foo() <br>&gt;  {<br>&gt;    //Polyfill for platforms which don&#39;t support the Object.foo method<br>&gt;  }<br>&gt; }<br>&gt; <br>&gt; Not sure about compiler details but being able to polyfill the function results in much cleaner code for me. I love this approach from the web, so I created my own Objective-C Library to do this:<br>&gt; <br>&gt; https://github.com/jcampbell05/Polly &lt;https://github.com/jcampbell05/Polly&gt;<br>&gt; ___________________________________<br>&gt; <br>&gt; James⎥Lead Engineer<br>&gt; <br>&gt; james at supmenow.com &lt;mailto:james at supmenow.com&gt;⎥supmenow.com &lt;http://supmenow.com/&gt;<br>&gt; Sup<br>&gt; <br>&gt; Runway East &gt; <br>&gt; <br>&gt; 10 Finsbury Square<br>&gt; <br>&gt; London<br>&gt; <br>&gt;  &gt; EC2A 1AF <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160204/132bae7c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>#available has a huge anti-pattern.</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>February  4, 2016 at 09:00:00pm</p></header><div class="content"><p>Thanks for that detailed explanation :)<br></p><p>For 1) I&#39;m thinking with Polyfills if Swift were to have them we would<br>ideally need some sort of mixin system. I would love to see a way where we<br>could specify which polyfill to apply like this.<br></p><p>extension CLLocationManager {<br></p><p>include RequestLocationPolyFill<br></p><p>}<br></p><p>or maybe even:<br></p><p>include CoreLocation apply RequestLocationPolyFill //But not sure about this<br></p><p>Perhaps if two things tried to polyfill the same thing we would reject the<br>ability to include that polyfill (we sort of have this issue already when<br>two things try to define the same method via an extension.<br></p><p>I think for 2) as Chris explained above we drop feature detection and for<br>these Polyfills we would try to detect the version for a certain Module. As<br>he states once Swift PM has matured enough it ciuld provide this<br>information. So if I wanted to polyfill requestLocation from the<br>CoreLocation library I could do this:<br></p><p>@avaliable(CoreLocation, &lt; 9) //Apply to CoreLocation version 9.0 or below<br>(Assuming CoreLocation is versioned same as iOS)<br>mixin RequestLocationPolyFill {<br> func requestLocation() {<br> }<br>}<br></p><p>*___________________________________*<br></p><p>*James⎥Lead Engineer*<br></p><p>*james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com &lt;http://supmenow.com&gt;*<br></p><p>*Sup*<br></p><p>*Runway East *<br></p><p>*10 Finsbury Square*<br></p><p>*London*<br></p><p>* EC2A 1AF *<br></p><p>On Thu, Feb 4, 2016 at 9:04 PM, Devin Coughlin &lt;dcoughlin at apple.com&gt; wrote:<br></p><p>&gt; James,<br>&gt;<br>&gt; We did consider an availability model with feature detection similar to<br>&gt; the one you proposed. This is essentially the model that Objective-C has.<br>&gt; We’ve found that there are significant drawbacks to that model and believe<br>&gt; that version checks + compile-time checking offer a better user experience.<br>&gt;<br>&gt; * Compile-time checking of availability makes version checking less<br>&gt; fragile.<br>&gt;<br>&gt; A key component of Swift’s availability model is that — unlike in<br>&gt; Objective-C or JavaScript — any use of an API element is verified for<br>&gt; availability by the compiler. This eliminates the main source of fragility<br>&gt; in the version checking model: getting a version check wrong and calling<br>&gt; the API anyway. The compiler makes the strong guarantee that it will detect<br>&gt; this and inform the developer that they have made a mistake.<br>&gt;<br>&gt;<br>&gt; * Feature detection checks are hard to reason about and test.<br>&gt;<br>&gt; With version checks it is is immediately obvious on what environment the<br>&gt; code will execute. This makes it easy to reason about, for example, how to<br>&gt; test the given class/method/branch. In contrast, with feature detection<br>&gt; even determining when a given branch of an availability check will execute<br>&gt; requires a trip to the documentation. A polyfill model would make this even<br>&gt; more challenging because the feature could be available earlier than the<br>&gt; documentation states!<br>&gt;<br>&gt;<br>&gt; * SPI and direct feature detection.<br>&gt;<br>&gt; Apple sometimes adds features first as SPI and only later makes them<br>&gt; available as API, potentially changing behavior when doing so. This means<br>&gt; that a naive check for the presence of, say, a class or method, does not<br>&gt; necessarily make it safe to call. For example, Apple added UINib as API in<br>&gt; iOS 4, but earlier versions used an incompatible class with the same name.<br>&gt; In this case, the Objective-C idiom checking for the feature effectively<br>&gt; “lied” about UINib’s availability. When it comes to API, the run-time<br>&gt; checks for #available need to allow symbols to be present but still not<br>&gt; considered available. Version checks (either OS versions or library<br>&gt; versions) are one mechanism to do this.<br>&gt;<br>&gt;<br>&gt; * Dead check detection<br>&gt;<br>&gt; One nice aspect of version checks is that it gives the compiler the<br>&gt; ability to detect availability checks that are no longer needed because the<br>&gt; application is being deployed only on versions of the OS on which the check<br>&gt; would always succeed. This is not possible with a direct feature detection<br>&gt; model alone (it still needs APIs to be annotated with their versions) and<br>&gt; would help prevent older codebases from being littered with feature checks<br>&gt; falling back to effectively dead code that no one knows whether it is safe<br>&gt; to remove or not.<br>&gt;<br>&gt;<br>&gt; * Overloading makes it verbose to check for a feature.<br>&gt;<br>&gt; Swift’s support for function and method overloads makes it quite verbose<br>&gt; to check for existence of a feature. Unambiguously identifying a method in<br>&gt; a #available check would require specifying its parameter types and even<br>&gt; constraints on generic type parameters.<br>&gt;<br>&gt;<br>&gt; * Features are often correlated.<br>&gt;<br>&gt; In Objective-C codebases we find that developers often make implicit<br>&gt; assumption about OS versions even when using direct feature checks. For<br>&gt; example, a developer will often check for the existence of one method and<br>&gt; then perform an unguarded use of another method that was introduced in the<br>&gt; same version. With a direct feature detection model, the developer would<br>&gt; have to check for each of these features separately — even though they know<br>&gt; they were introduced in the same OS version! The fact that Objective-C<br>&gt; developers are already skipping checks for correlated features shows that<br>&gt; their mental model is already based on versions, so it makes sense to match<br>&gt; that model in the affordances exposed by the language.<br>&gt;<br>&gt;<br>&gt; All that said, polyfill is a widely used technique and it would be<br>&gt; interesting to see what it would take to *safely* integrate into Swift. In<br>&gt; my view, the two key challenges there are (1) compatibility (whose polyfill<br>&gt; wins when two libraries try to polyfill the same thing?) and (2) how to<br>&gt; make assume-guarantee @available() annotations with polyfill/feature<br>&gt; detection safe at compile time and efficient without leaking implementation<br>&gt; details to clients (we don’t want every function to have to list all the<br>&gt; functions it calls [and all the functions they call, etc.] in its<br>&gt; @available() annotation!).<br>&gt;<br>&gt;<br>&gt; Devin<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Feb 2, 2016, at 2:03 AM, James Campbell via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Coming from a web background (before my iOS career) to me #avaliable has<br>&gt; huge problem. It encourages fragility.<br>&gt;<br>&gt; In my eyes we should encourage two types of detection: Features to make<br>&gt; code more adaptable to different environments and language version<br>&gt; detection: so we can understand the actual code.<br>&gt;<br>&gt; See this example below:<br>&gt;<br>&gt; func magic(object: Object)<br>&gt; {<br>&gt;   if(#avaliable(9.0, 10))<br>&gt;  {<br>&gt;   object.foo()<br>&gt;  }<br>&gt; }<br>&gt;<br>&gt; Ideally for me I would love to check if the foo function exists like so:<br>&gt;<br>&gt; func iOS9OnlyProtocolFunction(object: Object)<br>&gt; {<br>&gt;   if(#avaliable(Object.foo))<br>&gt;  {<br>&gt;     object.foo()<br>&gt;  }<br>&gt; else<br>&gt; {<br>&gt;   object.baz()<br>&gt;  }<br>&gt; }<br>&gt;<br>&gt; I think this encourages feature detection which results in less fragile<br>&gt; code. What I would love to do is also to extend this to extensions so we<br>&gt; could encourage polyfills.<br>&gt;<br>&gt; extend object where not_avaliable(Object.foo)<br>&gt; {<br>&gt;   func foo()<br>&gt;  {<br>&gt;    //Polyfill for platforms which don&#39;t support the Object.foo method<br>&gt;  }<br>&gt; }<br>&gt;<br>&gt; Not sure about compiler details but being able to polyfill the function<br>&gt; results in much cleaner code for me. I love this approach from the web, so<br>&gt; I created my own Objective-C Library to do this:<br>&gt;<br>&gt; https://github.com/jcampbell05/Polly<br>&gt;<br>&gt; *___________________________________*<br>&gt;<br>&gt; *James⎥Lead Engineer*<br>&gt;<br>&gt; *james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com<br>&gt; &lt;http://supmenow.com/&gt;*<br>&gt;<br>&gt; *Sup*<br>&gt;<br>&gt; *Runway East *<br>&gt;<br>&gt; *10 Finsbury Square*<br>&gt;<br>&gt; *London*<br>&gt;<br>&gt; * EC2A 1AF *<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160204/df97599f/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
