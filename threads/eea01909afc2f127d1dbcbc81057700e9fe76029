<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2720e8e2445923600966991c2b1287c5?s=50"></div><header><strong>Proposal: Intermediate mutation qualifier for protocol functions on reference-types</strong> from <string>Josh Avant</string> &lt;mailinglists at iamjo.sh&gt;<p>December 10, 2015 at 02:00:00pm</p></header><div class="content"><p>Currently, when a reference-type adopts a protocol with a function declared<br>as `mutating`, the reference-type&#39;s implementation cannot call that<br>function internally. This is because the compiler enforces an immutable<br>`self` pointer value, and the `mutating` qualifier implies that the<br>function implementation may mutate that `self` pointer value.<br></p><p>However, there seems to be a number of fairly reasonable situations where a<br>reference-type implementation of these `mutating` functions may only want<br>to mutate properties owned by `self`, but not the actual `self` pointer<br>value.<br></p><p>Consider this toy example:<br></p><p>```<br>import Foundation<br></p><p>protocol RandomDataTransformable {<br>    typealias TransformableType<br>    var data: [TransformableType] { get set }<br></p><p>    mutating func addRandomData()<br>}<br></p><p>extension RandomDataTransformable where TransformableType == Int {<br>    mutating func addRandomData() {<br>        let random = Int(arc4random_uniform(6) + 1)<br>        data.append(random)<br>    }<br>}<br></p><p><br>/////<br></p><p>// VALID<br>struct NumberSource_Struct : RandomDataTransformable {<br>    typealias TransformableType = Int<br>    var data: [Int] = []<br></p><p>    mutating func addData() {<br>        addRandomData()<br>    }<br>}<br></p><p><br>// VALID<br>class NumberSource_ClassDeclaration: NSObject, RandomDataTransformable {<br>    typealias TransformableType = Int<br>    var data: [Int] = []<br>}<br></p><p>var numberSource = NumberSource_ClassDeclaration()<br>numberSource.addRandomData()<br></p><p><br>// INVALID<br>class NumberSource_ClassImplementation: NSObject, RandomDataTransformable {<br>    typealias TransformableType = Int<br>    var data: [Int] = []<br></p><p>    func addData() {<br>        self.addRandomData() // Compiler Error: Cannot use mutating member<br>on immutable value: &#39;self&#39; is immutable<br>    }<br>}<br>```<br></p><p>Even despite the fact that the default implementation for `addRandomData`<br>does not mutate the `self` pointer value, reference-type implementations<br>are unable to call that function internally, since it is marked as<br>`mutating`.<br></p><p>Perhaps confusingly, `addRandomData` may be called by externally, by<br>objects which own instances of the reference-type (even though, again, it<br>may not called internally by the implementation, itself).<br></p><p>Currently, the only solution to allow reference-type implementations to<br>call the sample `addRandomData` implementation internally is to qualify the<br>whole `RandomDataTransformable` protocol as `class`. The downside here is<br>that this takes an otherwise perfectly reference- and struct-compatible<br>protocol + extension implementation and restricts it to only apply to<br>classes, decreasing overall code reusability.<br></p><p>My proposal would be to introduce an intermediate mutation qualifier that<br>applies when protocols are adopted by reference-types. The qualifier would<br>specify that the `self` pointer value itself may not be mutated, but<br>`self`&#39;s properties may be, as appropriate.<br></p><p>Thoughts, feedback on this?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/eea06029/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Intermediate mutation qualifier for protocol functions on reference-types</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 10, 2015 at 04:00:00pm</p></header><div class="content"><p>A couple of miscellaneous points:<br></p><p>* This problem only occurs when the class inherits a default<br>  implementation of the method from a protocol extension. If the class<br>  declares the method itself, then it&#39;s no longer a mutating method and<br>  everything works fine.<br>* The problem exists because mutating functions are allowed to assign<br>  to self, but methods on class types cannot assign to self, they can<br>  only mutate the properties of self. This is why we cannot simply<br>  allow the call to the inherited mutating method, as that method may<br>  reassign self.<br>* Classes can still call the method, they just have to say<br>  something like<br></p><p>var this = self this.callMutatingMethod()<br></p><p>Yeah it&#39;s a little awkward, but it&#39;s not really all that bad for an edge<br>case like this.<br></p><p>Another potential workaround requires more work on the protocol side but<br>allows implementations to not care about the difference, which is to<br>provide a non-mutating variant in an extension restricted by Self:<br>AnyObject:<br></p><p>protocol P {    var count: Int { get set }    mutating func foo()<br>-&gt; String }<br></p><p>extension P {    mutating func foo() -&gt; String {        return<br>_mutatingFoo(&amp;self)    } }<br></p><p>extension P where Self: AnyObject {    func foo() -&gt; String {        var<br>this = self        return _mutatingFoo(&amp;this)    } }<br></p><p>private func _mutatingFoo&lt;T: P&gt;(inout value: T) -&gt; String {<br>value.count += 1    return &quot;foo&quot; }<br></p><p>Ultimately, I think there&#39;s some value in this proposal, but I worry<br>about adding a new keyword to handle an edge case like this when there&#39;s<br>workarounds available. Assuming we do add this feature, I&#39;d suggest<br>using something like `mutating(ish)` instead of inventing a brand new<br>keyword (there&#39;s precedent in `private(set)`).<br></p><p>-Kevin Ballard<br></p><p>On Thu, Dec 10, 2015, at 02:35 PM, Josh Avant via swift-evolution wrote:<br>&gt; Currently, when a reference-type adopts a protocol with a function<br>&gt; declared as `mutating`, the reference-type&#39;s implementation cannot<br>&gt; call that function internally. This is because the compiler enforces<br>&gt; an immutable `self` pointer value, and the `mutating` qualifier<br>&gt; implies that the function implementation may mutate that `self`<br>&gt; pointer value.<br>&gt;<br>&gt; However, there seems to be a number of fairly reasonable situations<br>&gt; where a reference-type implementation of these `mutating` functions<br>&gt; may only want to mutate properties owned by `self`, but not the actual<br>&gt; `self` pointer value.<br>&gt;<br>&gt; Consider this toy example:<br>&gt;<br>&gt; ``` import Foundation<br>&gt;<br>&gt; protocol RandomDataTransformable {    typealias TransformableType<br>&gt; var data: [TransformableType] { get set }<br>&gt;<br>&gt; mutating func addRandomData() }<br>&gt;<br>&gt; extension RandomDataTransformable where TransformableType == Int {<br>&gt; mutating func addRandomData() {        let random =<br>&gt; Int(arc4random_uniform(6) + 1)        data.append(random)    } }<br>&gt;<br>&gt;<br>&gt; /////<br>&gt;<br>&gt; // VALID struct NumberSource_Struct : RandomDataTransformable {<br>&gt; typealias TransformableType = Int    var data: [Int] = []<br>&gt;<br>&gt; mutating func addData() {        addRandomData()    } }<br>&gt;<br>&gt;<br>&gt; // VALID class NumberSource_ClassDeclaration: NSObject,<br>&gt; RandomDataTransformable {    typealias TransformableType = Int    var<br>&gt; data: [Int] = [] }<br>&gt;<br>&gt; var numberSource = NumberSource_ClassDeclaration()<br>&gt; numberSource.addRandomData()<br>&gt;<br>&gt;<br>&gt; // INVALID class NumberSource_ClassImplementation: NSObject,<br>&gt; RandomDataTransformable {    typealias TransformableType = Int    var<br>&gt; data: [Int] = []<br>&gt;<br>&gt; func addData() {        self.addRandomData() // Compiler Error: Cannot<br>&gt; use mutating member on immutable value: &#39;self&#39; is immutable    } } ```<br>&gt;<br>&gt; Even despite the fact that the default implementation for<br>&gt; `addRandomData` does not mutate the `self` pointer value, reference-<br>&gt; type implementations are unable to call that function internally,<br>&gt; since it is marked as `mutating`.<br>&gt;<br>&gt; Perhaps confusingly, `addRandomData` may be called by externally, by<br>&gt; objects which own instances of the reference-type (even though, again,<br>&gt; it may not called internally by the implementation, itself).<br>&gt;<br>&gt; Currently, the only solution to allow reference-type implementations<br>&gt; to call the sample `addRandomData` implementation internally is to<br>&gt; qualify the whole `RandomDataTransformable` protocol as `class`. The<br>&gt; downside here is that this takes an otherwise perfectly reference- and<br>&gt; struct-compatible protocol + extension implementation and restricts it<br>&gt; to only apply to classes, decreasing overall code reusability.<br>&gt;<br>&gt; My proposal would be to introduce an intermediate mutation qualifier<br>&gt; that applies when protocols are adopted by reference-types. The<br>&gt; qualifier would specify that the `self` pointer value itself may not<br>&gt; be mutated, but `self`&#39;s properties may be, as appropriate.<br>&gt;<br>&gt; Thoughts, feedback on this?<br>&gt;<br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/231ce9b7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2720e8e2445923600966991c2b1287c5?s=50"></div><header><strong>Proposal: Intermediate mutation qualifier for protocol functions on reference-types</strong> from <string>Josh Avant</string> &lt;mailinglists at iamjo.sh&gt;<p>December 11, 2015 at 09:00:00am</p></header><div class="content"><p>Thanks, Kevin!<br></p><p>Look forward to any other feedback!<br></p><p>On Thursday, December 10, 2015, Kevin Ballard via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; A couple of miscellaneous points:<br>&gt;<br>&gt; * This problem only occurs when the class inherits a default<br>&gt; implementation of the method from a protocol extension. If the class<br>&gt; declares the method itself, then it&#39;s no longer a mutating method and<br>&gt; everything works fine.<br>&gt; * The problem exists because mutating functions are allowed to assign to<br>&gt; self, but methods on class types cannot assign to self, they can only<br>&gt; mutate the properties of self. This is why we cannot simply allow the call<br>&gt; to the inherited mutating method, as that method may reassign self.<br>&gt; * Classes can still call the method, they just have to say something like<br>&gt;<br>&gt; var this = self<br>&gt; this.callMutatingMethod()<br>&gt;<br>&gt; Yeah it&#39;s a little awkward, but it&#39;s not really all that bad for an edge<br>&gt; case like this.<br>&gt;<br>&gt; Another potential workaround requires more work on the protocol side but<br>&gt; allows implementations to not care about the difference, which is to<br>&gt; provide a non-mutating variant in an extension restricted by Self:<br>&gt; AnyObject:<br>&gt;<br>&gt; protocol P {<br>&gt;     var count: Int { get set }<br>&gt;     mutating func foo() -&gt; String<br>&gt; }<br>&gt;<br>&gt; extension P {<br>&gt;     mutating func foo() -&gt; String {<br>&gt;         return _mutatingFoo(&amp;self)<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; extension P where Self: AnyObject {<br>&gt;     func foo() -&gt; String {<br>&gt;         var this = self<br>&gt;         return _mutatingFoo(&amp;this)<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; private func _mutatingFoo&lt;T: P&gt;(inout value: T) -&gt; String {<br>&gt;     value.count += 1<br>&gt;     return &quot;foo&quot;<br>&gt; }<br>&gt;<br>&gt; Ultimately, I think there&#39;s some value in this proposal, but I worry about<br>&gt; adding a new keyword to handle an edge case like this when there&#39;s<br>&gt; workarounds available. Assuming we do add this feature, I&#39;d suggest using<br>&gt; something like `mutating(ish)` instead of inventing a brand new keyword<br>&gt; (there&#39;s precedent in `private(set)`).<br>&gt;<br>&gt; -Kevin Ballard<br>&gt;<br>&gt; On Thu, Dec 10, 2015, at 02:35 PM, Josh Avant via swift-evolution wrote:<br>&gt;<br>&gt; Currently, when a reference-type adopts a protocol with a function<br>&gt; declared as `mutating`, the reference-type&#39;s implementation cannot call<br>&gt; that function internally. This is because the compiler enforces an<br>&gt; immutable `self` pointer value, and the `mutating` qualifier implies that<br>&gt; the function implementation may mutate that `self` pointer value.<br>&gt;<br>&gt; However, there seems to be a number of fairly reasonable situations where<br>&gt; a reference-type implementation of these `mutating` functions may only want<br>&gt; to mutate properties owned by `self`, but not the actual `self` pointer<br>&gt; value.<br>&gt;<br>&gt; Consider this toy example:<br>&gt;<br>&gt; ```<br>&gt; import Foundation<br>&gt;<br>&gt; protocol RandomDataTransformable {<br>&gt;     typealias TransformableType<br>&gt;     var data: [TransformableType] { get set }<br>&gt;<br>&gt;     mutating func addRandomData()<br>&gt; }<br>&gt;<br>&gt; extension RandomDataTransformable where TransformableType == Int {<br>&gt;     mutating func addRandomData() {<br>&gt;         let random = Int(arc4random_uniform(6) + 1)<br>&gt;         data.append(random)<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; /////<br>&gt;<br>&gt; // VALID<br>&gt; struct NumberSource_Struct : RandomDataTransformable {<br>&gt;     typealias TransformableType = Int<br>&gt;     var data: [Int] = []<br>&gt;<br>&gt;     mutating func addData() {<br>&gt;         addRandomData()<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; // VALID<br>&gt; class NumberSource_ClassDeclaration: NSObject, RandomDataTransformable {<br>&gt;     typealias TransformableType = Int<br>&gt;     var data: [Int] = []<br>&gt; }<br>&gt;<br>&gt; var numberSource = NumberSource_ClassDeclaration()<br>&gt; numberSource.addRandomData()<br>&gt;<br>&gt;<br>&gt; // INVALID<br>&gt; class NumberSource_ClassImplementation: NSObject, RandomDataTransformable {<br>&gt;     typealias TransformableType = Int<br>&gt;     var data: [Int] = []<br>&gt;<br>&gt;     func addData() {<br>&gt;         self.addRandomData() // Compiler Error: Cannot use mutating member<br>&gt; on immutable value: &#39;self&#39; is immutable<br>&gt;     }<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; Even despite the fact that the default implementation for `addRandomData`<br>&gt; does not mutate the `self` pointer value, reference-type implementations<br>&gt; are unable to call that function internally, since it is marked as<br>&gt; `mutating`.<br>&gt;<br>&gt; Perhaps confusingly, `addRandomData` may be called by externally, by<br>&gt; objects which own instances of the reference-type (even though, again, it<br>&gt; may not called internally by the implementation, itself).<br>&gt;<br>&gt; Currently, the only solution to allow reference-type implementations to<br>&gt; call the sample `addRandomData` implementation internally is to qualify the<br>&gt; whole `RandomDataTransformable` protocol as `class`. The downside here is<br>&gt; that this takes an otherwise perfectly reference- and struct-compatible<br>&gt; protocol + extension implementation and restricts it to only apply to<br>&gt; classes, decreasing overall code reusability.<br>&gt;<br>&gt; My proposal would be to introduce an intermediate mutation qualifier that<br>&gt; applies when protocols are adopted by reference-types. The qualifier would<br>&gt; specify that the `self` pointer value itself may not be mutated, but<br>&gt; `self`&#39;s properties may be, as appropriate.<br>&gt;<br>&gt; Thoughts, feedback on this?<br>&gt;<br>&gt; *_______________________________________________*<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/bb47c0d2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>Proposal: Intermediate mutation qualifier for protocol functions on reference-types</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>December 11, 2015 at 06:00:00pm</p></header><div class="content"><p>I did report this problem as https://bugs.swift.org/browse/SR-142 a couple of days ago.<br></p><p>Greg Titus replied:<br></p><p>&gt; Looked into this briefly, and it&#39;s a lot harder than just changing the error checking, since m() has an implicit `inout P` first argument. Probably the solution is an automatic version of Gwendal&#39;s workaround: declaring a hidden `var p: P = c` and calling the method on p.<br></p><p>Gwendal Roué<br></p><p>&gt; Le 11 déc. 2015 à 18:22, Josh Avant via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Thanks, Kevin!<br>&gt; <br>&gt; Look forward to any other feedback!<br>&gt; <br>&gt; On Thursday, December 10, 2015, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; A couple of miscellaneous points:<br>&gt;  <br>&gt; * This problem only occurs when the class inherits a default implementation of the method from a protocol extension. If the class declares the method itself, then it&#39;s no longer a mutating method and everything works fine.<br>&gt; * The problem exists because mutating functions are allowed to assign to self, but methods on class types cannot assign to self, they can only mutate the properties of self. This is why we cannot simply allow the call to the inherited mutating method, as that method may reassign self.<br>&gt; * Classes can still call the method, they just have to say something like<br>&gt;  <br>&gt; var this = self<br>&gt; this.callMutatingMethod()<br>&gt;  <br>&gt; Yeah it&#39;s a little awkward, but it&#39;s not really all that bad for an edge case like this.<br>&gt;  <br>&gt; Another potential workaround requires more work on the protocol side but allows implementations to not care about the difference, which is to provide a non-mutating variant in an extension restricted by Self: AnyObject:<br>&gt;  <br>&gt; protocol P {<br>&gt;     var count: Int { get set }<br>&gt;     mutating func foo() -&gt; String<br>&gt; }<br>&gt;  <br>&gt; extension P {<br>&gt;     mutating func foo() -&gt; String {<br>&gt;         return _mutatingFoo(&amp;self)<br>&gt;     }<br>&gt; }<br>&gt;  <br>&gt; extension P where Self: AnyObject {<br>&gt;     func foo() -&gt; String {<br>&gt;         var this = self<br>&gt;         return _mutatingFoo(&amp;this)<br>&gt;     }<br>&gt; }<br>&gt;  <br>&gt; private func _mutatingFoo&lt;T: P&gt;(inout value: T) -&gt; String {<br>&gt;     value.count += 1<br>&gt;     return &quot;foo&quot;<br>&gt; }<br>&gt;  <br>&gt; Ultimately, I think there&#39;s some value in this proposal, but I worry about adding a new keyword to handle an edge case like this when there&#39;s workarounds available. Assuming we do add this feature, I&#39;d suggest using something like `mutating(ish)` instead of inventing a brand new keyword (there&#39;s precedent in `private(set)`).<br>&gt;  <br>&gt; -Kevin Ballard<br>&gt;  <br>&gt; On Thu, Dec 10, 2015, at 02:35 PM, Josh Avant via swift-evolution wrote:<br>&gt;&gt; Currently, when a reference-type adopts a protocol with a function declared as `mutating`, the reference-type&#39;s implementation cannot call that function internally. This is because the compiler enforces an immutable `self` pointer value, and the `mutating` qualifier implies that the function implementation may mutate that `self` pointer value.<br>&gt;&gt;  <br>&gt;&gt; However, there seems to be a number of fairly reasonable situations where a reference-type implementation of these `mutating` functions may only want to mutate properties owned by `self`, but not the actual `self` pointer value.<br>&gt;&gt;  <br>&gt;&gt; Consider this toy example:<br>&gt;&gt;  <br>&gt;&gt; ```<br>&gt;&gt; import Foundation<br>&gt;&gt;  <br>&gt;&gt; protocol RandomDataTransformable {<br>&gt;&gt;     typealias TransformableType<br>&gt;&gt;     var data: [TransformableType] { get set }<br>&gt;&gt;  <br>&gt;&gt;     mutating func addRandomData()<br>&gt;&gt; }<br>&gt;&gt;  <br>&gt;&gt; extension RandomDataTransformable where TransformableType == Int {<br>&gt;&gt;     mutating func addRandomData() {<br>&gt;&gt;         let random = Int(arc4random_uniform(6) + 1)<br>&gt;&gt;         data.append(random)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;  <br>&gt;&gt;  <br>&gt;&gt; /////<br>&gt;&gt;  <br>&gt;&gt; // VALID<br>&gt;&gt; struct NumberSource_Struct : RandomDataTransformable {<br>&gt;&gt;     typealias TransformableType = Int<br>&gt;&gt;     var data: [Int] = []<br>&gt;&gt;  <br>&gt;&gt;     mutating func addData() {<br>&gt;&gt;         addRandomData()<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;  <br>&gt;&gt;  <br>&gt;&gt; // VALID<br>&gt;&gt; class NumberSource_ClassDeclaration: NSObject, RandomDataTransformable {<br>&gt;&gt;     typealias TransformableType = Int<br>&gt;&gt;     var data: [Int] = []<br>&gt;&gt; }<br>&gt;&gt;  <br>&gt;&gt; var numberSource = NumberSource_ClassDeclaration()<br>&gt;&gt; numberSource.addRandomData()<br>&gt;&gt;  <br>&gt;&gt;  <br>&gt;&gt; // INVALID<br>&gt;&gt; class NumberSource_ClassImplementation: NSObject, RandomDataTransformable {<br>&gt;&gt;     typealias TransformableType = Int<br>&gt;&gt;     var data: [Int] = []<br>&gt;&gt;  <br>&gt;&gt;     func addData() {<br>&gt;&gt;         self.addRandomData() // Compiler Error: Cannot use mutating member on immutable value: &#39;self&#39; is immutable<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt;  <br>&gt;&gt; Even despite the fact that the default implementation for `addRandomData` does not mutate the `self` pointer value, reference-type implementations are unable to call that function internally, since it is marked as `mutating`.<br>&gt;&gt;  <br>&gt;&gt; Perhaps confusingly, `addRandomData` may be called by externally, by objects which own instances of the reference-type (even though, again, it may not called internally by the implementation, itself).<br>&gt;&gt;  <br>&gt;&gt; Currently, the only solution to allow reference-type implementations to call the sample `addRandomData` implementation internally is to qualify the whole `RandomDataTransformable` protocol as `class`. The downside here is that this takes an otherwise perfectly reference- and struct-compatible protocol + extension implementation and restricts it to only apply to classes, decreasing overall code reusability.<br>&gt;&gt;  <br>&gt;&gt; My proposal would be to introduce an intermediate mutation qualifier that applies when protocols are adopted by reference-types. The qualifier would specify that the `self` pointer value itself may not be mutated, but `self`&#39;s properties may be, as appropriate.<br>&gt;&gt;  <br>&gt;&gt; Thoughts, feedback on this?<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/babbad80/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>Proposal: Intermediate mutation qualifier for protocol functions on reference-types</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>December 11, 2015 at 11:00:00am</p></header><div class="content"><p>Hi Josh,<br></p><p>&gt; On Dec 10, 2015, at 2:35 PM, Josh Avant via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Currently, when a reference-type adopts a protocol with a function declared as `mutating`, the reference-type&#39;s implementation cannot call that function internally. This is because the compiler enforces an immutable `self` pointer value, and the `mutating` qualifier implies that the function implementation may mutate that `self` pointer value.<br>&gt; <br>&gt; However, there seems to be a number of fairly reasonable situations where a reference-type implementation of these `mutating` functions may only want to mutate properties owned by `self`, but not the actual `self` pointer value.<br>&gt; <br></p><p>Consider this usage of the code you show below:<br></p><p>var s: RandomDataTransformable = NumberSource_Struct()<br>var ss = s<br></p><p>s.addRandomData()<br>// ss.data unchanged<br></p><p>var c: RandomDataTransformable = NumberSource_ClassDeclaration()<br>var cc = c<br></p><p>c.addRandomData()<br>// cc.data changed!<br></p><p>It seems it would be difficult to write fully generic code with a protocol that has this behavior, because you cannot rely on value semantics at all. To implement ‘mutating’ class methods correctly, you would in fact have to create a new class instance and re-assign to self every time, to preserve old references, since mutating the old value might break users of the protocol that are written as if the witness was a value type. This seems to defeat the whole purpose of using a reference type in fact.<br></p><p>It seems that if you really know what you’re doing, you can define a one-element struct that conforms to the protocol and contains the reference. This is in fact how Array, Dictionary and Set implement copy-on-write under the hood.<br></p><p>For this reason I’m in favor of going in the opposite direction, and prohibiting classes from conforming to protocols with mutating requirements.<br></p><p>Now that I think about it, setters in protocols have the same issue with confusing behavior from code that expects value semantics. Hmm...<br></p><p>Slava<br></p><p>&gt; Consider this toy example:<br>&gt; <br>&gt; ```<br>&gt; import Foundation<br>&gt; <br>&gt; protocol RandomDataTransformable {<br>&gt;     typealias TransformableType<br>&gt;     var data: [TransformableType] { get set }<br>&gt;     <br>&gt;     mutating func addRandomData()<br>&gt; }<br>&gt; <br>&gt; extension RandomDataTransformable where TransformableType == Int {<br>&gt;     mutating func addRandomData() {<br>&gt;         let random = Int(arc4random_uniform(6) + 1)<br>&gt;         data.append(random)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; /////<br>&gt; <br>&gt; // VALID<br>&gt; struct NumberSource_Struct : RandomDataTransformable {<br>&gt;     typealias TransformableType = Int<br>&gt;     var data: [Int] = []<br>&gt;     <br>&gt;     mutating func addData() {<br>&gt;         addRandomData()<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; // VALID<br>&gt; class NumberSource_ClassDeclaration: NSObject, RandomDataTransformable {<br>&gt;     typealias TransformableType = Int<br>&gt;     var data: [Int] = []<br>&gt; }<br>&gt; <br>&gt; var numberSource = NumberSource_ClassDeclaration()<br>&gt; numberSource.addRandomData()<br>&gt; <br>&gt; <br>&gt; // INVALID<br>&gt; class NumberSource_ClassImplementation: NSObject, RandomDataTransformable {<br>&gt;     typealias TransformableType = Int<br>&gt;     var data: [Int] = []<br>&gt;     <br>&gt;     func addData() {<br>&gt;         self.addRandomData() // Compiler Error: Cannot use mutating member on immutable value: &#39;self&#39; is immutable<br>&gt;     }<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; Even despite the fact that the default implementation for `addRandomData` does not mutate the `self` pointer value, reference-type implementations are unable to call that function internally, since it is marked as `mutating`.<br>&gt; <br>&gt; Perhaps confusingly, `addRandomData` may be called by externally, by objects which own instances of the reference-type (even though, again, it may not called internally by the implementation, itself).<br>&gt; <br>&gt; Currently, the only solution to allow reference-type implementations to call the sample `addRandomData` implementation internally is to qualify the whole `RandomDataTransformable` protocol as `class`. The downside here is that this takes an otherwise perfectly reference- and struct-compatible protocol + extension implementation and restricts it to only apply to classes, decreasing overall code reusability.<br>&gt; <br>&gt; My proposal would be to introduce an intermediate mutation qualifier that applies when protocols are adopted by reference-types. The qualifier would specify that the `self` pointer value itself may not be mutated, but `self`&#39;s properties may be, as appropriate.<br>&gt; <br>&gt; Thoughts, feedback on this?<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/c559e7c7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>Proposal: Intermediate mutation qualifier for protocol functions on reference-types</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>December 11, 2015 at 08:00:00pm</p></header><div class="content"><p>&gt; Le 11 déc. 2015 à 20:34, Slava Pestov via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; For this reason I’m in favor of going in the opposite direction, and prohibiting classes from conforming to protocols with mutating requirements.<br></p><p>This would go too far.<br></p><p>It’s common to write a protocol with mutating methods just because the protocol designer expects that some adopting structs may want to mutate in their implementation. And in this case the goal of the protocol designer is certainly not to limit the protocol adoption to structs.<br></p><p>Here is an example:<br></p><p>	protocol DatabaseFetchable {<br>	  mutating func awakeFromFetch()<br>	}<br>	extension DatabaseFetchable {<br>	  func fetch() -&gt; Self {<br>	    var value = /* details omitted */<br>	    value.awakeFromFetch()<br>	    return value<br>	  }<br>	}<br></p><p>The protocol does not care at all if awakeFromFetch mutates or not. But the protocol designer does: if the awakeFromFetch method were not declared mutating, many structs could simply not adopt it.<br></p><p>Gwendal Roué<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/fe44f006/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>Proposal: Intermediate mutation qualifier for protocol functions on reference-types</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>December 11, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; On Dec 11, 2015, at 11:43 AM, Gwendal Roué &lt;gwendal.roue at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Le 11 déc. 2015 à 20:34, Slava Pestov via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; For this reason I’m in favor of going in the opposite direction, and prohibiting classes from conforming to protocols with mutating requirements.<br>&gt; <br>&gt; This would go too far.<br>&gt; <br>&gt; It’s common to write a protocol with mutating methods just because the protocol designer expects that some adopting structs may want to mutate in their implementation. And in this case the goal of the protocol designer is certainly not to limit the protocol adoption to structs.<br>&gt; <br>&gt; Here is an example:<br>&gt; <br>&gt; 	protocol DatabaseFetchable {<br>&gt; 	  mutating func awakeFromFetch()<br>&gt; 	}<br>&gt; 	extension DatabaseFetchable {<br>&gt; 	  func fetch() -&gt; Self {<br>&gt; 	    var value = /* details omitted */<br>&gt; 	    value.awakeFromFetch()<br>&gt; 	    return value<br>&gt; 	  }<br>&gt; 	}<br>&gt; <br>&gt; The protocol does not care at all if awakeFromFetch mutates or not. But the protocol designer does: if the awakeFromFetch method were not declared mutating, many structs could simply not adopt it.<br>&gt; <br>&gt; Gwendal Roué<br>&gt; <br></p><p>I guess the question is, does it even make sense to write a protocol that can be adopted by both a struct and a class, if the protocol has mutating members?<br></p><p>Slava<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/a6635eaa/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>Proposal: Intermediate mutation qualifier for protocol functions on reference-types</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>December 11, 2015 at 08:00:00pm</p></header><div class="content"><p>&gt; Le 11 déc. 2015 à 20:44, Slava Pestov &lt;spestov at apple.com&gt; a écrit :<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 11, 2015, at 11:43 AM, Gwendal Roué &lt;gwendal.roue at gmail.com &lt;mailto:gwendal.roue at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Le 11 déc. 2015 à 20:34, Slava Pestov via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For this reason I’m in favor of going in the opposite direction, and prohibiting classes from conforming to protocols with mutating requirements.<br>&gt;&gt; <br>&gt;&gt; This would go too far.<br>&gt;&gt; <br>&gt;&gt; It’s common to write a protocol with mutating methods just because the protocol designer expects that some adopting structs may want to mutate in their implementation. And in this case the goal of the protocol designer is certainly not to limit the protocol adoption to structs.<br>&gt;&gt; <br>&gt;&gt; Here is an example:<br>&gt;&gt; <br>&gt;&gt; 	protocol DatabaseFetchable {<br>&gt;&gt; 	  mutating func awakeFromFetch()<br>&gt;&gt; 	}<br>&gt;&gt; 	extension DatabaseFetchable {<br>&gt;&gt; 	  func fetch() -&gt; Self {<br>&gt;&gt; 	    var value = /* details omitted */<br>&gt;&gt; 	    value.awakeFromFetch()<br>&gt;&gt; 	    return value<br>&gt;&gt; 	  }<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; The protocol does not care at all if awakeFromFetch mutates or not. But the protocol designer does: if the awakeFromFetch method were not declared mutating, many structs could simply not adopt it.<br>&gt;&gt; <br>&gt;&gt; Gwendal Roué<br>&gt;&gt; <br>&gt; <br>&gt; I guess the question is, does it even make sense to write a protocol that can be adopted by both a struct and a class, if the protocol has mutating members?<br></p><p>I just gave you an answer above: when the protocol designer does not care whether the protocol should be adopted by a struct or a class. Who knows? Maybe the user will adopt the protocol in an extension of an existing type, which happens to already be a struct or a class? Maybe the user will want to adopt the protocol in the base class of a class hierarchy? Who knows?<br></p><p>Gwendal Roué<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/511e47ae/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>Proposal: Intermediate mutation qualifier for protocol functions on reference-types</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>December 11, 2015 at 08:00:00pm</p></header><div class="content"><p>&gt; Le 11 déc. 2015 à 20:44, Slava Pestov &lt;spestov at apple.com&gt; a écrit :<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 11, 2015, at 11:43 AM, Gwendal Roué &lt;gwendal.roue at gmail.com &lt;mailto:gwendal.roue at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Le 11 déc. 2015 à 20:34, Slava Pestov via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For this reason I’m in favor of going in the opposite direction, and prohibiting classes from conforming to protocols with mutating requirements.<br>&gt;&gt; <br>&gt;&gt; This would go too far.<br>&gt;&gt; <br>&gt;&gt; It’s common to write a protocol with mutating methods just because the protocol designer expects that some adopting structs may want to mutate in their implementation. And in this case the goal of the protocol designer is certainly not to limit the protocol adoption to structs.<br>&gt;&gt; <br>&gt;&gt; Here is an example:<br>&gt;&gt; <br>&gt;&gt; 	protocol DatabaseFetchable {<br>&gt;&gt; 	  mutating func awakeFromFetch()<br>&gt;&gt; 	}<br>&gt;&gt; 	extension DatabaseFetchable {<br>&gt;&gt; 	  func fetch() -&gt; Self {<br>&gt;&gt; 	    var value = /* details omitted */<br>&gt;&gt; 	    value.awakeFromFetch()<br>&gt;&gt; 	    return value<br>&gt;&gt; 	  }<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; The protocol does not care at all if awakeFromFetch mutates or not. But the protocol designer does: if the awakeFromFetch method were not declared mutating, many structs could simply not adopt it.<br>&gt;&gt; <br>&gt;&gt; Gwendal Roué<br>&gt;&gt; <br>&gt; <br>&gt; I guess the question is, does it even make sense to write a protocol that can be adopted by both a struct and a class, if the protocol has mutating members?<br>&gt; <br>&gt; Slava<br></p><p>BTW, we have three workarounds to the initial problem so far, using the current state of Swift:<br></p><p>1. the one by Kevin Ballard below in the thread (the best one)<br>2. my first work around at https://bugs.swift.org/browse/SR-142 &lt;https://bugs.swift.org/browse/SR-142&gt;<br>3. declare a non-mutating protocol that inherits from the mutating one, and let classes adopt the non-mutating one, as in:<br></p><p>	protocol MutableP {<br>	  mutating func f()<br>	}<br>	protocol P : MutableP {<br>	  func f()<br>	}<br></p><p>The last workaround is a different in that it leaves room for structs that decide not to mutate in their implementation of the protocol.<br></p><p>You have an example of this approach at https://github.com/groue/GRDB.swift#databasepersistable-protocol<br></p><p>Gwendal Roué<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/73c90d64/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2720e8e2445923600966991c2b1287c5?s=50"></div><header><strong>Proposal: Intermediate mutation qualifier for protocol functions on reference-types</strong> from <string>Josh Avant</string> &lt;mailinglists at iamjo.sh&gt;<p>December 11, 2015 at 02:00:00pm</p></header><div class="content"><p>It seems it would be difficult to write fully generic code with a protocol<br>that has this behavior, because you cannot rely on value semantics at all.<br>To implement ‘mutating’ class methods correctly, you would in fact have to<br>create a new class instance and re-assign to self every time, to preserve<br>old references, since mutating the old value might break users of the<br>protocol that are written as if the witness was a value type. This seems to<br>defeat the whole purpose of using a reference type in fact.<br></p><p><br>Agreed. That description even seems to sound like a rehashing of the same<br>problem, but from a more strictly value-centric approach.<br></p><p>The &#39;one-element struct&#39; solution isn&#39;t what I was looking for, here. I<br>wasn&#39;t trying to achieve copy-on-write of a whole object structure, but<br>instead writing more fully generic code. Also, not having to use an awkward<br>workaround (i.e. the var this = self; this.mutatingMethod()).<br></p><p><br>I guess the question is, does it even make sense to write a protocol that<br>can be adopted by both a struct and a class, if the protocol has mutating<br>members?<br></p><p><br>I think so. But I think part of the problem is that protocol members are<br>currently interpreted in terms of value semantics, but protocols are, of<br>course, widely used in reference semantics, too.<br></p><p>To me, it feels like we&#39;re lacking a degree of fidelity. That&#39;s why my<br>initial proposition was a `mutating`-ish operator that applies specifically<br>to this scenario, and provides a more nuanced bridging to reference<br>semantics (feels vaguely similar in nature to unowned vs. weak modifiers).<br></p><p>On Fri, Dec 11, 2015 at 11:44 AM, Slava Pestov &lt;spestov at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Dec 11, 2015, at 11:43 AM, Gwendal Roué &lt;gwendal.roue at gmail.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; Le 11 déc. 2015 à 20:34, Slava Pestov via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;<br>&gt; For this reason I’m in favor of going in the opposite direction, and<br>&gt; prohibiting classes from conforming to protocols with mutating requirements.<br>&gt;<br>&gt;<br>&gt; This would go too far.<br>&gt;<br>&gt; It’s common to write a protocol with mutating methods just because the<br>&gt; protocol designer expects that some adopting structs may want to mutate in<br>&gt; their implementation. And in this case the goal of the protocol designer is<br>&gt; certainly not to limit the protocol adoption to structs.<br>&gt;<br>&gt; Here is an example:<br>&gt;<br>&gt; protocol DatabaseFetchable {<br>&gt;   mutating func awakeFromFetch()<br>&gt; }<br>&gt; extension DatabaseFetchable {<br>&gt;   func fetch() -&gt; Self {<br>&gt;     var value = /* details omitted */<br>&gt;     value.awakeFromFetch()<br>&gt;     return value<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; The protocol does not care at all if awakeFromFetch mutates or not. But<br>&gt; the protocol designer does: if the awakeFromFetch method were not declared<br>&gt; mutating, many structs could simply not adopt it.<br>&gt;<br>&gt; Gwendal Roué<br>&gt;<br>&gt;<br>&gt; I guess the question is, does it even make sense to write a protocol that<br>&gt; can be adopted by both a struct and a class, if the protocol has mutating<br>&gt; members?<br>&gt;<br>&gt; Slava<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/eec05c0f/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Proposal: Intermediate mutation qualifier for protocol functions on reference-types</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>December 11, 2015 at 07:00:00pm</p></header><div class="content"><p>Hey Swift team can you tell the iTunes Connect team their website is down,<br>there is no way to get a hold of them.<br></p><p>On Thu, Dec 10, 2015 at 10:35 PM, Josh Avant via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Currently, when a reference-type adopts a protocol with a function<br>&gt; declared as `mutating`, the reference-type&#39;s implementation cannot call<br>&gt; that function internally. This is because the compiler enforces an<br>&gt; immutable `self` pointer value, and the `mutating` qualifier implies that<br>&gt; the function implementation may mutate that `self` pointer value.<br>&gt;<br>&gt; However, there seems to be a number of fairly reasonable situations where<br>&gt; a reference-type implementation of these `mutating` functions may only want<br>&gt; to mutate properties owned by `self`, but not the actual `self` pointer<br>&gt; value.<br>&gt;<br>&gt; Consider this toy example:<br>&gt;<br>&gt; ```<br>&gt; import Foundation<br>&gt;<br>&gt; protocol RandomDataTransformable {<br>&gt;     typealias TransformableType<br>&gt;     var data: [TransformableType] { get set }<br>&gt;<br>&gt;     mutating func addRandomData()<br>&gt; }<br>&gt;<br>&gt; extension RandomDataTransformable where TransformableType == Int {<br>&gt;     mutating func addRandomData() {<br>&gt;         let random = Int(arc4random_uniform(6) + 1)<br>&gt;         data.append(random)<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; /////<br>&gt;<br>&gt; // VALID<br>&gt; struct NumberSource_Struct : RandomDataTransformable {<br>&gt;     typealias TransformableType = Int<br>&gt;     var data: [Int] = []<br>&gt;<br>&gt;     mutating func addData() {<br>&gt;         addRandomData()<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; // VALID<br>&gt; class NumberSource_ClassDeclaration: NSObject, RandomDataTransformable {<br>&gt;     typealias TransformableType = Int<br>&gt;     var data: [Int] = []<br>&gt; }<br>&gt;<br>&gt; var numberSource = NumberSource_ClassDeclaration()<br>&gt; numberSource.addRandomData()<br>&gt;<br>&gt;<br>&gt; // INVALID<br>&gt; class NumberSource_ClassImplementation: NSObject, RandomDataTransformable {<br>&gt;     typealias TransformableType = Int<br>&gt;     var data: [Int] = []<br>&gt;<br>&gt;     func addData() {<br>&gt;         self.addRandomData() // Compiler Error: Cannot use mutating member<br>&gt; on immutable value: &#39;self&#39; is immutable<br>&gt;     }<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; Even despite the fact that the default implementation for `addRandomData`<br>&gt; does not mutate the `self` pointer value, reference-type implementations<br>&gt; are unable to call that function internally, since it is marked as<br>&gt; `mutating`.<br>&gt;<br>&gt; Perhaps confusingly, `addRandomData` may be called by externally, by<br>&gt; objects which own instances of the reference-type (even though, again, it<br>&gt; may not called internally by the implementation, itself).<br>&gt;<br>&gt; Currently, the only solution to allow reference-type implementations to<br>&gt; call the sample `addRandomData` implementation internally is to qualify the<br>&gt; whole `RandomDataTransformable` protocol as `class`. The downside here is<br>&gt; that this takes an otherwise perfectly reference- and struct-compatible<br>&gt; protocol + extension implementation and restricts it to only apply to<br>&gt; classes, decreasing overall code reusability.<br>&gt;<br>&gt; My proposal would be to introduce an intermediate mutation qualifier that<br>&gt; applies when protocols are adopted by reference-types. The qualifier would<br>&gt; specify that the `self` pointer value itself may not be mutated, but<br>&gt; `self`&#39;s properties may be, as appropriate.<br>&gt;<br>&gt; Thoughts, feedback on this?<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p><p><br>-- <br> Wizard<br>james at supmenow.com<br>+44 7523 279 698<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/a046d657/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: Intermediate mutation qualifier for protocol functions on reference-types</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 11, 2015 at 06:00:00pm</p></header><div class="content"><p>I&#39;m sorry, but this isn&#39;t an area that the open source swift team can help with, please check with official apple channels on that.<br></p><p>-Chris<br></p><p>&gt; On Dec 11, 2015, at 11:42 AM, James Campbell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hey Swift team can you tell the iTunes Connect team their website is down, there is no way to get a hold of them.<br>&gt; <br>&gt;&gt; On Thu, Dec 10, 2015 at 10:35 PM, Josh Avant via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Currently, when a reference-type adopts a protocol with a function declared as `mutating`, the reference-type&#39;s implementation cannot call that function internally. This is because the compiler enforces an immutable `self` pointer value, and the `mutating` qualifier implies that the function implementation may mutate that `self` pointer value.<br>&gt;&gt; <br>&gt;&gt; However, there seems to be a number of fairly reasonable situations where a reference-type implementation of these `mutating` functions may only want to mutate properties owned by `self`, but not the actual `self` pointer value.<br>&gt;&gt; <br>&gt;&gt; Consider this toy example:<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; import Foundation<br>&gt;&gt; <br>&gt;&gt; protocol RandomDataTransformable {<br>&gt;&gt;     typealias TransformableType<br>&gt;&gt;     var data: [TransformableType] { get set }<br>&gt;&gt;     <br>&gt;&gt;     mutating func addRandomData()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension RandomDataTransformable where TransformableType == Int {<br>&gt;&gt;     mutating func addRandomData() {<br>&gt;&gt;         let random = Int(arc4random_uniform(6) + 1)<br>&gt;&gt;         data.append(random)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; /////<br>&gt;&gt; <br>&gt;&gt; // VALID<br>&gt;&gt; struct NumberSource_Struct : RandomDataTransformable {<br>&gt;&gt;     typealias TransformableType = Int<br>&gt;&gt;     var data: [Int] = []<br>&gt;&gt;     <br>&gt;&gt;     mutating func addData() {<br>&gt;&gt;         addRandomData()<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; // VALID<br>&gt;&gt; class NumberSource_ClassDeclaration: NSObject, RandomDataTransformable {<br>&gt;&gt;     typealias TransformableType = Int<br>&gt;&gt;     var data: [Int] = []<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; var numberSource = NumberSource_ClassDeclaration()<br>&gt;&gt; numberSource.addRandomData()<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; // INVALID<br>&gt;&gt; class NumberSource_ClassImplementation: NSObject, RandomDataTransformable {<br>&gt;&gt;     typealias TransformableType = Int<br>&gt;&gt;     var data: [Int] = []<br>&gt;&gt;     <br>&gt;&gt;     func addData() {<br>&gt;&gt;         self.addRandomData() // Compiler Error: Cannot use mutating member on immutable value: &#39;self&#39; is immutable<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; Even despite the fact that the default implementation for `addRandomData` does not mutate the `self` pointer value, reference-type implementations are unable to call that function internally, since it is marked as `mutating`.<br>&gt;&gt; <br>&gt;&gt; Perhaps confusingly, `addRandomData` may be called by externally, by objects which own instances of the reference-type (even though, again, it may not called internally by the implementation, itself).<br>&gt;&gt; <br>&gt;&gt; Currently, the only solution to allow reference-type implementations to call the sample `addRandomData` implementation internally is to qualify the whole `RandomDataTransformable` protocol as `class`. The downside here is that this takes an otherwise perfectly reference- and struct-compatible protocol + extension implementation and restricts it to only apply to classes, decreasing overall code reusability.<br>&gt;&gt; <br>&gt;&gt; My proposal would be to introduce an intermediate mutation qualifier that applies when protocols are adopted by reference-types. The qualifier would specify that the `self` pointer value itself may not be mutated, but `self`&#39;s properties may be, as appropriate.<br>&gt;&gt; <br>&gt;&gt; Thoughts, feedback on this?<br>&gt;&gt;  <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt;  Wizard<br>&gt; james at supmenow.com<br>&gt; +44 7523 279 698<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/5dc23b94/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
