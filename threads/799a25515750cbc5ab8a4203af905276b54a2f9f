<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/886f7902c986a59d5cc184425d513c36?s=50"></div><header><strong>[Proposal draft] Introducing `indexed()` collections</strong> from <string>Tim Vermeulen</string> &lt;tvermeulen at me.com&gt;<p>September 28, 2016 at 10:00:00pm</p></header><div class="content"><p>I’m fairly sure that MutableCollection mutations are not allowed to invalidate any indices (for this exact reason). It would be great if someone could confirm this.<br></p><p>&gt; One (potentially dumb) question...<br>&gt; <br>&gt; If the actual indices are needed inside the loop, presumably this means they will be used in the loop, perhaps to mutate it, and if the collection is mutated won&#39;t that either invalidate (or change the relative correspondence of) the others indices, because the collection accessed in the loop will be the mutated one whereas the indices refer to the copy that was taken at the start when the &#39;for&#39; statement was evaluated?<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Wed, 28 Sep 2016 at 19:34 Sean Heber via swift-evolution&lt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)&gt;wrote:<br>&gt; &gt; This might just be me being silly, but is there any way to be able to do something like this instead:<br>&gt; &gt; <br>&gt; &gt; for (index, value) in sequence {<br>&gt; &gt; }<br>&gt; &gt; <br>&gt; &gt; Maybe by adding another variant of makeIterator() that only differs by the return type or something like that?<br>&gt; &gt; <br>&gt; &gt; I sort of dislike that enumerated() and indexed() would co-exist and potentially lead to really subtle bugs when getting them confused. Obviously removing enumerated() would be a breaking change, though, and maybe it has valuable uses that I’m not really thinking about (although it seems to me that the index/value pair is what you want like, 99% of the time and plenty of people - myself included - have been using the index of enumerated() as an array index even though that’s technically maybe not quite ‘correct&#39;).<br>&gt; &gt; <br>&gt; &gt; l8r<br>&gt; &gt; Sean<br>&gt; &gt; <br>&gt; &gt; <br>&gt; &gt; &gt;On Sep 28, 2016, at 12:55 PM, Erica Sadun via swift-evolution&lt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)&gt;wrote:<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;Gist here:https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3f2<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;Introducing indexed() collections<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;• Proposal: TBD<br>&gt; &gt; &gt;• Author: Erica Sadun, Nate Cook, Jacob Bandes-Storch, Kevin Ballard<br>&gt; &gt; &gt;• Status: TBD<br>&gt; &gt; &gt;• Review manager: TBD<br>&gt; &gt; &gt;Introduction<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;This proposal introduces indexed() to the standard library, a method on collections that returns an (index, element) tuple sequence.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;Swift-evolution thread: TBD<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;Motivation<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;The standard library&#39;s enumerated() method returns a sequence of pairs enumerating a sequence. The pair&#39;s first member is a monotonically incrementing integer starting at zero, and the second member is the corresponding element of the sequence. When working with arrays, the integer is coincidentally the same type and value as an Array index but the enumerated value is not generated with index-specific semantics. This may lead to confusion when developers attempt to subscript a non-array collection with enumerated integers. It can introduce serious bugs when developers use enumerated()-based integer subscripting with non-zero-based array slices.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;Indices have a specific, fixed meaning in Swift, which are used to create valid collection subscripts. This proposal introduces indexed() to produce a more semantically relevant sequence by pairing a collection&#39;s indices with its members. While it is trivial to create a solution in Swift, the most common developer approach shown here calculates indexes twice:<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;extension Collection {<br>&gt; &gt; &gt;/// Returns a sequence of pairs (*idx*, *x*), where *idx* represents a<br>&gt; &gt; &gt;/// consecutive collection index, and *x* represents an element of<br>&gt; &gt; &gt;/// the sequence.<br>&gt; &gt; &gt;func indexed() -&gt;Zip2Sequence&lt;Self.Indices, Self&gt;{<br>&gt; &gt; &gt;return zip(indices, self)<br>&gt; &gt; &gt;}<br>&gt; &gt; &gt;}<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;Incrementing an index in some collections can be unnecessarily costly. In a lazy filtered collection, an index increment is potentially O(N). We feel this is better addressed introducing a new function into the Standard Library to provide a more efficient design that avoids the attractive nuisance of the &quot;obvious&quot; solution.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;Detailed Design<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;Our vision of indexed() bypasses duplicated index generation with their potentially high computation costs. We&#39;d create an iterator that calculates each index once and then applies that index to subscript the collection. Implementation would take place through IndexedSequence, similar to EnumeratedSequence.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;Impact on Existing Code<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;This proposal is purely additive and has no impact on existing code.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;Alternatives Considered<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;Not yet<br>&gt; &gt; &gt;_______________________________________________<br>&gt; &gt; &gt;swift-evolution mailing list<br>&gt; &gt; &gt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)<br>&gt; &gt; &gt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; <br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org(mailto:swift-evolution at swift.org)<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt;<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
