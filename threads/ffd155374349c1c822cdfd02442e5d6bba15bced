<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8dfc6932943f38e7a7de48be3194f13c?s=50"></div><header><strong>[Proposal draft] Import as member</strong> from <string>Michael Ilseman</string> &lt;milseman at apple.com&gt;<p>March  2, 2016 at 11:00:00am</p></header><div class="content"><p>You can find the living document at: https://github.com/milseman/swift-evolution/blob/master/0000-import-as-member.md &lt;https://github.com/milseman/swift-evolution/blob/master/0000-import-as-member.md&gt;<br></p><p>For your convenience, here is the current state:<br></p><p>Import as member<br></p><p>Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;<br>Author(s): Michael Ilseman &lt;https://github.com/milseman&gt;<br>Status: Awaiting review<br>Review manager: TBD<br> &lt;https://github.com/milseman/swift-evolution/blob/master/0000-import-as-member.md#introduction&gt;Introduction<br></p><p>Swift imports C declarations, allowing Swift code to natively interact with C libraries and frameworks. But, such imported APIs do not feel natural to interact with in Swift. This proposal seeks to provide a mechanism for C API authors to specify the capability of importing functions and variables as members on imported Swift types. It also seeks to provide an automatic inference option for APIs that follow a consistent, disciplined naming convention.<br></p><p> &lt;https://github.com/milseman/swift-evolution/blob/master/0000-import-as-member.md#motivation&gt;Motivation<br></p><p>C APIs and frameworks currently import into Swift as global functions and global variables. Interacting with these can feel awkward in Swift. <br></p><p>Here&#39;s an example of programmatic drawing using the Core Graphics C API:<br></p><p>override func drawRect(rect: CGRect) {<br>    let context: CGContext = UIGraphicsGetCurrentContext()!<br>    let toCenter = CGPoint(x: bounds.width/2.0, y: bounds.height/2.0)<br>    let angle = CGFloat(M_PI / 16)<br></p><p>    var transform = CGAffineTransformIdentity<br>    for _ in 0..&lt;32 {<br>        triangulateRect(bounds, inputTransform: transform, context: context)<br>        transform = CGAffineTransformTranslate(transform, toCenter.x, toCenter.y)<br>        transform = CGAffineTransformRotate(transform, angle)<br>        transform = CGAffineTransformTranslate(transform, -toCenter.x, -toCenter.y)<br>    }<br>    CGContextSetLineWidth(context, bounds.size.width / 100)<br>    CGContextSetGrayStrokeColor(context, 0.5, 1.0)<br>    CGContextDrawPath(context, .Stroke)<br>}<br></p><p>func triangulateRect(bounds: CGRect, inputTransform: CGAffineTransform, <br>        context: CGContext) {<br>    var transform = inputTransform<br></p><p>    // Triangle from top left corner, to bottom middle, to top right, and then <br>    // draw the boundary<br>    let topLeft = bounds.origin<br>    let bottomRight = CGPoint(x: bounds.size.width, y: bounds.size.height)<br>    let path = CGPathCreateMutable()<br>    CGPathMoveToPoint(path, &amp;transform, topLeft.x, topLeft.y)<br>    CGPathAddLineToPoint(path, &amp;transform, CGRectGetMidX(bounds), bottomRight.y)<br>    CGPathAddLineToPoint(path, &amp;transform, bottomRight.x, topLeft.y)<br>    CGPathAddLineToPoint(path, &amp;transform, topLeft.x, topLeft.y)<br>    CGPathAddLineToPoint(path, &amp;transform, topLeft.x, bottomRight.y)<br>    CGPathAddLineToPoint(path, &amp;transform, bottomRight.x, bottomRight.y)<br>    CGPathAddLineToPoint(path, &amp;transform, bottomRight.x, topLeft.y)<br>    CGContextAddPath(context, path)<br>}<br>A much more natural expression of this in Swift, would be something more like:<br></p><p>override func drawRect(rect: CGRect) {<br>    let context: CGContext = UIGraphicsGetCurrentContext()!<br>    let toCenter = CGPoint(x: bounds.width/2.0, y: bounds.height/2.0)<br>    let angle = CGFloat(M_PI / 16)<br></p><p>    var transform = CGAffineTransform.identity<br>    for _ in 0..&lt;32 {<br>        triangulateRect(bounds, inputTransform: transform, context: context)<br>        transform = transform.translate(toX: toCenter.x, toY: toCenter.y)<br>                             .rotate(angle: angle)<br>                             .translate(toX: -toCenter.x, toY: -toCenter.y)<br>    }<br></p><p>    context.lineWidth = bounds.size.width / 100<br>    context.strokeColor = CGColor(gray: 0.5, alpha: 1.0)<br>    context.drawPath(mode: .Stroke)<br>}<br></p><p>func triangulateRect(bounds: CGRect, inputTransform: CGAffineTransform, <br>        context: CGContext) {<br>    var transform = inputTransform<br></p><p>    // Triangle from top left corner, to bottom middle, to top right, and then <br>    // draw the boundary<br>    let topLeft = bounds.origin<br>    let bottomRight = CGPoint(x: bounds.size.width, y: bounds.size.height)<br>    let path = CGMutablePath()<br>    path.move(transform: &amp;transform, x: topLeft.x, y: topLeft.y)<br>    path.addLine(transform: &amp;transform, x: bounds.midX, y: bottomRight.y)<br>    path.addLine(transform: &amp;transform, x: bottomRight.x, y: topLeft.y)<br>    path.addLine(transform: &amp;transform, x: topLeft.x, y: topLeft.y)<br>    path.addLine(transform: &amp;transform, x: topLeft.x, y: bottomRight.y)<br>    path.addLine(transform: &amp;transform, x: bottomRight.x, y: bottomRight.y)<br>    path.addLine(transform: &amp;transform, x: bottomRight.x, y: topLeft.y)<br>    context.addPath(path)<br>}<br>Currently, the only way for a C framework to provide a natural Swift experience is to author large overlays or Swift wrappers.<br></p><p> &lt;https://github.com/milseman/swift-evolution/blob/master/0000-import-as-member.md#proposed-solution&gt;Proposed solution<br></p><p> &lt;https://github.com/milseman/swift-evolution/blob/master/0000-import-as-member.md#manual-specification&gt;Manual specification<br></p><p>C framework authors should have a way to manually specify how their APIs appear in Swift beyond the limited functionality currently provided with NS_SWIFT_NAME. This includes the ability to specify a type on which a given variable or function should be imported. This also includes the ability to specify when a function should be imported as a computed getter or setter of a property on that type.<br></p><p>The goal is for developers using a C framework, which has these manual annotations applied, to develop in Swift as naturally as if they were working with a native object-oriented interface.<br></p><p> &lt;https://github.com/milseman/swift-evolution/blob/master/0000-import-as-member.md#automatic-inference&gt;Automatic inference<br></p><p>Coupled with this manual specification ability is an automatic inference system. The inference system analyzes C global names and types, attempting to find an imported Swift type to extend with a method, initializer, or property from this global.<br></p><p>This inference system&#39;s goal for the is to be able to automatically handle the majority of global variables and functions in CF-style frameworks, and in the future be extensible to benefit other well structured, disciplined APIs.<br></p><p> &lt;https://github.com/milseman/swift-evolution/blob/master/0000-import-as-member.md#maps-directly-onto-c-calling-convention&gt;Maps directly onto C calling convention<br></p><p>Wrappers and overlays have the downside that they result in an extra function call hop in order to reach the underlying C API (though fragility controls may somewhat alleviate this in the future).<br></p><p>This proposal calls for imported APIs to map directly onto the original C APIs, without calling through intermediary wrappers or overlaid definitions. For instance members, this means supplying a reference to self in the appropriate parameter slot.<br></p><p> &lt;https://github.com/milseman/swift-evolution/blob/master/0000-import-as-member.md#detailed-design&gt;Detailed design<br></p><p> &lt;https://github.com/milseman/swift-evolution/blob/master/0000-import-as-member.md#swift_name-attribute&gt;swift_name attribute<br></p><p>The primary mechanism of manually communicating to the Swift compiler how an API should be imported is the swift_name attribute (e.g. through the CF_SWIFT_NAME macro). swift_name will be expanded to allow the user to provide a type on which the imported function will be a member of, and allow for specifying a function as a computed getter or setter for a type.<br></p><p>Examples:<br></p><p>struct Point3D createPoint3D(float x, float y, float z) <br>__attribute__((swift_name(&quot;Point3D.init(x:y:z:)&quot;)));<br></p><p>struct Point3D rotatePoint3D(Point3D point, float radians) <br>__attribute__((swift_name(&quot;Point3D.rotate(self:radius:)&quot;)));<br></p><p>float Point3DGetMagnitude(Point3D point) <br>__attribute__((swift_name(&quot;getter:Point3D.magnitude(self:)&quot;)));<br>The string present in swift_name will additionally support the following:<br></p><p>A type name proceeded by &#39;.&#39; to denote the context to import onto<br>&#39;self&#39; to denote which parameter to treat as self for an instance &#39;method/property, otherwise this will be a static method/property<br>&#39;getter:&#39; and &#39;setter:&#39; to denote the function as a property getter/setter<br> &lt;https://github.com/milseman/swift-evolution/blob/master/0000-import-as-member.md#automatic-inference-heuristics&gt;Automatic inference heuristics<br></p><p>The following are some techniques and heuristics that can be useful for consistently named C APIs, e.g. CF-style frameworks. These heuristics are based off of the variable/function&#39;s name and type.<br></p><p>Identify init by return type<br>- func CGColorCreate(space: CGColorSpace?, _ components: UnsafePointer&lt;CGFloat&gt;)<br>-   -&gt; CGColor?<br></p><p>// extension CGColor { ...<br>+   init?(space: CGColorSpace?, components: UnsafePointer&lt;CGFloat&gt;)<br>Identify computed properties by finding &quot;get&quot; / &quot;set&quot; pairs <br>- func CGContextGetInterpolationQuality(c: CGContext?) -&gt; CGInterpolationQuality<br>- func CGContextSetInterpolationQuality(c: CGContext?,<br>-   _ quality: CGInterpolationQuality)<br></p><p>// extension CGContext { ...<br>+   final var interpolationQuality: CGInterpolationQuality<br>Identify boolean predicates and other computed property patterns<br>- func CGDisplayModeIsUsableForDesktopGUI(mode: CGDisplayMode?) -&gt; Bool<br></p><p>// extension CGDisplayMode {<br>+   final var isUsableForDesktopGUI: Bool { get }<br>Identify methods by finding a self parameter<br>- func CGAffineTransformInvert(t: CGAffineTransform) -&gt; CGAffineTransform<br></p><p>// extension CGAffineTransformation { ...<br>+   func invert() -&gt; CGAffineTransform<br>Various special cases, fuzzy name matching, etc.<br>- func CGDisplayStreamUpdateGetTypeID() -&gt; CFTypeID<br></p><p>// extension CGDisplayStreamUpdate { ...<br>+   final class var typeID: CFTypeID { get }<br></p><p>...<br></p><p>- func CGBitmapContextGetData(context: CGContext?) -&gt; UnsafeMutablePointer&lt;Void&gt;<br></p><p>// extension CGContext { ...<br>+   final var bitmapData: UnsafeMutablePointer&lt;Void&gt; { get }<br> &lt;https://github.com/milseman/swift-evolution/blob/master/0000-import-as-member.md#underlying-infrastructure&gt;Underlying infrastructure<br></p><p>The Clang Importer will be extended to support importing function and variable declarations onto different effective contexts than they appear in Clang. Additionally, the Clang Importer will want to create a single extension point per submodule/type pair on which to add these members.<br></p><p>SILGen will need to be extended to map calls to these members directly to the original C API calls, passing self in the appropriate parameter location for instance members.<br></p><p> &lt;https://github.com/milseman/swift-evolution/blob/master/0000-import-as-member.md#migration&gt;Migration<br></p><p>Projects using old style APIs will need to migrate to any new API. Since the proposed imports are done programmatically in the importer, migration attributes can be attached to the new decls, allowing the Swift migrator to automatically migrate user code.<br></p><p> &lt;https://github.com/milseman/swift-evolution/blob/master/0000-import-as-member.md#impact-on-existing-code&gt;Impact on existing code<br></p><p>Any Swift code using a C framework that uses this functionality will be massively affected, though in ways that the Swift migrator can alleviate.<br></p><p> &lt;https://github.com/milseman/swift-evolution/blob/master/0000-import-as-member.md#alternatives-considered&gt;Alternatives considered<br></p><p> &lt;https://github.com/milseman/swift-evolution/blob/master/0000-import-as-member.md#wrap-everything&gt;Wrap everything<br></p><p>One alternative, which is the only option available currently to framework authors, is to require C APIs to provide Swift wrapper APIs or overlays in order to call into the underlying C functionality.<br></p><p>This has the disadvantage of having to maintain separate APIs in addition to the C headers themselves. This proposal allows for the C header to specify how the name should appear when imported into Swift. Additionally, if a C API follows consistent, CF-like naming, most of it can be imported automatically<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160302/ffd1bced/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d92e9730c561c120200f34e7e50ed46?s=50"></div><header><strong>[Proposal draft] Import as member</strong> from <string>Jeff Kelley</string> &lt;slaunchaman at gmail.com&gt;<p>March  2, 2016 at 02:00:00pm</p></header><div class="content"><p>This is one of those proposals that I immediately agree with and want to start using! Definite +1.<br></p><p>It might make sense in another proposal, but one thing that jumps out to me is seeing &amp;context still used to pass a reference to the context around. I wonder if there’d be a good way to import these opaque reference types like CGContextRef and dispense with the &amp; altogether?<br></p><p><br>Jeff Kelley<br></p><p>SlaunchaMan at gmail.com | @SlaunchaMan &lt;https://twitter.com/SlaunchaMan&gt; | jeffkelley.org &lt;http://jeffkelley.org/&gt;<br>&gt; On Mar 2, 2016, at 2:43 PM, Michael Ilseman via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; You can find the living document at: https://github.com/milseman/swift-evolution/blob/master/0000-import-as-member.md &lt;https://github.com/milseman/swift-evolution/blob/master/0000-import-as-member.md&gt;<br>&gt; <br>&gt; For your convenience, here is the current state:<br>&gt; <br>&gt; Import as member<br>&gt; <br>&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;<br>&gt; Author(s): Michael Ilseman &lt;https://github.com/milseman&gt;<br>&gt; Status: Awaiting review<br>&gt; Review manager: TBD<br>&gt;  &lt;https://github.com/milseman/swift-evolution/blob/master/0000-import-as-member.md#introduction&gt;Introduction<br>&gt; <br>&gt; Swift imports C declarations, allowing Swift code to natively interact with C libraries and frameworks. But, such imported APIs do not feel natural to interact with in Swift. This proposal seeks to provide a mechanism for C API authors to specify the capability of importing functions and variables as members on imported Swift types. It also seeks to provide an automatic inference option for APIs that follow a consistent, disciplined naming convention.<br>&gt; <br>&gt;  &lt;https://github.com/milseman/swift-evolution/blob/master/0000-import-as-member.md#motivation&gt;Motivation<br>&gt; <br>&gt; C APIs and frameworks currently import into Swift as global functions and global variables. Interacting with these can feel awkward in Swift. <br>&gt; <br>&gt; Here&#39;s an example of programmatic drawing using the Core Graphics C API:<br>&gt; <br>&gt; override func drawRect(rect: CGRect) {<br>&gt;     let context: CGContext = UIGraphicsGetCurrentContext()!<br>&gt;     let toCenter = CGPoint(x: bounds.width/2.0, y: bounds.height/2.0)<br>&gt;     let angle = CGFloat(M_PI / 16)<br>&gt; <br>&gt;     var transform = CGAffineTransformIdentity<br>&gt;     for _ in 0..&lt;32 {<br>&gt;         triangulateRect(bounds, inputTransform: transform, context: context)<br>&gt;         transform = CGAffineTransformTranslate(transform, toCenter.x, toCenter.y)<br>&gt;         transform = CGAffineTransformRotate(transform, angle)<br>&gt;         transform = CGAffineTransformTranslate(transform, -toCenter.x, -toCenter.y)<br>&gt;     }<br>&gt;     CGContextSetLineWidth(context, bounds.size.width / 100)<br>&gt;     CGContextSetGrayStrokeColor(context, 0.5, 1.0)<br>&gt;     CGContextDrawPath(context, .Stroke)<br>&gt; }<br>&gt; <br>&gt; func triangulateRect(bounds: CGRect, inputTransform: CGAffineTransform, <br>&gt;         context: CGContext) {<br>&gt;     var transform = inputTransform<br>&gt; <br>&gt;     // Triangle from top left corner, to bottom middle, to top right, and then <br>&gt;     // draw the boundary<br>&gt;     let topLeft = bounds.origin<br>&gt;     let bottomRight = CGPoint(x: bounds.size.width, y: bounds.size.height)<br>&gt;     let path = CGPathCreateMutable()<br>&gt;     CGPathMoveToPoint(path, &amp;transform, topLeft.x, topLeft.y)<br>&gt;     CGPathAddLineToPoint(path, &amp;transform, CGRectGetMidX(bounds), bottomRight.y)<br>&gt;     CGPathAddLineToPoint(path, &amp;transform, bottomRight.x, topLeft.y)<br>&gt;     CGPathAddLineToPoint(path, &amp;transform, topLeft.x, topLeft.y)<br>&gt;     CGPathAddLineToPoint(path, &amp;transform, topLeft.x, bottomRight.y)<br>&gt;     CGPathAddLineToPoint(path, &amp;transform, bottomRight.x, bottomRight.y)<br>&gt;     CGPathAddLineToPoint(path, &amp;transform, bottomRight.x, topLeft.y)<br>&gt;     CGContextAddPath(context, path)<br>&gt; }<br>&gt; A much more natural expression of this in Swift, would be something more like:<br>&gt; <br>&gt; override func drawRect(rect: CGRect) {<br>&gt;     let context: CGContext = UIGraphicsGetCurrentContext()!<br>&gt;     let toCenter = CGPoint(x: bounds.width/2.0, y: bounds.height/2.0)<br>&gt;     let angle = CGFloat(M_PI / 16)<br>&gt; <br>&gt;     var transform = CGAffineTransform.identity<br>&gt;     for _ in 0..&lt;32 {<br>&gt;         triangulateRect(bounds, inputTransform: transform, context: context)<br>&gt;         transform = transform.translate(toX: toCenter.x, toY: toCenter.y)<br>&gt;                              .rotate(angle: angle)<br>&gt;                              .translate(toX: -toCenter.x, toY: -toCenter.y)<br>&gt;     }<br>&gt; <br>&gt;     context.lineWidth = bounds.size.width / 100<br>&gt;     context.strokeColor = CGColor(gray: 0.5, alpha: 1.0)<br>&gt;     context.drawPath(mode: .Stroke)<br>&gt; }<br>&gt; <br>&gt; func triangulateRect(bounds: CGRect, inputTransform: CGAffineTransform, <br>&gt;         context: CGContext) {<br>&gt;     var transform = inputTransform<br>&gt; <br>&gt;     // Triangle from top left corner, to bottom middle, to top right, and then <br>&gt;     // draw the boundary<br>&gt;     let topLeft = bounds.origin<br>&gt;     let bottomRight = CGPoint(x: bounds.size.width, y: bounds.size.height)<br>&gt;     let path = CGMutablePath()<br>&gt;     path.move(transform: &amp;transform, x: topLeft.x, y: topLeft.y)<br>&gt;     path.addLine(transform: &amp;transform, x: bounds.midX, y: bottomRight.y)<br>&gt;     path.addLine(transform: &amp;transform, x: bottomRight.x, y: topLeft.y)<br>&gt;     path.addLine(transform: &amp;transform, x: topLeft.x, y: topLeft.y)<br>&gt;     path.addLine(transform: &amp;transform, x: topLeft.x, y: bottomRight.y)<br>&gt;     path.addLine(transform: &amp;transform, x: bottomRight.x, y: bottomRight.y)<br>&gt;     path.addLine(transform: &amp;transform, x: bottomRight.x, y: topLeft.y)<br>&gt;     context.addPath(path)<br>&gt; }<br>&gt; Currently, the only way for a C framework to provide a natural Swift experience is to author large overlays or Swift wrappers.<br>&gt; <br>&gt;  &lt;https://github.com/milseman/swift-evolution/blob/master/0000-import-as-member.md#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt;  &lt;https://github.com/milseman/swift-evolution/blob/master/0000-import-as-member.md#manual-specification&gt;Manual specification<br>&gt; <br>&gt; C framework authors should have a way to manually specify how their APIs appear in Swift beyond the limited functionality currently provided with NS_SWIFT_NAME. This includes the ability to specify a type on which a given variable or function should be imported. This also includes the ability to specify when a function should be imported as a computed getter or setter of a property on that type.<br>&gt; <br>&gt; The goal is for developers using a C framework, which has these manual annotations applied, to develop in Swift as naturally as if they were working with a native object-oriented interface.<br>&gt; <br>&gt;  &lt;https://github.com/milseman/swift-evolution/blob/master/0000-import-as-member.md#automatic-inference&gt;Automatic inference<br>&gt; <br>&gt; Coupled with this manual specification ability is an automatic inference system. The inference system analyzes C global names and types, attempting to find an imported Swift type to extend with a method, initializer, or property from this global.<br>&gt; <br>&gt; This inference system&#39;s goal for the is to be able to automatically handle the majority of global variables and functions in CF-style frameworks, and in the future be extensible to benefit other well structured, disciplined APIs.<br>&gt; <br>&gt;  &lt;https://github.com/milseman/swift-evolution/blob/master/0000-import-as-member.md#maps-directly-onto-c-calling-convention&gt;Maps directly onto C calling convention<br>&gt; <br>&gt; Wrappers and overlays have the downside that they result in an extra function call hop in order to reach the underlying C API (though fragility controls may somewhat alleviate this in the future).<br>&gt; <br>&gt; This proposal calls for imported APIs to map directly onto the original C APIs, without calling through intermediary wrappers or overlaid definitions. For instance members, this means supplying a reference to self in the appropriate parameter slot.<br>&gt; <br>&gt;  &lt;https://github.com/milseman/swift-evolution/blob/master/0000-import-as-member.md#detailed-design&gt;Detailed design<br>&gt; <br>&gt;  &lt;https://github.com/milseman/swift-evolution/blob/master/0000-import-as-member.md#swift_name-attribute&gt;swift_name attribute<br>&gt; <br>&gt; The primary mechanism of manually communicating to the Swift compiler how an API should be imported is the swift_name attribute (e.g. through the CF_SWIFT_NAME macro). swift_name will be expanded to allow the user to provide a type on which the imported function will be a member of, and allow for specifying a function as a computed getter or setter for a type.<br>&gt; <br>&gt; Examples:<br>&gt; <br>&gt; struct Point3D createPoint3D(float x, float y, float z) <br>&gt; __attribute__((swift_name(&quot;Point3D.init(x:y:z:)&quot;)));<br>&gt; <br>&gt; struct Point3D rotatePoint3D(Point3D point, float radians) <br>&gt; __attribute__((swift_name(&quot;Point3D.rotate(self:radius:)&quot;)));<br>&gt; <br>&gt; float Point3DGetMagnitude(Point3D point) <br>&gt; __attribute__((swift_name(&quot;getter:Point3D.magnitude(self:)&quot;)));<br>&gt; The string present in swift_name will additionally support the following:<br>&gt; <br>&gt; A type name proceeded by &#39;.&#39; to denote the context to import onto<br>&gt; &#39;self&#39; to denote which parameter to treat as self for an instance &#39;method/property, otherwise this will be a static method/property<br>&gt; &#39;getter:&#39; and &#39;setter:&#39; to denote the function as a property getter/setter<br>&gt;  &lt;https://github.com/milseman/swift-evolution/blob/master/0000-import-as-member.md#automatic-inference-heuristics&gt;Automatic inference heuristics<br>&gt; <br>&gt; The following are some techniques and heuristics that can be useful for consistently named C APIs, e.g. CF-style frameworks. These heuristics are based off of the variable/function&#39;s name and type.<br>&gt; <br>&gt; Identify init by return type<br>&gt; - func CGColorCreate(space: CGColorSpace?, _ components: UnsafePointer&lt;CGFloat&gt;)<br>&gt; -   -&gt; CGColor?<br>&gt; <br>&gt; // extension CGColor { ...<br>&gt; +   init?(space: CGColorSpace?, components: UnsafePointer&lt;CGFloat&gt;)<br>&gt; Identify computed properties by finding &quot;get&quot; / &quot;set&quot; pairs <br>&gt; - func CGContextGetInterpolationQuality(c: CGContext?) -&gt; CGInterpolationQuality<br>&gt; - func CGContextSetInterpolationQuality(c: CGContext?,<br>&gt; -   _ quality: CGInterpolationQuality)<br>&gt; <br>&gt; // extension CGContext { ...<br>&gt; +   final var interpolationQuality: CGInterpolationQuality<br>&gt; Identify boolean predicates and other computed property patterns<br>&gt; - func CGDisplayModeIsUsableForDesktopGUI(mode: CGDisplayMode?) -&gt; Bool<br>&gt; <br>&gt; // extension CGDisplayMode {<br>&gt; +   final var isUsableForDesktopGUI: Bool { get }<br>&gt; Identify methods by finding a self parameter<br>&gt; - func CGAffineTransformInvert(t: CGAffineTransform) -&gt; CGAffineTransform<br>&gt; <br>&gt; // extension CGAffineTransformation { ...<br>&gt; +   func invert() -&gt; CGAffineTransform<br>&gt; Various special cases, fuzzy name matching, etc.<br>&gt; - func CGDisplayStreamUpdateGetTypeID() -&gt; CFTypeID<br>&gt; <br>&gt; // extension CGDisplayStreamUpdate { ...<br>&gt; +   final class var typeID: CFTypeID { get }<br>&gt; <br>&gt; ...<br>&gt; <br>&gt; - func CGBitmapContextGetData(context: CGContext?) -&gt; UnsafeMutablePointer&lt;Void&gt;<br>&gt; <br>&gt; // extension CGContext { ...<br>&gt; +   final var bitmapData: UnsafeMutablePointer&lt;Void&gt; { get }<br>&gt;  &lt;https://github.com/milseman/swift-evolution/blob/master/0000-import-as-member.md#underlying-infrastructure&gt;Underlying infrastructure<br>&gt; <br>&gt; The Clang Importer will be extended to support importing function and variable declarations onto different effective contexts than they appear in Clang. Additionally, the Clang Importer will want to create a single extension point per submodule/type pair on which to add these members.<br>&gt; <br>&gt; SILGen will need to be extended to map calls to these members directly to the original C API calls, passing self in the appropriate parameter location for instance members.<br>&gt; <br>&gt;  &lt;https://github.com/milseman/swift-evolution/blob/master/0000-import-as-member.md#migration&gt;Migration<br>&gt; <br>&gt; Projects using old style APIs will need to migrate to any new API. Since the proposed imports are done programmatically in the importer, migration attributes can be attached to the new decls, allowing the Swift migrator to automatically migrate user code.<br>&gt; <br>&gt;  &lt;https://github.com/milseman/swift-evolution/blob/master/0000-import-as-member.md#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; Any Swift code using a C framework that uses this functionality will be massively affected, though in ways that the Swift migrator can alleviate.<br>&gt; <br>&gt;  &lt;https://github.com/milseman/swift-evolution/blob/master/0000-import-as-member.md#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt;  &lt;https://github.com/milseman/swift-evolution/blob/master/0000-import-as-member.md#wrap-everything&gt;Wrap everything<br>&gt; <br>&gt; One alternative, which is the only option available currently to framework authors, is to require C APIs to provide Swift wrapper APIs or overlays in order to call into the underlying C functionality.<br>&gt; <br>&gt; This has the disadvantage of having to maintain separate APIs in addition to the C headers themselves. This proposal allows for the C header to specify how the name should appear when imported into Swift. Additionally, if a C API follows consistent, CF-like naming, most of it can be imported automatically<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160302/c567f6f4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8dfc6932943f38e7a7de48be3194f13c?s=50"></div><header><strong>[Proposal draft] Import as member</strong> from <string>Michael Ilseman</string> &lt;milseman at apple.com&gt;<p>March  2, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Mar 2, 2016, at 11:59 AM, Jeff Kelley &lt;slaunchaman at gmail.com&gt; wrote:<br>&gt; <br>&gt; This is one of those proposals that I immediately agree with and want to start using! Definite +1.<br>&gt; <br>&gt; It might make sense in another proposal, but one thing that jumps out to me is seeing &amp;context still used to pass a reference to the context around. I wonder if there’d be a good way to import these opaque reference types like CGContextRef and dispense with the &amp; altogether?<br>&gt; <br></p><p>I assume you mean the &amp;transform? Yes, that was particularly painful to write, as it seems like the API intention is more closely aligned with having an Optional&lt;CGAffineTransform&gt; here. Fixing that is probably outside of the scope of this proposal, or it might be possible to do orthogonally.<br></p><p><br></p><p>&gt; <br>&gt; Jeff Kelley<br>&gt; <br>&gt; SlaunchaMan at gmail.com &lt;mailto:SlaunchaMan at gmail.com&gt; | @SlaunchaMan &lt;https://twitter.com/SlaunchaMan&gt; | jeffkelley.org &lt;http://jeffkelley.org/&gt;<br>&gt;&gt; On Mar 2, 2016, at 2:43 PM, Michael Ilseman via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; You can find the living document at: https://github.com/milseman/swift-evolution/blob/master/0000-import-as-member.md &lt;https://github.com/milseman/swift-evolution/blob/master/0000-import-as-member.md&gt;<br>&gt;&gt; <br>&gt;&gt; For your convenience, here is the current state:<br>&gt;&gt; <br>&gt;&gt; Import as member<br>&gt;&gt; <br>&gt;&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;<br>&gt;&gt; Author(s): Michael Ilseman &lt;https://github.com/milseman&gt;<br>&gt;&gt; Status: Awaiting review<br>&gt;&gt; Review manager: TBD<br>&gt;&gt;  &lt;https://github.com/milseman/swift-evolution/blob/master/0000-import-as-member.md#introduction&gt;Introduction<br>&gt;&gt; <br>&gt;&gt; Swift imports C declarations, allowing Swift code to natively interact with C libraries and frameworks. But, such imported APIs do not feel natural to interact with in Swift. This proposal seeks to provide a mechanism for C API authors to specify the capability of importing functions and variables as members on imported Swift types. It also seeks to provide an automatic inference option for APIs that follow a consistent, disciplined naming convention.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/milseman/swift-evolution/blob/master/0000-import-as-member.md#motivation&gt;Motivation<br>&gt;&gt; <br>&gt;&gt; C APIs and frameworks currently import into Swift as global functions and global variables. Interacting with these can feel awkward in Swift. <br>&gt;&gt; <br>&gt;&gt; Here&#39;s an example of programmatic drawing using the Core Graphics C API:<br>&gt;&gt; <br>&gt;&gt; override func drawRect(rect: CGRect) {<br>&gt;&gt;     let context: CGContext = UIGraphicsGetCurrentContext()!<br>&gt;&gt;     let toCenter = CGPoint(x: bounds.width/2.0, y: bounds.height/2.0)<br>&gt;&gt;     let angle = CGFloat(M_PI / 16)<br>&gt;&gt; <br>&gt;&gt;     var transform = CGAffineTransformIdentity<br>&gt;&gt;     for _ in 0..&lt;32 {<br>&gt;&gt;         triangulateRect(bounds, inputTransform: transform, context: context)<br>&gt;&gt;         transform = CGAffineTransformTranslate(transform, toCenter.x, toCenter.y)<br>&gt;&gt;         transform = CGAffineTransformRotate(transform, angle)<br>&gt;&gt;         transform = CGAffineTransformTranslate(transform, -toCenter.x, -toCenter.y)<br>&gt;&gt;     }<br>&gt;&gt;     CGContextSetLineWidth(context, bounds.size.width / 100)<br>&gt;&gt;     CGContextSetGrayStrokeColor(context, 0.5, 1.0)<br>&gt;&gt;     CGContextDrawPath(context, .Stroke)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func triangulateRect(bounds: CGRect, inputTransform: CGAffineTransform, <br>&gt;&gt;         context: CGContext) {<br>&gt;&gt;     var transform = inputTransform<br>&gt;&gt; <br>&gt;&gt;     // Triangle from top left corner, to bottom middle, to top right, and then <br>&gt;&gt;     // draw the boundary<br>&gt;&gt;     let topLeft = bounds.origin<br>&gt;&gt;     let bottomRight = CGPoint(x: bounds.size.width, y: bounds.size.height)<br>&gt;&gt;     let path = CGPathCreateMutable()<br>&gt;&gt;     CGPathMoveToPoint(path, &amp;transform, topLeft.x, topLeft.y)<br>&gt;&gt;     CGPathAddLineToPoint(path, &amp;transform, CGRectGetMidX(bounds), bottomRight.y)<br>&gt;&gt;     CGPathAddLineToPoint(path, &amp;transform, bottomRight.x, topLeft.y)<br>&gt;&gt;     CGPathAddLineToPoint(path, &amp;transform, topLeft.x, topLeft.y)<br>&gt;&gt;     CGPathAddLineToPoint(path, &amp;transform, topLeft.x, bottomRight.y)<br>&gt;&gt;     CGPathAddLineToPoint(path, &amp;transform, bottomRight.x, bottomRight.y)<br>&gt;&gt;     CGPathAddLineToPoint(path, &amp;transform, bottomRight.x, topLeft.y)<br>&gt;&gt;     CGContextAddPath(context, path)<br>&gt;&gt; }<br>&gt;&gt; A much more natural expression of this in Swift, would be something more like:<br>&gt;&gt; <br>&gt;&gt; override func drawRect(rect: CGRect) {<br>&gt;&gt;     let context: CGContext = UIGraphicsGetCurrentContext()!<br>&gt;&gt;     let toCenter = CGPoint(x: bounds.width/2.0, y: bounds.height/2.0)<br>&gt;&gt;     let angle = CGFloat(M_PI / 16)<br>&gt;&gt; <br>&gt;&gt;     var transform = CGAffineTransform.identity<br>&gt;&gt;     for _ in 0..&lt;32 {<br>&gt;&gt;         triangulateRect(bounds, inputTransform: transform, context: context)<br>&gt;&gt;         transform = transform.translate(toX: toCenter.x, toY: toCenter.y)<br>&gt;&gt;                              .rotate(angle: angle)<br>&gt;&gt;                              .translate(toX: -toCenter.x, toY: -toCenter.y)<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     context.lineWidth = bounds.size.width / 100<br>&gt;&gt;     context.strokeColor = CGColor(gray: 0.5, alpha: 1.0)<br>&gt;&gt;     context.drawPath(mode: .Stroke)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func triangulateRect(bounds: CGRect, inputTransform: CGAffineTransform, <br>&gt;&gt;         context: CGContext) {<br>&gt;&gt;     var transform = inputTransform<br>&gt;&gt; <br>&gt;&gt;     // Triangle from top left corner, to bottom middle, to top right, and then <br>&gt;&gt;     // draw the boundary<br>&gt;&gt;     let topLeft = bounds.origin<br>&gt;&gt;     let bottomRight = CGPoint(x: bounds.size.width, y: bounds.size.height)<br>&gt;&gt;     let path = CGMutablePath()<br>&gt;&gt;     path.move(transform: &amp;transform, x: topLeft.x, y: topLeft.y)<br>&gt;&gt;     path.addLine(transform: &amp;transform, x: bounds.midX, y: bottomRight.y)<br>&gt;&gt;     path.addLine(transform: &amp;transform, x: bottomRight.x, y: topLeft.y)<br>&gt;&gt;     path.addLine(transform: &amp;transform, x: topLeft.x, y: topLeft.y)<br>&gt;&gt;     path.addLine(transform: &amp;transform, x: topLeft.x, y: bottomRight.y)<br>&gt;&gt;     path.addLine(transform: &amp;transform, x: bottomRight.x, y: bottomRight.y)<br>&gt;&gt;     path.addLine(transform: &amp;transform, x: bottomRight.x, y: topLeft.y)<br>&gt;&gt;     context.addPath(path)<br>&gt;&gt; }<br>&gt;&gt; Currently, the only way for a C framework to provide a natural Swift experience is to author large overlays or Swift wrappers.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/milseman/swift-evolution/blob/master/0000-import-as-member.md#proposed-solution&gt;Proposed solution<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/milseman/swift-evolution/blob/master/0000-import-as-member.md#manual-specification&gt;Manual specification<br>&gt;&gt; <br>&gt;&gt; C framework authors should have a way to manually specify how their APIs appear in Swift beyond the limited functionality currently provided with NS_SWIFT_NAME. This includes the ability to specify a type on which a given variable or function should be imported. This also includes the ability to specify when a function should be imported as a computed getter or setter of a property on that type.<br>&gt;&gt; <br>&gt;&gt; The goal is for developers using a C framework, which has these manual annotations applied, to develop in Swift as naturally as if they were working with a native object-oriented interface.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/milseman/swift-evolution/blob/master/0000-import-as-member.md#automatic-inference&gt;Automatic inference<br>&gt;&gt; <br>&gt;&gt; Coupled with this manual specification ability is an automatic inference system. The inference system analyzes C global names and types, attempting to find an imported Swift type to extend with a method, initializer, or property from this global.<br>&gt;&gt; <br>&gt;&gt; This inference system&#39;s goal for the is to be able to automatically handle the majority of global variables and functions in CF-style frameworks, and in the future be extensible to benefit other well structured, disciplined APIs.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/milseman/swift-evolution/blob/master/0000-import-as-member.md#maps-directly-onto-c-calling-convention&gt;Maps directly onto C calling convention<br>&gt;&gt; <br>&gt;&gt; Wrappers and overlays have the downside that they result in an extra function call hop in order to reach the underlying C API (though fragility controls may somewhat alleviate this in the future).<br>&gt;&gt; <br>&gt;&gt; This proposal calls for imported APIs to map directly onto the original C APIs, without calling through intermediary wrappers or overlaid definitions. For instance members, this means supplying a reference to self in the appropriate parameter slot.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/milseman/swift-evolution/blob/master/0000-import-as-member.md#detailed-design&gt;Detailed design<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/milseman/swift-evolution/blob/master/0000-import-as-member.md#swift_name-attribute&gt;swift_name attribute<br>&gt;&gt; <br>&gt;&gt; The primary mechanism of manually communicating to the Swift compiler how an API should be imported is the swift_name attribute (e.g. through the CF_SWIFT_NAME macro). swift_name will be expanded to allow the user to provide a type on which the imported function will be a member of, and allow for specifying a function as a computed getter or setter for a type.<br>&gt;&gt; <br>&gt;&gt; Examples:<br>&gt;&gt; <br>&gt;&gt; struct Point3D createPoint3D(float x, float y, float z) <br>&gt;&gt; __attribute__((swift_name(&quot;Point3D.init(x:y:z:)&quot;)));<br>&gt;&gt; <br>&gt;&gt; struct Point3D rotatePoint3D(Point3D point, float radians) <br>&gt;&gt; __attribute__((swift_name(&quot;Point3D.rotate(self:radius:)&quot;)));<br>&gt;&gt; <br>&gt;&gt; float Point3DGetMagnitude(Point3D point) <br>&gt;&gt; __attribute__((swift_name(&quot;getter:Point3D.magnitude(self:)&quot;)));<br>&gt;&gt; The string present in swift_name will additionally support the following:<br>&gt;&gt; <br>&gt;&gt; A type name proceeded by &#39;.&#39; to denote the context to import onto<br>&gt;&gt; &#39;self&#39; to denote which parameter to treat as self for an instance &#39;method/property, otherwise this will be a static method/property<br>&gt;&gt; &#39;getter:&#39; and &#39;setter:&#39; to denote the function as a property getter/setter<br>&gt;&gt;  &lt;https://github.com/milseman/swift-evolution/blob/master/0000-import-as-member.md#automatic-inference-heuristics&gt;Automatic inference heuristics<br>&gt;&gt; <br>&gt;&gt; The following are some techniques and heuristics that can be useful for consistently named C APIs, e.g. CF-style frameworks. These heuristics are based off of the variable/function&#39;s name and type.<br>&gt;&gt; <br>&gt;&gt; Identify init by return type<br>&gt;&gt; - func CGColorCreate(space: CGColorSpace?, _ components: UnsafePointer&lt;CGFloat&gt;)<br>&gt;&gt; -   -&gt; CGColor?<br>&gt;&gt; <br>&gt;&gt; // extension CGColor { ...<br>&gt;&gt; +   init?(space: CGColorSpace?, components: UnsafePointer&lt;CGFloat&gt;)<br>&gt;&gt; Identify computed properties by finding &quot;get&quot; / &quot;set&quot; pairs <br>&gt;&gt; - func CGContextGetInterpolationQuality(c: CGContext?) -&gt; CGInterpolationQuality<br>&gt;&gt; - func CGContextSetInterpolationQuality(c: CGContext?,<br>&gt;&gt; -   _ quality: CGInterpolationQuality)<br>&gt;&gt; <br>&gt;&gt; // extension CGContext { ...<br>&gt;&gt; +   final var interpolationQuality: CGInterpolationQuality<br>&gt;&gt; Identify boolean predicates and other computed property patterns<br>&gt;&gt; - func CGDisplayModeIsUsableForDesktopGUI(mode: CGDisplayMode?) -&gt; Bool<br>&gt;&gt; <br>&gt;&gt; // extension CGDisplayMode {<br>&gt;&gt; +   final var isUsableForDesktopGUI: Bool { get }<br>&gt;&gt; Identify methods by finding a self parameter<br>&gt;&gt; - func CGAffineTransformInvert(t: CGAffineTransform) -&gt; CGAffineTransform<br>&gt;&gt; <br>&gt;&gt; // extension CGAffineTransformation { ...<br>&gt;&gt; +   func invert() -&gt; CGAffineTransform<br>&gt;&gt; Various special cases, fuzzy name matching, etc.<br>&gt;&gt; - func CGDisplayStreamUpdateGetTypeID() -&gt; CFTypeID<br>&gt;&gt; <br>&gt;&gt; // extension CGDisplayStreamUpdate { ...<br>&gt;&gt; +   final class var typeID: CFTypeID { get }<br>&gt;&gt; <br>&gt;&gt; ...<br>&gt;&gt; <br>&gt;&gt; - func CGBitmapContextGetData(context: CGContext?) -&gt; UnsafeMutablePointer&lt;Void&gt;<br>&gt;&gt; <br>&gt;&gt; // extension CGContext { ...<br>&gt;&gt; +   final var bitmapData: UnsafeMutablePointer&lt;Void&gt; { get }<br>&gt;&gt;  &lt;https://github.com/milseman/swift-evolution/blob/master/0000-import-as-member.md#underlying-infrastructure&gt;Underlying infrastructure<br>&gt;&gt; <br>&gt;&gt; The Clang Importer will be extended to support importing function and variable declarations onto different effective contexts than they appear in Clang. Additionally, the Clang Importer will want to create a single extension point per submodule/type pair on which to add these members.<br>&gt;&gt; <br>&gt;&gt; SILGen will need to be extended to map calls to these members directly to the original C API calls, passing self in the appropriate parameter location for instance members.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/milseman/swift-evolution/blob/master/0000-import-as-member.md#migration&gt;Migration<br>&gt;&gt; <br>&gt;&gt; Projects using old style APIs will need to migrate to any new API. Since the proposed imports are done programmatically in the importer, migration attributes can be attached to the new decls, allowing the Swift migrator to automatically migrate user code.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/milseman/swift-evolution/blob/master/0000-import-as-member.md#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt; <br>&gt;&gt; Any Swift code using a C framework that uses this functionality will be massively affected, though in ways that the Swift migrator can alleviate.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/milseman/swift-evolution/blob/master/0000-import-as-member.md#alternatives-considered&gt;Alternatives considered<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/milseman/swift-evolution/blob/master/0000-import-as-member.md#wrap-everything&gt;Wrap everything<br>&gt;&gt; <br>&gt;&gt; One alternative, which is the only option available currently to framework authors, is to require C APIs to provide Swift wrapper APIs or overlays in order to call into the underlying C functionality.<br>&gt;&gt; <br>&gt;&gt; This has the disadvantage of having to maintain separate APIs in addition to the C headers themselves. This proposal allows for the C header to specify how the name should appear when imported into Swift. Additionally, if a C API follows consistent, CF-like naming, most of it can be imported automatically<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160302/8db9a837/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d92e9730c561c120200f34e7e50ed46?s=50"></div><header><strong>[Proposal draft] Import as member</strong> from <string>Jeff Kelley</string> &lt;slaunchaman at gmail.com&gt;<p>March  2, 2016 at 03:00:00pm</p></header><div class="content"><p>Yes, I meant &amp;transform. I think this proposal is more immediately helpful. If I have time I’ll draft an additional proposal for your Optional suggestion. 👍<br></p><p><br>Jeff Kelley<br></p><p>SlaunchaMan at gmail.com | @SlaunchaMan &lt;https://twitter.com/SlaunchaMan&gt; | jeffkelley.org &lt;http://jeffkelley.org/&gt;<br>&gt; On Mar 2, 2016, at 3:33 PM, Michael Ilseman &lt;milseman at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Mar 2, 2016, at 11:59 AM, Jeff Kelley &lt;slaunchaman at gmail.com &lt;mailto:slaunchaman at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This is one of those proposals that I immediately agree with and want to start using! Definite +1.<br>&gt;&gt; <br>&gt;&gt; It might make sense in another proposal, but one thing that jumps out to me is seeing &amp;context still used to pass a reference to the context around. I wonder if there’d be a good way to import these opaque reference types like CGContextRef and dispense with the &amp; altogether?<br>&gt;&gt; <br>&gt; <br>&gt; I assume you mean the &amp;transform? Yes, that was particularly painful to write, as it seems like the API intention is more closely aligned with having an Optional&lt;CGAffineTransform&gt; here. Fixing that is probably outside of the scope of this proposal, or it might be possible to do orthogonally.<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; Jeff Kelley<br>&gt;&gt; <br>&gt;&gt; SlaunchaMan at gmail.com &lt;mailto:SlaunchaMan at gmail.com&gt; | @SlaunchaMan &lt;https://twitter.com/SlaunchaMan&gt; | jeffkelley.org &lt;http://jeffkelley.org/&gt;<br>&gt;&gt;&gt; On Mar 2, 2016, at 2:43 PM, Michael Ilseman via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You can find the living document at: https://github.com/milseman/swift-evolution/blob/master/0000-import-as-member.md &lt;https://github.com/milseman/swift-evolution/blob/master/0000-import-as-member.md&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For your convenience, here is the current state:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Import as member<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;<br>&gt;&gt;&gt; Author(s): Michael Ilseman &lt;https://github.com/milseman&gt;<br>&gt;&gt;&gt; Status: Awaiting review<br>&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt;  &lt;https://github.com/milseman/swift-evolution/blob/master/0000-import-as-member.md#introduction&gt;Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift imports C declarations, allowing Swift code to natively interact with C libraries and frameworks. But, such imported APIs do not feel natural to interact with in Swift. This proposal seeks to provide a mechanism for C API authors to specify the capability of importing functions and variables as members on imported Swift types. It also seeks to provide an automatic inference option for APIs that follow a consistent, disciplined naming convention.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/milseman/swift-evolution/blob/master/0000-import-as-member.md#motivation&gt;Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; C APIs and frameworks currently import into Swift as global functions and global variables. Interacting with these can feel awkward in Swift. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here&#39;s an example of programmatic drawing using the Core Graphics C API:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; override func drawRect(rect: CGRect) {<br>&gt;&gt;&gt;     let context: CGContext = UIGraphicsGetCurrentContext()!<br>&gt;&gt;&gt;     let toCenter = CGPoint(x: bounds.width/2.0, y: bounds.height/2.0)<br>&gt;&gt;&gt;     let angle = CGFloat(M_PI / 16)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     var transform = CGAffineTransformIdentity<br>&gt;&gt;&gt;     for _ in 0..&lt;32 {<br>&gt;&gt;&gt;         triangulateRect(bounds, inputTransform: transform, context: context)<br>&gt;&gt;&gt;         transform = CGAffineTransformTranslate(transform, toCenter.x, toCenter.y)<br>&gt;&gt;&gt;         transform = CGAffineTransformRotate(transform, angle)<br>&gt;&gt;&gt;         transform = CGAffineTransformTranslate(transform, -toCenter.x, -toCenter.y)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     CGContextSetLineWidth(context, bounds.size.width / 100)<br>&gt;&gt;&gt;     CGContextSetGrayStrokeColor(context, 0.5, 1.0)<br>&gt;&gt;&gt;     CGContextDrawPath(context, .Stroke)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func triangulateRect(bounds: CGRect, inputTransform: CGAffineTransform, <br>&gt;&gt;&gt;         context: CGContext) {<br>&gt;&gt;&gt;     var transform = inputTransform<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     // Triangle from top left corner, to bottom middle, to top right, and then <br>&gt;&gt;&gt;     // draw the boundary<br>&gt;&gt;&gt;     let topLeft = bounds.origin<br>&gt;&gt;&gt;     let bottomRight = CGPoint(x: bounds.size.width, y: bounds.size.height)<br>&gt;&gt;&gt;     let path = CGPathCreateMutable()<br>&gt;&gt;&gt;     CGPathMoveToPoint(path, &amp;transform, topLeft.x, topLeft.y)<br>&gt;&gt;&gt;     CGPathAddLineToPoint(path, &amp;transform, CGRectGetMidX(bounds), bottomRight.y)<br>&gt;&gt;&gt;     CGPathAddLineToPoint(path, &amp;transform, bottomRight.x, topLeft.y)<br>&gt;&gt;&gt;     CGPathAddLineToPoint(path, &amp;transform, topLeft.x, topLeft.y)<br>&gt;&gt;&gt;     CGPathAddLineToPoint(path, &amp;transform, topLeft.x, bottomRight.y)<br>&gt;&gt;&gt;     CGPathAddLineToPoint(path, &amp;transform, bottomRight.x, bottomRight.y)<br>&gt;&gt;&gt;     CGPathAddLineToPoint(path, &amp;transform, bottomRight.x, topLeft.y)<br>&gt;&gt;&gt;     CGContextAddPath(context, path)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; A much more natural expression of this in Swift, would be something more like:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; override func drawRect(rect: CGRect) {<br>&gt;&gt;&gt;     let context: CGContext = UIGraphicsGetCurrentContext()!<br>&gt;&gt;&gt;     let toCenter = CGPoint(x: bounds.width/2.0, y: bounds.height/2.0)<br>&gt;&gt;&gt;     let angle = CGFloat(M_PI / 16)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     var transform = CGAffineTransform.identity<br>&gt;&gt;&gt;     for _ in 0..&lt;32 {<br>&gt;&gt;&gt;         triangulateRect(bounds, inputTransform: transform, context: context)<br>&gt;&gt;&gt;         transform = transform.translate(toX: toCenter.x, toY: toCenter.y)<br>&gt;&gt;&gt;                              .rotate(angle: angle)<br>&gt;&gt;&gt;                              .translate(toX: -toCenter.x, toY: -toCenter.y)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     context.lineWidth = bounds.size.width / 100<br>&gt;&gt;&gt;     context.strokeColor = CGColor(gray: 0.5, alpha: 1.0)<br>&gt;&gt;&gt;     context.drawPath(mode: .Stroke)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func triangulateRect(bounds: CGRect, inputTransform: CGAffineTransform, <br>&gt;&gt;&gt;         context: CGContext) {<br>&gt;&gt;&gt;     var transform = inputTransform<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     // Triangle from top left corner, to bottom middle, to top right, and then <br>&gt;&gt;&gt;     // draw the boundary<br>&gt;&gt;&gt;     let topLeft = bounds.origin<br>&gt;&gt;&gt;     let bottomRight = CGPoint(x: bounds.size.width, y: bounds.size.height)<br>&gt;&gt;&gt;     let path = CGMutablePath()<br>&gt;&gt;&gt;     path.move(transform: &amp;transform, x: topLeft.x, y: topLeft.y)<br>&gt;&gt;&gt;     path.addLine(transform: &amp;transform, x: bounds.midX, y: bottomRight.y)<br>&gt;&gt;&gt;     path.addLine(transform: &amp;transform, x: bottomRight.x, y: topLeft.y)<br>&gt;&gt;&gt;     path.addLine(transform: &amp;transform, x: topLeft.x, y: topLeft.y)<br>&gt;&gt;&gt;     path.addLine(transform: &amp;transform, x: topLeft.x, y: bottomRight.y)<br>&gt;&gt;&gt;     path.addLine(transform: &amp;transform, x: bottomRight.x, y: bottomRight.y)<br>&gt;&gt;&gt;     path.addLine(transform: &amp;transform, x: bottomRight.x, y: topLeft.y)<br>&gt;&gt;&gt;     context.addPath(path)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; Currently, the only way for a C framework to provide a natural Swift experience is to author large overlays or Swift wrappers.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/milseman/swift-evolution/blob/master/0000-import-as-member.md#proposed-solution&gt;Proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/milseman/swift-evolution/blob/master/0000-import-as-member.md#manual-specification&gt;Manual specification<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; C framework authors should have a way to manually specify how their APIs appear in Swift beyond the limited functionality currently provided with NS_SWIFT_NAME. This includes the ability to specify a type on which a given variable or function should be imported. This also includes the ability to specify when a function should be imported as a computed getter or setter of a property on that type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The goal is for developers using a C framework, which has these manual annotations applied, to develop in Swift as naturally as if they were working with a native object-oriented interface.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/milseman/swift-evolution/blob/master/0000-import-as-member.md#automatic-inference&gt;Automatic inference<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Coupled with this manual specification ability is an automatic inference system. The inference system analyzes C global names and types, attempting to find an imported Swift type to extend with a method, initializer, or property from this global.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This inference system&#39;s goal for the is to be able to automatically handle the majority of global variables and functions in CF-style frameworks, and in the future be extensible to benefit other well structured, disciplined APIs.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/milseman/swift-evolution/blob/master/0000-import-as-member.md#maps-directly-onto-c-calling-convention&gt;Maps directly onto C calling convention<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Wrappers and overlays have the downside that they result in an extra function call hop in order to reach the underlying C API (though fragility controls may somewhat alleviate this in the future).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This proposal calls for imported APIs to map directly onto the original C APIs, without calling through intermediary wrappers or overlaid definitions. For instance members, this means supplying a reference to self in the appropriate parameter slot.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/milseman/swift-evolution/blob/master/0000-import-as-member.md#detailed-design&gt;Detailed design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/milseman/swift-evolution/blob/master/0000-import-as-member.md#swift_name-attribute&gt;swift_name attribute<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The primary mechanism of manually communicating to the Swift compiler how an API should be imported is the swift_name attribute (e.g. through the CF_SWIFT_NAME macro). swift_name will be expanded to allow the user to provide a type on which the imported function will be a member of, and allow for specifying a function as a computed getter or setter for a type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Examples:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Point3D createPoint3D(float x, float y, float z) <br>&gt;&gt;&gt; __attribute__((swift_name(&quot;Point3D.init(x:y:z:)&quot;)));<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Point3D rotatePoint3D(Point3D point, float radians) <br>&gt;&gt;&gt; __attribute__((swift_name(&quot;Point3D.rotate(self:radius:)&quot;)));<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; float Point3DGetMagnitude(Point3D point) <br>&gt;&gt;&gt; __attribute__((swift_name(&quot;getter:Point3D.magnitude(self:)&quot;)));<br>&gt;&gt;&gt; The string present in swift_name will additionally support the following:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A type name proceeded by &#39;.&#39; to denote the context to import onto<br>&gt;&gt;&gt; &#39;self&#39; to denote which parameter to treat as self for an instance &#39;method/property, otherwise this will be a static method/property<br>&gt;&gt;&gt; &#39;getter:&#39; and &#39;setter:&#39; to denote the function as a property getter/setter<br>&gt;&gt;&gt;  &lt;https://github.com/milseman/swift-evolution/blob/master/0000-import-as-member.md#automatic-inference-heuristics&gt;Automatic inference heuristics<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The following are some techniques and heuristics that can be useful for consistently named C APIs, e.g. CF-style frameworks. These heuristics are based off of the variable/function&#39;s name and type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Identify init by return type<br>&gt;&gt;&gt; - func CGColorCreate(space: CGColorSpace?, _ components: UnsafePointer&lt;CGFloat&gt;)<br>&gt;&gt;&gt; -   -&gt; CGColor?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // extension CGColor { ...<br>&gt;&gt;&gt; +   init?(space: CGColorSpace?, components: UnsafePointer&lt;CGFloat&gt;)<br>&gt;&gt;&gt; Identify computed properties by finding &quot;get&quot; / &quot;set&quot; pairs <br>&gt;&gt;&gt; - func CGContextGetInterpolationQuality(c: CGContext?) -&gt; CGInterpolationQuality<br>&gt;&gt;&gt; - func CGContextSetInterpolationQuality(c: CGContext?,<br>&gt;&gt;&gt; -   _ quality: CGInterpolationQuality)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // extension CGContext { ...<br>&gt;&gt;&gt; +   final var interpolationQuality: CGInterpolationQuality<br>&gt;&gt;&gt; Identify boolean predicates and other computed property patterns<br>&gt;&gt;&gt; - func CGDisplayModeIsUsableForDesktopGUI(mode: CGDisplayMode?) -&gt; Bool<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // extension CGDisplayMode {<br>&gt;&gt;&gt; +   final var isUsableForDesktopGUI: Bool { get }<br>&gt;&gt;&gt; Identify methods by finding a self parameter<br>&gt;&gt;&gt; - func CGAffineTransformInvert(t: CGAffineTransform) -&gt; CGAffineTransform<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // extension CGAffineTransformation { ...<br>&gt;&gt;&gt; +   func invert() -&gt; CGAffineTransform<br>&gt;&gt;&gt; Various special cases, fuzzy name matching, etc.<br>&gt;&gt;&gt; - func CGDisplayStreamUpdateGetTypeID() -&gt; CFTypeID<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // extension CGDisplayStreamUpdate { ...<br>&gt;&gt;&gt; +   final class var typeID: CFTypeID { get }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - func CGBitmapContextGetData(context: CGContext?) -&gt; UnsafeMutablePointer&lt;Void&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // extension CGContext { ...<br>&gt;&gt;&gt; +   final var bitmapData: UnsafeMutablePointer&lt;Void&gt; { get }<br>&gt;&gt;&gt;  &lt;https://github.com/milseman/swift-evolution/blob/master/0000-import-as-member.md#underlying-infrastructure&gt;Underlying infrastructure<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The Clang Importer will be extended to support importing function and variable declarations onto different effective contexts than they appear in Clang. Additionally, the Clang Importer will want to create a single extension point per submodule/type pair on which to add these members.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; SILGen will need to be extended to map calls to these members directly to the original C API calls, passing self in the appropriate parameter location for instance members.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/milseman/swift-evolution/blob/master/0000-import-as-member.md#migration&gt;Migration<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Projects using old style APIs will need to migrate to any new API. Since the proposed imports are done programmatically in the importer, migration attributes can be attached to the new decls, allowing the Swift migrator to automatically migrate user code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/milseman/swift-evolution/blob/master/0000-import-as-member.md#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Any Swift code using a C framework that uses this functionality will be massively affected, though in ways that the Swift migrator can alleviate.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/milseman/swift-evolution/blob/master/0000-import-as-member.md#alternatives-considered&gt;Alternatives considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/milseman/swift-evolution/blob/master/0000-import-as-member.md#wrap-everything&gt;Wrap everything<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One alternative, which is the only option available currently to framework authors, is to require C APIs to provide Swift wrapper APIs or overlays in order to call into the underlying C functionality.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This has the disadvantage of having to maintain separate APIs in addition to the C headers themselves. This proposal allows for the C header to specify how the name should appear when imported into Swift. Additionally, if a C API follows consistent, CF-like naming, most of it can be imported automatically<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160302/7c7328d9/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
