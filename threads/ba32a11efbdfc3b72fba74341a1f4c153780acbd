<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3283e69dac603660e4abad5fef6f538?s=50"></div><header><strong>[Proposal] Remove force unwrapping in function signature.</strong> from <string>Spromicky</string> &lt;spromicky at gmail.com&gt;<p>June 29, 2016 at 12:00:00pm</p></header><div class="content"><p>Hi Chris! It proposal only about function parameters, not about all IUO. In some cases IUO is great solution. For example class properties. If you write something like this <br></p><p>var bar: Int!<br></p><p>It is clearly understandable that you wanna say “Yes, in some moment after init `bar` will be `nil`, but it will be initialised before use, I guarantee this.” Its great and useful. In this code:<br></p><p>func foo(bar: Int!) {<br>    //...<br>}<br></p><p>what we wanna say? “You can pass `nil`, but i do not wanna unwrap this” or “I guarantee that bar will be unwrapped”? I think parameters T! make no sense for function signature. You clearly understand what you wanna see as parameter in function - optional or non-optional.<br></p><p>And what about legacy Obj-C code.<br>We can understand why we use this when import legacy Obj-C code without nullability annotations. In Obj-C we can have valid methods, that get `nil` as parameter. For example:<br></p><p>- (void)foo:(UINavigationController *)navController<br>{<br>    [navController popViewControllerAnimated:YES];<br>}<br></p><p>or not: <br></p><p>- (NSMutableArray *)foo:(NSNumber *)bar<br>{<br>    NSMutableArray *array = [[NSMutableArray alloc] init];<br>    [array addObject:bar];<br>    return array;<br>}<br></p><p>So before swift about nullability we wrote in documentation. About can this method get `nil` or not.<br>Let’s think about import this method in swift. If we import legacy methods like this in swift with non-optional parameters by default we disable valid `nil`-pass method like in first example. But if we import by default as optional - we mistakenly say <br>that second method can get `nil`, and therefore get crash. So we import like IUO params. But behaviour of IUO-code is same as with optional params. By placing `!` in parameter type we just trying to say “Man, parameter can be `nil` (cause in Obj-C it can be `nil`), but method maybe not handle `nil` as parameter. Be careful.” And if we remove `!` in parameter type, I think we can say it by different way.<br></p><p>I hope I explain my point.<br></p><p>&gt; &gt; On Jun 27, 2016, at 4:42 PM, Saagar Jha via swift-evolution&lt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)&gt;wrote:<br>&gt; &gt; <br>&gt; &gt; Alright, I’ve written it up a proposal; you can find ithere(https://gist.github.com/saagarjha/f33fecd4576f40133b6469da942ef453). This is my first proposal (and anyways I’ve been told that I can be unclear), so if you guys see anything that should be changed feel free to let me know. Here it is inline:<br>&gt; &gt; <br>&gt; &gt; <br>&gt; &gt; <br>&gt; HiSaagar,<br>&gt; <br>&gt; If I understand your proposal correctly, you are suggesting that we remove T! and just force people to use T? or T.This is a commonly rejected proposal (though not on the list yet) that frequently comes up.The problem with your proposal is that you don’t provide any solutions to the problems that T! is currently solving: that of two-phase initialization and importing of APIs that have not been nullability audited.It isn’t pragmatic to handle these cases as T?<br>&gt; <br>&gt; -Chris<br>&gt; &gt; Remove implicitly unwrapped optionals as function parameters<br>&gt; &gt; Proposal:SE-NNNN(x-msg://38/NNNN-remove-implicitly-unwrapped-function-parameters.md)<br>&gt; &gt; Author:Swift Developer(https://github.com/swiftdev)<br>&gt; &gt; Status:Awaiting review<br>&gt; &gt; Review manager: TBD<br>&gt; &gt; <br>&gt; &gt; Introduction<br>&gt; &gt; <br>&gt; &gt; Swift, in contrast with Objective-C, makes a distinction between values that may beniland values that can never benilthrough its use of Optionals. Due to the fact that Objective-C does not make this distinction, Objective-C functions that do not use theNullability(https://developer.apple.com/swift/blog/?id=25)annotations are imported with parameters of the implicitly unwrapped optional type. Unfortunately, this allows users to write their own Swift code that looks like this:<br>&gt; &gt; <br>&gt; &gt; func foo(bar: Int!) {   //… }<br>&gt; &gt; <br>&gt; &gt; Due to the confusion this may cause, we would like to propose theremoval of implicitly unwrapped optionals as function parameters. Discussion on this topic may be foundhere(http://article.gmane.org/gmane.comp.lang.swift.evolution/21730/).<br>&gt; &gt; <br>&gt; &gt; Motivation<br>&gt; &gt; <br>&gt; &gt; Implicitly unwrapped optionals are currently allowed in function declarations. Consider the following function:<br>&gt; &gt; <br>&gt; &gt; func triple(forceUnwrapping aNumber: Int) -&gt;Int {   return aNumber * 3 } let possiblyNil = Int(&quot;foo&quot;) triple(forceUnwrapping: possiblyNil)<br>&gt; &gt; <br>&gt; &gt; possiblyNilis anInt?; thus, this example will not compile due totriple(forceUnwrapping:)expecting anInt. It is easy to imagine a Swift beginner writing code that looks like this to &quot;fix&quot; the problem:<br>&gt; &gt; <br>&gt; &gt; func triple(forceUnwrapping aNumber: Int!) -&gt;Int {   return aNumber * 3 } let possiblyNil = Int(&quot;foo&quot;) triple(forceUnwrapping: possiblyNil)<br>&gt; &gt; <br>&gt; &gt; While this version compiles, it crashes due to the force unwrapping of anilvalue. Unfortunately, the compiler &quot;hides&quot; this fact by making it seem like it&#39;s acceptable to pass innil–it doesn&#39;t make the forced unwrappingexplicit.<br>&gt; &gt; <br>&gt; &gt; Proposed solution<br>&gt; &gt; <br>&gt; &gt; The safest solution, in this case, is to prevent the use of implicitly unrwapped optionals in function signatures. By forcing users to write<br>&gt; &gt; <br>&gt; &gt; func triple(forceUnwrapping aNumber: Int) -&gt;Int {   return aNumber * 3 }<br>&gt; &gt; <br>&gt; &gt; or<br>&gt; &gt; <br>&gt; &gt; func triple(forceUnwrapping aNumber: Int?) -&gt;Int {   return aNumber * 3 }<br>&gt; &gt; <br>&gt; &gt; the compiler will complain, reminding users that they should probably attempt to safely unwrap the optional before using it.<br>&gt; &gt; <br>&gt; &gt; Detailed design<br>&gt; &gt; <br>&gt; &gt; The proposal will prevent the use of implicitly unwrapped optionals in function signatures for both Swift code as well as imported Objective-C code. As non-annotated Objective-C functions are currently imported as implicitly unwrapped, they will be converted to optionals as a preliminary step. Non-audited frameworks can be audited in the future so that they can be tagged with_Nonnullif necessary.<br>&gt; &gt; <br>&gt; &gt; Impact on existing code<br>&gt; &gt; <br>&gt; &gt; This is a proposal is a source breaking change, but it should be easily mitigated using a migrator. Existing functions with implicitly unwrapped optionals can be changed to optional; users can easily shadow variables with aguardor change their function to non-optional.<br>&gt; &gt; <br>&gt; &gt; Alternatives considered<br>&gt; &gt; Importing Objective-C functions as-is, but disallowing implictly unwrapped optionals in Swift code<br>&gt; &gt; <br>&gt; &gt; This reduces the burden on existing frameworks and adding Nullability annotations, but creates a sort of disconnect between Objective-C and Swift in that it prevents Swift developers from writing functions with implicitly unwrapped optionals.<br>&gt; &gt; <br>&gt; &gt; Doing nothing<br>&gt; &gt; <br>&gt; &gt; Obviously, this has the benefit of keeping the current behavior and not requiring a migrator. However, I believe that the unsafe behavior that this encourages is not worth keeping.<br>&gt; &gt; <br>&gt; &gt; <br>&gt; &gt; <br>&gt; &gt; On Mon, Jun 27, 2016 at 1:35 PM Dennis Lysenko&lt;dennis.s.lysenko at gmail.com(mailto:dennis.s.lysenko at gmail.com)&gt;wrote:<br>&gt; &gt; &gt; +1. This is sort of how Kotlin does it. In Kotlin, IUOs are strictly a carryover from Java. They show up in method signatures from non-nullable-annotated Java, but you can&#39;t define a new method that takes e.g. an Int!.<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; The limited scope of this proposal is ideal in my opinion since we see areas where IUOs are clearly useful (ViewControllers for instance) but defining new functions that take implicitly unwrapped optionals makes no sense. If you need to pass a IUO at the call site, you can define the function taking a non-optional value and pass the IUO to that. There is no use case I can think of for having it in method/function signatures.<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; RE: language inconsistencies, there is no such issue in practice in Kotlin where there is also inconsistency in the same vein. I see it simply as a compromise that achieves the goal of keeping a useful feature but discouraging its overuse by forbidding its use in places where its use could confuse and snowball down the line into teaching developers worse code quality.<br>&gt; &gt; &gt; On Mon, Jun 27, 2016 at 12:04 PM Charlie Monroe via swift-evolution&lt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)&gt;wrote:<br>&gt; &gt; &gt; &gt; Ok, I see - though I find myself using occasionally IUOs in Swift as well - e.g. when you can&#39;t use the default values because they depend on self, etc.<br>&gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; Eliminating it just from method signatures IMHO brings an incosistency into the language. Why would you eliminate it only from method signatures - this proposal mentioned importing ObjC API in the beginning - why not then mark those properties all as optional as well? IUOs are scheduled to be removed completely once the language reaches a point where it can handle most scenarios otherwise...<br>&gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; Try to imagine some APIs brought to Swift with default being nullable:<br>&gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; /// Imported from<br>&gt; &gt; &gt; &gt; publicclassNSOrderedSet :NSObject,NSCopying,NSMutableCopying,NSSecureCoding,NSFastEnumeration{<br>&gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; publicvarcount:Int{ get }<br>&gt; &gt; &gt; &gt; publicfuncobjectAtIndex(idx:Int) -&gt;AnyObject?<br>&gt; &gt; &gt; &gt; publicfuncindexOfObject(object:AnyObject?) -&gt;Int<br>&gt; &gt; &gt; &gt; publicinit()<br>&gt; &gt; &gt; &gt; publicinit(objects:UnsafePointer&lt;AnyObject?&gt;, count cnt:Int)<br>&gt; &gt; &gt; &gt; publicinit?(coder aDecoder:NSCoder?)<br>&gt; &gt; &gt; &gt; }<br>&gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; This doesn&#39;t make much sense - mostly objectAtIndex(_:).<br>&gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; On Jun 27, 2016, at 8:35 PM, Saagar Jha&lt;saagarjha28 at gmail.com(mailto:saagarjha28 at gmail.com)&gt;wrote:<br>&gt; &gt; &gt; &gt; &gt; I think you’re mistaking the scope of the proposal. It’s simply removing IUOs infunction signatures, not throughout the language.<br>&gt; &gt; &gt; &gt; &gt; On Mon, Jun 27, 2016 at 11:31 AM Charlie Monroe via swift-evolution&lt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)&gt;wrote:<br>&gt; &gt; &gt; &gt; &gt; &gt; There are many useful cases for IUO in Swift - mostly when you have variables that cannot be calculated at the point of calling super.init(), but are guaranteed to be filled during initialization - i.e. during the lifetime of the object, the value is nonnil, but may be nil for a short period of time.<br>&gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; Or @IBOutlets. Making all @IBOutlets optionals would make the code either riddled with ! or shadowed locally re-declared instance members.<br>&gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;On Jun 27, 2016, at 8:12 PM, Jean-Daniel Dupas&lt;mailing at xenonium.com(mailto:mailing at xenonium.com)&gt;wrote:<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;Maybe we can prohibit it in Swift function declaration, and allow it only when importing native code.<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;As David, I don’t see any compelling reason to allow such construct in Swift.<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;Le 27 juin 2016 à 10:39, Charlie Monroe via swift-evolution&lt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)&gt;a écrit :<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;When you import ObjC code that has no nullability annotation, IUO make sense since:<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;- they can be checked against nil<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;- typically, most values in APIs are nonnull (looking at Foundation, for example, which is why Apple has the NS_ASSUME_NONNULL_BEGIN to mark entire regions as nonnull, yet there is no NS_ASSUME_NULL_BEGIN)<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;Importing them as optionals would make it really hard to work with the code - whenever you get a value, it&#39;s an optional, even in cases where it makes no sense and adding ! to unwrap the optional is not a great solution. And the other solution is to use guards everywhere.<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;IMHO the IUO is a nice (temporary) solution for using un-annotated code until it is. But the &quot;pressure&quot; should be applied on the ObjC code.<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;On Jun 27, 2016, at 10:03 AM, David Rönnqvist&lt;david.ronnqvist at gmail.com(mailto:david.ronnqvist at gmail.com)&gt;wrote:<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;I don’t know about the chances of getting approved, but I think this is something worth discussing.<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;It might just be my ignorance, but I can’t think of a good reason why a function argument would be force unwrapped. Either it’s non-null and the caller is expected to unwrap it or it’s nullable and the method is expected to handle the nil value. So I’m positive to that part of the proposal.<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;As to what we should do with the generated interfaces of Objective-C code that hasn’t been annotated with nullability, I think that needs input from more people to find the preferred solution.<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;Once that’s been discussed some more, I’d be willing to write up a formal proposal if you don’t feel like it (assuming the discussion leads somewhere).<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;- David<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;&gt;On 27 Jun 2016, at 06:28, Charlie Monroe via swift-evolution&lt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)&gt;wrote:<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;&gt;<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;&gt;Seehttps://github.com/apple/swift-evolution/blob/master/process.md- you would need to make an official proposal and submit it as pull request. But given the reaction here, it&#39;s unlikely to get approved.<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;&gt;<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;&gt;Also, the ObjC code without nullability is getting fairly rare - all Apple&#39;s frameworks are with nullability information (as far as I&#39;ve checked) in macOS 10.12, iOS 10. Third party libraries should be updated to use nullability (and most libraries that are maintained already do).<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;&gt;<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;&gt;<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;On Jun 25, 2016, at 5:13 PM, Spromicky via swift-evolution&lt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)&gt;wrote:<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;So, its proposal is dead, or what we must to do to force it to swift-evolution repo on GitHub?<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;Hello, everyone!<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;I wanna propose to you to remove force unwrapping in fuction signature for swift code. That no sense in clear swift code. If we wanna use some optional value as function param, that is not optional, we must unwrap it before function call.<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;People who new in swift look at how they old Obj-C code (without nullability modifiers) translate in to swift:<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;Obj-C:<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;- (void)foo:(NSInteger)bar {<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;//...<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;}<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;Swift transaliton:<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;func foo(bar: Int!) {<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;//...<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;}<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;And think that force unwrapping in signature is good practice. And start write functions in clear swift code like this:<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;func newFoo(bar: Int!) {<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;//...<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;}<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;and use it like this:<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;let bar: Int? = 1<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;newFoo(bar)<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;And it really work, and they does not think that this can crash in case if `bar` will be `nil`.<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;But in clear swift we wanna work with parametrs in function that clearly or optional, or not.<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;func newFoo(bar: Int) {<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;//...<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;}<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;or<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;func newFoo(bar: Int?) {<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;//...<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;}<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;When we write a new function we know what we need in this case and use optional params or not.<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;So my proposal is remove force unwrapping(`!`) from function signatures, cause it have no sense, and that confuse new users.<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;_______________________________________________<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;swift-evolution mailing list<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;&gt;&gt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;&gt;<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;&gt;_______________________________________________<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;&gt;swift-evolution mailing list<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;&gt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;&gt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;&gt;<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;_______________________________________________<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;swift-evolution mailing list<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;&gt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; _______________________________________________<br>&gt; &gt; &gt; &gt; &gt; &gt; swift-evolution mailing list<br>&gt; &gt; &gt; &gt; &gt; &gt; swift-evolution at swift.org(mailto:swift-evolution at swift.org)<br>&gt; &gt; &gt; &gt; &gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; &gt; &gt; &gt; --<br>&gt; &gt; &gt; &gt; &gt; -Saagar Jha<br>&gt; &gt; &gt; &gt; _______________________________________________<br>&gt; &gt; &gt; &gt; swift-evolution mailing list<br>&gt; &gt; &gt; &gt; swift-evolution at swift.org(mailto:swift-evolution at swift.org)<br>&gt; &gt; &gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; --<br>&gt; &gt; -Saagar Jha_______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org(mailto:swift-evolution at swift.org)<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt;<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
