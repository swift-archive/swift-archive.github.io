<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June 22, 2016 at 01:00:00pm</p></header><div class="content"><p>on Wed Jun 22 2016, David Waite &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Today, a Sequence differs from a Collection in that:<br>&gt;<br>&gt; - A sequence can be infinitely or indefinitely sized, or could require<br>&gt; an O(n) operation to count the values in the sequence. <br></p><p>The latter being no different from Collection.<br></p><p>&gt; A collection has a finite number of elements, and the fixed size is<br>&gt; exposed as an O(1) or O(n) operation via ‘count’<br></p><p>I don&#39;t believe we&#39;ve actually nailed down that Collection is finite.<br></p><p>Oh, gee, Nate&#39;s documentation edits do<br>that. (https://github.com/apple/swift/commit/6e274913)<br>Nate, did we discuss this explicitly or did it slip in unnoticed?<br></p><p>The one crucial distinction in Collection is that you can make multiple<br>passes over the same elements.<br></p><p>&gt; - A collection is indexable, with those indices being usable for<br>&gt; various operations including forming subsets, comparisons, and manual<br>&gt; iteration<br>&gt;<br>&gt; - A sequence may or may not be destructive, where a destructive<br>&gt; sequence consumes elements during traversal, making them unavailable<br>&gt; on subsequent traversals. Collection operations are required to be<br>&gt; non-destructive<br>&gt;<br>&gt; I would like to Pitch removing this third differentiation, the option<br>&gt; for destructive sequences.<br></p><p>I have been strongly considering this direction myself, and it&#39;s<br>something we need to decide about for Swift 3.<br></p><p>&gt; My main motivation for proposing this is the potential for developer<br>&gt; confusion. As stated during one of the previous threads on the naming<br>&gt; of map, flatMap, filter, etc. methods on Sequence, Sequence has a<br>&gt; naming requirement not typical of the rest of the Swift standard<br>&gt; library in that many methods on Sequence may or may not be<br>&gt; destructive. As such, naming methods for any extensions on Sequence is<br>&gt; challenging as the names need to not imply immutability.<br></p><p>I don&#39;t think the names are really the worst potential cause of<br>confusion here.  There&#39;s also the fact that you can conform to Sequence<br>with a destructively-traversed “value type” that has no mutating<br>methods.<br></p><p>&gt; It would still be possible to have Generators which operate<br></p><p>&lt;Ahem&gt; “Iterators,” please.<br></p><p>&gt; destructively, but such Generators would not conform to the needs of<br>&gt; Sequence. As such, the most significant impact would be the inability<br>&gt; to use such Generators in a for..in loop, <br></p><p>Trying to evaluate this statement, it&#39;s clear we&#39;re missing lots of<br>detail here:<br></p><p>* Would you remove Sequence?<br>* If so, what Protocol would embody “for...in-able?”<br>* If not, would you remove Collection?<br>* What role would Iterator play?<br></p><p><br>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 22, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jun 22, 2016, at 3:57 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Wed Jun 22 2016, David Waite &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Today, a Sequence differs from a Collection in that:<br>&gt;&gt; <br>&gt;&gt; - A sequence can be infinitely or indefinitely sized, or could require<br>&gt;&gt; an O(n) operation to count the values in the sequence. <br>&gt; <br>&gt; The latter being no different from Collection.<br>&gt; <br>&gt;&gt; A collection has a finite number of elements, and the fixed size is<br>&gt;&gt; exposed as an O(1) or O(n) operation via ‘count’<br>&gt; <br>&gt; I don&#39;t believe we&#39;ve actually nailed down that Collection is finite.<br>&gt; <br>&gt; Oh, gee, Nate&#39;s documentation edits do<br>&gt; that. (https://github.com/apple/swift/commit/6e274913)<br>&gt; Nate, did we discuss this explicitly or did it slip in unnoticed?<br>&gt; <br>&gt; The one crucial distinction in Collection is that you can make multiple<br>&gt; passes over the same elements.<br>&gt; <br>&gt;&gt; - A collection is indexable, with those indices being usable for<br>&gt;&gt; various operations including forming subsets, comparisons, and manual<br>&gt;&gt; iteration<br>&gt;&gt; <br>&gt;&gt; - A sequence may or may not be destructive, where a destructive<br>&gt;&gt; sequence consumes elements during traversal, making them unavailable<br>&gt;&gt; on subsequent traversals. Collection operations are required to be<br>&gt;&gt; non-destructive<br>&gt;&gt; <br>&gt;&gt; I would like to Pitch removing this third differentiation, the option<br>&gt;&gt; for destructive sequences.<br>&gt; <br>&gt; I have been strongly considering this direction myself, and it&#39;s<br>&gt; something we need to decide about for Swift 3.<br></p><p>I believe this is a problem that should be solved.  <br></p><p>I also believe distinguishing between finite and infinite sequences is a good idea (along with preventing for..in from being used with an infinite sequence)<br></p><p>&gt; <br>&gt;&gt; My main motivation for proposing this is the potential for developer<br>&gt;&gt; confusion. As stated during one of the previous threads on the naming<br>&gt;&gt; of map, flatMap, filter, etc. methods on Sequence, Sequence has a<br>&gt;&gt; naming requirement not typical of the rest of the Swift standard<br>&gt;&gt; library in that many methods on Sequence may or may not be<br>&gt;&gt; destructive. As such, naming methods for any extensions on Sequence is<br>&gt;&gt; challenging as the names need to not imply immutability.<br>&gt; <br>&gt; I don&#39;t think the names are really the worst potential cause of<br>&gt; confusion here.  There&#39;s also the fact that you can conform to Sequence<br>&gt; with a destructively-traversed “value type” that has no mutating<br>&gt; methods.<br></p><p>I agree, names are not the primary issue.  <br></p><p>Another issue is that you cannot currently write generic code that might need to iterate a sequence more than once.  You currently have to over-constrain types to `Collection` even if you don’t need to do anything other than iterate the elements (the discussion about whether `LazyFilterSequnce` has a bug in its `underestimateCount` is relevant here).<br></p><p>&gt; <br>&gt;&gt; It would still be possible to have Generators which operate<br>&gt; <br>&gt; &lt;Ahem&gt; “Iterators,” please.<br>&gt; <br>&gt;&gt; destructively, but such Generators would not conform to the needs of<br>&gt;&gt; Sequence. As such, the most significant impact would be the inability<br>&gt;&gt; to use such Generators in a for..in loop, <br>&gt; <br>&gt; Trying to evaluate this statement, it&#39;s clear we&#39;re missing lots of<br>&gt; detail here:<br>&gt; <br>&gt; * Would you remove Sequence?<br>&gt; * If so, what Protocol would embody “for...in-able?”<br>&gt; * If not, would you remove Collection?<br>&gt; * What role would Iterator play?<br></p><p>If we’re going to consider alternative designs it is worth considering the semantic space available.  For the sake of discussion, here is a model that captures the various semantics that exist (the names are just strawmen):<br></p><p>                           Iterable <br>                           /          \<br>                          /             \<br>                         /               \<br>    FiniteIterable                 MultipassIterable<br>                        \                 /<br>                          \              / <br>                           \            /<br>                          Sequence<br>                                 |<br>                                 |<br>                          Collection<br></p><p>`Iterable` corresponds to the current `Sequence` - no semantics beyond iteration are required.  Infinite, single-pass “sequences” may conform.  <br></p><p>`for..in` naturally requires `FiniteIterable`, but does not require the `MultipassIterable`.<br></p><p>There are many interesting infinite `MultipassIterable` types.  These include any dynamically generated sequence, such as a mathematical sequence (even numbers, odd numbers, etc).  This is also what the existing `Sequence` would become if we drop support for destructive sequences and do nothing else (note: it would still be possible to accidentally write a `for..in` loop over an infinite sequence).<br></p><p>Under this model `Sequence` brings together `FiniteIterable` and `MultipassIterable`.  This describes the most common models of `Sequence`, can safely be used in a `for..in` loop, and does support “destructive” single pass sequences.<br></p><p>`FiniteIterable` and `MultipassIterable` introduce independent and important semantic requirements.  If we’re going to consider changes here, I think it is worth at least considering introducing the distinction.<br></p><p>This is obviously much more complex than than the current design.  The most obvious simplification would be to drop `Iterable` if we don’t have any compelling use cases for infinite, single pass sequences.  One downside to doing this is that the syntactic requirements would need to be repeated in both `FiniteIterable` and `MultipassIterable`<br></p><p>Another obvious simplification would be to also remove `Sequence` (which becomes a “convenience” protocol under this model) and require types that can conform to both `FiniteIterable` and `MultipassIterable` to do so directly.  <br></p><p>If chose to make both simplifications we could also rename the remaining `FiniteIterable` and `MultipassIterable` to something simpler like `Iterable` and `Sequence`.<br></p><p>               (for..in)              (the existing `Sequence` with an additional multipass semantic requirement) <br>               Iterable             Sequence  <br>                        \                 /<br>                          \              / <br>                           \            /<br>                          Collection<br></p><p>I’m interested in hearing what others think about this way of thinking about the available design space.<br></p><p>-Matthew<br></p><p><br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>June 23, 2016 at 08:00:00am</p></header><div class="content"><p>I agree that there should be a type for a non-destructive re-entrant<br>sequence.<br></p><p>IIRC in past discussions one of the counter arguments given was IO stream<br>sequences. It is likely undesirable to buffer the entire stream, but<br>without buffering there&#39;s no guarantee of getting the same values.<br></p><p>These discussions were back when swift-evolution started, sorry I couldn&#39;t<br>find a link. I think it was discussed in the context of a non-mutating<br>Generator.<br></p><p>On Thursday, 23 June 2016, Matthew Johnson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Jun 22, 2016, at 3:57 PM, Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; on Wed Jun 22 2016, David Waite &lt;swift-evolution at swift.org<br>&gt; &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt; Today, a Sequence differs from a Collection in that:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; - A sequence can be infinitely or indefinitely sized, or could require<br>&gt; &gt;&gt; an O(n) operation to count the values in the sequence.<br>&gt; &gt;<br>&gt; &gt; The latter being no different from Collection.<br>&gt; &gt;<br>&gt; &gt;&gt; A collection has a finite number of elements, and the fixed size is<br>&gt; &gt;&gt; exposed as an O(1) or O(n) operation via ‘count’<br>&gt; &gt;<br>&gt; &gt; I don&#39;t believe we&#39;ve actually nailed down that Collection is finite.<br>&gt; &gt;<br>&gt; &gt; Oh, gee, Nate&#39;s documentation edits do<br>&gt; &gt; that. (https://github.com/apple/swift/commit/6e274913)<br>&gt; &gt; Nate, did we discuss this explicitly or did it slip in unnoticed?<br>&gt; &gt;<br>&gt; &gt; The one crucial distinction in Collection is that you can make multiple<br>&gt; &gt; passes over the same elements.<br>&gt; &gt;<br>&gt; &gt;&gt; - A collection is indexable, with those indices being usable for<br>&gt; &gt;&gt; various operations including forming subsets, comparisons, and manual<br>&gt; &gt;&gt; iteration<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; - A sequence may or may not be destructive, where a destructive<br>&gt; &gt;&gt; sequence consumes elements during traversal, making them unavailable<br>&gt; &gt;&gt; on subsequent traversals. Collection operations are required to be<br>&gt; &gt;&gt; non-destructive<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I would like to Pitch removing this third differentiation, the option<br>&gt; &gt;&gt; for destructive sequences.<br>&gt; &gt;<br>&gt; &gt; I have been strongly considering this direction myself, and it&#39;s<br>&gt; &gt; something we need to decide about for Swift 3.<br>&gt;<br>&gt; I believe this is a problem that should be solved.<br>&gt;<br>&gt; I also believe distinguishing between finite and infinite sequences is a<br>&gt; good idea (along with preventing for..in from being used with an infinite<br>&gt; sequence)<br>&gt;<br>&gt; &gt;<br>&gt; &gt;&gt; My main motivation for proposing this is the potential for developer<br>&gt; &gt;&gt; confusion. As stated during one of the previous threads on the naming<br>&gt; &gt;&gt; of map, flatMap, filter, etc. methods on Sequence, Sequence has a<br>&gt; &gt;&gt; naming requirement not typical of the rest of the Swift standard<br>&gt; &gt;&gt; library in that many methods on Sequence may or may not be<br>&gt; &gt;&gt; destructive. As such, naming methods for any extensions on Sequence is<br>&gt; &gt;&gt; challenging as the names need to not imply immutability.<br>&gt; &gt;<br>&gt; &gt; I don&#39;t think the names are really the worst potential cause of<br>&gt; &gt; confusion here.  There&#39;s also the fact that you can conform to Sequence<br>&gt; &gt; with a destructively-traversed “value type” that has no mutating<br>&gt; &gt; methods.<br>&gt;<br>&gt; I agree, names are not the primary issue.<br>&gt;<br>&gt; Another issue is that you cannot currently write generic code that might<br>&gt; need to iterate a sequence more than once.  You currently have to<br>&gt; over-constrain types to `Collection` even if you don’t need to do anything<br>&gt; other than iterate the elements (the discussion about whether<br>&gt; `LazyFilterSequnce` has a bug in its `underestimateCount` is relevant here).<br>&gt;<br>&gt; &gt;<br>&gt; &gt;&gt; It would still be possible to have Generators which operate<br>&gt; &gt;<br>&gt; &gt; &lt;Ahem&gt; “Iterators,” please.<br>&gt; &gt;<br>&gt; &gt;&gt; destructively, but such Generators would not conform to the needs of<br>&gt; &gt;&gt; Sequence. As such, the most significant impact would be the inability<br>&gt; &gt;&gt; to use such Generators in a for..in loop,<br>&gt; &gt;<br>&gt; &gt; Trying to evaluate this statement, it&#39;s clear we&#39;re missing lots of<br>&gt; &gt; detail here:<br>&gt; &gt;<br>&gt; &gt; * Would you remove Sequence?<br>&gt; &gt; * If so, what Protocol would embody “for...in-able?”<br>&gt; &gt; * If not, would you remove Collection?<br>&gt; &gt; * What role would Iterator play?<br>&gt;<br>&gt; If we’re going to consider alternative designs it is worth considering the<br>&gt; semantic space available.  For the sake of discussion, here is a model that<br>&gt; captures the various semantics that exist (the names are just strawmen):<br>&gt;<br>&gt;                            Iterable<br>&gt;                            /          \<br>&gt;                           /             \<br>&gt;                          /               \<br>&gt;     FiniteIterable                 MultipassIterable<br>&gt;                         \                 /<br>&gt;                           \              /<br>&gt;                            \            /<br>&gt;                           Sequence<br>&gt;                                  |<br>&gt;                                  |<br>&gt;                           Collection<br>&gt;<br>&gt; `Iterable` corresponds to the current `Sequence` - no semantics beyond<br>&gt; iteration are required.  Infinite, single-pass “sequences” may conform.<br>&gt;<br>&gt; `for..in` naturally requires `FiniteIterable`, but does not require the<br>&gt; `MultipassIterable`.<br>&gt;<br>&gt; There are many interesting infinite `MultipassIterable` types.  These<br>&gt; include any dynamically generated sequence, such as a mathematical sequence<br>&gt; (even numbers, odd numbers, etc).  This is also what the existing<br>&gt; `Sequence` would become if we drop support for destructive sequences and do<br>&gt; nothing else (note: it would still be possible to accidentally write a<br>&gt; `for..in` loop over an infinite sequence).<br>&gt;<br>&gt; Under this model `Sequence` brings together `FiniteIterable` and<br>&gt; `MultipassIterable`.  This describes the most common models of `Sequence`,<br>&gt; can safely be used in a `for..in` loop, and does support “destructive”<br>&gt; single pass sequences.<br>&gt;<br>&gt; `FiniteIterable` and `MultipassIterable` introduce independent and<br>&gt; important semantic requirements.  If we’re going to consider changes here,<br>&gt; I think it is worth at least considering introducing the distinction.<br>&gt;<br>&gt; This is obviously much more complex than than the current design.  The<br>&gt; most obvious simplification would be to drop `Iterable` if we don’t have<br>&gt; any compelling use cases for infinite, single pass sequences.  One downside<br>&gt; to doing this is that the syntactic requirements would need to be repeated<br>&gt; in both `FiniteIterable` and `MultipassIterable`<br>&gt;<br>&gt; Another obvious simplification would be to also remove `Sequence` (which<br>&gt; becomes a “convenience” protocol under this model) and require types that<br>&gt; can conform to both `FiniteIterable` and `MultipassIterable` to do so<br>&gt; directly.<br>&gt;<br>&gt; If chose to make both simplifications we could also rename the remaining<br>&gt; `FiniteIterable` and `MultipassIterable` to something simpler like<br>&gt; `Iterable` and `Sequence`.<br>&gt;<br>&gt;                (for..in)              (the existing `Sequence` with an<br>&gt; additional multipass semantic requirement)<br>&gt;                Iterable             Sequence<br>&gt;                         \                 /<br>&gt;                           \              /<br>&gt;                            \            /<br>&gt;                           Collection<br>&gt;<br>&gt; I’m interested in hearing what others think about this way of thinking<br>&gt; about the available design space.<br>&gt;<br>&gt; -Matthew<br>&gt;<br>&gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Dave<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/0b6140ba/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>June 23, 2016 at 08:00:00am</p></header><div class="content"><p>Could we have a BufferedSequence type that is identity in most cases?<br></p><p>On Thursday, 23 June 2016, Andrew Bennett &lt;cacoyi at gmail.com&gt; wrote:<br></p><p>&gt; I agree that there should be a type for a non-destructive re-entrant<br>&gt; sequence.<br>&gt;<br>&gt; IIRC in past discussions one of the counter arguments given was IO stream<br>&gt; sequences. It is likely undesirable to buffer the entire stream, but<br>&gt; without buffering there&#39;s no guarantee of getting the same values.<br>&gt;<br>&gt; These discussions were back when swift-evolution started, sorry I couldn&#39;t<br>&gt; find a link. I think it was discussed in the context of a non-mutating<br>&gt; Generator.<br>&gt;<br>&gt; On Thursday, 23 June 2016, Matthew Johnson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; On Jun 22, 2016, at 3:57 PM, Dave Abrahams via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; on Wed Jun 22 2016, David Waite &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; Today, a Sequence differs from a Collection in that:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; - A sequence can be infinitely or indefinitely sized, or could require<br>&gt;&gt; &gt;&gt; an O(n) operation to count the values in the sequence.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The latter being no different from Collection.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; A collection has a finite number of elements, and the fixed size is<br>&gt;&gt; &gt;&gt; exposed as an O(1) or O(n) operation via ‘count’<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I don&#39;t believe we&#39;ve actually nailed down that Collection is finite.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Oh, gee, Nate&#39;s documentation edits do<br>&gt;&gt; &gt; that. (https://github.com/apple/swift/commit/6e274913)<br>&gt;&gt; &gt; Nate, did we discuss this explicitly or did it slip in unnoticed?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The one crucial distinction in Collection is that you can make multiple<br>&gt;&gt; &gt; passes over the same elements.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; - A collection is indexable, with those indices being usable for<br>&gt;&gt; &gt;&gt; various operations including forming subsets, comparisons, and manual<br>&gt;&gt; &gt;&gt; iteration<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; - A sequence may or may not be destructive, where a destructive<br>&gt;&gt; &gt;&gt; sequence consumes elements during traversal, making them unavailable<br>&gt;&gt; &gt;&gt; on subsequent traversals. Collection operations are required to be<br>&gt;&gt; &gt;&gt; non-destructive<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; I would like to Pitch removing this third differentiation, the option<br>&gt;&gt; &gt;&gt; for destructive sequences.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I have been strongly considering this direction myself, and it&#39;s<br>&gt;&gt; &gt; something we need to decide about for Swift 3.<br>&gt;&gt;<br>&gt;&gt; I believe this is a problem that should be solved.<br>&gt;&gt;<br>&gt;&gt; I also believe distinguishing between finite and infinite sequences is a<br>&gt;&gt; good idea (along with preventing for..in from being used with an infinite<br>&gt;&gt; sequence)<br>&gt;&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; My main motivation for proposing this is the potential for developer<br>&gt;&gt; &gt;&gt; confusion. As stated during one of the previous threads on the naming<br>&gt;&gt; &gt;&gt; of map, flatMap, filter, etc. methods on Sequence, Sequence has a<br>&gt;&gt; &gt;&gt; naming requirement not typical of the rest of the Swift standard<br>&gt;&gt; &gt;&gt; library in that many methods on Sequence may or may not be<br>&gt;&gt; &gt;&gt; destructive. As such, naming methods for any extensions on Sequence is<br>&gt;&gt; &gt;&gt; challenging as the names need to not imply immutability.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I don&#39;t think the names are really the worst potential cause of<br>&gt;&gt; &gt; confusion here.  There&#39;s also the fact that you can conform to Sequence<br>&gt;&gt; &gt; with a destructively-traversed “value type” that has no mutating<br>&gt;&gt; &gt; methods.<br>&gt;&gt;<br>&gt;&gt; I agree, names are not the primary issue.<br>&gt;&gt;<br>&gt;&gt; Another issue is that you cannot currently write generic code that might<br>&gt;&gt; need to iterate a sequence more than once.  You currently have to<br>&gt;&gt; over-constrain types to `Collection` even if you don’t need to do anything<br>&gt;&gt; other than iterate the elements (the discussion about whether<br>&gt;&gt; `LazyFilterSequnce` has a bug in its `underestimateCount` is relevant here).<br>&gt;&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; It would still be possible to have Generators which operate<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; &lt;Ahem&gt; “Iterators,” please.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; destructively, but such Generators would not conform to the needs of<br>&gt;&gt; &gt;&gt; Sequence. As such, the most significant impact would be the inability<br>&gt;&gt; &gt;&gt; to use such Generators in a for..in loop,<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Trying to evaluate this statement, it&#39;s clear we&#39;re missing lots of<br>&gt;&gt; &gt; detail here:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; * Would you remove Sequence?<br>&gt;&gt; &gt; * If so, what Protocol would embody “for...in-able?”<br>&gt;&gt; &gt; * If not, would you remove Collection?<br>&gt;&gt; &gt; * What role would Iterator play?<br>&gt;&gt;<br>&gt;&gt; If we’re going to consider alternative designs it is worth considering<br>&gt;&gt; the semantic space available.  For the sake of discussion, here is a model<br>&gt;&gt; that captures the various semantics that exist (the names are just<br>&gt;&gt; strawmen):<br>&gt;&gt;<br>&gt;&gt;                            Iterable<br>&gt;&gt;                            /          \<br>&gt;&gt;                           /             \<br>&gt;&gt;                          /               \<br>&gt;&gt;     FiniteIterable                 MultipassIterable<br>&gt;&gt;                         \                 /<br>&gt;&gt;                           \              /<br>&gt;&gt;                            \            /<br>&gt;&gt;                           Sequence<br>&gt;&gt;                                  |<br>&gt;&gt;                                  |<br>&gt;&gt;                           Collection<br>&gt;&gt;<br>&gt;&gt; `Iterable` corresponds to the current `Sequence` - no semantics beyond<br>&gt;&gt; iteration are required.  Infinite, single-pass “sequences” may conform.<br>&gt;&gt;<br>&gt;&gt; `for..in` naturally requires `FiniteIterable`, but does not require the<br>&gt;&gt; `MultipassIterable`.<br>&gt;&gt;<br>&gt;&gt; There are many interesting infinite `MultipassIterable` types.  These<br>&gt;&gt; include any dynamically generated sequence, such as a mathematical sequence<br>&gt;&gt; (even numbers, odd numbers, etc).  This is also what the existing<br>&gt;&gt; `Sequence` would become if we drop support for destructive sequences and do<br>&gt;&gt; nothing else (note: it would still be possible to accidentally write a<br>&gt;&gt; `for..in` loop over an infinite sequence).<br>&gt;&gt;<br>&gt;&gt; Under this model `Sequence` brings together `FiniteIterable` and<br>&gt;&gt; `MultipassIterable`.  This describes the most common models of `Sequence`,<br>&gt;&gt; can safely be used in a `for..in` loop, and does support “destructive”<br>&gt;&gt; single pass sequences.<br>&gt;&gt;<br>&gt;&gt; `FiniteIterable` and `MultipassIterable` introduce independent and<br>&gt;&gt; important semantic requirements.  If we’re going to consider changes here,<br>&gt;&gt; I think it is worth at least considering introducing the distinction.<br>&gt;&gt;<br>&gt;&gt; This is obviously much more complex than than the current design.  The<br>&gt;&gt; most obvious simplification would be to drop `Iterable` if we don’t have<br>&gt;&gt; any compelling use cases for infinite, single pass sequences.  One downside<br>&gt;&gt; to doing this is that the syntactic requirements would need to be repeated<br>&gt;&gt; in both `FiniteIterable` and `MultipassIterable`<br>&gt;&gt;<br>&gt;&gt; Another obvious simplification would be to also remove `Sequence` (which<br>&gt;&gt; becomes a “convenience” protocol under this model) and require types that<br>&gt;&gt; can conform to both `FiniteIterable` and `MultipassIterable` to do so<br>&gt;&gt; directly.<br>&gt;&gt;<br>&gt;&gt; If chose to make both simplifications we could also rename the remaining<br>&gt;&gt; `FiniteIterable` and `MultipassIterable` to something simpler like<br>&gt;&gt; `Iterable` and `Sequence`.<br>&gt;&gt;<br>&gt;&gt;                (for..in)              (the existing `Sequence` with an<br>&gt;&gt; additional multipass semantic requirement)<br>&gt;&gt;                Iterable             Sequence<br>&gt;&gt;                         \                 /<br>&gt;&gt;                           \              /<br>&gt;&gt;                            \            /<br>&gt;&gt;                           Collection<br>&gt;&gt;<br>&gt;&gt; I’m interested in hearing what others think about this way of thinking<br>&gt;&gt; about the available design space.<br>&gt;&gt;<br>&gt;&gt; -Matthew<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; --<br>&gt;&gt; &gt; Dave<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/ba069bc2/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June 22, 2016 at 05:00:00pm</p></header><div class="content"><p>I think you&#39;re tremendously overcomplicating the design.<br></p><p>&gt; If we’re going to consider alternative designs it is worth considering the semantic space available.  For the sake of discussion, here is a model that captures the various semantics that exist (the names are just strawmen):<br>&gt; <br>&gt;                           Iterable <br>&gt;                           /          \<br>&gt;                          /             \<br>&gt;                         /               \<br>&gt;    FiniteIterable                 MultipassIterable<br>&gt;                        \                 /<br>&gt;                          \              / <br>&gt;                           \            /<br>&gt;                          Sequence<br>&gt;                                 |<br>&gt;                                 |<br>&gt;                          Collection<br>&gt; <br>&gt; `Iterable` corresponds to the current `Sequence` - no semantics beyond iteration are required.  Infinite, single-pass “sequences” may conform.  <br></p><p>Okay, so let&#39;s start by undoing that renaming to make clear which semantics in this hierarchy are actually new and which ones are already part of the standard library.<br></p><p>                        Sequence <br>                          /          \<br>                         /             \<br>                        /               \<br>   FiniteSequence         MultipassSequence<br>                       \                 /<br>                         \              / <br>                          \            /<br>               FiniteMultipassSequence<br>                                |<br>                                |<br>                         Collection<br></p><p>&gt; `for..in` naturally requires `FiniteIterable`,<br></p><p>Why? There&#39;s nothing conceptually incoherent about looping over an infinite sequence. Even ignoring errors, you can `break` out, you can `exit()` from an interior method, you can abort or fail a precondition, or you can just let it loop forever. Forbidding potentially-infinite for loops `for` loops is an arbitrary limitation.<br></p><p>&gt; but does not require the `MultipassIterable`.<br>&gt; <br>&gt; There are many interesting infinite `MultipassIterable` types.  These include any dynamically generated sequence, such as a mathematical sequence (even numbers, odd numbers, etc).  This is also what the existing `Sequence` would become if we drop support for destructive sequences and do nothing else (note: it would still be possible to accidentally write a `for..in` loop over an infinite sequence).<br></p><p>Okay, but all of these can be represented as infinite Collections.<br></p><p>Let me explain. If a Sequence is truly multipass—that is, you can iterate over it many times and it will always return the same elements—then it must look something like this:<br></p><p>	struct MyElement { … }	<br>	<br>	struct MyState {<br>		…<br>		init() { … }<br>		mutating func formNextElement(in: MySequence) { … }<br>		var currentElement(in: MySequence) -&gt; MyElement? { … }<br>	}<br></p><p>	struct MySequence: MultipassSequence {<br>		struct Iterator: IteratorProtocol {<br>			var sequence: MySequence<br>			var state: MyState<br>			<br>			init(sequence: MySequence, initialState: MyState) {<br>				self.sequence = sequence<br>				self.state = initialState<br>			}<br>			<br>			mutating func next() -&gt; MyElement? {<br>				defer { someState.formNextElement(in: sequence) }<br>				return someState.currentElement(in: sequence)<br>			}<br>		}<br>		<br>		func formIterator() -&gt; MyIterator {<br>			return MyIterator(sequence: self, initialState: MyState())<br>		}<br>	}<br></p><p>Now, the pieces may *appear* to be different—the Iterator may not actually need a reference to the Sequence, the state may be stored in many properties instead of just one, the code to iterate and get the current element may be directly in `next()` instead of in methods `next()` calls—but any multipass Sequence and Iterator could be refactored to match this pattern, so all multipass Sequences and Iterators are equivalent to it.<br></p><p>But you can convert MySequence into a possibly infinite MyCollection like so:<br></p><p>	struct MyCollection: PossiblyInfiniteCollection {<br>		enum Index: Comparable {<br>			var offset: Int<br>			var state: MyState?<br>		}<br>				<br>		var startIndex: Index {<br>			return Index(offset: 0, state: MyState())<br>		}<br>		var endIndex: Index {<br>			return Index(offset: Int.max, state: nil)<br>		}<br>		<br>		func formIndex(after index: inout Index) {<br>			index.state!.formNextElement(in: self)<br>			if index.state!.currentElement(in: self) == nil {<br>				index.offset = Int.max<br>			}<br>			else {<br>				index.offset! += 1<br>			}<br>		}<br>		<br>		subscript(index: Index) -&gt; MyElement {<br>			return index.state!.currentElement(in: self)<br>		}<br>	}<br>	<br>	func == (lhs: MyCollection.Index, rhs: MyCollection.Index) -&gt; Bool {<br>		return lhs.offset == rhs.offset<br>	}<br>	<br>	func &lt; (lhs: MyCollection.Index, rhs: MyCollection.Index) -&gt; Bool {<br>		return lhs.offset &lt; rhs.offset<br>	}<br></p><p>In other words, whatever state (other than the sequence itself) the Iterator needs to keep in its stored properties can instead be stored inside an index, and whatever logic the Iterator needs to implement its `next()` method can instead be split between `formIndex(after:)` and `subscript(_:)`. Any MultipassSequence can be written as a PossiblyInfiniteCollection if you&#39;re willing to put in the effort. And this is a boon to its multipass-ness, because you can not only start over again from the beginning, but start over from *any* step in the iteration.<br></p><p>If any MultipassSequence can be written as a PossiblyInfiniteCollection, then we can eliminate another protocol:<br></p><p>                        Sequence <br>                          /          \<br>                         /             \<br>                        /               \<br>   FiniteSequence         PossiblyInfiniteCollection<br>                       \                 /<br>                         \              / <br>                          \            /<br>                         Collection<br></p><p>Now we can move any members which may not terminate early (like `map` or `last`) or are ill-defined when infinite (`count`) into `FiniteSequence` and `Collection`, while leaving any which often do terminate early (like `first` or `index(of:)`) in `Sequence` and `PossiblyInfiniteCollection`.<br></p><p>Is this necessary? I don&#39;t really know. Arguably, we could simply provide this hierarchy:<br></p><p>                        Sequence <br>                          /          \<br>                         /             \<br>                        /               \<br>      IteratorProtocol      Collection<br></p><p>Where Iterators must be treated as potentially infinite, Collections are always finite, and you are asked (or, with a &quot;closed protocol&quot; feature, forced) to conform to one or the other, rather than to Sequence directly. Then the non-infinite-safe APIs like `map` can move onto `Collection` and we&#39;ll have covered most of the use cases which matter.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 22, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jun 22, 2016, at 7:27 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt; I think you&#39;re tremendously overcomplicating the design.<br></p><p>This isn’t intended as a proposed design.  It is intended to start a discussion exploring the design space.<br></p><p>&gt; <br>&gt;&gt; If we’re going to consider alternative designs it is worth considering the semantic space available.  For the sake of discussion, here is a model that captures the various semantics that exist (the names are just strawmen):<br>&gt;&gt; <br>&gt;&gt;                          Iterable <br>&gt;&gt;                          /          \<br>&gt;&gt;                         /             \<br>&gt;&gt;                        /               \<br>&gt;&gt;   FiniteIterable                 MultipassIterable<br>&gt;&gt;                       \                 /<br>&gt;&gt;                         \              / <br>&gt;&gt;                          \            /<br>&gt;&gt;                         Sequence<br>&gt;&gt;                                |<br>&gt;&gt;                                |<br>&gt;&gt;                         Collection<br>&gt;&gt; <br>&gt;&gt; `Iterable` corresponds to the current `Sequence` - no semantics beyond iteration are required.  Infinite, single-pass “sequences” may conform.  <br>&gt; <br>&gt; Okay, so let&#39;s start by undoing that renaming to make clear which semantics in this hierarchy are actually new and which ones are already part of the standard library.<br>&gt; <br>&gt;                        Sequence <br>&gt;                          /          \<br>&gt;                         /             \<br>&gt;                        /               \<br>&gt;   FiniteSequence         MultipassSequence<br>&gt;                       \                 /<br>&gt;                         \              / <br>&gt;                          \            /<br>&gt;               FiniteMultipassSequence<br>&gt;                                |<br>&gt;                                |<br>&gt;                         Collection<br></p><p>Yes, I should have done it this way to begin with.<br></p><p>&gt; <br>&gt;&gt; `for..in` naturally requires `FiniteIterable`,<br>&gt; <br>&gt; Why? There&#39;s nothing conceptually incoherent about looping over an infinite sequence. Even ignoring errors, you can `break` out, you can `exit()` from an interior method, you can abort or fail a precondition, or you can just let it loop forever. Forbidding potentially-infinite for loops `for` loops is an arbitrary limitation.<br></p><p>The argument for doing this is that `for..in` is syntactic sugar and looping over an infinite sequence using it is often going to be a mistake.  I think it’s reasonable to suggest that it be a little be more difficult to write an infinite loop in order to prevent one from doing so accidentally.  The position you and Dave have taken is also reasonable.<br></p><p>&gt; <br>&gt;&gt; but does not require the `MultipassIterable`.<br>&gt;&gt; <br>&gt;&gt; There are many interesting infinite `MultipassIterable` types.  These include any dynamically generated sequence, such as a mathematical sequence (even numbers, odd numbers, etc).  This is also what the existing `Sequence` would become if we drop support for destructive sequences and do nothing else (note: it would still be possible to accidentally write a `for..in` loop over an infinite sequence).<br>&gt; <br>&gt; Okay, but all of these can be represented as infinite Collections.<br>&gt; <br>&gt; Let me explain. If a Sequence is truly multipass—that is, you can iterate over it many times and it will always return the same elements—then it must look something like this:<br>&gt; <br>&gt; 	struct MyElement { … }	<br>&gt; 	<br>&gt; 	struct MyState {<br>&gt; 		…<br>&gt; 		init() { … }<br>&gt; 		mutating func formNextElement(in: MySequence) { … }<br>&gt; 		var currentElement(in: MySequence) -&gt; MyElement? { … }<br>&gt; 	}<br>&gt; <br>&gt; 	struct MySequence: MultipassSequence {<br>&gt; 		struct Iterator: IteratorProtocol {<br>&gt; 			var sequence: MySequence<br>&gt; 			var state: MyState<br>&gt; 			<br>&gt; 			init(sequence: MySequence, initialState: MyState) {<br>&gt; 				self.sequence = sequence<br>&gt; 				self.state = initialState<br>&gt; 			}<br>&gt; 			<br>&gt; 			mutating func next() -&gt; MyElement? {<br>&gt; 				defer { someState.formNextElement(in: sequence) }<br>&gt; 				return someState.currentElement(in: sequence)<br>&gt; 			}<br>&gt; 		}<br>&gt; 		<br>&gt; 		func formIterator() -&gt; MyIterator {<br>&gt; 			return MyIterator(sequence: self, initialState: MyState())<br>&gt; 		}<br>&gt; 	}<br>&gt; <br>&gt; Now, the pieces may *appear* to be different—the Iterator may not actually need a reference to the Sequence, the state may be stored in many properties instead of just one, the code to iterate and get the current element may be directly in `next()` instead of in methods `next()` calls—but any multipass Sequence and Iterator could be refactored to match this pattern, so all multipass Sequences and Iterators are equivalent to it.<br>&gt; <br>&gt; But you can convert MySequence into a possibly infinite MyCollection like so:<br>&gt; <br>&gt; 	struct MyCollection: PossiblyInfiniteCollection {<br>&gt; 		enum Index: Comparable {<br>&gt; 			var offset: Int<br>&gt; 			var state: MyState?<br>&gt; 		}<br>&gt; 				<br>&gt; 		var startIndex: Index {<br>&gt; 			return Index(offset: 0, state: MyState())<br>&gt; 		}<br>&gt; 		var endIndex: Index {<br>&gt; 			return Index(offset: Int.max, state: nil)<br>&gt; 		}<br>&gt; 		<br>&gt; 		func formIndex(after index: inout Index) {<br>&gt; 			index.state!.formNextElement(in: self)<br>&gt; 			if index.state!.currentElement(in: self) == nil {<br>&gt; 				index.offset = Int.max<br>&gt; 			}<br>&gt; 			else {<br>&gt; 				index.offset! += 1<br>&gt; 			}<br>&gt; 		}<br>&gt; 		<br>&gt; 		subscript(index: Index) -&gt; MyElement {<br>&gt; 			return index.state!.currentElement(in: self)<br>&gt; 		}<br>&gt; 	}<br>&gt; 	<br>&gt; 	func == (lhs: MyCollection.Index, rhs: MyCollection.Index) -&gt; Bool {<br>&gt; 		return lhs.offset == rhs.offset<br>&gt; 	}<br>&gt; 	<br>&gt; 	func &lt; (lhs: MyCollection.Index, rhs: MyCollection.Index) -&gt; Bool {<br>&gt; 		return lhs.offset &lt; rhs.offset<br>&gt; 	}<br>&gt; <br>&gt; In other words, whatever state (other than the sequence itself) the Iterator needs to keep in its stored properties can instead be stored inside an index, and whatever logic the Iterator needs to implement its `next()` method can instead be split between `formIndex(after:)` and `subscript(_:)`. Any MultipassSequence can be written as a PossiblyInfiniteCollection if you&#39;re willing to put in the effort. And this is a boon to its multipass-ness, because you can not only start over again from the beginning, but start over from *any* step in the iteration.<br>&gt; <br>&gt; If any MultipassSequence can be written as a PossiblyInfiniteCollection, then we can eliminate another protocol:<br>&gt; <br>&gt;                        Sequence <br>&gt;                          /          \<br>&gt;                         /             \<br>&gt;                        /               \<br>&gt;   FiniteSequence         PossiblyInfiniteCollection<br>&gt;                       \                 /<br>&gt;                         \              / <br>&gt;                          \            /<br>&gt;                         Collection<br>&gt; <br>&gt; Now we can move any members which may not terminate early (like `map` or `last`) or are ill-defined when infinite (`count`) into `FiniteSequence` and `Collection`, while leaving any which often do terminate early (like `first` or `index(of:)`) in `Sequence` and `PossiblyInfiniteCollection`.<br>&gt; <br>&gt; Is this necessary? I don&#39;t really know. Arguably, we could simply provide this hierarchy:<br>&gt; <br>&gt;                        Sequence <br>&gt;                          /          \<br>&gt;                         /             \<br>&gt;                        /               \<br>&gt;      IteratorProtocol      Collection<br>&gt; <br>&gt; Where Iterators must be treated as potentially infinite, Collections are always finite, and you are asked (or, with a &quot;closed protocol&quot; feature, forced) to conform to one or the other, rather than to Sequence directly. Then the non-infinite-safe APIs like `map` can move onto `Collection` and we&#39;ll have covered most of the use cases which matter.<br></p><p>Thanks!  This is exactly the kind of discussion I intended to encourage with my post.  <br></p><p>This looks pretty good to me but it doesn’t address the issue that initiated this thread - removing destructive consumption (non-multipass) from Sequence.  How do envision that fitting in?<br></p><p>Can you also elaborate on what you envision `IteratorProtocol` would look like in this picture?  You depict it refining `Sequence`.  That is not the current design in the standard library so it isn’t immediately clear to me.<br></p><p>-Matthew<br></p><p>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>June 22, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Jun 22, 2016, at 2:57 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; &lt;Ahem&gt; “Iterators,” please.<br></p><p>That makes me happy - for some reason I thought it was still GeneratorProtocol<br></p><p>&gt;&gt; destructively, but such Generators would not conform to the needs of<br>&gt;&gt; Sequence. As such, the most significant impact would be the inability<br>&gt;&gt; to use such Generators in a for..in loop, <br>&gt; <br>&gt; Trying to evaluate this statement, it&#39;s clear we&#39;re missing lots of<br>&gt; detail here:<br>&gt; <br>&gt; * Would you remove Sequence?<br>&gt; * If so, what Protocol would embody “for...in-able?”<br>No, I would just remove the allowance in the documentation and API design for a destructive/consuming iteration. Sequence would be the interface to getting access to repeatable iteration, without the need for meeting the other requirements for Collection.<br></p><p>Sequence would be what java would refer to as Iterable, C# refers to as IEnumerable&lt;&gt;, but perhaps it is closest to the Enumerable mixin module in Ruby in terms of default utility methods supplied based on an implementation of ‘each’ (forEach() in Swift). Sequence is for…in-able because Sequence defined makeIterator(). The only difference is that subsequent calls to makeIterator() are expected to return conceptually equivalent elements in the same order.<br></p><p>&gt; * If not, would you remove Collection?<br></p><p>I see value in the other differentiating factors between Collection (not needing to be indexable, not needing to return a definitive count, and possibly not needing to be finite - although it sounds like collections may be effectively infinite to the extent that the integer type returned from count allows.<br></p><p>A Fibonacci-providing sequence can be written as a rather small closure, while my understanding of Collection would require either more code (that I likely don’t need), rather funky indexes that preserve state internally, and/or a switch to a non-iterative algorithm.<br></p><p>&gt; * What role would Iterator play?<br></p><p><br>So far I haven’t considered whether IteratorProtocol would be destructive, since my motivation was primarily around consistent Sequence behavior. By that light, an Iterator returned by a method other than Sequence.makeIterator() could still consume data. However, I wonder if supporting such Iterators provides enough value to be worthwhile - there aren’t that many methods that consume an IteratorProtocol (the AnyIterator&lt;&gt; initializer is the only one I know of) and without applicability to a Sequence such an iterator has less value.<br></p><p>-DW<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160622/5d8c0afe/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June 26, 2016 at 07:00:00am</p></header><div class="content"><p>on Wed Jun 22 2016, David Waite &lt;david-AT-alkaline-solutions.com&gt; wrote:<br></p><p>&gt;&gt; On Jun 22, 2016, at 2:57 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &lt;Ahem&gt; “Iterators,” please.<br>&gt;<br>&gt; That makes me happy - for some reason I thought it was still GeneratorProtocol<br>&gt;<br>&gt;&gt;&gt; destructively, but such Generators would not conform to the needs of<br>&gt;&gt;&gt; Sequence. As such, the most significant impact would be the inability<br>&gt;&gt;&gt; to use such Generators in a for..in loop, <br>&gt;&gt; <br>&gt;&gt; Trying to evaluate this statement, it&#39;s clear we&#39;re missing lots of<br>&gt;&gt; detail here:<br>&gt;&gt; <br>&gt;&gt; * Would you remove Sequence?<br>&gt;&gt; * If so, what Protocol would embody “for...in-able?”<br>&gt; No, I would just remove the allowance in the documentation and API<br>&gt; design for a destructive/consuming iteration. Sequence would be the<br>&gt; interface to getting access to repeatable iteration, without the need<br>&gt; for meeting the other requirements for Collection.<br></p><p>That would be wrong unless there exist substantial examples of a<br>multipass Sequence that *can&#39;t* meet the other requirements of<br>Collection without loss of efficiency.  And since I can write an adaptor<br>that turns any multipass sequence into a Collection, I think it&#39;s<br>trivial to prove that no such examples exist.<br></p><p>-- <br>-Dave<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
