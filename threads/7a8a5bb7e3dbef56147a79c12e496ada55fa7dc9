<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9b5e7f229ebf32c8eca02e7cee0f379f?s=50"></div><header><strong>[Proposal] Instance Operators</strong> from <string>Nicola Salmoria</string> &lt;nicola.salmoria at gmail.com&gt;<p>February 26, 2016 at 11:00:00am</p></header><div class="content"><p>I’m wondering if we might be trying to solve the wrong problem here.<br></p><p>Let’s look for example at part of the definition of the IntegerArithmeticType protocol (disregarding implementation details):<br></p><p>public protocol IntegerArithmeticType {<br></p><p>    public func +(lhs: Self, rhs: Self) -&gt; Self<br></p><p>    public static func addWithOverflow(lhs: Self, _ rhs: Self) -&gt; (Self, overflow: Bool)<br>}<br></p><p>There’s an obvious asymmetry here: + is defined as “public func”, while addWithOverflow is “public static func”.<br></p><p>Perhaps instead of extending how operators are defined, it would be more efficient to reconsider how protocol conformance should be defined.<br>It seems to me that a ‘swifter’ way to do the above would be<br></p><p>public protocol IntegerArithmeticType {<br></p><p>    public func add(to: Self) -&gt; Self<br></p><p>    public func addWithOverflow(to: Self) -&gt; (Self, overflow: Bool)<br>}<br></p><p>and then generic operators can simply be defined once at global scope:<br></p><p>public func +&lt;T: IntegerArithmeticType&gt;(lhs: T, rhs: T) -&gt; T {<br>	return lhs.add(hrs)<br>}<br></p><p>public func &amp;+&lt;T: IntegerArithmeticType&gt;(lhs: T, rhs: T) -&gt; T {<br>	return lhs.addWithOverflow(hrs).0<br>}<br></p><p><br>Equatable and Comparable have similar asymmetries:<br></p><p>/// Instances of conforming types can be compared for value equality<br>/// using operators `==` and `!=`.<br>///<br>/// When adopting `Equatable`, only the `==` operator is required to be<br>/// implemented.  The standard library provides an implementation for `!=`.<br>public protocol Equatable {<br>    public func ==(lhs: Self, rhs: Self) -&gt; Bool<br>}<br></p><p>so we need to define ==, but not != because it’s derived from the former.<br>Again, the cause of the inconsistency is the requirement to define the operator as part of the protocol conformance. If it was done like this, it might seem simpler and more symmetrical:<br></p><p>public protocol Equatable {<br>    public func equals(other: Self) -&gt; Bool<br>}<br></p><p>public func ==&lt;T: Equatable&gt;(lhs: T, rhs: T) -&gt; T {<br>	return lhs.equals(hrs)<br>}<br>public func !=&lt;T: Equatable&gt;(lhs: T, rhs: T) -&gt; T {<br>	return !lhs.equals(hrs)<br>}<br></p><p>Nicola<br></p><p>&gt; Hello.<br>&gt; <br>&gt; The proposal can be also read athttps://gist.github.com/vmartinelli/67d6ad234c7a4e14f8d5<br>&gt; <br>&gt; Original thread:https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160125/008508.html<br>&gt; <br>&gt; Opinions, comments and corrections (including on English grammar) are all welcome. :-)<br>&gt; <br>&gt; -Van<br>&gt; <br>&gt; ---------<br>&gt; <br>&gt; Instance Operators<br>&gt; Proposal:SE-NNNN(https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-instance-operators.md)<br>&gt; Author:Vanderlei Martinelli(https://github.com/vmartinelli)<br>&gt; Status:Awaiting review<br>&gt; Review manager: TBD<br>&gt; <br>&gt; Introduction<br>&gt; <br>&gt; The proposal aims to move operator implementation from the global and static scope into extension/struct/class instance scope.<br>&gt; <br>&gt; <br>&gt; Swift-evolution thread:link to the discussion thread for that proposal(https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160125/008508.html)<br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; When writing the protocol interface the operator is declarated inside the scope of that protocol, but its implementation has to be static and global. This, besides being inconsistent, might not the behaviour expected by programmers coming from other languages that have some kind of support for interface/protocol and operator implementation.<br>&gt; <br>&gt; <br>&gt; Example:<br>&gt; <br>&gt; // MARK: - protocolpublicprotocolMyDoubleType {publicfuncsomeUsefulFunction()publicfunc*(lhs:Self, rhs:Self)-&gt;Selfpublicpostfixfunc++(inoutx:Self)-&gt;Self }// MARK: - implementationextensionDouble: MyDoubleType {publicfuncsomeUsefulFunction() {// ...}// we cannot implement the operators here...}// ... but have to implement them herepublicfunc*(lhs:Double, rhs:Double)-&gt;Double{returnlhs.multipliedBy(rhs) }publicpostfixfunc++(inoutx:Double)-&gt;Double{   x+=1.0returnx }<br>&gt; <br>&gt; <br>&gt; Also the current implementation does not leave much room for future expansion in the use of operators (such as conversion between values, for example).<br>&gt; <br>&gt; Proposed solution<br>&gt; <br>&gt; Move the operator implementation into the extension/struct/class scope and turn operator funcs into instance funcs, using theoperatorkeyword.<br>&gt; <br>&gt; Detailed design<br>&gt; Protocol conformance<br>&gt; <br>&gt; After the change the above code can be written like the example bellow.<br>&gt; <br>&gt; // MARK: - protocolpublicprotocolMyDoubleType {publicfuncsomeUsefulFunction()publicoperator*(rhs:Self)-&gt;Selfpublicmutatingpostfixoperator++()-&gt;Self}// MARK: - implementationextensionDouble: MyDoubleType {publicfuncsomeUsefulFunction() {// ...}publicoperator*(rhs:Double)-&gt;Double{returnself.multipliedBy(rhs)   }publicmutatingpostfixoperator++()-&gt;Double{self+=1.0returnself} }<br>&gt; <br>&gt; Operator funcs everywhere<br>&gt; <br>&gt; An operator does not have to be implemented only to conform to a protocol, however. It can be also be implemented in any other place where a common func is. This means that even the current form can be supported.<br>&gt; <br>&gt; Operator internal names<br>&gt; <br>&gt; Perhaps because of the internal implementation of Swift, operators have to have names to be handled. The suggestion is to adopt__operator__GreaterThanOrEqualfor a&gt;=operator, as example. The operator introduction would be:<br>&gt; <br>&gt; infixoperator&gt;={associativitynoneprecedence130name&quot;GreaterThanOrEqual&quot;}<br>&gt; <br>&gt; <br>&gt; So the code will be written like this...<br>&gt; <br>&gt; structMyStruct {operator&gt;=(other: MyStruct)-&gt;Bool{return...} }<br>&gt; <br>&gt; <br>&gt; ... but translated internally to this:<br>&gt; <br>&gt; structMyStruct {func__operator__GreaterThanOrEqual(other: MyStruct)-&gt;Bool{return...} }<br>&gt; <br>&gt; Impact on existing code<br>&gt; <br>&gt; Since after this change an operator can be implemented in any other place where a common func can be, the current implementation may continue to exist, but marked as deprecated with a compiler/analyser warning.<br>&gt; <br>&gt; <br>&gt; Also thefunckeyword would be deprecated for operators as well, using theoperatorto declare/implement an operator func.<br>&gt; <br>&gt; Alternatives considered<br>&gt; Status quo<br>&gt; <br>&gt; Leave things as they are. Even being inconsistent or not allowing new possibilities that instance operators will bring.<br>&gt; <br>&gt; Static implementation inside extension/struct/class scope<br>&gt; <br>&gt; This is the way operators are implemented in C#, for example. The change would be only aesthetic. The functionality would remain the same as today.<br>&gt; <br>&gt; <br>&gt; As the types may differ from protocol/structure/class, this would allow state within the scope of operators that have nothing to do with that type. Not a good thing. In this case it might be better to keep things as they are.<br>&gt; <br>&gt; <br>&gt; Example:<br>&gt; <br>&gt; // MARK: - protocolpublicprotocolMyDoubleType {publicfuncsomeUsefulFunction()publicstaticoperator*(lhs:Self, rhs:Self)-&gt;Selfpublicstaticoperator/(lhs:Int64, rhs:Int64)-&gt;Int64// what?publicstaticpostfixoperator++(inoutx:Self)-&gt;Self}// MARK: - implementationextensionDouble: MyDoubleType {publicfuncsomeUsefulFunction() {// ...}publicstaticoperator*(lhs:Double, rhs:Double)-&gt;Double{returnlhs.multipliedBy(rhs)   }// this should be implemented inside a Int64 type, not here...publicstaticoperator/(lhs:Int64, rhs:Int64)-&gt;Int64{// ...}publicstaticpostfixoperator++(inoutx:Double)-&gt;Double{     x+=1.0returnx   } }<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160226/7a8a7dc9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Proposal] Instance Operators</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>February 26, 2016 at 04:00:00pm</p></header><div class="content"><p>I don&#39;t think symmetric operators should be mapped to asymmetric methods which are only dispatched on the receiver&#39;s type.<br></p><p>Of course the current scheme using global functions with no dynamic dispatch at all is not much better (the selected function depends on the static types I happen to see at the call site but at least it isn&#39;t preferring one of the arguments.<br>Having real multiple dispatch would be nice :-)<br></p><p>-Thorsten <br></p><p>&gt; Am 26.02.2016 um 11:41 schrieb Nicola Salmoria via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; I’m wondering if we might be trying to solve the wrong problem here.<br>&gt; <br>&gt; Let’s look for example at part of the definition of the IntegerArithmeticType protocol (disregarding implementation details):<br>&gt; <br>&gt; public protocol IntegerArithmeticType {<br>&gt; <br>&gt;     public func +(lhs: Self, rhs: Self) -&gt; Self<br>&gt; <br>&gt;     public static func addWithOverflow(lhs: Self, _ rhs: Self) -&gt; (Self, overflow: Bool)<br>&gt; }<br>&gt; <br>&gt; There’s an obvious asymmetry here: + is defined as “public func”, while addWithOverflow is “public static func”.<br>&gt; <br>&gt; Perhaps instead of extending how operators are defined, it would be more efficient to reconsider how protocol conformance should be defined.<br>&gt; It seems to me that a ‘swifter’ way to do the above would be<br>&gt; <br>&gt; public protocol IntegerArithmeticType {<br>&gt; <br>&gt;     public func add(to: Self) -&gt; Self<br>&gt; <br>&gt;     public func addWithOverflow(to: Self) -&gt; (Self, overflow: Bool)<br>&gt; }<br>&gt; <br>&gt; and then generic operators can simply be defined once at global scope:<br>&gt; <br>&gt; public func +&lt;T: IntegerArithmeticType&gt;(lhs: T, rhs: T) -&gt; T {<br>&gt; 	return lhs.add(hrs)<br>&gt; }<br>&gt; <br>&gt; public func &amp;+&lt;T: IntegerArithmeticType&gt;(lhs: T, rhs: T) -&gt; T {<br>&gt; 	return lhs.addWithOverflow(hrs).0<br>&gt; }<br>&gt; <br>&gt; <br>&gt; Equatable and Comparable have similar asymmetries:<br>&gt; <br>&gt; /// Instances of conforming types can be compared for value equality<br>&gt; /// using operators `==` and `!=`.<br>&gt; ///<br>&gt; /// When adopting `Equatable`, only the `==` operator is required to be<br>&gt; /// implemented.  The standard library provides an implementation for `!=`.<br>&gt; public protocol Equatable {<br>&gt;     public func ==(lhs: Self, rhs: Self) -&gt; Bool<br>&gt; }<br>&gt; <br>&gt; so we need to define ==, but not != because it’s derived from the former.<br>&gt; Again, the cause of the inconsistency is the requirement to define the operator as part of the protocol conformance. If it was done like this, it might seem simpler and more symmetrical:<br>&gt; <br>&gt; public protocol Equatable {<br>&gt;     public func equals(other: Self) -&gt; Bool<br>&gt; }<br>&gt; <br>&gt; public func ==&lt;T: Equatable&gt;(lhs: T, rhs: T) -&gt; T {<br>&gt; 	return lhs.equals(hrs)<br>&gt; }<br>&gt; public func !=&lt;T: Equatable&gt;(lhs: T, rhs: T) -&gt; T {<br>&gt; 	return !lhs.equals(hrs)<br>&gt; }<br>&gt; <br>&gt; Nicola<br>&gt; <br>&gt; &gt; Hello.<br>&gt; &gt; <br>&gt; &gt; The proposal can be also read athttps://gist.github.com/vmartinelli/67d6ad234c7a4e14f8d5<br>&gt; &gt; <br>&gt; &gt; Original thread:https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160125/008508.html<br>&gt; &gt; <br>&gt; &gt; Opinions, comments and corrections (including on English grammar) are all welcome. :-)<br>&gt; &gt; <br>&gt; &gt; -Van<br>&gt; &gt; <br>&gt; &gt; ---------<br>&gt; &gt; <br>&gt; &gt; Instance Operators<br>&gt; &gt; Proposal:SE-NNNN(https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-instance-operators.md)<br>&gt; &gt; Author:Vanderlei Martinelli(https://github.com/vmartinelli)<br>&gt; &gt; Status:Awaiting review<br>&gt; &gt; Review manager: TBD<br>&gt; &gt; <br>&gt; &gt; Introduction<br>&gt; &gt; <br>&gt; &gt; The proposal aims to move operator implementation from the global and static scope into extension/struct/class instance scope.<br>&gt; &gt; <br>&gt; &gt; <br>&gt; &gt; Swift-evolution thread:link to the discussion thread for that proposal(https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160125/008508.html)<br>&gt; &gt; <br>&gt; &gt; Motivation<br>&gt; &gt; <br>&gt; &gt; When writing the protocol interface the operator is declarated inside the scope of that protocol, but its implementation has to be static and global. This, besides being inconsistent, might not the behaviour expected by programmers coming from other languages that have some kind of support for interface/protocol and operator implementation.<br>&gt; &gt; <br>&gt; &gt; <br>&gt; &gt; Example:<br>&gt; &gt; <br>&gt; &gt; // MARK: - protocolpublicprotocolMyDoubleType {publicfuncsomeUsefulFunction()publicfunc*(lhs:Self, rhs:Self)-&gt;Selfpublicpostfixfunc++(inoutx:Self)-&gt;Self }// MARK: - implementationextensionDouble: MyDoubleType {publicfuncsomeUsefulFunction() {// ...}// we cannot implement the operators here...}// ... but have to implement them herepublicfunc*(lhs:Double, rhs:Double)-&gt;Double{returnlhs.multipliedBy(rhs) }publicpostfixfunc++(inoutx:Double)-&gt;Double{   x+=1.0returnx }<br>&gt; &gt; <br>&gt; &gt; <br>&gt; &gt; Also the current implementation does not leave much room for future expansion in the use of operators (such as conversion between values, for example).<br>&gt; &gt; <br>&gt; &gt; Proposed solution<br>&gt; &gt; <br>&gt; &gt; Move the operator implementation into the extension/struct/class scope and turn operator funcs into instance funcs, using theoperatorkeyword.<br>&gt; &gt; <br>&gt; &gt; Detailed design<br>&gt; &gt; Protocol conformance<br>&gt; &gt; <br>&gt; &gt; After the change the above code can be written like the example bellow.<br>&gt; &gt; <br>&gt; &gt; // MARK: - protocolpublicprotocolMyDoubleType {publicfuncsomeUsefulFunction()publicoperator*(rhs:Self)-&gt;Selfpublicmutatingpostfixoperator++()-&gt;Self}// MARK: - implementationextensionDouble: MyDoubleType {publicfuncsomeUsefulFunction() {// ...}publicoperator*(rhs:Double)-&gt;Double{returnself.multipliedBy(rhs)   }publicmutatingpostfixoperator++()-&gt;Double{self+=1.0returnself} }<br>&gt; &gt; <br>&gt; &gt; Operator funcs everywhere<br>&gt; &gt; <br>&gt; &gt; An operator does not have to be implemented only to conform to a protocol, however. It can be also be implemented in any other place where a common func is. This means that even the current form can be supported.<br>&gt; &gt; <br>&gt; &gt; Operator internal names<br>&gt; &gt; <br>&gt; &gt; Perhaps because of the internal implementation of Swift, operators have to have names to be handled. The suggestion is to adopt__operator__GreaterThanOrEqualfor a&gt;=operator, as example. The operator introduction would be:<br>&gt; &gt; <br>&gt; &gt; infixoperator&gt;={associativitynoneprecedence130name&quot;GreaterThanOrEqual&quot;}<br>&gt; &gt; <br>&gt; &gt; <br>&gt; &gt; So the code will be written like this...<br>&gt; &gt; <br>&gt; &gt; structMyStruct {operator&gt;=(other: MyStruct)-&gt;Bool{return...} }<br>&gt; &gt; <br>&gt; &gt; <br>&gt; &gt; ... but translated internally to this:<br>&gt; &gt; <br>&gt; &gt; structMyStruct {func__operator__GreaterThanOrEqual(other: MyStruct)-&gt;Bool{return...} }<br>&gt; &gt; <br>&gt; &gt; Impact on existing code<br>&gt; &gt; <br>&gt; &gt; Since after this change an operator can be implemented in any other place where a common func can be, the current implementation may continue to exist, but marked as deprecated with a compiler/analyser warning.<br>&gt; &gt; <br>&gt; &gt; <br>&gt; &gt; Also thefunckeyword would be deprecated for operators as well, using theoperatorto declare/implement an operator func.<br>&gt; &gt; <br>&gt; &gt; Alternatives considered<br>&gt; &gt; Status quo<br>&gt; &gt; <br>&gt; &gt; Leave things as they are. Even being inconsistent or not allowing new possibilities that instance operators will bring.<br>&gt; &gt; <br>&gt; &gt; Static implementation inside extension/struct/class scope<br>&gt; &gt; <br>&gt; &gt; This is the way operators are implemented in C#, for example. The change would be only aesthetic. The functionality would remain the same as today.<br>&gt; &gt; <br>&gt; &gt; <br>&gt; &gt; As the types may differ from protocol/structure/class, this would allow state within the scope of operators that have nothing to do with that type. Not a good thing. In this case it might be better to keep things as they are.<br>&gt; &gt; <br>&gt; &gt; <br>&gt; &gt; Example:<br>&gt; &gt; <br>&gt; &gt; // MARK: - protocolpublicprotocolMyDoubleType {publicfuncsomeUsefulFunction()publicstaticoperator*(lhs:Self, rhs:Self)-&gt;Selfpublicstaticoperator/(lhs:Int64, rhs:Int64)-&gt;Int64// what?publicstaticpostfixoperator++(inoutx:Self)-&gt;Self}// MARK: - implementationextensionDouble: MyDoubleType {publicfuncsomeUsefulFunction() {// ...}publicstaticoperator*(lhs:Double, rhs:Double)-&gt;Double{returnlhs.multipliedBy(rhs)   }// this should be implemented inside a Int64 type, not here...publicstaticoperator/(lhs:Int64, rhs:Int64)-&gt;Int64{// ...}publicstaticpostfixoperator++(inoutx:Double)-&gt;Double{     x+=1.0returnx   } }<br>&gt; &gt; <br>&gt; &gt; <br>&gt; &gt; <br>&gt; &gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160226/6070ecc6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9b5e7f229ebf32c8eca02e7cee0f379f?s=50"></div><header><strong>[Proposal] Instance Operators</strong> from <string>Nicola Salmoria</string> &lt;nicola.salmoria at gmail.com&gt;<p>February 26, 2016 at 04:00:00pm</p></header><div class="content"><p>If the argument symmetry should be preserved, I think I&#39;d still prefer to<br>leave operators out of this, and consistently use static methods, like this:<br></p><p>public protocol IntegerArithmeticType {<br>    public static func add(lhs: Self, _ rhs: Self) -&gt; Self<br>    public static func addWithOverflow(lhs: Self, _ rhs: Self) -&gt; (Self,<br>overflow: Bool)<br>}<br></p><p>public func +&lt;T: IntegerArithmeticType&gt;(lhs: T, rhs: T) -&gt; T {<br>    return T.add(lhs, rhs)<br>}<br>public func &amp;+&lt;T: IntegerArithmeticType&gt;(lhs: T, rhs: T) -&gt; T {<br>    return T.addWithOverflow(lhs, rhs).0<br>}<br></p><p><br>public protocol Equatable {<br>    public static func equal(lhs: Self, _ rhs: Self) -&gt; Bool<br>}<br></p><p>public func ==&lt;T: Equatable&gt;(lhs: T, rhs: T) -&gt; T {<br>    return T.equal(lhs, rhs)<br>}<br>public func !=&lt;T: Equatable&gt;(lhs: T, rhs: T) -&gt; T {<br>    return !T.equals(lhs, rhs)<br>}<br></p><p><br>--<br>Nicola<br></p><p><br>On Fri, Feb 26, 2016 at 4:18 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br></p><p>&gt; I don&#39;t think symmetric operators should be mapped to asymmetric methods<br>&gt; which are only dispatched on the receiver&#39;s type.<br>&gt;<br>&gt; Of course the current scheme using global functions with no dynamic<br>&gt; dispatch at all is not much better (the selected function depends on the<br>&gt; static types I happen to see at the call site but at least it isn&#39;t<br>&gt; preferring one of the arguments.<br>&gt; Having real multiple dispatch would be nice :-)<br>&gt;<br>&gt; -Thorsten<br>&gt;<br>&gt; Am 26.02.2016 um 11:41 schrieb Nicola Salmoria via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt;<br>&gt; I’m wondering if we might be trying to solve the wrong problem here.<br>&gt;<br>&gt; Let’s look for example at part of the definition of the<br>&gt; IntegerArithmeticType protocol (disregarding implementation details):<br>&gt;<br>&gt; public protocol IntegerArithmeticType {<br>&gt;<br>&gt;     public func +(lhs: Self, rhs: Self) -&gt; Self<br>&gt;<br>&gt;     public static func addWithOverflow(lhs: Self, _ rhs: Self) -&gt; (Self,<br>&gt; overflow: Bool)<br>&gt; }<br>&gt;<br>&gt; There’s an obvious asymmetry here: + is defined as “public func”, while<br>&gt; addWithOverflow is “public static func”.<br>&gt;<br>&gt; Perhaps instead of extending how operators are defined, it would be more<br>&gt; efficient to reconsider how protocol conformance should be defined.<br>&gt; It seems to me that a ‘swifter’ way to do the above would be<br>&gt;<br>&gt; public protocol IntegerArithmeticType {<br>&gt;<br>&gt;     public func add(to: Self) -&gt; Self<br>&gt;<br>&gt;     public func addWithOverflow(to: Self) -&gt; (Self, overflow: Bool)<br>&gt; }<br>&gt;<br>&gt; and then generic operators can simply be defined once at global scope:<br>&gt;<br>&gt; public func +&lt;T: IntegerArithmeticType&gt;(lhs: T, rhs: T) -&gt; T {<br>&gt; return lhs.add(hrs)<br>&gt; }<br>&gt;<br>&gt; public func &amp;+&lt;T: IntegerArithmeticType&gt;(lhs: T, rhs: T) -&gt; T {<br>&gt; return lhs.addWithOverflow(hrs).0<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Equatable and Comparable have similar asymmetries:<br>&gt;<br>&gt; /// Instances of conforming types can be compared for value equality<br>&gt; /// using operators `==` and `!=`.<br>&gt; ///<br>&gt; /// When adopting `Equatable`, only the `==` operator is required to be<br>&gt; /// implemented.  The standard library provides an implementation for `!=`.<br>&gt; public protocol Equatable {<br>&gt;     public func ==(lhs: Self, rhs: Self) -&gt; Bool<br>&gt; }<br>&gt;<br>&gt; so we need to define ==, but not != because it’s derived from the former.<br>&gt; Again, the cause of the inconsistency is the requirement to define the<br>&gt; operator as part of the protocol conformance. If it was done like this, it<br>&gt; might seem simpler and more symmetrical:<br>&gt;<br>&gt; public protocol Equatable {<br>&gt;     public func equals(other: Self) -&gt; Bool<br>&gt; }<br>&gt;<br>&gt; public func ==&lt;T: Equatable&gt;(lhs: T, rhs: T) -&gt; T {<br>&gt; return lhs.equals(hrs)<br>&gt; }<br>&gt; public func !=&lt;T: Equatable&gt;(lhs: T, rhs: T) -&gt; T {<br>&gt; return !lhs.equals(hrs)<br>&gt; }<br>&gt;<br>&gt; Nicola<br>&gt;<br>&gt; &gt; Hello.<br>&gt; &gt;<br>&gt; &gt; The proposal can be also read<br>&gt; athttps://gist.github.com/vmartinelli/67d6ad234c7a4e14f8d5<br>&gt; &gt;<br>&gt; &gt; Original thread:https://<br>&gt; lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160125/008508.html<br>&gt; &gt;<br>&gt; &gt; Opinions, comments and corrections (including on English grammar) are<br>&gt; all welcome. :-)<br>&gt; &gt;<br>&gt; &gt; -Van<br>&gt; &gt;<br>&gt; &gt; ---------<br>&gt; &gt;<br>&gt; &gt; Instance Operators<br>&gt; &gt; Proposal:SE-NNNN(<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-instance-operators.md<br>&gt; )<br>&gt; &gt; Author:Vanderlei Martinelli(https://github.com/vmartinelli)<br>&gt; &gt; Status:Awaiting review<br>&gt; &gt; Review manager: TBD<br>&gt; &gt;<br>&gt; &gt; Introduction<br>&gt; &gt;<br>&gt; &gt; The proposal aims to move operator implementation from the global and<br>&gt; static scope into extension/struct/class instance scope.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; Swift-evolution thread:link to the discussion thread for that proposal(<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160125/008508.html<br>&gt; )<br>&gt; &gt;<br>&gt; &gt; Motivation<br>&gt; &gt;<br>&gt; &gt; When writing the protocol interface the operator is declarated inside<br>&gt; the scope of that protocol, but its implementation has to be static and<br>&gt; global. This, besides being inconsistent, might not the behaviour expected<br>&gt; by programmers coming from other languages that have some kind of support<br>&gt; for interface/protocol and operator implementation.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; Example:<br>&gt; &gt;<br>&gt; &gt; // MARK: - protocolpublicprotocolMyDoubleType<br>&gt; {publicfuncsomeUsefulFunction()publicfunc*(lhs:Self,<br>&gt; rhs:Self)-&gt;Selfpublicpostfixfunc++(inoutx:Self)-&gt;Self }// MARK: -<br>&gt; implementationextensionDouble: MyDoubleType {publicfuncsomeUsefulFunction()<br>&gt; {// ...}// we cannot implement the operators here...}// ... but have to<br>&gt; implement them herepublicfunc*(lhs:Double,<br>&gt; rhs:Double)-&gt;Double{returnlhs.multipliedBy(rhs)<br>&gt; }publicpostfixfunc++(inoutx:Double)-&gt;Double{   x+=1.0returnx }<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; Also the current implementation does not leave much room for future<br>&gt; expansion in the use of operators (such as conversion between values, for<br>&gt; example).<br>&gt; &gt;<br>&gt; &gt; Proposed solution<br>&gt; &gt;<br>&gt; &gt; Move the operator implementation into the extension/struct/class scope<br>&gt; and turn operator funcs into instance funcs, using theoperatorkeyword.<br>&gt; &gt;<br>&gt; &gt; Detailed design<br>&gt; &gt; Protocol conformance<br>&gt; &gt;<br>&gt; &gt; After the change the above code can be written like the example bellow.<br>&gt; &gt;<br>&gt; &gt; // MARK: - protocolpublicprotocolMyDoubleType<br>&gt; {publicfuncsomeUsefulFunction()publicoperator*(rhs:Self)-&gt;Selfpublicmutatingpostfixoperator++()-&gt;Self}//<br>&gt; MARK: - implementationextensionDouble: MyDoubleType<br>&gt; {publicfuncsomeUsefulFunction() {//<br>&gt; ...}publicoperator*(rhs:Double)-&gt;Double{returnself.multipliedBy(rhs)<br>&gt; }publicmutatingpostfixoperator++()-&gt;Double{self+=1.0returnself} }<br>&gt; &gt;<br>&gt; &gt; Operator funcs everywhere<br>&gt; &gt;<br>&gt; &gt; An operator does not have to be implemented only to conform to a<br>&gt; protocol, however. It can be also be implemented in any other place where a<br>&gt; common func is. This means that even the current form can be supported.<br>&gt; &gt;<br>&gt; &gt; Operator internal names<br>&gt; &gt;<br>&gt; &gt; Perhaps because of the internal implementation of Swift, operators have<br>&gt; to have names to be handled. The suggestion is to<br>&gt; adopt__operator__GreaterThanOrEqualfor a&gt;=operator, as example. The<br>&gt; operator introduction would be:<br>&gt; &gt;<br>&gt; &gt; infixoperator&gt;={associativitynoneprecedence130name&quot;GreaterThanOrEqual&quot;}<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; So the code will be written like this...<br>&gt; &gt;<br>&gt; &gt; structMyStruct {operator&gt;=(other: MyStruct)-&gt;Bool{return...} }<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; ... but translated internally to this:<br>&gt; &gt;<br>&gt; &gt; structMyStruct {func__operator__GreaterThanOrEqual(other:<br>&gt; MyStruct)-&gt;Bool{return...} }<br>&gt; &gt;<br>&gt; &gt; Impact on existing code<br>&gt; &gt;<br>&gt; &gt; Since after this change an operator can be implemented in any other<br>&gt; place where a common func can be, the current implementation may continue<br>&gt; to exist, but marked as deprecated with a compiler/analyser warning.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; Also thefunckeyword would be deprecated for operators as well, using<br>&gt; theoperatorto declare/implement an operator func.<br>&gt; &gt;<br>&gt; &gt; Alternatives considered<br>&gt; &gt; Status quo<br>&gt; &gt;<br>&gt; &gt; Leave things as they are. Even being inconsistent or not allowing new<br>&gt; possibilities that instance operators will bring.<br>&gt; &gt;<br>&gt; &gt; Static implementation inside extension/struct/class scope<br>&gt; &gt;<br>&gt; &gt; This is the way operators are implemented in C#, for example. The change<br>&gt; would be only aesthetic. The functionality would remain the same as today.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; As the types may differ from protocol/structure/class, this would allow<br>&gt; state within the scope of operators that have nothing to do with that type.<br>&gt; Not a good thing. In this case it might be better to keep things as they<br>&gt; are.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; Example:<br>&gt; &gt;<br>&gt; &gt; // MARK: - protocolpublicprotocolMyDoubleType<br>&gt; {publicfuncsomeUsefulFunction()publicstaticoperator*(lhs:Self,<br>&gt; rhs:Self)-&gt;Selfpublicstaticoperator/(lhs:Int64, rhs:Int64)-&gt;Int64//<br>&gt; what?publicstaticpostfixoperator++(inoutx:Self)-&gt;Self}// MARK: -<br>&gt; implementationextensionDouble: MyDoubleType {publicfuncsomeUsefulFunction()<br>&gt; {// ...}publicstaticoperator*(lhs:Double,<br>&gt; rhs:Double)-&gt;Double{returnlhs.multipliedBy(rhs)   }// this should be<br>&gt; implemented inside a Int64 type, not<br>&gt; here...publicstaticoperator/(lhs:Int64, rhs:Int64)-&gt;Int64{//<br>&gt; ...}publicstaticpostfixoperator++(inoutx:Double)-&gt;Double{<br>&gt; x+=1.0returnx   } }<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160226/8303a256/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
