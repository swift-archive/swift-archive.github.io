<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] property lists</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 10, 2016 at 09:00:00pm</p></header><div class="content"><p>I have always considered the Flexible Memberwise Initialization proposal to be just a first step (as evidenced by the many future enhancements it discussed).  Its review has inspired new ideas and helped to shape my vision of the best long-term solution.    My final thoughts about the review can be found here: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/006176.html<br></p><p>Property lists is the third in a series of three proposals describing general features that can work together to form a complete solution.<br></p><p>The proposal drafts can be found at the following links:<br></p><p>* Parameter forwarding: https://github.com/anandabits/swift-evolution/blob/parameter-forwarding/proposals/NNNN-parameter-forwarding.md<br>* Partial initializers: https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md<br>* Property lists: https://github.com/anandabits/swift-evolution/blob/property-lists/proposals/NNNN-property-lists.md<br></p><p>Matthew<br>Property Lists<br></p><p>Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-property-lists.md&gt;<br>Author(s): Matthew Johnson &lt;https://github.com/anandabits&gt;<br>Status: Awaiting review<br>Review manager: TBD<br>Introduction<br></p><p>This proposal introduces the propertylist declaration. Property lists provide concise syntactic sugar for declaring memberwise partial initializers and memberwise computed tuple properties.<br></p><p>NOTE: I do not love the name “property lists” for the feature or the keyword but haven’t thought of anything better. Suggestions are welcome.<br></p><p>Swift-evolution thread: Proposal Draft: Property Lists &lt;https://lists.swift.org/pipermail/swift-evolution&gt;<br>Motivation<br></p><p>I believe the review of the Flexible Memberwise Initialization &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md&gt; proposal demonstrated a strong demand for concise yet flexible memberwise initialization. The discussion highlighted several areas where that proposal fell short:<br></p><p>Clarity regarding which parameters receive memberwise initialization.<br>Control over which parameters receive memberwise initialization.<br>Control over specific memberwise parameter ordering.<br>Control over parameter labels.<br>Control over default parameter values, especially for let properties.<br>It is a very narrow, special case feature.<br>This proposal builds on the Partial Initializer &lt;https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md&gt; proposal to solve these problems using a more general underlying mechanism. It enables truly flexible memberwise initialization. <br></p><p>Property lists also support other memberwise features, beginning with memberwise computed tuple properties.<br></p><p>Proposed solution<br></p><p>There are two ways to specify a property list. The basic mechanism is a property list declaration that looks as follows: <br></p><p>  propertylist configProperties: aPropName, customLabel anotherPropName = 42<br>All properties mentioned in the property list declaration must be visible at the site of the declaration.<br></p><p>A propertylist attribute also exists for property declarations to support cases where a list of property declarations should also be treated as a property list:<br></p><p>  @propertylist(aPropertyListIdentifier) let prop1, prop2: Int<br>A property list can contain any kind of property, including those with behaviors. However, when certain kinds of properties are included it will not be possible to synthesize a partial memberwise initializer and / or a setter for the computed tuple property.<br></p><p>Synthesized elements<br></p><p>A typealias will always be synthesized:<br></p><p>It will have a name matching the identifier of the property list, with the first character transformed to upper case.<br>It will be a tuple type containing labels and types matching those specified in the property list.<br>A computed tuple property will always be synthesized:<br></p><p>It will always include a getter.<br>Visibility of the getter will match the visibility of the least visible getter.<br>It will contain a setter as long as all of the properties are settable.<br>Visibility of the setter will match the visibility of the least visible setter.<br>A paritial initializer will only be generated if:<br></p><p>All properties are stored properties.<br>None are let properties with an initial value.<br>None have a behavior which is incompatible with phase 1 initialization.<br>Visibility of the partial initializer will match the least visible setter for structs. Partial initializers for classes are always private (as specified by the partial initializer proposal).<br>The property list is declared in the main body of the type, not an extension, unless the type is a struct.<br>If stored properties are allowed in extensions and / or protocols in the future, all properties included in the list must be declared within the same body as the property list for a partial initializer to be synthesized (either the main body of the type or the body of the same extension or same protocol).<br>The structure of the synthesized elements is as follows:<br></p><p>Ordering of partial initializer parameters and tuple members will match the order of the property list declaration.<br>The external parameter labels and tuple labels will match the label specified in the property list if it exists and the property name otherwise.<br>The default value for partial initializer parameters will be the default value specified in the property list if it exists and the initial value of the property otherwise (if that exists). If neither exist the parameter will not have a default value.<br>Visibility of a synthesized members is capped at internal unless public is explicitly specified. If public (or internal) is explicitly specified, all properties referenced must have getter and setter visibility of at least the specified access level or a compiler error will result.<br></p><p>Examples<br></p><p>Basic example<br></p><p>public struct S {<br>  let i: Int = 42<br>  public var s: String = &quot;hello&quot;<br>  public var d: Double<br>  <br>  // user declares:<br>  public propertylist custom: dLabel d = 42, s<br>  <br>  // compiler synthesizes:<br>  public typealias Custom = (dLabel: Double, s: String)<br>  public var custom: Custom {<br>    get { return (dLabel: d, s: s) }<br>    set { (d, s) = newValue }<br>  }<br>  public partial init custom(dlabel d: Double = 42, s: String = &quot;hello&quot;) {<br>    self.d = d<br>    self.s = s<br>  }<br>}<br>Including a let with a initial value<br></p><p>struct S {<br>  let i: Int = 42<br>  let s: String = &quot;hello&quot;<br>  var d: Double<br>  <br>  // user declares:<br>  propertylist custom: dLabel d, s<br>  <br>  // compiler synthesizes:<br>  typealias Custom = (dLabel: Double, s: String)<br>  var custom: Custom {<br>    get { return (dLabel: d, s: s) }<br>  }<br>  // NOTE: no setter because a `let` was included<br>  // and no partial initializer because the `let` <br>  // has an initial value.<br>}<br>Including a lazy property<br></p><p>struct S {<br>  let i: Int<br>  var s: String<br>  lazy var d: Double<br>  <br>  // user declares:<br>  propertylist custom: dLabel d, s<br>  <br>  // compiler synthesizes:<br>  typealias Custom = (dLabel: Double, s: String)<br>  var custom: Custom {<br>    get { return (dLabel: d, s: s) }<br>    set { (d, s) = newValue }<br>  }<br>  // NOTE: no partial initializer because a `lazy var` was included.<br>}<br>Including a var with a private setter<br></p><p>struct S {<br>  let i: Int<br>  var s: String<br>  private(set) var d: Double = 42<br>  <br>  // user declares:<br>  propertylist custom: dLabel d, s = &quot;hello&quot;<br>  <br>  // compiler synthesizes:<br>  typealias Custom = (dLabel: Double, s: String)<br>  private(set) var custom: Custom {<br>    get { return (dLabel: d, s: s) }<br>    set { (d, s) = newValue }<br>  }<br>  // NOTE: The initial value for `d` is used as a default <br>  // parameter value because a different default parameter value <br>  // was not specified.<br>  private partial init custom(dlabel d: Double = 42, s: String = &quot;hello&quot;) {<br>    self.d = d<br>    self.s = s<br>  }<br>}<br>Including a computed property<br></p><p>struct S {<br>  let i: Int<br>  var s: String<br>  var d: Double {<br>    get { return getValueFromSomewhere() }<br>    set { storeValueSomewhere(newValue) }<br>  }<br>  <br>  // user declares:<br>  propertylist custom: dLabel d, s<br>  <br>  // compiler synthesizes:<br>  typealias Custom = (dLabel: Double, s: String)<br>  var custom: Custom {<br>    get { return (dLabel: d, s: s) }<br>    set { (d, s) = newValue }<br>  }<br>  // NOTE: no partial initializer because a computed property was included.<br>}<br>Using the @propertylist attribute<br></p><p>struct S {<br>  @propertylist(custom) var s: String, d: Double = 42<br>  private let i: Int<br>  <br>  // compiler synthesizes:<br>  typealias Custom = (s: String, d: Double)<br>  var custom: Custom {<br>    get { return (s: s, d: d) }<br>    set { (s, d) = newValue }<br>  }<br>  partial init custom(s: String, d: Double = 42) {<br>    self.s = s<br>    self.d = d<br>  }<br>}<br>Using a property list declaration for memberwise intialization<br></p><p>struct S {<br>  var x, y, z: Int<br>  let s: String<br>  let d: Double<br>  <br>  propertylist randomGroup aString s = &quot;hello&quot;, anInt x = 42<br>  <br>  // user declares<br>  init(...randomGroup) {<br>    y = 42<br>    z = 42<br>    d = 42<br>  }<br>  <br>  // compiler synthesizes<br>  partial init randomGroup(aString s: String = &quot;hello&quot;, anInt x: Int = 42) {<br>    self.s = s<br>    self.x = x<br>  }<br>  init(aString s: String = &quot;hello&quot;, anInt x: Int = 42) {<br>    randomGroup.init(aString: s, anInt: x)<br>    y = 42<br>    z = 42<br>    d = 42<br>  }<br>  <br>}<br>Using the property list attribute for memberwise intialization<br></p><p>```swift<br>struct S {<br>@propertylist(declaredTogether) var x, y, z: Int<br>let s: String<br>let d: Double<br></p><p>// user declares:<br>init(…declaredTogether) {<br>s = “hello”<br>d = 42<br>}<br></p><p>// compiler synthesizes:<br>partial init declaredTogether(x: Int, y: Int, z: Int) {<br>self.x = x<br>self.y = y<br>self.z = z<br>} init(x: Int, y: Int, z: Int) {<br>declaredTogether.init(x: Int, y: Int, z: Int)<br>s = “hello”<br>d = 42<br>}<br></p><p>}<br></p><p>Implicit property lists<br></p><p>It may be desirable to have several implicit property lists available, such as one that includes all properties of the type. Properties would appear in any implicit property lists in declaration order.<br></p><p>The specific details of what implicit property lists should be available and what they should be called is a good topic for bikeshedding.<br></p><p>Detailed design<br></p><p>TODO but should fall out pretty clearly from the proposed solution<br></p><p>Impact on existing code<br></p><p>This is a strictly additive change. It has no impact on existing code.<br></p><p>Alternatives considered<br></p><p>We could live without this syntactic sugar. There are several reasons the language is better with it:<br></p><p>It is much more convenient than manually writing memberwise partial intializers. It does not include any unnecessary information, thus making the details more clear.<br>It gives us the memberwise computed tuple properties for free. This would would not be possible when writing memberwise partial initializers manually.<br>It scales to any new memberwise features that might make sense for a type.<br>As always, the propertylist keyword is game for bikeshedding. The use of : to separate the identifier from the list of properties could also be game for bikeshedding. Also, as mentioned previously, the implicit property lists are game for bikeshedding.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160110/a894b1f0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b660eecceda60138f137d353b8289925?s=50"></div><header><strong>[Proposal Draft] property lists</strong> from <string>Janosch Hildebrand</string> &lt;jnosh at jnosh.com&gt;<p>January 11, 2016 at 05:00:00pm</p></header><div class="content"><p>Hi Matthew,<br></p><p>Just a few quick comments:<br></p><p>propertylist:<br>Not a big fan of the name either, `propertyalias` came to mind but that sounds like it&#39;s only for a single property.<br></p><p>@propertylist:<br>I think this is mostly redundant and the proposal would be improved by its removal.<br></p><p>propertylist syntax:<br>I don&#39;t think the current syntax. Using `:` feels wrong as I instinctively expect a type to it&#39;s right.<br></p><p>How about: `propertylist fooProps =  (aProp, bProp)`<br></p><p>Default values in propertylist:<br>Strongly against this. Only applicable to initializer use case and feels generally out of place.<br></p><p><br></p><p>I have also looked at the other two related proposals but I&#39;m far from having a final opinion on any of the three.<br>I&#39;m also posting my current very short and very rough impressions of the three related proposals here as I feel they are strongly related and I don&#39;t have enough to say about the other two to really justify separate posts:<br></p><p>Parameter forwarding:<br>This is the proposal I like the least. I&#39;m not a fan of the syntax and it mostly saves some minor typing at the cost immediately knowing what the actual arguments are.<br></p><p>Partial initializers:<br>My dislike of parameter forwarding carries over to this but otherwise I find the basic idea quite nice.<br>My bigger issue here is that I currently don&#39;t see a huge use case for this that isn&#39;t already served by initializer delegation. Yes this seems to cover additional cases but I&#39;m not sure it justifies it&#39;s existence. It makes a lot more sense when considered as part of the memberwise initialization trifecta with parameter forwarding but like I said that&#39;s the part I don&#39;t really like.<br></p><p>Property Lists:<br>Like with partial initializers I find this to be an interesting idea and this seems to have other potential use cases apart from memberwise initialization. Then again I&#39;m unsure if this exact proposal is the way to go here. I&#39;d really prefer to see more abstract discussion of this idea before committing to any specifics.<br></p><p><br>Particularly here but also in general for all three proposals I feel that we might be better served by letting the language form further and waiting for more general pieces to fall into place before charging ahead in these areas. None of these require stopgap solutions from my point of view and I at least feel like I could evaluate this much better once I have an idea of what Swift is going to look like at version 4, 5, ...<br>From reading the Swift team&#39;s comments it seems like future improvements like variadic generics might make a potential difference here and I imagine the macro system might as well.<br></p><p><br>I hope this doesn&#39;t sound too negative, you clearly invested a significant amount of work into these proposals and I value the effort. It helps me better understand the problems people see and what potential solutions might look like and stirs a lot of healthy discussion.<br>So don&#39;t let yourself be discouraged if I don&#39;t feel that changes in this area are required just yet :-)<br></p><p>- Janosch<br></p><p>&gt; On 11 Jan 2016, at 04:44, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I have always considered the Flexible Memberwise Initialization proposal to be just a first step (as evidenced by the many future enhancements it discussed).  Its review has inspired new ideas and helped to shape my vision of the best long-term solution.    My final thoughts about the review can be found here: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/006176.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/006176.html&gt;<br>&gt; <br>&gt; Property lists is the third in a series of three proposals describing general features that can work together to form a complete solution.<br>&gt; <br>&gt; The proposal drafts can be found at the following links:<br>&gt; <br>&gt; * Parameter forwarding: https://github.com/anandabits/swift-evolution/blob/parameter-forwarding/proposals/NNNN-parameter-forwarding.md &lt;https://github.com/anandabits/swift-evolution/blob/parameter-forwarding/proposals/NNNN-parameter-forwarding.md&gt;<br>&gt; * Partial initializers: https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md &lt;https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md&gt;<br>&gt; * Property lists: https://github.com/anandabits/swift-evolution/blob/property-lists/proposals/NNNN-property-lists.md &lt;https://github.com/anandabits/swift-evolution/blob/property-lists/proposals/NNNN-property-lists.md&gt;<br>&gt; <br>&gt; Matthew<br>&gt; Property Lists<br>&gt; <br>&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-property-lists.md&gt;<br>&gt; Author(s): Matthew Johnson &lt;https://github.com/anandabits&gt;<br>&gt; Status: Awaiting review<br>&gt; Review manager: TBD<br>&gt; Introduction<br>&gt; <br>&gt; This proposal introduces the propertylist declaration. Property lists provide concise syntactic sugar for declaring memberwise partial initializers and memberwise computed tuple properties.<br>&gt; <br>&gt; NOTE: I do not love the name “property lists” for the feature or the keyword but haven’t thought of anything better. Suggestions are welcome.<br>&gt; <br>&gt; Swift-evolution thread: Proposal Draft: Property Lists &lt;https://lists.swift.org/pipermail/swift-evolution&gt;<br>&gt; Motivation<br>&gt; <br>&gt; I believe the review of the Flexible Memberwise Initialization &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md&gt; proposal demonstrated a strong demand for concise yet flexible memberwise initialization. The discussion highlighted several areas where that proposal fell short:<br>&gt; <br>&gt; Clarity regarding which parameters receive memberwise initialization.<br>&gt; Control over which parameters receive memberwise initialization.<br>&gt; Control over specific memberwise parameter ordering.<br>&gt; Control over parameter labels.<br>&gt; Control over default parameter values, especially for let properties.<br>&gt; It is a very narrow, special case feature.<br>&gt; This proposal builds on the Partial Initializer &lt;https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md&gt; proposal to solve these problems using a more general underlying mechanism. It enables truly flexible memberwise initialization. <br>&gt; <br>&gt; Property lists also support other memberwise features, beginning with memberwise computed tuple properties.<br>&gt; <br>&gt; Proposed solution<br>&gt; <br>&gt; There are two ways to specify a property list. The basic mechanism is a property list declaration that looks as follows: <br>&gt; <br>&gt;   propertylist configProperties: aPropName, customLabel anotherPropName = 42<br>&gt; All properties mentioned in the property list declaration must be visible at the site of the declaration.<br>&gt; <br>&gt; A propertylist attribute also exists for property declarations to support cases where a list of property declarations should also be treated as a property list:<br>&gt; <br>&gt;   @propertylist(aPropertyListIdentifier) let prop1, prop2: Int<br>&gt; A property list can contain any kind of property, including those with behaviors. However, when certain kinds of properties are included it will not be possible to synthesize a partial memberwise initializer and / or a setter for the computed tuple property.<br>&gt; <br>&gt; Synthesized elements<br>&gt; <br>&gt; A typealias will always be synthesized:<br>&gt; <br>&gt; It will have a name matching the identifier of the property list, with the first character transformed to upper case.<br>&gt; It will be a tuple type containing labels and types matching those specified in the property list.<br>&gt; A computed tuple property will always be synthesized:<br>&gt; <br>&gt; It will always include a getter.<br>&gt; Visibility of the getter will match the visibility of the least visible getter.<br>&gt; It will contain a setter as long as all of the properties are settable.<br>&gt; Visibility of the setter will match the visibility of the least visible setter.<br>&gt; A paritial initializer will only be generated if:<br>&gt; <br>&gt; All properties are stored properties.<br>&gt; None are let properties with an initial value.<br>&gt; None have a behavior which is incompatible with phase 1 initialization.<br>&gt; Visibility of the partial initializer will match the least visible setter for structs. Partial initializers for classes are always private (as specified by the partial initializer proposal).<br>&gt; The property list is declared in the main body of the type, not an extension, unless the type is a struct.<br>&gt; If stored properties are allowed in extensions and / or protocols in the future, all properties included in the list must be declared within the same body as the property list for a partial initializer to be synthesized (either the main body of the type or the body of the same extension or same protocol).<br>&gt; The structure of the synthesized elements is as follows:<br>&gt; <br>&gt; Ordering of partial initializer parameters and tuple members will match the order of the property list declaration.<br>&gt; The external parameter labels and tuple labels will match the label specified in the property list if it exists and the property name otherwise.<br>&gt; The default value for partial initializer parameters will be the default value specified in the property list if it exists and the initial value of the property otherwise (if that exists). If neither exist the parameter will not have a default value.<br>&gt; Visibility of a synthesized members is capped at internal unless public is explicitly specified. If public (or internal) is explicitly specified, all properties referenced must have getter and setter visibility of at least the specified access level or a compiler error will result.<br>&gt; <br>&gt; Examples<br>&gt; <br>&gt; Basic example<br>&gt; <br>&gt; public struct S {<br>&gt;   let i: Int = 42<br>&gt;   public var s: String = &quot;hello&quot;<br>&gt;   public var d: Double<br>&gt;   <br>&gt;   // user declares:<br>&gt;   public propertylist custom: dLabel d = 42, s<br>&gt;   <br>&gt;   // compiler synthesizes:<br>&gt;   public typealias Custom = (dLabel: Double, s: String)<br>&gt;   public var custom: Custom {<br>&gt;     get { return (dLabel: d, s: s) }<br>&gt;     set { (d, s) = newValue }<br>&gt;   }<br>&gt;   public partial init custom(dlabel d: Double = 42, s: String = &quot;hello&quot;) {<br>&gt;     self.d = d<br>&gt;     self.s = s<br>&gt;   }<br>&gt; }<br>&gt; Including a let with a initial value<br>&gt; <br>&gt; struct S {<br>&gt;   let i: Int = 42<br>&gt;   let s: String = &quot;hello&quot;<br>&gt;   var d: Double<br>&gt;   <br>&gt;   // user declares:<br>&gt;   propertylist custom: dLabel d, s<br>&gt;   <br>&gt;   // compiler synthesizes:<br>&gt;   typealias Custom = (dLabel: Double, s: String)<br>&gt;   var custom: Custom {<br>&gt;     get { return (dLabel: d, s: s) }<br>&gt;   }<br>&gt;   // NOTE: no setter because a `let` was included<br>&gt;   // and no partial initializer because the `let` <br>&gt;   // has an initial value.<br>&gt; }<br>&gt; Including a lazy property<br>&gt; <br>&gt; struct S {<br>&gt;   let i: Int<br>&gt;   var s: String<br>&gt;   lazy var d: Double<br>&gt;   <br>&gt;   // user declares:<br>&gt;   propertylist custom: dLabel d, s<br>&gt;   <br>&gt;   // compiler synthesizes:<br>&gt;   typealias Custom = (dLabel: Double, s: String)<br>&gt;   var custom: Custom {<br>&gt;     get { return (dLabel: d, s: s) }<br>&gt;     set { (d, s) = newValue }<br>&gt;   }<br>&gt;   // NOTE: no partial initializer because a `lazy var` was included.<br>&gt; }<br>&gt; Including a var with a private setter<br>&gt; <br>&gt; struct S {<br>&gt;   let i: Int<br>&gt;   var s: String<br>&gt;   private(set) var d: Double = 42<br>&gt;   <br>&gt;   // user declares:<br>&gt;   propertylist custom: dLabel d, s = &quot;hello&quot;<br>&gt;   <br>&gt;   // compiler synthesizes:<br>&gt;   typealias Custom = (dLabel: Double, s: String)<br>&gt;   private(set) var custom: Custom {<br>&gt;     get { return (dLabel: d, s: s) }<br>&gt;     set { (d, s) = newValue }<br>&gt;   }<br>&gt;   // NOTE: The initial value for `d` is used as a default <br>&gt;   // parameter value because a different default parameter value <br>&gt;   // was not specified.<br>&gt;   private partial init custom(dlabel d: Double = 42, s: String = &quot;hello&quot;) {<br>&gt;     self.d = d<br>&gt;     self.s = s<br>&gt;   }<br>&gt; }<br>&gt; Including a computed property<br>&gt; <br>&gt; struct S {<br>&gt;   let i: Int<br>&gt;   var s: String<br>&gt;   var d: Double {<br>&gt;     get { return getValueFromSomewhere() }<br>&gt;     set { storeValueSomewhere(newValue) }<br>&gt;   }<br>&gt;   <br>&gt;   // user declares:<br>&gt;   propertylist custom: dLabel d, s<br>&gt;   <br>&gt;   // compiler synthesizes:<br>&gt;   typealias Custom = (dLabel: Double, s: String)<br>&gt;   var custom: Custom {<br>&gt;     get { return (dLabel: d, s: s) }<br>&gt;     set { (d, s) = newValue }<br>&gt;   }<br>&gt;   // NOTE: no partial initializer because a computed property was included.<br>&gt; }<br>&gt; Using the @propertylist attribute<br>&gt; <br>&gt; struct S {<br>&gt;   @propertylist(custom) var s: String, d: Double = 42<br>&gt;   private let i: Int<br>&gt;   <br>&gt;   // compiler synthesizes:<br>&gt;   typealias Custom = (s: String, d: Double)<br>&gt;   var custom: Custom {<br>&gt;     get { return (s: s, d: d) }<br>&gt;     set { (s, d) = newValue }<br>&gt;   }<br>&gt;   partial init custom(s: String, d: Double = 42) {<br>&gt;     self.s = s<br>&gt;     self.d = d<br>&gt;   }<br>&gt; }<br>&gt; Using a property list declaration for memberwise intialization<br>&gt; <br>&gt; struct S {<br>&gt;   var x, y, z: Int<br>&gt;   let s: String<br>&gt;   let d: Double<br>&gt;   <br>&gt;   propertylist randomGroup aString s = &quot;hello&quot;, anInt x = 42<br>&gt;   <br>&gt;   // user declares<br>&gt;   init(...randomGroup) {<br>&gt;     y = 42<br>&gt;     z = 42<br>&gt;     d = 42<br>&gt;   }<br>&gt;   <br>&gt;   // compiler synthesizes<br>&gt;   partial init randomGroup(aString s: String = &quot;hello&quot;, anInt x: Int = 42) {<br>&gt;     self.s = s<br>&gt;     self.x = x<br>&gt;   }<br>&gt;   init(aString s: String = &quot;hello&quot;, anInt x: Int = 42) {<br>&gt;     randomGroup.init(aString: s, anInt: x)<br>&gt;     y = 42<br>&gt;     z = 42<br>&gt;     d = 42<br>&gt;   }<br>&gt;   <br>&gt; }<br>&gt; Using the property list attribute for memberwise intialization<br>&gt; <br>&gt; ```swift<br>&gt; struct S {<br>&gt; @propertylist(declaredTogether) var x, y, z: Int<br>&gt; let s: String<br>&gt; let d: Double<br>&gt; <br>&gt; // user declares:<br>&gt; init(…declaredTogether) {<br>&gt; s = “hello”<br>&gt; d = 42<br>&gt; }<br>&gt; <br>&gt; // compiler synthesizes:<br>&gt; partial init declaredTogether(x: Int, y: Int, z: Int) {<br>&gt; self.x = x<br>&gt; self.y = y<br>&gt; self.z = z<br>&gt; } init(x: Int, y: Int, z: Int) {<br>&gt; declaredTogether.init(x: Int, y: Int, z: Int)<br>&gt; s = “hello”<br>&gt; d = 42<br>&gt; }<br>&gt; <br>&gt; }<br>&gt; <br>&gt; Implicit property lists<br>&gt; <br>&gt; It may be desirable to have several implicit property lists available, such as one that includes all properties of the type. Properties would appear in any implicit property lists in declaration order.<br>&gt; <br>&gt; The specific details of what implicit property lists should be available and what they should be called is a good topic for bikeshedding.<br>&gt; <br>&gt; Detailed design<br>&gt; <br>&gt; TODO but should fall out pretty clearly from the proposed solution<br>&gt; <br>&gt; Impact on existing code<br>&gt; <br>&gt; This is a strictly additive change. It has no impact on existing code.<br>&gt; <br>&gt; Alternatives considered<br>&gt; <br>&gt; We could live without this syntactic sugar. There are several reasons the language is better with it:<br>&gt; <br>&gt; It is much more convenient than manually writing memberwise partial intializers. It does not include any unnecessary information, thus making the details more clear.<br>&gt; It gives us the memberwise computed tuple properties for free. This would would not be possible when writing memberwise partial initializers manually.<br>&gt; It scales to any new memberwise features that might make sense for a type.<br>&gt; As always, the propertylist keyword is game for bikeshedding. The use of : to separate the identifier from the list of properties could also be game for bikeshedding. Also, as mentioned previously, the implicit property lists are game for bikeshedding.<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/ad3b045b/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] property lists</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 11, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jan 11, 2016, at 10:21 AM, Janosch Hildebrand &lt;jnosh at jnosh.com&gt; wrote:<br>&gt; <br>&gt; Hi Matthew,<br>&gt; <br>&gt; Just a few quick comments:<br>&gt; <br>&gt; propertylist:<br>&gt; Not a big fan of the name either, `propertyalias` came to mind but that sounds like it&#39;s only for a single property.<br></p><p>If you think of something better please let me know!<br></p><p>&gt; <br>&gt; @propertylist:<br>&gt; I think this is mostly redundant and the proposal would be improved by its removal.<br></p><p>Removing it would require a redundant list of property names in some cases.  Why do you think that is better?<br></p><p>&gt; <br>&gt; propertylist syntax:<br>&gt; I don&#39;t think the current syntax. Using `:` feels wrong as I instinctively expect a type to it&#39;s right.<br>&gt; <br>&gt; How about: `propertylist fooProps =  (aProp, bProp)`<br></p><p>That syntax could work.<br></p><p>&gt; <br>&gt; Default values in propertylist:<br>&gt; Strongly against this. Only applicable to initializer use case and feels generally out of place.<br></p><p>It is extremely important to the initializer use case.  There is no way to provide a default for `let` properties in the initializer without allowing this.  I would not have written this proposal at all if it weren’t for a desire to improvise the initializer use case.<br></p><p>&gt; <br>&gt; I have also looked at the other two related proposals but I&#39;m far from having a final opinion on any of the three.<br>&gt; I&#39;m also posting my current very short and very rough impressions of the three related proposals here as I feel they are strongly related and I don&#39;t have enough to say about the other two to really justify separate posts:<br></p><p>Thanks.  I appreciate your feedback!<br></p><p>&gt; <br>&gt; Parameter forwarding:<br>&gt; This is the proposal I like the least. I&#39;m not a fan of the syntax and it mostly saves some minor typing at the cost immediately knowing what the actual arguments are.<br></p><p>Have you used a language with a similar feature (such as tuple packing and unpacking in a dynamic language)?  It is quite useful.  IMO, removing the clutter of each argument, type, and default value makes it much more clear that simple forwarding is happening.<br></p><p>The complete parameter list would still appear in generated documentation, autocomplete, etc.  An IDE could also provide an option to view the full parameter list in the function declaration itself.<br></p><p>&gt; <br>&gt; Partial initializers:<br>&gt; My dislike of parameter forwarding carries over to this but otherwise I find the basic idea quite nice.<br>&gt; My bigger issue here is that I currently don&#39;t see a huge use case for this that isn&#39;t already served by initializer delegation. Yes this seems to cover additional cases but I&#39;m not sure it justifies it&#39;s existence. It makes a lot more sense when considered as part of the memberwise initialization trifecta with parameter forwarding but like I said that&#39;s the part I don&#39;t really like.<br></p><p>Initializer delegation requires the initializer you call to be a complete initializer.  It is not uncommon to have more than one designated initializer that need to share initialization logic.  There are techniques to factor out some of this logic today, but it would be much easier with partial initializers.  <br></p><p>&gt; <br>&gt; Property Lists:<br>&gt; Like with partial initializers I find this to be an interesting idea and this seems to have other potential use cases apart from memberwise initialization. Then again I&#39;m unsure if this exact proposal is the way to go here. I&#39;d really prefer to see more abstract discussion of this idea before committing to any specifics.<br>&gt; <br>&gt; <br>&gt; Particularly here but also in general for all three proposals I feel that we might be better served by letting the language form further and waiting for more general pieces to fall into place before charging ahead in these areas. None of these require stopgap solutions from my point of view and I at least feel like I could evaluate this much better once I have an idea of what Swift is going to look like at version 4, 5, ...<br>&gt; From reading the Swift team&#39;s comments it seems like future improvements like variadic generics might make a potential difference here and I imagine the macro system might as well.<br></p><p>These proposals are partly a response to the comments Dave and Joe made about building on more general underlying features.<br></p><p>Partial initializers are a feature that would need to stand on its own, it would not be enabled by any other features.  As noted in the proposal, it might actually help to prepare the initialization model to support initialization of extensions and protocols with stored properties.<br></p><p>I don’t believe variadic generics would cover the full set of forwarding capabilities I would like to see.  Particularly forwarding of default values, but also forwarding a subset of parameters.  I know you are not a fan of the forwarding idea so that may not matter much to you.<br></p><p>The property list idea could probably be implemented with a powerful-enough macro system.  My opinion is that it would be nice to solve this problem in Swift 3 if possible.  The feature could be replaced by a macro down the road if it becomes possible to write it that way.<br></p><p>&gt; <br>&gt; <br>&gt; I hope this doesn&#39;t sound too negative, you clearly invested a significant amount of work into these proposals and I value the effort. It helps me better understand the problems people see and what potential solutions might look like and stirs a lot of healthy discussion.<br>&gt; So don&#39;t let yourself be discouraged if I don&#39;t feel that changes in this area are required just yet :-)<br></p><p>That’s a fair opinion.  The discussion has been healthy indeed!  IMO it has at least validated that there is broad support for doing something to address these problems.  <br></p><p>One of the big critiques of the Flexible Memberwise Initialization proposal was that it wasn’t powerful enough to support all the use cases people want to solve.  I think there is a lot of demand to solve these problems and many people would like to see them solved in Swift 3.  <br></p><p>Matthew<br></p><p>&gt; <br>&gt; - Janosch<br>&gt; <br>&gt;&gt; On 11 Jan 2016, at 04:44, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I have always considered the Flexible Memberwise Initialization proposal to be just a first step (as evidenced by the many future enhancements it discussed).  Its review has inspired new ideas and helped to shape my vision of the best long-term solution.    My final thoughts about the review can be found here: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/006176.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/006176.html&gt;<br>&gt;&gt; <br>&gt;&gt; Property lists is the third in a series of three proposals describing general features that can work together to form a complete solution.<br>&gt;&gt; <br>&gt;&gt; The proposal drafts can be found at the following links:<br>&gt;&gt; <br>&gt;&gt; * Parameter forwarding: https://github.com/anandabits/swift-evolution/blob/parameter-forwarding/proposals/NNNN-parameter-forwarding.md &lt;https://github.com/anandabits/swift-evolution/blob/parameter-forwarding/proposals/NNNN-parameter-forwarding.md&gt;<br>&gt;&gt; * Partial initializers: https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md &lt;https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md&gt;<br>&gt;&gt; * Property lists: https://github.com/anandabits/swift-evolution/blob/property-lists/proposals/NNNN-property-lists.md &lt;https://github.com/anandabits/swift-evolution/blob/property-lists/proposals/NNNN-property-lists.md&gt;<br>&gt;&gt; <br>&gt;&gt; Matthew<br>&gt;&gt; Property Lists<br>&gt;&gt; <br>&gt;&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-property-lists.md&gt;<br>&gt;&gt; Author(s): Matthew Johnson &lt;https://github.com/anandabits&gt;<br>&gt;&gt; Status: Awaiting review<br>&gt;&gt; Review manager: TBD<br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; This proposal introduces the propertylist declaration. Property lists provide concise syntactic sugar for declaring memberwise partial initializers and memberwise computed tuple properties.<br>&gt;&gt; <br>&gt;&gt; NOTE: I do not love the name “property lists” for the feature or the keyword but haven’t thought of anything better. Suggestions are welcome.<br>&gt;&gt; <br>&gt;&gt; Swift-evolution thread: Proposal Draft: Property Lists &lt;https://lists.swift.org/pipermail/swift-evolution&gt;<br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; I believe the review of the Flexible Memberwise Initialization &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md&gt; proposal demonstrated a strong demand for concise yet flexible memberwise initialization. The discussion highlighted several areas where that proposal fell short:<br>&gt;&gt; <br>&gt;&gt; Clarity regarding which parameters receive memberwise initialization.<br>&gt;&gt; Control over which parameters receive memberwise initialization.<br>&gt;&gt; Control over specific memberwise parameter ordering.<br>&gt;&gt; Control over parameter labels.<br>&gt;&gt; Control over default parameter values, especially for let properties.<br>&gt;&gt; It is a very narrow, special case feature.<br>&gt;&gt; This proposal builds on the Partial Initializer &lt;https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md&gt; proposal to solve these problems using a more general underlying mechanism. It enables truly flexible memberwise initialization. <br>&gt;&gt; <br>&gt;&gt; Property lists also support other memberwise features, beginning with memberwise computed tuple properties.<br>&gt;&gt; <br>&gt;&gt; Proposed solution<br>&gt;&gt; <br>&gt;&gt; There are two ways to specify a property list. The basic mechanism is a property list declaration that looks as follows: <br>&gt;&gt; <br>&gt;&gt;   propertylist configProperties: aPropName, customLabel anotherPropName = 42<br>&gt;&gt; All properties mentioned in the property list declaration must be visible at the site of the declaration.<br>&gt;&gt; <br>&gt;&gt; A propertylist attribute also exists for property declarations to support cases where a list of property declarations should also be treated as a property list:<br>&gt;&gt; <br>&gt;&gt;   @propertylist(aPropertyListIdentifier) let prop1, prop2: Int<br>&gt;&gt; A property list can contain any kind of property, including those with behaviors. However, when certain kinds of properties are included it will not be possible to synthesize a partial memberwise initializer and / or a setter for the computed tuple property.<br>&gt;&gt; <br>&gt;&gt; Synthesized elements<br>&gt;&gt; <br>&gt;&gt; A typealias will always be synthesized:<br>&gt;&gt; <br>&gt;&gt; It will have a name matching the identifier of the property list, with the first character transformed to upper case.<br>&gt;&gt; It will be a tuple type containing labels and types matching those specified in the property list.<br>&gt;&gt; A computed tuple property will always be synthesized:<br>&gt;&gt; <br>&gt;&gt; It will always include a getter.<br>&gt;&gt; Visibility of the getter will match the visibility of the least visible getter.<br>&gt;&gt; It will contain a setter as long as all of the properties are settable.<br>&gt;&gt; Visibility of the setter will match the visibility of the least visible setter.<br>&gt;&gt; A paritial initializer will only be generated if:<br>&gt;&gt; <br>&gt;&gt; All properties are stored properties.<br>&gt;&gt; None are let properties with an initial value.<br>&gt;&gt; None have a behavior which is incompatible with phase 1 initialization.<br>&gt;&gt; Visibility of the partial initializer will match the least visible setter for structs. Partial initializers for classes are always private (as specified by the partial initializer proposal).<br>&gt;&gt; The property list is declared in the main body of the type, not an extension, unless the type is a struct.<br>&gt;&gt; If stored properties are allowed in extensions and / or protocols in the future, all properties included in the list must be declared within the same body as the property list for a partial initializer to be synthesized (either the main body of the type or the body of the same extension or same protocol).<br>&gt;&gt; The structure of the synthesized elements is as follows:<br>&gt;&gt; <br>&gt;&gt; Ordering of partial initializer parameters and tuple members will match the order of the property list declaration.<br>&gt;&gt; The external parameter labels and tuple labels will match the label specified in the property list if it exists and the property name otherwise.<br>&gt;&gt; The default value for partial initializer parameters will be the default value specified in the property list if it exists and the initial value of the property otherwise (if that exists). If neither exist the parameter will not have a default value.<br>&gt;&gt; Visibility of a synthesized members is capped at internal unless public is explicitly specified. If public (or internal) is explicitly specified, all properties referenced must have getter and setter visibility of at least the specified access level or a compiler error will result.<br>&gt;&gt; <br>&gt;&gt; Examples<br>&gt;&gt; <br>&gt;&gt; Basic example<br>&gt;&gt; <br>&gt;&gt; public struct S {<br>&gt;&gt;   let i: Int = 42<br>&gt;&gt;   public var s: String = &quot;hello&quot;<br>&gt;&gt;   public var d: Double<br>&gt;&gt;   <br>&gt;&gt;   // user declares:<br>&gt;&gt;   public propertylist custom: dLabel d = 42, s<br>&gt;&gt;   <br>&gt;&gt;   // compiler synthesizes:<br>&gt;&gt;   public typealias Custom = (dLabel: Double, s: String)<br>&gt;&gt;   public var custom: Custom {<br>&gt;&gt;     get { return (dLabel: d, s: s) }<br>&gt;&gt;     set { (d, s) = newValue }<br>&gt;&gt;   }<br>&gt;&gt;   public partial init custom(dlabel d: Double = 42, s: String = &quot;hello&quot;) {<br>&gt;&gt;     self.d = d<br>&gt;&gt;     self.s = s<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; Including a let with a initial value<br>&gt;&gt; <br>&gt;&gt; struct S {<br>&gt;&gt;   let i: Int = 42<br>&gt;&gt;   let s: String = &quot;hello&quot;<br>&gt;&gt;   var d: Double<br>&gt;&gt;   <br>&gt;&gt;   // user declares:<br>&gt;&gt;   propertylist custom: dLabel d, s<br>&gt;&gt;   <br>&gt;&gt;   // compiler synthesizes:<br>&gt;&gt;   typealias Custom = (dLabel: Double, s: String)<br>&gt;&gt;   var custom: Custom {<br>&gt;&gt;     get { return (dLabel: d, s: s) }<br>&gt;&gt;   }<br>&gt;&gt;   // NOTE: no setter because a `let` was included<br>&gt;&gt;   // and no partial initializer because the `let` <br>&gt;&gt;   // has an initial value.<br>&gt;&gt; }<br>&gt;&gt; Including a lazy property<br>&gt;&gt; <br>&gt;&gt; struct S {<br>&gt;&gt;   let i: Int<br>&gt;&gt;   var s: String<br>&gt;&gt;   lazy var d: Double<br>&gt;&gt;   <br>&gt;&gt;   // user declares:<br>&gt;&gt;   propertylist custom: dLabel d, s<br>&gt;&gt;   <br>&gt;&gt;   // compiler synthesizes:<br>&gt;&gt;   typealias Custom = (dLabel: Double, s: String)<br>&gt;&gt;   var custom: Custom {<br>&gt;&gt;     get { return (dLabel: d, s: s) }<br>&gt;&gt;     set { (d, s) = newValue }<br>&gt;&gt;   }<br>&gt;&gt;   // NOTE: no partial initializer because a `lazy var` was included.<br>&gt;&gt; }<br>&gt;&gt; Including a var with a private setter<br>&gt;&gt; <br>&gt;&gt; struct S {<br>&gt;&gt;   let i: Int<br>&gt;&gt;   var s: String<br>&gt;&gt;   private(set) var d: Double = 42<br>&gt;&gt;   <br>&gt;&gt;   // user declares:<br>&gt;&gt;   propertylist custom: dLabel d, s = &quot;hello&quot;<br>&gt;&gt;   <br>&gt;&gt;   // compiler synthesizes:<br>&gt;&gt;   typealias Custom = (dLabel: Double, s: String)<br>&gt;&gt;   private(set) var custom: Custom {<br>&gt;&gt;     get { return (dLabel: d, s: s) }<br>&gt;&gt;     set { (d, s) = newValue }<br>&gt;&gt;   }<br>&gt;&gt;   // NOTE: The initial value for `d` is used as a default <br>&gt;&gt;   // parameter value because a different default parameter value <br>&gt;&gt;   // was not specified.<br>&gt;&gt;   private partial init custom(dlabel d: Double = 42, s: String = &quot;hello&quot;) {<br>&gt;&gt;     self.d = d<br>&gt;&gt;     self.s = s<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; Including a computed property<br>&gt;&gt; <br>&gt;&gt; struct S {<br>&gt;&gt;   let i: Int<br>&gt;&gt;   var s: String<br>&gt;&gt;   var d: Double {<br>&gt;&gt;     get { return getValueFromSomewhere() }<br>&gt;&gt;     set { storeValueSomewhere(newValue) }<br>&gt;&gt;   }<br>&gt;&gt;   <br>&gt;&gt;   // user declares:<br>&gt;&gt;   propertylist custom: dLabel d, s<br>&gt;&gt;   <br>&gt;&gt;   // compiler synthesizes:<br>&gt;&gt;   typealias Custom = (dLabel: Double, s: String)<br>&gt;&gt;   var custom: Custom {<br>&gt;&gt;     get { return (dLabel: d, s: s) }<br>&gt;&gt;     set { (d, s) = newValue }<br>&gt;&gt;   }<br>&gt;&gt;   // NOTE: no partial initializer because a computed property was included.<br>&gt;&gt; }<br>&gt;&gt; Using the @propertylist attribute<br>&gt;&gt; <br>&gt;&gt; struct S {<br>&gt;&gt;   @propertylist(custom) var s: String, d: Double = 42<br>&gt;&gt;   private let i: Int<br>&gt;&gt;   <br>&gt;&gt;   // compiler synthesizes:<br>&gt;&gt;   typealias Custom = (s: String, d: Double)<br>&gt;&gt;   var custom: Custom {<br>&gt;&gt;     get { return (s: s, d: d) }<br>&gt;&gt;     set { (s, d) = newValue }<br>&gt;&gt;   }<br>&gt;&gt;   partial init custom(s: String, d: Double = 42) {<br>&gt;&gt;     self.s = s<br>&gt;&gt;     self.d = d<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; Using a property list declaration for memberwise intialization<br>&gt;&gt; <br>&gt;&gt; struct S {<br>&gt;&gt;   var x, y, z: Int<br>&gt;&gt;   let s: String<br>&gt;&gt;   let d: Double<br>&gt;&gt;   <br>&gt;&gt;   propertylist randomGroup aString s = &quot;hello&quot;, anInt x = 42<br>&gt;&gt;   <br>&gt;&gt;   // user declares<br>&gt;&gt;   init(...randomGroup) {<br>&gt;&gt;     y = 42<br>&gt;&gt;     z = 42<br>&gt;&gt;     d = 42<br>&gt;&gt;   }<br>&gt;&gt;   <br>&gt;&gt;   // compiler synthesizes<br>&gt;&gt;   partial init randomGroup(aString s: String = &quot;hello&quot;, anInt x: Int = 42) {<br>&gt;&gt;     self.s = s<br>&gt;&gt;     self.x = x<br>&gt;&gt;   }<br>&gt;&gt;   init(aString s: String = &quot;hello&quot;, anInt x: Int = 42) {<br>&gt;&gt;     randomGroup.init(aString: s, anInt: x)<br>&gt;&gt;     y = 42<br>&gt;&gt;     z = 42<br>&gt;&gt;     d = 42<br>&gt;&gt;   }<br>&gt;&gt;   <br>&gt;&gt; }<br>&gt;&gt; Using the property list attribute for memberwise intialization<br>&gt;&gt; <br>&gt;&gt; ```swift<br>&gt;&gt; struct S {<br>&gt;&gt; @propertylist(declaredTogether) var x, y, z: Int<br>&gt;&gt; let s: String<br>&gt;&gt; let d: Double<br>&gt;&gt; <br>&gt;&gt; // user declares:<br>&gt;&gt; init(…declaredTogether) {<br>&gt;&gt; s = “hello”<br>&gt;&gt; d = 42<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // compiler synthesizes:<br>&gt;&gt; partial init declaredTogether(x: Int, y: Int, z: Int) {<br>&gt;&gt; self.x = x<br>&gt;&gt; self.y = y<br>&gt;&gt; self.z = z<br>&gt;&gt; } init(x: Int, y: Int, z: Int) {<br>&gt;&gt; declaredTogether.init(x: Int, y: Int, z: Int)<br>&gt;&gt; s = “hello”<br>&gt;&gt; d = 42<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Implicit property lists<br>&gt;&gt; <br>&gt;&gt; It may be desirable to have several implicit property lists available, such as one that includes all properties of the type. Properties would appear in any implicit property lists in declaration order.<br>&gt;&gt; <br>&gt;&gt; The specific details of what implicit property lists should be available and what they should be called is a good topic for bikeshedding.<br>&gt;&gt; <br>&gt;&gt; Detailed design<br>&gt;&gt; <br>&gt;&gt; TODO but should fall out pretty clearly from the proposed solution<br>&gt;&gt; <br>&gt;&gt; Impact on existing code<br>&gt;&gt; <br>&gt;&gt; This is a strictly additive change. It has no impact on existing code.<br>&gt;&gt; <br>&gt;&gt; Alternatives considered<br>&gt;&gt; <br>&gt;&gt; We could live without this syntactic sugar. There are several reasons the language is better with it:<br>&gt;&gt; <br>&gt;&gt; It is much more convenient than manually writing memberwise partial intializers. It does not include any unnecessary information, thus making the details more clear.<br>&gt;&gt; It gives us the memberwise computed tuple properties for free. This would would not be possible when writing memberwise partial initializers manually.<br>&gt;&gt; It scales to any new memberwise features that might make sense for a type.<br>&gt;&gt; As always, the propertylist keyword is game for bikeshedding. The use of : to separate the identifier from the list of properties could also be game for bikeshedding. Also, as mentioned previously, the implicit property lists are game for bikeshedding.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/c04a9d62/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>[Proposal Draft] property lists</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>January 11, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jan 11, 2016, at 9:17 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 11, 2016, at 10:21 AM, Janosch Hildebrand &lt;jnosh at jnosh.com &lt;mailto:jnosh at jnosh.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; propertylist:<br>&gt;&gt; Not a big fan of the name either, `propertyalias` came to mind but that sounds like it&#39;s only for a single property.<br>&gt; <br>&gt; If you think of something better please let me know!<br></p><p>&quot;property list&quot; already means something in Cocoa. You are unlikely to get approval under that name.<br></p><p><br>-- <br>Greg Parker     gparker at apple.com     Runtime Wrangler<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/b69de776/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] property lists</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 11, 2016 at 05:00:00pm</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On Jan 11, 2016, at 4:49 PM, Greg Parker &lt;gparker at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Jan 11, 2016, at 9:17 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 11, 2016, at 10:21 AM, Janosch Hildebrand &lt;jnosh at jnosh.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; propertylist:<br>&gt;&gt;&gt; Not a big fan of the name either, `propertyalias` came to mind but that sounds like it&#39;s only for a single property.<br>&gt;&gt; <br>&gt;&gt; If you think of something better please let me know!<br>&gt; <br>&gt; &quot;property list&quot; already means something in Cocoa. You are unlikely to get approval under that name.<br>&gt; <br>Good point!  Any better ideas?  I don&#39;t like it, just didn&#39;t think of a good one yet.<br></p><p>&gt; <br>&gt; -- <br>&gt; Greg Parker     gparker at apple.com     Runtime Wrangler<br>&gt; <br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/b5959765/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05e222e6ef4d84013bb3baeb0e25c90b?s=50"></div><header><strong>[Proposal Draft] property lists</strong> from <string>Patrick Gili</string> &lt;gili.patrick.r at gili-labs.com&gt;<p>January 13, 2016 at 10:00:00am</p></header><div class="content"><p>Ruby has the notion of attribute accessors, which is very similar to this proposal. If you align the proposal to look more like attribute accessors in Ruby, then it might play well with the forwarding, like the Ruby Forwardable module.<br></p><p>-Patrick<br></p><p>&gt; On Jan 11, 2016, at 6:02 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt; On Jan 11, 2016, at 4:49 PM, Greg Parker &lt;gparker at apple.com &lt;mailto:gparker at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 11, 2016, at 9:17 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 11, 2016, at 10:21 AM, Janosch Hildebrand &lt;jnosh at jnosh.com &lt;mailto:jnosh at jnosh.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; propertylist:<br>&gt;&gt;&gt;&gt; Not a big fan of the name either, `propertyalias` came to mind but that sounds like it&#39;s only for a single property.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you think of something better please let me know!<br>&gt;&gt; <br>&gt;&gt; &quot;property list&quot; already means something in Cocoa. You are unlikely to get approval under that name.<br>&gt;&gt; <br>&gt; Good point!  Any better ideas?  I don&#39;t like it, just didn&#39;t think of a good one yet.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Greg Parker     gparker at apple.com &lt;mailto:gparker at apple.com&gt;     Runtime Wrangler<br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/6834b3be/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] property lists</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 13, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 13, 2016, at 9:15 AM, Patrick Gili &lt;gili.patrick.r at gili-labs.com&gt; wrote:<br>&gt; <br>&gt; Ruby has the notion of attribute accessors, which is very similar to this proposal. If you align the proposal to look more like attribute accessors in Ruby, then it might play well with the forwarding, like the Ruby Forwardable module.<br></p><p>It’s been a while since I’ve written Ruby but I have written quite a bit of it in the past.  Did something change?  As far as I know attribute accessors are basically like properties.  <br></p><p>As far as forwarding goes, I have worked on a totally separate proposal for forwarding and have a second draft of that close to complete.  I don’t see how the two are related.<br></p><p>Matthew<br></p><p>&gt; <br>&gt; -Patrick<br>&gt; <br>&gt;&gt; On Jan 11, 2016, at 6:02 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt; On Jan 11, 2016, at 4:49 PM, Greg Parker &lt;gparker at apple.com &lt;mailto:gparker at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 11, 2016, at 9:17 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 11, 2016, at 10:21 AM, Janosch Hildebrand &lt;jnosh at jnosh.com &lt;mailto:jnosh at jnosh.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; propertylist:<br>&gt;&gt;&gt;&gt;&gt; Not a big fan of the name either, `propertyalias` came to mind but that sounds like it&#39;s only for a single property.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If you think of something better please let me know!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &quot;property list&quot; already means something in Cocoa. You are unlikely to get approval under that name.<br>&gt;&gt;&gt; <br>&gt;&gt; Good point!  Any better ideas?  I don&#39;t like it, just didn&#39;t think of a good one yet.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Greg Parker     gparker at apple.com &lt;mailto:gparker at apple.com&gt;     Runtime Wrangler<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/2ee0a227/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05e222e6ef4d84013bb3baeb0e25c90b?s=50"></div><header><strong>[Proposal Draft] property lists</strong> from <string>Patrick Gili</string> &lt;gili.patrick.r at gili-labs.com&gt;<p>January 13, 2016 at 12:00:00pm</p></header><div class="content"><p>Not much has changed with regard to attribute accessors.<br></p><p>Here is a link to a great tutorial:<br></p><p>http://www.rubyist.net/~slagell/ruby/accessors.html<br></p><p>Here is a link to the Ruby documentation the Module module, which contains documentation for attire, attr_accessor, attr_reader, and attr_writer:<br></p><p>http://ruby-doc.org/core-1.9.3/Module.html<br></p><p>I think the Ruby notion of an attribute is the direction you&#39;re trying to take this. You can take your concept and build on it.<br></p><p>My apologies regarding my comment about forwarding. I momentarily confused the concepts of protocol forwarding and parameter forwarding.<br></p><p>Cheers,<br>-Patrick<br></p><p><br>&gt; On Jan 13, 2016, at 11:21 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 13, 2016, at 9:15 AM, Patrick Gili &lt;gili.patrick.r at gili-labs.com &lt;mailto:gili.patrick.r at gili-labs.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Ruby has the notion of attribute accessors, which is very similar to this proposal. If you align the proposal to look more like attribute accessors in Ruby, then it might play well with the forwarding, like the Ruby Forwardable module.<br>&gt; <br>&gt; It’s been a while since I’ve written Ruby but I have written quite a bit of it in the past.  Did something change?  As far as I know attribute accessors are basically like properties.  <br>&gt; <br>&gt; As far as forwarding goes, I have worked on a totally separate proposal for forwarding and have a second draft of that close to complete.  I don’t see how the two are related.<br>&gt; <br>&gt; Matthew<br>&gt; <br>&gt;&gt; <br>&gt;&gt; -Patrick<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 11, 2016, at 6:02 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 11, 2016, at 4:49 PM, Greg Parker &lt;gparker at apple.com &lt;mailto:gparker at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 11, 2016, at 9:17 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 11, 2016, at 10:21 AM, Janosch Hildebrand &lt;jnosh at jnosh.com &lt;mailto:jnosh at jnosh.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; propertylist:<br>&gt;&gt;&gt;&gt;&gt;&gt; Not a big fan of the name either, `propertyalias` came to mind but that sounds like it&#39;s only for a single property.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If you think of something better please let me know!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &quot;property list&quot; already means something in Cocoa. You are unlikely to get approval under that name.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; Good point!  Any better ideas?  I don&#39;t like it, just didn&#39;t think of a good one yet.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; Greg Parker     gparker at apple.com &lt;mailto:gparker at apple.com&gt;     Runtime Wrangler<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/289ed8fd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] property lists</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 13, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jan 13, 2016, at 11:46 AM, Patrick Gili &lt;gili.patrick.r at gili-labs.com&gt; wrote:<br>&gt; <br>&gt; Not much has changed with regard to attribute accessors.<br>&gt; <br>&gt; Here is a link to a great tutorial:<br>&gt; <br>&gt; http://www.rubyist.net/~slagell/ruby/accessors.html &lt;http://www.rubyist.net/~slagell/ruby/accessors.html&gt;<br>&gt; <br>&gt; Here is a link to the Ruby documentation the Module module, which contains documentation for attire, attr_accessor, attr_reader, and attr_writer:<br>&gt; <br>&gt; http://ruby-doc.org/core-1.9.3/Module.html &lt;http://ruby-doc.org/core-1.9.3/Module.html&gt;<br>&gt; <br>&gt; I think the Ruby notion of an attribute is the direction you&#39;re trying to take this. You can take your concept and build on it.<br></p><p>This hasn’t changed at all since I used Ruby.  It is really not like this proposal at all.  It is synthesizing the property (attribute) accessors themselves.  Swift does this automatically when you declare a stored property, or allows you to do so manually by writing computed accessors.<br></p><p>The idea in this proposal was that we could synthesize at least two useful memberwise features for a type from a list of properties - a memberwise partial initializer and a computed tuple property.<br></p><p>That said, I won’t be pursuing this proposal further given Chris’s comments about syntactic sugar proposals.  It seems doubtful that something like this would be considered in the Swift 3 timeframe and Swift 4 might bring macros which would hopefully make it possible to implement something like this ourselves if desired.<br></p><p>Matthew<br></p><p>&gt; <br>&gt; My apologies regarding my comment about forwarding. I momentarily confused the concepts of protocol forwarding and parameter forwarding.<br></p><p>No problem, although I don’t see how either are directly related to this topic.<br></p><p>Matthew<br></p><p>&gt; <br>&gt; Cheers,<br>&gt; -Patrick<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 13, 2016, at 11:21 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 13, 2016, at 9:15 AM, Patrick Gili &lt;gili.patrick.r at gili-labs.com &lt;mailto:gili.patrick.r at gili-labs.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Ruby has the notion of attribute accessors, which is very similar to this proposal. If you align the proposal to look more like attribute accessors in Ruby, then it might play well with the forwarding, like the Ruby Forwardable module.<br>&gt;&gt; <br>&gt;&gt; It’s been a while since I’ve written Ruby but I have written quite a bit of it in the past.  Did something change?  As far as I know attribute accessors are basically like properties.  <br>&gt;&gt; <br>&gt;&gt; As far as forwarding goes, I have worked on a totally separate proposal for forwarding and have a second draft of that close to complete.  I don’t see how the two are related.<br>&gt;&gt; <br>&gt;&gt; Matthew<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Patrick<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 11, 2016, at 6:02 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 11, 2016, at 4:49 PM, Greg Parker &lt;gparker at apple.com &lt;mailto:gparker at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 11, 2016, at 9:17 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jan 11, 2016, at 10:21 AM, Janosch Hildebrand &lt;jnosh at jnosh.com &lt;mailto:jnosh at jnosh.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; propertylist:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Not a big fan of the name either, `propertyalias` came to mind but that sounds like it&#39;s only for a single property.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If you think of something better please let me know!<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &quot;property list&quot; already means something in Cocoa. You are unlikely to get approval under that name.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Good point!  Any better ideas?  I don&#39;t like it, just didn&#39;t think of a good one yet.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt; Greg Parker     gparker at apple.com &lt;mailto:gparker at apple.com&gt;     Runtime Wrangler<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/506b121c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05e222e6ef4d84013bb3baeb0e25c90b?s=50"></div><header><strong>[Proposal Draft] property lists</strong> from <string>Patrick Gili</string> &lt;gili.patrick.r at gili-labs.com&gt;<p>January 13, 2016 at 02:00:00pm</p></header><div class="content"><p>Just for the record, I like these proposals that add syntactic sugar the compiler uses to synthesize code in an effort to save time and effort for developers. However, developers need a means of inspecting synthesizing code.<br></p><p>Cheers,<br>-Patrick<br></p><p>&gt; On Jan 13, 2016, at 12:55 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 13, 2016, at 11:46 AM, Patrick Gili &lt;gili.patrick.r at gili-labs.com &lt;mailto:gili.patrick.r at gili-labs.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Not much has changed with regard to attribute accessors.<br>&gt;&gt; <br>&gt;&gt; Here is a link to a great tutorial:<br>&gt;&gt; <br>&gt;&gt; http://www.rubyist.net/~slagell/ruby/accessors.html &lt;http://www.rubyist.net/~slagell/ruby/accessors.html&gt;<br>&gt;&gt; <br>&gt;&gt; Here is a link to the Ruby documentation the Module module, which contains documentation for attire, attr_accessor, attr_reader, and attr_writer:<br>&gt;&gt; <br>&gt;&gt; http://ruby-doc.org/core-1.9.3/Module.html &lt;http://ruby-doc.org/core-1.9.3/Module.html&gt;<br>&gt;&gt; <br>&gt;&gt; I think the Ruby notion of an attribute is the direction you&#39;re trying to take this. You can take your concept and build on it.<br>&gt; <br>&gt; This hasn’t changed at all since I used Ruby.  It is really not like this proposal at all.  It is synthesizing the property (attribute) accessors themselves.  Swift does this automatically when you declare a stored property, or allows you to do so manually by writing computed accessors.<br>&gt; <br>&gt; The idea in this proposal was that we could synthesize at least two useful memberwise features for a type from a list of properties - a memberwise partial initializer and a computed tuple property.<br>&gt; <br>&gt; That said, I won’t be pursuing this proposal further given Chris’s comments about syntactic sugar proposals.  It seems doubtful that something like this would be considered in the Swift 3 timeframe and Swift 4 might bring macros which would hopefully make it possible to implement something like this ourselves if desired.<br>&gt; <br>&gt; Matthew<br>&gt; <br>&gt;&gt; <br>&gt;&gt; My apologies regarding my comment about forwarding. I momentarily confused the concepts of protocol forwarding and parameter forwarding.<br>&gt; <br>&gt; No problem, although I don’t see how either are directly related to this topic.<br>&gt; <br>&gt; Matthew<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Cheers,<br>&gt;&gt; -Patrick<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 13, 2016, at 11:21 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 13, 2016, at 9:15 AM, Patrick Gili &lt;gili.patrick.r at gili-labs.com &lt;mailto:gili.patrick.r at gili-labs.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Ruby has the notion of attribute accessors, which is very similar to this proposal. If you align the proposal to look more like attribute accessors in Ruby, then it might play well with the forwarding, like the Ruby Forwardable module.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It’s been a while since I’ve written Ruby but I have written quite a bit of it in the past.  Did something change?  As far as I know attribute accessors are basically like properties.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As far as forwarding goes, I have worked on a totally separate proposal for forwarding and have a second draft of that close to complete.  I don’t see how the two are related.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Patrick<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 11, 2016, at 6:02 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 11, 2016, at 4:49 PM, Greg Parker &lt;gparker at apple.com &lt;mailto:gparker at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jan 11, 2016, at 9:17 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jan 11, 2016, at 10:21 AM, Janosch Hildebrand &lt;jnosh at jnosh.com &lt;mailto:jnosh at jnosh.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; propertylist:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Not a big fan of the name either, `propertyalias` came to mind but that sounds like it&#39;s only for a single property.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; If you think of something better please let me know!<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &quot;property list&quot; already means something in Cocoa. You are unlikely to get approval under that name.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Good point!  Any better ideas?  I don&#39;t like it, just didn&#39;t think of a good one yet.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt;&gt; Greg Parker     gparker at apple.com &lt;mailto:gparker at apple.com&gt;     Runtime Wrangler<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/c00c07ae/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b660eecceda60138f137d353b8289925?s=50"></div><header><strong>[Proposal Draft] property lists</strong> from <string>Janosch Hildebrand</string> &lt;jnosh at jnosh.com&gt;<p>January 11, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On 11 Jan 2016, at 18:17, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; propertylist:<br>&gt;&gt; Not a big fan of the name either, `propertyalias` came to mind but that sounds like it&#39;s only for a single property.<br>&gt; <br>&gt; If you think of something better please let me know!<br></p><p>I will. There are also a lot of possibilities along the `propertygroup`, `propertyset` axis that share most of the downsides of `propertylist` but at least they wouldn&#39;t be too similar to https://en.wikipedia.org/wiki/Property_list. Although I&#39;m not sure if that naming overlap should be considered a problem.<br></p><p>&gt;&gt; @propertylist:<br>&gt;&gt; I think this is mostly redundant and the proposal would be improved by its removal.<br>&gt; <br>&gt; Removing it would require a redundant list of property names in some cases.  Why do you think that is better?<br></p><p>1) One less attribute to document, understand, maintain, ...<br>2) It makes the proposal simpler and clearer focusing more on the basic idea. If it were accepted and it turns out there is a big desire for something like that it could always be added – the reverse is much harder.<br>3) Having to explicitly spell out the propertylist aids clarity of intent and consequences<br>3) It has a very small use case. I don&#39;t think there are a lot of property declarations that would profit from this so I don&#39;t think it requires special consideration. At least personally I rarely declare multiple properties on a single line and not all of these might form a logical group.<br></p><p><br>&gt;&gt; [snip]<br>&gt;&gt; Default values in propertylist:<br>&gt;&gt; Strongly against this. Only applicable to initializer use case and feels generally out of place.<br>&gt; <br>&gt; It is extremely important to the initializer use case.  There is no way to provide a default for `let` properties in the initializer without allowing this.  I would not have written this proposal at all if it weren’t for a desire to improvise the initializer use case.<br></p><p>I understand and I&#39;m certainly biased by having mixed feelings about the initializer story in the first place...<br></p><p>My issues with the default values are roughly as follows:<br></p><p>1) My biggest issue is that it is really weird with regards to the other use case(s) of this idea, that is getters and setters for multiple properties.<br>I&#39;m not really sure yet how useful that would be but I find the idea interesting. But default values really don&#39;t fit well with it. They aren&#39;t really applicable to that use but it feels really weird to have these default values in the declaration and then not have them influence the synthesized behaviour.<br></p><p>2) If a property has a generally applicable default value -&gt; on the property declaration.<br>If a property has an applicable default value for a given initializer -&gt; on the initializer argument.<br></p><p>I understand that you&#39;re introducing a sort of middle ground that is applicable to multiple (related) initializers but I feel it muddles the waters with regards to the other cases and from my perspective has limited use. I&#39;d feel better with something that were still part of the initializer (syntax completely arbitrary): `init(...someGroup default s = &quot;&quot;)` but again for me the complexity outstrips the usefulness so I&#39;d be against that too ;-)<br></p><p>I tend towards requiring one to spell out (at least parts of) the initializer when one wants custom behaviour (or hope for a suitable flexible macro system) so we&#39;re probably bound to be at odds in these regards ;-)<br></p><p><br>&gt;&gt; [snip]<br>&gt;&gt; Parameter forwarding:<br>&gt;&gt; This is the proposal I like the least. I&#39;m not a fan of the syntax and it mostly saves some minor typing at the cost immediately knowing what the actual arguments are.<br>&gt; <br>&gt; Have you used a language with a similar feature (such as tuple packing and unpacking in a dynamic language)?  It is quite useful.  IMO, removing the clutter of each argument, type, and default value makes it much more clear that simple forwarding is happening.<br></p><p>I&#39;m aware of the concept but I have to admit that I don&#39;t have much experience with these features or the respective languages.<br>Although I think plain Swift tuples go more into that direction (albeit less powerful (for now?!)).<br></p><p>I agree that it is visually simpler but I think the visual similarity of the forwarding call (with all arguments) to the function definition is often enough to quickly deduce what is happening while still allowing one to check at a glance what the arguments, types and default values are...<br></p><p>&gt; The complete parameter list would still appear in generated documentation, autocomplete, etc.  An IDE could also provide an option to view the full parameter list in the function declaration itself.<br></p><p>I agree that would happen and would be helpful but I can&#39;t help but feel that I&#39;d be better served by a much smarter autocompletion than what we have today that would take care of the redundant typing without actually changing the resulting source code.<br></p><p>My larger issues are with:<br></p><p>a) the syntax<br>... which I dislike. Currently it&#39;s more at an emotional than intellectual level so I haven&#39;t fully grasped the why and how.<br>Also I actually quite liked the `init(...)` syntax in your earlier proposal so it&#39;s not the `...` per se...<br>At least I&#39;d like to see more discussion and proposals towards what something like that would look like and weigh the options.<br></p><p>b) not having a clear and settled picture of the concepts and ramifications under discussion.<br></p><p>This actually applies to all three proposals and the memberwise initializers proposal before as well. I can see that there is a problem being solved and a reasonable proposal for a solution. However I&#39;m neither sure that the problem is big enough to require a or the proposed solution and I&#39;m unsure if the proposed solution is the right one and I feel that I can&#39;t yet fully grasp the long term implications.<br></p><p>In part this is because the problems at hand don&#39;t irk me personally enough to want immediate remedy and in a larger part because I simply haven&#39;t much if any experience with languages and concepts that (attempt to) solve these issues. I&#39;m really missing a frame of reference as to what the solution-space looks like in these areas and what the respective advantages and disadvantages are – especially since disadvantages of language constructs are often not immediately obvious.<br></p><p>That&#39;s also why I really appreciate these proposals and the related discussions. Currently I feel like I&#39;m still swimming too much in the dark to form a well-reasoned opinion and I&#39;d like to see more approaches, more discussion and get a better feeling of future Swift changes that might impact these areas before settling down. I really don&#39;t mind waiting a few years before attempting to solve these issues (if they still exist). I also don&#39;t feel the need for a fast (stopgap) solution since these are not fundamental issues to me.<br></p><p>I&#39;m not sure if that is of much help to you but I hope it explains my current wait-and-see attitude a bit better. YMMV of course :-)<br></p><p>&gt;&gt; Partial initializers:<br>&gt;&gt; My dislike of parameter forwarding carries over to this but otherwise I find the basic idea quite nice.<br>&gt;&gt; My bigger issue here is that I currently don&#39;t see a huge use case for this that isn&#39;t already served by initializer delegation. Yes this seems to cover additional cases but I&#39;m not sure it justifies it&#39;s existence. It makes a lot more sense when considered as part of the memberwise initialization trifecta with parameter forwarding but like I said that&#39;s the part I don&#39;t really like.<br>&gt; <br>&gt; Initializer delegation requires the initializer you call to be a complete initializer.  It is not uncommon to have more than one designated initializer that need to share initialization logic.  There are techniques to factor out some of this logic today, but it would be much easier with partial initializers.  <br></p><p>Indeed! Which is why I like this part of the proposal and agree with what some others have written in response in the respective thread. It is also something that can and perhaps should be decided now. I&#39;m just unsure if there are enough use-cases to justify it. I can think of cases where it would have been useful but not enough to convince me.<br>There is also the downside that this can lead to less code duplication at the cost of fragmented and harder-to-follwo logic if abused.<br></p><p>Currently speaking I have no strong opinion either way and the discussion will probably convince me one way or another but as it stands I would certainly not object to this being added to the language.<br></p><p>&gt;&gt; Property Lists:<br>&gt;&gt; Like with partial initializers I find this to be an interesting idea and this seems to have other potential use cases apart from memberwise initialization. Then again I&#39;m unsure if this exact proposal is the way to go here. I&#39;d really prefer to see more abstract discussion of this idea before committing to any specifics.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Particularly here but also in general for all three proposals I feel that we might be better served by letting the language form further and waiting for more general pieces to fall into place before charging ahead in these areas. None of these require stopgap solutions from my point of view and I at least feel like I could evaluate this much better once I have an idea of what Swift is going to look like at version 4, 5, ...<br>&gt;&gt; From reading the Swift team&#39;s comments it seems like future improvements like variadic generics might make a potential difference here and I imagine the macro system might as well.<br>&gt; <br>&gt; These proposals are partly a response to the comments Dave and Joe made about building on more general underlying features.<br>&gt; <br>&gt; Partial initializers are a feature that would need to stand on its own, it would not be enabled by any other features.  As noted in the proposal, it might actually help to prepare the initialization model to support initialization of extensions and protocols with stored properties.<br></p><p>I would certainly be in favor of extracting partial initialization into a separate proposal without forwarding and have forwarding optionally build on that later. As it stands partial initialization seems more like step 2 of 3.<br></p><p>&gt; I don’t believe variadic generics would cover the full set of forwarding capabilities I would like to see.  Particularly forwarding of default values, but also forwarding a subset of parameters.  I know you are not a fan of the forwarding idea so that may not matter much to you.<br>&gt; <br>&gt; The property list idea could probably be implemented with a powerful-enough macro system.  My opinion is that it would be nice to solve this problem in Swift 3 if possible.  The feature could be replaced by a macro down the road if it becomes possible to write it that way.<br></p><p>Like I wrote above I fall on the other side of that argument and would rather wait than implement something now. For example I&#39;d first like to see what the variadic generics and macro system look like. However if the Swift team and community decide to implement a solution now and maybe revisit the topic later I won&#39;t really mind that on any of these topics.<br></p><p>&gt;&gt; I hope this doesn&#39;t sound too negative, you clearly invested a significant amount of work into these proposals and I value the effort. It helps me better understand the problems people see and what potential solutions might look like and stirs a lot of healthy discussion.<br>&gt;&gt; So don&#39;t let yourself be discouraged if I don&#39;t feel that changes in this area are required just yet :-)<br>&gt; <br>&gt; That’s a fair opinion.  The discussion has been healthy indeed!  IMO it has at least validated that there is broad support for doing something to address these problems.<br></p><p>Absolutely. Although that alone is not enough to convince me per se. Not a fair comparison really, but there was once broad support for adding GC to objc too ;-)<br></p><p>&gt; One of the big critiques of the Flexible Memberwise Initialization proposal was that it wasn’t powerful enough to support all the use cases people want to solve.  I think there is a lot of demand to solve these problems and many people would like to see them solved in Swift 3.  <br></p><p>Indeed! And there&#39;s probably no solution that fully satisfies everyone. It&#39;s also easy to desire increased power or a simpler system but you&#39;re the one left to actually present a cohesive solution and argument and defend the resultant complexity or lack of power so I respect your effort and certainly don&#39;t envy your position ;-)<br></p><p>- Janosch<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/d766406f/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] property lists</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 11, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Jan 11, 2016, at 4:50 PM, Janosch Hildebrand &lt;jnosh at jnosh.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 11 Jan 2016, at 18:17, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt; propertylist:<br>&gt;&gt;&gt; Not a big fan of the name either, `propertyalias` came to mind but that sounds like it&#39;s only for a single property.<br>&gt;&gt; <br>&gt;&gt; If you think of something better please let me know!<br>&gt; <br>&gt; I will. There are also a lot of possibilities along the `propertygroup`, `propertyset` axis that share most of the downsides of `propertylist` but at least they wouldn&#39;t be too similar to https://en.wikipedia.org/wiki/Property_list &lt;https://en.wikipedia.org/wiki/Property_list&gt;. Although I&#39;m not sure if that naming overlap should be considered a problem.<br></p><p>Yeah, I thought of those.  I went with list because it implies order which is important to this feature while group and set do not imply order.  Not sure why the overlap with plist files didn’t occur to me.  I guess because I’m used to the plist abbreviation.  :)<br></p><p>&gt; <br>&gt;&gt;&gt; @propertylist:<br>&gt;&gt;&gt; I think this is mostly redundant and the proposal would be improved by its removal.<br>&gt;&gt; <br>&gt;&gt; Removing it would require a redundant list of property names in some cases.  Why do you think that is better?<br>&gt; <br>&gt; 1) One less attribute to document, understand, maintain, ...<br>&gt; 2) It makes the proposal simpler and clearer focusing more on the basic idea. If it were accepted and it turns out there is a big desire for something like that it could always be added – the reverse is much harder.<br>&gt; 3) Having to explicitly spell out the propertylist aids clarity of intent and consequences<br>&gt; 3) It has a very small use case. I don&#39;t think there are a lot of property declarations that would profit from this so I don&#39;t think it requires special consideration. At least personally I rarely declare multiple properties on a single line and not all of these might form a logical group.<br></p><p>Fair points.  I agree that people usually don’t declare things this way.  <br></p><p>Part of the reason I included this was as a gesture to the people who like the Scala syntax which does declare a bunch of properties in one list.  If it was a major source of contention I would take it out.<br></p><p>&gt; <br>&gt; <br>&gt;&gt;&gt; [snip]<br>&gt;&gt;&gt; Default values in propertylist:<br>&gt;&gt;&gt; Strongly against this. Only applicable to initializer use case and feels generally out of place.<br>&gt;&gt; <br>&gt;&gt; It is extremely important to the initializer use case.  There is no way to provide a default for `let` properties in the initializer without allowing this.  I would not have written this proposal at all if it weren’t for a desire to improvise the initializer use case.<br>&gt; <br>&gt; I understand and I&#39;m certainly biased by having mixed feelings about the initializer story in the first place...<br>&gt; <br>&gt; My issues with the default values are roughly as follows:<br>&gt; <br>&gt; 1) My biggest issue is that it is really weird with regards to the other use case(s) of this idea, that is getters and setters for multiple properties.<br>&gt; I&#39;m not really sure yet how useful that would be but I find the idea interesting. But default values really don&#39;t fit well with it. They aren&#39;t really applicable to that use but it feels really weird to have these default values in the declaration and then not have them influence the synthesized behavior.<br></p><p>I agree it is a bit weird here, but IMO the primary use case is the partial initializer.  <br></p><p>The computed tuple properties seemed to get a lot of interest during the memberwise init review.  I generalized the idea from just sugar for a partial init because I realized we could get the those for free (and maybe other memberwise features down the road as well).  <br></p><p>But maybe that was a mistake.  Especially since we will eventually be able to do this kind of stuff with macros.<br></p><p>&gt; <br>&gt; 2) If a property has a generally applicable default value -&gt; on the property declaration.<br>&gt; If a property has an applicable default value for a given initializer -&gt; on the initializer argument.<br>&gt; <br>&gt; I understand that you&#39;re introducing a sort of middle ground that is applicable to multiple (related) initializers but I feel it muddles the waters with regards to the other cases and from my perspective has limited use. I&#39;d feel better with something that were still part of the initializer (syntax completely arbitrary): `init(...someGroup default s = &quot;&quot;)` but again for me the complexity outstrips the usefulness so I&#39;d be against that too ;-)<br></p><p>Sure.  Maybe it would make more sense to focus on making memberwise partial init declarations really concise.<br></p><p>&gt; <br>&gt; I tend towards requiring one to spell out (at least parts of) the initializer when one wants custom behaviour (or hope for a suitable flexible macro system) so we&#39;re probably bound to be at odds in these regards ;-)<br></p><p>I agree in terms of custom behavior.  But simple property assignments are just boilerplate that would ideally be stated as concisely as possible.  <br></p><p>The problem IMO isn’t the repetition as much as the fact that it clutters up your code making the nontrivial stuff stand out less.<br></p><p>&gt; <br>&gt; <br>&gt;&gt;&gt; [snip]<br>&gt;&gt;&gt; Parameter forwarding:<br>&gt;&gt;&gt; This is the proposal I like the least. I&#39;m not a fan of the syntax and it mostly saves some minor typing at the cost immediately knowing what the actual arguments are.<br>&gt;&gt; <br>&gt;&gt; Have you used a language with a similar feature (such as tuple packing and unpacking in a dynamic language)?  It is quite useful.  IMO, removing the clutter of each argument, type, and default value makes it much more clear that simple forwarding is happening.<br>&gt; <br>&gt; I&#39;m aware of the concept but I have to admit that I don&#39;t have much experience with these features or the respective languages.<br>&gt; Although I think plain Swift tuples go more into that direction (albeit less powerful (for now?!)).<br>&gt; <br>&gt; I agree that it is visually simpler but I think the visual similarity of the forwarding call (with all arguments) to the function definition is often enough to quickly deduce what is happening while still allowing one to check at a glance what the arguments, types and default values are...<br>&gt; <br>&gt;&gt; The complete parameter list would still appear in generated documentation, autocomplete, etc.  An IDE could also provide an option to view the full parameter list in the function declaration itself.<br>&gt; <br>&gt; I agree that would happen and would be helpful but I can&#39;t help but feel that I&#39;d be better served by a much smarter autocompletion than what we have today that would take care of the redundant typing without actually changing the resulting source code.<br>&gt; <br>&gt; My larger issues are with:<br>&gt; <br>&gt; a) the syntax<br>&gt; ... which I dislike. Currently it&#39;s more at an emotional than intellectual level so I haven&#39;t fully grasped the why and how.<br>&gt; Also I actually quite liked the `init(...)` syntax in your earlier proposal so it&#39;s not the `...` per se...<br>&gt; At least I&#39;d like to see more discussion and proposals towards what something like that would look like and weigh the options.<br></p><p>Syntax is something I don’t care much about as long as it is clear and makes sense, etc.  I would change it if a better idea comes up.<br></p><p>&gt; <br>&gt; b) not having a clear and settled picture of the concepts and ramifications under discussion.<br>&gt; <br>&gt; This actually applies to all three proposals and the memberwise initializers proposal before as well. I can see that there is a problem being solved and a reasonable proposal for a solution. However I&#39;m neither sure that the problem is big enough to require a or the proposed solution and I&#39;m unsure if the proposed solution is the right one and I feel that I can&#39;t yet fully grasp the long term implications.<br>&gt; <br>&gt; In part this is because the problems at hand don&#39;t irk me personally enough to want immediate remedy and in a larger part because I simply haven&#39;t much if any experience with languages and concepts that (attempt to) solve these issues. I&#39;m really missing a frame of reference as to what the solution-space looks like in these areas and what the respective advantages and disadvantages are – especially since disadvantages of language constructs are often not immediately obvious.<br>&gt; <br>&gt; That&#39;s also why I really appreciate these proposals and the related discussions. Currently I feel like I&#39;m still swimming too much in the dark to form a well-reasoned opinion and I&#39;d like to see more approaches, more discussion and get a better feeling of future Swift changes that might impact these areas before settling down. I really don&#39;t mind waiting a few years before attempting to solve these issues (if they still exist). I also don&#39;t feel the need for a fast (stopgap) solution since these are not fundamental issues to me.<br>&gt; <br>&gt; I&#39;m not sure if that is of much help to you but I hope it explains my current wait-and-see attitude a bit better. YMMV of course :-)<br>&gt; <br>&gt;&gt;&gt; Partial initializers:<br>&gt;&gt;&gt; My dislike of parameter forwarding carries over to this but otherwise I find the basic idea quite nice.<br>&gt;&gt;&gt; My bigger issue here is that I currently don&#39;t see a huge use case for this that isn&#39;t already served by initializer delegation. Yes this seems to cover additional cases but I&#39;m not sure it justifies it&#39;s existence. It makes a lot more sense when considered as part of the memberwise initialization trifecta with parameter forwarding but like I said that&#39;s the part I don&#39;t really like.<br>&gt;&gt; <br>&gt;&gt; Initializer delegation requires the initializer you call to be a complete initializer.  It is not uncommon to have more than one designated initializer that need to share initialization logic.  There are techniques to factor out some of this logic today, but it would be much easier with partial initializers.  <br>&gt; <br>&gt; Indeed! Which is why I like this part of the proposal and agree with what some others have written in response in the respective thread. It is also something that can and perhaps should be decided now. I&#39;m just unsure if there are enough use-cases to justify it. I can think of cases where it would have been useful but not enough to convince me.<br></p><p>Glad you like this part.<br></p><p>&gt; There is also the downside that this can lead to less code duplication at the cost of fragmented and harder-to-follwo logic if abused.<br></p><p>Yes, but that is always the case.  :)<br></p><p>&gt; <br>&gt; Currently speaking I have no strong opinion either way and the discussion will probably convince me one way or another but as it stands I would certainly not object to this being added to the language.<br>&gt; <br>&gt;&gt;&gt; Property Lists:<br>&gt;&gt;&gt; Like with partial initializers I find this to be an interesting idea and this seems to have other potential use cases apart from memberwise initialization. Then again I&#39;m unsure if this exact proposal is the way to go here. I&#39;d really prefer to see more abstract discussion of this idea before committing to any specifics.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Particularly here but also in general for all three proposals I feel that we might be better served by letting the language form further and waiting for more general pieces to fall into place before charging ahead in these areas. None of these require stopgap solutions from my point of view and I at least feel like I could evaluate this much better once I have an idea of what Swift is going to look like at version 4, 5, ...<br>&gt;&gt;&gt; From reading the Swift team&#39;s comments it seems like future improvements like variadic generics might make a potential difference here and I imagine the macro system might as well.<br>&gt;&gt; <br>&gt;&gt; These proposals are partly a response to the comments Dave and Joe made about building on more general underlying features.<br>&gt;&gt; <br>&gt;&gt; Partial initializers are a feature that would need to stand on its own, it would not be enabled by any other features.  As noted in the proposal, it might actually help to prepare the initialization model to support initialization of extensions and protocols with stored properties.<br>&gt; <br>&gt; I would certainly be in favor of extracting partial initialization into a separate proposal without forwarding and have forwarding optionally build on that later. As it stands partial initialization seems more like step 2 of 3.<br>&gt; <br>&gt;&gt; I don’t believe variadic generics would cover the full set of forwarding capabilities I would like to see.  Particularly forwarding of default values, but also forwarding a subset of parameters.  I know you are not a fan of the forwarding idea so that may not matter much to you.<br>&gt;&gt; <br>&gt;&gt; The property list idea could probably be implemented with a powerful-enough macro system.  My opinion is that it would be nice to solve this problem in Swift 3 if possible.  The feature could be replaced by a macro down the road if it becomes possible to write it that way.<br>&gt; <br>&gt; Like I wrote above I fall on the other side of that argument and would rather wait than implement something now. For example I&#39;d first like to see what the variadic generics and macro system look like. However if the Swift team and community decide to implement a solution now and maybe revisit the topic later I won&#39;t really mind that on any of these topics.<br>&gt; <br>&gt;&gt;&gt; I hope this doesn&#39;t sound too negative, you clearly invested a significant amount of work into these proposals and I value the effort. It helps me better understand the problems people see and what potential solutions might look like and stirs a lot of healthy discussion.<br>&gt;&gt;&gt; So don&#39;t let yourself be discouraged if I don&#39;t feel that changes in this area are required just yet :-)<br>&gt;&gt; <br>&gt;&gt; That’s a fair opinion.  The discussion has been healthy indeed!  IMO it has at least validated that there is broad support for doing something to address these problems.<br>&gt; <br>&gt; Absolutely. Although that alone is not enough to convince me per se. Not a fair comparison really, but there was once broad support for adding GC to objc too ;-)<br></p><p>Lol.  :)<br></p><p>&gt; <br>&gt;&gt; One of the big critiques of the Flexible Memberwise Initialization proposal was that it wasn’t powerful enough to support all the use cases people want to solve.  I think there is a lot of demand to solve these problems and many people would like to see them solved in Swift 3.  <br>&gt; <br>&gt; Indeed! And there&#39;s probably no solution that fully satisfies everyone. It&#39;s also easy to desire increased power or a simpler system but you&#39;re the one left to actually present a cohesive solution and argument and defend the resultant complexity or lack of power so I respect your effort and certainly don&#39;t envy your position ;-)<br>&gt; <br></p><p>Yeah, it’s clear that no one thing will make everyone happy.  I’m hoping to find solutions that make most people mostly happy.  :)<br></p><p>Matthew<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/390ce97f/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Proposal Draft] property lists</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January 12, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; Am 11.01.2016 um 18:17 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; These proposals are partly a response to the comments Dave and Joe made about building on more general underlying features.<br>&gt; <br></p><p>I am afraid they are not general enough for my taste and leaning too much towards initialization.<br></p><p>Parameter forwarding:<br>This does not make the language more expressive, i.e. there is no abstraction of the parameter list. I cannot do anything with it except forwarding it. That seems not very useful, it just allows saving some keystrokes which is not really necessary.<br></p><p>Furthermore the syntax is really wrong in my opinion:<br></p><p>// user writes:<br>func bar(...fooParams) {<br>    foo(i: 32, ...fooParams)<br>}<br></p><p>The problem is that I do not see anymore what the API of bar() is! I have to look at method foo() (after scanning the body of bar() to find it) and look there. That’s really bad.<br></p><p>Something like the following (just using some random syntax) would be much better, as it (1) keeps the API of bar() visible and (2) abstracts over the arguments giving us a handle to manipulate it.<br></p><p>func bar(i i: Int, s: String, f: Float = 42, d: Double = 43, b: Bool = false) {<br>	foo(#arguments.with(i: 32))<br>	// we can do something with #arguments!<br>	for (Argument arg in #arguments) {<br>		print(&quot;\(arg.name): \(arg.type) = \(arg.value)“)<br>	}<br>}<br></p><p>But then I’m not sure what concrete problems this would solve. Writing out the parameter list is not so bad. I’d wager that in cases of long argument lists a redesign would be better, i.e. by encapsulating groups of parameters into structs or classes (which will probably attract behavior as well in contrast to the property list tuples).<br>I’d really like to see some concrete examples of use cases where this would be useful and better than refactoring the design.<br></p><p>Partial initializers:<br>These might have the most merit but are a special case of initialization, so there is nothing gained in general expressivity.<br></p><p>Property Lists:<br>This is an attempt to solve the problem of the „members“ attribute having to be narrowed for different use cases, like narrowing with regards to var parameters only or with regards to accessibility. Declaring the different views which are required for a specific class or struct explicitly as property list is an interesting solution for that and might possibly be the right thing for a statically safe language. <br>What I definitely don’t like is having a partial initializer automatically being created as well. I’m not too fond of automatically created code as that is (a) not visible, (b) therefore not part of the documentation (and even if the documentation gets enriched by explicit entries for automagic functions, which would be nice [the memberwise initializer should be auto-expanded in the documentation, for example], it is still not visible in the source file), and last not least it is (c) not searchable.<br>Currently I’m thinking the potential problems to be solved with this are not worth the magic (= making the language more difficult and reducing the readability of code).<br></p><p>-Thorsten<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160112/d88a4124/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
