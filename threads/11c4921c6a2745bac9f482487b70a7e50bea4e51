<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>When to use argument labels (a new approach)</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>February  3, 2016 at 04:00:00pm</p></header><div class="content"><p>on Wed Feb 03 2016, Dave Abrahams &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; on Tue Feb 02 2016, Erica Sadun &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Thoughts? Thoughts:<br>&gt;&gt;<br>&gt;&gt; Swift prizes clarity. Its parameter labeling system emphasizes<br>&gt;&gt; self-documentation and guides code production. In nearly every case,<br>&gt;&gt; labels follow three simple rules:<br>&gt;&gt;<br>&gt;&gt; Skip argument labels for a method or function&#39;s first parameter<br>&gt;&gt; Use argument labels for a method or function&#39;s subsequent parameters<br>&gt;&gt; Require argument labels for initializers<br>&gt;&gt;<br>&gt;&gt; These base rules enhance Swift legibility. Unlike other languages<br>&gt;&gt; whose positional argument names have meaning only within the<br>&gt;&gt; implementation context, Swift&#39;s labels convey use and meaning at the<br>&gt;&gt; calling site. This creates better communication, enhances<br>&gt;&gt; maintainability, and adheres to the principle that code is written<br>&gt;&gt; rarely and read and reviewed often.<br>&gt;&gt;<br>&gt;&gt; At times, special circumstances may apply to your code as explored in<br>&gt;&gt; the following rules:<br>&gt;&gt;<br>&gt;&gt; Skip first argument labels when the first argument completes a sentence established in the base name. If the argument describes a call&#39;s primary semantics, it does not require a label:<br>&gt;&gt;     a.contains(b)  // b completes the phrase &quot;a contains b&quot;<br>&gt;&gt;     a.mergeWith(b) // b completes the phrase &quot;merge with b&quot;<br>&gt;&gt;     a.readFrom(u, ofType: b) // &quot;a, read from u&quot; describes<br>&gt;&gt;                              // primary semantics so u gets no<br>&gt;&gt;                              // label. <br>&gt;&gt;                              // b is an option that tunes the <br>&gt;&gt;                              // primary semantics<br>&gt;&gt; Skip the first argument label when a noun in the base name describes the first argument&#39;s role.<br>&gt;&gt;    a.addObserver(b) // &quot;add b&quot; completes a meaningful sentence that<br>&gt;&gt;                     // defines the intentended semantics.  The first<br>&gt;&gt;                     // argument is the &quot;Observer&quot;.<br>&gt;&gt; Move the first argument label to the base name when it describes a name or identifier that acts as the subject of the base action.<br>&gt;&gt;      a.transitionToScene(.GreatHall)               // yes<br>&gt;&gt;      a.transitionToSceneWithIdentifier(.GreatHall) // no<br>&gt;&gt;<br>&gt;&gt;      let p = someFont.glyph(&quot;propellor&quot;)           // yes<br>&gt;&gt;      let p = someFont.glyphWithName(&quot;propellor&quot;)   // no<br>&gt;&gt;      let p = someFont.glyph(name: &quot;propellor&quot;)     // no<br>&gt;&gt; Move the first argument label to the base name when it describes argument attributes of existing instances.<br>&gt;&gt;      a.tracksOfMediaType(&quot;Wax Cylinder&quot;)      // yes<br>&gt;&gt;      a.removeFirstTrackOfMediaType(&quot;BetaMax&quot;) // yes<br>&gt;&gt;<br>&gt;&gt;      a.tracks(mediaType: &quot;Wax Cylinder&quot;)            // no<br>&gt;&gt;      a.removeFirstTrack(havingMediaType: &quot;BetaMax&quot;) // no<br>&gt;&gt; Use first label arguments when the first parameter is semantically distinct from the base name and does not complete a meaningful &quot;sentence&quot;<br>&gt;&gt;     a.dismiss(animated: b) // &quot;a, dismiss b&quot; is a sentence but <br>&gt;&gt;                            // doesn&#39;t describe the semantics at all, <br>&gt;&gt;                            // thus we add a label for b.<br>&gt;&gt; Use all argument labels when the relationship between arguments is semantically stronger than the relationship between the first argument and the base name.<br>&gt;&gt;     moveTo(x: a, y: b)<br>&gt;&gt;     login(userName: a, password: b)<br>&gt;&gt;     constructColor(red: r, green: g, blue: b, alpha: a)<br>&gt;&gt; Omit labels for argument peers that cannot be usefully distinguished.<br>&gt;&gt;     min(number1, number2)<br>&gt;&gt;     zip(sequence1, sequence2)<br>&gt;&gt; Use explicit argument labels to describe attributes of an instance that&#39;s being created. Your calls should resemble initializers.<br>&gt;&gt;      AudioTrack(mediaType: &quot;BetaMax&quot;)                   // initializer<br>&gt;&gt;      trackFactory.newTrack(mediaType: &quot;Wax Cylinder&quot;)   // yes<br>&gt;&gt;<br>&gt;&gt;      trackFactory.newTrackOfMediaType(&quot;Wax Cylinder&quot;)   // no<br>&gt;&gt; Use first argument labels that would have normally appeared in the base name when building groups of related calls whose implementations are distinguished specifically by their parameters. Your calls should resemble initializers. <br>&gt;&gt;   login(userName: a, password: b) // not loginWithUserName(a, password: b)<br>&gt;&gt;   login(credential: a) // not loginWithCredential(a)<br>&gt;&gt; Skip first argument labels for initializers when using full width type conversions, that is when initializing from instances of another type.<br>&gt;&gt;  extension String { <br>&gt;&gt;      // Convert `x` into its textual representation <br>&gt;&gt;      // in the given radix<br>&gt;&gt;      init(_ x: BigInt, radix: Int = 10) <br>&gt;&gt;  }<br>&gt;&gt;  text = &quot;The value is: &quot;<br>&gt;&gt;  text += String(veryLargeNumber)<br>&gt;&gt;  text += &quot; and in hexadecimal, it&#39;s&quot;<br>&gt;&gt;  text += String(veryLargeNumber, radix: 16)<br>&gt;&gt; Use first argument labels when narrowing initial values to make it conform to restrictions within the new type. The label should describe how the instance will be modified:<br>&gt;&gt;  extension UInt32 {<br>&gt;&gt;      init(_ value: Int16) // Widening, so no label <br>&gt;&gt;      init(truncating bits: UInt64)<br>&gt;&gt;      init(saturating value: UInt64)<br>&gt;&gt;  }<br>&gt;<br>&gt; Okay... since you didn&#39;t directly address anything I wrote, should I<br>&gt; take this to mean you think I got it all wrong?  Or...?<br></p><p>OK, sorry, that was hasty; you rewrote what I wrote.  But again, I&#39;m<br>missing any explanation of what you think your writeup accomplishes that<br>mine does not.  Is it an improvement?  If so, why and how?<br></p><p>-- <br>-Dave<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
