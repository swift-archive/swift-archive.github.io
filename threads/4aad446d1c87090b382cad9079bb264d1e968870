<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Splat</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February 10, 2016 at 01:00:00pm</p></header><div class="content"><p>So, since SE-0029 has been accepted, let&#39;s think about explicit replacements. So far, I&#39;ve been able to think of three general approaches. For the examples below, I&#39;ll assume there&#39;s a `func concatenate(number: Int, to string: String) -&gt; String`, which does the obvious thing. Where supported, I will fully qualify names with SE-0021 syntax, but in some cases this might not be necessary.<br></p><p>		1. Special parameter label.<br></p><p>`concatenate` is implicitly overloaded with a `func concatenate(parameters: (Int, String)) -&gt; String`.<br></p><p>	concatenate(parameters: tuple)<br>	tuples.map(concatenate(parameters:))<br></p><p>Advantages: <br>- Does not require any new call-side syntax.<br>- Googleable thanks to use of identifiers.<br></p><p>Disadvantages:<br>- Could conflict with functions that use `parameters` as an argument label.<br>- Not clear how it would distinguish between `concatenate(_:to:)` and e.g. `concatenate(_:with:)`.<br>- Might reintroduce type checking complexity, since it&#39;s adding overloads.<br>- A bit wordy.<br>- As far as I know, not precedented in other languages.<br></p><p>		2. Method on functions.<br></p><p>`concatenate` has a method on it called, say, `apply(to:)` which takes a tuple of parameters.<br></p><p>	concatenate(_:to:).apply(to: tuple)<br>	tuples.map(concatenate(_:to:).apply(to:))<br></p><p>Advantages:<br>- You can be sure of the variant you&#39;re selecting.<br>- Googleable thanks to use of identifiers.<br>- Similar to usage in Javascript.<br></p><p>Disadvantages:<br>- Rather wordy, with lots of chaining and extra parentheses.<br>- Methods on unapplied functions might be a little confusing.<br></p><p>		3. Splat operator.<br></p><p>An operator like `*` is used to indicate splatting. A tuple can be put to the right of the operator to splat it in immediately, or it can be omitted to select a splattable version of the function.<br></p><p>	concatenate(_:to: *tuple)<br>	tuples.map(concatenate(_:to: *))<br></p><p>Advantages:<br>- You can be sure of the variant you&#39;re selecting.<br>- Similar to usage in Ruby and Perl 6.<br>- Fairly short in all forms.<br></p><p>Disadvantages:<br>- Not Googleable.<br>- New magic syntax.<br>- Two slightly different forms depending on whether you&#39;re calling or not.<br></p><p>Any thoughts on these, or alternative approaches (as opposed to small syntax tweaks)?<br></p><p><br></p><p>P.S. As for pointers potentially using prefix `*` for memory dereferencing, I would instead make them use postfix `!`. `!` could become an `unwrapped` pseudo-property that any type can use, democratizing another piece of `Optional` magic and working around the vexing problem of what you name the `Pointer` property for &quot;that thing you&#39;re actually pointing to&quot;.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>Splat</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>February 11, 2016 at 04:00:00am</p></header><div class="content"><p>Do you need access to the same functions using tuple-splat and non-tuple splat way — or just need a way to generically pass parameters from a tuple (homogeneous list of typed values - label accessible as content type) of variable length?<br></p><p><br>&gt; On 2016-02-11, at 4:21:32, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; So, since SE-0029 has been accepted, let&#39;s think about explicit replacements. So far, I&#39;ve been able to think of three general approaches. For the examples below, I&#39;ll assume there&#39;s a `func concatenate(number: Int, to string: String) -&gt; String`, which does the obvious thing. Where supported, I will fully qualify names with SE-0021 syntax, but in some cases this might not be necessary.<br>&gt; <br>&gt; 		1. Special parameter label.<br>&gt; <br>&gt; `concatenate` is implicitly overloaded with a `func concatenate(parameters: (Int, String)) -&gt; String`.<br>&gt; <br>&gt; 	concatenate(parameters: tuple)<br>&gt; 	tuples.map(concatenate(parameters:))<br>&gt; <br>&gt; Advantages: <br>&gt; - Does not require any new call-side syntax.<br>&gt; - Googleable thanks to use of identifiers.<br>&gt; <br>&gt; Disadvantages:<br>&gt; - Could conflict with functions that use `parameters` as an argument label.<br>&gt; - Not clear how it would distinguish between `concatenate(_:to:)` and e.g. `concatenate(_:with:)`.<br>&gt; - Might reintroduce type checking complexity, since it&#39;s adding overloads.<br>&gt; - A bit wordy.<br>&gt; - As far as I know, not precedented in other languages.<br>&gt; <br>&gt; 		2. Method on functions.<br>&gt; <br>&gt; `concatenate` has a method on it called, say, `apply(to:)` which takes a tuple of parameters.<br>&gt; <br>&gt; 	concatenate(_:to:).apply(to: tuple)<br>&gt; 	tuples.map(concatenate(_:to:).apply(to:))<br>&gt; <br>&gt; Advantages:<br>&gt; - You can be sure of the variant you&#39;re selecting.<br>&gt; - Googleable thanks to use of identifiers.<br>&gt; - Similar to usage in Javascript.<br>&gt; <br>&gt; Disadvantages:<br>&gt; - Rather wordy, with lots of chaining and extra parentheses.<br>&gt; - Methods on unapplied functions might be a little confusing.<br>&gt; <br>&gt; 		3. Splat operator.<br>&gt; <br>&gt; An operator like `*` is used to indicate splatting. A tuple can be put to the right of the operator to splat it in immediately, or it can be omitted to select a splattable version of the function.<br>&gt; <br>&gt; 	concatenate(_:to: *tuple)<br>&gt; 	tuples.map(concatenate(_:to: *))<br>&gt; <br>&gt; Advantages:<br>&gt; - You can be sure of the variant you&#39;re selecting.<br>&gt; - Similar to usage in Ruby and Perl 6.<br>&gt; - Fairly short in all forms.<br>&gt; <br>&gt; Disadvantages:<br>&gt; - Not Googleable.<br>&gt; - New magic syntax.<br>&gt; - Two slightly different forms depending on whether you&#39;re calling or not.<br>&gt; <br>&gt; Any thoughts on these, or alternative approaches (as opposed to small syntax tweaks)?<br>&gt; <br>&gt; <br>&gt; <br>&gt; P.S. As for pointers potentially using prefix `*` for memory dereferencing, I would instead make them use postfix `!`. `!` could become an `unwrapped` pseudo-property that any type can use, democratizing another piece of `Optional` magic and working around the vexing problem of what you name the `Pointer` property for &quot;that thing you&#39;re actually pointing to&quot;.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Splat</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>February 10, 2016 at 01:00:00pm</p></header><div class="content"><p>Weird idea based on #1: since some folks were discussing having &quot;$$&quot; as a<br>special identifier meaning &quot;all arguments&quot; in a closure, perhaps the<br>special parameter label could be $$ as well?<br></p><p>    concatenate(mytuple.0, mytuple.1)<br>    concatenate($$: mytuple)<br></p><p>On Wed, Feb 10, 2016 at 1:21 PM, Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; So, since SE-0029 has been accepted, let&#39;s think about explicit<br>&gt; replacements. So far, I&#39;ve been able to think of three general approaches.<br>&gt; For the examples below, I&#39;ll assume there&#39;s a `func concatenate(number:<br>&gt; Int, to string: String) -&gt; String`, which does the obvious thing. Where<br>&gt; supported, I will fully qualify names with SE-0021 syntax, but in some<br>&gt; cases this might not be necessary.<br>&gt;<br>&gt;                 1. Special parameter label.<br>&gt;<br>&gt; `concatenate` is implicitly overloaded with a `func<br>&gt; concatenate(parameters: (Int, String)) -&gt; String`.<br>&gt;<br>&gt;         concatenate(parameters: tuple)<br>&gt;         tuples.map(concatenate(parameters:))<br>&gt;<br>&gt; Advantages:<br>&gt; - Does not require any new call-side syntax.<br>&gt; - Googleable thanks to use of identifiers.<br>&gt;<br>&gt; Disadvantages:<br>&gt; - Could conflict with functions that use `parameters` as an argument label.<br>&gt; - Not clear how it would distinguish between `concatenate(_:to:)` and e.g.<br>&gt; `concatenate(_:with:)`.<br>&gt; - Might reintroduce type checking complexity, since it&#39;s adding overloads.<br>&gt; - A bit wordy.<br>&gt; - As far as I know, not precedented in other languages.<br>&gt;<br>&gt;                 2. Method on functions.<br>&gt;<br>&gt; `concatenate` has a method on it called, say, `apply(to:)` which takes a<br>&gt; tuple of parameters.<br>&gt;<br>&gt;         concatenate(_:to:).apply(to: tuple)<br>&gt;         tuples.map(concatenate(_:to:).apply(to:))<br>&gt;<br>&gt; Advantages:<br>&gt; - You can be sure of the variant you&#39;re selecting.<br>&gt; - Googleable thanks to use of identifiers.<br>&gt; - Similar to usage in Javascript.<br>&gt;<br>&gt; Disadvantages:<br>&gt; - Rather wordy, with lots of chaining and extra parentheses.<br>&gt; - Methods on unapplied functions might be a little confusing.<br>&gt;<br>&gt;                 3. Splat operator.<br>&gt;<br>&gt; An operator like `*` is used to indicate splatting. A tuple can be put to<br>&gt; the right of the operator to splat it in immediately, or it can be omitted<br>&gt; to select a splattable version of the function.<br>&gt;<br>&gt;         concatenate(_:to: *tuple)<br>&gt;         tuples.map(concatenate(_:to: *))<br>&gt;<br>&gt; Advantages:<br>&gt; - You can be sure of the variant you&#39;re selecting.<br>&gt; - Similar to usage in Ruby and Perl 6.<br>&gt; - Fairly short in all forms.<br>&gt;<br>&gt; Disadvantages:<br>&gt; - Not Googleable.<br>&gt; - New magic syntax.<br>&gt; - Two slightly different forms depending on whether you&#39;re calling or not.<br>&gt;<br>&gt; Any thoughts on these, or alternative approaches (as opposed to small<br>&gt; syntax tweaks)?<br>&gt;<br>&gt;<br>&gt;<br>&gt; P.S. As for pointers potentially using prefix `*` for memory<br>&gt; dereferencing, I would instead make them use postfix `!`. `!` could become<br>&gt; an `unwrapped` pseudo-property that any type can use, democratizing another<br>&gt; piece of `Optional` magic and working around the vexing problem of what you<br>&gt; name the `Pointer` property for &quot;that thing you&#39;re actually pointing to&quot;.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160210/41d53b91/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/49f329a0267f5a1773a77017882a82a8?s=50"></div><header><strong>Splat</strong> from <string>Rainer Brockerhoff</string> &lt;rainer at brockerhoff.net&gt;<p>February 10, 2016 at 09:00:00pm</p></header><div class="content"><p>On 2/10/16 19:52, Jacob Bandes-Storch via swift-evolution wrote:<br>&gt; Weird idea based on #1: since some folks were discussing having &quot;$$&quot; as<br>&gt; a special identifier meaning &quot;all arguments&quot; in a closure, perhaps the<br>&gt; special parameter label could be $$ as well?<br>&gt; <br>&gt;     concatenate(mytuple.0, mytuple.1)<br>&gt;     concatenate($$: mytuple)<br></p><p>Would this, perhaps, solve the varargs forwarding problem?<br></p><p>public func Foo(items: Any...) {<br>	Bar($$)<br>}<br></p><p>-- <br>Rainer Brockerhoff  &lt;rainer at brockerhoff.net&gt;<br>Belo Horizonte, Brazil<br>&quot;In the affairs of others even fools are wise<br>In their own business even sages err.&quot;<br>http://brockerhoff.net/blog/<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Splat</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>February 10, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Feb 10, 2016, at 1:21 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; P.S. As for pointers potentially using prefix `*` for memory dereferencing, I would instead make them use postfix `!`. `!` could become an `unwrapped` pseudo-property that any type can use, democratizing another piece of `Optional` magic and working around the vexing problem of what you name the `Pointer` property for &quot;that thing you&#39;re actually pointing to&quot;.<br></p><p>FWIW, I’m +1 on eliminating magic in the compiler and moving it to the stdlib (postfix ! is one example of that, I don’t recall offhand what prevents it from moving).  However, I’d be reticent to start using ! for safe operations like dereferencing a (guaranteed memory safe) pointer.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Splat</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February 10, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Feb 10, 2016, at 1:47 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 10, 2016, at 1:21 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; P.S. As for pointers potentially using prefix `*` for memory dereferencing, I would instead make them use postfix `!`. `!` could become an `unwrapped` pseudo-property that any type can use, democratizing another piece of `Optional` magic and working around the vexing problem of what you name the `Pointer` property for &quot;that thing you&#39;re actually pointing to&quot;.<br>&gt; <br>&gt; FWIW, I’m +1 on eliminating magic in the compiler and moving it to the stdlib (postfix ! is one example of that, I don’t recall offhand what prevents it from moving).  However, I’d be reticent to start using ! for safe operations like dereferencing a (guaranteed memory safe) pointer.<br></p><p>&#39;!&#39; produces an lvalue if its operand is an lvalue, which is something user-defined operators are currently unable to do.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Splat</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>February 10, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Feb 10, 2016, at 2:12 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 10, 2016, at 1:47 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 10, 2016, at 1:21 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; P.S. As for pointers potentially using prefix `*` for memory dereferencing, I would instead make them use postfix `!`. `!` could become an `unwrapped` pseudo-property that any type can use, democratizing another piece of `Optional` magic and working around the vexing problem of what you name the `Pointer` property for &quot;that thing you&#39;re actually pointing to&quot;.<br>&gt;&gt; <br>&gt;&gt; FWIW, I’m +1 on eliminating magic in the compiler and moving it to the stdlib (postfix ! is one example of that, I don’t recall offhand what prevents it from moving).  However, I’d be reticent to start using ! for safe operations like dereferencing a (guaranteed memory safe) pointer.<br>&gt; <br>&gt; &#39;!&#39; produces an lvalue if its operand is an lvalue, which is something user-defined operators are currently unable to do.<br></p><p>Right, makes sense, thanks.<br></p><p>-Chris<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Splat</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February 10, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; However, I’d be reticent to start using ! for safe operations like dereferencing a (guaranteed memory safe) pointer.<br></p><p>A pointer dereference can cause a segfault. Even if you assume it&#39;s not pointing to unallocated memory, UnsafePointers can be nil, at least in Swift 2.<br></p><p>(The lvalue thing Joe Groff mentioned is also a concern, but adding inout return values would fix that in principle.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Splat</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>February 10, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Feb 10, 2016, at 14:32, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; However, I’d be reticent to start using ! for safe operations like dereferencing a (guaranteed memory safe) pointer.<br>&gt; <br>&gt; A pointer dereference can cause a segfault. Even if you assume it&#39;s not pointing to unallocated memory, UnsafePointers can be nil, at least in Swift 2.<br></p><p>Aside: I&#39;m still hoping to make this Optionality explicit at some point, so that &#39;UnsafePointer&#39; is known non-null and &#39;Optional&lt;UnsafePointer&gt;&#39; may be null. But even then you can&#39;t be sure the memory hasn&#39;t been freed since you first got the pointer.<br></p><p>Jordan<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/aeab22e60ba7b7e2bd445775850448d1?s=50"></div><header><strong>Splat</strong> from <string>Radosław Pietruszewski</string> &lt;radexpl at gmail.com&gt;<p>February 10, 2016 at 11:00:00pm</p></header><div class="content"><p>There was a discussion about using `…` as an _array splat_ operator, i.e:<br></p><p>    func foo(xs: Int…)<br>    let xs = [1, 2, 3]<br>    foo(xs…)<br></p><p>That would be symmetric with “…” defining a variable length argument, and also the same approach as Ruby, but instead of `*xs` which looks like memory dereferencing, `xs…`, which IMHO works better as a symbol for this.<br></p><p>Perhaps it would be possible to overload this operator to perform _tuple splat_ as well. (I haven’t put it through tough thorough thought, though.)<br></p><p>— Radek<br></p><p>&gt; On 10 Feb 2016, at 22:21, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; So, since SE-0029 has been accepted, let&#39;s think about explicit replacements. So far, I&#39;ve been able to think of three general approaches. For the examples below, I&#39;ll assume there&#39;s a `func concatenate(number: Int, to string: String) -&gt; String`, which does the obvious thing. Where supported, I will fully qualify names with SE-0021 syntax, but in some cases this might not be necessary.<br>&gt; <br>&gt; 		1. Special parameter label.<br>&gt; <br>&gt; `concatenate` is implicitly overloaded with a `func concatenate(parameters: (Int, String)) -&gt; String`.<br>&gt; <br>&gt; 	concatenate(parameters: tuple)<br>&gt; 	tuples.map(concatenate(parameters:))<br>&gt; <br>&gt; Advantages: <br>&gt; - Does not require any new call-side syntax.<br>&gt; - Googleable thanks to use of identifiers.<br>&gt; <br>&gt; Disadvantages:<br>&gt; - Could conflict with functions that use `parameters` as an argument label.<br>&gt; - Not clear how it would distinguish between `concatenate(_:to:)` and e.g. `concatenate(_:with:)`.<br>&gt; - Might reintroduce type checking complexity, since it&#39;s adding overloads.<br>&gt; - A bit wordy.<br>&gt; - As far as I know, not precedented in other languages.<br>&gt; <br>&gt; 		2. Method on functions.<br>&gt; <br>&gt; `concatenate` has a method on it called, say, `apply(to:)` which takes a tuple of parameters.<br>&gt; <br>&gt; 	concatenate(_:to:).apply(to: tuple)<br>&gt; 	tuples.map(concatenate(_:to:).apply(to:))<br>&gt; <br>&gt; Advantages:<br>&gt; - You can be sure of the variant you&#39;re selecting.<br>&gt; - Googleable thanks to use of identifiers.<br>&gt; - Similar to usage in Javascript.<br>&gt; <br>&gt; Disadvantages:<br>&gt; - Rather wordy, with lots of chaining and extra parentheses.<br>&gt; - Methods on unapplied functions might be a little confusing.<br>&gt; <br>&gt; 		3. Splat operator.<br>&gt; <br>&gt; An operator like `*` is used to indicate splatting. A tuple can be put to the right of the operator to splat it in immediately, or it can be omitted to select a splattable version of the function.<br>&gt; <br>&gt; 	concatenate(_:to: *tuple)<br>&gt; 	tuples.map(concatenate(_:to: *))<br>&gt; <br>&gt; Advantages:<br>&gt; - You can be sure of the variant you&#39;re selecting.<br>&gt; - Similar to usage in Ruby and Perl 6.<br>&gt; - Fairly short in all forms.<br>&gt; <br>&gt; Disadvantages:<br>&gt; - Not Googleable.<br>&gt; - New magic syntax.<br>&gt; - Two slightly different forms depending on whether you&#39;re calling or not.<br>&gt; <br>&gt; Any thoughts on these, or alternative approaches (as opposed to small syntax tweaks)?<br>&gt; <br>&gt; <br>&gt; <br>&gt; P.S. As for pointers potentially using prefix `*` for memory dereferencing, I would instead make them use postfix `!`. `!` could become an `unwrapped` pseudo-property that any type can use, democratizing another piece of `Optional` magic and working around the vexing problem of what you name the `Pointer` property for &quot;that thing you&#39;re actually pointing to&quot;.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Splat</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February 10, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; There was a discussion about using `…` as an _array splat_ operator, i.e:<br>&gt; <br>&gt;    func foo(xs: Int…)<br>&gt;    let xs = [1, 2, 3]<br>&gt;    foo(xs…)<br>&gt; <br>&gt; That would be symmetric with “…” defining a variable length argument, and also the same approach as Ruby, but instead of `*xs` which looks like memory dereferencing, `xs…`, which IMHO works better as a symbol for this.<br>&gt; <br>&gt; Perhaps it would be possible to overload this operator to perform _tuple splat_ as well. (I haven’t put it through tough thorough thought, though.)<br></p><p>When I was looking up how different languages handle splatting, I noticed that `...` is PHP&#39;s splat operator. But keep in mind that, even though some of them can be typed pretty tightly if you want, Ruby, Perl 6, and PHP all have much looser *attitudes* towards typing than Swift; their splat operators are used to unpack heterogenous arrays into argument lists, with overflowing elements either being dropped or going into a specially-marked array parameter.<br></p><p>Swift is a very different language; this feature is meant for strongly-typed tuples, and is basically orthogonal to unpacking an array into a variadic parameter. I think that giving the &quot;unpack tuple into multiple parameters&quot; and &quot;unpack array into a single variadic parameter&quot; operators the same name would be confusing, and given that variadic parameters are declared with `...`, that operator should be reserved for variadic unpacking.<br></p><p>(By the way, are we going to drop variadic tuples? With the demise of parameters-as-tuples, I&#39;m not sure there&#39;s much of a point in them anymore.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Splat</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>February 10, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Feb 10, 2016, at 2:50 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; There was a discussion about using `…` as an _array splat_ operator, i.e:<br>&gt;&gt; <br>&gt;&gt;   func foo(xs: Int…)<br>&gt;&gt;   let xs = [1, 2, 3]<br>&gt;&gt;   foo(xs…)<br>&gt;&gt; <br>&gt;&gt; That would be symmetric with “…” defining a variable length argument, and also the same approach as Ruby, but instead of `*xs` which looks like memory dereferencing, `xs…`, which IMHO works better as a symbol for this.<br>&gt;&gt; <br>&gt;&gt; Perhaps it would be possible to overload this operator to perform _tuple splat_ as well. (I haven’t put it through tough thorough thought, though.)<br>&gt; <br>&gt; When I was looking up how different languages handle splatting, I noticed that `...` is PHP&#39;s splat operator. But keep in mind that, even though some of them can be typed pretty tightly if you want, Ruby, Perl 6, and PHP all have much looser *attitudes* towards typing than Swift; their splat operators are used to unpack heterogenous arrays into argument lists, with overflowing elements either being dropped or going into a specially-marked array parameter.<br>&gt; <br>&gt; Swift is a very different language; this feature is meant for strongly-typed tuples, and is basically orthogonal to unpacking an array into a variadic parameter. I think that giving the &quot;unpack tuple into multiple parameters&quot; and &quot;unpack array into a single variadic parameter&quot; operators the same name would be confusing, and given that variadic parameters are declared with `...`, that operator should be reserved for variadic unpacking.<br></p><p>Using … for this makes sense.  Forwarding a varargs array using &quot;foo(varargarray…)” would be the seemingly most obvious way to unpack “varargsarray” as the varargs list.  Generalizing that to “foo(tuple…)” seems analogous and unambiguous.<br></p><p>&gt; (By the way, are we going to drop variadic tuples? With the demise of parameters-as-tuples, I&#39;m not sure there&#39;s much of a point in them anymore.)<br></p><p>I’m pretty sure that variadic tuples are already dead, is there some case still limping along?<br></p><p>-Chris<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc045f9bdc3bd1885767f2a2ba8af458?s=50"></div><header><strong>Splat</strong> from <string>Jonathan Tang</string> &lt;jonathan.d.tang at gmail.com&gt;<p>February 10, 2016 at 03:00:00pm</p></header><div class="content"><p>On Wed, Feb 10, 2016 at 1:21 PM, Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; So, since SE-0029 has been accepted, let&#39;s think about explicit<br>&gt; replacements. So far, I&#39;ve been able to think of three general approaches.<br>&gt; For the examples below, I&#39;ll assume there&#39;s a `func concatenate(number:<br>&gt; Int, to string: String) -&gt; String`, which does the obvious thing. Where<br>&gt; supported, I will fully qualify names with SE-0021 syntax, but in some<br>&gt; cases this might not be necessary.<br>&gt;<br>&gt;                 1. Special parameter label.<br>&gt;<br>&gt; `concatenate` is implicitly overloaded with a `func<br>&gt; concatenate(parameters: (Int, String)) -&gt; String`.<br>&gt;<br>&gt;         concatenate(parameters: tuple)<br>&gt;         tuples.map(concatenate(parameters:))<br>&gt;<br>&gt; Advantages:<br>&gt; - Does not require any new call-side syntax.<br>&gt; - Googleable thanks to use of identifiers.<br>&gt;<br>&gt; Disadvantages:<br>&gt; - Could conflict with functions that use `parameters` as an argument label.<br>&gt; - Not clear how it would distinguish between `concatenate(_:to:)` and e.g.<br>&gt; `concatenate(_:with:)`.<br>&gt; - Might reintroduce type checking complexity, since it&#39;s adding overloads.<br>&gt; - A bit wordy.<br>&gt; - As far as I know, not precedented in other languages.<br>&gt;<br>&gt;                 2. Method on functions.<br>&gt;<br>&gt; `concatenate` has a method on it called, say, `apply(to:)` which takes a<br>&gt; tuple of parameters.<br>&gt;<br>&gt;         concatenate(_:to:).apply(to: tuple)<br>&gt;         tuples.map(concatenate(_:to:).apply(to:))<br>&gt;<br>&gt; Advantages:<br>&gt; - You can be sure of the variant you&#39;re selecting.<br>&gt; - Googleable thanks to use of identifiers.<br>&gt; - Similar to usage in Javascript.<br>&gt;<br>&gt; Disadvantages:<br>&gt; - Rather wordy, with lots of chaining and extra parentheses.<br>&gt; - Methods on unapplied functions might be a little confusing.<br>&gt;<br>&gt;                 3. Splat operator.<br>&gt;<br>&gt; An operator like `*` is used to indicate splatting. A tuple can be put to<br>&gt; the right of the operator to splat it in immediately, or it can be omitted<br>&gt; to select a splattable version of the function.<br>&gt;<br>&gt;         concatenate(_:to: *tuple)<br>&gt;         tuples.map(concatenate(_:to: *))<br>&gt;<br>&gt; Advantages:<br>&gt; - You can be sure of the variant you&#39;re selecting.<br>&gt; - Similar to usage in Ruby and Perl 6.<br>&gt; - Fairly short in all forms.<br>&gt;<br>&gt; Disadvantages:<br>&gt; - Not Googleable.<br>&gt; - New magic syntax.<br>&gt; - Two slightly different forms depending on whether you&#39;re calling or not.<br>&gt;<br>&gt; Any thoughts on these, or alternative approaches (as opposed to small<br>&gt; syntax tweaks)?<br>&gt;<br>&gt;<br>&gt;<br>&gt; P.S. As for pointers potentially using prefix `*` for memory<br>&gt; dereferencing, I would instead make them use postfix `!`. `!` could become<br>&gt; an `unwrapped` pseudo-property that any type can use, democratizing another<br>&gt; piece of `Optional` magic and working around the vexing problem of what you<br>&gt; name the `Pointer` property for &quot;that thing you&#39;re actually pointing to&quot;.<br>&gt;<br>&gt;<br>I&#39;m curious what the type signature of the splat operator would be?  IIUC,<br>one of the primary reasons the Swift core team accepted SE-0029 (remove<br>implicit tuple splat) is because it adds a lot of complexity to the<br>typechecker.  That was my experience too, having implemented a hobby<br>language several years ago where every function took a single tuple<br>argument.  It made it very difficult to reason about the types in the<br>program, because a function type held no intrinsic type information, and<br>the only way to typecheck it was to know how the function was defined and<br>see whether that was compatible with how it was invoked.  That, in turn,<br>made first-class functions and separate module compilation very difficult:<br>you had to carry around full information about the arity of the tuple, each<br>of its types, whether the types were generic type variables, whether they<br>had typeclass (protocol in Swift) constraints, whether the typeclasses<br>themselves had associated types, etc.  And then when you try to *infer*<br>types, each of these become cases in the inference engine, and interacted<br>combinatorially.<br></p><p>I&#39;d start by trying to write down the type of the splat operator.  Can it<br>be expressed within the normal Swift type system?  I&#39;m not sure...I&#39;m not<br>familiar enough with the intricacies of Swift tuple types to know.<br></p><p>If it can&#39;t, I have a strong preference against the options (#1 &amp; #2) that<br>look like normal function call syntax.  Because you won&#39;t be able to do<br>several things that you&#39;re accustomed to with functions: assign them to<br>variables, store them in containers, pass them as parameters to other<br>functions.<br></p><p>This is less of a problem with explicit language syntax, because you could<br>have a rule in the typechecker that says &quot;If the expression being splatted<br>is a tuple of type (A, B, x: C), then it must be applied to a function of<br>type (A, B, C) -&gt; Ret, with the result type of the call being Ret.&quot;  I<br>think you can also get around many of the type inference pitfalls as well,<br>because in most cases the types of the function and tuple are unlikely to<br>need inferring (occasionally this will require explicit type annotations on<br>tuple components, but it seems like most of the time they will have already<br>been inferred when the tuple was declared).  And it&#39;s much easier to do<br>&quot;partial splat&quot; operations, where, for example, you may want to pass the<br>first couple arguments of a function explicitly but splat the rest.<br></p><p>Note that there&#39;s a loss of expressiveness through *not* making the splat<br>operator first-class; a number of interesting Haskell combinators come out<br>of using $ (the function-application operator) as a function that can<br>itself be passed around.  But it&#39;s also a question of how much complexity<br>you want to add to the language for the sake of conceptual purity.  Python,<br>Ruby, and Javascript all seem to get along fine with just the ability to<br>splat lists &amp; dictionaries into the final position of an argument list.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160210/be2930e3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Splat</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February 10, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; I&#39;m curious what the type signature of the splat operator would be?<br></p><p>None of the options I present actually involves a standalone operator; even 3 is a magic syntax which happens to look like an operator. That&#39;s why you can use the splat without specifying a tuple to get a tuple-taking version of the function.<br></p><p>I *did* consider adding a fourth option, that of annotating parameters as converting n-ary functions to tuple-taking equivalents, but I didn&#39;t feel like I had a good enough idea of how that would work to really suggest it. Roughly, an `apply(_:to:)` function would look something like this:<br></p><p>	func apply&lt;In, Out&gt;(function: @splatting In -&gt; Out, to params: In) -&gt; Out {<br>		// `function` is of type `In -&gt; Out`, where In is a tuple containing the types <br>		// of the parameters of the function that was passed. Essentially, the generic system<br>		// implicitly wraps the function in a trampoline that takes a tuple of compatible arguments.<br>		return function(params)<br>	}<br></p><p>But this starts getting deep into type checker and generic system territory, which I don&#39;t understand well enough to feel comfortable proposing.<br></p><p>&gt; If it can&#39;t, I have a strong preference against the options (#1 &amp; #2) that look like normal function call syntax.  Because you won&#39;t be able to do several things that you&#39;re accustomed to with functions: assign them to variables, store them in containers, pass them as parameters to other functions.<br></p><p>I think this feature has to be able to make a first-class, tuple-taking closure, and all three alternatives I presented are intended to do that. That&#39;s what the second example for each syntax (the one where I map it over an array of tuples) is meant to show.<br></p><p>&gt; This is less of a problem with explicit language syntax, because you could have a rule in the typechecker that says &quot;If the expression being splatted is a tuple of type (A, B, x: C), then it must be applied to a function of type (A, B, C) -&gt; Ret, with the result type of the call being Ret.&quot;  I think you can also get around many of the type inference pitfalls as well, because in most cases the types of the function and tuple are unlikely to need inferring (occasionally this will require explicit type annotations on tuple components, but it seems like most of the time they will have already been inferred when the tuple was declared).<br></p><p>As long as the splatting is explicit—that is, the parser can tell whether you&#39;re making a normal call or a tuple call—I don&#39;t think the overload resolution on a splatted version of a function is any more difficult than the non-splatted version. Possibly even easier, depending on how we handle default arguments.<br></p><p>&gt; And it&#39;s much easier to do &quot;partial splat&quot; operations, where, for example, you may want to pass the first couple arguments of a function explicitly but splat the rest.<br></p><p>I haven&#39;t really considered how to do this kind of thing, but I think it&#39;s probably better represented by constructing a single tuple containing all of the arguments. I believe there was another thread recently that discussed tuple combining operators.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>Splat</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>February 11, 2016 at 11:00:00am</p></header><div class="content"><p>I like the first option, concatenate(parameters:)<br></p><p>It may not have issues conflicting if &quot;parameters&quot; was renamed to something<br>which is an invalid label, this would also make it clearer that it&#39;s doing<br>something special. For example:<br>    concatenate(#parameters: tuple)<br></p><p>It may be that it can also distinguish different labels if the label is<br>stored as part of the type information. If I remember correctly there is a<br>bug which would allow this when fixed.<br></p><p>For example:<br>    concatenate(#parameters: (123, with: &quot;string&quot;))<br></p><p>I&#39;m fairly sure this should be sufficient, even in generics, the tuple just<br>needs to have the labels.<br></p><p>It may also be nice to allow unlabelled tuples if the function is<br>unambiguous.<br></p><p>The thread on tuples combining operators was probably this one:<br>Tuple conversion and type composition<br>http://comments.gmane.org/gmane.comp.lang.swift.evolution/5334<br></p><p>On Thursday, 11 February 2016, Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org<br>&lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br></p><p>&gt; &gt; I&#39;m curious what the type signature of the splat operator would be?<br>&gt;<br>&gt; None of the options I present actually involves a standalone operator;<br>&gt; even 3 is a magic syntax which happens to look like an operator. That&#39;s why<br>&gt; you can use the splat without specifying a tuple to get a tuple-taking<br>&gt; version of the function.<br>&gt;<br>&gt; I *did* consider adding a fourth option, that of annotating parameters as<br>&gt; converting n-ary functions to tuple-taking equivalents, but I didn&#39;t feel<br>&gt; like I had a good enough idea of how that would work to really suggest it.<br>&gt; Roughly, an `apply(_:to:)` function would look something like this:<br>&gt;<br>&gt;         func apply&lt;In, Out&gt;(function: @splatting In -&gt; Out, to params: In)<br>&gt; -&gt; Out {<br>&gt;                 // `function` is of type `In -&gt; Out`, where In is a tuple<br>&gt; containing the types<br>&gt;                 // of the parameters of the function that was passed.<br>&gt; Essentially, the generic system<br>&gt;                 // implicitly wraps the function in a trampoline that<br>&gt; takes a tuple of compatible arguments.<br>&gt;                 return function(params)<br>&gt;         }<br>&gt;<br>&gt; But this starts getting deep into type checker and generic system<br>&gt; territory, which I don&#39;t understand well enough to feel comfortable<br>&gt; proposing.<br>&gt;<br>&gt; &gt; If it can&#39;t, I have a strong preference against the options (#1 &amp; #2)<br>&gt; that look like normal function call syntax.  Because you won&#39;t be able to<br>&gt; do several things that you&#39;re accustomed to with functions: assign them to<br>&gt; variables, store them in containers, pass them as parameters to other<br>&gt; functions.<br>&gt;<br>&gt; I think this feature has to be able to make a first-class, tuple-taking<br>&gt; closure, and all three alternatives I presented are intended to do that.<br>&gt; That&#39;s what the second example for each syntax (the one where I map it over<br>&gt; an array of tuples) is meant to show.<br>&gt;<br>&gt; &gt; This is less of a problem with explicit language syntax, because you<br>&gt; could have a rule in the typechecker that says &quot;If the expression being<br>&gt; splatted is a tuple of type (A, B, x: C), then it must be applied to a<br>&gt; function of type (A, B, C) -&gt; Ret, with the result type of the call being<br>&gt; Ret.&quot;  I think you can also get around many of the type inference pitfalls<br>&gt; as well, because in most cases the types of the function and tuple are<br>&gt; unlikely to need inferring (occasionally this will require explicit type<br>&gt; annotations on tuple components, but it seems like most of the time they<br>&gt; will have already been inferred when the tuple was declared).<br>&gt;<br>&gt; As long as the splatting is explicit—that is, the parser can tell whether<br>&gt; you&#39;re making a normal call or a tuple call—I don&#39;t think the overload<br>&gt; resolution on a splatted version of a function is any more difficult than<br>&gt; the non-splatted version. Possibly even easier, depending on how we handle<br>&gt; default arguments.<br>&gt;<br>&gt; &gt; And it&#39;s much easier to do &quot;partial splat&quot; operations, where, for<br>&gt; example, you may want to pass the first couple arguments of a function<br>&gt; explicitly but splat the rest.<br>&gt;<br>&gt; I haven&#39;t really considered how to do this kind of thing, but I think it&#39;s<br>&gt; probably better represented by constructing a single tuple containing all<br>&gt; of the arguments. I believe there was another thread recently that<br>&gt; discussed tuple combining operators.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/619d95de/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Splat</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February 10, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; I&#39;m fairly sure this should be sufficient, even in generics, the tuple just needs to have the labels.<br></p><p>I&#39;ve noticed a trend in comments from the core team towards thinking of argument labels as part of the function&#39;s name, not its type, so I was assuming that these tuple types would *not* have element labels.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc045f9bdc3bd1885767f2a2ba8af458?s=50"></div><header><strong>Splat</strong> from <string>Jonathan Tang</string> &lt;jonathan.d.tang at gmail.com&gt;<p>February 10, 2016 at 08:00:00pm</p></header><div class="content"><p>On Wed, Feb 10, 2016 at 5:41 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>wrote:<br></p><p>&gt; &gt; I&#39;m curious what the type signature of the splat operator would be?<br>&gt;<br>&gt; None of the options I present actually involves a standalone operator;<br>&gt; even 3 is a magic syntax which happens to look like an operator. That&#39;s why<br>&gt; you can use the splat without specifying a tuple to get a tuple-taking<br>&gt; version of the function.<br>&gt;<br>&gt;<br>Ah, I see, at least for #1.  I&#39;m assuming that to get the function that<br>takes a tuple, you&#39;d have to explicitly use the parameters: overload:<br></p><p>let f = concatenate   // Gives you concatenate(_, to:), type signature<br>(Int, to: String) -&gt; String<br>f(1, to: &quot;foo&quot;)  // Legal<br>f(2, &quot;foo&quot;)  // Legal, argument labels may be omitted<br>f(3, from: &quot;foo&quot;)  // Illegal, argument labels don&#39;t line up<br></p><p>let g = concatenate(parameters:) // Gives you concatenate(parameters), type<br>signature (Int, String) -&gt; String<br>g(1, to: &quot;foo&quot;) // Legal, tuple label ignored<br>g(2, &quot;foo&quot;)  // Legal<br>g(3, bar: &quot;foo&quot;)  // Legal, tuple label ignored<br></p><p>For #2, I&#39;m asking what the type is of .apply(to:)?<br></p><p>let f = concatenate(_:to:).apply(to:)  // I assume this has type (Int,<br>String) -&gt; String<br>var f = concatenate<br>var g = f.apply(to:)  // Is this legal?  What&#39;s the type?<br></p><p>class Promise&lt;ResultTuple&gt; {<br>  init(resolve: ResultTuple -&gt; Void) {<br>    self.resolve = resolve<br>  }<br></p><p>  func onPromiseComplete(result: ResultTuple) {<br>    resolve.apply(to: result)  // Is this legal?<br>  }<br></p><p>  let resolve: ResultTuple -&gt; Void<br>}<br></p><p>let p1 = Promise(resolve: concatenate)  // Presumably this is a<br>Promise&lt;(Int, String)&gt;<br>let p2 = Promise(resolve: f)  // What&#39;s the type of this?  Compiler smart<br>enough to figure out it&#39;s Promise&lt;(Int, String)&gt;?<br>let p3 = Promise(resolve: g)  // How about this?<br>let p4 = Promise(resolve: Promise(resolve:))   // For extra recursion...<br></p><p>// This type signature is wrong, g takes an arbitrary argument list...but<br>how do I write that?<br>func compose&lt;Params, Intermediate, Result&gt;(f: Intermediate -&gt; Result , g:<br>Params -&gt; Intermediate) -&gt; Result {<br>  return { args in f.apply(to: g.apply(to: args)) }<br>}<br></p><p>// Here&#39;s a function that takes an Array of functions and applies them one<br>after another...<br>// I don&#39;t really know where to start with this...the types of all of its<br>arguments seem inexpressible<br>func composeMany&lt;/* ...arbitrary many intermediate params... */&gt;(functions:<br>[/* What type for arbitrary function? */]) {<br>  reduce(compose, functions, identity)<br>}<br></p><p>A lot of this is going overboard with functional programming and is<br>probably outside the scope of what Swift&#39;s designers want it to<br>accomplish.  My point isn&#39;t to turn Swift into Haskell, it&#39;s to point out<br>some of the potential edge cases when interacting with other language<br>features.   Many of those edge cases can be avoided by saying &quot;This is a<br>simple syntactic feature, it *looks* like this but all it does is construct<br>a closure that&#39;s syntactic sugar for applying this function to each of the<br>components of its tuple-based argument.&quot;  But then if it looks like a<br>method, people are going to wonder why they can&#39;t pass it to a function or<br>store it in a data-structure.<br></p><p>I *did* consider adding a fourth option, that of annotating parameters as<br>&gt; converting n-ary functions to tuple-taking equivalents, but I didn&#39;t feel<br>&gt; like I had a good enough idea of how that would work to really suggest it.<br>&gt; Roughly, an `apply(_:to:)` function would look something like this:<br>&gt;<br>&gt;         func apply&lt;In, Out&gt;(function: @splatting In -&gt; Out, to params: In)<br>&gt; -&gt; Out {<br>&gt;                 // `function` is of type `In -&gt; Out`, where In is a tuple<br>&gt; containing the types<br>&gt;                 // of the parameters of the function that was passed.<br>&gt; Essentially, the generic system<br>&gt;                 // implicitly wraps the function in a trampoline that<br>&gt; takes a tuple of compatible arguments.<br>&gt;                 return function(params)<br>&gt;         }<br>&gt;<br>&gt; But this starts getting deep into type checker and generic system<br>&gt; territory, which I don&#39;t understand well enough to feel comfortable<br>&gt; proposing.<br>&gt;<br>&gt; &gt; If it can&#39;t, I have a strong preference against the options (#1 &amp; #2)<br>&gt; that look like normal function call syntax.  Because you won&#39;t be able to<br>&gt; do several things that you&#39;re accustomed to with functions: assign them to<br>&gt; variables, store them in containers, pass them as parameters to other<br>&gt; functions.<br>&gt;<br>&gt; I think this feature has to be able to make a first-class, tuple-taking<br>&gt; closure, and all three alternatives I presented are intended to do that.<br>&gt; That&#39;s what the second example for each syntax (the one where I map it over<br>&gt; an array of tuples) is meant to show.<br>&gt;<br>&gt; This is less of a problem with explicit language syntax, because you<br>&gt; could have a rule in the typechecker that says &quot;If the expression being<br>&gt; splatted is a tuple of type (A, B, x: C), then it must be applied to a<br>&gt; function of type (A, B, C) -&gt; Ret, with the result type of the call being<br>&gt; Ret.&quot;  I think you can also get around many of the type inference pitfalls<br>&gt; as well, because in most cases the types of the function and tuple are<br>&gt; unlikely to need inferring (occasionally this will require explicit type<br>&gt; annotations on tuple components, but it seems like most of the time they<br>&gt; will have already been inferred when the tuple was declared).<br>&gt;<br>&gt; As long as the splatting is explicit—that is, the parser can tell whether<br>&gt; you&#39;re making a normal call or a tuple call—I don&#39;t think the overload<br>&gt; resolution on a splatted version of a function is any more difficult than<br>&gt; the non-splatted version. Possibly even easier, depending on how we handle<br>&gt; default arguments.<br>&gt;<br>&gt; &gt; And it&#39;s much easier to do &quot;partial splat&quot; operations, where, for<br>&gt; example, you may want to pass the first couple arguments of a function<br>&gt; explicitly but splat the rest.<br>&gt;<br>&gt; I haven&#39;t really considered how to do this kind of thing, but I think it&#39;s<br>&gt; probably better represented by constructing a single tuple containing all<br>&gt; of the arguments. I believe there was another thread recently that<br>&gt; discussed tuple combining operators.<br>&gt;<br>&gt;<br>I saw that, briefly.  I hope that something like that makes it in, but it<br>has similar issues with &quot;What&#39;s the type signature of this operator, and if<br>the only way it can exist is as compiler-supported syntax, how do we make<br>it clear to users that this is a compiler language feature and not a<br>first-class function call?&quot;  IIRC the syntax suggested there made use of<br>the #thisIsACompilerDirective naming convention.  I wonder if that might be<br>appropriate here:<br></p><p>f(#splat(tuple))<br>concatenate(_: #splat)<br></p><p>The latter form also suggests a way this could be used for partial<br>application:<br></p><p>concatenate(2, #splat) returns a closure where the first argument is always<br>2, but any remaining arguments are pulled from the provided tuple.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160210/3e7eb08d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Splat</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February 10, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; Ah, I see, at least for #1.  I&#39;m assuming that to get the function that takes a tuple, you&#39;d have to explicitly use the parameters: overload:<br></p><p>Probably; otherwise this doesn&#39;t actually save the type checker much.<br></p><p>There&#39;s a bit of a complication when talking about type signatures. Currently, the fact that a function operates on a tuple is embedded in our type syntax, and the parentheses around the argument list are optional and represent a tuple—`(Int, String) -&gt; String` is equivalent to `TupleOfIntAndString -&gt; String`. This might now need a change, or at least a clarification. For the purposes of this post, I&#39;ll say that `(Int, String) -&gt; String` is the type of a function taking an Int and String, while `((Int, String)) -&gt; String` is the type of a function taking a tuple.<br></p><p>For the `concatenate(_:to:)` example, the original function has a signature of `(Int, String) -&gt; String` (once argument labels are fully part of the name, which seems to be the trend). For each of the syntaxes I proposed, the type of this expression is `((Int, String)) -&gt; String`:<br></p><p>	concatenate(parameters:)<br>	concatenate(_:to:).apply(to:)<br>	concatenate(_:to: *)<br></p><p>&gt; let f = concatenate(_:to:).apply(to:)  // I assume this has type (Int, String) -&gt; String<br>&gt; var g = f.apply(to:)  // Is this legal?  What&#39;s the type?<br></p><p>That&#39;s an interesting question. Swift does not have 1-tuples, so unary functions might not have an `apply(to:)` method.<br></p><p>&gt; // This type signature is wrong, g takes an arbitrary argument list...but how do I write that?<br>&gt; func compose&lt;Params, Intermediate, Result&gt;(f: Intermediate -&gt; Result , g: Params -&gt; Intermediate) -&gt; Result {<br>&gt;   return { args in f.apply(to: g.apply(to: args)) }<br>&gt; }<br></p><p>Without something along the lines of the `@splatting` annotation in a parameter list, it would not be possible to write a `compose(_:_:)` function which could operate on non-unary functions directly. Instead of writing `compose(f, g)`, you&#39;d have to write `compose(f.apply, g.apply)`.<br></p><p>If you think that&#39;s kind of ugly, I don&#39;t disagree.<br></p><p>&gt; // Here&#39;s a function that takes an Array of functions and applies them one after another...<br>&gt; // I don&#39;t really know where to start with this...the types of all of its arguments seem inexpressible<br>&gt; func composeMany&lt;/* ...arbitrary many intermediate params... */&gt;(functions: [/* What type for arbitrary function? */]) {<br>&gt;   reduce(compose, functions, identity)<br>&gt; }<br></p><p>Even with the current implicit splatting, this is impossible to express unless all functions have the same argument and return type. The generics system is simply not equipped to handle arbitrarily many generic types.<br></p><p>&gt; But then if it looks like a method, people are going to wonder why they can&#39;t pass it to a function or store it in a data-structure.<br></p><p>I&#39;m not sure why you think it can&#39;t be stored. I think it can.<br></p><p>&gt; I saw that, briefly.  I hope that something like that makes it in, but it has similar issues with &quot;What&#39;s the type signature of this operator, and if the only way it can exist is as compiler-supported syntax, how do we make it clear to users that this is a compiler language feature and not a first-class function call?&quot;  IIRC the syntax suggested there made use of the #thisIsACompilerDirective naming convention.  I wonder if that might be appropriate here:<br>&gt; <br>&gt; f(#splat(tuple))<br>&gt; concatenate(_: #splat)<br>&gt; <br>&gt; The latter form also suggests a way this could be used for partial application:<br>&gt; <br>&gt; concatenate(2, #splat) returns a closure where the first argument is always 2, but any remaining arguments are pulled from the provided tuple.<br></p><p>I don&#39;t really think # is a good fit here. I think it&#39;s best used in places where it&#39;s performing a relatively straightforward textual substitution; in the `concatenate(_: #splat)` case, that&#39;s not really what&#39;s being done here.<br></p><p>(To tell the truth, in my head I imagine that when we finally get a macro system in Swift N, all macros are marked by a leading #. So I tend to get a little squeamish about # uses which draw heavily from context instead of relying on what you &quot;pass&quot; to them.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc045f9bdc3bd1885767f2a2ba8af458?s=50"></div><header><strong>Splat</strong> from <string>Jonathan Tang</string> &lt;jonathan.d.tang at gmail.com&gt;<p>February 10, 2016 at 09:00:00pm</p></header><div class="content"><p>On Wed, Feb 10, 2016 at 8:37 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>wrote:<br></p><p>&gt; &gt; Ah, I see, at least for #1.  I&#39;m assuming that to get the function that<br>&gt; takes a tuple, you&#39;d have to explicitly use the parameters: overload:<br>&gt;<br>&gt; Probably; otherwise this doesn&#39;t actually save the type checker much.<br>&gt;<br>&gt; There&#39;s a bit of a complication when talking about type signatures.<br>&gt; Currently, the fact that a function operates on a tuple is embedded in our<br>&gt; type syntax, and the parentheses around the argument list are optional and<br>&gt; represent a tuple—`(Int, String) -&gt; String` is equivalent to<br>&gt; `TupleOfIntAndString -&gt; String`. This might now need a change, or at least<br>&gt; a clarification. For the purposes of this post, I&#39;ll say that `(Int,<br>&gt; String) -&gt; String` is the type of a function taking an Int and String,<br>&gt; while `((Int, String)) -&gt; String` is the type of a function taking a tuple.<br>&gt;<br>&gt; For the `concatenate(_:to:)` example, the original function has a<br>&gt; signature of `(Int, String) -&gt; String` (once argument labels are fully part<br>&gt; of the name, which seems to be the trend). For each of the syntaxes I<br>&gt; proposed, the type of this expression is `((Int, String)) -&gt; String`:<br>&gt;<br>&gt;         concatenate(parameters:)<br>&gt;         concatenate(_:to:).apply(to:)<br>&gt;         concatenate(_:to: *)<br>&gt;<br>&gt; &gt; let f = concatenate(_:to:).apply(to:)  // I assume this has type (Int,<br>&gt; String) -&gt; String<br>&gt; &gt; var g = f.apply(to:)  // Is this legal?  What&#39;s the type?<br>&gt;<br>&gt; That&#39;s an interesting question. Swift does not have 1-tuples, so unary<br>&gt; functions might not have an `apply(to:)` method.<br>&gt;<br>&gt; &gt; // This type signature is wrong, g takes an arbitrary argument<br>&gt; list...but how do I write that?<br>&gt; &gt; func compose&lt;Params, Intermediate, Result&gt;(f: Intermediate -&gt; Result ,<br>&gt; g: Params -&gt; Intermediate) -&gt; Result {<br>&gt; &gt;   return { args in f.apply(to: g.apply(to: args)) }<br>&gt; &gt; }<br>&gt;<br>&gt; Without something along the lines of the `@splatting` annotation in a<br>&gt; parameter list, it would not be possible to write a `compose(_:_:)`<br>&gt; function which could operate on non-unary functions directly. Instead of<br>&gt; writing `compose(f, g)`, you&#39;d have to write `compose(f.apply, g.apply)`.<br>&gt;<br>&gt; If you think that&#39;s kind of ugly, I don&#39;t disagree.<br>&gt;<br>&gt; &gt; // Here&#39;s a function that takes an Array of functions and applies them<br>&gt; one after another...<br>&gt; &gt; // I don&#39;t really know where to start with this...the types of all of<br>&gt; its arguments seem inexpressible<br>&gt; &gt; func composeMany&lt;/* ...arbitrary many intermediate params...<br>&gt; */&gt;(functions: [/* What type for arbitrary function? */]) {<br>&gt; &gt;   reduce(compose, functions, identity)<br>&gt; &gt; }<br>&gt;<br>&gt; Even with the current implicit splatting, this is impossible to express<br>&gt; unless all functions have the same argument and return type. The generics<br>&gt; system is simply not equipped to handle arbitrarily many generic types.<br>&gt;<br>&gt; &gt; But then if it looks like a method, people are going to wonder why they<br>&gt; can&#39;t pass it to a function or store it in a data-structure.<br>&gt;<br>&gt; I&#39;m not sure why you think it can&#39;t be stored. I think it can.<br>&gt;<br>&gt;<br>Not the result of the splatting operation, but the splatting operation<br>itself:<br></p><p>let legal = [f, g)<br>let illegal = [f.apply, g.apply]   // But it certainly looks like an<br>expression that would normally be legal!<br></p><p><br>&gt; &gt; I saw that, briefly.  I hope that something like that makes it in, but<br>&gt; it has similar issues with &quot;What&#39;s the type signature of this operator, and<br>&gt; if the only way it can exist is as compiler-supported syntax, how do we<br>&gt; make it clear to users that this is a compiler language feature and not a<br>&gt; first-class function call?&quot;  IIRC the syntax suggested there made use of<br>&gt; the #thisIsACompilerDirective naming convention.  I wonder if that might be<br>&gt; appropriate here:<br>&gt; &gt;<br>&gt; &gt; f(#splat(tuple))<br>&gt; &gt; concatenate(_: #splat)<br>&gt; &gt;<br>&gt; &gt; The latter form also suggests a way this could be used for partial<br>&gt; application:<br>&gt; &gt;<br>&gt; &gt; concatenate(2, #splat) returns a closure where the first argument is<br>&gt; always 2, but any remaining arguments are pulled from the provided tuple.<br>&gt;<br>&gt; I don&#39;t really think # is a good fit here. I think it&#39;s best used in<br>&gt; places where it&#39;s performing a relatively straightforward textual<br>&gt; substitution; in the `concatenate(_: #splat)` case, that&#39;s not really<br>&gt; what&#39;s being done here.<br>&gt;<br>&gt; (To tell the truth, in my head I imagine that when we finally get a macro<br>&gt; system in Swift N, all macros are marked by a leading #. So I tend to get a<br>&gt; little squeamish about # uses which draw heavily from context instead of<br>&gt; relying on what you &quot;pass&quot; to them.)<br>&gt;<br>&gt;<br>&gt;<br>The &quot;...&quot; syntax that&#39;s been batted around here looks fine to me as well.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160210/953cdd6c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc045f9bdc3bd1885767f2a2ba8af458?s=50"></div><header><strong>Splat</strong> from <string>Jonathan Tang</string> &lt;jonathan.d.tang at gmail.com&gt;<p>February 10, 2016 at 09:00:00pm</p></header><div class="content"><p>On Wed, Feb 10, 2016 at 9:10 PM, Jonathan Tang &lt;jonathan.d.tang at gmail.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt;<br>&gt; On Wed, Feb 10, 2016 at 8:37 PM, Brent Royal-Gordon &lt;<br>&gt; brent at architechies.com&gt; wrote:<br>&gt;<br>&gt;&gt; &gt; Ah, I see, at least for #1.  I&#39;m assuming that to get the function that<br>&gt;&gt; takes a tuple, you&#39;d have to explicitly use the parameters: overload:<br>&gt;&gt;<br>&gt;&gt; Probably; otherwise this doesn&#39;t actually save the type checker much.<br>&gt;&gt;<br>&gt;&gt; There&#39;s a bit of a complication when talking about type signatures.<br>&gt;&gt; Currently, the fact that a function operates on a tuple is embedded in our<br>&gt;&gt; type syntax, and the parentheses around the argument list are optional and<br>&gt;&gt; represent a tuple—`(Int, String) -&gt; String` is equivalent to<br>&gt;&gt; `TupleOfIntAndString -&gt; String`. This might now need a change, or at least<br>&gt;&gt; a clarification. For the purposes of this post, I&#39;ll say that `(Int,<br>&gt;&gt; String) -&gt; String` is the type of a function taking an Int and String,<br>&gt;&gt; while `((Int, String)) -&gt; String` is the type of a function taking a tuple.<br>&gt;&gt;<br>&gt;&gt; For the `concatenate(_:to:)` example, the original function has a<br>&gt;&gt; signature of `(Int, String) -&gt; String` (once argument labels are fully part<br>&gt;&gt; of the name, which seems to be the trend). For each of the syntaxes I<br>&gt;&gt; proposed, the type of this expression is `((Int, String)) -&gt; String`:<br>&gt;&gt;<br>&gt;&gt;         concatenate(parameters:)<br>&gt;&gt;         concatenate(_:to:).apply(to:)<br>&gt;&gt;         concatenate(_:to: *)<br>&gt;&gt;<br>&gt;&gt; &gt; let f = concatenate(_:to:).apply(to:)  // I assume this has type (Int,<br>&gt;&gt; String) -&gt; String<br>&gt;&gt; &gt; var g = f.apply(to:)  // Is this legal?  What&#39;s the type?<br>&gt;&gt;<br>&gt;&gt; That&#39;s an interesting question. Swift does not have 1-tuples, so unary<br>&gt;&gt; functions might not have an `apply(to:)` method.<br>&gt;&gt;<br>&gt;&gt; &gt; // This type signature is wrong, g takes an arbitrary argument<br>&gt;&gt; list...but how do I write that?<br>&gt;&gt; &gt; func compose&lt;Params, Intermediate, Result&gt;(f: Intermediate -&gt; Result ,<br>&gt;&gt; g: Params -&gt; Intermediate) -&gt; Result {<br>&gt;&gt; &gt;   return { args in f.apply(to: g.apply(to: args)) }<br>&gt;&gt; &gt; }<br>&gt;&gt;<br>&gt;&gt; Without something along the lines of the `@splatting` annotation in a<br>&gt;&gt; parameter list, it would not be possible to write a `compose(_:_:)`<br>&gt;&gt; function which could operate on non-unary functions directly. Instead of<br>&gt;&gt; writing `compose(f, g)`, you&#39;d have to write `compose(f.apply, g.apply)`.<br>&gt;&gt;<br>&gt;&gt; If you think that&#39;s kind of ugly, I don&#39;t disagree.<br>&gt;&gt;<br>&gt;&gt; &gt; // Here&#39;s a function that takes an Array of functions and applies them<br>&gt;&gt; one after another...<br>&gt;&gt; &gt; // I don&#39;t really know where to start with this...the types of all of<br>&gt;&gt; its arguments seem inexpressible<br>&gt;&gt; &gt; func composeMany&lt;/* ...arbitrary many intermediate params...<br>&gt;&gt; */&gt;(functions: [/* What type for arbitrary function? */]) {<br>&gt;&gt; &gt;   reduce(compose, functions, identity)<br>&gt;&gt; &gt; }<br>&gt;&gt;<br>&gt;&gt; Even with the current implicit splatting, this is impossible to express<br>&gt;&gt; unless all functions have the same argument and return type. The generics<br>&gt;&gt; system is simply not equipped to handle arbitrarily many generic types.<br>&gt;&gt;<br>&gt;&gt; &gt; But then if it looks like a method, people are going to wonder why they<br>&gt;&gt; can&#39;t pass it to a function or store it in a data-structure.<br>&gt;&gt;<br>&gt;&gt; I&#39;m not sure why you think it can&#39;t be stored. I think it can.<br>&gt;&gt;<br>&gt;&gt;<br>&gt; Not the result of the splatting operation, but the splatting operation<br>&gt; itself:<br>&gt;<br>&gt; let legal = [f, g)<br>&gt; let illegal = [f.apply, g.apply]   // But it certainly looks like an<br>&gt; expression that would normally be legal!<br>&gt;<br>&gt;<br></p><p>Actually nevermind, I see that a list of [f.apply, g.apply] would be legal<br>(modulo the to: keyword) and has the expected semantics, assuming that the<br>types match up.<br></p><p>Still find it quite confusing, because I expected x.methodName to be a<br>bound method and here it&#39;s a special syntactic form.  What happens if a<br>protocol defines &quot;func apply(to:)&quot;?  Is that legal?  Would function types<br>automatically conform to the protocol?<br></p><p><br>&gt; &gt; I saw that, briefly.  I hope that something like that makes it in, but<br>&gt;&gt; it has similar issues with &quot;What&#39;s the type signature of this operator, and<br>&gt;&gt; if the only way it can exist is as compiler-supported syntax, how do we<br>&gt;&gt; make it clear to users that this is a compiler language feature and not a<br>&gt;&gt; first-class function call?&quot;  IIRC the syntax suggested there made use of<br>&gt;&gt; the #thisIsACompilerDirective naming convention.  I wonder if that might be<br>&gt;&gt; appropriate here:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; f(#splat(tuple))<br>&gt;&gt; &gt; concatenate(_: #splat)<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The latter form also suggests a way this could be used for partial<br>&gt;&gt; application:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; concatenate(2, #splat) returns a closure where the first argument is<br>&gt;&gt; always 2, but any remaining arguments are pulled from the provided tuple.<br>&gt;&gt;<br>&gt;&gt; I don&#39;t really think # is a good fit here. I think it&#39;s best used in<br>&gt;&gt; places where it&#39;s performing a relatively straightforward textual<br>&gt;&gt; substitution; in the `concatenate(_: #splat)` case, that&#39;s not really<br>&gt;&gt; what&#39;s being done here.<br>&gt;&gt;<br>&gt;&gt; (To tell the truth, in my head I imagine that when we finally get a macro<br>&gt;&gt; system in Swift N, all macros are marked by a leading #. So I tend to get a<br>&gt;&gt; little squeamish about # uses which draw heavily from context instead of<br>&gt;&gt; relying on what you &quot;pass&quot; to them.)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt; The &quot;...&quot; syntax that&#39;s been batted around here looks fine to me as well.<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160210/f6142847/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Splat</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February 10, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; Still find it quite confusing, because I expected x.methodName to be a bound method and here it&#39;s a special syntactic form.  What happens if a protocol defines &quot;func apply(to:)&quot;?  Is that legal?  Would function types automatically conform to the protocol?<br></p><p>For `apply(to:)`, it really would just be a method available on function types. You could put an `apply(to:)` method on any other type, and it wouldn&#39;t have any effect on things. You could declare a protocol with `apply(to:)`, but it wouldn&#39;t do anything to any function types. Conceptually, there would only be a few special things about them:<br></p><p>1. The compiler generates the `apply(to:)` methods automatically. We could, perhaps, have it generate a conformance to an `Applicable` protocol like this one, but that&#39;s probably overkill:<br></p><p>	protocol Applicable {<br>		typealias ReturnValue<br>		typealias ArgumentTuple<br>		func apply(to: ArgumentTuple) -&gt; ReturnValue<br>	}<br></p><p>(Actually, as I think about this, I wonder if `Applicable` could give us the `@splatting` property for free: take a generic parameter on Applicable and someone can specify a bare function, but you can&#39;t call it directly, only through its `apply(to:)` method.)<br></p><p>2. If `fn` is overloaded, `fn.apply(x)` will end up selecting an `fn` overload based on the type of `x`. Concrete example: `(+).apply(tupleOfInts)` would give you the `Int, Int` implementation of the `+` operator.<br></p><p>3. There&#39;s no way to add your own methods to a function type. (At least, I&#39;m not proposing there would be. There&#39;s no particular reason we couldn&#39;t have other methods on functions, particularly if there&#39;s an `Applicable` protocol to extend.)<br></p><p>But `apply` is not a keyword, `apply(to:)` does not receive any special parsing, and you can still splatter `apply`s all around your code with no consequences whatsoever. Honestly, that&#39;s the main virtue of the `apply(to:)` suggestion: that there&#39;s really very little to it.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Splat</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>February 11, 2016 at 09:00:00am</p></header><div class="content"><p>I really like the apply-variant, especially as it moves functions one step into being first class, i.e. allowing them to have methods. Furthermore I like that it does not need new syntax.<br>The Applicable protocol is a good idea.<br></p><p>-Thorsten <br></p><p><br>Am 11.02.2016 um 08:54 schrieb Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt;:<br></p><p>&gt;&gt; Still find it quite confusing, because I expected x.methodName to be a bound method and here it&#39;s a special syntactic form.  What happens if a protocol defines &quot;func apply(to:)&quot;?  Is that legal?  Would function types automatically conform to the protocol?<br>&gt; <br>&gt; For `apply(to:)`, it really would just be a method available on function types. You could put an `apply(to:)` method on any other type, and it wouldn&#39;t have any effect on things. You could declare a protocol with `apply(to:)`, but it wouldn&#39;t do anything to any function types. Conceptually, there would only be a few special things about them:<br>&gt; <br>&gt; 1. The compiler generates the `apply(to:)` methods automatically. We could, perhaps, have it generate a conformance to an `Applicable` protocol like this one, but that&#39;s probably overkill:<br>&gt; <br>&gt;    protocol Applicable {<br>&gt;        typealias ReturnValue<br>&gt;        typealias ArgumentTuple<br>&gt;        func apply(to: ArgumentTuple) -&gt; ReturnValue<br>&gt;    }<br>&gt; <br>&gt; (Actually, as I think about this, I wonder if `Applicable` could give us the `@splatting` property for free: take a generic parameter on Applicable and someone can specify a bare function, but you can&#39;t call it directly, only through its `apply(to:)` method.)<br>&gt; <br>&gt; 2. If `fn` is overloaded, `fn.apply(x)` will end up selecting an `fn` overload based on the type of `x`. Concrete example: `(+).apply(tupleOfInts)` would give you the `Int, Int` implementation of the `+` operator.<br>&gt; <br>&gt; 3. There&#39;s no way to add your own methods to a function type. (At least, I&#39;m not proposing there would be. There&#39;s no particular reason we couldn&#39;t have other methods on functions, particularly if there&#39;s an `Applicable` protocol to extend.)<br>&gt; <br>&gt; But `apply` is not a keyword, `apply(to:)` does not receive any special parsing, and you can still splatter `apply`s all around your code with no consequences whatsoever. Honestly, that&#39;s the main virtue of the `apply(to:)` suggestion: that there&#39;s really very little to it.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9ae1f2ed10d2ef77cce06bbb5a2dcf7e?s=50"></div><header><strong>Splat</strong> from <string>Alex Hoppen</string> &lt;alex at ateamer.de&gt;<p>February 11, 2016 at 03:00:00pm</p></header><div class="content"><p>I really like your suggestion of functions conforming to a protocol. I thought about this a little while and how an extendable FunctionType (or Applicable as you called it) protocol may impact existing code. For that I would even go one step further and add another step of protocol indirection such that the function’s signature is just a specialised form of a protocol SignatureType (this allows even better syntax when extending FunctionType as you can see in my last example).<br></p><p>So this protocol would look like<br></p><p>protocol FunctionSignatureType {<br>  associatedtype Parameters<br>  associatedtype ReturnType<br>}<br></p><p>Parameters will be set to the functions parameters in tuple notation<br></p><p>(((Int, String), secondParameter: Int) -&gt; String).Input == ((Int, String), secondParameter: Int)<br></p><p>FunctionType would then only have one associated type:<br></p><p>protocol FunctionType {<br>  associatedtype Signature: FunctionSignatureType<br>}<br></p><p>Signature could for example be ((Int, String), secondParameter: Int) -&gt; String.<br></p><p>We could then declare the apply function as a simple extension to FunctionType just like you suggested<br></p><p>extension FunctionType {<br>  func apply(tuple: Signature.Parameters) -&gt; Signature.ReturnType {<br>    // Add some compiler magic here<br>  }<br>}<br></p><p>This would make apply another normal Swift function with a special implementation just like print, + and so on. I think that providing the ability to extend FunctionTypes would be a huge win, because several functions that used to be global could now just be methods on FunctionType. For example to execute a function asynchronously via GCD could now be declared as:<br></p><p>extension FunctionType where Signature == (() -&gt; Void) {<br>  func dispatchAsync(queue: dispatch_queue_t) {<br>    dispatch_async(queue, self)<br>  }<br>}<br></p><p>I don’t know how this fits into the compiler and if functions can be made to conform to a protocol anyway but from the outside this looks like a solution to me that fits very well in the current style of Swift.<br></p><p>- Alex<br></p><p><br>&gt; On 11 Feb 2016, at 08:54, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Still find it quite confusing, because I expected x.methodName to be a bound method and here it&#39;s a special syntactic form.  What happens if a protocol defines &quot;func apply(to:)&quot;?  Is that legal?  Would function types automatically conform to the protocol?<br>&gt; <br>&gt; For `apply(to:)`, it really would just be a method available on function types. You could put an `apply(to:)` method on any other type, and it wouldn&#39;t have any effect on things. You could declare a protocol with `apply(to:)`, but it wouldn&#39;t do anything to any function types. Conceptually, there would only be a few special things about them:<br>&gt; <br>&gt; 1. The compiler generates the `apply(to:)` methods automatically. We could, perhaps, have it generate a conformance to an `Applicable` protocol like this one, but that&#39;s probably overkill:<br>&gt; <br>&gt; 	protocol Applicable {<br>&gt; 		typealias ReturnValue<br>&gt; 		typealias ArgumentTuple<br>&gt; 		func apply(to: ArgumentTuple) -&gt; ReturnValue<br>&gt; 	}<br>&gt; <br>&gt; (Actually, as I think about this, I wonder if `Applicable` could give us the `@splatting` property for free: take a generic parameter on Applicable and someone can specify a bare function, but you can&#39;t call it directly, only through its `apply(to:)` method.)<br>&gt; <br>&gt; 2. If `fn` is overloaded, `fn.apply(x)` will end up selecting an `fn` overload based on the type of `x`. Concrete example: `(+).apply(tupleOfInts)` would give you the `Int, Int` implementation of the `+` operator.<br>&gt; <br>&gt; 3. There&#39;s no way to add your own methods to a function type. (At least, I&#39;m not proposing there would be. There&#39;s no particular reason we couldn&#39;t have other methods on functions, particularly if there&#39;s an `Applicable` protocol to extend.)<br>&gt; <br>&gt; But `apply` is not a keyword, `apply(to:)` does not receive any special parsing, and you can still splatter `apply`s all around your code with no consequences whatsoever. Honestly, that&#39;s the main virtue of the `apply(to:)` suggestion: that there&#39;s really very little to it.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/be3b17a5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Splat</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>February 11, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Feb 11, 2016, at 8:00 AM, Alex Hoppen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I really like your suggestion of functions conforming to a protocol. I thought about this a little while and how an extendable FunctionType (or Applicable as you called it) protocol may impact existing code. For that I would even go one step further and add another step of protocol indirection such that the function’s signature is just a specialised form of a protocol SignatureType (this allows even better syntax when extending FunctionType as you can see in my last example).<br>&gt; <br>&gt; So this protocol would look like<br>&gt; <br>&gt; protocol FunctionSignatureType {<br>&gt;   associatedtype Parameters<br>&gt;   associatedtype ReturnType<br>&gt; }<br>&gt; <br>&gt; Parameters will be set to the functions parameters in tuple notation<br>&gt; <br>&gt; (((Int, String), secondParameter: Int) -&gt; String).Input == ((Int, String), secondParameter: Int)<br>&gt; <br>&gt; FunctionType would then only have one associated type:<br>&gt; <br>&gt; protocol FunctionType {<br>&gt;   associatedtype Signature: FunctionSignatureType<br>&gt; }<br>&gt; <br>&gt; Signature could for example be ((Int, String), secondParameter: Int) -&gt; String.<br>&gt; <br>&gt; We could then declare the apply function as a simple extension to FunctionType just like you suggested<br>&gt; <br>&gt; extension FunctionType {<br>&gt;   func apply(tuple: Signature.Parameters) -&gt; Signature.ReturnType {<br>&gt;     // Add some compiler magic here<br>&gt;   }<br>&gt; }<br></p><p>I really like the idea of a FuncionType protocol.  However, `apply` should be a requirement, not just in an extension.  This would allow other types to conform to the protocol.  <br></p><p>&gt; <br>&gt; This would make apply another normal Swift function with a special implementation just like print, + and so on. I think that providing the ability to extend FunctionTypes would be a huge win, because several functions that used to be global could now just be methods on FunctionType. For example to execute a function asynchronously via GCD could now be declared as:<br>&gt; <br>&gt; extension FunctionType where Signature == (() -&gt; Void) {<br>&gt;   func dispatchAsync(queue: dispatch_queue_t) {<br>&gt;     dispatch_async(queue, self)<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; I don’t know how this fits into the compiler and if functions can be made to conform to a protocol anyway but from the outside this looks like a solution to me that fits very well in the current style of Swift.<br>&gt; <br>&gt; - Alex<br>&gt; <br>&gt; <br>&gt;&gt; On 11 Feb 2016, at 08:54, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Still find it quite confusing, because I expected x.methodName to be a bound method and here it&#39;s a special syntactic form.  What happens if a protocol defines &quot;func apply(to:)&quot;?  Is that legal?  Would function types automatically conform to the protocol?<br>&gt;&gt; <br>&gt;&gt; For `apply(to:)`, it really would just be a method available on function types. You could put an `apply(to:)` method on any other type, and it wouldn&#39;t have any effect on things. You could declare a protocol with `apply(to:)`, but it wouldn&#39;t do anything to any function types. Conceptually, there would only be a few special things about them:<br>&gt;&gt; <br>&gt;&gt; 1. The compiler generates the `apply(to:)` methods automatically. We could, perhaps, have it generate a conformance to an `Applicable` protocol like this one, but that&#39;s probably overkill:<br>&gt;&gt; <br>&gt;&gt; 	protocol Applicable {<br>&gt;&gt; 		typealias ReturnValue<br>&gt;&gt; 		typealias ArgumentTuple<br>&gt;&gt; 		func apply(to: ArgumentTuple) -&gt; ReturnValue<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; (Actually, as I think about this, I wonder if `Applicable` could give us the `@splatting` property for free: take a generic parameter on Applicable and someone can specify a bare function, but you can&#39;t call it directly, only through its `apply(to:)` method.)<br>&gt;&gt; <br>&gt;&gt; 2. If `fn` is overloaded, `fn.apply(x)` will end up selecting an `fn` overload based on the type of `x`. Concrete example: `(+).apply(tupleOfInts)` would give you the `Int, Int` implementation of the `+` operator.<br>&gt;&gt; <br>&gt;&gt; 3. There&#39;s no way to add your own methods to a function type. (At least, I&#39;m not proposing there would be. There&#39;s no particular reason we couldn&#39;t have other methods on functions, particularly if there&#39;s an `Applicable` protocol to extend.)<br>&gt;&gt; <br>&gt;&gt; But `apply` is not a keyword, `apply(to:)` does not receive any special parsing, and you can still splatter `apply`s all around your code with no consequences whatsoever. Honestly, that&#39;s the main virtue of the `apply(to:)` suggestion: that there&#39;s really very little to it.<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/e718b027/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9ae1f2ed10d2ef77cce06bbb5a2dcf7e?s=50"></div><header><strong>Splat</strong> from <string>Alex Hoppen</string> &lt;alex at ateamer.de&gt;<p>February 11, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On 11 Feb 2016, at 16:05, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Feb 11, 2016, at 8:00 AM, Alex Hoppen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I really like your suggestion of functions conforming to a protocol. I thought about this a little while and how an extendable FunctionType (or Applicable as you called it) protocol may impact existing code. For that I would even go one step further and add another step of protocol indirection such that the function’s signature is just a specialised form of a protocol SignatureType (this allows even better syntax when extending FunctionType as you can see in my last example).<br>&gt;&gt; <br>&gt;&gt; So this protocol would look like<br>&gt;&gt; <br>&gt;&gt; protocol FunctionSignatureType {<br>&gt;&gt;   associatedtype Parameters<br>&gt;&gt;   associatedtype ReturnType<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Parameters will be set to the functions parameters in tuple notation<br>&gt;&gt; <br>&gt;&gt; (((Int, String), secondParameter: Int) -&gt; String).Input == ((Int, String), secondParameter: Int)<br>&gt;&gt; <br>&gt;&gt; FunctionType would then only have one associated type:<br>&gt;&gt; <br>&gt;&gt; protocol FunctionType {<br>&gt;&gt;   associatedtype Signature: FunctionSignatureType<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Signature could for example be ((Int, String), secondParameter: Int) -&gt; String.<br>&gt;&gt; <br>&gt;&gt; We could then declare the apply function as a simple extension to FunctionType just like you suggested<br>&gt;&gt; <br>&gt;&gt; extension FunctionType {<br>&gt;&gt;   func apply(tuple: Signature.Parameters) -&gt; Signature.ReturnType {<br>&gt;&gt;     // Add some compiler magic here<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt; <br>&gt; I really like the idea of a FuncionType protocol.  However, `apply` should be a requirement, not just in an extension.  This would allow other types to conform to the protocol.  <br>&gt; <br></p><p>Good point, it seems like I haven’t completely considered other types conforming to FunctionType. <br>If we provided a default implementation for apply that uses a special implementation only applicable to real functions we would have to make sure that this implementation is never used for custom types conforming to FunctionType. I can currently think of two options to achieve this:<br>1. Create a new private protocol in the stdlib extending FunctionType to which the functions actually conform and provide a default implementation for that protocol only<br>2. Make FunctionType a struct instead of a protocol (and call it Function instead). But I have no idea what implications that poses to the compiler. Making functions conform to FunctionType already seems hard to me and this even harder… If it would be possible I would prefer this option. Functions would then nicely line up along with Int etc.<br></p><p>&gt;&gt; <br>&gt;&gt; This would make apply another normal Swift function with a special implementation just like print, + and so on. I think that providing the ability to extend FunctionTypes would be a huge win, because several functions that used to be global could now just be methods on FunctionType. For example to execute a function asynchronously via GCD could now be declared as:<br>&gt;&gt; <br>&gt;&gt; extension FunctionType where Signature == (() -&gt; Void) {<br>&gt;&gt;   func dispatchAsync(queue: dispatch_queue_t) {<br>&gt;&gt;     dispatch_async(queue, self)<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I don’t know how this fits into the compiler and if functions can be made to conform to a protocol anyway but from the outside this looks like a solution to me that fits very well in the current style of Swift.<br>&gt;&gt; <br>&gt;&gt; - Alex<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 11 Feb 2016, at 08:54, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Still find it quite confusing, because I expected x.methodName to be a bound method and here it&#39;s a special syntactic form.  What happens if a protocol defines &quot;func apply(to:)&quot;?  Is that legal?  Would function types automatically conform to the protocol?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For `apply(to:)`, it really would just be a method available on function types. You could put an `apply(to:)` method on any other type, and it wouldn&#39;t have any effect on things. You could declare a protocol with `apply(to:)`, but it wouldn&#39;t do anything to any function types. Conceptually, there would only be a few special things about them:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. The compiler generates the `apply(to:)` methods automatically. We could, perhaps, have it generate a conformance to an `Applicable` protocol like this one, but that&#39;s probably overkill:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	protocol Applicable {<br>&gt;&gt;&gt; 		typealias ReturnValue<br>&gt;&gt;&gt; 		typealias ArgumentTuple<br>&gt;&gt;&gt; 		func apply(to: ArgumentTuple) -&gt; ReturnValue<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (Actually, as I think about this, I wonder if `Applicable` could give us the `@splatting` property for free: take a generic parameter on Applicable and someone can specify a bare function, but you can&#39;t call it directly, only through its `apply(to:)` method.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2. If `fn` is overloaded, `fn.apply(x)` will end up selecting an `fn` overload based on the type of `x`. Concrete example: `(+).apply(tupleOfInts)` would give you the `Int, Int` implementation of the `+` operator.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 3. There&#39;s no way to add your own methods to a function type. (At least, I&#39;m not proposing there would be. There&#39;s no particular reason we couldn&#39;t have other methods on functions, particularly if there&#39;s an `Applicable` protocol to extend.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But `apply` is not a keyword, `apply(to:)` does not receive any special parsing, and you can still splatter `apply`s all around your code with no consequences whatsoever. Honestly, that&#39;s the main virtue of the `apply(to:)` suggestion: that there&#39;s really very little to it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/c83a1a78/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
