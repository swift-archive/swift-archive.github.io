<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/18be32aa5ee2c4aa6ba2f23cf6ac42f7?s=50"></div><header><strong>Auto Unwrapping Of Optionals</strong> from <string>Tod Cunningham</string> &lt;tcunningham at vectorform.com&gt;<p>April 29, 2016 at 02:00:00pm</p></header><div class="content"><p>I&#39;m new to the swift evolution community, but I wanted to toss an idea out there to get some feedback on it. So here it goes...<br></p><p>Currently, if you assign a non-nil value to an optional and then want to access that optional later, in the same context, you need to manually unwrap the value.  This is usually done either by using &quot;!&quot; or by using something like &quot;if let&quot; or guard.<br></p><p>What would it be like if the compiler could auto unwrap, in cases where in knows the optional will have some value?  This would make the code &quot;clean&quot; and still be safe.<br></p><p>This concept of Auto Unwrapping of Optionals is similar to Implicitly Unwrapped Optionals, but is only applied when the compiler knows it is safe to do so.<br></p><p>Take the following example:<br></p><p>class Test {<br>    var today: NSDate? = nil<br>    func test() {<br>        today = today ?? NSDate()<br>        print(&quot;Today is \(today)&quot;)   // Would be printed as an optional<br>        let timeInterval: NSTimeInterval = today!.timeIntervalSinceNow  // Requires ! or (if let) to unwrap<br>        // ... do stuff with timeInterval ...<br>    }<br>}<br></p><p>With the above example, the compiler could known that today has a value after it&#39;s set in the test method.  So why couldn&#39;t the compiler auto unwrap it when accessed?  This would mean manual unwrapping would be unnecessary:<br></p><p>class Test {<br>    var today: NSDate? = nil<br>    func test() {<br>        today = today ?? NSDate()<br>        print(&quot;Today is \(today)&quot;)   // Would be printed as a value (not an optional)<br>        let timeInterval: NSTimeInterval = today.timeIntervalSinceNow  // No ! required (auto unwrapped)<br>        // ... do stuff with timeInterval ...<br>    }<br>}<br></p><p>If the value later gets set to an optional value, then it will no longer be auto unwrapable :<br></p><p>class Test {<br>    var today: NSDate? = nil<br></p><p>    func optionalDay() -&gt; NSDate? {<br>        return NSDate()<br>    }<br></p><p>    func test() {<br>        today = today ?? NSDate()<br>        print(&quot;Today is \(today)&quot;)   // Would be printed as a value (not an optional)<br>        let timeInterval: NSTimeInterval = today.timeIntervalSinceNow    // No ! required (auto unwrapped)<br>        let timeInterval2: NSTimeInterval = today!.timeIntervalSinceNow  // Explicit unwrapping would still be allowed<br></p><p>        // If today is assigned an optional value, we can no longer auto unwrap it<br>        today = optionalDay()<br>        print(&quot;Today is \(today)&quot;)   // Would be printed as an optional<br>        let timeInterval3: NSTimeInterval = today!.timeIntervalSinceNow  // manual unwrapping would be required<br>    }<br>}<br></p><p>Note in the above example, explicit unwrapping would still be allow.  The variable is still an optional.  This allows for existing code to remain unchanged.<br></p><p>This change would encourage less use of forced unwrapping &quot;!&quot;, generally require the developer to write less code, and would maintain code safety.  On the down side, it is performing some compiler “magic”.  It would be yet another thing to explain when trying to introduce people to swift and especially optionals.<br></p><p>What do you all think, would something like this be worth pursuing, what other pluses or minus would this introduce, has something like this already been discussed?<br></p><p>Thanks,<br>Tod Cunningham<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Auto Unwrapping Of Optionals</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>April 29, 2016 at 07:00:00pm</p></header><div class="content"><p>This is definitely something I’m hoping to see as well, alongside more intelligent handling of the is keyword, as currently Swift doesn’t handle the following either:<br></p><p>	if foo is SomeType { /* foo could be safely used as SomeType here, but currently is not */ }<br></p><p>Hopefully someone more familiar can weigh in, as it seems like something I expect to be on the way but perhaps has been delayed in case any further changes to the type system were required?<br></p><p>&gt; On 29 Apr 2016, at 15:37, Tod Cunningham via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;m new to the swift evolution community, but I wanted to toss an idea out there to get some feedback on it. So here it goes...<br>&gt; <br>&gt; Currently, if you assign a non-nil value to an optional and then want to access that optional later, in the same context, you need to manually unwrap the value.  This is usually done either by using &quot;!&quot; or by using something like &quot;if let&quot; or guard.<br>&gt; <br>&gt; What would it be like if the compiler could auto unwrap, in cases where in knows the optional will have some value?  This would make the code &quot;clean&quot; and still be safe.<br>&gt; <br>&gt; This concept of Auto Unwrapping of Optionals is similar to Implicitly Unwrapped Optionals, but is only applied when the compiler knows it is safe to do so.<br>&gt; <br>&gt; Take the following example:<br>&gt; <br>&gt; class Test {<br>&gt;    var today: NSDate? = nil<br>&gt;    func test() {<br>&gt;        today = today ?? NSDate()<br>&gt;        print(&quot;Today is \(today)&quot;)   // Would be printed as an optional<br>&gt;        let timeInterval: NSTimeInterval = today!.timeIntervalSinceNow  // Requires ! or (if let) to unwrap<br>&gt;        // ... do stuff with timeInterval ...<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; With the above example, the compiler could known that today has a value after it&#39;s set in the test method.  So why couldn&#39;t the compiler auto unwrap it when accessed?  This would mean manual unwrapping would be unnecessary:<br>&gt; <br>&gt; class Test {<br>&gt;    var today: NSDate? = nil<br>&gt;    func test() {<br>&gt;        today = today ?? NSDate()<br>&gt;        print(&quot;Today is \(today)&quot;)   // Would be printed as a value (not an optional)<br>&gt;        let timeInterval: NSTimeInterval = today.timeIntervalSinceNow  // No ! required (auto unwrapped)<br>&gt;        // ... do stuff with timeInterval ...<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; If the value later gets set to an optional value, then it will no longer be auto unwrapable :<br>&gt; <br>&gt; class Test {<br>&gt;    var today: NSDate? = nil<br>&gt; <br>&gt;    func optionalDay() -&gt; NSDate? {<br>&gt;        return NSDate()<br>&gt;    }<br>&gt; <br>&gt;    func test() {<br>&gt;        today = today ?? NSDate()<br>&gt;        print(&quot;Today is \(today)&quot;)   // Would be printed as a value (not an optional)<br>&gt;        let timeInterval: NSTimeInterval = today.timeIntervalSinceNow    // No ! required (auto unwrapped)<br>&gt;        let timeInterval2: NSTimeInterval = today!.timeIntervalSinceNow  // Explicit unwrapping would still be allowed<br>&gt; <br>&gt;        // If today is assigned an optional value, we can no longer auto unwrap it<br>&gt;        today = optionalDay()<br>&gt;        print(&quot;Today is \(today)&quot;)   // Would be printed as an optional<br>&gt;        let timeInterval3: NSTimeInterval = today!.timeIntervalSinceNow  // manual unwrapping would be required<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; Note in the above example, explicit unwrapping would still be allow.  The variable is still an optional.  This allows for existing code to remain unchanged.<br>&gt; <br>&gt; This change would encourage less use of forced unwrapping &quot;!&quot;, generally require the developer to write less code, and would maintain code safety.  On the down side, it is performing some compiler “magic”.  It would be yet another thing to explain when trying to introduce people to swift and especially optionals.<br>&gt; <br>&gt; What do you all think, would something like this be worth pursuing, what other pluses or minus would this introduce, has something like this already been discussed?<br>&gt; <br>&gt; Thanks,<br>&gt; Tod Cunningham<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160429/4333f38f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Auto Unwrapping Of Optionals</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>May  1, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On Apr 29, 2016, at 1:23 PM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This is definitely something I’m hoping to see as well, alongside more intelligent handling of the is keyword, as currently Swift doesn’t handle the following either:<br>&gt; <br>&gt; 	if foo is SomeType { /* foo could be safely used as SomeType here, but currently is not */ }<br>&gt; <br>&gt; Hopefully someone more familiar can weigh in, as it seems like something I expect to be on the way but perhaps has been delayed in case any further changes to the type system were required?<br></p><p>This can be handled with the if-let syntax:<br>if let foo = foo as? SomeType { … }<br>although I think your idea is more readable.<br></p><p>- Dave Sweeris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160501/a97060e6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/db5e2fe903111a67076e0a6b97e635dd?s=50"></div><header><strong>Auto Unwrapping Of Optionals</strong> from <string>Tyler Cloutier</string> &lt;cloutiertyler at aol.com&gt;<p>May  2, 2016 at 04:00:00pm</p></header><div class="content"><p>The difference between the if-let syntax and the below syntax is that the type of foo never changes with the if-let syntax. Instead a new variable is created which shadows the original foo. The distinction is important because types don’t implicitly change in Swift. The implicit change is called &quot;type narrowing”, that this has been discussed previously here: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/005475.html<br></p><p>I can definitely see the argument for no implicit type changes, but I can also see the argument that the syntax is much nicer.<br></p><p>Tyler<br></p><p><br>&gt; On Apr 30, 2016, at 10:11 PM, David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 29, 2016, at 1:23 PM, Haravikk via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This is definitely something I’m hoping to see as well, alongside more intelligent handling of the is keyword, as currently Swift doesn’t handle the following either:<br>&gt;&gt; <br>&gt;&gt; 	if foo is SomeType { /* foo could be safely used as SomeType here, but currently is not */ }<br>&gt;&gt; <br>&gt;&gt; Hopefully someone more familiar can weigh in, as it seems like something I expect to be on the way but perhaps has been delayed in case any further changes to the type system were required?<br>&gt; <br>&gt; This can be handled with the if-let syntax:<br>&gt; if let foo = foo as? SomeType { … }<br>&gt; although I think your idea is more readable.<br>&gt; <br>&gt; - Dave Sweeris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160502/04e1f208/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>Auto Unwrapping Of Optionals</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>April 29, 2016 at 09:00:00pm</p></header><div class="content"><p>+1 But your example is too good to be true. :)  <br></p><p>What would happen to this code:  <br></p><p>class A {  <br></p><p> var value: Type? = nil  <br></p><p> func reset() { self.value = nil }  <br></p><p> func test() {  <br></p><p> self.value = self.value ?? Type()  <br></p><p> self.reset()  <br></p><p> self.value.doSomething()  <br></p><p> // can the compiler be sure that our value wasn&#39;t reset somewhere from a different scope ?  <br> }<br>}<br></p><p>I&#39;m curious what will happen here. Can someone clarify on that?  <br></p><p>--  <br>Adrian Zubarev  <br></p><p>Am 29. April 2016 um 16:37:37, Tod Cunningham via swift-evolution (swift-evolution at swift.org(mailto:swift-evolution at swift.org)) schrieb:<br></p><p>&gt;  <br>&gt; I&#39;m new to the swift evolution community, but I wanted to toss an idea out there to get some feedback on it. So here it goes...<br>&gt;  <br>&gt; Currently, if you assign a non-nil value to an optional and then want to access that optional later, in the same context, you need to manually unwrap the value. This is usually done either by using &quot;!&quot; or by using something like &quot;if let&quot; or guard.<br>&gt;  <br>&gt; What would it be like if the compiler could auto unwrap, in cases where in knows the optional will have some value? This would make the code &quot;clean&quot; and still be safe.<br>&gt;  <br>&gt; This concept of Auto Unwrapping of Optionals is similar to Implicitly Unwrapped Optionals, but is only applied when the compiler knows it is safe to do so.<br>&gt;  <br>&gt; Take the following example:<br>&gt;  <br>&gt; class Test {<br>&gt; var today: NSDate? = nil<br>&gt; func test() {<br>&gt; today = today ?? NSDate()<br>&gt; print(&quot;Today is \(today)&quot;) // Would be printed as an optional<br>&gt; let timeInterval: NSTimeInterval = today!.timeIntervalSinceNow // Requires ! or (if let) to unwrap<br>&gt; // ... do stuff with timeInterval ...<br>&gt; }<br>&gt; }<br>&gt;  <br>&gt; With the above example, the compiler could known that today has a value after it&#39;s set in the test method. So why couldn&#39;t the compiler auto unwrap it when accessed? This would mean manual unwrapping would be unnecessary:<br>&gt;  <br>&gt; class Test {<br>&gt; var today: NSDate? = nil<br>&gt; func test() {<br>&gt; today = today ?? NSDate()<br>&gt; print(&quot;Today is \(today)&quot;) // Would be printed as a value (not an optional)<br>&gt; let timeInterval: NSTimeInterval = today.timeIntervalSinceNow // No ! required (auto unwrapped)<br>&gt; // ... do stuff with timeInterval ...<br>&gt; }<br>&gt; }<br>&gt;  <br>&gt; If the value later gets set to an optional value, then it will no longer be auto unwrapable :<br>&gt;  <br>&gt; class Test {<br>&gt; var today: NSDate? = nil<br>&gt;  <br>&gt; func optionalDay() -&gt; NSDate? {<br>&gt; return NSDate()<br>&gt; }<br>&gt;  <br>&gt; func test() {<br>&gt; today = today ?? NSDate()<br>&gt; print(&quot;Today is \(today)&quot;) // Would be printed as a value (not an optional)<br>&gt; let timeInterval: NSTimeInterval = today.timeIntervalSinceNow // No ! required (auto unwrapped)<br>&gt; let timeInterval2: NSTimeInterval = today!.timeIntervalSinceNow // Explicit unwrapping would still be allowed<br>&gt;  <br>&gt; // If today is assigned an optional value, we can no longer auto unwrap it<br>&gt; today = optionalDay()<br>&gt; print(&quot;Today is \(today)&quot;) // Would be printed as an optional<br>&gt; let timeInterval3: NSTimeInterval = today!.timeIntervalSinceNow // manual unwrapping would be required<br>&gt; }<br>&gt; }<br>&gt;  <br>&gt; Note in the above example, explicit unwrapping would still be allow. The variable is still an optional. This allows for existing code to remain unchanged.<br>&gt;  <br>&gt; This change would encourage less use of forced unwrapping &quot;!&quot;, generally require the developer to write less code, and would maintain code safety. On the down side, it is performing some compiler “magic”. It would be yet another thing to explain when trying to introduce people to swift and especially optionals.<br>&gt;  <br>&gt; What do you all think, would something like this be worth pursuing, what other pluses or minus would this introduce, has something like this already been discussed?<br>&gt;  <br>&gt; Thanks,<br>&gt; Tod Cunningham<br>&gt;  <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160429/c69ff754/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/18be32aa5ee2c4aa6ba2f23cf6ac42f7?s=50"></div><header><strong>Auto Unwrapping Of Optionals</strong> from <string>Tod Cunningham</string> &lt;tcunningham at vectorform.com&gt;<p>April 29, 2016 at 08:00:00pm</p></header><div class="content"><p>Adrian, excellent example of a challenging case.  I would say that when calling any method that might mutate the value, the compiler would no longer be able to safely auto unwrap.  That really limits the usefulness of this capability, at least for classes. For classes that would mean any call that would leave the current context would disable the auto unwrapping. For structs, it would be any mutating method would disable the auto unwrap.<br></p><p>I modified my example a bit to show how this would effect the ability to auto unwrap.<br></p><p>class Test {<br>  var today: NSDate? = nil<br></p><p>  func test() {<br>     today = today ?? NSDate()<br>     let timeInterval: NSTimeInterval = today.timeIntervalSinceNow // No ! required (auto unwrapped)<br></p><p>     // today can no longer be auto unwrapped as calling timeIntervalSinceNow has escaped<br>     // the enclosing context and could cause side effects with this instance.<br>}<br></p><p>It would be nice if the compiler could know that timeIntervalSinceNow had no dependencies or knowledge of class Test, but I doubt that would be practical.<br></p><p>However if Test was a struct the mutation information is readily available, so we know these calls would be safe:<br></p><p>struct Test {<br>    var today: NSDate? = nil<br></p><p>    mutating func test() {<br>        today = today ?? NSDate()<br>        let timeInterval: NSTimeInterval = today!.timeIntervalSinceNow // No ! required (auto unwrapped)<br>        let timeInterval2: NSTimeInterval = today!.timeIntervalSinceNow // Explicit unwrapping would still be allowed<br>        print(&quot;Today is \(today)&quot;) // Would be printed as a value (not an optional)<br></p><p>        // today can still be auto unwrapped as it won&#39;t be mutated by timeIntervalSinceNow or print<br>    }<br>}<br></p><p><br>From: &lt;swift-evolution-bounces at swift.org&lt;mailto:swift-evolution-bounces at swift.org&gt;&gt; on behalf of Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;&gt;<br>Reply-To: Adrian Zubarev &lt;adrian.zubarev at devandartist.com&lt;mailto:adrian.zubarev at devandartist.com&gt;&gt;<br>Date: Friday, April 29, 2016 at 3:21 PM<br>To: &quot;swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;&quot; &lt;swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;&gt;<br>Subject: Re: [swift-evolution] Auto Unwrapping Of Optionals<br></p><p>+1 But your example is too good to be true. :)<br></p><p>What would happen to this code:<br></p><p>class A {<br></p><p>    var value: Type? = nil<br></p><p>    func reset() { self.value = nil }<br></p><p>    func test() {<br></p><p>        self.value = self.value ?? Type()<br></p><p>        self.reset()<br></p><p>        self.value.doSomething()<br></p><p>        // can the compiler be sure that our value wasn&#39;t reset somewhere from a different scope ?<br>     }<br>}<br></p><p>I&#39;m curious what will happen here. Can someone clarify on that?<br></p><p>--<br>Adrian Zubarev<br></p><p>Am 29. April 2016 um 16:37:37, Tod Cunningham via swift-evolution (swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;) schrieb:<br></p><p>I&#39;m new to the swift evolution community, but I wanted to toss an idea out there to get some feedback on it. So here it goes...<br></p><p>Currently, if you assign a non-nil value to an optional and then want to access that optional later, in the same context, you need to manually unwrap the value. This is usually done either by using &quot;!&quot; or by using something like &quot;if let&quot; or guard.<br></p><p>What would it be like if the compiler could auto unwrap, in cases where in knows the optional will have some value? This would make the code &quot;clean&quot; and still be safe.<br></p><p>This concept of Auto Unwrapping of Optionals is similar to Implicitly Unwrapped Optionals, but is only applied when the compiler knows it is safe to do so.<br></p><p>Take the following example:<br></p><p>class Test {<br>var today: NSDate? = nil<br>func test() {<br>today = today ?? NSDate()<br>print(&quot;Today is \(today)&quot;) // Would be printed as an optional<br>let timeInterval: NSTimeInterval = today!.timeIntervalSinceNow // Requires ! or (if let) to unwrap<br>// ... do stuff with timeInterval ...<br>}<br>}<br></p><p>With the above example, the compiler could known that today has a value after it&#39;s set in the test method. So why couldn&#39;t the compiler auto unwrap it when accessed? This would mean manual unwrapping would be unnecessary:<br></p><p>class Test {<br>var today: NSDate? = nil<br>func test() {<br>today = today ?? NSDate()<br>print(&quot;Today is \(today)&quot;) // Would be printed as a value (not an optional)<br>let timeInterval: NSTimeInterval = today.timeIntervalSinceNow // No ! required (auto unwrapped)<br>// ... do stuff with timeInterval ...<br>}<br>}<br></p><p>If the value later gets set to an optional value, then it will no longer be auto unwrapable :<br></p><p>class Test {<br>var today: NSDate? = nil<br></p><p>func optionalDay() -&gt; NSDate? {<br>return NSDate()<br>}<br></p><p>func test() {<br>today = today ?? NSDate()<br>print(&quot;Today is \(today)&quot;) // Would be printed as a value (not an optional)<br>let timeInterval: NSTimeInterval = today.timeIntervalSinceNow // No ! required (auto unwrapped)<br>let timeInterval2: NSTimeInterval = today!.timeIntervalSinceNow // Explicit unwrapping would still be allowed<br></p><p>// If today is assigned an optional value, we can no longer auto unwrap it<br>today = optionalDay()<br>print(&quot;Today is \(today)&quot;) // Would be printed as an optional<br>let timeInterval3: NSTimeInterval = today!.timeIntervalSinceNow // manual unwrapping would be required<br>}<br>}<br></p><p>Note in the above example, explicit unwrapping would still be allow. The variable is still an optional. This allows for existing code to remain unchanged.<br></p><p>This change would encourage less use of forced unwrapping &quot;!&quot;, generally require the developer to write less code, and would maintain code safety. On the down side, it is performing some compiler “magic”. It would be yet another thing to explain when trying to introduce people to swift and especially optionals.<br></p><p>What do you all think, would something like this be worth pursuing, what other pluses or minus would this introduce, has something like this already been discussed?<br></p><p>Thanks,<br>Tod Cunningham<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Auto Unwrapping Of Optionals</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>April 30, 2016 at 08:00:00am</p></header><div class="content"><p>Wouldn&#39;t calling the NSDate constructor escape the context ?<br></p><p>Sent from Supmenow.com<br></p><p><br></p><p><br>On Fri, Apr 29, 2016 at 1:47 PM -0700, &quot;Tod Cunningham via swift-evolution&quot; &lt;swift-evolution at swift.org&gt; wrote:<br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br>Adrian, excellent example of a challenging case.  I would say that when calling any method that might mutate the value, the compiler would no longer be able to safely auto unwrap.  That really limits the usefulness of this capability, at least for classes. For classes that would mean any call that would leave the current context would disable the auto unwrapping. For structs, it would be any mutating method would disable the auto unwrap.<br></p><p>I modified my example a bit to show how this would effect the ability to auto unwrap.<br></p><p>class Test {<br>  var today: NSDate? = nil<br></p><p>  func test() {<br>     today = today ?? NSDate()<br>     let timeInterval: NSTimeInterval = today.timeIntervalSinceNow // No ! required (auto unwrapped)<br></p><p>     // today can no longer be auto unwrapped as calling timeIntervalSinceNow has escaped<br>     // the enclosing context and could cause side effects with this instance.<br>}<br></p><p>It would be nice if the compiler could know that timeIntervalSinceNow had no dependencies or knowledge of class Test, but I doubt that would be practical.<br></p><p>However if Test was a struct the mutation information is readily available, so we know these calls would be safe:<br></p><p>struct Test {<br>    var today: NSDate? = nil<br></p><p>    mutating func test() {<br>        today = today ?? NSDate()<br>        let timeInterval: NSTimeInterval = today!.timeIntervalSinceNow // No ! required (auto unwrapped)<br>        let timeInterval2: NSTimeInterval = today!.timeIntervalSinceNow // Explicit unwrapping would still be allowed<br>        print(&quot;Today is \(today)&quot;) // Would be printed as a value (not an optional)<br></p><p>        // today can still be auto unwrapped as it won&#39;t be mutated by timeIntervalSinceNow or print<br>    }<br>}<br></p><p><br>From: &gt; on behalf of Adrian Zubarev via swift-evolution &gt;<br>Reply-To: Adrian Zubarev &gt;<br>Date: Friday, April 29, 2016 at 3:21 PM<br>To: &quot;swift-evolution at swift.org&quot; &gt;<br>Subject: Re: [swift-evolution] Auto Unwrapping Of Optionals<br></p><p>+1 But your example is too good to be true. :)<br></p><p>What would happen to this code:<br></p><p>class A {<br></p><p>    var value: Type? = nil<br></p><p>    func reset() { self.value = nil }<br></p><p>    func test() {<br></p><p>        self.value = self.value ?? Type()<br></p><p>        self.reset()<br></p><p>        self.value.doSomething()<br></p><p>        // can the compiler be sure that our value wasn&#39;t reset somewhere from a different scope ?<br>     }<br>}<br></p><p>I&#39;m curious what will happen here. Can someone clarify on that?<br></p><p>--<br>Adrian Zubarev<br></p><p>Am 29. April 2016 um 16:37:37, Tod Cunningham via swift-evolution (swift-evolution at swift.org) schrieb:<br></p><p>I&#39;m new to the swift evolution community, but I wanted to toss an idea out there to get some feedback on it. So here it goes...<br></p><p>Currently, if you assign a non-nil value to an optional and then want to access that optional later, in the same context, you need to manually unwrap the value. This is usually done either by using &quot;!&quot; or by using something like &quot;if let&quot; or guard.<br></p><p>What would it be like if the compiler could auto unwrap, in cases where in knows the optional will have some value? This would make the code &quot;clean&quot; and still be safe.<br></p><p>This concept of Auto Unwrapping of Optionals is similar to Implicitly Unwrapped Optionals, but is only applied when the compiler knows it is safe to do so.<br></p><p>Take the following example:<br></p><p>class Test {<br>var today: NSDate? = nil<br>func test() {<br>today = today ?? NSDate()<br>print(&quot;Today is \(today)&quot;) // Would be printed as an optional<br>let timeInterval: NSTimeInterval = today!.timeIntervalSinceNow // Requires ! or (if let) to unwrap<br>// ... do stuff with timeInterval ...<br>}<br>}<br></p><p>With the above example, the compiler could known that today has a value after it&#39;s set in the test method. So why couldn&#39;t the compiler auto unwrap it when accessed? This would mean manual unwrapping would be unnecessary:<br></p><p>class Test {<br>var today: NSDate? = nil<br>func test() {<br>today = today ?? NSDate()<br>print(&quot;Today is \(today)&quot;) // Would be printed as a value (not an optional)<br>let timeInterval: NSTimeInterval = today.timeIntervalSinceNow // No ! required (auto unwrapped)<br>// ... do stuff with timeInterval ...<br>}<br>}<br></p><p>If the value later gets set to an optional value, then it will no longer be auto unwrapable :<br></p><p>class Test {<br>var today: NSDate? = nil<br></p><p>func optionalDay() -&gt; NSDate? {<br>return NSDate()<br>}<br></p><p>func test() {<br>today = today ?? NSDate()<br>print(&quot;Today is \(today)&quot;) // Would be printed as a value (not an optional)<br>let timeInterval: NSTimeInterval = today.timeIntervalSinceNow // No ! required (auto unwrapped)<br>let timeInterval2: NSTimeInterval = today!.timeIntervalSinceNow // Explicit unwrapping would still be allowed<br></p><p>// If today is assigned an optional value, we can no longer auto unwrap it<br>today = optionalDay()<br>print(&quot;Today is \(today)&quot;) // Would be printed as an optional<br>let timeInterval3: NSTimeInterval = today!.timeIntervalSinceNow // manual unwrapping would be required<br>}<br>}<br></p><p>Note in the above example, explicit unwrapping would still be allow. The variable is still an optional. This allows for existing code to remain unchanged.<br></p><p>This change would encourage less use of forced unwrapping &quot;!&quot;, generally require the developer to write less code, and would maintain code safety. On the down side, it is performing some compiler “magic”. It would be yet another thing to explain when trying to introduce people to swift and especially optionals.<br></p><p>What do you all think, would something like this be worth pursuing, what other pluses or minus would this introduce, has something like this already been discussed?<br></p><p>Thanks,<br>Tod Cunningham<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160430/147ff446/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>Auto Unwrapping Of Optionals</strong> from <string>Michael Peternell</string> &lt;michael.peternell at gmx.at&gt;<p>April 30, 2016 at 12:00:00am</p></header><div class="content"><p>I thought about this too, and I think it would be convenient. It feels a bit like artificial intelligence though, and I&#39;m not sure how easy it would be to implement this. It should be sharply defined what the compiler should infer and what not. This can be very hard.<br></p><p>For example, you write `print(&quot;Today is \(today)&quot;)`: should it print an Optional or should it print just the date, because it knows that it cannot be nil? I say it should print `.Optional(... 23:37)`. But what if it prints just the date? In this case `today` cannot be nil, so it would be safe to just print `23:37`. Now, I see the source code example for the first time. What thinking process do I have to go through to know if the variable is automatically unwrapped or not? I&#39;ll think &quot;can this variable be nil at that place?&quot; The compiler also thinks &quot;can this variable be nil at that place?&quot; Will the compiler and me always agree in this respect? Or do I have to think &quot;Will the compiler think that the variable can be nil at this place? Can it decide that it can never be nil?&quot;? In this case, the language user needs to have a mental model about what inferences the compiler is able to do, so the rules must be fixed and easily understandable. The model would probably be something along the lines of &quot;NSDate() always returns a non-optional value, so `x ?? NSDate()` is non-optional too.&quot; But knowing that foo(3) will return a value because foo only returns nil if its argument is &lt; 0 is probably out of scope, even if the foo-function is defined within the same source file and even if the `-O2` flag is turned on (because you don&#39;t want to have different semantics depending on how much optimization is turned on).<br></p><p>Therefore, I think it would be best to only apply implicit unwrapping in cases where the code would otherwise not compile.<br></p><p>E.g. now you have to write<br></p><p>    var x: Int? = someFunction()<br>    if(x == nil) { return 22 }<br>    return x!+2+(2*x!);<br></p><p>It should be possible to rewrite this as<br></p><p>    var x: Int? = someFunction()<br>    if(x == nil) { return 22 }<br>    return x+2+(2*x);<br></p><p>This should only work for variables defined within the same scope, so this should fail to compile:<br></p><p>    // type of self.foo is String<br>    if(self.foo == nil) { return 11 }<br>    // type of myFunc is String -&gt; ()<br>    myFunc(self.foo)<br>  <br>because even though self.foo was non-nil 1 microsecond ago, it doesn&#39;t mean that it is non-nil now.<br></p><p>On the other hand, what happens if a variable is captured by a block? Do we know that the variable is not mutated from another thread? Should we disable all these rules as soon as there is a block somewhere that captures one of the variables and might mutate them?<br></p><p>I just started thinking... For all these reasons, I don&#39;t see how this is going to be implemented in a way that is consistent and that doesn&#39;t introduce all kinds of strange edge cases. And any solution should be comprehensible by a Swift-beginner IMHO. On the other hand, if I ever forget a &quot;!&quot; somewhere, and the compiler compiles it anyways because it knows that it is safe, I will not complain :)<br></p><p>-Michael<br></p><p>&gt; Am 29.04.2016 um 16:37 schrieb Tod Cunningham via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; I&#39;m new to the swift evolution community, but I wanted to toss an idea out there to get some feedback on it. So here it goes...<br>&gt; <br>&gt; Currently, if you assign a non-nil value to an optional and then want to access that optional later, in the same context, you need to manually unwrap the value.  This is usually done either by using &quot;!&quot; or by using something like &quot;if let&quot; or guard.<br>&gt; <br>&gt; What would it be like if the compiler could auto unwrap, in cases where in knows the optional will have some value?  This would make the code &quot;clean&quot; and still be safe.<br>&gt; <br>&gt; This concept of Auto Unwrapping of Optionals is similar to Implicitly Unwrapped Optionals, but is only applied when the compiler knows it is safe to do so.<br>&gt; <br>&gt; Take the following example:<br>&gt; <br>&gt; class Test {<br>&gt;    var today: NSDate? = nil<br>&gt;    func test() {<br>&gt;        today = today ?? NSDate()<br>&gt;        print(&quot;Today is \(today)&quot;)   // Would be printed as an optional<br>&gt;        let timeInterval: NSTimeInterval = today!.timeIntervalSinceNow  // Requires ! or (if let) to unwrap<br>&gt;        // ... do stuff with timeInterval ...<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; With the above example, the compiler could known that today has a value after it&#39;s set in the test method.  So why couldn&#39;t the compiler auto unwrap it when accessed?  This would mean manual unwrapping would be unnecessary:<br>&gt; <br>&gt; class Test {<br>&gt;    var today: NSDate? = nil<br>&gt;    func test() {<br>&gt;        today = today ?? NSDate()<br>&gt;        print(&quot;Today is \(today)&quot;)   // Would be printed as a value (not an optional)<br>&gt;        let timeInterval: NSTimeInterval = today.timeIntervalSinceNow  // No ! required (auto unwrapped)<br>&gt;        // ... do stuff with timeInterval ...<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; If the value later gets set to an optional value, then it will no longer be auto unwrapable :<br>&gt; <br>&gt; class Test {<br>&gt;    var today: NSDate? = nil<br>&gt; <br>&gt;    func optionalDay() -&gt; NSDate? {<br>&gt;        return NSDate()<br>&gt;    }<br>&gt; <br>&gt;    func test() {<br>&gt;        today = today ?? NSDate()<br>&gt;        print(&quot;Today is \(today)&quot;)   // Would be printed as a value (not an optional)<br>&gt;        let timeInterval: NSTimeInterval = today.timeIntervalSinceNow    // No ! required (auto unwrapped)<br>&gt;        let timeInterval2: NSTimeInterval = today!.timeIntervalSinceNow  // Explicit unwrapping would still be allowed<br>&gt; <br>&gt;        // If today is assigned an optional value, we can no longer auto unwrap it<br>&gt;        today = optionalDay()<br>&gt;        print(&quot;Today is \(today)&quot;)   // Would be printed as an optional<br>&gt;        let timeInterval3: NSTimeInterval = today!.timeIntervalSinceNow  // manual unwrapping would be required<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; Note in the above example, explicit unwrapping would still be allow.  The variable is still an optional.  This allows for existing code to remain unchanged.<br>&gt; <br>&gt; This change would encourage less use of forced unwrapping &quot;!&quot;, generally require the developer to write less code, and would maintain code safety.  On the down side, it is performing some compiler “magic”.  It would be yet another thing to explain when trying to introduce people to swift and especially optionals.<br>&gt; <br>&gt; What do you all think, would something like this be worth pursuing, what other pluses or minus would this introduce, has something like this already been discussed?<br>&gt; <br>&gt; Thanks,<br>&gt; Tod Cunningham<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e9b374b9587bd8da1a1a027c8716ac0d?s=50"></div><header><strong>Auto Unwrapping Of Optionals</strong> from <string>Rod Brown</string> &lt;rodney.brown6 at icloud.com&gt;<p>April 30, 2016 at 08:00:00am</p></header><div class="content"><p>I agree that it&#39;s a pain to have to unwrap after this, but this proposal worries me somewhat.<br></p><p>I don&#39;t think we can safely guarantee that the value is non-null outside a very limited subset of cases, and we&#39;re breaking the simple, general and reasonable syntax of Swift for a very minor convenience win. <br></p><p>Additionally, this will play out like magic. Suddenly an optional starts dynamically changing its behaviour. I can&#39;t see where the compiler begins or ends the assertion of the value&#39;s non-null state, and so you have code that, with a little shifting around, begins to fail to even compile, based on something the user cannot see.<br></p><p>I think we have better mechanisms to handle this type of thing, like the if/guard let syntax, and implicitly unwrapped optionals.<br></p><p>&gt; On 30 Apr 2016, at 12:37 AM, Tod Cunningham via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;m new to the swift evolution community, but I wanted to toss an idea out there to get some feedback on it. So here it goes...<br>&gt; <br>&gt; Currently, if you assign a non-nil value to an optional and then want to access that optional later, in the same context, you need to manually unwrap the value.  This is usually done either by using &quot;!&quot; or by using something like &quot;if let&quot; or guard.<br>&gt; <br>&gt; What would it be like if the compiler could auto unwrap, in cases where in knows the optional will have some value?  This would make the code &quot;clean&quot; and still be safe.<br>&gt; <br>&gt; This concept of Auto Unwrapping of Optionals is similar to Implicitly Unwrapped Optionals, but is only applied when the compiler knows it is safe to do so.<br>&gt; <br>&gt; Take the following example:<br>&gt; <br>&gt; class Test {<br>&gt;    var today: NSDate? = nil<br>&gt;    func test() {<br>&gt;        today = today ?? NSDate()<br>&gt;        print(&quot;Today is \(today)&quot;)   // Would be printed as an optional<br>&gt;        let timeInterval: NSTimeInterval = today!.timeIntervalSinceNow  // Requires ! or (if let) to unwrap<br>&gt;        // ... do stuff with timeInterval ...<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; With the above example, the compiler could known that today has a value after it&#39;s set in the test method.  So why couldn&#39;t the compiler auto unwrap it when accessed?  This would mean manual unwrapping would be unnecessary:<br>&gt; <br>&gt; class Test {<br>&gt;    var today: NSDate? = nil<br>&gt;    func test() {<br>&gt;        today = today ?? NSDate()<br>&gt;        print(&quot;Today is \(today)&quot;)   // Would be printed as a value (not an optional)<br>&gt;        let timeInterval: NSTimeInterval = today.timeIntervalSinceNow  // No ! required (auto unwrapped)<br>&gt;        // ... do stuff with timeInterval ...<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; If the value later gets set to an optional value, then it will no longer be auto unwrapable :<br>&gt; <br>&gt; class Test {<br>&gt;    var today: NSDate? = nil<br>&gt; <br>&gt;    func optionalDay() -&gt; NSDate? {<br>&gt;        return NSDate()<br>&gt;    }<br>&gt; <br>&gt;    func test() {<br>&gt;        today = today ?? NSDate()<br>&gt;        print(&quot;Today is \(today)&quot;)   // Would be printed as a value (not an optional)<br>&gt;        let timeInterval: NSTimeInterval = today.timeIntervalSinceNow    // No ! required (auto unwrapped)<br>&gt;        let timeInterval2: NSTimeInterval = today!.timeIntervalSinceNow  // Explicit unwrapping would still be allowed<br>&gt; <br>&gt;        // If today is assigned an optional value, we can no longer auto unwrap it<br>&gt;        today = optionalDay()<br>&gt;        print(&quot;Today is \(today)&quot;)   // Would be printed as an optional<br>&gt;        let timeInterval3: NSTimeInterval = today!.timeIntervalSinceNow  // manual unwrapping would be required<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; Note in the above example, explicit unwrapping would still be allow.  The variable is still an optional.  This allows for existing code to remain unchanged.<br>&gt; <br>&gt; This change would encourage less use of forced unwrapping &quot;!&quot;, generally require the developer to write less code, and would maintain code safety.  On the down side, it is performing some compiler “magic”.  It would be yet another thing to explain when trying to introduce people to swift and especially optionals.<br>&gt; <br>&gt; What do you all think, would something like this be worth pursuing, what other pluses or minus would this introduce, has something like this already been discussed?<br>&gt; <br>&gt; Thanks,<br>&gt; Tod Cunningham<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Auto Unwrapping Of Optionals</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>April 30, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On 29 Apr 2016, at 23:28, Rod Brown via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I agree that it&#39;s a pain to have to unwrap after this, but this proposal worries me somewhat.<br>&gt; <br>&gt; I don&#39;t think we can safely guarantee that the value is non-null outside a very limited subset of cases, and we&#39;re breaking the simple, general and reasonable syntax of Swift for a very minor convenience win. <br>&gt; <br>&gt; Additionally, this will play out like magic. Suddenly an optional starts dynamically changing its behaviour. I can&#39;t see where the compiler begins or ends the assertion of the value&#39;s non-null state, and so you have code that, with a little shifting around, begins to fail to even compile, based on something the user cannot see.<br>&gt; <br>&gt; I think we have better mechanisms to handle this type of thing, like the if/guard let syntax, and implicitly unwrapped optionals.<br></p><p>Actually, thinking about it a bit more I think that the main case where I would want something like this is actually, something more like the following:<br></p><p>	if var unwrappedFoo = self.foo {<br>		unwrappedFoo.mutate()	// self.foo is unchanged, we have to do this:<br>		self.foo!.mutate()	// original is changed, but unwrappedFoo is not<br>		// foo was changed once, not twice<br>	}<br></p><p>Of course classes follow different rules, but it’s a little counter-intuitive for structs, what if we could do something like this:<br></p><p>	if inout unwrappedFoo = self.foo {<br>		unwrappedFoo.mutate()	// both are changed<br>		self.foo!.mutate()	// no longer required this<br>		// foo was changed twice, and both forms are consistent<br>	}<br></p><p>i.e- inout in this case gets us a non-optional reference to the original value, not a copy (or potential copy). In the event that self.foo is changed somewhere else, unwrappedFoo would continue to reference to what it used to be and remain usable, though of course in the above example the call to self.foo! would fail in such a case, but it should no longer be required.<br></p><p><br>At least in my experience this is the most common case that I encounter, as I try to use if let or guard let (or var) for safety, but then this doesn’t help when manipulating a struct, so a third option could be useful in such cases.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160430/c7ce8b46/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e9b374b9587bd8da1a1a027c8716ac0d?s=50"></div><header><strong>Auto Unwrapping Of Optionals</strong> from <string>Rod Brown</string> &lt;rodney.brown6 at icloud.com&gt;<p>April 30, 2016 at 10:00:00pm</p></header><div class="content"><p>I definitely agree there are difficulties with working with nullability and structs. Interesting perspective on how to deal with that. I&#39;d be interested in what others think of your inout type idea.<br></p><p>I think this specific proposal asking for compiler magic to auto-unwrap invisibly and only in very limited cases, as this proposal suggests, ends up breaking a lot more than it fixes. I can only see circumstances of this working with variables in the current scope, as anything like a property could be updated by other methods, threads etc, and the compiler couldn&#39;t be certain of state.<br></p><p>I think a language feature like you describe would be a lot more helpful, but I&#39;d love to hear others&#39; views on that.<br></p><p>- Rod<br></p><p>&gt; On 30 Apr 2016, at 5:22 PM, Haravikk &lt;swift-evolution at haravikk.me&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 29 Apr 2016, at 23:28, Rod Brown via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I agree that it&#39;s a pain to have to unwrap after this, but this proposal worries me somewhat.<br>&gt;&gt; <br>&gt;&gt; I don&#39;t think we can safely guarantee that the value is non-null outside a very limited subset of cases, and we&#39;re breaking the simple, general and reasonable syntax of Swift for a very minor convenience win. <br>&gt;&gt; <br>&gt;&gt; Additionally, this will play out like magic. Suddenly an optional starts dynamically changing its behaviour. I can&#39;t see where the compiler begins or ends the assertion of the value&#39;s non-null state, and so you have code that, with a little shifting around, begins to fail to even compile, based on something the user cannot see.<br>&gt;&gt; <br>&gt;&gt; I think we have better mechanisms to handle this type of thing, like the if/guard let syntax, and implicitly unwrapped optionals.<br>&gt; <br>&gt; Actually, thinking about it a bit more I think that the main case where I would want something like this is actually, something more like the following:<br>&gt; <br>&gt; 	if var unwrappedFoo = self.foo {<br>&gt; 		unwrappedFoo.mutate()	// self.foo is unchanged, we have to do this:<br>&gt; 		self.foo!.mutate()	// original is changed, but unwrappedFoo is not<br>&gt; 		// foo was changed once, not twice<br>&gt; 	}<br>&gt; <br>&gt; Of course classes follow different rules, but it’s a little counter-intuitive for structs, what if we could do something like this:<br>&gt; <br>&gt; 	if inout unwrappedFoo = self.foo {<br>&gt; 		unwrappedFoo.mutate()	// both are changed<br>&gt; 		self.foo!.mutate()	// no longer required this<br>&gt; 		// foo was changed twice, and both forms are consistent<br>&gt; 	}<br>&gt; <br>&gt; i.e- inout in this case gets us a non-optional reference to the original value, not a copy (or potential copy). In the event that self.foo is changed somewhere else, unwrappedFoo would continue to reference to what it used to be and remain usable, though of course in the above example the call to self.foo! would fail in such a case, but it should no longer be required.<br>&gt; <br>&gt; <br>&gt; At least in my experience this is the most common case that I encounter, as I try to use if let or guard let (or var) for safety, but then this doesn’t help when manipulating a struct, so a third option could be useful in such cases.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160430/11040072/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Auto Unwrapping Of Optionals</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>April 30, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Apr 30, 2016, at 7:18 AM, Rod Brown via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I think this specific proposal asking for compiler magic to auto-unwrap invisibly and only in very limited cases, as this proposal suggests, ends up breaking a lot more than it fixes. I can only see circumstances of this working with variables in the current scope, as anything like a property could be updated by other methods, threads etc, and the compiler couldn&#39;t be certain of state.<br>&gt; <br>&gt; I think a language feature like you describe would be a lot more helpful, but I&#39;d love to hear others&#39; views on that.<br>&gt; <br>&gt; - Rod<br></p><p><br>Yeah, auto-unwrapping &quot;wherever it might be possible&quot; seems too magical to me. I wouldn’t object to the compiler auto-unwraping optionals within a well defined code block, though:<br>//foo is T?<br>if foo != nil {<br>//foo is T within this set of curly braces<br>}<br>But even that invokes a bit of compiler magic, in that for this one type of enum (`Optional`), the compiler knows that if it isn’t one case, it must be the other. I’d prefer a more general solution…<br></p><p>What if the “is” keyword could function as a kind of incomplete switch?<br>var foo: UnicodeDecodingResult<br>...<br>if foo is .Result {<br>    //since we know foo is a result, `foo` refers to foo&#39;s associated or raw value within this set of curly braces<br>}<br>This allows the language feature (and relevant compiler code paths) to be used with any enum, not just Optionals. The “optional unwrapping behavior&quot; could then be written like this:<br>var bar = 4 as Int?<br>...<br>if bar is .Some {<br>    //bar is 4 within this set of curly braces<br>}<br></p><p>- Dave Sweeris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160430/dba1257d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Auto Unwrapping Of Optionals</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>April 30, 2016 at 09:00:00pm</p></header><div class="content"><p>That would be handy<br></p><p>Sent from Supmenow.com<br></p><p><br></p><p><br>On Sat, Apr 30, 2016 at 1:31 PM -0700, &quot;David Sweeris via swift-evolution&quot; &lt;swift-evolution at swift.org&gt; wrote:<br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p>On Apr 30, 2016, at 7:18 AM, Rod Brown via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>I think this specific proposal asking for compiler magic to auto-unwrap invisibly and only in very limited cases, as this proposal suggests, ends up breaking a lot more than it fixes. I can only see circumstances of this working with variables in the current scope, as anything like a property could be updated by other methods, threads etc, and the compiler couldn&#39;t be certain of state.<br>I think a language feature like you describe would be a lot more helpful, but I&#39;d love to hear others&#39; views on that.<br>- Rod<br>Yeah, auto-unwrapping &quot;wherever it might be possible&quot; seems too magical to me. I wouldn’t object to the compiler auto-unwraping optionals within a well defined code block, though://foo is T?if foo != nil {//foo is T within this set of curly braces}But even that invokes a bit of compiler magic, in that for this one type of enum (`Optional`), the compiler knows that if it isn’t one case, it must be the other. I’d prefer a more general solution…<br>What if the “is” keyword could function as a kind of incomplete switch?var foo: UnicodeDecodingResult...if foo is .Result {    //since we know foo is a result, `foo` refers to foo&#39;s associated or raw value within this set of curly braces}This allows the language feature (and relevant compiler code paths) to be used with any enum, not just Optionals. The “optional unwrapping behavior&quot; could then be written like this:var bar = 4 as Int?...if bar is .Some {    //bar is 4 within this set of curly braces}<br>- Dave Sweeris<br></p><p><br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160430/a99ea22a/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e9b374b9587bd8da1a1a027c8716ac0d?s=50"></div><header><strong>Auto Unwrapping Of Optionals</strong> from <string>Rod Brown</string> &lt;rodney.brown6 at icloud.com&gt;<p>May  1, 2016 at 08:00:00am</p></header><div class="content"><p>Re-sent for Swift Evolution. Response at end.<br></p><p>On 1 May 2016, at 6:31 AM, David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt;&gt; On Apr 30, 2016, at 7:18 AM, Rod Brown via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I think this specific proposal asking for compiler magic to auto-unwrap invisibly and only in very limited cases, as this proposal suggests, ends up breaking a lot more than it fixes. I can only see circumstances of this working with variables in the current scope, as anything like a property could be updated by other methods, threads etc, and the compiler couldn&#39;t be certain of state.<br>&gt;&gt; <br>&gt;&gt; I think a language feature like you describe would be a lot more helpful, but I&#39;d love to hear others&#39; views on that.<br>&gt;&gt; <br>&gt;&gt; - Rod<br>&gt; <br>&gt; <br>&gt; Yeah, auto-unwrapping &quot;wherever it might be possible&quot; seems too magical to me. I wouldn’t object to the compiler auto-unwraping optionals within a well defined code block, though:<br>&gt; //foo is T?<br>&gt; if foo != nil {<br>&gt; //foo is T within this set of curly braces<br>&gt; }<br>&gt; But even that invokes a bit of compiler magic, in that for this one type of enum (`Optional`), the compiler knows that if it isn’t one case, it must be the other. I’d prefer a more general solution…<br>&gt; <br>&gt; What if the “is” keyword could function as a kind of incomplete switch?<br>&gt; var foo: UnicodeDecodingResult<br>&gt; ...<br>&gt; if foo is .Result {<br>&gt;     //since we know foo is a result, `foo` refers to foo&#39;s associated or raw value within this set of curly braces<br>&gt; }<br>&gt; This allows the language feature (and relevant compiler code paths) to be used with any enum, not just Optionals. The “optional unwrapping behavior&quot; could then be written like this:<br>&gt; var bar = 4 as Int?<br>&gt; ...<br>&gt; if bar is .Some {<br>&gt;     //bar is 4 within this set of curly braces<br>&gt; }<br>&gt; <br>&gt; - Dave Sweeris<br></p><p>I think your idea makes a lot more sense in respect to ensuring we don&#39;t have as much magic.<br></p><p>That said, I still wonder about the implications for thread safety etc. While it isn&#39;t a focus of Swift 3, it&#39;s something to think about whether this promotes a paradigm that cannot be supported in a threaded environment, specifically accessing properties.<br></p><p>The if-let paradigm is a lot stronger for this set of actions. It gains a separate reference or copy to the internal value, and allows you to action it safely. Should the property change in the meantime, it isn&#39;t relevant, because you have you own reference/copy, and then you have the right to re-set the property as required.<br></p><p>This, however, would theoretically add in an invisible ! for you. This leaves you unable to handle the situation should the variable have been changed by another thread between your check and your subsequent action.<br></p><p>Unless I&#39;m missing something, I worry about the behaviour of such a &quot;feature&quot; in a multithreaded environment. I think the previous &quot;inout&quot; idea actually held a lot more weight in this regard - at least then you can act on the copy, and have the change propagate to the main declaration, and overwrite any changes made on another thread.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160501/cf97692c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Auto Unwrapping Of Optionals</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>May  1, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On Apr 30, 2016, at 5:42 PM, Rod Brown &lt;rodney.brown6 at icloud.com&gt; wrote:<br>&gt; <br>&gt; Re-sent for Swift Evolution. Response at end.<br>&gt; <br>&gt; On 1 May 2016, at 6:31 AM, David Sweeris &lt;davesweeris at mac.com &lt;mailto:davesweeris at mac.com&gt;&gt; wrote:<br>&gt;&gt;&gt; On Apr 30, 2016, at 7:18 AM, Rod Brown via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think this specific proposal asking for compiler magic to auto-unwrap invisibly and only in very limited cases, as this proposal suggests, ends up breaking a lot more than it fixes. I can only see circumstances of this working with variables in the current scope, as anything like a property could be updated by other methods, threads etc, and the compiler couldn&#39;t be certain of state.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think a language feature like you describe would be a lot more helpful, but I&#39;d love to hear others&#39; views on that.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Rod<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Yeah, auto-unwrapping &quot;wherever it might be possible&quot; seems too magical to me. I wouldn’t object to the compiler auto-unwraping optionals within a well defined code block, though:<br>&gt;&gt; //foo is T?<br>&gt;&gt; if foo != nil {<br>&gt;&gt; //foo is T within this set of curly braces<br>&gt;&gt; }<br>&gt;&gt; But even that invokes a bit of compiler magic, in that for this one type of enum (`Optional`), the compiler knows that if it isn’t one case, it must be the other. I’d prefer a more general solution…<br>&gt;&gt; <br>&gt;&gt; What if the “is” keyword could function as a kind of incomplete switch?<br>&gt;&gt; var foo: UnicodeDecodingResult<br>&gt;&gt; ...<br>&gt;&gt; if foo is .Result {<br>&gt;&gt;     //since we know foo is a result, `foo` refers to foo&#39;s associated or raw value within this set of curly braces<br>&gt;&gt; }<br>&gt;&gt; This allows the language feature (and relevant compiler code paths) to be used with any enum, not just Optionals. The “optional unwrapping behavior&quot; could then be written like this:<br>&gt;&gt; var bar = 4 as Int?<br>&gt;&gt; ...<br>&gt;&gt; if bar is .Some {<br>&gt;&gt;     //bar is 4 within this set of curly braces<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; - Dave Sweeris<br>&gt; <br>&gt; I think your idea makes a lot more sense in respect to ensuring we don&#39;t have as much magic.<br>&gt; <br>&gt; That said, I still wonder about the implications for thread safety etc. While it isn&#39;t a focus of Swift 3, it&#39;s something to think about whether this promotes a paradigm that cannot be supported in a threaded environment, specifically accessing properties.<br>&gt; <br>&gt; The if-let paradigm is a lot stronger for this set of actions. It gains a separate reference or copy to the internal value, and allows you to action it safely. Should the property change in the meantime, it isn&#39;t relevant, because you have you own reference/copy, and then you have the right to re-set the property as required.<br>&gt; <br>&gt; This, however, would theoretically add in an invisible ! for you. This leaves you unable to handle the situation should the variable have been changed by another thread between your check and your subsequent action.<br>&gt; <br>&gt; Unless I&#39;m missing something, I worry about the behaviour of such a &quot;feature&quot; in a multithreaded environment. I think the previous &quot;inout&quot; idea actually held a lot more weight in this regard - at least then you can act on the copy, and have the change propagate to the main declaration, and overwrite any changes made on another thread.<br></p><p><br>I think it would have the same resiliency as if-let, since I was envisioning this to just be syntactic sugar for a switch statement. That is, this:<br>if foo is .Result { //`foo` refers to foo&#39;s associated or raw value within the following code block<br>    //code block<br>}<br>would get rewritten to this, for enums with associated values:<br>switch foo {<br>case .Result(let foo): //we get a local copy of `foo` (the associated value) for the following code block<br>    //code block<br>default: break<br>}<br>or this, for enums with raw values:<br>switch foo {<br>case .Result:<br>    let _foo = foo.rawValue //the compiler substitutes `_foo` for `foo`<br>    //code block<br>default: break<br>}<br></p><p>There’d have to be some more auto-generated code to copy assigned values back into the original `foo`, but I don’t think it’d be hard to do.<br></p><p>- Dave Sweeris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160501/2bff8c61/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e9b374b9587bd8da1a1a027c8716ac0d?s=50"></div><header><strong>Auto Unwrapping Of Optionals</strong> from <string>Rod Brown</string> &lt;rodney.brown6 at icloud.com&gt;<p>May  1, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On 1 May 2016, at 3:00 PM, David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Apr 30, 2016, at 5:42 PM, Rod Brown &lt;rodney.brown6 at icloud.com &lt;mailto:rodney.brown6 at icloud.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Re-sent for Swift Evolution. Response at end.<br>&gt;&gt; <br>&gt;&gt; On 1 May 2016, at 6:31 AM, David Sweeris &lt;davesweeris at mac.com &lt;mailto:davesweeris at mac.com&gt;&gt; wrote:<br>&gt;&gt; I think your idea makes a lot more sense in respect to ensuring we don&#39;t have as much magic.<br>&gt;&gt; <br>&gt;&gt; That said, I still wonder about the implications for thread safety etc. While it isn&#39;t a focus of Swift 3, it&#39;s something to think about whether this promotes a paradigm that cannot be supported in a threaded environment, specifically accessing properties.<br>&gt;&gt; <br>&gt;&gt; The if-let paradigm is a lot stronger for this set of actions. It gains a separate reference or copy to the internal value, and allows you to action it safely. Should the property change in the meantime, it isn&#39;t relevant, because you have you own reference/copy, and then you have the right to re-set the property as required.<br>&gt;&gt; <br>&gt;&gt; This, however, would theoretically add in an invisible ! for you. This leaves you unable to handle the situation should the variable have been changed by another thread between your check and your subsequent action.<br>&gt;&gt; <br>&gt;&gt; Unless I&#39;m missing something, I worry about the behaviour of such a &quot;feature&quot; in a multithreaded environment. I think the previous &quot;inout&quot; idea actually held a lot more weight in this regard - at least then you can act on the copy, and have the change propagate to the main declaration, and overwrite any changes made on another thread.<br>&gt; <br>&gt; <br>&gt; I think it would have the same resiliency as if-let, since I was envisioning this to just be syntactic sugar for a switch statement. That is, this:<br>&gt; if foo is .Result { //`foo` refers to foo&#39;s associated or raw value within the following code block<br>&gt;     //code block<br>&gt; }<br>&gt; would get rewritten to this, for enums with associated values:<br>&gt; switch foo {<br>&gt; case .Result(let foo): //we get a local copy of `foo` (the associated value) for the following code block<br>&gt;     //code block<br>&gt; default: break<br>&gt; }<br>&gt; or this, for enums with raw values:<br>&gt; switch foo {<br>&gt; case .Result:<br>&gt;     let _foo = foo.rawValue //the compiler substitutes `_foo` for `foo`<br>&gt;     //code block<br>&gt; default: break<br>&gt; }<br>&gt; <br>&gt; There’d have to be some more auto-generated code to copy assigned values back into the original `foo`, but I don’t think it’d be hard to do.<br>&gt; <br>&gt; - Dave Sweeris<br></p><p><br>Ah yes, that makes sense. So how do you see the compiler dealing with the assignment/access problem on structs? If you assign to foo, the compiler assigns to both “_foo” and “foo”?<br></p><p>I wonder if we’re pushing down the road of convenience at the expense of truth. The if/guard let syntax is clear that you’re getting a separate reference or copy, but what you’re suggesting is hiding the reality from the user for what I see as relatively little convenience.<br></p><p>This is not to say I don’t see the problem, or the convenience… I just wonder if this might be going a little too far.<br></p><p>- Rod<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160501/455a868b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/18be32aa5ee2c4aa6ba2f23cf6ac42f7?s=50"></div><header><strong>Auto Unwrapping Of Optionals</strong> from <string>Tod Cunningham</string> &lt;tcunningham at vectorform.com&gt;<p>May  2, 2016 at 07:00:00pm</p></header><div class="content"><p>&quot;I wonder if we’re pushing down the road of convenience at the expense of truth. The if/guard let syntax is clear that you’re getting a separate reference or copy, but what you’re suggesting is hiding the reality from the user for what I see as relatively little convenience.&quot;<br></p><p>It just might be me trying to avoid using !, and especially avoid implicit unwrapped options.  While there is nothing wrong with the following code it makes me very uncomfortable from a defensive programming point of view:<br></p><p>        today = today ?? NSDate()<br>        let timeInterval = today!.timeIntervalSinceNow<br></p><p>Some developer coming along and changing the code could easily introduce a crash, such as by removing the default value.  In the above example, such a change wouldn’t introduce a compiler warning/error and the bug might not reveal itself until a much later.<br></p><p>Also using if-let or guard also doesn’t seem right, in this case, as it should never fail:<br></p><p>   today = today ?? NSDate()   // self.today changed!<br>   if let today = today {<br>      let timeInterval: NSTimeInterval = today!.timeIntervalSinceNow<br>   } else {<br>      assertFailure()<br>   }<br></p><p>Same issue with guard:<br></p><p>   today = today ?? NSDate()   // self.today changed!<br>   guard let today = today else {<br>      assertFailure()<br>      return //  that should never happen<br>   }<br>   let timeInterval: NSTimeInterval = today!.timeIntervalSinceNow<br></p><p>This introduces code that just gets in the way of the code’s meaning for cases that should never happen.  Yuck, there has to be a better way!<br></p><p>- Tod<br></p><p><br></p><p>From: &lt;swift-evolution-bounces at swift.org&lt;mailto:swift-evolution-bounces at swift.org&gt;&gt; on behalf of Rod Brown via swift-evolution &lt;swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;&gt;<br>Reply-To: Rod Brown &lt;rodney.brown6 at icloud.com&lt;mailto:rodney.brown6 at icloud.com&gt;&gt;<br>Date: Sunday, May 1, 2016 at 1:25 AM<br>To: David Sweeris &lt;davesweeris at mac.com&lt;mailto:davesweeris at mac.com&gt;&gt;<br>Cc: Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;&gt;<br>Subject: Re: [swift-evolution] Auto Unwrapping Of Optionals<br></p><p><br>On 1 May 2016, at 3:00 PM, David Sweeris &lt;davesweeris at mac.com&lt;mailto:davesweeris at mac.com&gt;&gt; wrote:<br></p><p>On Apr 30, 2016, at 5:42 PM, Rod Brown &lt;rodney.brown6 at icloud.com&lt;mailto:rodney.brown6 at icloud.com&gt;&gt; wrote:<br></p><p>Re-sent for Swift Evolution. Response at end.<br></p><p>On 1 May 2016, at 6:31 AM, David Sweeris &lt;davesweeris at mac.com&lt;mailto:davesweeris at mac.com&gt;&gt; wrote:<br>I think your idea makes a lot more sense in respect to ensuring we don&#39;t have as much magic.<br></p><p>That said, I still wonder about the implications for thread safety etc. While it isn&#39;t a focus of Swift 3, it&#39;s something to think about whether this promotes a paradigm that cannot be supported in a threaded environment, specifically accessing properties.<br></p><p>The if-let paradigm is a lot stronger for this set of actions. It gains a separate reference or copy to the internal value, and allows you to action it safely. Should the property change in the meantime, it isn&#39;t relevant, because you have you own reference/copy, and then you have the right to re-set the property as required.<br></p><p>This, however, would theoretically add in an invisible ! for you. This leaves you unable to handle the situation should the variable have been changed by another thread between your check and your subsequent action.<br></p><p>Unless I&#39;m missing something, I worry about the behaviour of such a &quot;feature&quot; in a multithreaded environment. I think the previous &quot;inout&quot; idea actually held a lot more weight in this regard - at least then you can act on the copy, and have the change propagate to the main declaration, and overwrite any changes made on another thread.<br></p><p>I think it would have the same resiliency as if-let, since I was envisioning this to just be syntactic sugar for a switch statement. That is, this:<br>if foo is .Result { //`foo` refers to foo&#39;s associated or raw value within the following code block<br>    //code block<br>}<br>would get rewritten to this, for enums with associated values:<br>switchfoo {<br>case .Result(let foo): //we get a local copy of `foo` (the associated value) for the following code block<br>    //code block<br>default: break<br>}<br>or this, for enums with raw values:<br>switchfoo {<br>case .Result:<br>    let _foo = foo.rawValue //the compiler substitutes `_foo` for `foo`<br>    //code block<br>default: break<br>}<br></p><p>There’d have to be some more auto-generated code to copy assigned values back into the original `foo`, but I don’t think it’d be hard to do.<br></p><p>- Dave Sweeris<br></p><p><br>Ah yes, that makes sense. So how do you see the compiler dealing with the assignment/access problem on structs? If you assign to foo, the compiler assigns to both “_foo” and “foo”?<br></p><p>I wonder if we’re pushing down the road of convenience at the expense of truth. The if/guard let syntax is clear that you’re getting a separate reference or copy, but what you’re suggesting is hiding the reality from the user for what I see as relatively little convenience.<br></p><p>This is not to say I don’t see the problem, or the convenience… I just wonder if this might be going a little too far.<br></p><p>- Rod<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Auto Unwrapping Of Optionals</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>May  2, 2016 at 02:00:00pm</p></header><div class="content"><p>It is a bad idea to have the compiler change the interpretation of a type without some hard and fast rules; the compiler’s interpretation of the optionality of your code will result in your code being legal or not.<br></p><p>In terms of solutions, I would prefer something similar to a guard statement that, rather than exiting, shadows a constant or variable with a non-optional equivalent type, e.g.<br></p><p>shadow var today = today ?? NSDate()<br>let timeInterval = today.timeIntervalSinceNow<br></p><p>-DW<br></p><p>On May 2, 2016, at 1:27 PM, Tod Cunningham via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; &quot;I wonder if we’re pushing down the road of convenience at the expense of truth. The if/guard let syntax is clear that you’re getting a separate reference or copy, but what you’re suggesting is hiding the reality from the user for what I see as relatively little convenience.&quot;<br>&gt; <br>&gt; It just might be me trying to avoid using !, and especially avoid implicit unwrapped options.  While there is nothing wrong with the following code it makes me very uncomfortable from a defensive programming point of view:<br>&gt; <br>&gt;        today = today ?? NSDate()<br>&gt;        let timeInterval = today!.timeIntervalSinceNow<br>&gt; <br>&gt; Some developer coming along and changing the code could easily introduce a crash, such as by removing the default value.  In the above example, such a change wouldn’t introduce a compiler warning/error and the bug might not reveal itself until a much later.<br>&gt; <br>&gt; Also using if-let or guard also doesn’t seem right, in this case, as it should never fail:<br>&gt; <br>&gt;   today = today ?? NSDate()   // self.today changed!<br>&gt;   if let today = today {<br>&gt;      let timeInterval: NSTimeInterval = today!.timeIntervalSinceNow<br>&gt;   } else {<br>&gt;      assertFailure()<br>&gt;   }<br>&gt; <br>&gt; Same issue with guard:<br>&gt; <br>&gt;   today = today ?? NSDate()   // self.today changed!<br>&gt;   guard let today = today else {<br>&gt;      assertFailure()<br>&gt;      return //  that should never happen<br>&gt;   }<br>&gt;   let timeInterval: NSTimeInterval = today!.timeIntervalSinceNow<br>&gt; <br>&gt; This introduces code that just gets in the way of the code’s meaning for cases that should never happen.  Yuck, there has to be a better way!<br>&gt; <br>&gt; - Tod<br>&gt; <br>&gt; <br>&gt; <br>&gt; From: &lt;swift-evolution-bounces at swift.org&lt;mailto:swift-evolution-bounces at swift.org&gt;&gt; on behalf of Rod Brown via swift-evolution &lt;swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt; Reply-To: Rod Brown &lt;rodney.brown6 at icloud.com&lt;mailto:rodney.brown6 at icloud.com&gt;&gt;<br>&gt; Date: Sunday, May 1, 2016 at 1:25 AM<br>&gt; To: David Sweeris &lt;davesweeris at mac.com&lt;mailto:davesweeris at mac.com&gt;&gt;<br>&gt; Cc: Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt; Subject: Re: [swift-evolution] Auto Unwrapping Of Optionals<br>&gt; <br>&gt; <br>&gt; On 1 May 2016, at 3:00 PM, David Sweeris &lt;davesweeris at mac.com&lt;mailto:davesweeris at mac.com&gt;&gt; wrote:<br>&gt; <br>&gt; On Apr 30, 2016, at 5:42 PM, Rod Brown &lt;rodney.brown6 at icloud.com&lt;mailto:rodney.brown6 at icloud.com&gt;&gt; wrote:<br>&gt; <br>&gt; Re-sent for Swift Evolution. Response at end.<br>&gt; <br>&gt; On 1 May 2016, at 6:31 AM, David Sweeris &lt;davesweeris at mac.com&lt;mailto:davesweeris at mac.com&gt;&gt; wrote:<br>&gt; I think your idea makes a lot more sense in respect to ensuring we don&#39;t have as much magic.<br>&gt; <br>&gt; That said, I still wonder about the implications for thread safety etc. While it isn&#39;t a focus of Swift 3, it&#39;s something to think about whether this promotes a paradigm that cannot be supported in a threaded environment, specifically accessing properties.<br>&gt; <br>&gt; The if-let paradigm is a lot stronger for this set of actions. It gains a separate reference or copy to the internal value, and allows you to action it safely. Should the property change in the meantime, it isn&#39;t relevant, because you have you own reference/copy, and then you have the right to re-set the property as required.<br>&gt; <br>&gt; This, however, would theoretically add in an invisible ! for you. This leaves you unable to handle the situation should the variable have been changed by another thread between your check and your subsequent action.<br>&gt; <br>&gt; Unless I&#39;m missing something, I worry about the behaviour of such a &quot;feature&quot; in a multithreaded environment. I think the previous &quot;inout&quot; idea actually held a lot more weight in this regard - at least then you can act on the copy, and have the change propagate to the main declaration, and overwrite any changes made on another thread.<br>&gt; <br>&gt; I think it would have the same resiliency as if-let, since I was envisioning this to just be syntactic sugar for a switch statement. That is, this:<br>&gt; if foo is .Result { //`foo` refers to foo&#39;s associated or raw value within the following code block<br>&gt;    //code block<br>&gt; }<br>&gt; would get rewritten to this, for enums with associated values:<br>&gt; switchfoo {<br>&gt; case .Result(let foo): //we get a local copy of `foo` (the associated value) for the following code block<br>&gt;    //code block<br>&gt; default: break<br>&gt; }<br>&gt; or this, for enums with raw values:<br>&gt; switchfoo {<br>&gt; case .Result:<br>&gt;    let _foo = foo.rawValue //the compiler substitutes `_foo` for `foo`<br>&gt;    //code block<br>&gt; default: break<br>&gt; }<br>&gt; <br>&gt; There’d have to be some more auto-generated code to copy assigned values back into the original `foo`, but I don’t think it’d be hard to do.<br>&gt; <br>&gt; - Dave Sweeris<br>&gt; <br>&gt; <br>&gt; Ah yes, that makes sense. So how do you see the compiler dealing with the assignment/access problem on structs? If you assign to foo, the compiler assigns to both “_foo” and “foo”?<br>&gt; <br>&gt; I wonder if we’re pushing down the road of convenience at the expense of truth. The if/guard let syntax is clear that you’re getting a separate reference or copy, but what you’re suggesting is hiding the reality from the user for what I see as relatively little convenience.<br>&gt; <br>&gt; This is not to say I don’t see the problem, or the convenience… I just wonder if this might be going a little too far.<br>&gt; <br>&gt; - Rod<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e9b374b9587bd8da1a1a027c8716ac0d?s=50"></div><header><strong>Auto Unwrapping Of Optionals</strong> from <string>Rod Brown</string> &lt;rodney.brown6 at icloud.com&gt;<p>May  3, 2016 at 06:00:00am</p></header><div class="content"><p>Wow, I&#39;m really sad I missed this while I was writing my last response!<br></p><p>I completely agree with this, and that is a much better solution than the ones previously suggested.<br></p><p>- Rod<br></p><p><br>&gt; On 3 May 2016, at 6:16 AM, David Waite &lt;david at alkaline-solutions.com&gt; wrote:<br>&gt; <br>&gt; It is a bad idea to have the compiler change the interpretation of a type without some hard and fast rules; the compiler’s interpretation of the optionality of your code will result in your code being legal or not.<br>&gt; <br>&gt; In terms of solutions, I would prefer something similar to a guard statement that, rather than exiting, shadows a constant or variable with a non-optional equivalent type, e.g.<br>&gt; <br>&gt; shadow var today = today ?? NSDate()<br>&gt; let timeInterval = today.timeIntervalSinceNow<br>&gt; <br>&gt; -DW<br>&gt; <br>&gt;&gt; On May 2, 2016, at 1:27 PM, Tod Cunningham via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &quot;I wonder if we’re pushing down the road of convenience at the expense of truth. The if/guard let syntax is clear that you’re getting a separate reference or copy, but what you’re suggesting is hiding the reality from the user for what I see as relatively little convenience.&quot;<br>&gt;&gt; <br>&gt;&gt; It just might be me trying to avoid using !, and especially avoid implicit unwrapped options.  While there is nothing wrong with the following code it makes me very uncomfortable from a defensive programming point of view:<br>&gt;&gt; <br>&gt;&gt;       today = today ?? NSDate()<br>&gt;&gt;       let timeInterval = today!.timeIntervalSinceNow<br>&gt;&gt; <br>&gt;&gt; Some developer coming along and changing the code could easily introduce a crash, such as by removing the default value.  In the above example, such a change wouldn’t introduce a compiler warning/error and the bug might not reveal itself until a much later.<br>&gt;&gt; <br>&gt;&gt; Also using if-let or guard also doesn’t seem right, in this case, as it should never fail:<br>&gt;&gt; <br>&gt;&gt;  today = today ?? NSDate()   // self.today changed!<br>&gt;&gt;  if let today = today {<br>&gt;&gt;     let timeInterval: NSTimeInterval = today!.timeIntervalSinceNow<br>&gt;&gt;  } else {<br>&gt;&gt;     assertFailure()<br>&gt;&gt;  }<br>&gt;&gt; <br>&gt;&gt; Same issue with guard:<br>&gt;&gt; <br>&gt;&gt;  today = today ?? NSDate()   // self.today changed!<br>&gt;&gt;  guard let today = today else {<br>&gt;&gt;     assertFailure()<br>&gt;&gt;     return //  that should never happen<br>&gt;&gt;  }<br>&gt;&gt;  let timeInterval: NSTimeInterval = today!.timeIntervalSinceNow<br>&gt;&gt; <br>&gt;&gt; This introduces code that just gets in the way of the code’s meaning for cases that should never happen.  Yuck, there has to be a better way!<br>&gt;&gt; <br>&gt;&gt; - Tod<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; From: &lt;swift-evolution-bounces at swift.org&lt;mailto:swift-evolution-bounces at swift.org&gt;&gt; on behalf of Rod Brown via swift-evolution &lt;swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; Reply-To: Rod Brown &lt;rodney.brown6 at icloud.com&lt;mailto:rodney.brown6 at icloud.com&gt;&gt;<br>&gt;&gt; Date: Sunday, May 1, 2016 at 1:25 AM<br>&gt;&gt; To: David Sweeris &lt;davesweeris at mac.com&lt;mailto:davesweeris at mac.com&gt;&gt;<br>&gt;&gt; Cc: Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; Subject: Re: [swift-evolution] Auto Unwrapping Of Optionals<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On 1 May 2016, at 3:00 PM, David Sweeris &lt;davesweeris at mac.com&lt;mailto:davesweeris at mac.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Apr 30, 2016, at 5:42 PM, Rod Brown &lt;rodney.brown6 at icloud.com&lt;mailto:rodney.brown6 at icloud.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Re-sent for Swift Evolution. Response at end.<br>&gt;&gt; <br>&gt;&gt; On 1 May 2016, at 6:31 AM, David Sweeris &lt;davesweeris at mac.com&lt;mailto:davesweeris at mac.com&gt;&gt; wrote:<br>&gt;&gt; I think your idea makes a lot more sense in respect to ensuring we don&#39;t have as much magic.<br>&gt;&gt; <br>&gt;&gt; That said, I still wonder about the implications for thread safety etc. While it isn&#39;t a focus of Swift 3, it&#39;s something to think about whether this promotes a paradigm that cannot be supported in a threaded environment, specifically accessing properties.<br>&gt;&gt; <br>&gt;&gt; The if-let paradigm is a lot stronger for this set of actions. It gains a separate reference or copy to the internal value, and allows you to action it safely. Should the property change in the meantime, it isn&#39;t relevant, because you have you own reference/copy, and then you have the right to re-set the property as required.<br>&gt;&gt; <br>&gt;&gt; This, however, would theoretically add in an invisible ! for you. This leaves you unable to handle the situation should the variable have been changed by another thread between your check and your subsequent action.<br>&gt;&gt; <br>&gt;&gt; Unless I&#39;m missing something, I worry about the behaviour of such a &quot;feature&quot; in a multithreaded environment. I think the previous &quot;inout&quot; idea actually held a lot more weight in this regard - at least then you can act on the copy, and have the change propagate to the main declaration, and overwrite any changes made on another thread.<br>&gt;&gt; <br>&gt;&gt; I think it would have the same resiliency as if-let, since I was envisioning this to just be syntactic sugar for a switch statement. That is, this:<br>&gt;&gt; if foo is .Result { //`foo` refers to foo&#39;s associated or raw value within the following code block<br>&gt;&gt;   //code block<br>&gt;&gt; }<br>&gt;&gt; would get rewritten to this, for enums with associated values:<br>&gt;&gt; switchfoo {<br>&gt;&gt; case .Result(let foo): //we get a local copy of `foo` (the associated value) for the following code block<br>&gt;&gt;   //code block<br>&gt;&gt; default: break<br>&gt;&gt; }<br>&gt;&gt; or this, for enums with raw values:<br>&gt;&gt; switchfoo {<br>&gt;&gt; case .Result:<br>&gt;&gt;   let _foo = foo.rawValue //the compiler substitutes `_foo` for `foo`<br>&gt;&gt;   //code block<br>&gt;&gt; default: break<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; There’d have to be some more auto-generated code to copy assigned values back into the original `foo`, but I don’t think it’d be hard to do.<br>&gt;&gt; <br>&gt;&gt; - Dave Sweeris<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Ah yes, that makes sense. So how do you see the compiler dealing with the assignment/access problem on structs? If you assign to foo, the compiler assigns to both “_foo” and “foo”?<br>&gt;&gt; <br>&gt;&gt; I wonder if we’re pushing down the road of convenience at the expense of truth. The if/guard let syntax is clear that you’re getting a separate reference or copy, but what you’re suggesting is hiding the reality from the user for what I see as relatively little convenience.<br>&gt;&gt; <br>&gt;&gt; This is not to say I don’t see the problem, or the convenience… I just wonder if this might be going a little too far.<br>&gt;&gt; <br>&gt;&gt; - Rod<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/18be32aa5ee2c4aa6ba2f23cf6ac42f7?s=50"></div><header><strong>Auto Unwrapping Of Optionals</strong> from <string>Tod Cunningham</string> &lt;tcunningham at vectorform.com&gt;<p>May  2, 2016 at 09:00:00pm</p></header><div class="content"><p>+1 on the shadow variable idea.  What an awesome idea.<br></p><p>- Tod<br></p><p><br></p><p><br></p><p>On 5/2/16, 4:41 PM, &quot;Rod Brown&quot; &lt;rodney.brown6 at icloud.com&gt; wrote:<br></p><p>&gt;Wow, I&#39;m really sad I missed this while I was writing my last response!<br>&gt;<br>&gt;I completely agree with this, and that is a much better solution than the ones previously suggested.<br>&gt;<br>&gt;- Rod<br>&gt;<br>&gt;<br>&gt;&gt; On 3 May 2016, at 6:16 AM, David Waite &lt;david at alkaline-solutions.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; It is a bad idea to have the compiler change the interpretation of a type without some hard and fast rules; the compiler’s interpretation of the optionality of your code will result in your code being legal or not.<br>&gt;&gt; <br>&gt;&gt; In terms of solutions, I would prefer something similar to a guard statement that, rather than exiting, shadows a constant or variable with a non-optional equivalent type, e.g.<br>&gt;&gt; <br>&gt;&gt; shadow var today = today ?? NSDate()<br>&gt;&gt; let timeInterval = today.timeIntervalSinceNow<br>&gt;&gt; <br>&gt;&gt; -DW<br>&gt;&gt; <br>&gt;&gt;&gt; On May 2, 2016, at 1:27 PM, Tod Cunningham via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &quot;I wonder if we’re pushing down the road of convenience at the expense of truth. The if/guard let syntax is clear that you’re getting a separate reference or copy, but what you’re suggesting is hiding the reality from the user for what I see as relatively little convenience.&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It just might be me trying to avoid using !, and especially avoid implicit unwrapped options.  While there is nothing wrong with the following code it makes me very uncomfortable from a defensive programming point of view:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       today = today ?? NSDate()<br>&gt;&gt;&gt;       let timeInterval = today!.timeIntervalSinceNow<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Some developer coming along and changing the code could easily introduce a crash, such as by removing the default value.  In the above example, such a change wouldn’t introduce a compiler warning/error and the bug might not reveal itself until a much later.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Also using if-let or guard also doesn’t seem right, in this case, as it should never fail:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  today = today ?? NSDate()   // self.today changed!<br>&gt;&gt;&gt;  if let today = today {<br>&gt;&gt;&gt;     let timeInterval: NSTimeInterval = today!.timeIntervalSinceNow<br>&gt;&gt;&gt;  } else {<br>&gt;&gt;&gt;     assertFailure()<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Same issue with guard:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  today = today ?? NSDate()   // self.today changed!<br>&gt;&gt;&gt;  guard let today = today else {<br>&gt;&gt;&gt;     assertFailure()<br>&gt;&gt;&gt;     return //  that should never happen<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt;  let timeInterval: NSTimeInterval = today!.timeIntervalSinceNow<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This introduces code that just gets in the way of the code’s meaning for cases that should never happen.  Yuck, there has to be a better way!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Tod<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; From: &lt;swift-evolution-bounces at swift.org&lt;mailto:swift-evolution-bounces at swift.org&gt;&gt; on behalf of Rod Brown via swift-evolution &lt;swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt; Reply-To: Rod Brown &lt;rodney.brown6 at icloud.com&lt;mailto:rodney.brown6 at icloud.com&gt;&gt;<br>&gt;&gt;&gt; Date: Sunday, May 1, 2016 at 1:25 AM<br>&gt;&gt;&gt; To: David Sweeris &lt;davesweeris at mac.com&lt;mailto:davesweeris at mac.com&gt;&gt;<br>&gt;&gt;&gt; Cc: Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt; Subject: Re: [swift-evolution] Auto Unwrapping Of Optionals<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 1 May 2016, at 3:00 PM, David Sweeris &lt;davesweeris at mac.com&lt;mailto:davesweeris at mac.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Apr 30, 2016, at 5:42 PM, Rod Brown &lt;rodney.brown6 at icloud.com&lt;mailto:rodney.brown6 at icloud.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Re-sent for Swift Evolution. Response at end.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 1 May 2016, at 6:31 AM, David Sweeris &lt;davesweeris at mac.com&lt;mailto:davesweeris at mac.com&gt;&gt; wrote:<br>&gt;&gt;&gt; I think your idea makes a lot more sense in respect to ensuring we don&#39;t have as much magic.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That said, I still wonder about the implications for thread safety etc. While it isn&#39;t a focus of Swift 3, it&#39;s something to think about whether this promotes a paradigm that cannot be supported in a threaded environment, specifically accessing properties.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The if-let paradigm is a lot stronger for this set of actions. It gains a separate reference or copy to the internal value, and allows you to action it safely. Should the property change in the meantime, it isn&#39;t relevant, because you have you own reference/copy, and then you have the right to re-set the property as required.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This, however, would theoretically add in an invisible ! for you. This leaves you unable to handle the situation should the variable have been changed by another thread between your check and your subsequent action.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Unless I&#39;m missing something, I worry about the behaviour of such a &quot;feature&quot; in a multithreaded environment. I think the previous &quot;inout&quot; idea actually held a lot more weight in this regard - at least then you can act on the copy, and have the change propagate to the main declaration, and overwrite any changes made on another thread.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think it would have the same resiliency as if-let, since I was envisioning this to just be syntactic sugar for a switch statement. That is, this:<br>&gt;&gt;&gt; if foo is .Result { //`foo` refers to foo&#39;s associated or raw value within the following code block<br>&gt;&gt;&gt;   //code block<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; would get rewritten to this, for enums with associated values:<br>&gt;&gt;&gt; switchfoo {<br>&gt;&gt;&gt; case .Result(let foo): //we get a local copy of `foo` (the associated value) for the following code block<br>&gt;&gt;&gt;   //code block<br>&gt;&gt;&gt; default: break<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; or this, for enums with raw values:<br>&gt;&gt;&gt; switchfoo {<br>&gt;&gt;&gt; case .Result:<br>&gt;&gt;&gt;   let _foo = foo.rawValue //the compiler substitutes `_foo` for `foo`<br>&gt;&gt;&gt;   //code block<br>&gt;&gt;&gt; default: break<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There’d have to be some more auto-generated code to copy assigned values back into the original `foo`, but I don’t think it’d be hard to do.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Dave Sweeris<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Ah yes, that makes sense. So how do you see the compiler dealing with the assignment/access problem on structs? If you assign to foo, the compiler assigns to both “_foo” and “foo”?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I wonder if we’re pushing down the road of convenience at the expense of truth. The if/guard let syntax is clear that you’re getting a separate reference or copy, but what you’re suggesting is hiding the reality from the user for what I see as relatively little convenience.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is not to say I don’t see the problem, or the convenience… I just wonder if this might be going a little too far.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Rod<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2b74cd4039f0c53145a186868ab569c0?s=50"></div><header><strong>Auto Unwrapping Of Optionals</strong> from <string>Josh Parmenter</string> &lt;jparmenter at vectorform.com&gt;<p>May  2, 2016 at 09:00:00pm</p></header><div class="content"><p>yes - that is a wonderful syntax addition in my opinion.<br>Josh<br></p><p>&gt; On May 2, 2016, at 2:08 PM, Tod Cunningham via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; +1 on the shadow variable idea.  What an awesome idea.<br>&gt; <br>&gt; - Tod<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; On 5/2/16, 4:41 PM, &quot;Rod Brown&quot; &lt;rodney.brown6 at icloud.com&gt; wrote:<br>&gt; <br>&gt;&gt; Wow, I&#39;m really sad I missed this while I was writing my last response!<br>&gt;&gt; <br>&gt;&gt; I completely agree with this, and that is a much better solution than the ones previously suggested.<br>&gt;&gt; <br>&gt;&gt; - Rod<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 3 May 2016, at 6:16 AM, David Waite &lt;david at alkaline-solutions.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It is a bad idea to have the compiler change the interpretation of a type without some hard and fast rules; the compiler’s interpretation of the optionality of your code will result in your code being legal or not.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In terms of solutions, I would prefer something similar to a guard statement that, rather than exiting, shadows a constant or variable with a non-optional equivalent type, e.g.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; shadow var today = today ?? NSDate()<br>&gt;&gt;&gt; let timeInterval = today.timeIntervalSinceNow<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -DW<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 2, 2016, at 1:27 PM, Tod Cunningham via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &quot;I wonder if we’re pushing down the road of convenience at the expense of truth. The if/guard let syntax is clear that you’re getting a separate reference or copy, but what you’re suggesting is hiding the reality from the user for what I see as relatively little convenience.&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It just might be me trying to avoid using !, and especially avoid implicit unwrapped options.  While there is nothing wrong with the following code it makes me very uncomfortable from a defensive programming point of view:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;      today = today ?? NSDate()<br>&gt;&gt;&gt;&gt;      let timeInterval = today!.timeIntervalSinceNow<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Some developer coming along and changing the code could easily introduce a crash, such as by removing the default value.  In the above example, such a change wouldn’t introduce a compiler warning/error and the bug might not reveal itself until a much later.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Also using if-let or guard also doesn’t seem right, in this case, as it should never fail:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; today = today ?? NSDate()   // self.today changed!<br>&gt;&gt;&gt;&gt; if let today = today {<br>&gt;&gt;&gt;&gt;    let timeInterval: NSTimeInterval = today!.timeIntervalSinceNow<br>&gt;&gt;&gt;&gt; } else {<br>&gt;&gt;&gt;&gt;    assertFailure()<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Same issue with guard:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; today = today ?? NSDate()   // self.today changed!<br>&gt;&gt;&gt;&gt; guard let today = today else {<br>&gt;&gt;&gt;&gt;    assertFailure()<br>&gt;&gt;&gt;&gt;    return //  that should never happen<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; let timeInterval: NSTimeInterval = today!.timeIntervalSinceNow<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This introduces code that just gets in the way of the code’s meaning for cases that should never happen.  Yuck, there has to be a better way!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Tod<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; From: &lt;swift-evolution-bounces at swift.org&lt;mailto:swift-evolution-bounces at swift.org&gt;&gt; on behalf of Rod Brown via swift-evolution &lt;swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt; Reply-To: Rod Brown &lt;rodney.brown6 at icloud.com&lt;mailto:rodney.brown6 at icloud.com&gt;&gt;<br>&gt;&gt;&gt;&gt; Date: Sunday, May 1, 2016 at 1:25 AM<br>&gt;&gt;&gt;&gt; To: David Sweeris &lt;davesweeris at mac.com&lt;mailto:davesweeris at mac.com&gt;&gt;<br>&gt;&gt;&gt;&gt; Cc: Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt; Subject: Re: [swift-evolution] Auto Unwrapping Of Optionals<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 1 May 2016, at 3:00 PM, David Sweeris &lt;davesweeris at mac.com&lt;mailto:davesweeris at mac.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Apr 30, 2016, at 5:42 PM, Rod Brown &lt;rodney.brown6 at icloud.com&lt;mailto:rodney.brown6 at icloud.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Re-sent for Swift Evolution. Response at end.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 1 May 2016, at 6:31 AM, David Sweeris &lt;davesweeris at mac.com&lt;mailto:davesweeris at mac.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; I think your idea makes a lot more sense in respect to ensuring we don&#39;t have as much magic.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That said, I still wonder about the implications for thread safety etc. While it isn&#39;t a focus of Swift 3, it&#39;s something to think about whether this promotes a paradigm that cannot be supported in a threaded environment, specifically accessing properties.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The if-let paradigm is a lot stronger for this set of actions. It gains a separate reference or copy to the internal value, and allows you to action it safely. Should the property change in the meantime, it isn&#39;t relevant, because you have you own reference/copy, and then you have the right to re-set the property as required.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This, however, would theoretically add in an invisible ! for you. This leaves you unable to handle the situation should the variable have been changed by another thread between your check and your subsequent action.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Unless I&#39;m missing something, I worry about the behaviour of such a &quot;feature&quot; in a multithreaded environment. I think the previous &quot;inout&quot; idea actually held a lot more weight in this regard - at least then you can act on the copy, and have the change propagate to the main declaration, and overwrite any changes made on another thread.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think it would have the same resiliency as if-let, since I was envisioning this to just be syntactic sugar for a switch statement. That is, this:<br>&gt;&gt;&gt;&gt; if foo is .Result { //`foo` refers to foo&#39;s associated or raw value within the following code block<br>&gt;&gt;&gt;&gt;  //code block<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; would get rewritten to this, for enums with associated values:<br>&gt;&gt;&gt;&gt; switchfoo {<br>&gt;&gt;&gt;&gt; case .Result(let foo): //we get a local copy of `foo` (the associated value) for the following code block<br>&gt;&gt;&gt;&gt;  //code block<br>&gt;&gt;&gt;&gt; default: break<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; or this, for enums with raw values:<br>&gt;&gt;&gt;&gt; switchfoo {<br>&gt;&gt;&gt;&gt; case .Result:<br>&gt;&gt;&gt;&gt;  let _foo = foo.rawValue //the compiler substitutes `_foo` for `foo`<br>&gt;&gt;&gt;&gt;  //code block<br>&gt;&gt;&gt;&gt; default: break<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There’d have to be some more auto-generated code to copy assigned values back into the original `foo`, but I don’t think it’d be hard to do.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Dave Sweeris<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Ah yes, that makes sense. So how do you see the compiler dealing with the assignment/access problem on structs? If you assign to foo, the compiler assigns to both “_foo” and “foo”?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I wonder if we’re pushing down the road of convenience at the expense of truth. The if/guard let syntax is clear that you’re getting a separate reference or copy, but what you’re suggesting is hiding the reality from the user for what I see as relatively little convenience.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is not to say I don’t see the problem, or the convenience… I just wonder if this might be going a little too far.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Rod<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e9b374b9587bd8da1a1a027c8716ac0d?s=50"></div><header><strong>Auto Unwrapping Of Optionals</strong> from <string>Rod Brown</string> &lt;rodney.brown6 at icloud.com&gt;<p>May  3, 2016 at 06:00:00am</p></header><div class="content"><p>Yeah, I definitely see your concerns about such code.<br></p><p>That said, unless the compiler does a lot of rearranging under the covers, all you&#39;re asking he compiler to do is to hide the ! for you, which is something you should be aware of. If the compiler does the rearrangement, you&#39;re asking for two references or copies to be held while you do what you do. Additionally, the compiler could actually start doing so when your don&#39;t want it to. It could end up with another class of bugs where:<br></p><p>1. You assign to the variable<br>2. Another thread updates it<br>3. Later in the same method as the first assignment, you rely on that value being correct, but it&#39;s only a reference to the initial assignment, not truth.<br></p><p>Writing code that incorrectly states the truth about the value within a property to add safety will itself remove other types of safety.<br></p><p>There are easy ways to handle the unsafe case you proposed that don&#39;t rely on this update, which is to assign to a local variable, update the property, and act on the local variable.<br></p><p>let today: NSDate = self.today ?? NSDate()<br>let timeInterval = today.timeIntervalSinceNow<br>self.today = today<br></p><p>I think making the compiler rewrite your code in a way that changes the semantics of what you wrote to avoid this defensive programming technique ends up causing more problems than it solves. It would also make your code factually incorrect: you wouldn&#39;t be dealing with self.today, as your code would suggest, but a local reference (or copy in Swift 3).<br></p><p><br>&gt; On 3 May 2016, at 5:27 AM, Tod Cunningham &lt;tcunningham at vectorform.com&gt; wrote:<br>&gt; <br>&gt; &quot;I wonder if we’re pushing down the road of convenience at the expense of truth. The if/guard let syntax is clear that you’re getting a separate reference or copy, but what you’r suggesting is hiding the reality from the user for what I see as relatively little convenience.&quot;<br>&gt; <br>&gt; It just might be me trying to avoid using !, and especially avoid implicit unwrapped options.  While there is nothing wrong with the following code it makes me very uncomfortable from a defensive programming point of view:<br>&gt; <br>&gt;        today = today ?? NSDate()<br>&gt;        let timeInterval = today!.timeIntervalSinceNow<br>&gt; <br>&gt; Some developer coming along and changing the code could easily introduce a crash, such as by removing the default value.  In the above example, such a change wouldn’t introduce a compiler warning/error and the bug might not reveal itself until a much later.<br>&gt; <br>&gt; Also using if-let or guard also doesn’t seem right, in this case, as it should never fail:<br>&gt; <br>&gt;   today = today ?? NSDate()   // self.today changed!<br>&gt;   if let today = today {<br>&gt;      let timeInterval: NSTimeInterval = today!.timeIntervalSinceNow<br>&gt;   } else {<br>&gt;      assertFailure()<br>&gt;   }<br>&gt; <br>&gt; Same issue with guard:<br>&gt; <br>&gt;   today = today ?? NSDate()   // self.today changed!<br>&gt;   guard let today = today else {<br>&gt;      assertFailure()<br>&gt;      return //  that should never happen<br>&gt;   }<br>&gt;   let timeInterval: NSTimeInterval = today!.timeIntervalSinceNow<br>&gt; <br>&gt; This introduces code that just gets in the way of the code’s meaning for cases that should never happen.  Yuck, there has to be a better way!<br>&gt; <br>&gt; - Tod<br>&gt; <br>&gt; <br>&gt; <br>&gt; From: &lt;swift-evolution-bounces at swift.org&lt;mailto:swift-evolution-bounces at swift.org&gt;&gt; on behalf of Rod Brown via swift-evolution &lt;swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt; Reply-To: Rod Brown &lt;rodney.brown6 at icloud.com&lt;mailto:rodney.brown6 at icloud.com&gt;&gt;<br>&gt; Date: Sunday, May 1, 2016 at 1:25 AM<br>&gt; To: David Sweeris &lt;davesweeris at mac.com&lt;mailto:davesweeris at mac.com&gt;&gt;<br>&gt; Cc: Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt; Subject: Re: [swift-evolution] Auto Unwrapping Of Optionals<br>&gt; <br>&gt; <br>&gt; On 1 May 2016, at 3:00 PM, David Sweeris &lt;davesweeris at mac.com&lt;mailto:davesweeris at mac.com&gt;&gt; wrote:<br>&gt; <br>&gt; On Apr 30, 2016, at 5:42 PM, Rod Brown &lt;rodney.brown6 at icloud.com&lt;mailto:rodney.brown6 at icloud.com&gt;&gt; wrote:<br>&gt; <br>&gt; Re-sent for Swift Evolution. Response at end.<br>&gt; <br>&gt; On 1 May 2016, at 6:31 AM, David Sweeris &lt;davesweeris at mac.com&lt;mailto:davesweeris at mac.com&gt;&gt; wrote:<br>&gt; I think your idea makes a lot more sense in respect to ensuring we don&#39;t have as much magic.<br>&gt; <br>&gt; That said, I still wonder about the implications for thread safety etc. While it isn&#39;t a focus of Swift 3, it&#39;s something to think about whether this promotes a paradigm that cannot be supported in a threaded environment, specifically accessing properties.<br>&gt; <br>&gt; The if-let paradigm is a lot stronger for this set of actions. It gains a separate reference or copy to the internal value, and allows you to action it safely. Should the property change in the meantime, it isn&#39;t relevant, because you have you own reference/copy, and then you have the right to re-set the property as required.<br>&gt; <br>&gt; This, however, would theoretically add in an invisible ! for you. This leaves you unable to handle the situation should the variable have been changed by another thread between your check and your subsequent action.<br>&gt; <br>&gt; Unless I&#39;m missing something, I worry about the behaviour of such a &quot;feature&quot; in a multithreaded environment. I think the previous &quot;inout&quot; idea actually held a lot more weight in this regard - at least then you can act on the copy, and have the change propagate to the main declaration, and overwrite any changes made on another thread.<br>&gt; <br>&gt; I think it would have the same resiliency as if-let, since I was envisioning this to just be syntactic sugar for a switch statement. That is, this:<br>&gt; if foo is .Result { //`foo` refers to foo&#39;s associated or raw value within the following code block<br>&gt;    //code block<br>&gt; }<br>&gt; would get rewritten to this, for enums with associated values:<br>&gt; switchfoo {<br>&gt; case .Result(let foo): //we get a local copy of `foo` (the associated value) for the following code block<br>&gt;    //code block<br>&gt; default: break<br>&gt; }<br>&gt; or this, for enums with raw values:<br>&gt; switchfoo {<br>&gt; case .Result:<br>&gt;    let _foo = foo.rawValue //the compiler substitutes `_foo` for `foo`<br>&gt;    //code block<br>&gt; default: break<br>&gt; }<br>&gt; <br>&gt; There’d have to be some more auto-generated code to copy assigned values back into the original `foo`, but I don’t think it’d be hard to do.<br>&gt; <br>&gt; - Dave Sweeris<br>&gt; <br>&gt; <br>&gt; Ah yes, that makes sense. So how do you see the compiler dealing with the assignment/access problem on structs? If you assign to foo, the compiler assigns to both “_foo” and “foo”?<br>&gt; <br>&gt; I wonder if we’re pushing down the road of convenience at the expense of truth. The if/guard let syntax is clear that you’re getting a separate reference or copy, but what you’re suggesting is hiding the reality from the user for what I see as relatively little convenience.<br>&gt; <br>&gt; This is not to say I don’t see the problem, or the convenience… I just wonder if this might be going a little too far.<br>&gt; <br>&gt; - Rod<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160503/df72804e/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7411024ff3fb3fdbb0624c41b72a1b92?s=50"></div><header><strong>Auto Unwrapping Of Optionals</strong> from <string>Alan Skipp</string> &lt;al_skipp at icloud.com&gt;<p>April 30, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On 29 Apr 2016, at 15:37, Tod Cunningham via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This concept of Auto Unwrapping of Optionals is similar to Implicitly Unwrapped Optionals, but is only applied when the compiler knows it is safe to do so.<br>&gt; <br>&gt; Take the following example:<br>&gt; <br>&gt; class Test {<br>&gt;    var today: NSDate? = nil<br>&gt;    func test() {<br>&gt;        today = today ?? NSDate()<br>&gt;        print(&quot;Today is \(today)&quot;)   // Would be printed as an optional<br>&gt;        let timeInterval: NSTimeInterval = today!.timeIntervalSinceNow  // Requires ! or (if let) to unwrap<br>&gt;        // ... do stuff with timeInterval ...<br>&gt;    }<br>&gt; }<br></p><p>I can’t say I’m keen on adding further compiler magic to Optionals, each special case adds further complication to the concept.<br></p><p>An alternative take on the example code posted would be: should the property be an Optional? If there is an Optional property which can later be replaced with a default value (today = today ?? NSDate()), perhaps the property should have been assigned the default non-optional value to begin with? Avoiding having to deal with the ceremony of Optionals all together.<br></p><p>I appreciate that the example code you posted was a succinct way to demonstrate the use case you had in mind and not meant as a `real world` case, but it does highlight that if a property has a valid default value, it probably shouldn’t be an Optional. The great thing about Optionals is that there’s the choice to avoid them as much as possible : )<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
