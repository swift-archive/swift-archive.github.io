<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8809800aec2460f291384b794d7e6f8f?s=50"></div><header><strong>Why can&#39;t Swift instance methods call class methods without qualification?</strong> from <string>Rick Mann</string> &lt;rmann at latencyzero.com&gt;<p>June 30, 2016 at 05:00:00pm</p></header><div class="content"><p>Why can my instance methods not call class methods without the class specifier?<br></p><p>class MyClass<br>{<br>   func<br>   foo()<br>   {<br>       classMethod()<br>   }<br></p><p>   class<br>   func<br>   classMethod()<br>   {<br>   }<br>}<br></p><p>Why do I have to call MyClass.classMethod()? Just a choice made by the language designers to distinguish the call at the call site? I like C++&#39;s way of treating all static methods as directly available to the instance.<br></p><p>-- <br>Rick Mann<br>rmann at latencyzero.com<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/957b675456a66c394945a7361aedd51d?s=50"></div><header><strong>Why can&#39;t Swift instance methods call class methods without qualification?</strong> from <string>Zhao Xin</string> &lt;owenzx at gmail.com&gt;<p>July  1, 2016 at 09:00:00am</p></header><div class="content"><p>Just a choice made by the language designers to distinguish the call at the<br>call site.<br></p><p>You should be aware of using static methods as it may change static<br>variables, which affects all instances of that class. Normally I think<br>static methods is designed to use outside the class instance, if you have<br>to use it inside its instance method. You may need to rethink the pattern<br>you do.<br></p><p>Zhaoxin<br></p><p>On Fri, Jul 1, 2016 at 8:59 AM, Rick Mann via swift-users &lt;<br>swift-users at swift.org&gt; wrote:<br></p><p>&gt; Why can my instance methods not call class methods without the class<br>&gt; specifier?<br>&gt;<br>&gt; class MyClass<br>&gt; {<br>&gt;    func<br>&gt;    foo()<br>&gt;    {<br>&gt;        classMethod()<br>&gt;    }<br>&gt;<br>&gt;    class<br>&gt;    func<br>&gt;    classMethod()<br>&gt;    {<br>&gt;    }<br>&gt; }<br>&gt;<br>&gt; Why do I have to call MyClass.classMethod()? Just a choice made by the<br>&gt; language designers to distinguish the call at the call site? I like C++&#39;s<br>&gt; way of treating all static methods as directly available to the instance.<br>&gt;<br>&gt; --<br>&gt; Rick Mann<br>&gt; rmann at latencyzero.com<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160701/3fb175bc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8809800aec2460f291384b794d7e6f8f?s=50"></div><header><strong>Why can&#39;t Swift instance methods call class methods without qualification?</strong> from <string>Rick Mann</string> &lt;rmann at latencyzero.com&gt;<p>June 30, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Jun 30, 2016, at 18:47 , zh ao &lt;owenzx at gmail.com&gt; wrote:<br>&gt; <br>&gt; Just a choice made by the language designers to distinguish the call at the call site. <br>&gt; <br>&gt; You should be aware of using static methods as it may change static variables, which affects all instances of that class. Normally I think static methods is designed to use outside the class instance, if you have to use it inside its instance method. You may need to rethink the pattern you do. <br></p><p>I think of static methods as applying to all instances, and so code them to &quot;behave properly&quot; no matter how they&#39;re called (since I can&#39;t really control who calls it, unless it&#39;s my own class). Since it&#39;s implicitly obvious (to me) that I mean &quot;this class&quot; when I call one, I find it a bit tedious qualify the call with the class name.<br></p><p>It&#39;s fine, in the end, but I was curious why it was like this, and if there was a more obvious reason why it needed the qualification.<br></p><p>&gt; <br>&gt; Zhaoxin<br>&gt; <br>&gt; On Fri, Jul 1, 2016 at 8:59 AM, Rick Mann via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; Why can my instance methods not call class methods without the class specifier?<br>&gt; <br>&gt; class MyClass<br>&gt; {<br>&gt;    func<br>&gt;    foo()<br>&gt;    {<br>&gt;        classMethod()<br>&gt;    }<br>&gt; <br>&gt;    class<br>&gt;    func<br>&gt;    classMethod()<br>&gt;    {<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; Why do I have to call MyClass.classMethod()? Just a choice made by the language designers to distinguish the call at the call site? I like C++&#39;s way of treating all static methods as directly available to the instance.<br>&gt; <br>&gt; --<br>&gt; Rick Mann<br>&gt; rmann at latencyzero.com<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt; <br></p><p><br>-- <br>Rick Mann<br>rmann at latencyzero.com<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Why can&#39;t Swift instance methods call class methods without qualification?</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>June 30, 2016 at 09:00:00pm</p></header><div class="content"><p>I&#39;m pretty sure you can have instance and static methods with the same name. Requiring `Type.foo()` instead of just `foo()` would tell the compiler which one you want.<br></p><p>- Dave Sweeris<br></p><p>&gt; On Jun 30, 2016, at 21:01, Rick Mann via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 30, 2016, at 18:47 , zh ao &lt;owenzx at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Just a choice made by the language designers to distinguish the call at the call site. <br>&gt;&gt; <br>&gt;&gt; You should be aware of using static methods as it may change static variables, which affects all instances of that class. Normally I think static methods is designed to use outside the class instance, if you have to use it inside its instance method. You may need to rethink the pattern you do.<br>&gt; <br>&gt; I think of static methods as applying to all instances, and so code them to &quot;behave properly&quot; no matter how they&#39;re called (since I can&#39;t really control who calls it, unless it&#39;s my own class). Since it&#39;s implicitly obvious (to me) that I mean &quot;this class&quot; when I call one, I find it a bit tedious qualify the call with the class name.<br>&gt; <br>&gt; It&#39;s fine, in the end, but I was curious why it was like this, and if there was a more obvious reason why it needed the qualification.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Zhaoxin<br>&gt;&gt; <br>&gt;&gt; On Fri, Jul 1, 2016 at 8:59 AM, Rick Mann via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt; Why can my instance methods not call class methods without the class specifier?<br>&gt;&gt; <br>&gt;&gt; class MyClass<br>&gt;&gt; {<br>&gt;&gt;   func<br>&gt;&gt;   foo()<br>&gt;&gt;   {<br>&gt;&gt;       classMethod()<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;   class<br>&gt;&gt;   func<br>&gt;&gt;   classMethod()<br>&gt;&gt;   {<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Why do I have to call MyClass.classMethod()? Just a choice made by the language designers to distinguish the call at the call site? I like C++&#39;s way of treating all static methods as directly available to the instance.<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; Rick Mann<br>&gt;&gt; rmann at latencyzero.com<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Rick Mann<br>&gt; rmann at latencyzero.com<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/957b675456a66c394945a7361aedd51d?s=50"></div><header><strong>Why can&#39;t Swift instance methods call class methods without qualification?</strong> from <string>Zhao Xin</string> &lt;owenzx at gmail.com&gt;<p>July  1, 2016 at 12:00:00pm</p></header><div class="content"><p>Swift has its own suggested patterns on calling methods. For example, it<br>suggests you calling instance methods directly inside class. It also forces<br>you calling self.method() in closure that without @noescape. As well as the<br>static method with the class name in your question. Those are different<br>from C++. But it does differ the differences between methods.<br></p><p>Zhaoxin<br></p><p>On Fri, Jul 1, 2016 at 10:01 AM, Rick Mann &lt;rmann at latencyzero.com&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Jun 30, 2016, at 18:47 , zh ao &lt;owenzx at gmail.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Just a choice made by the language designers to distinguish the call at<br>&gt; the call site.<br>&gt; &gt;<br>&gt; &gt; You should be aware of using static methods as it may change static<br>&gt; variables, which affects all instances of that class. Normally I think<br>&gt; static methods is designed to use outside the class instance, if you have<br>&gt; to use it inside its instance method. You may need to rethink the pattern<br>&gt; you do.<br>&gt;<br>&gt; I think of static methods as applying to all instances, and so code them<br>&gt; to &quot;behave properly&quot; no matter how they&#39;re called (since I can&#39;t really<br>&gt; control who calls it, unless it&#39;s my own class). Since it&#39;s implicitly<br>&gt; obvious (to me) that I mean &quot;this class&quot; when I call one, I find it a bit<br>&gt; tedious qualify the call with the class name.<br>&gt;<br>&gt; It&#39;s fine, in the end, but I was curious why it was like this, and if<br>&gt; there was a more obvious reason why it needed the qualification.<br>&gt;<br>&gt; &gt;<br>&gt; &gt; Zhaoxin<br>&gt; &gt;<br>&gt; &gt; On Fri, Jul 1, 2016 at 8:59 AM, Rick Mann via swift-users &lt;<br>&gt; swift-users at swift.org&gt; wrote:<br>&gt; &gt; Why can my instance methods not call class methods without the class<br>&gt; specifier?<br>&gt; &gt;<br>&gt; &gt; class MyClass<br>&gt; &gt; {<br>&gt; &gt;    func<br>&gt; &gt;    foo()<br>&gt; &gt;    {<br>&gt; &gt;        classMethod()<br>&gt; &gt;    }<br>&gt; &gt;<br>&gt; &gt;    class<br>&gt; &gt;    func<br>&gt; &gt;    classMethod()<br>&gt; &gt;    {<br>&gt; &gt;    }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; Why do I have to call MyClass.classMethod()? Just a choice made by the<br>&gt; language designers to distinguish the call at the call site? I like C++&#39;s<br>&gt; way of treating all static methods as directly available to the instance.<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Rick Mann<br>&gt; &gt; rmann at latencyzero.com<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-users mailing list<br>&gt; &gt; swift-users at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt; &gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Rick Mann<br>&gt; rmann at latencyzero.com<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160701/e23fee13/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>Why can&#39;t Swift instance methods call class methods without qualification?</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>July  1, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Jun 30, 2016, at 6:47 PM, zh ao via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; You should be aware of using static methods as it may change static variables, which affects all instances of that class. Normally I think static methods is designed to use outside the class instance, if you have to use it inside its instance method. You may need to rethink the pattern you do. <br></p><p>This doesn’t make any sense to me. All class-based OO languages have static/class methods, so this isn’t specific to Swift. And any method can change static class variables. There’s nothing special about static methods that makes them less suitable for use by instance methods.<br></p><p>—Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160701/7e6fae87/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/957b675456a66c394945a7361aedd51d?s=50"></div><header><strong>Why can&#39;t Swift instance methods call class methods without qualification?</strong> from <string>Zhao Xin</string> &lt;owenzx at gmail.com&gt;<p>July  2, 2016 at 12:00:00am</p></header><div class="content"><p>Swift forces you to use class name to alert you on the fact that static<br>variables and methods (may) affect the other instances of the class as<br>static variables are shared between instances. That does make sense.<br></p><p>Zhaoxin<br></p><p>On Fri, Jul 1, 2016 at 11:57 PM, Jens Alfke &lt;jens at mooseyard.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Jun 30, 2016, at 6:47 PM, zh ao via swift-users &lt;swift-users at swift.org&gt;<br>&gt; wrote:<br>&gt;<br>&gt; You should be aware of using static methods as it may change static<br>&gt; variables, which affects all instances of that class. Normally I think<br>&gt; static methods is designed to use outside the class instance, if you have<br>&gt; to use it inside its instance method. You may need to rethink the pattern<br>&gt; you do.<br>&gt;<br>&gt;<br>&gt; This doesn’t make any sense to me. All class-based OO languages have<br>&gt; static/class methods, so this isn’t specific to Swift. And *any* method<br>&gt; can change static class variables. There’s nothing special about static<br>&gt; methods that makes them less suitable for use by instance methods.<br>&gt;<br>&gt; —Jens<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160702/79346bcc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>Why can&#39;t Swift instance methods call class methods without qualification?</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>July  1, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jul 1, 2016, at 9:38 AM, zh ao &lt;owenzx at gmail.com&gt; wrote:<br>&gt; <br>&gt; Swift forces you to use class name to alert you on the fact that static variables and methods (may) affect the other instances of the class as static variables are shared between instances. That does make sense.<br></p><p>I disagree. Both static and instance methods can affect other instances of the class. In other words, just looking at these two calls:<br>	something()<br>	MyClass.something()<br>there’s no way to tell whether either or both of them change class-wide state. (To spell it out clearly: the implementation of the instance method something() might change the variable MyClass.staticState.)<br></p><p>I think the reasoning behind this syntax is simply to make it easy to distinguish usages of static members (methods or variables) from instance ones.<br></p><p>—Jens<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/957b675456a66c394945a7361aedd51d?s=50"></div><header><strong>Why can&#39;t Swift instance methods call class methods without qualification?</strong> from <string>Zhao Xin</string> &lt;owenzx at gmail.com&gt;<p>July  2, 2016 at 01:00:00am</p></header><div class="content"><p>Your conclusion is the same as mine and you disagree with what I said? :/<br></p><p>mine:<br></p><p>&gt; Swift forces you to use class name to alert you on the fact that static<br>&gt; variables and methods (may) affect the other instances of the class as<br>&gt; static variables are shared between instances. That does make sense.<br></p><p><br>y<br>​ours:<br></p><p>&gt;  I think the reasoning behind this syntax is simply to make it easy to<br>&gt; distinguish usages of static members (methods or variables) from instance<br>&gt; ones.<br></p><p><br>Zhaoxin<br></p><p>On Sat, Jul 2, 2016 at 12:58 AM, Jens Alfke &lt;jens at mooseyard.com&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Jul 1, 2016, at 9:38 AM, zh ao &lt;owenzx at gmail.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Swift forces you to use class name to alert you on the fact that static<br>&gt; variables and methods (may) affect the other instances of the class as<br>&gt; static variables are shared between instances. That does make sense.<br>&gt;<br>&gt; I disagree. Both static and instance methods can affect other instances of<br>&gt; the class. In other words, just looking at these two calls:<br>&gt;         something()<br>&gt;         MyClass.something()<br>&gt; there’s no way to tell whether either or both of them change class-wide<br>&gt; state. (To spell it out clearly: the implementation of the instance method<br>&gt; something() might change the variable MyClass.staticState.)<br>&gt;<br>&gt; I think the reasoning behind this syntax is simply to make it easy to<br>&gt; distinguish usages of static members (methods or variables) from instance<br>&gt; ones.<br>&gt;<br>&gt; —Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160702/6570d39b/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0f0154768aeec561194e651b0bca02d9?s=50"></div><header><strong>Why can&#39;t Swift instance methods call class methods without qualification?</strong> from <string>Dan Loewenherz</string> &lt;dan at lionheartsw.com&gt;<p>July  1, 2016 at 12:00:00pm</p></header><div class="content"><p>On Fri, Jul 1, 2016 at 11:58 AM, Jens Alfke via swift-users<br>&lt;swift-users at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; &gt; On Jul 1, 2016, at 9:38 AM, zh ao &lt;owenzx at gmail.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Swift forces you to use class name to alert you on the fact that static variables and methods (may) affect the other instances of the class as static variables are shared between instances. That does make sense.<br>&gt;<br>&gt; I disagree. Both static and instance methods can affect other instances of the class. In other words, just looking at these two calls:<br>&gt;         something()<br>&gt;         MyClass.something()<br>&gt; there’s no way to tell whether either or both of them change class-wide state. (To spell it out clearly: the implementation of the instance method something() might change the variable MyClass.staticState.)<br>&gt;<br>&gt; I think the reasoning behind this syntax is simply to make it easy to distinguish usages of static members (methods or variables) from instance ones.<br>&gt;<br>&gt; —Jens<br></p><p>I agree. If not for this rule, the compiler would need to enforce<br>uniqueness across type and instance method names. There’s no other way<br>to disambiguate which function you’re trying to call.<br></p><p>Also, keep in mind that something() is syntactic sugar for<br>self.something(), which itself is syntactic sugar for<br>MyClass.something(self)().<br></p><p>If the compiler allowed you to skip MyClass and let you use<br>something() to reference the type method, how can it know that you<br>mean MyClass.something() and not MyClass.something(self)()? Since both<br>functions accept different parameters this behavior would be undefined<br>and you would be unable to use the same name for a type method and<br>instance method on the same type.<br></p><p>Dan<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3eada20d8d86f9b78ef64f570acd29e9?s=50"></div><header><strong>Why can&#39;t Swift instance methods call class methods without qualification?</strong> from <string>Nicholas Outram</string> &lt;nicholas.outram at icloud.com&gt;<p>July  1, 2016 at 06:00:00pm</p></header><div class="content"><p>I personally find the prefix to be consistent and safer.<br></p><p>class methods may mutate &quot;mutable static variables” (singletons), which are dangerous in multi-threaded code. For me, having the class prefix is a reminder and therefore requires additional synchronisation if it is to be invoked safely from multiple threads.<br></p><p><br>Nick<br></p><p><br>&gt; On 1 Jul 2016, at 01:59, Rick Mann via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Why can my instance methods not call class methods without the class specifier?<br>&gt; <br>&gt; class MyClass<br>&gt; {<br>&gt;   func<br>&gt;   foo()<br>&gt;   {<br>&gt;       classMethod()<br>&gt;   }<br>&gt; <br>&gt;   class<br>&gt;   func<br>&gt;   classMethod()<br>&gt;   {<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; Why do I have to call MyClass.classMethod()? Just a choice made by the language designers to distinguish the call at the call site? I like C++&#39;s way of treating all static methods as directly available to the instance.<br>&gt; <br>&gt; -- <br>&gt; Rick Mann<br>&gt; rmann at latencyzero.com<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>Why can&#39;t Swift instance methods call class methods without qualification?</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>July  1, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jul 1, 2016, at 10:28 AM, Nicholas Outram via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; class methods may mutate &quot;mutable static variables” (singletons), which are dangerous in multi-threaded code.<br></p><p>This is the same argument zh ao made. But instance methods may also mutate static variables, so the fact that you’re calling a class method doesn’t make the call any more dangerous.<br></p><p>Moreover, mutating instance variables can be just as dangerous for multithreaded code (and is a more frequent source of bugs IMHO).<br></p><p>Really, the only significant difference is that a class method can’t modify instance variables, so from that perspective it’s actually a bit safer than an instance method call!<br></p><p>—Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160701/cc7d764e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d631f09a3a336a15ae258e01899cb736?s=50"></div><header><strong>Why can&#39;t Swift instance methods call class methods without qualification?</strong> from <string>Kate Stone</string> &lt;k8stone at apple.com&gt;<p>July  1, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jul 1, 2016, at 11:01 AM, Jens Alfke via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 1, 2016, at 10:28 AM, Nicholas Outram via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; class methods may mutate &quot;mutable static variables” (singletons), which are dangerous in multi-threaded code.<br>&gt; <br>&gt; This is the same argument zh ao made. But instance methods may also mutate static variables, so the fact that you’re calling a class method doesn’t make the call any more dangerous.<br>&gt; <br>&gt; Moreover, mutating instance variables can be just as dangerous for multithreaded code (and is a more frequent source of bugs IMHO).<br>&gt; <br>&gt; Really, the only significant difference is that a class method can’t modify instance variables, so from that perspective it’s actually a bit safer than an instance method call!<br></p><p>Though that isn’t strictly true for singleton patterns and other reasons why class variables might include references to instances.<br></p><p>I believe there’s real value in being explicit about referencing class members.  It helps both the reader of the code and it makes writing code with typical IDE conveniences like code completion less cluttered and more informative. Unfamiliar class methods won’t be included in lists of suggestions where they might look like they operate on the current instance.<br></p><p>Kate Stone k8stone at apple.com &lt;mailto:k8stone at apple.com&gt;<br> Xcode Low Level Tools<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160701/0056e6cb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0fb6430f693fc6d384b0734bb59092bf?s=50"></div><header><strong>Why can&#39;t Swift instance methods call class methods without qualification?</strong> from <string>Kerry Hazelgren</string> &lt;hazelgren at me.com&gt;<p>July  1, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jul 1, 2016, at 11:06 AM, Kate Stone via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Jul 1, 2016, at 11:01 AM, Jens Alfke via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 1, 2016, at 10:28 AM, Nicholas Outram via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class methods may mutate &quot;mutable static variables” (singletons), which are dangerous in multi-threaded code.<br>&gt;&gt; <br>&gt;&gt; This is the same argument zh ao made. But instance methods may also mutate static variables, so the fact that you’re calling a class method doesn’t make the call any more dangerous.<br>&gt;&gt; <br>&gt;&gt; Moreover, mutating instance variables can be just as dangerous for multithreaded code (and is a more frequent source of bugs IMHO).<br>&gt;&gt; <br>&gt;&gt; Really, the only significant difference is that a class method can’t modify instance variables, so from that perspective it’s actually a bit safer than an instance method call!<br>&gt; <br>&gt; Though that isn’t strictly true for singleton patterns and other reasons why class variables might include references to instances.<br>&gt; <br>&gt; I believe there’s real value in being explicit about referencing class members.  It helps both the reader of the code and it makes writing code with typical IDE conveniences like code completion less cluttered and more informative. Unfamiliar class methods won’t be included in lists of suggestions where they might look like they operate on the current instance.<br></p><p>I agree. I think that removing the class specifier provides a bit of simplicity but at the cost of ambiguity, which is decidedly not swift-y.<br></p><p>Kerry<br></p><p>&gt; <br>&gt; Kate Stone k8stone at apple.com &lt;mailto:k8stone at apple.com&gt;<br>&gt;  Xcode Low Level Tools<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160701/e5495bf0/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3eada20d8d86f9b78ef64f570acd29e9?s=50"></div><header><strong>Why can&#39;t Swift instance methods call class methods without qualification?</strong> from <string>Nicholas Outram</string> &lt;nicholas.outram at icloud.com&gt;<p>July  3, 2016 at 07:00:00am</p></header><div class="content"><p>Good point.<br></p><p>Again, from an educator perspective, one view is to think of the Class itself as a singleton object in memory, with its own set of iVars and methods that operate upon them. Although declared and defined in one source, when you visualise as objects / relationships in memory, one model is to see each instance as a small island with references back to a common shared singleton object (the class). <br>The prefix seems consistent with this model.<br></p><p>Now this may / may not match reality, but I find it&#39;s helpful to have that clear separation, especially for new learners, and Swift is a good entry language in this respect.<br>(Similarly I like the way closures sometimes force the developer to use the self prefix as well).<br></p><p><br>Sent from my iPad<br></p><p>&gt; On 1 Jul 2016, at 19:06, Kate Stone &lt;k8stone at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Jul 1, 2016, at 11:01 AM, Jens Alfke via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jul 1, 2016, at 10:28 AM, Nicholas Outram via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class methods may mutate &quot;mutable static variables” (singletons), which are dangerous in multi-threaded code.<br>&gt;&gt; <br>&gt;&gt; This is the same argument zh ao made. But instance methods may also mutate static variables, so the fact that you’re calling a class method doesn’t make the call any more dangerous.<br>&gt;&gt; <br>&gt;&gt; Moreover, mutating instance variables can be just as dangerous for multithreaded code (and is a more frequent source of bugs IMHO).<br>&gt;&gt; <br>&gt;&gt; Really, the only significant difference is that a class method can’t modify instance variables, so from that perspective it’s actually a bit safer than an instance method call!<br>&gt; <br>&gt; Though that isn’t strictly true for singleton patterns and other reasons why class variables might include references to instances.<br>&gt; <br>&gt; I believe there’s real value in being explicit about referencing class members.  It helps both the reader of the code and it makes writing code with typical IDE conveniences like code completion less cluttered and more informative. Unfamiliar class methods won’t be included in lists of suggestions where they might look like they operate on the current instance.<br>&gt; <br>&gt; Kate Stone k8stone at apple.com<br>&gt;  Xcode Low Level Tools<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160703/be666ef0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8809800aec2460f291384b794d7e6f8f?s=50"></div><header><strong>Why can&#39;t Swift instance methods call class methods without qualification?</strong> from <string>Rick Mann</string> &lt;rmann at latencyzero.com&gt;<p>July  3, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; Karen Stone wrote:<br></p><p>&gt;&gt; I believe there’s real value in being explicit about referencing class members.  It helps both the reader of the code and it makes writing code with typical IDE conveniences like code completion less cluttered and more informative. Unfamiliar class methods won’t be included in lists of suggestions where they might look like they operate on the current instance.<br></p><p>But it&#39;s not required of instance members, and frankly I hope it never is. I don&#39;t want to have to write self.foo() (and find it a bit weird that I have to in closures defined within the context of a class, when there&#39;s only one possible self that one could be referring to). I&#39;ve finally gotten used to writing self.instanceVar, but only because Swift really resists naming by scope (e.g. mInstanceVar), and I wanted something to clearly identify when I&#39;m referencing an instance variable rather than some possible local variable.<br></p><p>(I&#39;m a huge proponent of styling the name of things after their scope, but I also like doing that as compactly as possible. In C++, this meant prefixing variable names according to their scope (e.g. m, s, k, q). In Swift, when you have to write self.mInstanceVar, it just bugs me, and is rather redundant, so I&#39;ve modified my personal style rules. Anyway, this is a huge digression. I guess I&#39;m saying there&#39;s no consistent requirement in Swift, so saying it&#39;s helpful to call it out for class statics doesn&#39;t seem to hold much water.)<br></p><p>-- <br>Rick Mann<br>rmann at latencyzero.com<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3eada20d8d86f9b78ef64f570acd29e9?s=50"></div><header><strong>Why can&#39;t Swift instance methods call class methods without qualification?</strong> from <string>Nicholas Outram</string> &lt;nicholas.outram at icloud.com&gt;<p>July  3, 2016 at 06:00:00am</p></header><div class="content"><p>You are right of course.<br></p><p> I&#39;m looking at this more from the eyes of an educator, where anything that reduces ambiguity helps. Students naively gravitating towards a singleton pattern is one of the battles I face. Some learners don&#39;t even properly understand the difference or risks. <br>Invoking a static method can only mutate shared memory, making it a simple candidate for dangerous practise, so it&#39;s helpful when a language is explicit. <br></p><p>Ultimately you are right of course, as you say, instance methods can do this also. <br>(Maybe it&#39;s also my own personal style / bias as I tend to avoid referencing static variables from instance methods where possible)<br></p><p>Good discussion!<br></p><p><br></p><p><br>Sent from my iPad<br></p><p>&gt; On 1 Jul 2016, at 19:01, Jens Alfke &lt;jens at mooseyard.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 1, 2016, at 10:28 AM, Nicholas Outram via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; class methods may mutate &quot;mutable static variables” (singletons), which are dangerous in multi-threaded code.<br>&gt; <br>&gt; This is the same argument zh ao made. But instance methods may also mutate static variables, so the fact that you’re calling a class method doesn’t make the call any more dangerous.<br>&gt; <br>&gt; Moreover, mutating instance variables can be just as dangerous for multithreaded code (and is a more frequent source of bugs IMHO).<br>&gt; <br>&gt; Really, the only significant difference is that a class method can’t modify instance variables, so from that perspective it’s actually a bit safer than an instance method call!<br>&gt; <br>&gt; —Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160703/c034c779/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Why can&#39;t Swift instance methods call class methods without qualification?</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>July  1, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jun 30, 2016, at 5:59 PM, Rick Mann via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Why do I have to call MyClass.classMethod()? Just a choice made by the language designers to distinguish the call at the call site? I like C++&#39;s way of treating all static methods as directly available to the instance.<br></p><p>There are two kinds of OO languages: ones with metatypes and ones without them.<br></p><p>Basically, in C++ a class is a thing that exists at compile-time. You can&#39;t create a variable that contains &quot;a class&quot; or pass &quot;a class&quot; to a function. RTTI gives you access to an object *describing* a class, but this is not the class itself, any more than a map of California is California.<br></p><p>In many other languages, including Swift, this is not the case. A class is itself an object that exists at runtime. The class object is an instance of a &quot;metaclass&quot;, a second class which parallels the original class; its class/static members are actually metaclass instance members. That means you can get the class instance, assign it to variables, pass it around, call static methods on it, and call initializers on it to create new instances. You might think of it this way: Every class inherently comes with a singleton, which provides access to all static members and factory methods for all initializers.<br></p><p>(In Swift, which has non-object types, the terminology is actually a little different from normal: the &quot;class object&quot; is a &quot;type instance&quot;, and the &quot;metaclass&quot; is a &quot;metatype&quot;. A type `Foo` has a metatype called `Foo.Type`. You can retrieve any instance&#39;s type instance with `foo.dynamicType`, or retrieve a type&#39;s type instance with `Foo.self`.)<br></p><p>If you adopt this design, then treating instance methods and class methods as belonging to different namespaces is the most straightforward way to design the language. Instance methods belong to the class and are called on instances, while class methods belong to the metaclass and are called on class objects. You wouldn&#39;t expect `someFoo.bar()` to call a method on `Foo`&#39;s class object any more than you would expect it to call a method on `someBaz`.<br></p><p>You *could* make that work, of course, but it would be wholly artificial. Languages which do put class and instance methods in the same namespace—C++, Perl, Python—usually do so because that falls out naturally from their own designs.<br></p><p>If the above was too dense and jargony:<br></p><p>1. Sorry.<br></p><p>2. This is common behavior in many OO languages. Off the top of my head, Ruby, Objective-C, and C# all behave the way Swift does.<br></p><p>3. This behavior falls naturally out of some very deep—and very desirable—features of Swift&#39;s design. If it were changed, the change would be a hack.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8809800aec2460f291384b794d7e6f8f?s=50"></div><header><strong>Why can&#39;t Swift instance methods call class methods without qualification?</strong> from <string>Rick Mann</string> &lt;rmann at latencyzero.com&gt;<p>July  1, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jul 1, 2016, at 15:17 , Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Jun 30, 2016, at 5:59 PM, Rick Mann via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Why do I have to call MyClass.classMethod()? Just a choice made by the language designers to distinguish the call at the call site? I like C++&#39;s way of treating all static methods as directly available to the instance.<br>&gt; <br>&gt; There are two kinds of OO languages: ones with metatypes and ones without them.<br>&gt; <br>&gt; Basically, in C++ a class is a thing that exists at compile-time. You can&#39;t create a variable that contains &quot;a class&quot; or pass &quot;a class&quot; to a function. RTTI gives you access to an object *describing* a class, but this is not the class itself, any more than a map of California is California.<br>&gt; <br>&gt; In many other languages, including Swift, this is not the case. A class is itself an object that exists at runtime. The class object is an instance of a &quot;metaclass&quot;, a second class which parallels the original class; its class/static members are actually metaclass instance members. That means you can get the class instance, assign it to variables, pass it around, call static methods on it, and call initializers on it to create new instances. You might think of it this way: Every class inherently comes with a singleton, which provides access to all static members and factory methods for all initializers.<br>&gt; <br>&gt; (In Swift, which has non-object types, the terminology is actually a little different from normal: the &quot;class object&quot; is a &quot;type instance&quot;, and the &quot;metaclass&quot; is a &quot;metatype&quot;. A type `Foo` has a metatype called `Foo.Type`. You can retrieve any instance&#39;s type instance with `foo.dynamicType`, or retrieve a type&#39;s type instance with `Foo.self`.)<br>&gt; <br>&gt; If you adopt this design, then treating instance methods and class methods as belonging to different namespaces is the most straightforward way to design the language. Instance methods belong to the class and are called on instances, while class methods belong to the metaclass and are called on class objects. You wouldn&#39;t expect `someFoo.bar()` to call a method on `Foo`&#39;s class object any more than you would expect it to call a method on `someBaz`.<br>&gt; <br>&gt; You *could* make that work, of course, but it would be wholly artificial. Languages which do put class and instance methods in the same namespace—C++, Perl, Python—usually do so because that falls out naturally from their own designs.<br>&gt; <br>&gt; If the above was too dense and jargony:<br>&gt; <br>&gt; 1. Sorry.<br>&gt; <br>&gt; 2. This is common behavior in many OO languages. Off the top of my head, Ruby, Objective-C, and C# all behave the way Swift does.<br>&gt; <br>&gt; 3. This behavior falls naturally out of some very deep—and very desirable—features of Swift&#39;s design. If it were changed, the change would be a hack.<br></p><p>Hmm. It sounds like you&#39;re saying it is the way it is as a side-effect of the language implementation.<br></p><p>Maybe it&#39;s just my C++ upbringing, but it seems very counter-intuitive to me. A class method and an instance method look very much the same: they&#39;re defined in the same place (inside a class), and differ only in the &quot;class&quot; keyword. Sure, the class method can&#39;t access the instance variables, but it seems very, very natural that the instance can access the class, because the knowledge is available right there (either the implicit &quot;self&quot; or the instance variable used to call the method both have an obvious type).<br></p><p>In the same way that &quot;self&quot; is implicit in front of a method call from within the class, so to should be the class name in front of a class method call. That to me is consistent not only with Swift, but with other languages.<br></p><p>I&#39;ve always found it annoying that Objective-C couldn&#39;t do this, either, but it has so many weirdnesses I just chocked it up as yet another.<br></p><p>-- <br>Rick Mann<br>rmann at latencyzero.com<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>Why can&#39;t Swift instance methods call class methods without qualification?</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>July  1, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jul 1, 2016, at 3:24 PM, Rick Mann via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Maybe it&#39;s just my C++ upbringing<br></p><p>I think that’s it, yes. (No offense intended.) Different languages have very different ways of doing things. C++ has a very intense focus on performance, and that’s led to its object model being very limited (I could say “crippled”) compared to almost any other OO language. Part of this is the way that static methods are really just namespaced functions, not true methods.<br></p><p>&gt; Hmm. It sounds like you&#39;re saying it is the way it is as a side-effect of the language implementation.<br></p><p>No, it’s a side effect of the language design. I could go into more detail, but I’d just be repeating what Brent said, basically.<br></p><p>If you really want to dive into this rabbit hole, I suggest learning about Smalltalk, which is in most respects the original OO language, and the direct ancestor of Obj-C’s OO features. Metaclasses are a pretty deep concept and well worth learning about. (I remember poring over the class hierarchy diagram in the flyleaf of the Smalltalk-80 “Blue Book” as a college student…)<br></p><p>—Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160701/f795e32a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8809800aec2460f291384b794d7e6f8f?s=50"></div><header><strong>Why can&#39;t Swift instance methods call class methods without qualification?</strong> from <string>Rick Mann</string> &lt;rmann at latencyzero.com&gt;<p>July  1, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jul 1, 2016, at 17:15 , Jens Alfke &lt;jens at mooseyard.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 1, 2016, at 3:24 PM, Rick Mann via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Maybe it&#39;s just my C++ upbringing<br>&gt; <br>&gt; I think that’s it, yes. (No offense intended.) Different languages have very different ways of doing things. C++ has a very intense focus on performance, and that’s led to its object model being very limited (I could say “crippled”) compared to almost any other OO language. Part of this is the way that static methods are really just namespaced functions, not true methods.<br>&gt; <br>&gt;&gt; Hmm. It sounds like you&#39;re saying it is the way it is as a side-effect of the language implementation.<br>&gt; <br>&gt; No, it’s a side effect of the language design. I could go into more detail, but I’d just be repeating what Brent said, basically.<br>&gt; <br>&gt; If you really want to dive into this rabbit hole, I suggest learning about Smalltalk, which is in most respects the original OO language, and the direct ancestor of Obj-C’s OO features. Metaclasses are a pretty deep concept and well worth learning about. (I remember poring over the class hierarchy diagram in the flyleaf of the Smalltalk-80 “Blue Book” as a college student…)<br>&gt; <br></p><p><br>I&#39;m willing to let the matter drop after this comment. But based solely on the syntax of how one defines a class, I think it makes perfect sense to be able to call a class method from an instance method with no special qualifier, but the reverse is obviously not true. There&#39;s more than adequate information <br></p><p>It also makes sense to disallow class and instance methods to have the same name. That&#39;s just asking for trouble, especially with implicit scoping.<br></p><p>I say this because the class and the instance are declared in the same place (i.e. in a &quot;class&quot; declaration). To me, this is is a part of the design of the language, and why nothing about this design screams to me that you can&#39;t implicitly understand that an unqualified call to a class method is what it is.<br></p><p>Anyway, I&#39;m done discussing it. I don&#39;t like it, I think it&#39;s an esoteric argument for why it is, and I think it&#39;s nonintuitive, I think the alternative is better (i.e. easier to use), and wouldn&#39;t prevent any reasonable or necessary programming paradigm.<br></p><p>-- <br>Rick Mann<br>rmann at latencyzero.com<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
