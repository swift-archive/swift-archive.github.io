<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>Protected access level / multiple class/struct/protocol APIs</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>March 29, 2016 at 02:00:00pm</p></header><div class="content"><p>Now that the scoped access discussion is close(r) to being settled, let&#39;s tackle the next controversial topic: protected.<br></p><p><br>Expose<br></p><p>Objective-C allows multiple “APIs” to be exposed for a given class by virtue of writing additional header files. There are two common uses of that:<br></p><p>Use case 1: API for private clients<br></p><p>Foo.h<br>Foo-Private.h<br>Foo.m<br></p><p>Use case 2: API for subclasses, intended to be overridden<br></p><p>Foo.h<br>Foo-Subclasses.h  // defines a method to override, e.g. layoutSubviews<br>Foo.m<br></p><p>Use case 3: API for subclasses, intended to be called<br></p><p>Foo.h<br>Foo-Subclasses.h  // defines a dangerous helper method<br>Foo.m<br></p><p>Swift covers use case #1 with the internal (or perhaps soon-to-be moduleprivate) access modifier.<br></p><p><br>The problem<br></p><p>Swift core teams has prompted us to explore using internal and file-private access levels to cover use cases #2 and #3, and I&#39;ve faithfully tried to do just that. It works for many cases inside the code of apps, but it doesn&#39;t work if you&#39;re writing a library package and want to expose the “special extenders club” API to the clients of the library.<br></p><p>Here&#39;s the use case in more detail:<br></p><p>1. You have a library that exposes a class called Foo.<br>2. There are two different ways to use that library: you can just use Foo, or you can extend the library, perhaps subclassing Foo.<br>3. Those who opt for the second way to use the library (i.e. extending it) need access to a broader set of APIs.<br></p><p><br>Why do extenders need access to a broader set of APIs?<br></p><p>Basically, for safety and documentation purposes.<br></p><p>Considering use case #2:<br></p><p>The library often exposes very similar APIs, some of which are intended to be called (layoutIfNeeded), others intended to be extended (layoutSubviews). These typically sound very similar, and are easy to mix up, so you definitely want to document this difference, and ideally you also want to statically prevent the first (non-extending) type of clients from calling them.<br></p><p>Note that accidentally calling layoutSubviews instead of layoutIfNeeded is one of the worst kinds of mistakes; it might seem to work, and it might not be found until production, and the bug it causes may be weird and difficult to reproduce.<br></p><p><br>Considering use case #3:<br></p><p>A library may expose methods that should not be called by normal clients, but are useful when extending it:<br></p><p>3.1) They may carry substantially different guarantees from normal methods (e.g. require to be called only on a certain dispatch queue),<br></p><p>3.2) or may only be callable while another overridable method is executing,<br></p><p>3.3) or may simply allow mutating the internal state of the class (e.g. the state of UIGestureRecognizer) that is not supposed to be mutated from outside.<br></p><p><br>Swift currently requires making all of this public. :-(<br></p><p><br>The problem has tons of prior art.<br></p><p>C family of languages use multiple header files.<br></p><p>Ada has special access rules for subpackages (nicely explained in http://blog.spacesocket.com/2012/07/31/ada-child-packages/).<br></p><p>OOP languages have protected access levels.<br></p><p><br>What does extending mean in Swift?<br></p><p>I&#39;m not sure about this. It certainly needs to include subclassing a class, but we may find other useful meanings.<br></p><p>In particular, writing an extension for a struct/class/protocol may raise similar concerns and may need similar treatment.<br></p><p><br>What do I propose?<br></p><p>I&#39;m mainly looking for ideas and discussion, but as a strawman, let me put this out:<br></p><p>Introduce protected access modifier that allows the member to be accessed by:<br></p><p>1. Subclasses of a class.<br>2. Extenders of a struct or protocol.<br>3. Implementors of a protocol. <br></p><p>package FooKit:<br></p><p>public class Foo {<br>	public func amSafe() { ... }<br>	protected func amDangerous() { ... }<br>}<br></p><p>public struct Boo {<br>	public func amSafe() { ... }<br>	protected func amDangerous() { ... }<br>}<br></p><p>public protocol Moo {<br>	func amSafe()<br>}<br></p><p>public extension Moo {<br>	protected func amDangerous() { ... }<br>}<br></p><p>App:<br></p><p>	public class Bar: Foo {<br>		public func bar() {<br>			amDangerous()<br>		}<br>	}<br></p><p>	public extension Foo {<br>		public func boz() {<br>			amDangerous()<br>		}<br>	}<br></p><p>	public extension Boo {<br>		public func boz() {<br>			amDangerous()<br>		}<br>	}<br></p><p>	public class Boz: Moo {<br>		public func fubar() {<br>			amDangerous()<br>		}<br>	}<br></p><p><br>So what do you think?<br></p><p>A.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160329/ab33725c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Protected access level / multiple class/struct/protocol APIs</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>March 29, 2016 at 10:00:00am</p></header><div class="content"><p>A more sophisticated rights system isn&#39;t necessary, but actually, we could build everything with nothing but &quot;public&quot;, so it is always a compromise between simplicity and expressiveness…<br>Imho it would be nice to be able to mark a method that is only there to be overridden and should never be called directly, but I don&#39;t think the compiler has to enforce this:<br>An official way to document the intent that affects autocompletion would be sufficient for me.<br></p><p>Besides the question where (class/module/public…) something is visible, there is also the question of what can or has to be done with a method:<br></p><p>- callable (read for properties)<br>- can override, call to super enforced<br>- can override<br>- has to be overridden (abstract)<br>- properties only: Write access<br></p><p>If there is an elegant way to handle all use cases, I&#39;d strongly support this direction.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>Protected access level / multiple class/struct/protocol APIs</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>March 29, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; Imho it would be nice to be able to mark a method that is only there to be overridden and should never be called directly, but I don&#39;t think the compiler has to enforce this:<br>&gt; An official way to document the intent that affects autocompletion would be sufficient for me.<br></p><p>An interesting idea that I see reflected in another proposal (intendedusage doc tag, or something like that).<br></p><p>Why, though? If we can express it, why not also make it a part of the signature and get warnings/errors on violations?<br></p><p>I have an argument in favor of annotations:<br></p><p>+ The documentation is known to lie and to get out of date, even when acting on best intentions. I know mine did, and I&#39;m writing a lot less of it now. So I also see compiler-enforced annotations as “more reliable documentation”.<br></p><p>What are other possible arguments for and against?<br></p><p>&gt; - callable (read for properties)<br>&gt; - can override, call to super enforced<br>&gt; - can override<br>&gt; - has to be overridden (abstract)<br>&gt; - properties only: Write access<br></p><p>You&#39;re right, perhaps this isn&#39;t so much about access as it is about intended usage. (Not sure what that distinction means in practice, though.)<br></p><p>A.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Protected access level / multiple class/struct/protocol APIs</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>March 30, 2016 at 10:00:00am</p></header><div class="content"><p>I tend to think an intended use annotation that could also be used in Obj-C<br>would be better than protected. The problem with protected is that it<br>provides virtually no protection at all; you can trivially expose it in a<br>derived class, e.g.:<br></p><p>class Protected {<br></p><p>protected func onlyDerived() { ... }<br></p><p>}<br></p><p>class Derived: Protected {<br></p><p>public override func onlyDerived() { super.onlyDerived() }<br></p><p>}<br></p><p>let d = Derived()<br>d.onlyDerived() // Protection lost<br></p><p>Therefore an annotation would be just as effective.<br></p><p>  -- Howard.<br></p><p>On 29 March 2016 at 21:54, Andrey Tarantsov via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; Imho it would be nice to be able to mark a method that is only there to<br>&gt; be overridden and should never be called directly, but I don&#39;t think the<br>&gt; compiler has to enforce this:<br>&gt; &gt; An official way to document the intent that affects autocompletion would<br>&gt; be sufficient for me.<br>&gt;<br>&gt; An interesting idea that I see reflected in another proposal<br>&gt; (intendedusage doc tag, or something like that).<br>&gt;<br>&gt; Why, though? If we can express it, why not also make it a part of the<br>&gt; signature and get warnings/errors on violations?<br>&gt;<br>&gt; I have an argument in favor of annotations:<br>&gt;<br>&gt; + The documentation is known to lie and to get out of date, even when<br>&gt; acting on best intentions. I know mine did, and I&#39;m writing a lot less of<br>&gt; it now. So I also see compiler-enforced annotations as “more reliable<br>&gt; documentation”.<br>&gt;<br>&gt; What are other possible arguments for and against?<br>&gt;<br>&gt; &gt; - callable (read for properties)<br>&gt; &gt; - can override, call to super enforced<br>&gt; &gt; - can override<br>&gt; &gt; - has to be overridden (abstract)<br>&gt; &gt; - properties only: Write access<br>&gt;<br>&gt; You&#39;re right, perhaps this isn&#39;t so much about access as it is about<br>&gt; intended usage. (Not sure what that distinction means in practice, though.)<br>&gt;<br>&gt; A.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160330/e9892007/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d1af757c2ce75a92193ad0c34bc62af1?s=50"></div><header><strong>Protected access level / multiple class/struct/protocol APIs</strong> from <string>Dietmar Planitzer</string> &lt;dplanitzer at q.com&gt;<p>March 29, 2016 at 06:00:00pm</p></header><div class="content"><p>Well that would be true if we assume that protected would work that way. Considering that this:<br></p><p>private class A { … }<br></p><p>public class B : A { … }<br></p><p>is not allowed in Swift, I don’t see a good reason why an override of a protected method should be allowed to upgrade the access level to public. On the other hand this:<br></p><p>public class A {<br>    private func foo() {<br>        print(&quot;A&quot;)<br>    }<br>}<br></p><p>public class B : A {<br>    public override func foo() {<br>        print(“B”)<br>    }<br>}<br></p><p>happens to actually work if both A and B are defined in the same file - which is rather unexpected. I would have expected that Swift would in general not allow overrides to upgrade the inherited access level. Eg exposing semantics which is embodied in a private or protected method should require a conscisous design decision and should require the designer to introduce a separate method name which is part of the public API. The public method can then call through to the private or protected method as needed.<br></p><p>Anyway, I do think that a protected access level would be a useful tool to have exactly because it would allow me to clearly communicated the intent of whether a method is only there for use by subclassers. Today I can’t do that and thus I have to mark the method as public and thus make it part of the overall class API which means that I end up making a much bigger promise than I actually intended to give.<br></p><p><br>Regards,<br></p><p>Dietmar Planitzer<br></p><p><br></p><p>&gt; On Mar 29, 2016, at 16:56, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I tend to think an intended use annotation that could also be used in Obj-C would be better than protected. The problem with protected is that it provides virtually no protection at all; you can trivially expose it in a derived class, e.g.:<br>&gt; <br>&gt; class Protected {<br>&gt; protected func onlyDerived() { ... }<br>&gt; }<br>&gt; <br>&gt; class Derived: Protected {<br>&gt; public override func onlyDerived() { super.onlyDerived() }<br>&gt; }<br>&gt; <br>&gt; let d = Derived()<br>&gt; d.onlyDerived() // Protection lost<br>&gt; <br>&gt; Therefore an annotation would be just as effective.<br>&gt; <br>&gt;   -- Howard.<br>&gt; <br>&gt; On 29 March 2016 at 21:54, Andrey Tarantsov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; &gt; Imho it would be nice to be able to mark a method that is only there to be overridden and should never be called directly, but I don&#39;t think the compiler has to enforce this:<br>&gt; &gt; An official way to document the intent that affects autocompletion would be sufficient for me.<br>&gt; <br>&gt; An interesting idea that I see reflected in another proposal (intendedusage doc tag, or something like that).<br>&gt; <br>&gt; Why, though? If we can express it, why not also make it a part of the signature and get warnings/errors on violations?<br>&gt; <br>&gt; I have an argument in favor of annotations:<br>&gt; <br>&gt; + The documentation is known to lie and to get out of date, even when acting on best intentions. I know mine did, and I&#39;m writing a lot less of it now. So I also see compiler-enforced annotations as “more reliable documentation”.<br>&gt; <br>&gt; What are other possible arguments for and against?<br>&gt; <br>&gt; &gt; - callable (read for properties)<br>&gt; &gt; - can override, call to super enforced<br>&gt; &gt; - can override<br>&gt; &gt; - has to be overridden (abstract)<br>&gt; &gt; - properties only: Write access<br>&gt; <br>&gt; You&#39;re right, perhaps this isn&#39;t so much about access as it is about intended usage. (Not sure what that distinction means in practice, though.)<br>&gt; <br>&gt; A.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Protected access level / multiple class/struct/protocol APIs</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March 29, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Mar 29, 2016, at 6:04 PM, Dietmar Planitzer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Well that would be true if we assume that protected would work that way. Considering that this:<br>&gt; <br>&gt; private class A { … }<br>&gt; <br>&gt; public class B : A { … }<br>&gt; <br>&gt; is not allowed in Swift, I don’t see a good reason why an override of a protected method should be allowed to upgrade the access level to public. On the other hand this:<br>&gt; <br>&gt; public class A {<br>&gt;    private func foo() {<br>&gt;        print(&quot;A&quot;)<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; public class B : A {<br>&gt;    public override func foo() {<br>&gt;        print(“B”)<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; happens to actually work if both A and B are defined in the same file - which is rather unexpected. I would have expected that Swift would in general not allow overrides to upgrade the inherited access level. Eg exposing semantics which is embodied in a private or protected method should require a conscisous design decision and should require the designer to introduce a separate method name which is part of the public API. The public method can then call through to the private or protected method as needed.<br></p><p>That would still be a toothless restriction, since a subclass could define a new method:<br></p><p>public class B : A {<br>   public func foo_() {<br>       super.foo()<br>   }<br>}<br></p><p>From an interface perspective, there&#39;s no difference between a subclass defining a new method or overriding a method that happens to be private to the base class.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Protected access level / multiple class/struct/protocol APIs</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March 29, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Mar 29, 2016, at 6:18 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Mar 29, 2016, at 6:04 PM, Dietmar Planitzer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Well that would be true if we assume that protected would work that way. Considering that this:<br>&gt;&gt; <br>&gt;&gt; private class A { … }<br>&gt;&gt; <br>&gt;&gt; public class B : A { … }<br>&gt;&gt; <br>&gt;&gt; is not allowed in Swift, I don’t see a good reason why an override of a protected method should be allowed to upgrade the access level to public. On the other hand this:<br>&gt;&gt; <br>&gt;&gt; public class A {<br>&gt;&gt;   private func foo() {<br>&gt;&gt;       print(&quot;A&quot;)<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; public class B : A {<br>&gt;&gt;   public override func foo() {<br>&gt;&gt;       print(“B”)<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; happens to actually work if both A and B are defined in the same file - which is rather unexpected. I would have expected that Swift would in general not allow overrides to upgrade the inherited access level. Eg exposing semantics which is embodied in a private or protected method should require a conscisous design decision and should require the designer to introduce a separate method name which is part of the public API. The public method can then call through to the private or protected method as needed.<br>&gt; <br>&gt; That would still be a toothless restriction, since a subclass could define a new method:<br>&gt; <br>&gt; public class B : A {<br>&gt;   public func foo_() {<br>&gt;       super.foo()<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; From an interface perspective, there&#39;s no difference between a subclass defining a new method or overriding a method that happens to be private to the base class.<br></p><p>Extensions further dilute the enforceability of &quot;protected&quot;, since anyone would be able to use an extension to dump methods into a class&#39;s namespace and access its supposedly-protected bits.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Protected access level / multiple class/struct/protocol APIs</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>March 30, 2016 at 06:00:00am</p></header><div class="content"><p>I have no problems with &quot;protected&quot; members being made accessible in subclasses or extensions because this requires conscious decisions and actions to extend the API.<br>Access levels are not there to protect against hacking, they are there to ensure that something can only be used through its given API. They are not there to restrict extending that API.<br></p><p>Having said that I&#39;d love to have &quot;protected&quot;.<br></p><p>-Thorsten <br></p><p>&gt; Am 30.03.2016 um 03:28 schrieb Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Mar 29, 2016, at 6:18 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Mar 29, 2016, at 6:04 PM, Dietmar Planitzer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Well that would be true if we assume that protected would work that way. Considering that this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; private class A { … }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public class B : A { … }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; is not allowed in Swift, I don’t see a good reason why an override of a protected method should be allowed to upgrade the access level to public. On the other hand this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public class A {<br>&gt;&gt;&gt;  private func foo() {<br>&gt;&gt;&gt;      print(&quot;A&quot;)<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public class B : A {<br>&gt;&gt;&gt;  public override func foo() {<br>&gt;&gt;&gt;      print(“B”)<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; happens to actually work if both A and B are defined in the same file - which is rather unexpected. I would have expected that Swift would in general not allow overrides to upgrade the inherited access level. Eg exposing semantics which is embodied in a private or protected method should require a conscisous design decision and should require the designer to introduce a separate method name which is part of the public API. The public method can then call through to the private or protected method as needed.<br>&gt;&gt; <br>&gt;&gt; That would still be a toothless restriction, since a subclass could define a new method:<br>&gt;&gt; <br>&gt;&gt; public class B : A {<br>&gt;&gt;  public func foo_() {<br>&gt;&gt;      super.foo()<br>&gt;&gt;  }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; From an interface perspective, there&#39;s no difference between a subclass defining a new method or overriding a method that happens to be private to the base class.<br>&gt; <br>&gt; Extensions further dilute the enforceability of &quot;protected&quot;, since anyone would be able to use an extension to dump methods into a class&#39;s namespace and access its supposedly-protected bits.<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/175ad9e0827a836bfb3d1d06fe3182ec?s=50"></div><header><strong>Protected access level / multiple class/struct/protocol APIs</strong> from <string>Diego Sánchez</string> &lt;diego.sanchezr at gmail.com&gt;<p>March 30, 2016 at 11:00:00am</p></header><div class="content"><p>That&#39;s the key point.<br></p><p>&quot;Protected&quot; would increase the expressivity of the language by declaring<br>intent and exposing cleaner public APIs.<br></p><p>I don&#39;t think this idea should be dropped just because conscious<br>hacks/decisions<br>can workaround it, so big +1 for it.<br></p><p>2016-03-30 5:51 GMT+01:00 Thorsten Seitz via swift-evolution &lt;<br>swift-evolution at swift.org&gt;:<br></p><p>&gt; I have no problems with &quot;protected&quot; members being made accessible in<br>&gt; subclasses or extensions because this requires conscious decisions and<br>&gt; actions to extend the API.<br>&gt; Access levels are not there to protect against hacking, they are there to<br>&gt; ensure that something can only be used through its given API. They are not<br>&gt; there to restrict extending that API.<br>&gt;<br>&gt; Having said that I&#39;d love to have &quot;protected&quot;.<br>&gt;<br>&gt; -Thorsten<br>&gt;<br>&gt; &gt; Am 30.03.2016 um 03:28 schrieb Joe Groff via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt;&gt; On Mar 29, 2016, at 6:18 PM, Joe Groff via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; On Mar 29, 2016, at 6:04 PM, Dietmar Planitzer via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Well that would be true if we assume that protected would work that<br>&gt; way. Considering that this:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; private class A { … }<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; public class B : A { … }<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; is not allowed in Swift, I don’t see a good reason why an override of<br>&gt; a protected method should be allowed to upgrade the access level to public.<br>&gt; On the other hand this:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; public class A {<br>&gt; &gt;&gt;&gt;  private func foo() {<br>&gt; &gt;&gt;&gt;      print(&quot;A&quot;)<br>&gt; &gt;&gt;&gt;  }<br>&gt; &gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; public class B : A {<br>&gt; &gt;&gt;&gt;  public override func foo() {<br>&gt; &gt;&gt;&gt;      print(“B”)<br>&gt; &gt;&gt;&gt;  }<br>&gt; &gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; happens to actually work if both A and B are defined in the same file<br>&gt; - which is rather unexpected. I would have expected that Swift would in<br>&gt; general not allow overrides to upgrade the inherited access level. Eg<br>&gt; exposing semantics which is embodied in a private or protected method<br>&gt; should require a conscisous design decision and should require the designer<br>&gt; to introduce a separate method name which is part of the public API. The<br>&gt; public method can then call through to the private or protected method as<br>&gt; needed.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; That would still be a toothless restriction, since a subclass could<br>&gt; define a new method:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; public class B : A {<br>&gt; &gt;&gt;  public func foo_() {<br>&gt; &gt;&gt;      super.foo()<br>&gt; &gt;&gt;  }<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; From an interface perspective, there&#39;s no difference between a subclass<br>&gt; defining a new method or overriding a method that happens to be private to<br>&gt; the base class.<br>&gt; &gt;<br>&gt; &gt; Extensions further dilute the enforceability of &quot;protected&quot;, since<br>&gt; anyone would be able to use an extension to dump methods into a class&#39;s<br>&gt; namespace and access its supposedly-protected bits.<br>&gt; &gt;<br>&gt; &gt; -Joe<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160330/9ee37f07/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d1af757c2ce75a92193ad0c34bc62af1?s=50"></div><header><strong>Protected access level / multiple class/struct/protocol APIs</strong> from <string>Dietmar Planitzer</string> &lt;dplanitzer at q.com&gt;<p>March 30, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Mar 29, 2016, at 18:28, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 29, 2016, at 6:18 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Mar 29, 2016, at 6:04 PM, Dietmar Planitzer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Well that would be true if we assume that protected would work that way. Considering that this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; private class A { … }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public class B : A { … }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; is not allowed in Swift, I don’t see a good reason why an override of a protected method should be allowed to upgrade the access level to public. On the other hand this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public class A {<br>&gt;&gt;&gt;  private func foo() {<br>&gt;&gt;&gt;      print(&quot;A&quot;)<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public class B : A {<br>&gt;&gt;&gt;  public override func foo() {<br>&gt;&gt;&gt;      print(“B”)<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; happens to actually work if both A and B are defined in the same file - which is rather unexpected. I would have expected that Swift would in general not allow overrides to upgrade the inherited access level. Eg exposing semantics which is embodied in a private or protected method should require a conscisous design decision and should require the designer to introduce a separate method name which is part of the public API. The public method can then call through to the private or protected method as needed.<br>&gt;&gt; <br>&gt;&gt; That would still be a toothless restriction, since a subclass could define a new method:<br>&gt;&gt; <br>&gt;&gt; public class B : A {<br>&gt;&gt;  public func foo_() {<br>&gt;&gt;      super.foo()<br>&gt;&gt;  }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; From an interface perspective, there&#39;s no difference between a subclass defining a new method or overriding a method that happens to be private to the base class.<br>&gt; <br>&gt; Extensions further dilute the enforceability of &quot;protected&quot;, since anyone would be able to use an extension to dump methods into a class&#39;s namespace and access its supposedly-protected bits.<br></p><p>That is true assuming that Swift would allow an extension to call a protected method. But I don’t see a strict requirement that Swift would have to allow this.<br></p><p>There are two variants of extensions that are useful:<br></p><p>a) extension is used by the producer of a type to break up a large implementation into smaller pieces: in this case the implementor writes those extensions and in this case you can argue that an extension should allow the code writer to do everything that he can do in a base type. Eg allow the definition of stored properties and allow the calling of protected methods (and likely private methods too). Swift doesn’t currently really support this. Ideally it would be possible to put each extension into a separate file and things like accessing private members would still work.<br></p><p>b) extension is used by a consumer of a type to extend the type after the fact: in this case it makes sense that an extension comes with certain restrictions. Eg you can not add stored properties (which especially in the case of value types could change the nature of the value type drastically) and you can not call private or protected methods. This is what Swift’s extensions are today.<br></p><p><br>Regards,<br></p><p>Dietmar Planitzer<br></p><p>&gt; -Joe<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d1af757c2ce75a92193ad0c34bc62af1?s=50"></div><header><strong>Protected access level / multiple class/struct/protocol APIs</strong> from <string>Dietmar Planitzer</string> &lt;dplanitzer at q.com&gt;<p>March 30, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Mar 29, 2016, at 18:18, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 29, 2016, at 6:04 PM, Dietmar Planitzer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Well that would be true if we assume that protected would work that way. Considering that this:<br>&gt;&gt; <br>&gt;&gt; private class A { … }<br>&gt;&gt; <br>&gt;&gt; public class B : A { … }<br>&gt;&gt; <br>&gt;&gt; is not allowed in Swift, I don’t see a good reason why an override of a protected method should be allowed to upgrade the access level to public. On the other hand this:<br>&gt;&gt; <br>&gt;&gt; public class A {<br>&gt;&gt;   private func foo() {<br>&gt;&gt;       print(&quot;A&quot;)<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; public class B : A {<br>&gt;&gt;   public override func foo() {<br>&gt;&gt;       print(“B”)<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; happens to actually work if both A and B are defined in the same file - which is rather unexpected. I would have expected that Swift would in general not allow overrides to upgrade the inherited access level. Eg exposing semantics which is embodied in a private or protected method should require a conscisous design decision and should require the designer to introduce a separate method name which is part of the public API. The public method can then call through to the private or protected method as needed.<br>&gt; <br>&gt; That would still be a toothless restriction, since a subclass could define a new method:<br>&gt; <br>&gt; public class B : A {<br>&gt;   public func foo_() {<br>&gt;       super.foo()<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; From an interface perspective, there&#39;s no difference between a subclass defining a new method or overriding a method that happens to be private to the base class.<br></p><p>If a method was marked private in the base class, then it is very likely that the name of the method, the design of its argument list and its return value did not go through the same detailed design review as if the method would have been meant to be part of the class’ interface from the start. So it’s rather unlikely that increasing the visibility in an override is good idea and in the spirit of the original writer of the private method. If on the other side I’m required to introduce a new method name if I want to make the semantics of the private method part of my public interface, then (a) it gives me an opportunity to think about what kind of interface I want to commit to and (b) it gives me stability because it doesn’t matter anymore what is going to happen over time to the name, argument list and return value of the private method since the name and signature of my public method is now decoupled from the ones of the private method.<br></p><p>Also, your argument would just as well apply to the scenario below since a class is a collection of methods when you look at it purely from an interface perspective:<br></p><p>private class A { … }<br></p><p>public class B : A { … }<br></p><p>but Swift doesn’t allow this. <br></p><p><br>Regards,<br></p><p>Dietmar Planitzer<br></p><p><br>&gt; -Joe<br>&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>Protected access level / multiple class/struct/protocol APIs</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>March 31, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; The problem with protected is that it provides virtually no protection at all; you can trivially expose it in a derived class<br></p><p>+<br></p><p>&gt; Extensions further dilute the enforceability of &quot;protected&quot;, since anyone would be able to use an extension to dump methods into a class&#39;s namespace and access its supposedly-protected bits.<br></p><p>I don&#39;t understand the need to protect against exposing something deliberately. We don&#39;t have a goal of restricting other developers, we&#39;re only saving them from accidental mistakes.<br></p><p><br>&gt; If a method was marked private in the base class, then it is very likely that the name of the method, the design of its argument list and its return value did not go through the same detailed design review as if the method would have been meant to be part of the class’ interface from the start. So it’s rather unlikely that increasing the visibility in an override is good idea and in the spirit of the original writer of the private method.<br></p><p>The design review and whether something is a good idea is left as a responsibility for those subclasses that choose to expose methods. The intentions of the original class author don&#39;t override the intentions of the subclass author.<br></p><p><br>That said, I don&#39;t necessarily believe that the protected modifier is the best solution for the problems we&#39;re discussing. Some methods are not intended to be called at all, and protected doesn&#39;t solve that.<br></p><p>A.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160331/fb764f5c/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
