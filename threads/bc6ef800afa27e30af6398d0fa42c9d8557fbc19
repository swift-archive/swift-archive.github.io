<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>[Pitch] Memos for Struct Calculated Properties</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>May  7, 2016 at 07:00:00am</p></header><div class="content"><p>I saw a message come across about Memoization, and I thought of using a slightly different approach for similar benefit.<br></p><p>I commonly want to store the result of a complex calculation in a private variable in a struct to avoid recalculation cost… but now I have to mark that calculation as *mutating* even though it isn’t really mutating in the semantic sense (since it will have the same value). It is an implementation detail leaking out… the caller shouldn’t care if I am memoizing.<br></p><p>Also, my attempt to speed things up may have actually slowed things down, since a bunch of other stuff had to be copied...<br></p><p>It would be nice to mark a calculated property of a struct as “memo&quot; so that the calculation result is stored… but the calculation shouldn’t need to be marked as mutable (unless it actually mutates other things).  That memo should be automatically cleared whenever an actual mutating method is called on the struct.<br></p><p>Ideally, the compiler would eventually be smart enough to only clear the memos when properties used in the calculations change, but I think just clearing it whenever the struct is mutated is a good first step.<br></p><p>struct MyStruct {<br>    var a:Int<br>    var b:Int<br></p><p>    memo var c {<br>	//Complex calculation here<br>    }<br>}<br></p><p>let s = MyStruct(a:2, b:3)<br>print(s.c) // result of c is automatically memoized<br>print(s.c) // returns memoized result<br>s.a = 5 //This clears the memo for c as it may affect the calculation<br>print(s.c) // New result of c is automatically memoized<br></p><p><br>The other alternative is to do things manually.  Letting the programmer declare special private variables on a struct that are allowed to mutate without the “mutating” key word.  That is potentially more powerful, but also more error prone.  I prefer the set-it-and-forget-it approach.<br></p><p>If “memo&quot; is the wrong word for this, I am completely open to calling it something else.  I would really like to see this functionality in Swift 3 though (whatever it is called).<br></p><p>Thanks,<br>Jon<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160507/bc6ebc19/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2969f67fc010e956c71442148f3f6fc0?s=50"></div><header><strong>[Pitch] Memos for Struct Calculated Properties</strong> from <string>Wallacy</string> &lt;wallacyf at gmail.com&gt;<p>May  7, 2016 at 02:00:00pm</p></header><div class="content"><p>We already have lazy properties to get what you are describing. But we need<br>to wait for the Properties Behavior for the ability to clean a precomputed<br>lazy var.<br></p><p>Em sáb, 7 de mai de 2016 11:27, Jonathan Hull via swift-evolution &lt;<br>swift-evolution at swift.org&gt; escreveu:<br></p><p>&gt; I saw a message come across about Memoization, and I thought of using a<br>&gt; slightly different approach for similar benefit.<br>&gt;<br>&gt; I commonly want to store the result of a complex calculation in a private<br>&gt; variable in a struct to avoid recalculation cost… but now I have to mark<br>&gt; that calculation as *mutating* even though it isn’t really mutating in the<br>&gt; semantic sense (since it will have the same value). It is an implementation<br>&gt; detail leaking out… the caller shouldn’t care if I am memoizing.<br>&gt;<br>&gt; Also, my attempt to speed things up may have actually slowed things down,<br>&gt; since a bunch of other stuff had to be copied...<br>&gt;<br>&gt; It would be nice to mark a calculated property of a struct as “memo&quot; so<br>&gt; that the calculation result is stored… but the calculation shouldn’t need<br>&gt; to be marked as mutable (unless it actually mutates other things).  That<br>&gt; memo should be automatically cleared whenever an actual mutating method is<br>&gt; called on the struct.<br>&gt;<br>&gt; Ideally, the compiler would eventually be smart enough to only clear the<br>&gt; memos when properties used in the calculations change, but I think just<br>&gt; clearing it whenever the struct is mutated is a good first step.<br>&gt;<br>&gt; struct MyStruct {<br>&gt;     var a:Int<br>&gt;     var b:Int<br>&gt;<br>&gt;     memo var c {<br>&gt; //Complex calculation here<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; let s = MyStruct(a:2, b:3)<br>&gt; print(s.c) // result of c is automatically memoized<br>&gt; print(s.c) // returns memoized result<br>&gt; s.a = 5 //This clears the memo for c as it may affect the calculation<br>&gt; print(s.c) // New result of c is automatically memoized<br>&gt;<br>&gt;<br>&gt;<br>&gt; The other alternative is to do things manually.  Letting the programmer<br>&gt; declare special private variables on a struct that are allowed to mutate<br>&gt; without the “mutating” key word.  That is potentially more powerful, but<br>&gt; also more error prone.  I prefer the set-it-and-forget-it approach.<br>&gt;<br>&gt; If “memo&quot; is the wrong word for this, I am completely open to calling it<br>&gt; something else.  I would really like to see this functionality in Swift 3<br>&gt; though (whatever it is called).<br>&gt;<br>&gt; Thanks,<br>&gt; Jon<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160507/31890028/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>[Pitch] Memos for Struct Calculated Properties</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>May  7, 2016 at 08:00:00am</p></header><div class="content"><p>There is a subtle, but very important difference.  Lazy properties let you defer a calculation until it is needed, but once it is set, it is set.  Changing it to clear it would be a mutation.<br></p><p>The auto clearing behavior (on mutation of any part of the struct) of the memo proposal allows the calculation to lazily update as the struct is mutated.  The key bit is that setting the memo doesn’t trip the mutation wires. <br></p><p>I am completely ok calling this feature “lazy” if that is a better fit/word, though it has a slightly different connotation to me.<br></p><p>Thanks,<br>Jon<br></p><p>&gt; On May 7, 2016, at 7:54 AM, Wallacy &lt;wallacyf at gmail.com&gt; wrote:<br>&gt; <br>&gt; We already have lazy properties to get what you are describing. But we need to wait for the Properties Behavior for the ability to clean a precomputed lazy var.<br>&gt; <br>&gt; <br>&gt; Em sáb, 7 de mai de 2016 11:27, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; escreveu:<br>&gt; I saw a message come across about Memoization, and I thought of using a slightly different approach for similar benefit.<br>&gt; <br>&gt; I commonly want to store the result of a complex calculation in a private variable in a struct to avoid recalculation cost… but now I have to mark that calculation as *mutating* even though it isn’t really mutating in the semantic sense (since it will have the same value). It is an implementation detail leaking out… the caller shouldn’t care if I am memoizing.<br>&gt; <br>&gt; Also, my attempt to speed things up may have actually slowed things down, since a bunch of other stuff had to be copied...<br>&gt; <br>&gt; It would be nice to mark a calculated property of a struct as “memo&quot; so that the calculation result is stored… but the calculation shouldn’t need to be marked as mutable (unless it actually mutates other things).  That memo should be automatically cleared whenever an actual mutating method is called on the struct.<br>&gt; <br>&gt; Ideally, the compiler would eventually be smart enough to only clear the memos when properties used in the calculations change, but I think just clearing it whenever the struct is mutated is a good first step.<br>&gt; <br>&gt; struct MyStruct {<br>&gt;     var a:Int<br>&gt;     var b:Int<br>&gt; <br>&gt;     memo var c {<br>&gt; 	//Complex calculation here<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; let s = MyStruct(a:2, b:3)<br>&gt; print(s.c) // result of c is automatically memoized<br>&gt; print(s.c) // returns memoized result<br>&gt; s.a = 5 //This clears the memo for c as it may affect the calculation<br>&gt; print(s.c) // New result of c is automatically memoized<br>&gt; <br>&gt; <br>&gt; The other alternative is to do things manually.  Letting the programmer declare special private variables on a struct that are allowed to mutate without the “mutating” key word.  That is potentially more powerful, but also more error prone.  I prefer the set-it-and-forget-it approach.<br>&gt; <br>&gt; If “memo&quot; is the wrong word for this, I am completely open to calling it something else.  I would really like to see this functionality in Swift 3 though (whatever it is called).<br>&gt; <br>&gt; Thanks,<br>&gt; Jon<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160507/a3844d8a/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
