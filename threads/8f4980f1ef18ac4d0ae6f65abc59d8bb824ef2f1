<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April  5, 2016 at 04:00:00pm</p></header><div class="content"><p>on Tue Apr 05 2016, Erica Sadun &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; On Apr 5, 2016, at 4:17 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Tue Apr 05 2016, Erica Sadun &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;<br>&gt;&gt;&gt;    On Apr 5, 2016, at 1:54 PM, Dave Abrahams<br>&gt;&gt;&gt;    &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt;    IMO this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    (-9...0).reverse()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    is better than <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    stride(from: 0, to: -10, by: -1)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    What do you think?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The latter better reflects an author&#39;s actual intent. The former depends on<br>&gt;&gt;&gt; implementation details, which can be hazy, especially, around the edge cases. It<br>&gt;&gt;&gt; is quicker to read, understand, and verify that the latter is what is<br>&gt;&gt;&gt; meant.<br>&gt;&gt; <br>&gt;&gt; Except that there seems to be some confusion over what &quot;to:&quot; means, right?<br>&gt;<br>&gt; obviously (0..&lt;-10).by(-2) would be best.<br></p><p>I don&#39;t think that&#39;s obvious at all, because 0 ≮ 10<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April  5, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Apr 5, 2016, at 5:22 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; I don&#39;t think that&#39;s obvious at all, because 0 ≮ 10<br></p><p>Points brought up elsewhere:<br></p><p>* A range does not have direction, it is is an area of variation between lower and upper limits.<br>* A range does not go from a larger amount to a smaller amount because it is not a sequence<br>* Much of this problem goes away with striding (as Dave pointed out several times, sorry Dave)<br></p><p>After consideration, I have been persuaded to the opinion that<br></p><p>&gt;  stride(from: 0, to: -10, by: -1)<br></p><p>and <br></p><p>&gt;    (-9...0).reverse()<br></p><p>both represent the numbers -9, -8,...,0 better than any alternatives I have offered. I still<br>prefer the stride version for intent and clarity.<br></p><p>That said, I also prefer my revised SE-0051 semantics for better representing what strides will<br>attempt to do.<br></p><p>-- Erica<br>p.s. Thanks all for the patient explanations<br></p><p><br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160405/27aa14d1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April  6, 2016 at 12:00:00am</p></header><div class="content"><p>I think my opinion is largely the same. A range is not a stride, and<br>sometimes we have use for striding backwards, a use case that shouldn&#39;t be<br>penalized. +1 to the free function.<br></p><p>I wouldn&#39;t mind, orthogonally, a way to express (a, b] as a range. It just<br>seems like that should be of use, somewhere.<br></p><p>Finally, orthogonal to all of the above, I&#39;m super eager to end error<br>accumulation in floating point strides.<br>On Tue, Apr 5, 2016 at 6:52 PM Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Apr 5, 2016, at 5:22 PM, Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; I don&#39;t think that&#39;s obvious at all, because 0 ≮ 10<br>&gt;<br>&gt;<br>&gt; Points brought up elsewhere:<br>&gt;<br>&gt; * A range does not have direction, it is is an area of variation between<br>&gt; lower and upper limits.<br>&gt; * A range does not go from a larger amount to a smaller amount because it<br>&gt; is not a sequence<br>&gt; * Much of this problem goes away with striding (as Dave pointed out<br>&gt; several times, sorry Dave)<br>&gt;<br>&gt; After consideration, I have been persuaded to the opinion that<br>&gt;<br>&gt;  stride(from: 0, to: -10, by: -1)<br>&gt;<br>&gt;<br>&gt; and<br>&gt;<br>&gt;    (-9...0).reverse()<br>&gt;<br>&gt;<br>&gt; both represent the numbers -9, -8,...,0 better than any alternatives I<br>&gt; have offered. I still<br>&gt; prefer the stride version for intent and clarity.<br>&gt;<br>&gt; That said, I also prefer my revised SE-0051 semantics for better<br>&gt; representing what strides will<br>&gt; attempt to do.<br>&gt;<br>&gt; -- Erica<br>&gt; p.s. Thanks all for the patient explanations<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/1eb3bb1a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April  6, 2016 at 09:00:00am</p></header><div class="content"><p>on Tue Apr 05 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br></p><p>&gt; I think my opinion is largely the same. A range is not a stride, <br></p><p>I don&#39;t think anyone on this thread has suggested they could be<br>considered the same... until just now.<br></p><p>&gt; and sometimes we have use for striding backwards, a use case that<br>&gt; shouldn&#39;t be penalized. +1 to the free function.<br>&gt;<br>&gt; I wouldn&#39;t mind, orthogonally, a way to express (a, b] as a range. It<br>&gt; just seems like that should be of use, somewhere.<br></p><p>But that&#39;s not a strong enough reason to add it to the standard library.<br></p><p>&gt; Finally, orthogonal to all of the above, I&#39;m super eager to end error<br>&gt; accumulation in floating point strides.<br></p><p>Looking forward to those results, too!<br></p><p>&gt; On Tue, Apr 5, 2016 at 6:52 PM Erica Sadun via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;         On Apr 5, 2016, at 5:22 PM, Dave Abrahams via swift-evolution<br>&gt;         &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;         I don&#39;t think that&#39;s obvious at all, because 0 ≮ 10<br>&gt;<br>&gt;     Points brought up elsewhere:<br>&gt;<br>&gt;     * A range does not have direction, it is is an area of variation between<br>&gt;     lower and upper limits.<br>&gt;     * A range does not go from a larger amount to a smaller amount because it is<br>&gt;     not a sequence<br>&gt;     * Much of this problem goes away with striding (as Dave pointed out several<br>&gt;     times, sorry Dave)<br>&gt;<br>&gt;     After consideration, I have been persuaded to the opinion that<br>&gt;<br>&gt;         stride(from: 0, to: -10, by: -1)<br>&gt;<br>&gt;     and <br>&gt;<br>&gt;         (-9...0).reverse()<br>&gt;<br>&gt;     both represent the numbers -9, -8,...,0 better than any alternatives I have<br>&gt;     offered. I still<br>&gt;     prefer the stride version for intent and clarity.<br>&gt;<br>&gt;     That said, I also prefer my revised SE-0051 semantics for better<br>&gt;     representing what strides will<br>&gt;     attempt to do.<br>&gt;<br>&gt;     -- Erica<br>&gt;<br>&gt;     p.s. Thanks all for the patient explanations<br>&gt;<br>&gt;     _______________________________________________<br>&gt;     swift-evolution mailing list<br>&gt;     swift-evolution at swift.org<br>&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p>-- <br>Dave<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April  6, 2016 at 09:00:00am</p></header><div class="content"><p>on Tue Apr 05 2016, Erica Sadun &lt;erica-AT-ericasadun.com&gt; wrote:<br></p><p>&gt;     On Apr 5, 2016, at 5:22 PM, Dave Abrahams via swift-evolution<br>&gt;     &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;     I don&#39;t think that&#39;s obvious at all, because 0 ≮ 10<br>&gt;<br>&gt; Points brought up elsewhere:<br></p><p>Sorry, I&#39;ve tried, but I&#39;m afraid I don&#39;t understand any of this:<br></p><p>&gt; * A range does not have direction, it is is an area of variation between lower<br>&gt; and upper limits.<br></p><p>I don&#39;t know what you mean by “does not have direction.”  We&#39;re talking<br>about a concept whose Bound must be Comparable, so there&#39;s an implied<br>ordering of bounds: the lower bound precedes (or is coincident with) the<br>upper bound.  This ordering is also strongly implied by the form of the<br>..&lt; operator.<br></p><p>&gt; * A range does not go from a larger amount to a smaller amount because it is not<br>&gt;   a sequence<br></p><p>Ranges with Integer strides *are* sequences.  Are you saying that<br>there&#39;s no good reason to expect any particular traversal order?<br></p><p>&gt; <br>&gt; * Much of this problem goes away with striding (as Dave pointed out<br>&gt; several times, sorry Dave)<br></p><p>What problem goes away with striding, and how?  I pointed this out?<br></p><p>&gt; After consideration, I have been persuaded to the opinion that<br>&gt;<br>&gt;     stride(from: 0, to: -10, by: -1)<br>&gt;<br>&gt; and <br>&gt;<br>&gt;     (-9...0).reverse()<br>&gt;<br>&gt; both represent the numbers -9, -8,...,0 better than any alternatives I<br>&gt; have offered. I still prefer the stride version for intent and<br>&gt; clarity.<br></p><p>I agree it&#39;s clearer.  The only question I have about this is whether<br>it&#39;s worth the complexity, since the choice isn&#39;t between the first and<br>the second, but between *both* and the second.<br></p><p>&gt; That said, I also prefer my revised SE-0051 semantics for better<br>&gt; representing what strides will attempt to do.<br></p><p><br>My biggest problem with that proposal is that it isn&#39;t clear that these<br>three distinctions map onto important use-cases.  The only reason we<br>ended up with stride(to:...) and stride(through:...) in the first place<br>was that we have closed and open ranges.  In other words, the two<br>original distinctions were not driven by use-cases.  Now SE-0051 is<br>talking about expanding them to three distinctions in the name of<br>clarity, still without use-cases to motivate them.  I&#39;d rather roll<br>these features back while we still can, as long as there&#39;s another<br>reasonable way to express them, until we find out what kinds of things<br>people actually want to write that are difficult to express.<br></p><p>For example, there are all kinds of other ways to slice this:<br></p><p>    stride(over: 0..&lt;200, by: -2)<br></p><p>    stride(100, stepsOver: 0..&lt;200)<br></p><p>    (0..&lt;200).divided(into: 100)<br>    <br>    (0..&lt;200).stepping(100).times<br></p><p>    (0..&lt;200) / 100<br></p><p>I&#39;m not suggesting any of these, in particular.  I&#39;m just saying, we<br>don&#39;t really even have a good idea of what will suit peoples&#39; real-world<br>needs.<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April  6, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; For example, there are all kinds of other ways to slice this:<br>&gt; <br>&gt;    stride(over: 0..&lt;200, by: -2)<br></p><p>This seems like a particularly good solution. The way I understand it at least, it would allow ranges to always be ordered, with the only difference being whether it went start-to-end or end-to-start, determined by the stride&#39;s sign.<br></p><p>It would also avoid the need for additional range operators. The main reason you would need `&gt;..` is so you could say `array.endIndex&gt;..array.startIndex`, but by using the sign to decide which direction to stride over the range, you instead stride over `array.startIndex..&lt;array.endIndex`, which is exactly what we already have.<br></p><p>Unfortunately, moving away from `stride(from:to/through:by:)` would kind of mess up an idea I&#39;ve been developing for providing an &quot;induction sequence&quot; to replace the more complicated C-style for use cases, but I suppose that&#39;s the way it goes...<br></p><p>(Link to that: https://gist.github.com/brentdax/b24dd89a770d9fe376984498d3185187)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April  6, 2016 at 10:00:00am</p></header><div class="content"><p>on Wed Apr 06 2016, Brent Royal-Gordon &lt;brent-AT-architechies.com&gt; wrote:<br></p><p>&gt;&gt; For example, there are all kinds of other ways to slice this:<br>&gt;&gt; <br>&gt;&gt;    stride(over: 0..&lt;200, by: -2)<br>&gt;<br>&gt; This seems like a particularly good solution. The way I understand it<br>&gt; at least, it would allow ranges to always be ordered, with the only<br>&gt; difference being whether it went start-to-end or end-to-start,<br>&gt; determined by the stride&#39;s sign.<br></p><p>This is no different in principle from<br></p><p>     (0..&lt;200).striding(by: -2)<br></p><p>Again, I wasn&#39;t trying to suggest any of the solutions listed there.<br>The point I was making was that we don&#39;t have enough information to<br>design more than<br></p><p>    (0..&lt;200).striding(by: -2)<br></p><p>&gt; It would also avoid the need for additional range operators. The main<br>&gt; reason you would need `&gt;..` is so you could say<br>&gt; `array.endIndex&gt;..array.startIndex`, but by using the sign to decide<br>&gt; which direction to stride over the range, you instead stride over<br>&gt; `array.startIndex..&lt;array.endIndex`, which is exactly what we already<br>&gt; have.<br>&gt;<br>&gt; Unfortunately, moving away from `stride(from:to/through:by:)` would<br>&gt; kind of mess up an idea I&#39;ve been developing for providing an<br>&gt; &quot;induction sequence&quot; to replace the more complicated C-style for use<br>&gt; cases, but I suppose that&#39;s the way it goes...<br>&gt;<br>&gt; (Link to that: https://gist.github.com/brentdax/b24dd89a770d9fe376984498d3185187)<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April  6, 2016 at 05:00:00pm</p></header><div class="content"><p>I think a lightbulb just went on for me:<br></p><p>You&#39;re talking about expressing something in the vein of<br>`(0..&lt;200).striding(by: -2)`, which has I&#39;m sure many use cases, and which<br>isn&#39;t straightforward to express with the current free function--I hadn&#39;t<br>considered that.<br></p><p>Meanwhile, I was trying to talk about something like `stride(from: 200, to:<br>0, by: -2)`, which is easily expressed today but isn&#39;t straightforward at<br>all to preserve with only ranges. Clearly, given that this is what&#39;s on<br>offer currently, someone who designed the language thinks (or thought) it&#39;s<br>of some use.<br></p><p>In the absence of information as to which is more in demand, couldn&#39;t we<br>have both? If it must be a method on a range, then I would advocate for<br>having what seems to be an utterly reasonable set of options for striding<br>backwards:<br></p><p>```<br>(0...200).striding(by: -2) // [a, b]<br>(0..&lt;200).striding(by: -2) // [a, b)<br>(0&lt;..200).striding(by: -2) // (a, b]<br>```<br>On Wed, Apr 6, 2016 at 12:10 PM Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; on Wed Apr 06 2016, Brent Royal-Gordon &lt;brent-AT-architechies.com&gt; wrote:<br>&gt;<br>&gt; &gt;&gt; For example, there are all kinds of other ways to slice this:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;    stride(over: 0..&lt;200, by: -2)<br>&gt; &gt;<br>&gt; &gt; This seems like a particularly good solution. The way I understand it<br>&gt; &gt; at least, it would allow ranges to always be ordered, with the only<br>&gt; &gt; difference being whether it went start-to-end or end-to-start,<br>&gt; &gt; determined by the stride&#39;s sign.<br>&gt;<br>&gt; This is no different in principle from<br>&gt;<br>&gt;      (0..&lt;200).striding(by: -2)<br>&gt;<br>&gt; Again, I wasn&#39;t trying to suggest any of the solutions listed there.<br>&gt; The point I was making was that we don&#39;t have enough information to<br>&gt; design more than<br>&gt;<br>&gt;     (0..&lt;200).striding(by: -2)<br>&gt;<br>&gt; &gt; It would also avoid the need for additional range operators. The main<br>&gt; &gt; reason you would need `&gt;..` is so you could say<br>&gt; &gt; `array.endIndex&gt;..array.startIndex`, but by using the sign to decide<br>&gt; &gt; which direction to stride over the range, you instead stride over<br>&gt; &gt; `array.startIndex..&lt;array.endIndex`, which is exactly what we already<br>&gt; &gt; have.<br>&gt; &gt;<br>&gt; &gt; Unfortunately, moving away from `stride(from:to/through:by:)` would<br>&gt; &gt; kind of mess up an idea I&#39;ve been developing for providing an<br>&gt; &gt; &quot;induction sequence&quot; to replace the more complicated C-style for use<br>&gt; &gt; cases, but I suppose that&#39;s the way it goes...<br>&gt; &gt;<br>&gt; &gt; (Link to that:<br>&gt; https://gist.github.com/brentdax/b24dd89a770d9fe376984498d3185187)<br>&gt;<br>&gt; --<br>&gt; Dave<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/fb56468b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6d3081a5b9c408dfecc2681ab82af734?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Milos Rankovic</string> &lt;milos at milos-and-slavica.net&gt;<p>April  6, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On 6 Apr 2016, at 18:57, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Meanwhile, I was trying to talk about something like `stride(from: 200, to: 0, by: -2)`, which is easily expressed today but isn&#39;t straightforward at all to preserve with only ranges.<br></p><p>Precisely because the free function is also range-free, the sign of the step need not repeat the direction intent which is already indicated with `from: 200, to: 0`. In other words, I think this is much more intuitive:<br></p><p>     `stride(from: 200, to: 0, by: 2)`<br></p><p>milos<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/a43f52b1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April  6, 2016 at 11:00:00am</p></header><div class="content"><p>on Wed Apr 06 2016, Milos Rankovic &lt;milos-AT-milos-and-slavica.net&gt; wrote:<br></p><p>&gt;     On 6 Apr 2016, at 18:57, Xiaodi Wu via swift-evolution<br>&gt;     &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;     Meanwhile, I was trying to talk about something like `stride(from: 200, to:<br>&gt;     0, by: -2)`, which is easily expressed today but isn&#39;t straightforward at<br>&gt;     all to preserve with only ranges.<br>&gt;<br>&gt; Precisely because the free function is also range-free, the sign of the step<br>&gt; need not repeat the direction intent which is already indicated with `from: 200,<br>&gt; to: 0`. In other words, I think this is much more intuitive:<br>&gt;<br>&gt; `stride(from: 200, to: 0, by: 2)`<br></p><p>But it leaves the “does it include 0?” question less clear than<br>something involving 0..&lt;200 would.<br></p><p>-- <br>Dave<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April  6, 2016 at 11:00:00am</p></header><div class="content"><p>on Wed Apr 06 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br></p><p>&gt; I think a lightbulb just went on for me:<br>&gt;<br>&gt; You&#39;re talking about expressing something in the vein of `(0..&lt;200).striding(by:<br>&gt; -2)`, which has I&#39;m sure many use cases, and which isn&#39;t straightforward to<br>&gt; express with the current free function--I hadn&#39;t considered that.<br>&gt;<br>&gt; Meanwhile, I was trying to talk about something like `stride(from: 200, to: 0,<br>&gt; by: -2)`, which is easily expressed today but isn&#39;t straightforward at all to<br>&gt; preserve with only ranges. Clearly, given that this is what&#39;s on offer<br>&gt; currently, someone who designed the language thinks (or thought) it&#39;s of some<br>&gt; use.<br></p><p>That someone was me, and I explained that it wasn&#39;t an extremely<br>deeply-considered decision.<br></p><p>&gt; In the absence of information as to which is more in demand, couldn&#39;t<br>&gt; we have both? <br></p><p>That&#39;s not how we make decisions about what should be in the language or<br>standard library.  We need to make choices based on (at least educated<br>guesses about) what people need, or we&#39;ll end up with a sprawling mess.<br></p><p>&gt; If it must be a method on a range, <br></p><p>It&#39;s not that it must be, but having such a method tends to reduce API<br>surface area.  We prefer methods to free functions.<br></p><p>&gt; then I would advocate for having what seems to be an utterly<br>&gt; reasonable set of options for striding backwards:<br>&gt;<br>&gt; ```<br>&gt; (0...200).striding(by: -2) // [a, b]<br>&gt; (0..&lt;200).striding(by: -2) // [a, b)<br>&gt; (0&lt;..200).striding(by: -2) // (a, b]<br>&gt; ```<br></p><p>And I&#39;m trying to say that without a more compelling reason to introduce<br>`&lt;..`, I don&#39;t want to do it.  I&#39;d like to know that `&lt;..` is useful<br>outside the domain of striding, for example.  Use-cases, anyone?<br></p><p>Reasons we might not need it: the cases where it&#39;s important are much<br>more likely to be notionally continuous domains (e.g. floats), since you<br>can always write<br></p><p>    ((0+1)...200).striding(by: -2)<br></p><p>and if you need the floating version there&#39;s always<br></p><p>   (0.0...200.0).striding(by: -2).lazy.filter { $0 != 0.0 }<br></p><p>which probably optimizes down to the same code.<br></p><p>One question that I *do* think we should answer, is whether the elements<br>of<br></p><p>    (0..&lt;199).striding(by: -2)<br></p><p>are even or odd.<br></p><p>&gt; On Wed, Apr 6, 2016 at 12:10 PM Dave Abrahams via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;     on Wed Apr 06 2016, Brent Royal-Gordon &lt;brent-AT-architechies.com&gt; wrote:<br>&gt;<br>&gt;     &gt;&gt; For example, there are all kinds of other ways to slice this:<br>&gt;     &gt;&gt;<br>&gt;     &gt;&gt; stride(over: 0..&lt;200, by: -2)<br>&gt;     &gt;<br>&gt;     &gt; This seems like a particularly good solution. The way I understand it<br>&gt;     &gt; at least, it would allow ranges to always be ordered, with the only<br>&gt;     &gt; difference being whether it went start-to-end or end-to-start,<br>&gt;     &gt; determined by the stride&#39;s sign.<br>&gt;<br>&gt;     This is no different in principle from<br>&gt;<br>&gt;     (0..&lt;200).striding(by: -2)<br>&gt;<br>&gt;     Again, I wasn&#39;t trying to suggest any of the solutions listed there.<br>&gt;     The point I was making was that we don&#39;t have enough information to<br>&gt;     design more than<br>&gt;<br>&gt;     (0..&lt;200).striding(by: -2)<br>&gt;<br>&gt;     &gt; It would also avoid the need for additional range operators. The main<br>&gt;     &gt; reason you would need `&gt;..` is so you could say<br>&gt;     &gt; `array.endIndex&gt;..array.startIndex`, but by using the sign to decide<br>&gt;     &gt; which direction to stride over the range, you instead stride over<br>&gt;     &gt; `array.startIndex..&lt;array.endIndex`, which is exactly what we already<br>&gt;     &gt; have.<br>&gt;     &gt;<br>&gt;     &gt; Unfortunately, moving away from `stride(from:to/through:by:)` would<br>&gt;     &gt; kind of mess up an idea I&#39;ve been developing for providing an<br>&gt;     &gt; &quot;induction sequence&quot; to replace the more complicated C-style for use<br>&gt;     &gt; cases, but I suppose that&#39;s the way it goes...<br>&gt;     &gt;<br>&gt;     &gt; (Link to that:<br>&gt;     https://gist.github.com/brentdax/b24dd89a770d9fe376984498d3185187)<br>&gt;<br>&gt;     --<br>&gt;     Dave<br>&gt;     _______________________________________________<br>&gt;     swift-evolution mailing list<br>&gt;     swift-evolution at swift.org<br>&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>April  6, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Apr 6, 2016, at 11:16 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; One question that I *do* think we should answer, is whether the elements<br>&gt; of<br>&gt; <br>&gt;    (0..&lt;199).striding(by: -2)<br>&gt; <br>&gt; are even or odd.<br></p><p>Odd.  I don’t believe that many real use cases care, but odd is more efficient from a performance perspective.  Needs to be documented clearly, however.<br></p><p>– Steve<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/5a768fb4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>April  6, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Apr 6, 2016, at 11:20 AM, Stephen Canon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Apr 6, 2016, at 11:16 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; One question that I *do* think we should answer, is whether the elements<br>&gt;&gt; of<br>&gt;&gt; <br>&gt;&gt;    (0..&lt;199).striding(by: -2)<br>&gt;&gt; <br>&gt;&gt; are even or odd.<br>&gt; <br>&gt; Odd.  I don’t believe that many real use cases care, but odd is more efficient from a performance perspective.  Needs to be documented clearly, however.<br></p><p>Sorry, I was thinking of (0…199).striding(by: -2).<br></p><p>For the (0..&lt;199) case, Erica’s assessment seems about right, though it isn’t at all obvious how it generalizes to floating point strides.<br></p><p>– Steve<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/b0240d01/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April  6, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Apr 6, 2016, at 12:23 PM, Stephen Canon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 6, 2016, at 11:20 AM, Stephen Canon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Apr 6, 2016, at 11:16 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One question that I *do* think we should answer, is whether the elements<br>&gt;&gt;&gt; of<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    (0..&lt;199).striding(by: -2)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; are even or odd.<br>&gt;&gt; <br>&gt;&gt; Odd.  I don’t believe that many real use cases care, but odd is more efficient from a performance perspective.  Needs to be documented clearly, however.<br>&gt; <br>&gt; Sorry, I was thinking of (0…199).striding(by: -2).<br>&gt; <br>&gt; For the (0..&lt;199) case, Erica’s assessment seems about right, though it isn’t at all obvious how it generalizes to floating point strides.<br></p><p>(l..&lt;h).striding(by: -dX) is undefined for floating point strides as there cannot be a starting value.<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/ccc7ca6a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>April  6, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Apr 6, 2016, at 11:26 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Apr 6, 2016, at 12:23 PM, Stephen Canon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Apr 6, 2016, at 11:20 AM, Stephen Canon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Apr 6, 2016, at 11:16 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One question that I *do* think we should answer, is whether the elements<br>&gt;&gt;&gt;&gt; of<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    (0..&lt;199).striding(by: -2)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; are even or odd.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Odd.  I don’t believe that many real use cases care, but odd is more efficient from a performance perspective.  Needs to be documented clearly, however.<br>&gt;&gt; <br>&gt;&gt; Sorry, I was thinking of (0…199).striding(by: -2).<br>&gt;&gt; <br>&gt;&gt; For the (0..&lt;199) case, Erica’s assessment seems about right, though it isn’t at all obvious how it generalizes to floating point strides.<br>&gt; <br>&gt; (l..&lt;h).striding(by: -dX) is undefined for floating point strides as there cannot be a starting value.<br></p><p>I’m OK with this.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/13d75107/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>April  7, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; Am 06.04.2016 um 20:26 schrieb Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt;&gt;&gt; On Apr 6, 2016, at 12:23 PM, Stephen Canon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Apr 6, 2016, at 11:20 AM, Stephen Canon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Apr 6, 2016, at 11:16 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One question that I *do* think we should answer, is whether the elements<br>&gt;&gt;&gt;&gt; of<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    (0..&lt;199).striding(by: -2)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; are even or odd.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Odd.  I don’t believe that many real use cases care, but odd is more efficient from a performance perspective.  Needs to be documented clearly, however.<br>&gt;&gt; <br>&gt;&gt; Sorry, I was thinking of (0…199).striding(by: -2).<br>&gt;&gt; <br>&gt;&gt; For the (0..&lt;199) case, Erica’s assessment seems about right, though it isn’t at all obvious how it generalizes to floating point strides.<br>&gt; <br>&gt; (l..&lt;h).striding(by: -dX) is undefined for floating point strides as there cannot be a starting value.<br></p><p>Why?<br>The starting value could quite naturally be s = l + k*dX for the largest value of k in the natural numbers for which s &lt; h, wouldn&#39;t it?<br></p><p>-Thorsten <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160407/96216c8a/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April  6, 2016 at 11:00:00am</p></header><div class="content"><p>on Wed Apr 06 2016, Stephen Canon &lt;scanon-AT-apple.com&gt; wrote:<br></p><p>&gt;     On Apr 6, 2016, at 11:20 AM, Stephen Canon via swift-evolution<br>&gt;     &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;         On Apr 6, 2016, at 11:16 AM, Dave Abrahams via swift-evolution<br>&gt;         &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;         One question that I *do* think we should answer, is whether the elements<br>&gt;         of<br>&gt;<br>&gt;         (0..&lt;199).striding(by: -2)<br>&gt;<br>&gt;         are even or odd.<br>&gt;<br>&gt;     Odd. I don’t believe that many real use cases care, but odd is more<br>&gt;     efficient from a performance perspective. Needs to be documented clearly,<br>&gt;     however.<br>&gt;<br>&gt; Sorry, I was thinking of (0…199).striding(by: -2).<br>&gt;<br>&gt; For the (0..&lt;199) case, Erica’s assessment <br></p><p>which is...?<br></p><p>&gt; seems about right, though it isn’t at all obvious how it generalizes<br>&gt; to floating point strides.<br>&gt;<br>&gt; – Steve<br>&gt;<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April  6, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Apr 6, 2016, at 12:30 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; on Wed Apr 06 2016, Stephen Canon &lt;scanon-AT-apple.com&gt; wrote:<br>&gt;&gt; For the (0..&lt;199) case, Erica’s assessment <br>&gt; <br>&gt; which is...?<br></p><p>https://gist.github.com/erica/786ab9703f699db1301be65510e7da03 &lt;https://gist.github.com/erica/786ab9703f699db1301be65510e7da03&gt;<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/836f16c0/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April  6, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Apr 6, 2016, at 12:16 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;    (0..&lt;199).striding(by: -2)<br>&gt; <br>&gt; are even or odd.<br></p><p>(0..&lt;199).striding(by: -2): 0..&lt;199 == 0...198 Even<br>(1..&lt;199).striding(by: -2): 1..&lt;199 == 1...198 Even<br>(0..&lt;198).striding(by: -2): 1..&lt;198 == 0...197 Odd<br>(1..&lt;198).striding(by: -2): 1..&lt;198 == 1...197 Odd<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/84fff3fd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April  6, 2016 at 11:00:00am</p></header><div class="content"><p>on Wed Apr 06 2016, Erica Sadun &lt;erica-AT-ericasadun.com&gt; wrote:<br></p><p>&gt;     On Apr 6, 2016, at 12:16 PM, Dave Abrahams via swift-evolution<br>&gt;     &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;     (0..&lt;199).striding(by: -2)<br>&gt;<br>&gt;     are even or odd.<br>&gt;<br>&gt; (0..&lt;199).striding(by: -2): 0..&lt;199 == 0...198 Even<br>&gt; (1..&lt;199).striding(by: -2): 1..&lt;199 == 1...198 Even<br></p><p>I understand the logic that got you there, but I find it incredibly<br>counter-intuitive that striding by 2s over a range with odd endpoints<br>should produce even numbers... I can&#39;t imagine any way I&#39;d be convinced<br>that was a good idea.<br></p><p>&gt; (0..&lt;198).striding(by: -2): 1..&lt;198 == 0...197 Odd<br>&gt; (1..&lt;198).striding(by: -2): 1..&lt;198 == 1...197 Odd<br>&gt;<br>&gt; -- E<br>&gt;<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April  6, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Apr 6, 2016, at 12:43 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Wed Apr 06 2016, Erica Sadun &lt;erica-AT-ericasadun.com&gt; wrote:<br>&gt; <br>&gt;&gt;    On Apr 6, 2016, at 12:16 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;    &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;    (0..&lt;199).striding(by: -2)<br>&gt;&gt; <br>&gt;&gt;    are even or odd.<br>&gt;&gt; <br>&gt;&gt; (0..&lt;199).striding(by: -2): 0..&lt;199 == 0...198 Even<br>&gt;&gt; (1..&lt;199).striding(by: -2): 1..&lt;199 == 1...198 Even<br>&gt; <br>&gt; I understand the logic that got you there, but I find it incredibly<br>&gt; counter-intuitive that striding by 2s over a range with odd endpoints<br>&gt; should produce even numbers... I can&#39;t imagine any way I&#39;d be convinced<br>&gt; that was a good idea.<br></p><p>Guidance:<br></p><p>When using odd integer literals to produce an even number sequence,<br>prefer the `...` operator to the `..&lt;` operator and change your ending<br>literal to an even number.<br></p><p>-- E<br></p><p><br>&gt; <br>&gt;&gt; (0..&lt;198).striding(by: -2): 1..&lt;198 == 0...197 Odd<br>&gt;&gt; (1..&lt;198).striding(by: -2): 1..&lt;198 == 1...197 Odd<br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br>&gt; <br>&gt; -- <br>&gt; Dave<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April  6, 2016 at 03:00:00pm</p></header><div class="content"><p>On Wed, Apr 6, 2016 at 1:43 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;<br>&gt; on Wed Apr 06 2016, Erica Sadun &lt;erica-AT-ericasadun.com&gt; wrote:<br>&gt;<br>&gt;&gt;     On Apr 6, 2016, at 12:16 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;     &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;     (0..&lt;199).striding(by: -2)<br>&gt;&gt;<br>&gt;&gt;     are even or odd.<br>&gt;&gt;<br>&gt;&gt; (0..&lt;199).striding(by: -2): 0..&lt;199 == 0...198 Even<br>&gt;&gt; (1..&lt;199).striding(by: -2): 1..&lt;199 == 1...198 Even<br>&gt;<br>&gt; I understand the logic that got you there, but I find it incredibly<br>&gt; counter-intuitive that striding by 2s over a range with odd endpoints<br>&gt; should produce even numbers... I can&#39;t imagine any way I&#39;d be convinced<br>&gt; that was a good idea.<br>&gt;<br>&gt;&gt; (0..&lt;198).striding(by: -2): 1..&lt;198 == 0...197 Odd<br>&gt;&gt; (1..&lt;198).striding(by: -2): 1..&lt;198 == 1...197 Odd<br>&gt;&gt;<br></p><p>One other aspect of the counterintuitiveness is that<br>`(a..&lt;b).striding(by: -c)` has been discussed, even in this thread, as<br>essentially reversing the sequence given by `(a..&lt;b).striding(by: c)`.<br>That would not be the case with the logic presented here. I worry that<br>there is no obviously correct interpretation of `(a..&lt;b).striding(by:<br>-c)` and wonder if any conclusion arrived at would necessarily be more<br>confusing that `stride(from:to:by:)`.<br></p><p>Prohibiting StrideTo with floating-point ranges altogether would be<br>distressing. IMO, it&#39;s plenty distressing that backwards<br>floating-point StrideTo as it currently exists might go away.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April  6, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Apr 6, 2016, at 2:17 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; Prohibiting StrideTo with floating-point ranges altogether would be<br>&gt; distressing. IMO, it&#39;s plenty distressing that backwards<br>&gt; floating-point StrideTo as it currently exists might go away.<br></p><p>I wouldn&#39;t suggest doing so. I&#39;m just saying that for a half-open interval, there is no max value<br>so it makes no sense mathematically to have a first value and a negative step. You&#39;re not so restricted <br>with:<br></p><p>* positive steps<br>* closed intervals<br></p><p>-- E<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>April  7, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; Am 06.04.2016 um 22:17 schrieb Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt;&gt; On Wed, Apr 6, 2016 at 1:43 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; on Wed Apr 06 2016, Erica Sadun &lt;erica-AT-ericasadun.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    On Apr 6, 2016, at 12:16 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;    &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;    (0..&lt;199).striding(by: -2)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    are even or odd.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (0..&lt;199).striding(by: -2): 0..&lt;199 == 0...198 Even<br>&gt;&gt;&gt; (1..&lt;199).striding(by: -2): 1..&lt;199 == 1...198 Even<br>&gt;&gt; <br>&gt;&gt; I understand the logic that got you there, but I find it incredibly<br>&gt;&gt; counter-intuitive that striding by 2s over a range with odd endpoints<br>&gt;&gt; should produce even numbers... I can&#39;t imagine any way I&#39;d be convinced<br>&gt;&gt; that was a good idea.<br>&gt;&gt; <br>&gt;&gt;&gt; (0..&lt;198).striding(by: -2): 1..&lt;198 == 0...197 Odd<br>&gt;&gt;&gt; (1..&lt;198).striding(by: -2): 1..&lt;198 == 1...197 Odd<br>&gt; <br>&gt; One other aspect of the counterintuitiveness is that<br>&gt; `(a..&lt;b).striding(by: -c)` has been discussed, even in this thread, as<br>&gt; essentially reversing the sequence given by `(a..&lt;b).striding(by: c)`.<br>&gt; That would not be the case with the logic presented here. I worry that<br>&gt; there is no obviously correct interpretation of `(a..&lt;b).striding(by:<br>&gt; -c)` and wonder if any conclusion arrived at would necessarily be more<br>&gt; confusing that `stride(from:to:by:)`.<br></p><p>Yep, that&#39;s my impression, too.<br></p><p>-Thorsten<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6d3081a5b9c408dfecc2681ab82af734?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Milos Rankovic</string> &lt;milos at milos-and-slavica.net&gt;<p>April  6, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On 6 Apr 2016, at 19:16, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; We prefer methods to free functions.<br></p><p>However, `(from:to:by)` need not be a free function, it could be a sequence initialiser:<br></p><p>    Walk(from: 200, to: 0, by: 2)<br></p><p>or:<br></p><p>    Steps(from: 200, to: 0, by: 2)<br></p><p>or something along those lines...<br></p><p>milos<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/32c2f055/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April  6, 2016 at 03:00:00pm</p></header><div class="content"><p>On Wed, Apr 6, 2016 at 1:16 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;<br>&gt; on Wed Apr 06 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; I think a lightbulb just went on for me:<br>&gt;&gt;<br>&gt;&gt; You&#39;re talking about expressing something in the vein of `(0..&lt;200).striding(by:<br>&gt;&gt; -2)`, which has I&#39;m sure many use cases, and which isn&#39;t straightforward to<br>&gt;&gt; express with the current free function--I hadn&#39;t considered that.<br>&gt;&gt;<br>&gt;&gt; Meanwhile, I was trying to talk about something like `stride(from: 200, to: 0,<br>&gt;&gt; by: -2)`, which is easily expressed today but isn&#39;t straightforward at all to<br>&gt;&gt; preserve with only ranges. Clearly, given that this is what&#39;s on offer<br>&gt;&gt; currently, someone who designed the language thinks (or thought) it&#39;s of some<br>&gt;&gt; use.<br>&gt;<br>&gt; That someone was me, and I explained that it wasn&#39;t an extremely<br>&gt; deeply-considered decision.<br></p><p>Fair enough. Though your decision may not have been deeply considered,<br>I wouldn&#39;t say it was an ill-considered one given that there wasn&#39;t<br>(to my knowledge) any great clamor against it subsequently.<br></p><p><br>&gt;&gt; In the absence of information as to which is more in demand, couldn&#39;t<br>&gt;&gt; we have both?<br>&gt;<br>&gt; That&#39;s not how we make decisions about what should be in the language or<br>&gt; standard library.  We need to make choices based on (at least educated<br>&gt; guesses about) what people need, or we&#39;ll end up with a sprawling mess.<br></p><p>Well, to elicit the kind of feedback that would help determine user<br>needs, I would suggest that (when the eventually reconsidered syntax<br>is proposed) this change should be highlighted explicitly as a feature<br>removal. IMO, it wouldn&#39;t be otherwise immediately apparent from a<br>quick glance that revising `stride(from: 0, to: 10, by: 1)` to<br>`(0..&lt;10).striding(by: 1)` necessarily entails deletion of backwards<br>strides from upper bound to-and-not-through lower bound.<br></p><p><br>&gt;&gt; If it must be a method on a range,<br>&gt;<br>&gt; It&#39;s not that it must be, but having such a method tends to reduce API<br>&gt; surface area.  We prefer methods to free functions.<br>&gt;<br>&gt;&gt; then I would advocate for having what seems to be an utterly<br>&gt;&gt; reasonable set of options for striding backwards:<br>&gt;&gt;<br>&gt;&gt; ```<br>&gt;&gt; (0...200).striding(by: -2) // [a, b]<br>&gt;&gt; (0..&lt;200).striding(by: -2) // [a, b)<br>&gt;&gt; (0&lt;..200).striding(by: -2) // (a, b]<br>&gt;&gt; ```<br>&gt;<br>&gt; And I&#39;m trying to say that without a more compelling reason to introduce<br>&gt; `&lt;..`, I don&#39;t want to do it.  I&#39;d like to know that `&lt;..` is useful<br>&gt; outside the domain of striding, for example.  Use-cases, anyone?<br></p><p>Well, my use case (an actual one) is supremely mundane. I&#39;m doing some<br>scientific computing and I need to deal with numeric intervals. Some<br>of them are closed, some of them are open at one end, and some at the<br>other. I&#39;d like to be able to represent any of those as<br>Intervals-which-are-now-Ranges. It makes sense to do so because the<br>things I want to do with them, such as clamping and testing if some<br>value is contained, are exactly what Intervals-now-Ranges provide.<br>Looking around, it seems many other languages provide only what Swift<br>currently does, but Perl does provide `..`, `..^`, `^..`, and `^..^`<br>(which, brought over to Swift, would be `...`, `..&lt;`, `&lt;..`, and<br>`&lt;.&lt;`).<br></p><p><br>&gt; Reasons we might not need it: the cases where it&#39;s important are much<br>&gt; more likely to be notionally continuous domains (e.g. floats), since you<br>&gt; can always write<br>&gt;<br>&gt;     ((0+1)...200).striding(by: -2)<br>&gt;<br>&gt; and if you need the floating version there&#39;s always<br>&gt;<br>&gt;    (0.0...200.0).striding(by: -2).lazy.filter { $0 != 0.0 }<br>&gt;<br>&gt; which probably optimizes down to the same code.<br>&gt;<br>&gt; One question that I *do* think we should answer, is whether the elements<br>&gt; of<br>&gt;<br>&gt;     (0..&lt;199).striding(by: -2)<br>&gt;<br>&gt; are even or odd.<br>&gt;<br>&gt;&gt; On Wed, Apr 6, 2016 at 12:10 PM Dave Abrahams via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;     on Wed Apr 06 2016, Brent Royal-Gordon &lt;brent-AT-architechies.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;     &gt;&gt; For example, there are all kinds of other ways to slice this:<br>&gt;&gt;     &gt;&gt;<br>&gt;&gt;     &gt;&gt; stride(over: 0..&lt;200, by: -2)<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt; This seems like a particularly good solution. The way I understand it<br>&gt;&gt;     &gt; at least, it would allow ranges to always be ordered, with the only<br>&gt;&gt;     &gt; difference being whether it went start-to-end or end-to-start,<br>&gt;&gt;     &gt; determined by the stride&#39;s sign.<br>&gt;&gt;<br>&gt;&gt;     This is no different in principle from<br>&gt;&gt;<br>&gt;&gt;     (0..&lt;200).striding(by: -2)<br>&gt;&gt;<br>&gt;&gt;     Again, I wasn&#39;t trying to suggest any of the solutions listed there.<br>&gt;&gt;     The point I was making was that we don&#39;t have enough information to<br>&gt;&gt;     design more than<br>&gt;&gt;<br>&gt;&gt;     (0..&lt;200).striding(by: -2)<br>&gt;&gt;<br>&gt;&gt;     &gt; It would also avoid the need for additional range operators. The main<br>&gt;&gt;     &gt; reason you would need `&gt;..` is so you could say<br>&gt;&gt;     &gt; `array.endIndex&gt;..array.startIndex`, but by using the sign to decide<br>&gt;&gt;     &gt; which direction to stride over the range, you instead stride over<br>&gt;&gt;     &gt; `array.startIndex..&lt;array.endIndex`, which is exactly what we already<br>&gt;&gt;     &gt; have.<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt; Unfortunately, moving away from `stride(from:to/through:by:)` would<br>&gt;&gt;     &gt; kind of mess up an idea I&#39;ve been developing for providing an<br>&gt;&gt;     &gt; &quot;induction sequence&quot; to replace the more complicated C-style for use<br>&gt;&gt;     &gt; cases, but I suppose that&#39;s the way it goes...<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt; (Link to that:<br>&gt;&gt;     https://gist.github.com/brentdax/b24dd89a770d9fe376984498d3185187)<br>&gt;&gt;<br>&gt;&gt;     --<br>&gt;&gt;     Dave<br>&gt;&gt;     _______________________________________________<br>&gt;&gt;     swift-evolution mailing list<br>&gt;&gt;     swift-evolution at swift.org<br>&gt;&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt; --<br>&gt; Dave<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April  6, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Apr 6, 2016, at 11:10 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; Again, I wasn&#39;t trying to suggest any of the solutions listed there.<br>&gt; The point I was making was that we don&#39;t have enough information to<br>&gt; design more than<br>&gt; <br>&gt;    (0..&lt;200).striding(by: -2)<br></p><p>I like this a lot but I assure you there will be some pushback about readability of intent.<br></p><p>-- &quot;Cassandra&quot;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/bf8e94ca/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>April  6, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Apr 6, 2016, at 10:10 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Wed Apr 06 2016, Brent Royal-Gordon &lt;brent-AT-architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; For example, there are all kinds of other ways to slice this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   stride(over: 0..&lt;200, by: -2)<br>&gt;&gt; <br>&gt;&gt; This seems like a particularly good solution. The way I understand it<br>&gt;&gt; at least, it would allow ranges to always be ordered, with the only<br>&gt;&gt; difference being whether it went start-to-end or end-to-start,<br>&gt;&gt; determined by the stride&#39;s sign.<br>&gt; <br>&gt; This is no different in principle from<br>&gt; <br>&gt;     (0..&lt;200).striding(by: -2)<br>&gt; <br>&gt; Again, I wasn&#39;t trying to suggest any of the solutions listed there.<br>&gt; The point I was making was that we don&#39;t have enough information to<br>&gt; design more than<br>&gt; <br>&gt;    (0..&lt;200).striding(by: -2)<br></p><p>Of the suggestions I’ve seen floated, this is my favorite by a huge margin.<br></p><p>- It preserves the ordering of range endpoints.<br>- It supports the right kind of half-open intervals—[a,b)—for zero-based indexing.<br>- It avoids making reverse iteration significantly more complex.<br></p><p>– Steve<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>April  6, 2016 at 06:00:00pm</p></header><div class="content"><p>I think people are reading a ..&lt; b as the mathematical notation [a, b)<br>which means {}, null, or empty, not error, if b &lt; a and {a} if b = a.<br></p><p>If Range was changed to be an Array like collection indexed from 0 to count<br>and stride was how the indexed counted and was an Int &gt; 0 then the<br>following would make sense in terms of interval mathematics as described<br>above (note how stride refers to how the index counts *not* how the values<br>count):<br></p><p>(0 ... -1) == []<br>(0 ..&lt; 0) == []<br></p><p>(0 ... 0) == [0]<br>(0 ..&lt; 2) == [0, 1]<br></p><p>(0 ... 2) == [0, 1, 2]<br></p><p>(0 ..&lt; 4).strided(by: 2) == [0, 1, 2, 3].strided(by: 2) == [0, 2]<br></p><p>(0 ... 4).strided(by: 2) == [0, 1, 2, 3, 4].strided(by: 2) == [0, 2, 4]<br></p><p>(0 ..&lt; 2).reversed == [0, 1].reversed == [1, 0]<br></p><p>(0 ..&lt; 4).strided(by: 2).reversed == [0, 1, 2, 3].strided(by: 2).reversed<br>== [0, 2].reversed == [2, 0]<br></p><p>(-2 ..&lt; 2).strided(by: 2).reversed == [-2, -1, 0, 1].strided(by:<br>2).reversed == [-2, 0].reversed == [0, -2]<br></p><p>(-2 ..&lt; 2).reversed.strided(by: 2) == [-2, -1, 0, 1].reversed.strided(by:<br>2) == [1, 0, -1, -2].strided(by: 2) == [1, -1]<br></p><p><br>Then provide a very general init for Range to cope with difficult cases:<br></p><p>init(first: T, isFirstIncluded: Bool = true, last: T, isLastIncluded: Bool<br>= true, stride: Int = 1)<br></p><p>Range(first: 0, last: 0, stride: 0) // ERROR, stride must be &gt; 0<br>Range(first: 0, last: 0) == [0]<br></p><p>Range(first: 0, isFirstIncluded: false, last: 0) == [] // {x | first &lt; x &lt;=<br>last }<br>Range(first: 0, last: 0, isLastIncluded: false) == [] // {x | first &lt;= x &lt;<br>last }<br></p><p>Range(first: -2, isFirstIncluded: false, last: 2, isLastIncluded: false) ==<br>[-1, 0, 1]<br>Range(first: -2, isFirstIncluded: false, last: 2, isLastIncluded: false,<br>stride: 2) == [-1, 1]<br></p><p><br>Note: only ForwardIndexType necessary.<br></p><p>  -- Howard.<br></p><p>On 6 April 2016 at 09:22, Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; on Tue Apr 05 2016, Erica Sadun &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; &gt;&gt; On Apr 5, 2016, at 4:17 PM, Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; on Tue Apr 05 2016, Erica Sadun &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;<br>&gt; &gt;&gt;&gt;    On Apr 5, 2016, at 1:54 PM, Dave Abrahams<br>&gt; &gt;&gt;&gt;    &lt;dabrahams at apple.com&gt; wrote:<br>&gt; &gt;&gt;&gt;    IMO this:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;    (-9...0).reverse()<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;    is better than<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;    stride(from: 0, to: -10, by: -1)<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;    What do you think?<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; The latter better reflects an author&#39;s actual intent. The former<br>&gt; depends on<br>&gt; &gt;&gt;&gt; implementation details, which can be hazy, especially, around the edge<br>&gt; cases. It<br>&gt; &gt;&gt;&gt; is quicker to read, understand, and verify that the latter is what is<br>&gt; &gt;&gt;&gt; meant.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Except that there seems to be some confusion over what &quot;to:&quot; means,<br>&gt; right?<br>&gt; &gt;<br>&gt; &gt; obviously (0..&lt;-10).by(-2) would be best.<br>&gt;<br>&gt; I don&#39;t think that&#39;s obvious at all, because 0 ≮ 10<br>&gt;<br>&gt; --<br>&gt; Dave<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/97e5567d/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
