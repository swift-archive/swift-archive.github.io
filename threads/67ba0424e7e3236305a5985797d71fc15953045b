<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4bb2d8cd29d26d7067e8b62a5e1cbf95?s=50"></div><header><strong>Swiftier? implementation of Measurement and Unit in Foundation</strong> from <string>Joanna Carter</string> &lt;joanna at carterconsulting.org.uk&gt;<p>August 11, 2016 at 11:00:00am</p></header><div class="content"><p>Having had to implement convertible measurements and units for a project a couple of years ago, I thought I would take a look at the upcoming Measurements and Units implementations as found in the Github archive.<br></p><p>Since we are continually being told that protocol-oriented code and the preferred use of structs were good things, I was surprised at the class inheritance I found.<br></p><p>As a long-time proponent of OO design (some 29 years) I know that classes are not &quot;evil&quot; but was interested to see if Swift 2.2 could manage to implement Measurements and Units without falling into the inheritance trap where unnecessary implementation has to be included throughout a class hierarchy.<br></p><p>I replaced the name Dimension with ConvertibleUnit as I felt a Dimension was not truly a Unit; in fact, a Dimension could be better described in terms of composition rather than inheritance i.e. a Dimension &quot;has a&quot; Unit rather than a Dimension &quot;is a&quot; Unit.<br></p><p>Using a protocol for ConvertibleUnit also removes the requirement for methods in a base class that were either empty or that carried out a conversion at a coefficient of 1, which is essentially no conversion at all.<br></p><p>Therefore, if I may indulge, here is my attempt at a more protocol-orientd version. The code is not complete with regards to bridging but, looking at the bridging code in Github, that should not be a problem. <br></p><p>public protocol UnitConverter<br>{<br>  func baseUnitValue(fromValue value: Double) -&gt; Double<br>  <br>  func value(fromBaseUnitValue baseUnitValue: Double) -&gt; Double<br>}<br></p><p>// example converters<br>public struct UnitConverterLinear : UnitConverter<br>{<br>  private let coefficient: Double<br>  <br>  private let constant: Double<br>  <br>  public init(coefficient: Double, constant: Double)<br>  {<br>    self.coefficient = coefficient<br>    <br>    self.constant = constant<br>  }<br>  <br>  public init(coefficient: Double)<br>  {<br>    self.init(coefficient: coefficient, constant: 0)<br>  }<br>  <br>  public func baseUnitValue(fromValue value: Double) -&gt; Double<br>  {<br>    return value * coefficient + constant<br>  }<br>  <br>  public func value(fromBaseUnitValue baseUnitValue: Double) -&gt; Double<br>  {<br>    return (baseUnitValue - constant) / coefficient<br>  }<br>}<br></p><p><br>public struct UnitConverterReciprocal : UnitConverter<br>{<br>  private let reciprocal: Double<br>  <br>  public init(reciprocal: Double)<br>  {<br>    self.reciprocal = reciprocal<br>  }<br>  <br>  public func baseUnitValue(fromValue value: Double) -&gt; Double<br>  {<br>    return reciprocal / value<br>  }<br>  <br>  public func value(fromBaseUnitValue baseUnitValue: Double) -&gt; Double<br>  {<br>    return baseUnitValue * reciprocal<br>  }<br>}<br></p><p>// base protocols<br>public protocol Unit<br>{<br>  var symbol: String { get }<br>}<br></p><p><br>public protocol ConvertibleUnit : Unit<br>{<br>  var converter: UnitConverter { get }<br>  <br>  static var baseUnit : Self { get }<br>}<br></p><p>// generic Measurement<br>public struct Measurement&lt;UnitType : ConvertibleUnit&gt;<br>{<br>  var value: Double<br>  <br>  let unit: UnitType<br>  <br>  public init(value: Double, unit: UnitType)<br>  {<br>    self.value = value<br>    <br>    self.unit = unit<br>  }<br>  <br>  public func canBeConverted&lt;TargetUnit : ConvertibleUnit&gt;(to unit: TargetUnit) -&gt; Bool<br>  {<br>    return unit is UnitType<br>  }<br>  <br>  public func converting&lt;TargetUnit : ConvertibleUnit&gt;(to unit: TargetUnit) -&gt; Measurement&lt;TargetUnit&gt;<br>  {<br>    if !canBeConverted(to: unit)<br>    {<br>      fatalError(&quot;Unit type not compatible&quot;)<br>    }<br>    <br>    let baseUnitValue = self.unit.converter.baseUnitValue(fromValue: value)<br>    <br>    let convertedValue = unit.converter.value(fromBaseUnitValue: baseUnitValue)<br>    <br>    return Measurement&lt;TargetUnit&gt;(value: convertedValue, unit: unit)<br>  }<br>}<br></p><p>// example implementing ConvertibleUnit<br></p><p>public struct LengthUnit : ConvertibleUnit<br>{<br>  public let symbol: String<br>  <br>  public let converter: UnitConverter<br>  <br>  private struct Symbol<br>  {<br>    static let kilometers = &quot;km&quot;<br>    static let meters = &quot;m&quot;<br>    // ...<br>  }<br>  <br>  private struct Coefficient<br>  {<br>    static let kilometers   = 1000.0<br>    static let meters   = 1.0<br>    // ...<br>  }<br>  <br>  public static var kilometers: LengthUnit<br>  {<br>    return LengthUnit(symbol: Symbol.kilometers, converter: UnitConverterLinear(coefficient: Coefficient.kilometers))<br>  }<br>  <br>  public static var meters: LengthUnit<br>  {<br>    return LengthUnit(symbol: Symbol.meters, converter: UnitConverterLinear(coefficient: Coefficient.meters))<br>  }<br>  <br>  // ...<br></p><p>  public static var baseUnit : LengthUnit<br>  {<br>    return LengthUnit.meters<br>  }<br>}<br></p><p><br>--<br>Joanna Carter<br>Carter Consulting<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be4c3c3b76631a155e1358db48066692?s=50"></div><header><strong>Swiftier? implementation of Measurement and Unit in Foundation</strong> from <string>Tony Parker</string> &lt;anthony.parker at apple.com&gt;<p>August 14, 2016 at 12:00:00pm</p></header><div class="content"><p>Hi Joanna,<br></p><p>An important requirement of the design of measurements and units was that it had to work in Objective-C as well, where protocols do not have as many capabilities as they do in Swift. The bridging into Swift can only do so much, and frankly it didnâ€™t seem to be the case that traditional inheritance was really much of a problem for this API in the first place.<br></p><p>The approach of separating out the coefficient was one that the HealthKit unit API took, but we did not. Some units do lend themselves well to metric prefixes, but others do not (angles, for example).<br></p><p>We did make some changes upon import to Swift. Most importantly, Measurement is indeed a struct in Swift while a class in Objective-C.<br></p><p>- Tony<br></p><p>&gt; On Aug 11, 2016, at 2:49 AM, Joanna Carter via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Having had to implement convertible measurements and units for a project a couple of years ago, I thought I would take a look at the upcoming Measurements and Units implementations as found in the Github archive.<br>&gt; <br>&gt; Since we are continually being told that protocol-oriented code and the preferred use of structs were good things, I was surprised at the class inheritance I found.<br>&gt; <br>&gt; As a long-time proponent of OO design (some 29 years) I know that classes are not &quot;evil&quot; but was interested to see if Swift 2.2 could manage to implement Measurements and Units without falling into the inheritance trap where unnecessary implementation has to be included throughout a class hierarchy.<br>&gt; <br>&gt; I replaced the name Dimension with ConvertibleUnit as I felt a Dimension was not truly a Unit; in fact, a Dimension could be better described in terms of composition rather than inheritance i.e. a Dimension &quot;has a&quot; Unit rather than a Dimension &quot;is a&quot; Unit.<br>&gt; <br>&gt; Using a protocol for ConvertibleUnit also removes the requirement for methods in a base class that were either empty or that carried out a conversion at a coefficient of 1, which is essentially no conversion at all.<br>&gt; <br>&gt; Therefore, if I may indulge, here is my attempt at a more protocol-orientd version. The code is not complete with regards to bridging but, looking at the bridging code in Github, that should not be a problem. <br>&gt; <br>&gt; public protocol UnitConverter<br>&gt; {<br>&gt;  func baseUnitValue(fromValue value: Double) -&gt; Double<br>&gt; <br>&gt;  func value(fromBaseUnitValue baseUnitValue: Double) -&gt; Double<br>&gt; }<br>&gt; <br>&gt; // example converters<br>&gt; public struct UnitConverterLinear : UnitConverter<br>&gt; {<br>&gt;  private let coefficient: Double<br>&gt; <br>&gt;  private let constant: Double<br>&gt; <br>&gt;  public init(coefficient: Double, constant: Double)<br>&gt;  {<br>&gt;    self.coefficient = coefficient<br>&gt; <br>&gt;    self.constant = constant<br>&gt;  }<br>&gt; <br>&gt;  public init(coefficient: Double)<br>&gt;  {<br>&gt;    self.init(coefficient: coefficient, constant: 0)<br>&gt;  }<br>&gt; <br>&gt;  public func baseUnitValue(fromValue value: Double) -&gt; Double<br>&gt;  {<br>&gt;    return value * coefficient + constant<br>&gt;  }<br>&gt; <br>&gt;  public func value(fromBaseUnitValue baseUnitValue: Double) -&gt; Double<br>&gt;  {<br>&gt;    return (baseUnitValue - constant) / coefficient<br>&gt;  }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; public struct UnitConverterReciprocal : UnitConverter<br>&gt; {<br>&gt;  private let reciprocal: Double<br>&gt; <br>&gt;  public init(reciprocal: Double)<br>&gt;  {<br>&gt;    self.reciprocal = reciprocal<br>&gt;  }<br>&gt; <br>&gt;  public func baseUnitValue(fromValue value: Double) -&gt; Double<br>&gt;  {<br>&gt;    return reciprocal / value<br>&gt;  }<br>&gt; <br>&gt;  public func value(fromBaseUnitValue baseUnitValue: Double) -&gt; Double<br>&gt;  {<br>&gt;    return baseUnitValue * reciprocal<br>&gt;  }<br>&gt; }<br>&gt; <br>&gt; // base protocols<br>&gt; public protocol Unit<br>&gt; {<br>&gt;  var symbol: String { get }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; public protocol ConvertibleUnit : Unit<br>&gt; {<br>&gt;  var converter: UnitConverter { get }<br>&gt; <br>&gt;  static var baseUnit : Self { get }<br>&gt; }<br>&gt; <br>&gt; // generic Measurement<br>&gt; public struct Measurement&lt;UnitType : ConvertibleUnit&gt;<br>&gt; {<br>&gt;  var value: Double<br>&gt; <br>&gt;  let unit: UnitType<br>&gt; <br>&gt;  public init(value: Double, unit: UnitType)<br>&gt;  {<br>&gt;    self.value = value<br>&gt; <br>&gt;    self.unit = unit<br>&gt;  }<br>&gt; <br>&gt;  public func canBeConverted&lt;TargetUnit : ConvertibleUnit&gt;(to unit: TargetUnit) -&gt; Bool<br>&gt;  {<br>&gt;    return unit is UnitType<br>&gt;  }<br>&gt; <br>&gt;  public func converting&lt;TargetUnit : ConvertibleUnit&gt;(to unit: TargetUnit) -&gt; Measurement&lt;TargetUnit&gt;<br>&gt;  {<br>&gt;    if !canBeConverted(to: unit)<br>&gt;    {<br>&gt;      fatalError(&quot;Unit type not compatible&quot;)<br>&gt;    }<br>&gt; <br>&gt;    let baseUnitValue = self.unit.converter.baseUnitValue(fromValue: value)<br>&gt; <br>&gt;    let convertedValue = unit.converter.value(fromBaseUnitValue: baseUnitValue)<br>&gt; <br>&gt;    return Measurement&lt;TargetUnit&gt;(value: convertedValue, unit: unit)<br>&gt;  }<br>&gt; }<br>&gt; <br>&gt; // example implementing ConvertibleUnit<br>&gt; <br>&gt; public struct LengthUnit : ConvertibleUnit<br>&gt; {<br>&gt;  public let symbol: String<br>&gt; <br>&gt;  public let converter: UnitConverter<br>&gt; <br>&gt;  private struct Symbol<br>&gt;  {<br>&gt;    static let kilometers = &quot;km&quot;<br>&gt;    static let meters = &quot;m&quot;<br>&gt;    // ...<br>&gt;  }<br>&gt; <br>&gt;  private struct Coefficient<br>&gt;  {<br>&gt;    static let kilometers   = 1000.0<br>&gt;    static let meters   = 1.0<br>&gt;    // ...<br>&gt;  }<br>&gt; <br>&gt;  public static var kilometers: LengthUnit<br>&gt;  {<br>&gt;    return LengthUnit(symbol: Symbol.kilometers, converter: UnitConverterLinear(coefficient: Coefficient.kilometers))<br>&gt;  }<br>&gt; <br>&gt;  public static var meters: LengthUnit<br>&gt;  {<br>&gt;    return LengthUnit(symbol: Symbol.meters, converter: UnitConverterLinear(coefficient: Coefficient.meters))<br>&gt;  }<br>&gt; <br>&gt;  // ...<br>&gt; <br>&gt;  public static var baseUnit : LengthUnit<br>&gt;  {<br>&gt;    return LengthUnit.meters<br>&gt;  }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; --<br>&gt; Joanna Carter<br>&gt; Carter Consulting<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-corelibs-dev mailing list<br>&gt; swift-corelibs-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
