<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/86ade2d59a056c03066ec9eacb919148?s=50"></div><header><strong>[late pitch] UnsafeBytes proposal</strong> from <string>Jason Cardwell</string> &lt;cardwell.jason at gmail.com&gt;<p>August 23, 2016 at 10:00:00am</p></header><div class="content"><p>As an average developer that likes to look at this stuff on occasion, I thought I&#39;d toss in my take on &#39;byte&#39; terminology. I know little about machine architecture; but, it feels like the programming community in general has taken the term byte to mean 8 bits. Since it is actually the smallest unit of addressable memory, which is much more abstract, the APIs tend to go all wonky. In my head I think of it in a way not unlike the Int, IntMax, Int64 family. I haven&#39;t dealt with an architecture where IntMax = Int32 in so long that as I&#39;m coding my head translates them all to &#39;a 64 bit integer&#39;. However, the aliasing is enough to keep me honest from time to time as it forces me to consider whether I can count on a certain size for a particular situation. I don&#39;t know, something about the Byte and UInt8 situation feels the same to me. It seems like the standard library should be telling me upfront somewhere what the hell I can safely call a byte for the target architecture. The need for this proposal arose out of developers like me wanting to work with bytes. If some future architecture allowed addressing 4 bits instead of 8, that&#39;s what I&#39;d want to work with. It seems any confusion over interchangeable use of Byte and UInt8 stems from the varying levels of degree to which people see byte as an abstract term vs 8 bits. A simple declaration somewhere that officially tells us, &quot;Hey, when you see mention of byte it is safe to think in your head &#39;8 bits&#39;&#39;&#39; would make it all fall in line for me. Anywho, thanks so far for the wonderful language.<br></p><p>Jason Cardwell<br></p><p>&gt;&gt; On Aug 19, 2016, at 12:43 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Fri, Aug 19, 2016 at 2:32 PM, Karl via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 19 Aug 2016, at 19:35, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Aug 16, 2016, at 7:13 PM, Karl via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 16 Aug 2016, at 01:14, David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Aug 15, 2016, at 13:55, Michael Ilseman via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; It seems like there’s a potential for confusion here, in that people may see “UInt8” and assume there is some kind of typed-ness, even though the whole point is that this is untyped. Adjusting the header comments slightly might help:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; /// A non-owning view of raw memory as a collection of bytes.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ///<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; /// Reads and writes on memory via `UnsafeBytes` are untyped operations that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; /// do no require binding the memory to a type. These operations are expressed <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; /// in terms of `UInt8`, though the underlying memory is untyped.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; …<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; You could go even further towards hinting this fact with a `typealias Byte = UInt8`, and use Byte throughout. But, I don’t know if that’s getting too excessive.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t think that&#39;s too excessive at all. I might even go further and say that we should call it &quot;Untyped&quot; instead of &quot;Byte&quot;, to really drive home the point (many people see &quot;byte&quot; and think &quot;8-bit int&quot;, which is merely a side effect of CPUs generally not having support for types *other* than ints and floats, rather than a reflection of the true &quot;type&quot; of the data).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; - Dave Sweeris<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ‘Byte’ is sufficient, I think.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In some sense, it is typed as bytes. It reflects the fact that anything that is representable to the computer must be expressible as a sequence of bits (the same way we have string de/serialisation — which of course is not to say that the byte representation is good for serialisation purposes). “withUnsafeBytes” can be seen as doing a reversible type conversion the same way LosslessStringConvertible does; only in this case the conversion is free.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes. Byte clearly refers to a value&#39;s in-memory representation. But typealias Byte = UInt8 would imply the opposite of what needs to be conveyed. The name Byte refers to raw memory being accessed, not the value being returned by the collection. The in-memory value&#39;s bytes are loaded from memory and reinterpreted as UInt8 values. UInt8 is the correct type for the value after it is loaded. Calling the collection’s element type Byte sends the wrong message. e.g. [Byte] or UnsafePointer&lt;Byte&gt; would be nonsense.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Keep in mind the important use case is code that needs to work with a collection of UInt8 values without knowing the type of the values in memory. This makes it intuitive and convenient to implement correctly without needing to reason about the Swift-specific notions of raw vs. typed pointers and binding memory to a type.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The documentation should be fixed to clarify that the in-memory value is not the same as the loaded value.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Andy<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Well, a byte is a numerical type as much as a UInt8 is. We attach meaning to it (e.g. a memory location), but it’s just a number.<br>&gt;&gt; <br>&gt;&gt; But I thought what Andy&#39;s saying is that he&#39;s proposing to standardize the usage of the word byte to mean raw memory and not a number?<br>&gt;&gt;  <br>&gt;&gt;&gt; Perhaps it shouldn’t be a typealias then (if the alias would have some kind of impure semantics), but its own type which is exactly the same as UInt8. Typing raw memory accesses with `Byte` to indicate that the number was read from raw memory is a good idea for type-safety IMO.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You’d wonder if we could have initialisers for other integer types which take a fixed-size array of `Byte`s - e.g. UInt16(_: [2 * Byte]). That wouldn’t make as much sense with two UInt8s.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Karl<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160823/8e7182c6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c40db4457ab2c91a0d8006da31b177c6?s=50"></div><header><strong>[late pitch] UnsafeBytes proposal</strong> from <string>Trent Nadeau</string> &lt;tanadeau at gmail.com&gt;<p>August 23, 2016 at 08:00:00pm</p></header><div class="content"><p>For an architecture to be C-compatible, its byte size must be 8 bits. Given<br>the need to run C everywhere and that almost all OSes are written in C,<br>it&#39;s a very safe assumption that a byte equals 8 bits. At this point, I<br>think the only thing where that&#39;s not true are certain micro-controllers<br>for which there are specialized compilers.<br></p><p>In any case, LLVM (the compiler infrastructure on which the Swift compiler<br>is built) doesn&#39;t support architectures where that&#39;s not true.<br></p><p>On Tue, Aug 23, 2016 at 1:12 PM, Jason Cardwell via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; As an average developer that likes to look at this stuff on occasion, I<br>&gt; thought I&#39;d toss in my take on &#39;byte&#39; terminology. I know little about<br>&gt; machine architecture; but, it feels like the programming community in<br>&gt; general has taken the term byte to mean 8 bits. Since it is actually the<br>&gt; smallest unit of addressable memory, which is much more abstract, the APIs<br>&gt; tend to go all wonky. In my head I think of it in a way not unlike the Int,<br>&gt; IntMax, Int64 family. I haven&#39;t dealt with an architecture where IntMax =<br>&gt; Int32 in so long that as I&#39;m coding my head translates them all to &#39;a 64<br>&gt; bit integer&#39;. However, the aliasing is enough to keep me honest from time<br>&gt; to time as it forces me to consider whether I can count on a certain size<br>&gt; for a particular situation. I don&#39;t know, something about the Byte and<br>&gt; UInt8 situation feels the same to me. It seems like the standard library<br>&gt; should be telling me upfront somewhere what the hell I can safely call a<br>&gt; byte for the target architecture. The need for this proposal arose out of<br>&gt; developers like me wanting to work with bytes. If some future architecture<br>&gt; allowed addressing 4 bits instead of 8, that&#39;s what I&#39;d want to work with.<br>&gt; It seems any confusion over interchangeable use of Byte and UInt8 stems<br>&gt; from the varying levels of degree to which people see byte as an abstract<br>&gt; term vs 8 bits. A simple declaration somewhere that officially tells us,<br>&gt; &quot;Hey, when you see mention of byte it is safe to think in your head &#39;8<br>&gt; bits&#39;&#39;&#39; would make it all fall in line for me. Anywho, thanks so far for<br>&gt; the wonderful language.<br>&gt;<br>&gt; Jason Cardwell<br>&gt;<br>&gt; On Aug 19, 2016, at 12:43 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Fri, Aug 19, 2016 at 2:32 PM, Karl via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On 19 Aug 2016, at 19:35, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Aug 16, 2016, at 7:13 PM, Karl via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On 16 Aug 2016, at 01:14, David Sweeris via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Aug 15, 2016, at 13:55, Michael Ilseman via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; It seems like there’s a potential for confusion here, in that people may<br>&gt;&gt; see “UInt8” and assume there is some kind of typed-ness, even though the<br>&gt;&gt; whole point is that this is untyped. Adjusting the header comments slightly<br>&gt;&gt; might help:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; /// A non-owning view of raw memory as a collection of bytes.<br>&gt;&gt; ///<br>&gt;&gt; /// Reads and writes on memory via `UnsafeBytes` are untyped operations<br>&gt;&gt; that<br>&gt;&gt; /// do no require binding the memory to a type. These operations are<br>&gt;&gt; expressed<br>&gt;&gt; /// in terms of `UInt8`, though the underlying memory is untyped.<br>&gt;&gt;<br>&gt;&gt; …<br>&gt;&gt;<br>&gt;&gt; You could go even further towards hinting this fact with a `typealias<br>&gt;&gt; Byte = UInt8`, and use Byte throughout. But, I don’t know if that’s getting<br>&gt;&gt; too excessive.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I don&#39;t think that&#39;s too excessive at all. I might even go further and<br>&gt;&gt; say that we should call it &quot;Untyped&quot; instead of &quot;Byte&quot;, to really drive<br>&gt;&gt; home the point (many people see &quot;byte&quot; and think &quot;8-bit int&quot;, which is<br>&gt;&gt; merely a side effect of CPUs generally not having support for types *other*<br>&gt;&gt; than ints and floats, rather than a reflection of the true &quot;type&quot; of the<br>&gt;&gt; data).<br>&gt;&gt;<br>&gt;&gt; - Dave Sweeris<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; ‘Byte’ is sufficient, I think.<br>&gt;&gt;<br>&gt;&gt; In some sense, it is typed as bytes. It reflects the fact that anything<br>&gt;&gt; that is representable to the computer must be expressible as a sequence of<br>&gt;&gt; bits (the same way we have string de/serialisation — which of course is not<br>&gt;&gt; to say that the byte representation is good for serialisation purposes).<br>&gt;&gt; “withUnsafeBytes” can be seen as doing a reversible type conversion the<br>&gt;&gt; same way LosslessStringConvertible does; only in this case the conversion<br>&gt;&gt; is free.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Yes. Byte clearly refers to a value&#39;s in-memory representation. But<br>&gt;&gt; typealias Byte = UInt8 would imply the opposite of what needs to be<br>&gt;&gt; conveyed. The name Byte refers to raw memory being accessed, not the value<br>&gt;&gt; being returned by the collection. The in-memory value&#39;s bytes are loaded<br>&gt;&gt; from memory and reinterpreted as UInt8 values. UInt8 is the correct type<br>&gt;&gt; for the value after it is loaded. Calling the collection’s element type<br>&gt;&gt; Byte sends the wrong message. e.g. [Byte] or UnsafePointer&lt;Byte&gt; would be<br>&gt;&gt; nonsense.<br>&gt;&gt;<br>&gt;&gt; Keep in mind the important use case is code that needs to work with a<br>&gt;&gt; collection of UInt8 values without knowing the type of the values in<br>&gt;&gt; memory. This makes it intuitive and convenient to implement correctly<br>&gt;&gt; without needing to reason about the Swift-specific notions of raw vs. typed<br>&gt;&gt; pointers and binding memory to a type.<br>&gt;&gt;<br>&gt;&gt; The documentation should be fixed to clarify that the in-memory value is<br>&gt;&gt; not the same as the loaded value.<br>&gt;&gt;<br>&gt;&gt; -Andy<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Well, a byte is a numerical type as much as a UInt8 is. We attach meaning<br>&gt;&gt; to it (e.g. a memory location), but it’s just a number.<br>&gt;&gt;<br>&gt;<br>&gt; But I thought what Andy&#39;s saying is that he&#39;s proposing to standardize the<br>&gt; usage of the word byte to mean raw memory and not a number?<br>&gt;<br>&gt;<br>&gt;&gt; Perhaps it shouldn’t be a typealias then (if the alias would have some<br>&gt;&gt; kind of impure semantics), but its own type which is exactly the same as<br>&gt;&gt; UInt8. Typing raw memory accesses with `Byte` to indicate that the number<br>&gt;&gt; was read from raw memory is a good idea for type-safety IMO.<br>&gt;&gt;<br>&gt;&gt; You’d wonder if we could have initialisers for other integer types which<br>&gt;&gt; take a fixed-size array of `Byte`s - e.g. UInt16(_: [2 * Byte]). That<br>&gt;&gt; wouldn’t make as much sense with two UInt8s.<br>&gt;&gt;<br>&gt;&gt; Karl<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p><p><br>-- <br>Trent Nadeau<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160823/7cf8adb9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[late pitch] UnsafeBytes proposal</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>August 23, 2016 at 08:00:00pm</p></header><div class="content"><p>I&#39;m told that POSIX requires that bytes are 8 bits, but modern C only says that it has to be at least 8. If your platform can only address one size, then `char` will take that size. Larger-than-8 bit sizes are apparently mostly found on DSPs.<br></p><p>LLVM can be (and has been &lt;http://lists.llvm.org/pipermail/llvm-dev/2014-September/076572.html&gt;) extended to support bytes that are not 8 bits.<br></p><p>That said, it&#39;s the kind of thing that comes into being with corporate support, and the main corporate sponsor behind Swift is mostly interested in x86 and ARM. It might be a while before this assumption has to be seriously revisited, and it would be quite breaking. <br></p><p>Félix<br></p><p>&gt; Le 23 août 2016 à 17:28:53, Trent Nadeau via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; For an architecture to be C-compatible, its byte size must be 8 bits. Given the need to run C everywhere and that almost all OSes are written in C, it&#39;s a very safe assumption that a byte equals 8 bits. At this point, I think the only thing where that&#39;s not true are certain micro-controllers for which there are specialized compilers.<br>&gt; <br>&gt; In any case, LLVM (the compiler infrastructure on which the Swift compiler is built) doesn&#39;t support architectures where that&#39;s not true.<br>&gt; <br>&gt; On Tue, Aug 23, 2016 at 1:12 PM, Jason Cardwell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; As an average developer that likes to look at this stuff on occasion, I thought I&#39;d toss in my take on &#39;byte&#39; terminology. I know little about machine architecture; but, it feels like the programming community in general has taken the term byte to mean 8 bits. Since it is actually the smallest unit of addressable memory, which is much more abstract, the APIs tend to go all wonky. In my head I think of it in a way not unlike the Int, IntMax, Int64 family. I haven&#39;t dealt with an architecture where IntMax = Int32 in so long that as I&#39;m coding my head translates them all to &#39;a 64 bit integer&#39;. However, the aliasing is enough to keep me honest from time to time as it forces me to consider whether I can count on a certain size for a particular situation. I don&#39;t know, something about the Byte and UInt8 situation feels the same to me. It seems like the standard library should be telling me upfront somewhere what the hell I can safely call a byte for the target architecture. The need for this proposal arose out of developers like me wanting to work with bytes. If some future architecture allowed addressing 4 bits instead of 8, that&#39;s what I&#39;d want to work with. It seems any confusion over interchangeable use of Byte and UInt8 stems from the varying levels of degree to which people see byte as an abstract term vs 8 bits. A simple declaration somewhere that officially tells us, &quot;Hey, when you see mention of byte it is safe to think in your head &#39;8 bits&#39;&#39;&#39; would make it all fall in line for me. Anywho, thanks so far for the wonderful language.<br>&gt; <br>&gt; Jason Cardwell<br>&gt; <br>&gt;&gt; On Aug 19, 2016, at 12:43 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Fri, Aug 19, 2016 at 2:32 PM, Karl via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 19 Aug 2016, at 19:35, Andrew Trick &lt;atrick at apple.com &lt;mailto:atrick at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Aug 16, 2016, at 7:13 PM, Karl via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 16 Aug 2016, at 01:14, David Sweeris via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Aug 15, 2016, at 13:55, Michael Ilseman via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; It seems like there’s a potential for confusion here, in that people may see “UInt8” and assume there is some kind of typed-ness, even though the whole point is that this is untyped. Adjusting the header comments slightly might help:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; /// A non-owning view of raw memory as a collection of bytes.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ///<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; /// Reads and writes on memory via `UnsafeBytes` are untyped operations that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; /// do no require binding the memory to a type. These operations are expressed <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; /// in terms of `UInt8`, though the underlying memory is untyped.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; …<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; You could go even further towards hinting this fact with a `typealias Byte = UInt8`, and use Byte throughout. But, I don’t know if that’s getting too excessive.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t think that&#39;s too excessive at all. I might even go further and say that we should call it &quot;Untyped&quot; instead of &quot;Byte&quot;, to really drive home the point (many people see &quot;byte&quot; and think &quot;8-bit int&quot;, which is merely a side effect of CPUs generally not having support for types *other* than ints and floats, rather than a reflection of the true &quot;type&quot; of the data).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; - Dave Sweeris<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; ‘Byte’ is sufficient, I think.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In some sense, it is typed as bytes. It reflects the fact that anything that is representable to the computer must be expressible as a sequence of bits (the same way we have string de/serialisation — which of course is not to say that the byte representation is good for serialisation purposes). “withUnsafeBytes” can be seen as doing a reversible type conversion the same way LosslessStringConvertible does; only in this case the conversion is free.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes. Byte clearly refers to a value&#39;s in-memory representation. But typealias Byte = UInt8 would imply the opposite of what needs to be conveyed. The name Byte refers to raw memory being accessed, not the value being returned by the collection. The in-memory value&#39;s bytes are loaded from memory and reinterpreted as UInt8 values. UInt8 is the correct type for the value after it is loaded. Calling the collection’s element type Byte sends the wrong message. e.g. [Byte] or UnsafePointer&lt;Byte&gt; would be nonsense.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Keep in mind the important use case is code that needs to work with a collection of UInt8 values without knowing the type of the values in memory. This makes it intuitive and convenient to implement correctly without needing to reason about the Swift-specific notions of raw vs. typed pointers and binding memory to a type.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The documentation should be fixed to clarify that the in-memory value is not the same as the loaded value.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Andy<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Well, a byte is a numerical type as much as a UInt8 is. We attach meaning to it (e.g. a memory location), but it’s just a number.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But I thought what Andy&#39;s saying is that he&#39;s proposing to standardize the usage of the word byte to mean raw memory and not a number?<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Perhaps it shouldn’t be a typealias then (if the alias would have some kind of impure semantics), but its own type which is exactly the same as UInt8. Typing raw memory accesses with `Byte` to indicate that the number was read from raw memory is a good idea for type-safety IMO.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You’d wonder if we could have initialisers for other integer types which take a fixed-size array of `Byte`s - e.g. UInt16(_: [2 * Byte]). That wouldn’t make as much sense with two UInt8s.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Karl<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Trent Nadeau<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160823/fd30d853/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[late pitch] UnsafeBytes proposal</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>August 23, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Aug 23, 2016, at 5:28 PM, Trent Nadeau via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; For an architecture to be C-compatible, its byte size must be 8 bits. Given the need to run C everywhere and that almost all OSes are written in C, it&#39;s a very safe assumption that a byte equals 8 bits. At this point, I think the only thing where that&#39;s not true are certain micro-controllers for which there are specialized compilers.<br></p><p>Right, Swift depends on Clang.  Clang assumes that the target machine has 8-bit-byte-addressable memory.  I don’t see any reason that Swift should pretend to work on the (only historically interesting) systems that had 9-bit (or any other weird number) addressable units.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[late pitch] UnsafeBytes proposal</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>August 24, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Aug 23, 2016, at 9:56 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Aug 23, 2016, at 5:28 PM, Trent Nadeau via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; For an architecture to be C-compatible, its byte size must be 8 bits. Given the need to run C everywhere and that almost all OSes are written in C, it&#39;s a very safe assumption that a byte equals 8 bits. At this point, I think the only thing where that&#39;s not true are certain micro-controllers for which there are specialized compilers.<br>&gt; <br>&gt; Right, Swift depends on Clang.  Clang assumes that the target machine has 8-bit-byte-addressable memory.  I don’t see any reason that Swift should pretend to work on the (only historically interesting) systems that had 9-bit (or any other weird number) addressable units.<br></p><p>To be fair to Jason, I think he just wants the language to be explicit about a byte being an 8-bit numeric value.<br></p><p>That’s not quite what I’m trying to convey though. I want bytes to refer only to the in-memory layout of values of any type in 8-bit chunks per the ABI. Typically, loading a byte without imposing any type on the in-memory value should produce a UInt8 value. Swift should not have a Byte type because it would contradict this meaning and serve no purpose.<br></p><p>I’ve been working with developers who need to parse or stream binary data. It’s a common use case. What I’m proposing perfectly matches the intuition of these developers who are already using the same concepts and terminology that I am.<br></p><p>-Andy<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/86ade2d59a056c03066ec9eacb919148?s=50"></div><header><strong>[late pitch] UnsafeBytes proposal</strong> from <string>Jason Cardwell</string> &lt;cardwell.jason at gmail.com&gt;<p>August 24, 2016 at 01:00:00pm</p></header><div class="content"><p>To be a little more clear, all I meant to point out was the difference between what originated as an abstract term and what is decidedly a concrete term. Everybody seems to have merged the two as a result of how the architecture evolved over time. My first degree was in English and that side of me is wondering if the entry for byte in the Oxford English Dictionary would show it as historical or current. If the two words are entirely equal than just drop one and use the other everywhere. If using the there one everywhere seems off in some places then ask why they aren&#39;t interchangeable. When the byte typealias was first dropped I added my own to use in a custom framework. Later I removed it because it bugged me using two different types to mean the same thing. I don&#39;t care one way or the other so long as there is consistency.<br></p><p>&gt; On Aug 23, 2016, at 5:28 PM, Trent Nadeau &lt;tanadeau at gmail.com&gt; wrote:<br>&gt; <br>&gt; For an architecture to be C-compatible, its byte size must be 8 bits. Given the need to run C everywhere and that almost all OSes are written in C, it&#39;s a very safe assumption that a byte equals 8 bits. At this point, I think the only thing where that&#39;s not true are certain micro-controllers for which there are specialized compilers.<br>&gt; <br>&gt; In any case, LLVM (the compiler infrastructure on which the Swift compiler is built) doesn&#39;t support architectures where that&#39;s not true.<br>&gt; <br>&gt;&gt; On Tue, Aug 23, 2016 at 1:12 PM, Jason Cardwell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; As an average developer that likes to look at this stuff on occasion, I thought I&#39;d toss in my take on &#39;byte&#39; terminology. I know little about machine architecture; but, it feels like the programming community in general has taken the term byte to mean 8 bits. Since it is actually the smallest unit of addressable memory, which is much more abstract, the APIs tend to go all wonky. In my head I think of it in a way not unlike the Int, IntMax, Int64 family. I haven&#39;t dealt with an architecture where IntMax = Int32 in so long that as I&#39;m coding my head translates them all to &#39;a 64 bit integer&#39;. However, the aliasing is enough to keep me honest from time to time as it forces me to consider whether I can count on a certain size for a particular situation. I don&#39;t know, something about the Byte and UInt8 situation feels the same to me. It seems like the standard library should be telling me upfront somewhere what the hell I can safely call a byte for the target architecture. The need for this proposal arose out of developers like me wanting to work with bytes. If some future architecture allowed addressing 4 bits instead of 8, that&#39;s what I&#39;d want to work with. It seems any confusion over interchangeable use of Byte and UInt8 stems from the varying levels of degree to which people see byte as an abstract term vs 8 bits. A simple declaration somewhere that officially tells us, &quot;Hey, when you see mention of byte it is safe to think in your head &#39;8 bits&#39;&#39;&#39; would make it all fall in line for me. Anywho, thanks so far for the wonderful language.<br>&gt;&gt; <br>&gt;&gt; Jason Cardwell<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Aug 19, 2016, at 12:43 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Fri, Aug 19, 2016 at 2:32 PM, Karl via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 19 Aug 2016, at 19:35, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Aug 16, 2016, at 7:13 PM, Karl via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 16 Aug 2016, at 01:14, David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Aug 15, 2016, at 13:55, Michael Ilseman via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It seems like there’s a potential for confusion here, in that people may see “UInt8” and assume there is some kind of typed-ness, even though the whole point is that this is untyped. Adjusting the header comments slightly might help:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; /// A non-owning view of raw memory as a collection of bytes.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ///<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; /// Reads and writes on memory via `UnsafeBytes` are untyped operations that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; /// do no require binding the memory to a type. These operations are expressed <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; /// in terms of `UInt8`, though the underlying memory is untyped.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; …<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; You could go even further towards hinting this fact with a `typealias Byte = UInt8`, and use Byte throughout. But, I don’t know if that’s getting too excessive.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t think that&#39;s too excessive at all. I might even go further and say that we should call it &quot;Untyped&quot; instead of &quot;Byte&quot;, to really drive home the point (many people see &quot;byte&quot; and think &quot;8-bit int&quot;, which is merely a side effect of CPUs generally not having support for types *other* than ints and floats, rather than a reflection of the true &quot;type&quot; of the data).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Dave Sweeris<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ‘Byte’ is sufficient, I think.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; In some sense, it is typed as bytes. It reflects the fact that anything that is representable to the computer must be expressible as a sequence of bits (the same way we have string de/serialisation — which of course is not to say that the byte representation is good for serialisation purposes). “withUnsafeBytes” can be seen as doing a reversible type conversion the same way LosslessStringConvertible does; only in this case the conversion is free.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Yes. Byte clearly refers to a value&#39;s in-memory representation. But typealias Byte = UInt8 would imply the opposite of what needs to be conveyed. The name Byte refers to raw memory being accessed, not the value being returned by the collection. The in-memory value&#39;s bytes are loaded from memory and reinterpreted as UInt8 values. UInt8 is the correct type for the value after it is loaded. Calling the collection’s element type Byte sends the wrong message. e.g. [Byte] or UnsafePointer&lt;Byte&gt; would be nonsense.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Keep in mind the important use case is code that needs to work with a collection of UInt8 values without knowing the type of the values in memory. This makes it intuitive and convenient to implement correctly without needing to reason about the Swift-specific notions of raw vs. typed pointers and binding memory to a type.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The documentation should be fixed to clarify that the in-memory value is not the same as the loaded value.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -Andy<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Well, a byte is a numerical type as much as a UInt8 is. We attach meaning to it (e.g. a memory location), but it’s just a number.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; But I thought what Andy&#39;s saying is that he&#39;s proposing to standardize the usage of the word byte to mean raw memory and not a number?<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; Perhaps it shouldn’t be a typealias then (if the alias would have some kind of impure semantics), but its own type which is exactly the same as UInt8. Typing raw memory accesses with `Byte` to indicate that the number was read from raw memory is a good idea for type-safety IMO.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; You’d wonder if we could have initialisers for other integer types which take a fixed-size array of `Byte`s - e.g. UInt16(_: [2 * Byte]). That wouldn’t make as much sense with two UInt8s.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Karl<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Trent Nadeau<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160824/1dc850cf/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
