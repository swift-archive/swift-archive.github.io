<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>Type-safe selectors</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>December  4, 2015 at 05:00:00pm</p></header><div class="content"><p>Currently in Swift you can get a closure by referring to a method:<br></p><p>	let x = NSString.hasPrefix<br>	// x is of type NSString -&gt; String -&gt; Bool<br></p><p>Something that would be useful here is if the closure created from Objective-C methods were special in that they could implicitly be converted to a Selector. Instead of writing manually a selector as a string, you&#39;d just have to refer to the method, and you know there&#39;s no typo (or else you get a compile-time error). For instance, adding an observer to a NSNotificationCenter would work like this:<br></p><p>	notificationCenter.addObserver(self, selector: MyClass.observeNotification, name: NSSomeNotificationName, object: nil) <br></p><p>This, making sure the correct selector is used for the designated method, seem like it should be somewhat more important in Swift 3 if it includes Evolution Proposal 0005 that suggests many Objective-C methods will be given Swift-specific names.<br>https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md<br></p><p>But why stop there when you can go one step further and actually improve type-safety? Instead of taking a Selector parameter, the NSNotificationCenter.addObserver method above could request a @convention(selector) closure of this form:<br></p><p>	@convention(selector) AnyObject -&gt; NSNotification -&gt; Void<br></p><p>Under the hood that closure is still a plain selector pointer, but the compiler attaches proper type information to the arguments. Since `addObserver` now declares it wants a selector with the given signature, the compiler can enforce that the arguments and return type for the passed selector are compatible. You <br></p><p>Moreover, the @convention(selector) closure you get can then be used as a normal closure inside a Swift method that can be called from Objective-C:<br></p><p>	@objc func callSelector(selector: @convention(selector) NSString -&gt; String -&gt; Bool) -&gt; Bool {<br>		let str = NSString(string: &quot;hello&quot;)<br>		return selector(str)(&quot;hell&quot;)<br>	}<br></p><p>	let x = NSString.hasPrefix<br>	// x is of type @convention(selector) NSString -&gt; String -&gt; Bool<br>	callSelector(x)<br></p><p>So that would make selectors less error-prone because the compiler can type-check them, and you can use selectors in Swift code in a very natural manner.<br></p><p> - - -<br></p><p>This is inspired from the D/Objective-C compiler I prototyped a while ago. There, I made selectors typed with their arguments because:<br></p><p>1. I wanted to preserve D&#39;s type-safety while still being able to use selectors, and<br>2. I needed to decouple selector names from method names in the code; this would later allow me to implement overloading by adding some name mangling in selectors. Obtaining selectors by referring to the method allowed selectors to become an implementation detail while providing a nice way to associate the parameter types.<br></p><p>For reference, here is the meager documentation for that feature:<br>https://michelf.ca/projects/d-objc/syntax/#selector-literals<br>And for the selector-name mangling:<br>https://michelf.ca/projects/d-objc/syntax/#generated-selectors<br></p><p><br>-- <br>Michel Fortin<br>michel.fortin at michelf.ca<br>https://michelf.ca<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Type-safe selectors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December  4, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; On Dec 4, 2015, at 2:22 PM, Michel Fortin &lt;michel.fortin at michelf.ca&gt; wrote:<br>&gt; <br>&gt; Currently in Swift you can get a closure by referring to a method:<br>&gt; <br>&gt; 	let x = NSString.hasPrefix<br>&gt; 	// x is of type NSString -&gt; String -&gt; Bool<br>&gt; <br>&gt; Something that would be useful here is if the closure created from Objective-C methods were special in that they could implicitly be converted to a Selector. Instead of writing manually a selector as a string, you&#39;d just have to refer to the method, and you know there&#39;s no typo (or else you get a compile-time error). For instance, adding an observer to a NSNotificationCenter would work like this:<br>&gt; <br>&gt; 	notificationCenter.addObserver(self, selector: MyClass.observeNotification, name: NSSomeNotificationName, object: nil) <br>&gt; <br>&gt; This, making sure the correct selector is used for the designated method, seem like it should be somewhat more important in Swift 3 if it includes Evolution Proposal 0005 that suggests many Objective-C methods will be given Swift-specific names.<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md<br>&gt; <br>&gt; But why stop there when you can go one step further and actually improve type-safety? Instead of taking a Selector parameter, the NSNotificationCenter.addObserver method above could request a @convention(selector) closure of this form:<br>&gt; <br>&gt; 	@convention(selector) AnyObject -&gt; NSNotification -&gt; Void<br>&gt; <br>&gt; Under the hood that closure is still a plain selector pointer, but the compiler attaches proper type information to the arguments. Since `addObserver` now declares it wants a selector with the given signature, the compiler can enforce that the arguments and return type for the passed selector are compatible. You <br></p><p>This is a great approach, and it&#39;s mostly exactly what I&#39;ve had in mind for this. Another nice thing about @convention(selector) is that the compiler could also context-free closures, like with @convention(c), by compiling them down to categories with mangled methods.<br></p><p>&gt; <br>&gt; Moreover, the @convention(selector) closure you get can then be used as a normal closure inside a Swift method that can be called from Objective-C:<br>&gt; <br>&gt; 	@objc func callSelector(selector: @convention(selector) NSString -&gt; String -&gt; Bool) -&gt; Bool {<br>&gt; 		let str = NSString(string: &quot;hello&quot;)<br>&gt; 		return selector(str)(&quot;hell&quot;)<br>&gt; 	}<br>&gt; <br>&gt; 	let x = NSString.hasPrefix<br>&gt; 	// x is of type @convention(selector) NSString -&gt; String -&gt; Bool<br>&gt; 	callSelector(x)<br>&gt; <br>&gt; So that would make selectors less error-prone because the compiler can type-check them, and you can use selectors in Swift code in a very natural manner.<br></p><p>I would say that &#39;let x = NSString.hasPrefix&#39; should still give you a @convention(swift) function value by default; that&#39;s what we do with method references in general, but you could ask for a @convention(selector) reference explicitly:<br></p><p>let x: @convention(selector) X -&gt; Y -&gt; Z = X.hasPrefix<br></p><p>-Joe<br></p><p>&gt; - - -<br>&gt; <br>&gt; This is inspired from the D/Objective-C compiler I prototyped a while ago. There, I made selectors typed with their arguments because:<br>&gt; <br>&gt; 1. I wanted to preserve D&#39;s type-safety while still being able to use selectors, and<br>&gt; 2. I needed to decouple selector names from method names in the code; this would later allow me to implement overloading by adding some name mangling in selectors. Obtaining selectors by referring to the method allowed selectors to become an implementation detail while providing a nice way to associate the parameter types.<br>&gt; <br>&gt; For reference, here is the meager documentation for that feature:<br>&gt; https://michelf.ca/projects/d-objc/syntax/#selector-literals<br>&gt; And for the selector-name mangling:<br>&gt; https://michelf.ca/projects/d-objc/syntax/#generated-selectors<br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Michel Fortin<br>&gt; michel.fortin at michelf.ca<br>&gt; https://michelf.ca<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Type-safe selectors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December  4, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; On Dec 4, 2015, at 2:26 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 4, 2015, at 2:22 PM, Michel Fortin &lt;michel.fortin at michelf.ca&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Currently in Swift you can get a closure by referring to a method:<br>&gt;&gt; <br>&gt;&gt; 	let x = NSString.hasPrefix<br>&gt;&gt; 	// x is of type NSString -&gt; String -&gt; Bool<br>&gt;&gt; <br>&gt;&gt; Something that would be useful here is if the closure created from Objective-C methods were special in that they could implicitly be converted to a Selector. Instead of writing manually a selector as a string, you&#39;d just have to refer to the method, and you know there&#39;s no typo (or else you get a compile-time error). For instance, adding an observer to a NSNotificationCenter would work like this:<br>&gt;&gt; <br>&gt;&gt; 	notificationCenter.addObserver(self, selector: MyClass.observeNotification, name: NSSomeNotificationName, object: nil) <br>&gt;&gt; <br>&gt;&gt; This, making sure the correct selector is used for the designated method, seem like it should be somewhat more important in Swift 3 if it includes Evolution Proposal 0005 that suggests many Objective-C methods will be given Swift-specific names.<br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md<br>&gt;&gt; <br>&gt;&gt; But why stop there when you can go one step further and actually improve type-safety? Instead of taking a Selector parameter, the NSNotificationCenter.addObserver method above could request a @convention(selector) closure of this form:<br>&gt;&gt; <br>&gt;&gt; 	@convention(selector) AnyObject -&gt; NSNotification -&gt; Void<br>&gt;&gt; <br>&gt;&gt; Under the hood that closure is still a plain selector pointer, but the compiler attaches proper type information to the arguments. Since `addObserver` now declares it wants a selector with the given signature, the compiler can enforce that the arguments and return type for the passed selector are compatible. You <br>&gt; <br>&gt; This is a great approach, and it&#39;s mostly exactly what I&#39;ve had in mind for this. Another nice thing about @convention(selector) is that the compiler could also context-free closures, like with @convention(c), by compiling them down to categories with mangled methods.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Moreover, the @convention(selector) closure you get can then be used as a normal closure inside a Swift method that can be called from Objective-C:<br>&gt;&gt; <br>&gt;&gt; 	@objc func callSelector(selector: @convention(selector) NSString -&gt; String -&gt; Bool) -&gt; Bool {<br>&gt;&gt; 		let str = NSString(string: &quot;hello&quot;)<br>&gt;&gt; 		return selector(str)(&quot;hell&quot;)<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; 	let x = NSString.hasPrefix<br>&gt;&gt; 	// x is of type @convention(selector) NSString -&gt; String -&gt; Bool<br>&gt;&gt; 	callSelector(x)<br>&gt;&gt; <br>&gt;&gt; So that would make selectors less error-prone because the compiler can type-check them, and you can use selectors in Swift code in a very natural manner.<br>&gt; <br>&gt; I would say that &#39;let x = NSString.hasPrefix&#39; should still give you a @convention(swift) function value by default; that&#39;s what we do with method references in general, but you could ask for a @convention(selector) reference explicitly:<br>&gt; <br>&gt; let x: @convention(selector) X -&gt; Y -&gt; Z = X.hasPrefix<br></p><p>One wrinkle you need to consider is the different ARC behavior of method families. @convention(selector) would have to be restricted to referencing methods that don&#39;t belong to an usual method family or have unusual ownership rules, or else we&#39;d need multiple @convention(init_selector), (copy_selector), (alloc_selector) etc. conventions.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/82063808/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Type-safe selectors</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>December  4, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; On Dec 4, 2015, at 2:31 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; On Dec 4, 2015, at 2:26 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 4, 2015, at 2:22 PM, Michel Fortin &lt;michel.fortin at michelf.ca &lt;mailto:michel.fortin at michelf.ca&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Currently in Swift you can get a closure by referring to a method:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	let x = NSString.hasPrefix<br>&gt;&gt;&gt; 	// x is of type NSString -&gt; String -&gt; Bool<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Something that would be useful here is if the closure created from Objective-C methods were special in that they could implicitly be converted to a Selector. Instead of writing manually a selector as a string, you&#39;d just have to refer to the method, and you know there&#39;s no typo (or else you get a compile-time error). For instance, adding an observer to a NSNotificationCenter would work like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	notificationCenter.addObserver(self, selector: MyClass.observeNotification, name: NSSomeNotificationName, object: nil) <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This, making sure the correct selector is used for the designated method, seem like it should be somewhat more important in Swift 3 if it includes Evolution Proposal 0005 that suggests many Objective-C methods will be given Swift-specific names.<br>&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But why stop there when you can go one step further and actually improve type-safety? Instead of taking a Selector parameter, the NSNotificationCenter.addObserver method above could request a @convention(selector) closure of this form:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	@convention(selector) AnyObject -&gt; NSNotification -&gt; Void<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Under the hood that closure is still a plain selector pointer, but the compiler attaches proper type information to the arguments. Since `addObserver` now declares it wants a selector with the given signature, the compiler can enforce that the arguments and return type for the passed selector are compatible. You <br>&gt;&gt; <br>&gt;&gt; This is a great approach, and it&#39;s mostly exactly what I&#39;ve had in mind for this. Another nice thing about @convention(selector) is that the compiler could also context-free closures, like with @convention(c), by compiling them down to categories with mangled methods.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Moreover, the @convention(selector) closure you get can then be used as a normal closure inside a Swift method that can be called from Objective-C:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	@objc func callSelector(selector: @convention(selector) NSString -&gt; String -&gt; Bool) -&gt; Bool {<br>&gt;&gt;&gt; 		let str = NSString(string: &quot;hello&quot;)<br>&gt;&gt;&gt; 		return selector(str)(&quot;hell&quot;)<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	let x = NSString.hasPrefix<br>&gt;&gt;&gt; 	// x is of type @convention(selector) NSString -&gt; String -&gt; Bool<br>&gt;&gt;&gt; 	callSelector(x)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So that would make selectors less error-prone because the compiler can type-check them, and you can use selectors in Swift code in a very natural manner.<br>&gt;&gt; <br>&gt;&gt; I would say that &#39;let x = NSString.hasPrefix&#39; should still give you a @convention(swift) function value by default; that&#39;s what we do with method references in general, but you could ask for a @convention(selector) reference explicitly:<br>&gt;&gt; <br>&gt;&gt; let x: @convention(selector) X -&gt; Y -&gt; Z = X.hasPrefix<br>&gt; <br>&gt; One wrinkle you need to consider is the different ARC behavior of method families. @convention(selector) would have to be restricted to referencing methods that don&#39;t belong to an usual method family or have unusual ownership rules, or else we&#39;d need multiple @convention(init_selector), (copy_selector), (alloc_selector) etc. conventions.<br></p><p>Or, alternatively, encode that information in the type, which would be necessary for full ObjC fidelity anyway, since ObjC ARC allows you to override conventions with attributes.<br></p><p>The flip side is that, of course, that’s quite a bit more complicated.<br></p><p>John.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/a1f6873c/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>Type-safe selectors</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>December  4, 2015 at 06:00:00pm</p></header><div class="content"><p>Le 4 déc. 2015 à 17:31, Joe Groff &lt;jgroff at apple.com&gt; a écrit :<br></p><p>&gt; One wrinkle you need to consider is the different ARC behavior of method families. @convention(selector) would have to be restricted to referencing methods that don&#39;t belong to an usual method family or have unusual ownership rules, or else we&#39;d need multiple @convention(init_selector), (copy_selector), (alloc_selector) etc. conventions.<br></p><p>Very true. Still, people currently pass selectors around without really bothering about this. It seems to me that restricting @convention(selector) to represent methods having standard behaviour (standard being autoreleased-return with non-consuming arguments) would cover about 99.9% of the use cases.<br></p><p>-- <br>Michel Fortin<br>michel.fortin at michelf.ca<br>https://michelf.ca<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>Type-safe selectors</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>December  4, 2015 at 06:00:00pm</p></header><div class="content"><p>Le 4 déc. 2015 à 17:26, Joe Groff &lt;jgroff at apple.com&gt; a écrit :<br></p><p>&gt; This is a great approach, and it&#39;s mostly exactly what I&#39;ve had in mind for this. Another nice thing about @convention(selector) is that the compiler could also context-free closures, like with @convention(c), by compiling them down to categories with mangled methods.<br></p><p>Something like this?<br></p><p>	view.target = target<br>	view.action = { (target) in beep() }<br></p><p>Not bad, but wouldn&#39;t that be somewhat fragile? Given you must make sure the target is retained, I&#39;m not sure it really make things simpler. And you need to make sure it&#39;s not nil either: this just won&#39;t work:<br></p><p>	view.action = { beep() }<br></p><p>It looks like an error-prone idiom to me.<br></p><p><br>-- <br>Michel Fortin<br>michel.fortin at michelf.ca<br>https://michelf.ca<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Type-safe selectors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December  4, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; On Dec 4, 2015, at 3:01 PM, Michel Fortin &lt;michel.fortin at michelf.ca&gt; wrote:<br>&gt; <br>&gt; Le 4 déc. 2015 à 17:26, Joe Groff &lt;jgroff at apple.com&gt; a écrit :<br>&gt; <br>&gt;&gt; This is a great approach, and it&#39;s mostly exactly what I&#39;ve had in mind for this. Another nice thing about @convention(selector) is that the compiler could also context-free closures, like with @convention(c), by compiling them down to categories with mangled methods.<br>&gt; <br>&gt; Something like this?<br>&gt; <br>&gt; 	view.target = target<br>&gt; 	view.action = { (target) in beep() }<br>&gt; <br>&gt; Not bad, but wouldn&#39;t that be somewhat fragile? Given you must make sure the target is retained, I&#39;m not sure it really make things simpler. And you need to make sure it&#39;s not nil either: this just won&#39;t work:<br>&gt; <br>&gt; 	view.action = { beep() }<br>&gt; <br>&gt; It looks like an error-prone idiom to me.<br></p><p>That shouldn&#39;t be a problem, since the function would be emitted with the same guaranteed-self convention ObjC methods normally have.<br></p><p>-Joe<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Type-safe selectors</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December  4, 2015 at 03:00:00pm</p></header><div class="content"><p>The @convention(selector) as proposed is a neat idea, but it will<br>completely break target/action. This is because the<br>@convention(selector) is a strongly-typed function signature, but<br>target/action relies on the fact that it can provide 2 parameters to the<br>method and this will work with any method that matches one of the 3<br>forms (2 forms on OS X):<br></p><p>- (void)action<br>- (void)action:(id)sender<br>- (void)action:(id)sender forEvent:(UIEvent *)event<br></p><p>But these 3 forms translate into the 3 distinct types:<br></p><p>@convention(selector) T -&gt; () -&gt; Void<br>@convention(selector) T -&gt; AnyObject -&gt; Void<br>@convention(selector) T -&gt; AnyObject -&gt; UIEvent -&gt; Void<br></p><p>But the only way to handle this in a reasonable fashion is to allow<br>these 3 types to implicitly coerce to each other, which seems like a bad<br>idea and removes a lot of the benefit of trying to strongly type them.<br>There&#39;s also the confusion around the receiver type T here; a selector<br>can&#39;t possibly encode the receiver type, because the whole point of<br>selectors is the caller doesn&#39;t care what the receiver is, it only cares<br>how the receiver behaves. You could make the receiver be AnyObject, but<br>now you can create a selector from one type and call it with another<br>type.<br></p><p>Furthermore, how would you even handle this for methods that take<br>selectors of arbitrary types, e.g. respondsToSelector() or various obj-c<br>runtime methods? Allowing implicit conversion to a single common form<br>like `@convention(selector) () -&gt; Void` is no better than keeping the<br>current Selector (and is in fact worse because it implies strong typing<br>where there is none), and keeping the current Selector in addition to<br>@convention(selector) is not a great solution either (it leaves the<br>language as more complex, without really providing the strong typing<br>that @convention(selector) looks like it&#39;s trying to do).<br></p><p>I also worry that allowing something like @convention(selector) would be<br>confusing, because it would look like the following two code snippets<br>should be identical:<br></p><p>    foo.performSelector(Foo.handleBar)<br></p><p>and<br></p><p>    let sel = Foo.handleBar<br>    foo.performSelector(sel)<br></p><p>But this can&#39;t work because it requires the ability to convert from<br>@convention(swift) T -&gt; U into @convention(selector) T -&gt; U, which can&#39;t<br>work because not all closures will have associated selectors. You&#39;d need<br>to introduce something else, like @convention(objc_swift) T -&gt; U, that<br>includes a selector and implicitly converts to both @convention(swift)<br>and @convention(objc), but this is quickly becoming needlessly complex.<br>And it still doesn&#39;t solve the type-safety issues above.<br></p><p>---<br></p><p>My simpler proposal here would be to simply embrace the fact that<br>selectors are weakly-typed, to say that any API that wants type safety<br>should be changed to just take a closure (or to have an overload that<br>does), and then to just have a bit of Swift syntax that gives you the<br>selector for any method. I&#39;m not sure offhand what the syntax should be,<br>but I filed a couple of radars a long time ago that also asked for a<br>syntax to get at the willSet/didSet property observers and the<br>underlying storage for lazy properties, and suggested that these could<br>all use the same bit of syntax. I don&#39;t know what the syntax should be,<br>but general meaning of the syntax would be to access pieces of<br>information about members (where &quot;members&quot; means properties and<br>methods). As an example of what I&#39;m talking about, if we decided that<br>the syntax should be to use `` to access things like &quot;foo.storage&quot; as a<br>value the way you can use it for keywords-as-identifiers, then you could<br>say things like<br></p><p>    notificationCenter.addObserver(foo, selector:<br>    Foo.`observeBar.selector`, name: /* ... */)<br>    self.`lazyBar.storage` = nil<br>    self.`baz.didSet`(oldValue: qux)<br></p><p>Note that I&#39;m not actually suggesting this is the right syntax to use<br>(while I like that it re-uses existing syntax, it&#39;s also pretty weird),<br>but the concept is sound.<br></p><p>-Kevin Ballard<br></p><p>On Fri, Dec 4, 2015, at 02:26 PM, Joe Groff wrote:<br>&gt; <br>&gt; &gt; On Dec 4, 2015, at 2:22 PM, Michel Fortin &lt;michel.fortin at michelf.ca&gt; wrote:<br>&gt; &gt; <br>&gt; &gt; Currently in Swift you can get a closure by referring to a method:<br>&gt; &gt; <br>&gt; &gt; 	let x = NSString.hasPrefix<br>&gt; &gt; 	// x is of type NSString -&gt; String -&gt; Bool<br>&gt; &gt; <br>&gt; &gt; Something that would be useful here is if the closure created from Objective-C methods were special in that they could implicitly be converted to a Selector. Instead of writing manually a selector as a string, you&#39;d just have to refer to the method, and you know there&#39;s no typo (or else you get a compile-time error). For instance, adding an observer to a NSNotificationCenter would work like this:<br>&gt; &gt; <br>&gt; &gt; 	notificationCenter.addObserver(self, selector: MyClass.observeNotification, name: NSSomeNotificationName, object: nil) <br>&gt; &gt; <br>&gt; &gt; This, making sure the correct selector is used for the designated method, seem like it should be somewhat more important in Swift 3 if it includes Evolution Proposal 0005 that suggests many Objective-C methods will be given Swift-specific names.<br>&gt; &gt; https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md<br>&gt; &gt; <br>&gt; &gt; But why stop there when you can go one step further and actually improve type-safety? Instead of taking a Selector parameter, the NSNotificationCenter.addObserver method above could request a @convention(selector) closure of this form:<br>&gt; &gt; <br>&gt; &gt; 	@convention(selector) AnyObject -&gt; NSNotification -&gt; Void<br>&gt; &gt; <br>&gt; &gt; Under the hood that closure is still a plain selector pointer, but the compiler attaches proper type information to the arguments. Since `addObserver` now declares it wants a selector with the given signature, the compiler can enforce that the arguments and return type for the passed selector are compatible. You <br>&gt; <br>&gt; This is a great approach, and it&#39;s mostly exactly what I&#39;ve had in mind<br>&gt; for this. Another nice thing about @convention(selector) is that the<br>&gt; compiler could also context-free closures, like with @convention(c), by<br>&gt; compiling them down to categories with mangled methods.<br>&gt; <br>&gt; &gt; <br>&gt; &gt; Moreover, the @convention(selector) closure you get can then be used as a normal closure inside a Swift method that can be called from Objective-C:<br>&gt; &gt; <br>&gt; &gt; 	@objc func callSelector(selector: @convention(selector) NSString -&gt; String -&gt; Bool) -&gt; Bool {<br>&gt; &gt; 		let str = NSString(string: &quot;hello&quot;)<br>&gt; &gt; 		return selector(str)(&quot;hell&quot;)<br>&gt; &gt; 	}<br>&gt; &gt; <br>&gt; &gt; 	let x = NSString.hasPrefix<br>&gt; &gt; 	// x is of type @convention(selector) NSString -&gt; String -&gt; Bool<br>&gt; &gt; 	callSelector(x)<br>&gt; &gt; <br>&gt; &gt; So that would make selectors less error-prone because the compiler can type-check them, and you can use selectors in Swift code in a very natural manner.<br>&gt; <br>&gt; I would say that &#39;let x = NSString.hasPrefix&#39; should still give you a<br>&gt; @convention(swift) function value by default; that&#39;s what we do with<br>&gt; method references in general, but you could ask for a<br>&gt; @convention(selector) reference explicitly:<br>&gt; <br>&gt; let x: @convention(selector) X -&gt; Y -&gt; Z = X.hasPrefix<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt; &gt; - - -<br>&gt; &gt; <br>&gt; &gt; This is inspired from the D/Objective-C compiler I prototyped a while ago. There, I made selectors typed with their arguments because:<br>&gt; &gt; <br>&gt; &gt; 1. I wanted to preserve D&#39;s type-safety while still being able to use selectors, and<br>&gt; &gt; 2. I needed to decouple selector names from method names in the code; this would later allow me to implement overloading by adding some name mangling in selectors. Obtaining selectors by referring to the method allowed selectors to become an implementation detail while providing a nice way to associate the parameter types.<br>&gt; &gt; <br>&gt; &gt; For reference, here is the meager documentation for that feature:<br>&gt; &gt; https://michelf.ca/projects/d-objc/syntax/#selector-literals<br>&gt; &gt; And for the selector-name mangling:<br>&gt; &gt; https://michelf.ca/projects/d-objc/syntax/#generated-selectors<br>&gt; &gt; <br>&gt; &gt; <br>&gt; &gt; -- <br>&gt; &gt; Michel Fortin<br>&gt; &gt; michel.fortin at michelf.ca<br>&gt; &gt; https://michelf.ca<br>&gt; &gt; <br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Type-safe selectors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December  4, 2015 at 06:00:00pm</p></header><div class="content"><p>&gt; On Dec 4, 2015, at 3:27 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; <br>&gt; The @convention(selector) as proposed is a neat idea, but it will<br>&gt; completely break target/action. This is because the<br>&gt; @convention(selector) is a strongly-typed function signature, but<br>&gt; target/action relies on the fact that it can provide 2 parameters to the<br>&gt; method and this will work with any method that matches one of the 3<br>&gt; forms (2 forms on OS X):<br>&gt; <br>&gt; - (void)action<br>&gt; - (void)action:(id)sender<br>&gt; - (void)action:(id)sender forEvent:(UIEvent *)event<br>&gt; <br>&gt; But these 3 forms translate into the 3 distinct types:<br>&gt; <br>&gt; @convention(selector) T -&gt; () -&gt; Void<br>&gt; @convention(selector) T -&gt; AnyObject -&gt; Void<br>&gt; @convention(selector) T -&gt; AnyObject -&gt; UIEvent -&gt; Void<br>&gt; <br>&gt; But the only way to handle this in a reasonable fashion is to allow<br>&gt; these 3 types to implicitly coerce to each other, which seems like a bad<br>&gt; idea and removes a lot of the benefit of trying to strongly type them.<br>&gt; There&#39;s also the confusion around the receiver type T here; a selector<br>&gt; can&#39;t possibly encode the receiver type, because the whole point of<br>&gt; selectors is the caller doesn&#39;t care what the receiver is, it only cares<br>&gt; how the receiver behaves. You could make the receiver be AnyObject, but<br>&gt; now you can create a selector from one type and call it with another<br>&gt; type.<br></p><p>Why couldn&#39;t this be covered by overloads? It&#39;s unlikely we&#39;d be able to import selectors from Objective-C to specific types because of this and other reasons, so we&#39;d still need an untyped Selector type, but we could easily provide well-typed overloads in Swift overlays that convert from typed selectors to untyped.<br>&gt; <br>&gt; Furthermore, how would you even handle this for methods that take<br>&gt; selectors of arbitrary types, e.g. respondsToSelector() or various obj-c<br>&gt; runtime methods? Allowing implicit conversion to a single common form<br>&gt; like `@convention(selector) () -&gt; Void` is no better than keeping the<br>&gt; current Selector (and is in fact worse because it implies strong typing<br>&gt; where there is none), and keeping the current Selector in addition to<br>&gt; @convention(selector) is not a great solution either (it leaves the<br>&gt; language as more complex, without really providing the strong typing<br>&gt; that @convention(selector) looks like it&#39;s trying to do).<br></p><p>It seems to me that things like performSelector could be replaced by generics in the overlay in a similar way. &#39;respondsToSelector&#39; is probably fine taking untyped Selectors (with a subtype relationship from @convention(selector) T -&gt; U to Selector).<br></p><p>-Joe<br></p><p>&gt; I also worry that allowing something like @convention(selector) would be<br>&gt; confusing, because it would look like the following two code snippets<br>&gt; should be identical:<br>&gt; <br>&gt;    foo.performSelector(Foo.handleBar)<br>&gt; <br>&gt; and<br>&gt; <br>&gt;    let sel = Foo.handleBar<br>&gt;    foo.performSelector(sel)<br>&gt; <br>&gt; But this can&#39;t work because it requires the ability to convert from<br>&gt; @convention(swift) T -&gt; U into @convention(selector) T -&gt; U, which can&#39;t<br>&gt; work because not all closures will have associated selectors. You&#39;d need<br>&gt; to introduce something else, like @convention(objc_swift) T -&gt; U, that<br>&gt; includes a selector and implicitly converts to both @convention(swift)<br>&gt; and @convention(objc), but this is quickly becoming needlessly complex.<br>&gt; And it still doesn&#39;t solve the type-safety issues above.<br>&gt; <br>&gt; ---<br>&gt; <br>&gt; My simpler proposal here would be to simply embrace the fact that<br>&gt; selectors are weakly-typed, to say that any API that wants type safety<br>&gt; should be changed to just take a closure (or to have an overload that<br>&gt; does), and then to just have a bit of Swift syntax that gives you the<br>&gt; selector for any method. I&#39;m not sure offhand what the syntax should be,<br>&gt; but I filed a couple of radars a long time ago that also asked for a<br>&gt; syntax to get at the willSet/didSet property observers and the<br>&gt; underlying storage for lazy properties, and suggested that these could<br>&gt; all use the same bit of syntax. I don&#39;t know what the syntax should be,<br>&gt; but general meaning of the syntax would be to access pieces of<br>&gt; information about members (where &quot;members&quot; means properties and<br>&gt; methods). As an example of what I&#39;m talking about, if we decided that<br>&gt; the syntax should be to use `` to access things like &quot;foo.storage&quot; as a<br>&gt; value the way you can use it for keywords-as-identifiers, then you could<br>&gt; say things like<br>&gt; <br>&gt;    notificationCenter.addObserver(foo, selector:<br>&gt;    Foo.`observeBar.selector`, name: /* ... */)<br>&gt;    self.`lazyBar.storage` = nil<br>&gt;    self.`baz.didSet`(oldValue: qux)<br>&gt; <br>&gt; Note that I&#39;m not actually suggesting this is the right syntax to use<br>&gt; (while I like that it re-uses existing syntax, it&#39;s also pretty weird),<br>&gt; but the concept is sound.<br>&gt; <br>&gt; -Kevin Ballard<br>&gt; <br>&gt; On Fri, Dec 4, 2015, at 02:26 PM, Joe Groff wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 4, 2015, at 2:22 PM, Michel Fortin &lt;michel.fortin at michelf.ca&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Currently in Swift you can get a closure by referring to a method:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	let x = NSString.hasPrefix<br>&gt;&gt;&gt; 	// x is of type NSString -&gt; String -&gt; Bool<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Something that would be useful here is if the closure created from Objective-C methods were special in that they could implicitly be converted to a Selector. Instead of writing manually a selector as a string, you&#39;d just have to refer to the method, and you know there&#39;s no typo (or else you get a compile-time error). For instance, adding an observer to a NSNotificationCenter would work like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	notificationCenter.addObserver(self, selector: MyClass.observeNotification, name: NSSomeNotificationName, object: nil) <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This, making sure the correct selector is used for the designated method, seem like it should be somewhat more important in Swift 3 if it includes Evolution Proposal 0005 that suggests many Objective-C methods will be given Swift-specific names.<br>&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But why stop there when you can go one step further and actually improve type-safety? Instead of taking a Selector parameter, the NSNotificationCenter.addObserver method above could request a @convention(selector) closure of this form:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	@convention(selector) AnyObject -&gt; NSNotification -&gt; Void<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Under the hood that closure is still a plain selector pointer, but the compiler attaches proper type information to the arguments. Since `addObserver` now declares it wants a selector with the given signature, the compiler can enforce that the arguments and return type for the passed selector are compatible. You <br>&gt;&gt; <br>&gt;&gt; This is a great approach, and it&#39;s mostly exactly what I&#39;ve had in mind<br>&gt;&gt; for this. Another nice thing about @convention(selector) is that the<br>&gt;&gt; compiler could also context-free closures, like with @convention(c), by<br>&gt;&gt; compiling them down to categories with mangled methods.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Moreover, the @convention(selector) closure you get can then be used as a normal closure inside a Swift method that can be called from Objective-C:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	@objc func callSelector(selector: @convention(selector) NSString -&gt; String -&gt; Bool) -&gt; Bool {<br>&gt;&gt;&gt; 		let str = NSString(string: &quot;hello&quot;)<br>&gt;&gt;&gt; 		return selector(str)(&quot;hell&quot;)<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	let x = NSString.hasPrefix<br>&gt;&gt;&gt; 	// x is of type @convention(selector) NSString -&gt; String -&gt; Bool<br>&gt;&gt;&gt; 	callSelector(x)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So that would make selectors less error-prone because the compiler can type-check them, and you can use selectors in Swift code in a very natural manner.<br>&gt;&gt; <br>&gt;&gt; I would say that &#39;let x = NSString.hasPrefix&#39; should still give you a<br>&gt;&gt; @convention(swift) function value by default; that&#39;s what we do with<br>&gt;&gt; method references in general, but you could ask for a<br>&gt;&gt; @convention(selector) reference explicitly:<br>&gt;&gt; <br>&gt;&gt; let x: @convention(selector) X -&gt; Y -&gt; Z = X.hasPrefix<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt;&gt; - - -<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is inspired from the D/Objective-C compiler I prototyped a while ago. There, I made selectors typed with their arguments because:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. I wanted to preserve D&#39;s type-safety while still being able to use selectors, and<br>&gt;&gt;&gt; 2. I needed to decouple selector names from method names in the code; this would later allow me to implement overloading by adding some name mangling in selectors. Obtaining selectors by referring to the method allowed selectors to become an implementation detail while providing a nice way to associate the parameter types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For reference, here is the meager documentation for that feature:<br>&gt;&gt;&gt; https://michelf.ca/projects/d-objc/syntax/#selector-literals<br>&gt;&gt;&gt; And for the selector-name mangling:<br>&gt;&gt;&gt; https://michelf.ca/projects/d-objc/syntax/#generated-selectors<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Michel Fortin<br>&gt;&gt;&gt; michel.fortin at michelf.ca<br>&gt;&gt;&gt; https://michelf.ca<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>Type-safe selectors</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>December  4, 2015 at 10:00:00pm</p></header><div class="content"><p>Le 4 déc. 2015 à 21:45, Joe Groff &lt;jgroff at apple.com&gt; a écrit :<br>&gt; <br>&gt;&gt; - (void)action<br>&gt;&gt; - (void)action:(id)sender<br>&gt;&gt; - (void)action:(id)sender forEvent:(UIEvent *)event<br>&gt; <br>&gt; Why couldn&#39;t this be covered by overloads? It&#39;s unlikely we&#39;d be able to import selectors from Objective-C to specific types because of this and other reasons, so we&#39;d still need an untyped Selector type, but we could easily provide well-typed overloads in Swift overlays that convert from typed selectors to untyped.<br></p><p>Good point. Overloads in framework overlays. That&#39;s much simpler than having the compiler trying to infer compatibility as I just suggested.<br></p><p><br>Le 4 déc. 2015 à 21:49, Brent Royal-Gordon &lt;brent at architechies.com&gt; a écrit :<br></p><p>&gt; If you’re worried about compile-time type checking of the call site, generics can help tie the selector to the object it’s intended for:<br>&gt; <br>&gt; 	func addTarget&lt;T: NSObject&gt;(target: T?, action: @convention(selector) T -&gt; AnyObject -&gt; Void, forControlEvents: UIControlEvents)<br></p><p>Nice.<br></p><p>Damned OS X with its target and action properties you have to set separately. Of course you could use the extension below, but it&#39;s still bad that you can then set the two properties separately.<br></p><p>	extension NSControl {<br>		func setTarget&lt;T: NSObject&gt;(target: T?, action: @convention(selector) T -&gt; AnyObject -&gt; Void) {<br>			self.target = target<br>			self.action = action<br>		}<br>	}<br></p><p><br>-- <br>Michel Fortin<br>michel.fortin at michelf.ca<br>https://michelf.ca<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Type-safe selectors</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December  4, 2015 at 10:00:00pm</p></header><div class="content"><p>On Fri, Dec 4, 2015, at 06:45 PM, Joe Groff wrote:<br></p><p>&gt; Why couldn&#39;t this be covered by overloads? It&#39;s unlikely we&#39;d be able<br>&gt; to import selectors from Objective-C to specific types because of this<br>&gt; and other reasons, so we&#39;d still need an untyped Selector type, but we<br>&gt; could easily provide well-typed overloads in Swift overlays that<br>&gt; convert from typed selectors to untyped.<br></p><p>This can only be covered by overloads when the selector is passed to a<br>function. So that would work for target/action in iOS, where you use<br>addTarget(_:action:forControlEvents:). But it won&#39;t work for OS X, where<br>target/action is exposed as two independent properties, because you<br>can&#39;t overload properties.<br></p><p>On Fri, Dec 4, 2015, at 06:46 PM, Michel Fortin wrote:<br></p><p>&gt; Implicit conversions cannot happen safely in the direction SubType to BaseType for<br>&gt; the arguments, including the target object. That makes Joe Groff&#39;s<br>&gt; approach the only type-safe solution: make an extension of the base<br>&gt; object and generate a method that does what you want. Which means that<br>&gt; instead of this:<br>&gt; <br>&gt; 	view.action = MyObject.doSomething<br>&gt; <br>&gt; you could write this:<br>&gt; <br>&gt; 	view.action = { (target: AnyObject) in {<br>&gt; 		(target as! MyObject).doSomething()<br>&gt; 	}<br>&gt; <br>&gt; ...which is safe. Maybe the compiler should just auto-generate that<br>&gt; boilerplate for you.<br></p><p>How can you write that? A @convention(selector) can&#39;t actually contain<br>any executable code, because there&#39;s nowhere to store that code (since<br>the runtime representation of a @convention(selector) is just a SEL,<br>because the message dispatch is done strictly with the SEL and the<br>receiver object). So you can&#39;t make this type-safe on the receiver,<br>because the object that receives the selector is by definition the<br>receiver, and there&#39;s no way to force this to be the same type as the<br>type you generated the selector from.<br></p><p>-Kevin Ballard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Type-safe selectors</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December  4, 2015 at 11:00:00pm</p></header><div class="content"><p>&gt;&gt; Why couldn&#39;t this be covered by overloads? It&#39;s unlikely we&#39;d be able<br>&gt;&gt; to import selectors from Objective-C to specific types because of this<br>&gt;&gt; and other reasons, so we&#39;d still need an untyped Selector type, but we<br>&gt;&gt; could easily provide well-typed overloads in Swift overlays that<br>&gt;&gt; convert from typed selectors to untyped.<br>&gt; <br>&gt; This can only be covered by overloads when the selector is passed to a<br>&gt; function. So that would work for target/action in iOS, where you use<br>&gt; addTarget(_:action:forControlEvents:). But it won&#39;t work for OS X, where<br>&gt; target/action is exposed as two independent properties, because you<br>&gt; can&#39;t overload properties.<br></p><p>So? I mean, it’s sad that OS X can’t force you to use a selector that matches the target. But you’re still going to get some typing benefits.<br></p><p>Suppose NSControl is bridged to Swift with these properties:<br></p><p>	var target: NSObjectProtocol?<br>	var action: Selector<br></p><p>And you set it up like so:<br></p><p>	frobButton.target = controller<br>	frobButton.action = MyViewController.frobnicate<br></p><p>Swift can’t prove that myViewController is of type MyViewController. But this code still proves that:<br></p><p>1. controller is an NSObjectProtocol, and thus a plausible target.<br>2. frobnicate is a real method on MyViewController (it’s not misspelled, it’s not on the window controller or something).<br>3. frobnicate is an @objc method.<br>4. frobnicate will be called if target is a MyViewController (i.e. the user doesn’t have to understand how Objective-C selectors map to Swift methods or worry about whether that particular method has an @objc(replacementName:) attribute).<br></p><p>Now let’s give action a more precise definition:<br></p><p>	var action: (@convention(selector) NSObjectProtocol -&gt; AnyObject -&gt; Void)?<br></p><p>(This doesn’t support no-sender actions, but technically, I don’t think OS X is supposed to allow them. They coincidentally work because the ABI is loosey-goosey in the right places.)<br></p><p>To the above four guarantees, this definition adds a fifth:<br></p><p>5. frobnicate takes one parameter which can accept an AnyObject.<br></p><p>Do these guarantees mean that you can’t ever mismatch the target and action? No. But do they eliminate several other common target/action bugs? Yes! That seems worth doing to me.<br></p><p>And that’s assuming you don’t take any artistic license in the bridging. There’s no reason the Swift overlay can’t do as Michel Fortin suggested and hide the target and action setters, replacing them with a method which provides the same features and guarantees as UIKit’s overloaded calls:<br></p><p>	func setTarget&lt;T: NSObjectProtocol&gt;(target: T?, action: (@convention(selector) T -&gt; AnyObject -&gt; Void)?)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>Type-safe selectors</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>December  5, 2015 at 07:00:00am</p></header><div class="content"><p>On Fri, Dec 4, 2015, at 06:46 PM, Michel Fortin wrote:<br></p><p>&gt;&gt; Implicit conversions cannot happen safely in the direction SubType to BaseType for<br>&gt;&gt; the arguments, including the target object. That makes Joe Groff&#39;s<br>&gt;&gt; approach the only type-safe solution: make an extension of the base<br>&gt;&gt; object and generate a method that does what you want. Which means that<br>&gt;&gt; instead of this:<br>&gt;&gt; <br>&gt;&gt; 	view.action = MyObject.doSomething<br>&gt;&gt; <br>&gt;&gt; you could write this:<br>&gt;&gt; <br>&gt;&gt; 	view.action = { (target: AnyObject) in {<br>&gt;&gt; 		(target as! MyObject).doSomething()<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; ...which is safe. Maybe the compiler should just auto-generate that<br>&gt;&gt; boilerplate for you.<br>&gt; <br>&gt; How can you write that? A @convention(selector) can&#39;t actually contain<br>&gt; any executable code [...]<br></p><p>Like this:<br></p><p>	view.action = &quot;_doSomething_UniqueSelector1234_currentModuleName_blahblah&quot;<br></p><p>	extension NSObject {<br>		func _doSomething_UniqueSelector1234_currentModuleName_blahblah() {<br>			let target = self<br>			(target as! MyObject).doSomething()<br>		}<br>	}<br></p><p>(Joe Groff suggested it first.) This simply assumes the receiver will derive from NSObject. You also need to set a non-nil target. And note that the closure is context-free, meaning you can&#39;t capture variables with it.<br></p><p>I wonder how many methods like this you can add to NSObject before it starts to impact objc_msgSend dispatch performance...<br></p><p><br>-- <br>Michel Fortin<br>michel.fortin at michelf.ca<br>https://michelf.ca<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Type-safe selectors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December  5, 2015 at 07:00:00am</p></header><div class="content"><p>&gt; On Dec 5, 2015, at 4:30 AM, Michel Fortin &lt;michel.fortin at michelf.ca&gt; wrote:<br>&gt; <br>&gt; On Fri, Dec 4, 2015, at 06:46 PM, Michel Fortin wrote:<br>&gt; <br>&gt;&gt;&gt; Implicit conversions cannot happen safely in the direction SubType to BaseType for<br>&gt;&gt;&gt; the arguments, including the target object. That makes Joe Groff&#39;s<br>&gt;&gt;&gt; approach the only type-safe solution: make an extension of the base<br>&gt;&gt;&gt; object and generate a method that does what you want. Which means that<br>&gt;&gt;&gt; instead of this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	view.action = MyObject.doSomething<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; you could write this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	view.action = { (target: AnyObject) in {<br>&gt;&gt;&gt; 		(target as! MyObject).doSomething()<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ...which is safe. Maybe the compiler should just auto-generate that<br>&gt;&gt;&gt; boilerplate for you.<br>&gt;&gt; <br>&gt;&gt; How can you write that? A @convention(selector) can&#39;t actually contain<br>&gt;&gt; any executable code [...]<br>&gt; <br>&gt; Like this:<br>&gt; <br>&gt; 	view.action = &quot;_doSomething_UniqueSelector1234_currentModuleName_blahblah&quot;<br>&gt; <br>&gt; 	extension NSObject {<br>&gt; 		func _doSomething_UniqueSelector1234_currentModuleName_blahblah() {<br>&gt; 			let target = self<br>&gt; 			(target as! MyObject).doSomething()<br>&gt; 		}<br>&gt; 	}<br>&gt; <br>&gt; (Joe Groff suggested it first.) This simply assumes the receiver will derive from NSObject. You also need to set a non-nil target. And note that the closure is context-free, meaning you can&#39;t capture variables with it.<br>&gt; <br>&gt; I wonder how many methods like this you can add to NSObject before it starts to impact objc_msgSend dispatch performance...<br></p><p>The receiver doesn&#39;t have to inherit NSObject. Pure Swift classes on Darwin are id-compatible and can have categories as well.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>Type-safe selectors</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>December  5, 2015 at 10:00:00am</p></header><div class="content"><p>Le 5 déc. 2015 à 10:17, Joe Groff &lt;jgroff at apple.com&gt; a écrit :<br>&gt; The receiver doesn&#39;t have to inherit NSObject. Pure Swift classes on Darwin are id-compatible and can have categories as well.<br></p><p>Does that mean that the compiler has to write two categories? one for NSObject and one for the root Swift class?<br></p><p>-- <br>Michel Fortin<br>michel.fortin at michelf.ca<br>https://michelf.ca<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Type-safe selectors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December  5, 2015 at 07:00:00am</p></header><div class="content"><p>&gt; On Dec 5, 2015, at 7:29 AM, Michel Fortin &lt;michel.fortin at michelf.ca&gt; wrote:<br>&gt; <br>&gt; Le 5 déc. 2015 à 10:17, Joe Groff &lt;jgroff at apple.com&gt; a écrit :<br>&gt;&gt; The receiver doesn&#39;t have to inherit NSObject. Pure Swift classes on Darwin are id-compatible and can have categories as well.<br>&gt; <br>&gt; Does that mean that the compiler has to write two categories? one for NSObject and one for the root Swift class?<br></p><p>If the selector is expected to exist on an arbitrary `id`, maybe. If it only needs to exist on its `Self` type, it seems to me we can emit the category onto the specific class.<br></p><p>-Joe<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Type-safe selectors</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December  5, 2015 at 12:00:00pm</p></header><div class="content"><p>On Sat, Dec 5, 2015, at 04:30 AM, Michel Fortin wrote:<br>&gt; Like this:<br>&gt; <br>&gt; 	view.action = &quot;_doSomething_UniqueSelector1234_currentModuleName_blahblah&quot;<br>&gt; <br>&gt; 	extension NSObject {<br>&gt; 		func _doSomething_UniqueSelector1234_currentModuleName_blahblah() {<br>&gt; 			let target = self<br>&gt; 			(target as! MyObject).doSomething()<br>&gt; 		}<br>&gt; 	}<br>&gt; <br>&gt; (Joe Groff suggested it first.) This simply assumes the receiver will<br>&gt; derive from NSObject. You also need to set a non-nil target. And note<br>&gt; that the closure is context-free, meaning you can&#39;t capture variables<br>&gt; with it.<br></p><p>How is this type-safe? You&#39;re using as! in there (and silently ignoring<br>the message if the receiver is wrong wouldn&#39;t be any better). If I send<br>a selector to the wrong receiver, it&#39;s still going to crash.<br></p><p>This comes back to my fundamental argument, which is that<br>@convention(selector) looks like it&#39;s type-safe, but there&#39;s so many<br>holes and so many implicit coercions that need to be added that you can<br>drive a gigantic truck full of unsafety right through it without even<br>noticing.<br></p><p>-Kevin Ballard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Type-safe selectors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December  5, 2015 at 06:00:00pm</p></header><div class="content"><p>&gt; On Dec 5, 2015, at 12:35 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; <br>&gt; On Sat, Dec 5, 2015, at 04:30 AM, Michel Fortin wrote:<br>&gt;&gt; Like this:<br>&gt;&gt; <br>&gt;&gt; 	view.action = &quot;_doSomething_UniqueSelector1234_currentModuleName_blahblah&quot;<br>&gt;&gt; <br>&gt;&gt; 	extension NSObject {<br>&gt;&gt; 		func _doSomething_UniqueSelector1234_currentModuleName_blahblah() {<br>&gt;&gt; 			let target = self<br>&gt;&gt; 			(target as! MyObject).doSomething()<br>&gt;&gt; 		}<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; (Joe Groff suggested it first.) This simply assumes the receiver will<br>&gt;&gt; derive from NSObject. You also need to set a non-nil target. And note<br>&gt;&gt; that the closure is context-free, meaning you can&#39;t capture variables<br>&gt;&gt; with it.<br>&gt; <br>&gt; How is this type-safe? You&#39;re using as! in there (and silently ignoring<br>&gt; the message if the receiver is wrong wouldn&#39;t be any better). If I send<br>&gt; a selector to the wrong receiver, it&#39;s still going to crash.<br></p><p>I think this would be better emitted like a category on MyObject than on NSObject.<br></p><p>&gt; This comes back to my fundamental argument, which is that<br>&gt; @convention(selector) looks like it&#39;s type-safe, but there&#39;s so many<br>&gt; holes and so many implicit coercions that need to be added that you can<br>&gt; drive a gigantic truck full of unsafety right through it without even<br>&gt; noticing.<br></p><p>There&#39;s plenty of useful space between &quot;no type safety&quot; and &quot;perfect type safety&quot;, IMO.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Type-safe selectors</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December  5, 2015 at 07:00:00pm</p></header><div class="content"><p>On Sat, Dec 5, 2015, at 06:00 PM, Joe Groff wrote:<br>&gt; &gt; How is this type-safe? You&#39;re using as! in there (and silently ignoring<br>&gt; &gt; the message if the receiver is wrong wouldn&#39;t be any better). If I send<br>&gt; &gt; a selector to the wrong receiver, it&#39;s still going to crash.<br>&gt; <br>&gt; I think this would be better emitted like a category on MyObject than on<br>&gt; NSObject.<br></p><p>Going back and reading your original suggestion about generating<br>closures, I think we&#39;re talking about this differently. If I understand<br>it right, your original suggestion for generating closures basically<br>just solves the problem of forgetting to mark a method as @objc, right?<br>In that case, putting the category on MyObject instead of NSObject is<br>absolutely the right thing to do. My arguments here are actually about<br>Michel Fortin&#39;s claim:<br></p><p>&gt; The fact that the selector lives separately from its target object makes things difficult because the expected target type is almost always going to be AnyObject. Implicit conversions cannot happen safely in the direction SubType to BaseType for the arguments, including the target object. That makes Joe Groff&#39;s approach the only type-safe solution: make an extension of the base object and generate a method that does what you want.<br></p><p>Which is in the context of the fact that @convention(selector) MyObject<br>-&gt; Args -&gt; Ret encodes the receiver type, but the problem is the<br>selector is sent to AnyObject, so having the receiver type in there is<br>basically false type-safety (it looks like it&#39;s strongly-typed but it&#39;s<br>actually not as that type information will be thrown away before the<br>selector is used). I&#39;m not really sure why Michel claimed that your<br>closure suggestion was a solution to this problem, because the only<br>reasonable behavior one can use in such a category emitted on<br>AnyObject/swift base class is to fatalError, which is no better than<br>what happens if the selector simply isn&#39;t implemented.<br></p><p>Ultimately, given the premise that @convention(selector) T -&gt; Args -&gt;<br>Ret exists, generating those methods on the receiver type with mangled<br>selector names seems like reasonable behavior. I just don&#39;t think<br>@convention(selector) should exist.<br></p><p>&gt; There&#39;s plenty of useful space between &quot;no type safety&quot; and &quot;perfect type safety&quot;, IMO.<br></p><p>In principle I agree. My basic argument here is that<br>@convention(selector) provides so little actual type safety that it&#39;s<br>not worth the language complexity. And I also worry that providing<br>functionality that appears to be strongly-typed but doesn&#39;t actually<br>provide any typing guarantees in practice will end up as a safety hazard<br>for unwary programmers.<br></p><p>It&#39;s also worth pointing out that my alternative suggestion of simply<br>providing some syntax to explicitly get a Selector from a method could<br>still use your closure-generating idea to work for non- at objc methods.<br>Heck, we don&#39;t even really need syntax for this, we could just say that<br>unbound method references can resolve to Selectors in addition to<br>function types (just as the primary suggestion here allows method<br>references to resolve to @convention(selector) functions in addition to<br>@convention(swift) functions).<br></p><p>-Kevin Ballard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>Type-safe selectors</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>December  6, 2015 at 10:00:00am</p></header><div class="content"><p>Le 5 déc. 2015 à 22:35, Kevin Ballard &lt;kevin at sb.org&gt; a écrit :<br></p><p>&gt; Which is in the context of the fact that @convention(selector) MyObject<br>&gt; -&gt; Args -&gt; Ret encodes the receiver type, but the problem is the<br>&gt; selector is sent to AnyObject, so having the receiver type in there is<br>&gt; basically false type-safety (it looks like it&#39;s strongly-typed but it&#39;s<br>&gt; actually not as that type information will be thrown away before the<br>&gt; selector is used). I&#39;m not really sure why Michel claimed that your<br>&gt; closure suggestion was a solution to this problem, because the only<br>&gt; reasonable behavior one can use in such a category emitted on<br>&gt; AnyObject/swift base class is to fatalError, which is no better than<br>&gt; what happens if the selector simply isn&#39;t implemented.<br></p><p>Somehow in the thinking process I forgot that the category could have been put on MyObject instead of NSObject. I agree it&#39;s better to set the category on MyObject.<br></p><p>As for why a category at all? The risk is that another class implements &quot;doSomething:&quot; with a different argument type or return type than the &quot;doSomething:&quot; referring to, and that somehow an object of this other class becomes the target. In that case you want to halt the program to avoid the other &quot;doSomething:&quot; method from being called. That&#39;s why I suggested using a unique selector. And that idea came from Joe&#39;s suggestion of creating unique selectors from context-free closures.<br></p><p><br>&gt;&gt; There&#39;s plenty of useful space between &quot;no type safety&quot; and &quot;perfect type safety&quot;, IMO.<br>&gt; <br>&gt; In principle I agree. My basic argument here is that<br>&gt; @convention(selector) provides so little actual type safety that it&#39;s<br>&gt; not worth the language complexity. And I also worry that providing<br>&gt; functionality that appears to be strongly-typed but doesn&#39;t actually<br>&gt; provide any typing guarantees in practice will end up as a safety hazard<br>&gt; for unwary programmers.<br></p><p>This is a reasonable concern. My opinion is that for @convention(selector) to be worthwhile, it needs to be safe.. If it can&#39;t be made safe, then maybe the idea probably should be abandoned. I think we are on the same page here, except that I&#39;m more optimistic about type-safety.<br></p><p><br>&gt; It&#39;s also worth pointing out that my alternative suggestion of simply<br>&gt; providing some syntax to explicitly get a Selector from a method could<br>&gt; still use your closure-generating idea to work for non- at objc methods.<br>&gt; Heck, we don&#39;t even really need syntax for this, we could just say that<br>&gt; unbound method references can resolve to Selectors in addition to<br>&gt; function types (just as the primary suggestion here allows method<br>&gt; references to resolve to @convention(selector) functions in addition to<br>&gt; @convention(swift) functions).<br></p><p>Most ideas floating in this thread are actually not mutually exclusive. I wouldn&#39;t qualify them as &quot;alternatives&quot; really since they can easily combine. We should look at the tradeoff of each and keep the good ones.<br></p><p><br>-- <br>Michel Fortin<br>michel.fortin at michelf.ca<br>https://michelf.ca<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>Type-safe selectors</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>December  4, 2015 at 09:00:00pm</p></header><div class="content"><p>Le 4 déc. 2015 à 18:27, Kevin Ballard &lt;kevin at sb.org&gt; a écrit :<br></p><p>&gt; The @convention(selector) as proposed is a neat idea, but it will<br>&gt; completely break target/action. This is because the<br>&gt; @convention(selector) is a strongly-typed function signature, but<br>&gt; target/action relies on the fact that it can provide 2 parameters to the<br>&gt; method and this will work with any method that matches one of the 3<br>&gt; forms (2 forms on OS X):<br>&gt; <br>&gt; - (void)action<br>&gt; - (void)action:(id)sender<br>&gt; - (void)action:(id)sender forEvent:(UIEvent *)event<br>&gt; <br>&gt; But these 3 forms translate into the 3 distinct types:<br>&gt; <br>&gt; @convention(selector) T -&gt; () -&gt; Void<br>&gt; @convention(selector) T -&gt; AnyObject -&gt; Void<br>&gt; @convention(selector) T -&gt; AnyObject -&gt; UIEvent -&gt; Void<br>&gt; <br>&gt; But the only way to handle this in a reasonable fashion is to allow<br>&gt; these 3 types to implicitly coerce to each other, which seems like a bad<br>&gt; idea and removes a lot of the benefit of trying to strongly type them.<br></p><p>I don&#39;t think it removes the benefit of strongly typing them. The reason to strongly type selectors is to avoid generating buggy code such as when passing an Int to a method that expects a pointer. Implicitly converting &quot;@convention(selector) T -&gt; (AnyObject, UIEvent) -&gt; Void&quot; to &quot;@convention(selector) T -&gt; () -&gt; Void&quot; is perfectly safe (we know it and do all the time) and the compiler could verify that for you before allowing the conversion to happen.<br></p><p>I agree with you though that if this implicit conversion does not work, it&#39;s going to be annoying despite the type-safety benefits.<br></p><p><br>&gt; There&#39;s also the confusion around the receiver type T here; a selector<br>&gt; can&#39;t possibly encode the receiver type, because the whole point of<br>&gt; selectors is the caller doesn&#39;t care what the receiver is, it only cares<br>&gt; how the receiver behaves. You could make the receiver be AnyObject, but<br>&gt; now you can create a selector from one type and call it with another<br>&gt; type.<br></p><p>That&#39;s indeed true. I hadn&#39;t realized. The fact that the selector lives separately from its target object makes things difficult because the expected target type is almost always going to be AnyObject. Implicit conversions cannot happen safely in the direction SubType to BaseType for the arguments, including the target object. That makes Joe Groff&#39;s approach the only type-safe solution: make an extension of the base object and generate a method that does what you want. Which means that instead of this:<br></p><p>	view.action = MyObject.doSomething<br></p><p>you could write this:<br></p><p>	view.action = { (target: AnyObject) in {<br>		(target as! MyObject).doSomething()<br>	}<br></p><p>...which is safe. Maybe the compiler should just auto-generate that boilerplate for you.<br></p><p><br>&gt; Furthermore, how would you even handle this for methods that take<br>&gt; selectors of arbitrary types, e.g. respondsToSelector() or various obj-c<br>&gt; runtime methods? Allowing implicit conversion to a single common form<br>&gt; like `@convention(selector) () -&gt; Void` is no better than keeping the<br>&gt; current Selector (and is in fact worse because it implies strong typing<br>&gt; where there is none), and keeping the current Selector in addition to<br>&gt; @convention(selector) is not a great solution either (it leaves the<br>&gt; language as more complex, without really providing the strong typing<br>&gt; that @convention(selector) looks like it&#39;s trying to do).<br></p><p>Having a @convention(selector) does not mean you have to get rid of Selector everywhere. When you have a selector of an unknown kind (such as in respondsToSelector), just use Selector, as you do currently. Perhaps it should be renamed to UnsafeSelector.<br></p><p>And with an UnsafeSelector you should be able to unsafely convert it to a selector closure that you can then call:<br></p><p>	let sel: UnsafeSelector = NSString.lengthOfBytesUsingEncoding<br>	// sel has no type information for the target or arguments<br>	let closure = sel.convertTo&lt;@convention(selector) NSString -&gt; UInt -&gt; Int&gt;()<br>	// now that we&#39;ve reinjected the type information, we can call it<br>	let result = closure(&quot;hello&quot;)(NSASCIIStringEncoding)<br></p><p>One important reason for having @convention(selector) is so you can call the selector from Swift.<br></p><p><br>&gt; I also worry that allowing something like @convention(selector) would be<br>&gt; confusing, because it would look like the following two code snippets<br>&gt; should be identical:<br>&gt; <br>&gt;    foo.performSelector(Foo.handleBar)<br>&gt; <br>&gt; and<br>&gt; <br>&gt;    let sel = Foo.handleBar<br>&gt;    foo.performSelector(sel)<br>&gt; <br>&gt; But this can&#39;t work because it requires the ability to convert from<br>&gt; @convention(swift) T -&gt; U into @convention(selector) T -&gt; U, which can&#39;t<br>&gt; work because not all closures will have associated selectors.<br></p><p>No, you certainly can&#39;t convert from @convention(swift) to @convention(selector). The reverse is possible however. That&#39;s why my first idea was to have &quot;Foo.handleBar&quot; be @convention(selector) with implicit conversion to @convention(swift) when necessary. Then Joe Groff suggested that this should only happen if you explicitly specify the type of &quot;sel&quot; to be @convention(selector). It makes sense from a performance standpoint that you don&#39;t want to wrap calls more than necessary.<br></p><p>Like you I feel like the two code snippets above should be equivalent. But if there&#39;s going to be a performance cost because of an implicit conversion from @convention(selector) to @convention(swift), then I think Joe&#39;s idea is the right one: force the user to specify early the type he needs and don&#39;t implicitly convert between conventions. Which gives you this:<br></p><p>	let sel: UnsafeSelector = Foo.handleBar<br>	foo.performSelector(sel)<br></p><p>or this (type-safe using objc_msgSend):<br></p><p>	let sel: @convention(selector) Foo -&gt; () -&gt; () = Foo.handleBar<br>	sel(foo)()<br></p><p>or this (type-safe using swift convention): <br></p><p>	let closure = Foo.handleBar<br>	closure(foo)() // likely the most performant<br></p><p><br>-- <br>Michel Fortin<br>michel.fortin at michelf.ca<br>https://michelf.ca<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Type-safe selectors</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December  4, 2015 at 06:00:00pm</p></header><div class="content"><p>&gt; But these 3 forms translate into the 3 distinct types:<br>&gt; <br>&gt; @convention(selector) T -&gt; () -&gt; Void<br>&gt; @convention(selector) T -&gt; AnyObject -&gt; Void<br>&gt; @convention(selector) T -&gt; AnyObject -&gt; UIEvent -&gt; Void<br></p><p>Niggle: the third one is actually &quot;T -&gt; (AnyObject, UIEvent) -&gt; Void”—arguments that go in the same parentheses live together in a tuple. Well, technically, the UIEvent is optional too, but that’s beside the point.<br></p><p>Addressing something out of order:<br></p><p>&gt; There&#39;s also the confusion around the receiver type T here; a selector<br>&gt; can&#39;t possibly encode the receiver type, because the whole point of<br>&gt; selectors is the caller doesn&#39;t care what the receiver is, it only cares<br>&gt; how the receiver behaves. You could make the receiver be AnyObject, but<br>&gt; now you can create a selector from one type and call it with another<br>&gt; type.<br></p><p>I’m not entirely sure what you’re objecting to here.<br></p><p>If you’re worried about compile-time type checking of the call site, generics can help tie the selector to the object it’s intended for:<br></p><p>	func addTarget&lt;T: NSObject&gt;(target: T?, action: @convention(selector) T -&gt; AnyObject -&gt; Void, forControlEvents: UIControlEvents)<br></p><p>Within the body of addTarget(_:action:forControlEvents:), the type information would be attached to the action *variable*, not the *value* in the variable. This would allow you to support a syntax like this for calling a selector “closure”, instead of relying on performSelector or NSInvocation:<br></p><p>	action(target)(sender)<br></p><p>I believe that natively, this would only allow a ‘target’ that ‘is’ whatever class the action was taken from. Anything less wouldn’t typecheck.<br></p><p>Casting from a typed @convention(selector) closure to a plain Selector would indeed strip away its type information, and casting from a Selector back to an @convention(selector) closure would be unsafe. Perhaps Selector would become “UnsafeSelector&quot; and you’d need an unsafeBitcast() to cast it back into a callable typed selector.<br></p><p>Or are you objecting to the fact that, if the Swift bridging doesn’t correctly reflect the semantics, Objective-C code can still do the wrong thing? Objective-C code can *always* do the wrong thing.<br></p><p>&gt; But the only way to handle this in a reasonable fashion is to allow<br>&gt; these 3 types to implicitly coerce to each other, which seems like a bad<br>&gt; idea and removes a lot of the benefit of trying to strongly type them.<br></p><p>Or you can bridge it with several overloaded signatures:<br></p><p>	// This is what’s actually in the Objective-C<br>	func addTarget(target: AnyObject?, action: UnsafeSelector, forControlEvents: UIControlEvents)<br></p><p>	// These three are added by the bridging layer<br>	func addTarget&lt;T: NSObject&gt;(target: T?, action: @convention(selector) T -&gt; () -&gt; Void, forControlEvents: UIControlEvents)<br>	func addTarget&lt;T: NSObject&gt;(target: T?, action: @convention(selector) T -&gt; (AnyObject) -&gt; Void, forControlEvents: UIControlEvents)<br>	func addTarget&lt;T: NSObject&gt;(target: T?, action: @convention(selector) T -&gt; (AnyObject, UIEvent?) -&gt; Void, forControlEvents: UIControlEvents)<br></p><p>This looks slightly gross, but it’s just reflecting the underlying sloppiness of the target-action mechanism. And it would have helped me a couple months ago, when I forgot that UIGestureRecognizer does *not* have a form which takes an event and lost an hour trying to write a gesture recognizer handler which inspected it. (For added fun, this broke in different ways on the simulator and device.)<br></p><p>&gt; Furthermore, how would you even handle this for methods that take<br>&gt; selectors of arbitrary types, e.g. respondsToSelector() or various obj-c<br>&gt; runtime methods?<br></p><p>By taking a Selector, just as it works currently:<br></p><p>	func respondsToSelector(selector: UnsafeSelector) -&gt; Bool<br></p><p>By bridging it as a generic method:<br></p><p>	func respondsToSelector&lt;Args, Return&gt;(selector: @convention(selector) Self -&gt; Args -&gt; Return) -&gt; Bool<br></p><p>By bridging it with Any, which permits any tuple, and otherwise can’t bridge to Objective-C:<br></p><p>	func respondsToSelector(selector: @convention(selector) Self -&gt; Any -&gt; Any) -&gt; Bool<br></p><p>(I *think* the first Any is technically unsound—it should be a bottom type—but a selector with an Any would be uncallable anyway.)<br></p><p>I can think of a few options.<br></p><p>&gt; Allowing implicit conversion to a single common form<br>&gt; like `@convention(selector) () -&gt; Void` is no better than keeping the<br>&gt; current Selector (and is in fact worse because it implies strong typing<br>&gt; where there is none), and keeping the current Selector in addition to<br>&gt; @convention(selector) is not a great solution either (it leaves the<br>&gt; language as more complex, without really providing the strong typing<br>&gt; that @convention(selector) looks like it&#39;s trying to do).<br></p><p>The way I see it, @convention(selector) is an opt-in form of strong typing. You can work with bare selectors if you want, just as you can pass around AnyObjects if you want, but when you *do* use @convention(selector) you get extra safety checks.<br></p><p>And, to add a carrot, you could probably get benefits at the call site too—I see no reason Swift couldn’t infer the proper type based on the type of the target parameter if you said:<br></p><p>	incrementButton.addTarget(self, action: .increment, forControlEvents: .PrimaryActionTriggered)<br></p><p>&gt; My simpler proposal here would be to simply embrace the fact that<br>&gt; selectors are weakly-typed, to say that any API that wants type safety<br>&gt; should be changed to just take a closure (or to have an overload that<br>&gt; does), and then to just have a bit of Swift syntax that gives you the<br>&gt; selector for any method.<br></p><p>In &quot;should be changed to just take a closure”, the “just” carries a lot of water. For instance, that “just” includes redesigning the entire target-action system in two UI frameworks. And how does the concept of dispatching to the first responder apply here? Or is the responder chain basically dead to Swift?<br></p><p>Beware the word “just”.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>Type-safe selectors</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>December  5, 2015 at 07:00:00am</p></header><div class="content"><p>Le 4 déc. 2015 à 21:49, Brent Royal-Gordon &lt;brent at architechies.com&gt; a écrit :<br></p><p>&gt; 	func addTarget&lt;T: NSObject&gt;(target: T?, action: @convention(selector) T -&gt; AnyObject -&gt; Void, forControlEvents: UIControlEvents)<br></p><p>Ok, just realized there&#39;s a problem here. This is a valid action method:<br></p><p>	func someAction(sender: UIButton)<br></p><p>It won&#39;t work with the above addTarget because it expects a UIButton instead of AnyObject. The signature should say &quot;Self&quot; in the selector type instead of AnyObject so that you can only pass it to addTarget if the control is a UIButton... But you can&#39;t use Self in this context, so it still doesn&#39;t work.<br></p><p>-- <br>Michel Fortin<br>michel.fortin at michelf.ca<br>https://michelf.ca<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
