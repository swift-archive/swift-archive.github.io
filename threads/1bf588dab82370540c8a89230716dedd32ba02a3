<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Type-annotated throws</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>August 26, 2016 at 08:00:00am</p></header><div class="content"><p>Hi all,<br></p><p>Currently, a function that throws is assumed to throw anything. There was a proposal draft last December to restrict that. The general idea was that you&#39;d write, for instance:<br></p><p>&gt; enum Foo: ErrorProtocol {<br>&gt;     case bar<br>&gt;     case baz<br>&gt; }<br>&gt; <br>&gt; func frob() throws Foo {<br>&gt;     throw Foo.bar // throw .bar?<br>&gt; }<br></p><p>If you `catch Foo` (or every case of Foo), now that the compiler can verify that your catch is exhaustive, you no longer have to have a catch-all block at the end of the sequence.<br></p><p>This impacts the metadata format and has implications on resilience, which leads me to believe that the discussion could qualify for the phase 1 of Swift 4. If this is the case, I&#39;d be interested in pulling out the old discussions and seeing where we left that at.<br></p><p>Félix<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160826/1bf502a3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e9b374b9587bd8da1a1a027c8716ac0d?s=50"></div><header><strong>Type-annotated throws</strong> from <string>Rod Brown</string> &lt;rodney.brown6 at icloud.com&gt;<p>August 27, 2016 at 01:00:00am</p></header><div class="content"><p>(resent for Swift Evolution)<br></p><p>I’m a big fan of this idea. Currently “throws” seems like a very limited API - you know it’s throwing out something, but you can only hope to guess what that is or create fallbacks. Definitely a big +1 from me. A fallback for compatibility could be “throws” assumes “throws Any” and can be a warning?<br></p><p>While I am not deeply familiar with the implications, I do like think your line of reasoning has merit, and think this makes sense for Phase 1 of Swift 4. <br></p><p>- Rod<br></p><p><br>&gt; On 27 Aug 2016, at 1:39 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi all,<br>&gt; <br>&gt; Currently, a function that throws is assumed to throw anything. There was a proposal draft last December to restrict that. The general idea was that you&#39;d write, for instance:<br>&gt; <br>&gt;&gt; enum Foo: ErrorProtocol {<br>&gt;&gt;     case bar<br>&gt;&gt;     case baz<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func frob() throws Foo {<br>&gt;&gt;     throw Foo.bar // throw .bar?<br>&gt;&gt; }<br>&gt; <br>&gt; If you `catch Foo` (or every case of Foo), now that the compiler can verify that your catch is exhaustive, you no longer have to have a catch-all block at the end of the sequence.<br>&gt; <br>&gt; This impacts the metadata format and has implications on resilience, which leads me to believe that the discussion could qualify for the phase 1 of Swift 4. If this is the case, I&#39;d be interested in pulling out the old discussions and seeing where we left that at.<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160827/4ba2fecd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0c6689d6389b72de39ed485a92217101?s=50"></div><header><strong>Type-annotated throws</strong> from <string>Nur Ismail</string> &lt;nur at estalea.com&gt;<p>August 26, 2016 at 06:00:00pm</p></header><div class="content"><p>Hi,<br></p><p>Sounds like checked exceptions of Java with a similar syntax. With Java you<br>have to specify the exceptions a method can throw. However been lots of<br>debate over the years whether it&#39;s a good thing or bad thing, some like it,<br>but I think many more hate it.<br>Most other languages don&#39;t have it, and possibly for good reason.<br></p><p>Regards,<br></p><p>On Fri, Aug 26, 2016 at 5:43 PM, Rod Brown via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; (resent for Swift Evolution)<br>&gt;<br>&gt; I’m a big fan of this idea. Currently “throws” seems like a very limited<br>&gt; API - you know it’s throwing out something, but you can only hope to guess<br>&gt; what that is or create fallbacks. Definitely a big +1 from me. A fallback<br>&gt; for compatibility could be “throws” assumes “throws Any” and can be a<br>&gt; warning?<br>&gt;<br>&gt; While I am not deeply familiar with the implications, I do like think your<br>&gt; line of reasoning has merit, and think this makes sense for Phase 1 of<br>&gt; Swift 4.<br>&gt;<br>&gt; - Rod<br>&gt;<br>&gt;<br>&gt; On 27 Aug 2016, at 1:39 AM, Félix Cloutier via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Hi all,<br>&gt;<br>&gt; Currently, a function that throws is assumed to throw anything. There was<br>&gt; a proposal draft last December to restrict that. The general idea was that<br>&gt; you&#39;d write, for instance:<br>&gt;<br>&gt; enum Foo: ErrorProtocol {<br>&gt;     case bar<br>&gt;     case baz<br>&gt; }<br>&gt;<br>&gt; func frob() throws Foo {<br>&gt;     throw Foo.bar // throw .bar?<br>&gt; }<br>&gt;<br>&gt;<br>&gt; If you `catch Foo` (or every case of Foo), now that the compiler can<br>&gt; verify that your catch is exhaustive, you no longer have to have a<br>&gt; catch-all block at the end of the sequence.<br>&gt;<br>&gt; This impacts the metadata format and has implications on resilience, which<br>&gt; leads me to believe that the discussion could qualify for the phase 1 of<br>&gt; Swift 4. If this is the case, I&#39;d be interested in pulling out the old<br>&gt; discussions and seeing where we left that at.<br>&gt;<br>&gt; Félix<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160826/c189d1be/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Type-annotated throws</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>August 26, 2016 at 05:00:00pm</p></header><div class="content"><p>I like checked exceptions in Java so I&#39;d be in support of this, as I feel it&#39;s a helpful feature to ensure that exceptions are properly handled.<br></p><p>I never really understood the complaints against it, as you&#39;re still free to just use a generic catch block for &quot;everything else&quot;, and we have things like try? and try! when you don&#39;t expect an exception and just want to keep things simple, so the situation is already easier than in Java.<br></p><p>I&#39;d say that there should still be generic &quot;could throw anything&quot; variant, like throws ErrorProtocol or such, but in most cases a well-defined error type (or several types?) is best, as developers should really think about what types of errors they produce and how someone might handle them when designing a method, and users of the method should be thinking about how they can recover from an error if it occurs, or fail in a more graceful/informative manner if they can&#39;t. Currently I don&#39;t think Swift&#39;s untyped throws achieve that.<br></p><p>&gt; On 26 Aug 2016, at 17:01, Nur Ismail via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi,<br>&gt; <br>&gt; Sounds like checked exceptions of Java with a similar syntax. With Java you have to specify the exceptions a method can throw. However been lots of debate over the years whether it&#39;s a good thing or bad thing, some like it, but I think many more hate it.<br>&gt; Most other languages don&#39;t have it, and possibly for good reason.<br>&gt; <br>&gt; Regards,<br>&gt; <br>&gt; On Fri, Aug 26, 2016 at 5:43 PM, Rod Brown via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; (resent for Swift Evolution)<br>&gt; <br>&gt; I’m a big fan of this idea. Currently “throws” seems like a very limited API - you know it’s throwing out something, but you can only hope to guess what that is or create fallbacks. Definitely a big +1 from me. A fallback for compatibility could be “throws” assumes “throws Any” and can be a warning?<br>&gt; <br>&gt; While I am not deeply familiar with the implications, I do like think your line of reasoning has merit, and think this makes sense for Phase 1 of Swift 4. <br>&gt; <br>&gt; - Rod<br>&gt; <br>&gt; <br>&gt;&gt; On 27 Aug 2016, at 1:39 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; Currently, a function that throws is assumed to throw anything. There was a proposal draft last December to restrict that. The general idea was that you&#39;d write, for instance:<br>&gt;&gt; <br>&gt;&gt;&gt; enum Foo: ErrorProtocol {<br>&gt;&gt;&gt;     case bar<br>&gt;&gt;&gt;     case baz<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func frob() throws Foo {<br>&gt;&gt;&gt;     throw Foo.bar // throw .bar?<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; If you `catch Foo` (or every case of Foo), now that the compiler can verify that your catch is exhaustive, you no longer have to have a catch-all block at the end of the sequence.<br>&gt;&gt; <br>&gt;&gt; This impacts the metadata format and has implications on resilience, which leads me to believe that the discussion could qualify for the phase 1 of Swift 4. If this is the case, I&#39;d be interested in pulling out the old discussions and seeing where we left that at.<br>&gt;&gt; <br>&gt;&gt; Félix<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160826/437977d0/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a6729e3608691552bd1c61373d0e5b08?s=50"></div><header><strong>Type-annotated throws</strong> from <string>Kevin Nattinger</string> &lt;swift at nattinger.net&gt;<p>August 26, 2016 at 09:00:00am</p></header><div class="content"><p>+1 from me.  I’m usually highly defensive about types, so the more the compiler can guarantee the better. <br></p><p>&gt; On Aug 26, 2016, at 9:01 AM, Nur Ismail via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi,<br>&gt; <br>&gt; Sounds like checked exceptions of Java with a similar syntax. With Java you have to specify the exceptions a method can throw. However been lots of debate over the years whether it&#39;s a good thing or bad thing, some like it, but I think many more hate it.<br></p><p>I’m pretty sure what people don’t like in Java is the enforced error handling or propagation and how much you have to nest to, e.g. set up IO, though I believe that has been mitigated somewhat by try-with-resources), not the specificity (and how it’s not obvious to many which throws need to be caught at compile time and which are RuntimeExceptions).  Though I don’t write much Java nowadays, I know I never liked all the boilerplate that required.<br></p><p>&gt; Most other languages don&#39;t have it, and possibly for good reason.<br></p><p>I’d love to hear those arguments against letting the compiler make more guarantees.<br></p><p>&gt; <br>&gt; Regards,<br>&gt; <br>&gt; On Fri, Aug 26, 2016 at 5:43 PM, Rod Brown via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; (resent for Swift Evolution)<br>&gt; <br>&gt; I’m a big fan of this idea. Currently “throws” seems like a very limited API - you know it’s throwing out something, but you can only hope to guess what that is or create fallbacks. Definitely a big +1 from me. A fallback for compatibility could be “throws” assumes “throws Any” and can be a warning?<br></p><p>I’d suggest a bare `throws` = `throws ErrorType` (you can only throw ErrorType, right?) and be valid, I don’t see any reason to make it a warning (plus that keeps source compatibility). <br></p><p>&gt; <br>&gt; While I am not deeply familiar with the implications, I do like think your line of reasoning has merit, and think this makes sense for Phase 1 of Swift 4. <br>&gt; <br>&gt; - Rod<br>&gt; <br>&gt; <br>&gt;&gt; On 27 Aug 2016, at 1:39 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; Currently, a function that throws is assumed to throw anything. There was a proposal draft last December to restrict that. The general idea was that you&#39;d write, for instance:<br>&gt;&gt; <br>&gt;&gt;&gt; enum Foo: ErrorProtocol {<br>&gt;&gt;&gt;     case bar<br>&gt;&gt;&gt;     case baz<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func frob() throws Foo {<br>&gt;&gt;&gt;     throw Foo.bar // throw .bar?<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; If you `catch Foo` (or every case of Foo), now that the compiler can verify that your catch is exhaustive, you no longer have to have a catch-all block at the end of the sequence.<br>&gt;&gt; <br>&gt;&gt; This impacts the metadata format and has implications on resilience, which leads me to believe that the discussion could qualify for the phase 1 of Swift 4. If this is the case, I&#39;d be interested in pulling out the old discussions and seeing where we left that at.<br>&gt;&gt; <br>&gt;&gt; Félix<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160826/8132ac7c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e9b374b9587bd8da1a1a027c8716ac0d?s=50"></div><header><strong>Type-annotated throws</strong> from <string>Rod Brown</string> &lt;rodney.brown6 at icloud.com&gt;<p>August 27, 2016 at 02:00:00am</p></header><div class="content"><p>&gt;&gt; <br>&gt;&gt; On Fri, Aug 26, 2016 at 5:43 PM, Rod Brown via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; (resent for Swift Evolution)<br>&gt;&gt; <br>&gt;&gt; I’m a big fan of this idea. Currently “throws” seems like a very limited API - you know it’s throwing out something, but you can only hope to guess what that is or create fallbacks. Definitely a big +1 from me. A fallback for compatibility could be “throws” assumes “throws Any” and can be a warning?<br>&gt; <br>&gt; I’d suggest a bare `throws` = `throws ErrorType` (you can only throw ErrorType, right?) and be valid, I don’t see any reason to make it a warning (plus that keeps source compatibility). <br></p><p><br>*hits head on desk*<br></p><p>How could I miss that?  `throws` = `throws ErrorType` makes perfect sense. It also means we can get some type safety, but it’s not lock in.<br></p><p>Thanks :)<br></p><p>-Rod<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160827/fa57b460/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Type-annotated throws</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 26, 2016 at 12:00:00pm</p></header><div class="content"><p>I think the core team has previously mentioned some positive notions about<br>typed throws, so it&#39;d be interesting to hear what they have in mind at this<br>point (or, more likely, at the point when they&#39;re no longer swamped with<br>getting Swift 3 out the door).<br></p><p><br>On Fri, Aug 26, 2016 at 11:55 AM, Rod Brown via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Fri, Aug 26, 2016 at 5:43 PM, Rod Brown via swift-evolution &lt;swift-<br>&gt; evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; (resent for Swift Evolution)<br>&gt;&gt;<br>&gt;&gt; I’m a big fan of this idea. Currently “throws” seems like a very limited<br>&gt;&gt; API - you know it’s throwing out something, but you can only hope to guess<br>&gt;&gt; what that is or create fallbacks. Definitely a big +1 from me. A fallback<br>&gt;&gt; for compatibility could be “throws” assumes “throws Any” and can be a<br>&gt;&gt; warning?<br>&gt;&gt;<br>&gt;<br>&gt; I’d suggest a bare `throws` = `throws ErrorType` (you can only throw<br>&gt; ErrorType, right?) and be valid, I don’t see any reason to make it a<br>&gt; warning (plus that keeps source compatibility).<br>&gt;<br>&gt;<br>&gt;<br>&gt; *hits head on desk*<br>&gt;<br>&gt; How could I miss that?  `throws` = `throws ErrorType` makes perfect sense.<br>&gt; It also means we can get some type safety, but it’s not lock in.<br>&gt;<br>&gt; Thanks :)<br>&gt;<br>&gt; -Rod<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160826/edb8c683/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>Type-annotated throws</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>August 26, 2016 at 08:00:00pm</p></header><div class="content"><p>Forwarding to more people:<br>This idea has already been discussed, and Chris Lattner specifically<br>mentioned that this proposal will be suitable for Swift 4 Phase 2. But<br>right now we shouldn&#39;t create a proposal for this.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160826/b0a3267f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Type-annotated throws</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>August 27, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Aug 26, 2016, at 10:22 AM, Anton Zhilin via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Forwarding to more people:<br>&gt; This idea has already been discussed, and Chris Lattner specifically mentioned that this proposal will be suitable for Swift 4 Phase 2. But right now we shouldn&#39;t create a proposal for this.<br></p><p>Right, this has come up many times before.  I’m personally in favor of it, I believe that John McCall has concerns about it.  In either case, it is out of scope for stage 1, because we need resilience to be figured out before we can consider this feature.<br></p><p>-Chris<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Type-annotated throws</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>August 26, 2016 at 11:00:00am</p></header><div class="content"><p>I believe the issue with checked exceptions in Java are multi-fold.<br></p><p>First, there are both checked and unchecked exceptions, which gives developers a way to avoid checked exceptions completely. RuntimeException is unchecked and meant to handle runtime detectable issues like math overflow or arrays indexed out of bounds, which would be too unwieldy for developers to have to catch explicitly - especially when they may “know” that an expression like &quot;1 + 1&quot; will not overflow. In Swift, many of these issues actually result in a fatal error.<br></p><p>RuntimeExceptions are also used extensively to work around cases where the appropriate checked exception is not defined on an interface or superclass. In these cases you cannot expand the list of checked exceptions declared, but you still want to throw on error. In this case, you wrap your desired exception in a RuntimeException, or just throw your hands up in the air and throw a RuntimeException with a string description. With such a large escape hatch from checked exceptions, the verbosity of doing things “the correct way” becomes a much more obvious burden.<br></p><p>Java does not have pattern matching in exceptions, with built-in support only for switching on class type of caught exception. However, many modules outside the very core of the language declare a single module-level exception, e.g. AWTException. This means there is an impedance mismatch - the declaration of exception types does not map well always to the appropriate recovery mechanism from the exception.<br></p><p>Having checked exceptions makes it more likely that interfaces will not be declared throwing, as the interface creator may not know the appropriate types of exceptions to be declared.<br></p><p>An interface expected to return an object might get the object from the network, filesystem,. or a database - resulting in three different families of possible exception types. This is usually worked around by having a module-level exception that is declared as the checked type, which can hold the actual exception which happened. Because the module-level exceptions do not differentiate classifications of issues, and the implementation of the interface does not have the actual kind of exception as part of the interface contract, you are limited in your ability to handle the exception in your code. It becomes commonplace to have a single “that thing you tried to do failed”, with a long stack trace to enable a developer or someone in a supporting role to diagnose which code was involved in the failure.<br></p><p><br></p><p>This gets to the root of the problem - since the focus is on documenting the class types of exceptions rather than categories of error states, the developer doesn’t feel any of the complexity or verbosity helps them make their code more robust. Instead of considering how to represent errors to your own callers for recovery, it becomes common to just declare the same list of checked exceptions and pass them through upstream unhanded - or to wrap them all in a module-level exception type to simplify the interface. The end result is that the exception mechanism is made more heavyweight via the checked mechanism, but still doesn’t enable developers to make their code more robust.<br></p><p>In the end, I believe the thing to emphasize is that developers of an API need to think of how the errors they raise would be handled by potential callers, and to represent *that* in their API. This might result in a specific error enumeration per method, which is O.K. In that case, declaring such a thrown error so that the error cases may be handled exhaustively is probably a good thing. A declaration which either does not allow exhaustive handling of error cases, or which allows someone to forward errors from multiple sources without thinking about their caller’s error needs are probably not productive.<br></p><p>-DW<br></p><p>&gt; On Aug 26, 2016, at 10:01 AM, Nur Ismail via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi,<br>&gt; <br>&gt; Sounds like checked exceptions of Java with a similar syntax. With Java you have to specify the exceptions a method can throw. However been lots of debate over the years whether it&#39;s a good thing or bad thing, some like it, but I think many more hate it.<br>&gt; Most other languages don&#39;t have it, and possibly for good reason.<br>&gt; <br>&gt; Regards,<br>&gt; <br>&gt; On Fri, Aug 26, 2016 at 5:43 PM, Rod Brown via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; (resent for Swift Evolution)<br>&gt; <br>&gt; I’m a big fan of this idea. Currently “throws” seems like a very limited API - you know it’s throwing out something, but you can only hope to guess what that is or create fallbacks. Definitely a big +1 from me. A fallback for compatibility could be “throws” assumes “throws Any” and can be a warning?<br>&gt; <br>&gt; While I am not deeply familiar with the implications, I do like think your line of reasoning has merit, and think this makes sense for Phase 1 of Swift 4. <br>&gt; <br>&gt; - Rod<br>&gt; <br>&gt; <br>&gt;&gt; On 27 Aug 2016, at 1:39 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; Currently, a function that throws is assumed to throw anything. There was a proposal draft last December to restrict that. The general idea was that you&#39;d write, for instance:<br>&gt;&gt; <br>&gt;&gt;&gt; enum Foo: ErrorProtocol {<br>&gt;&gt;&gt;     case bar<br>&gt;&gt;&gt;     case baz<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func frob() throws Foo {<br>&gt;&gt;&gt;     throw Foo.bar // throw .bar?<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; If you `catch Foo` (or every case of Foo), now that the compiler can verify that your catch is exhaustive, you no longer have to have a catch-all block at the end of the sequence.<br>&gt;&gt; <br>&gt;&gt; This impacts the metadata format and has implications on resilience, which leads me to believe that the discussion could qualify for the phase 1 of Swift 4. If this is the case, I&#39;d be interested in pulling out the old discussions and seeing where we left that at.<br>&gt;&gt; <br>&gt;&gt; Félix<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160826/12a04ee8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>Type-annotated throws</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>August 27, 2016 at 11:00:00am</p></header><div class="content"><p>@Anton: We still allowed to discuss it now. :) That won’t bother people that much.<br></p><p>Just a side note without reading all the stuff going on here.<br></p><p>As much as I would love to have some type safety error handling, I do believe it should be optional in first place.<br></p><p>Image some scenario like this:<br></p><p>func foo() throws AError {}<br>func boo() throws BError {}<br>func zoo() throws CError {}<br></p><p>// We also need some design to handle all errors at once:<br>func handle() rethrows AError &amp; BError &amp; CError -&gt; ReturnType {}<br></p><p>// As you can imagine the line might become really long and ugly looking<br>// Merging with existential syntax or typealias?<br>func handle() rethrows Any&lt;AError, BError, CError&gt; -&gt; ReturnType {}<br></p><p>typealias ABCError = AError &amp; BError &amp; CError<br></p><p>func handle() rethrows ABCError -&gt; ReturnType {}<br></p><p>// But sometime you don&#39;t really care which error type might be thrown and your API handles it with some other convention (docs?)<br>func handle() rethrows -&gt; ReturnType {<br>    try foo()<br>    try boo()<br>    try zoo()<br>    return ReturnType()<br>}<br>A mix of a type safe and the current error handling mechanism would be great, but not just the type safe (except we’ll get AnyError, where just re-/throws might be a shorthand form for re-/throws AnyError).<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160827/dd004236/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>Type-annotated throws</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>August 26, 2016 at 07:00:00pm</p></header><div class="content"><p>Felix, this idea has already been discussed, and Chris Lattner specifically<br>mentioned that it is planned for Swift 4 Phase 2. But right now we<br>shouldn&#39;t create a proposal for this.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160826/67b8e0f7/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Type-annotated throws</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>August 29, 2016 at 11:00:00am</p></header><div class="content"><p>I&#39;m quite skeptical here (Java has already been mentioned…), but if it&#39;s done, I&#39;d vote for removing ErrorType:<br>This empty protocol always felt a little bit odd to me, and when each function has information about what errors to expect, imho there is absolutely no benefit associated with conformance.<br>Even now, it&#39;s not that much — or does anyone actually consult a list of conforming types for error handling?<br></p><p>Tino<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>Type-annotated throws</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>August 29, 2016 at 03:00:00pm</p></header><div class="content"><p>+1 for removing Error protocol. Then it&#39;s a breaking change, and this<br>edition of the proposal can be reviewed for Stage 1.<br>Swift error model tries to be different (better) than of other languages.<br>We encourage not to rethrow, but to think of errors as of meaningful<br>results and process them accordingly, at all levels of abstraction.<br>Right now, the formal proposal can&#39;t be submitted, but discussion is fine.<br></p><p>2016-08-29 12:18 GMT+03:00 Tino Heth via swift-evolution &lt;<br>swift-evolution at swift.org&gt;:<br></p><p>&gt; I&#39;m quite skeptical here (Java has already been mentioned…), but if it&#39;s<br>&gt; done, I&#39;d vote for removing ErrorType:<br>&gt; This empty protocol always felt a little bit odd to me, and when each<br>&gt; function has information about what errors to expect, imho there is<br>&gt; absolutely no benefit associated with conformance.<br>&gt; Even now, it&#39;s not that much — or does anyone actually consult a list of<br>&gt; conforming types for error handling?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160829/274cb1d1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Type-annotated throws</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>August 29, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; Am 29.08.2016 um 14:21 schrieb Anton Zhilin &lt;antonyzhilin at gmail.com&gt;:<br>&gt; <br>&gt; +1 for removing Error protocol. Then it&#39;s a breaking change, and this edition of the proposal can be reviewed for Stage 1.<br>mhh… true, but I hope that is not your only motivation to support this change ;-) (I definitely don&#39;t want to see a flood of breaking changes that are only introduced to speed up the integration of proposals).<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160829/9259ba7c/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Type-annotated throws</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>August 29, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Aug 29, 2016, at 4:18 AM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;m quite skeptical here (Java has already been mentioned…), but if it&#39;s done, I&#39;d vote for removing ErrorType:<br>&gt; This empty protocol always felt a little bit odd to me, and when each function has information about what errors to expect, imho there is absolutely no benefit associated with conformance.<br>&gt; Even now, it&#39;s not that much — or does anyone actually consult a list of conforming types for error handling?<br>&gt; <br>&gt; Tino<br></p><p>Error is far from empty; it appears that way, but it contains default implementations to make bridging to and from Cocoa NSError objects much more convenient, especially since SE-0112. Plus, it’s a protocol rather than a base class, so conforming it doesn’t really constrain your design in any way.<br></p><p>-1 on removing Error.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160829/007b0dab/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>Type-annotated throws</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>September  1, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Aug 29, 2016, at 12:14 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Aug 29, 2016, at 4:18 AM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;m quite skeptical here (Java has already been mentioned…), but if it&#39;s done, I&#39;d vote for removing ErrorType:<br>&gt;&gt; This empty protocol always felt a little bit odd to me, and when each function has information about what errors to expect, imho there is absolutely no benefit associated with conformance.<br>&gt;&gt; Even now, it&#39;s not that much — or does anyone actually consult a list of conforming types for error handling?<br>&gt;&gt; <br>&gt;&gt; Tino<br>&gt; <br>&gt; Error is far from empty; it appears that way, but it contains default implementations to make bridging to and from Cocoa NSError objects much more convenient, especially since SE-0112. Plus, it’s a protocol rather than a base class, so conforming it doesn’t really constrain your design in any way.<br>&gt; <br>&gt; -1 on removing Error.<br></p><p>Given that SE-0112 bridges *all NSError values in Objective-C* to Error, removing Error is a non-starter.<br></p><p>	- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160901/6ff0e957/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Type-annotated throws</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>September  2, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; Am 02.09.2016 um 02:28 schrieb Douglas Gregor &lt;dgregor at apple.com&gt;:<br>&gt; <br>&gt; Given that SE-0112 bridges *all NSError values in Objective-C* to Error, removing Error is a non-starter.<br></p><p>I see my wording was to simple — instead of just &quot;removing ErrorType&quot;, I should have written &quot;… removing the restriction that thrown types have to conform to Error&quot; (I just noticed &quot;ErrorType&quot; is already scheduled for removal ;-).<br>Interoperability is an important aspect, but imho it shouldn&#39;t be enforced — in the future, there might be many Swift developers that don&#39;t care for Objective-C anymore; or is there anything special about Error besides the &quot;magic&quot; bridging to NSError?<br></p><p>&gt; Error is far from empty; it appears that way, but it contains default implementations<br>The protocols build on top of Error make absolutely sense to me, because they ensure features of conforming types.<br>Is there any reason to keep the methods of Error secret to Swift?<br>Imho it would feel much less arcane if you could ask an error for its NSError-properties (in a playground, for example, I guess I currently have to bridge to NSError manually to see its domain &amp; code).<br></p><p>&gt; Plus, it’s a protocol rather than a base class, so conforming it doesn’t really constrain your design in any way.<br>I never worried for constrained design; it&#39;s just that conforming to (empty) Error afaics has no benefit for pure Swift code with annotated throws.<br>Especially in the common case of error-enums, I realize the aspect of using &quot;: Error&quot; for documentation — but depending on the name of the type, this is redundant (&quot;enum NetworkError: Error&quot;…)<br></p><p>btw:<br>The proposal concentrates on error-enums, but I can throw a plain Int or String as well.<br>Is this just due to limitations of the language that can&#39;t enforce that a conforming type is an enum?<br></p><p>Tino<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160902/fdfcfdfe/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Type-annotated throws</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>August 29, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Aug 26, 2016, at 8:39 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi all,<br>&gt; <br>&gt; Currently, a function that throws is assumed to throw anything. There was a proposal draft last December to restrict that. The general idea was that you&#39;d write, for instance:<br>&gt; <br>&gt;&gt; enum Foo: ErrorProtocol {<br>&gt;&gt;     case bar<br>&gt;&gt;     case baz<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func frob() throws Foo {<br>&gt;&gt;     throw Foo.bar // throw .bar?<br>&gt;&gt; }<br>&gt; <br>&gt; If you `catch Foo` (or every case of Foo), now that the compiler can verify that your catch is exhaustive, you no longer have to have a catch-all block at the end of the sequence.<br>&gt; <br>&gt; This impacts the metadata format and has implications on resilience, which leads me to believe that the discussion could qualify for the phase 1 of Swift 4. If this is the case, I&#39;d be interested in pulling out the old discussions and seeing where we left that at.<br></p><p>Typed throws is largely additive, since an API that `throws` today can be compatibly changed to `throws T` in the future, so this isn&#39;t an absolute ABI issue.<br></p><p>-Joe<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>Type-annotated throws</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>August 29, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Aug 26, 2016, at 8:39 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi all,<br>&gt; <br>&gt; Currently, a function that throws is assumed to throw anything. There was a proposal draft last December to restrict that. The general idea was that you&#39;d write, for instance:<br>&gt; <br>&gt;&gt; enum Foo: ErrorProtocol {<br>&gt;&gt;     case bar<br>&gt;&gt;     case baz<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func frob() throws Foo {<br>&gt;&gt;     throw Foo.bar // throw .bar?<br>&gt;&gt; }<br>&gt; <br>&gt; If you `catch Foo` (or every case of Foo), now that the compiler can verify that your catch is exhaustive, you no longer have to have a catch-all block at the end of the sequence.<br></p><p>This contract is a lie in almost all real-world programs because real programs talk to the network, the filesystem, the database, etc and the class of errors that can be thrown is tremendous. The number of functions where “throws Foo” is an improvement and Foo is not an exhaustive list of “throws HTTPError, NetworkError, StorageError, DatabaseError, MachPortError, …” is close enough to zero to be considered zero. This ultimately leads to library authors merely wrapping exceptions using generic catch-all blocks anyway, adding no useful information.<br></p><p>There is zero value to adding it without the compiler enforcing it because you can only omit default catch blocks safely when you can be certain the list of exceptions is exhaustive.<br></p><p>I am sympathetic to the default/generic catch block problem but we could certainly solve that with some added syntax or automatic insertion of a rethrow if an error doesn’t match, meaning any function with a try{} and no default catch must itself be a throwing function.<br></p><p><br></p><p>Since this isn’t applicable to Swift 4 phase 1 I’ll hush now :)<br></p><p>Russ<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Type-annotated throws</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>August 29, 2016 at 11:00:00pm</p></header><div class="content"><p>I see two main use cases for throws right now:<br></p><p>for high-level operations that can fail for a lot of reasons<br>when it&#39;s convenient to bubble out of a complex, nested/recursive algorithm (like parsing a data structure)<br></p><p>Throws works well for case one, but it&#39;s not awesome for case two. I don&#39;t think that adding an optional type annotation to throws would hurt case one a lot, too.<br></p><p>Félix<br></p><p>&gt; Le 29 août 2016 à 21:13:51, Russ Bishop &lt;xenadu at gmail.com&gt; a écrit :<br>&gt; <br>&gt; <br>&gt;&gt; On Aug 26, 2016, at 8:39 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; Currently, a function that throws is assumed to throw anything. There was a proposal draft last December to restrict that. The general idea was that you&#39;d write, for instance:<br>&gt;&gt; <br>&gt;&gt;&gt; enum Foo: ErrorProtocol {<br>&gt;&gt;&gt;    case bar<br>&gt;&gt;&gt;    case baz<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func frob() throws Foo {<br>&gt;&gt;&gt;    throw Foo.bar // throw .bar?<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; If you `catch Foo` (or every case of Foo), now that the compiler can verify that your catch is exhaustive, you no longer have to have a catch-all block at the end of the sequence.<br>&gt; <br>&gt; This contract is a lie in almost all real-world programs because real programs talk to the network, the filesystem, the database, etc and the class of errors that can be thrown is tremendous. The number of functions where “throws Foo” is an improvement and Foo is not an exhaustive list of “throws HTTPError, NetworkError, StorageError, DatabaseError, MachPortError, …” is close enough to zero to be considered zero. This ultimately leads to library authors merely wrapping exceptions using generic catch-all blocks anyway, adding no useful information.<br>&gt; <br>&gt; There is zero value to adding it without the compiler enforcing it because you can only omit default catch blocks safely when you can be certain the list of exceptions is exhaustive.<br>&gt; <br>&gt; I am sympathetic to the default/generic catch block problem but we could certainly solve that with some added syntax or automatic insertion of a rethrow if an error doesn’t match, meaning any function with a try{} and no default catch must itself be a throwing function.<br>&gt; <br>&gt; <br>&gt; <br>&gt; Since this isn’t applicable to Swift 4 phase 1 I’ll hush now :)<br>&gt; <br>&gt; Russ<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160829/dfbab755/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
