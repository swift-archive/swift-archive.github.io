<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Optional comparison operators</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>July  7, 2016 at 02:00:00pm</p></header><div class="content"><p>These operators cause some potential for confusion:<br></p><p>    public func &lt;&lt;T : Comparable&gt;(lhs: T?, rhs: T?) -&gt; Bool<br>    public func &gt;&lt;T : Comparable&gt;(lhs: T?, rhs: T?) -&gt; Bool<br>    public func &lt;=&lt;T : Comparable&gt;(lhs: T?, rhs: T?) -&gt; Bool<br>    public func &gt;=&lt;T : Comparable&gt;(lhs: T?, rhs: T?) -&gt; Bool<br></p><p>1. The meaning of T? &lt; T? is not immediately obvious (Why is nil &lt; .some(x)<br>for any x? Personally, my intuition says that Optional should only provide<br>a partial order, with .none not being ordered w.r.t. .some(x).)<br></p><p>2. Even if the meaning is understood, it can be surprising when the (T?,<br>T?) -&gt; Bool version is used instead of (T, T) -&gt; Bool.<br></p><p>Prior discussion:<br>- http://thread.gmane.org/gmane.comp.lang.swift.devel/2089<br>- http://thread.gmane.org/gmane.comp.lang.swift.evolution/10095<br>- rdar://16966712&amp;22833869<br>- Replies to https://twitter.com/jtbandes/status/646914031433871364<br></p><p>In the swift-dev thread from May, Chris said:<br></p><p>One of the ideas that Joe Pamer has been discussing is whether the implicit<br>&gt;&gt; promotion from T to T? should be disabled when in an operator context.<br>&gt;&gt; Doing so would fix problems like this, but making the code invalid.<br>&gt;<br>&gt;<br>&gt;<br>A change like this would be source-breaking, so if the core team has<br>recommendations for how to handle these issues, now is probably the time to<br>get it done.<br></p><p>Jacob<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160707/a55813a4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Optional comparison operators</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>July 11, 2016 at 04:00:00pm</p></header><div class="content"><p>Bump for Swift 3.<br></p><p>On Thu, Jul 7, 2016 at 2:37 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>wrote:<br></p><p>&gt; These operators cause some potential for confusion:<br>&gt;<br>&gt;     public func &lt;&lt;T : Comparable&gt;(lhs: T?, rhs: T?) -&gt; Bool<br>&gt;     public func &gt;&lt;T : Comparable&gt;(lhs: T?, rhs: T?) -&gt; Bool<br>&gt;     public func &lt;=&lt;T : Comparable&gt;(lhs: T?, rhs: T?) -&gt; Bool<br>&gt;     public func &gt;=&lt;T : Comparable&gt;(lhs: T?, rhs: T?) -&gt; Bool<br>&gt;<br>&gt; 1. The meaning of T? &lt; T? is not immediately obvious (Why is nil &lt;<br>&gt; .some(x) for any x? Personally, my intuition says that Optional should only<br>&gt; provide a partial order, with .none not being ordered w.r.t. .some(x).)<br>&gt;<br>&gt; 2. Even if the meaning is understood, it can be surprising when the (T?,<br>&gt; T?) -&gt; Bool version is used instead of (T, T) -&gt; Bool.<br>&gt;<br>&gt; Prior discussion:<br>&gt; - http://thread.gmane.org/gmane.comp.lang.swift.devel/2089<br>&gt; - http://thread.gmane.org/gmane.comp.lang.swift.evolution/10095<br>&gt; - rdar://16966712&amp;22833869<br>&gt; - Replies to https://twitter.com/jtbandes/status/646914031433871364<br>&gt;<br>&gt; In the swift-dev thread from May, Chris said:<br>&gt;<br>&gt; One of the ideas that Joe Pamer has been discussing is whether the<br>&gt;&gt;&gt; implicit promotion from T to T? should be disabled when in an operator<br>&gt;&gt;&gt; context.  Doing so would fix problems like this, but making the code<br>&gt;&gt;&gt; invalid.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt; A change like this would be source-breaking, so if the core team has<br>&gt; recommendations for how to handle these issues, now is probably the time to<br>&gt; get it done.<br>&gt;<br>&gt; Jacob<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/e78ed070/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8e77369a540cf4d35924683e176c7a9c?s=50"></div><header><strong>Optional comparison operators</strong> from <string>Mark Lacey</string> &lt;mark.lacey at apple.com&gt;<p>July 11, 2016 at 04:00:00pm</p></header><div class="content"><p>Hi Jacob,<br></p><p>&gt; On Jul 11, 2016, at 4:23 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Bump for Swift 3.<br>&gt; <br>&gt; On Thu, Jul 7, 2016 at 2:37 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt; These operators cause some potential for confusion:<br>&gt; <br>&gt;     public func &lt;&lt;T : Comparable&gt;(lhs: T?, rhs: T?) -&gt; Bool<br>&gt;     public func &gt;&lt;T : Comparable&gt;(lhs: T?, rhs: T?) -&gt; Bool<br>&gt;     public func &lt;=&lt;T : Comparable&gt;(lhs: T?, rhs: T?) -&gt; Bool<br>&gt;     public func &gt;=&lt;T : Comparable&gt;(lhs: T?, rhs: T?) -&gt; Bool<br>&gt; <br>&gt; 1. The meaning of T? &lt; T? is not immediately obvious (Why is nil &lt; .some(x) for any x? Personally, my intuition says that Optional should only provide a partial order, with .none not being ordered w.r.t. .some(x).)<br>&gt; <br>&gt; 2. Even if the meaning is understood, it can be surprising when the (T?, T?) -&gt; Bool version is used instead of (T, T) -&gt; Bool.<br>&gt; <br>&gt; Prior discussion:<br>&gt; - http://thread.gmane.org/gmane.comp.lang.swift.devel/2089 &lt;http://thread.gmane.org/gmane.comp.lang.swift.devel/2089&gt;<br>&gt; - http://thread.gmane.org/gmane.comp.lang.swift.evolution/10095 &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/10095&gt;<br>&gt; - rdar://16966712&amp;22833869<br>&gt; - Replies to https://twitter.com/jtbandes/status/646914031433871364 &lt;https://twitter.com/jtbandes/status/646914031433871364&gt;<br>&gt; <br>&gt; In the swift-dev thread from May, Chris said:<br>&gt; <br>&gt; One of the ideas that Joe Pamer has been discussing is whether the implicit promotion from T to T? should be disabled when in an operator context.  Doing so would fix problems like this, but making the code invalid.<br>&gt; <br>&gt; <br>&gt; A change like this would be source-breaking, so if the core team has recommendations for how to handle these issues, now is probably the time to get it done.<br></p><p>I overlooked your previous message on this.<br></p><p>I’m actually writing up a proposal for this now, and have an implementation that I’ve done a bit of testing with.<br></p><p>I’m hoping to get the proposal out in the next couple days.<br></p><p>Mark<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/b45b5517/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Optional comparison operators</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>July 11, 2016 at 04:00:00pm</p></header><div class="content"><p>Great, thanks Mark! I look forward to it.<br></p><p>On Mon, Jul 11, 2016 at 4:31 PM, Mark Lacey &lt;mark.lacey at apple.com&gt; wrote:<br></p><p>&gt; Hi Jacob,<br>&gt;<br>&gt; On Jul 11, 2016, at 4:23 PM, Jacob Bandes-Storch via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Bump for Swift 3.<br>&gt;<br>&gt; On Thu, Jul 7, 2016 at 2:37 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; These operators cause some potential for confusion:<br>&gt;&gt;<br>&gt;&gt;     public func &lt;&lt;T : Comparable&gt;(lhs: T?, rhs: T?) -&gt; Bool<br>&gt;&gt;     public func &gt;&lt;T : Comparable&gt;(lhs: T?, rhs: T?) -&gt; Bool<br>&gt;&gt;     public func &lt;=&lt;T : Comparable&gt;(lhs: T?, rhs: T?) -&gt; Bool<br>&gt;&gt;     public func &gt;=&lt;T : Comparable&gt;(lhs: T?, rhs: T?) -&gt; Bool<br>&gt;&gt;<br>&gt;&gt; 1. The meaning of T? &lt; T? is not immediately obvious (Why is nil &lt;<br>&gt;&gt; .some(x) for any x? Personally, my intuition says that Optional should only<br>&gt;&gt; provide a partial order, with .none not being ordered w.r.t. .some(x).)<br>&gt;&gt;<br>&gt;&gt; 2. Even if the meaning is understood, it can be surprising when the (T?,<br>&gt;&gt; T?) -&gt; Bool version is used instead of (T, T) -&gt; Bool.<br>&gt;&gt;<br>&gt;&gt; Prior discussion:<br>&gt;&gt; - http://thread.gmane.org/gmane.comp.lang.swift.devel/2089<br>&gt;&gt; - http://thread.gmane.org/gmane.comp.lang.swift.evolution/10095<br>&gt;&gt; - rdar://16966712&amp;22833869<br>&gt;&gt; - Replies to https://twitter.com/jtbandes/status/646914031433871364<br>&gt;&gt;<br>&gt;&gt; In the swift-dev thread from May, Chris said:<br>&gt;&gt;<br>&gt;&gt; One of the ideas that Joe Pamer has been discussing is whether the<br>&gt;&gt;&gt;&gt; implicit promotion from T to T? should be disabled when in an operator<br>&gt;&gt;&gt;&gt; context.  Doing so would fix problems like this, but making the code<br>&gt;&gt;&gt;&gt; invalid.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt; A change like this would be source-breaking, so if the core team has<br>&gt;&gt; recommendations for how to handle these issues, now is probably the time to<br>&gt;&gt; get it done.<br>&gt;&gt;<br>&gt;<br>&gt; I overlooked your previous message on this.<br>&gt;<br>&gt; I’m actually writing up a proposal for this now, and have an<br>&gt; implementation that I’ve done a bit of testing with.<br>&gt;<br>&gt; I’m hoping to get the proposal out in the next couple days.<br>&gt;<br>&gt; Mark<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/1f5c74bb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8e77369a540cf4d35924683e176c7a9c?s=50"></div><header><strong>Optional comparison operators</strong> from <string>Mark Lacey</string> &lt;mark.lacey at apple.com&gt;<p>July 11, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jul 11, 2016, at 4:32 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt; <br>&gt; Great, thanks Mark! I look forward to it.<br></p><p>To be clear, I’m specifically looking at making the change to remove the coercion from T to T? for operator arguments.<br></p><p>I agree there might be other things worth looking at regarding operators that take optionals, but I’m not currently looking at those issues.<br></p><p>Mark<br></p><p>&gt; <br>&gt; On Mon, Jul 11, 2016 at 4:31 PM, Mark Lacey &lt;mark.lacey at apple.com &lt;mailto:mark.lacey at apple.com&gt;&gt; wrote:<br>&gt; Hi Jacob,<br>&gt; <br>&gt;&gt; On Jul 11, 2016, at 4:23 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Bump for Swift 3.<br>&gt;&gt; <br>&gt;&gt; On Thu, Jul 7, 2016 at 2:37 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt; These operators cause some potential for confusion:<br>&gt;&gt; <br>&gt;&gt;     public func &lt;&lt;T : Comparable&gt;(lhs: T?, rhs: T?) -&gt; Bool<br>&gt;&gt;     public func &gt;&lt;T : Comparable&gt;(lhs: T?, rhs: T?) -&gt; Bool<br>&gt;&gt;     public func &lt;=&lt;T : Comparable&gt;(lhs: T?, rhs: T?) -&gt; Bool<br>&gt;&gt;     public func &gt;=&lt;T : Comparable&gt;(lhs: T?, rhs: T?) -&gt; Bool<br>&gt;&gt; <br>&gt;&gt; 1. The meaning of T? &lt; T? is not immediately obvious (Why is nil &lt; .some(x) for any x? Personally, my intuition says that Optional should only provide a partial order, with .none not being ordered w.r.t. .some(x).)<br>&gt;&gt; <br>&gt;&gt; 2. Even if the meaning is understood, it can be surprising when the (T?, T?) -&gt; Bool version is used instead of (T, T) -&gt; Bool.<br>&gt;&gt; <br>&gt;&gt; Prior discussion:<br>&gt;&gt; - http://thread.gmane.org/gmane.comp.lang.swift.devel/2089 &lt;http://thread.gmane.org/gmane.comp.lang.swift.devel/2089&gt;<br>&gt;&gt; - http://thread.gmane.org/gmane.comp.lang.swift.evolution/10095 &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/10095&gt;<br>&gt;&gt; - rdar:// &lt;&gt;16966712&amp;22833869<br>&gt;&gt; - Replies to https://twitter.com/jtbandes/status/646914031433871364 &lt;https://twitter.com/jtbandes/status/646914031433871364&gt;<br>&gt;&gt; <br>&gt;&gt; In the swift-dev thread from May, Chris said:<br>&gt;&gt; <br>&gt;&gt; One of the ideas that Joe Pamer has been discussing is whether the implicit promotion from T to T? should be disabled when in an operator context.  Doing so would fix problems like this, but making the code invalid.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; A change like this would be source-breaking, so if the core team has recommendations for how to handle these issues, now is probably the time to get it done.<br>&gt; <br>&gt; I overlooked your previous message on this.<br>&gt; <br>&gt; I’m actually writing up a proposal for this now, and have an implementation that I’ve done a bit of testing with.<br>&gt; <br>&gt; I’m hoping to get the proposal out in the next couple days.<br>&gt; <br>&gt; Mark<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/a810f414/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Optional comparison operators</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>July 11, 2016 at 04:00:00pm</p></header><div class="content"><p>Personally I think we should just remove these optional-taking variants of<br>the comparison operators. Does anyone agree/disagree?<br></p><p>It does make sense to keep ==(T?, T?) and !=(T?, T?), and if coercion were<br>removed, we might want to add (T, T?) and (T?, T) versions. Are there any<br>other operators that would be affected by your proposal? If not, removing<br>the optional &lt;/&lt;=/&gt;/&gt;= would obviate the need to remove coercion.<br></p><p>Jacob<br></p><p>On Mon, Jul 11, 2016 at 4:45 PM, Mark Lacey &lt;mark.lacey at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Jul 11, 2016, at 4:32 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; Great, thanks Mark! I look forward to it.<br>&gt;<br>&gt;<br>&gt; To be clear, I’m specifically looking at making the change to remove the<br>&gt; coercion from T to T? for operator arguments.<br>&gt;<br>&gt; I agree there might be other things worth looking at regarding operators<br>&gt; that take optionals, but I’m not currently looking at those issues.<br>&gt;<br>&gt; Mark<br>&gt;<br>&gt;<br>&gt; On Mon, Jul 11, 2016 at 4:31 PM, Mark Lacey &lt;mark.lacey at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt; Hi Jacob,<br>&gt;&gt;<br>&gt;&gt; On Jul 11, 2016, at 4:23 PM, Jacob Bandes-Storch via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Bump for Swift 3.<br>&gt;&gt;<br>&gt;&gt; On Thu, Jul 7, 2016 at 2:37 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; These operators cause some potential for confusion:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     public func &lt;&lt;T : Comparable&gt;(lhs: T?, rhs: T?) -&gt; Bool<br>&gt;&gt;&gt;     public func &gt;&lt;T : Comparable&gt;(lhs: T?, rhs: T?) -&gt; Bool<br>&gt;&gt;&gt;     public func &lt;=&lt;T : Comparable&gt;(lhs: T?, rhs: T?) -&gt; Bool<br>&gt;&gt;&gt;     public func &gt;=&lt;T : Comparable&gt;(lhs: T?, rhs: T?) -&gt; Bool<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 1. The meaning of T? &lt; T? is not immediately obvious (Why is nil &lt;<br>&gt;&gt;&gt; .some(x) for any x? Personally, my intuition says that Optional should only<br>&gt;&gt;&gt; provide a partial order, with .none not being ordered w.r.t. .some(x).)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 2. Even if the meaning is understood, it can be surprising when the (T?,<br>&gt;&gt;&gt; T?) -&gt; Bool version is used instead of (T, T) -&gt; Bool.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Prior discussion:<br>&gt;&gt;&gt; - http://thread.gmane.org/gmane.comp.lang.swift.devel/2089<br>&gt;&gt;&gt; - http://thread.gmane.org/gmane.comp.lang.swift.evolution/10095<br>&gt;&gt;&gt; - rdar://16966712&amp;22833869<br>&gt;&gt;&gt; - Replies to https://twitter.com/jtbandes/status/646914031433871364<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In the swift-dev thread from May, Chris said:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; One of the ideas that Joe Pamer has been discussing is whether the<br>&gt;&gt;&gt;&gt;&gt; implicit promotion from T to T? should be disabled when in an operator<br>&gt;&gt;&gt;&gt;&gt; context.  Doing so would fix problems like this, but making the code<br>&gt;&gt;&gt;&gt;&gt; invalid.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; A change like this would be source-breaking, so if the core team has<br>&gt;&gt;&gt; recommendations for how to handle these issues, now is probably the time to<br>&gt;&gt;&gt; get it done.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I overlooked your previous message on this.<br>&gt;&gt;<br>&gt;&gt; I’m actually writing up a proposal for this now, and have an<br>&gt;&gt; implementation that I’ve done a bit of testing with.<br>&gt;&gt;<br>&gt;&gt; I’m hoping to get the proposal out in the next couple days.<br>&gt;&gt;<br>&gt;&gt; Mark<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/505d6fe9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Optional comparison operators</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 11, 2016 at 11:00:00pm</p></header><div class="content"><p>Yup, I too would prefer removing the functions over removing coercion.<br></p><p>On Mon, Jul 11, 2016 at 18:57 Jacob Bandes-Storch via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Personally I think we should just remove these optional-taking variants of<br>&gt; the comparison operators. Does anyone agree/disagree?<br>&gt;<br>&gt; It does make sense to keep ==(T?, T?) and !=(T?, T?), and if coercion were<br>&gt; removed, we might want to add (T, T?) and (T?, T) versions. Are there any<br>&gt; other operators that would be affected by your proposal? If not, removing<br>&gt; the optional &lt;/&lt;=/&gt;/&gt;= would obviate the need to remove coercion.<br>&gt;<br>&gt; Jacob<br>&gt;<br>&gt; On Mon, Jul 11, 2016 at 4:45 PM, Mark Lacey &lt;mark.lacey at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Jul 11, 2016, at 4:32 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Great, thanks Mark! I look forward to it.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; To be clear, I’m specifically looking at making the change to remove the<br>&gt;&gt; coercion from T to T? for operator arguments.<br>&gt;&gt;<br>&gt;&gt; I agree there might be other things worth looking at regarding operators<br>&gt;&gt; that take optionals, but I’m not currently looking at those issues.<br>&gt;&gt;<br>&gt;&gt; Mark<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Mon, Jul 11, 2016 at 4:31 PM, Mark Lacey &lt;mark.lacey at apple.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Hi Jacob,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Jul 11, 2016, at 4:23 PM, Jacob Bandes-Storch via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Bump for Swift 3.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Thu, Jul 7, 2016 at 2:37 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; These operators cause some potential for confusion:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     public func &lt;&lt;T : Comparable&gt;(lhs: T?, rhs: T?) -&gt; Bool<br>&gt;&gt;&gt;&gt;     public func &gt;&lt;T : Comparable&gt;(lhs: T?, rhs: T?) -&gt; Bool<br>&gt;&gt;&gt;&gt;     public func &lt;=&lt;T : Comparable&gt;(lhs: T?, rhs: T?) -&gt; Bool<br>&gt;&gt;&gt;&gt;     public func &gt;=&lt;T : Comparable&gt;(lhs: T?, rhs: T?) -&gt; Bool<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; 1. The meaning of T? &lt; T? is not immediately obvious (Why is nil &lt;<br>&gt;&gt;&gt;&gt; .some(x) for any x? Personally, my intuition says that Optional should only<br>&gt;&gt;&gt;&gt; provide a partial order, with .none not being ordered w.r.t. .some(x).)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; 2. Even if the meaning is understood, it can be surprising when the<br>&gt;&gt;&gt;&gt; (T?, T?) -&gt; Bool version is used instead of (T, T) -&gt; Bool.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Prior discussion:<br>&gt;&gt;&gt;&gt; - http://thread.gmane.org/gmane.comp.lang.swift.devel/2089<br>&gt;&gt;&gt;&gt; - http://thread.gmane.org/gmane.comp.lang.swift.evolution/10095<br>&gt;&gt;&gt;&gt; - rdar://16966712&amp;22833869<br>&gt;&gt;&gt;&gt; - Replies to https://twitter.com/jtbandes/status/646914031433871364<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; In the swift-dev thread from May, Chris said:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; One of the ideas that Joe Pamer has been discussing is whether the<br>&gt;&gt;&gt;&gt;&gt;&gt; implicit promotion from T to T? should be disabled when in an operator<br>&gt;&gt;&gt;&gt;&gt;&gt; context.  Doing so would fix problems like this, but making the code<br>&gt;&gt;&gt;&gt;&gt;&gt; invalid.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; A change like this would be source-breaking, so if the core team has<br>&gt;&gt;&gt;&gt; recommendations for how to handle these issues, now is probably the time to<br>&gt;&gt;&gt;&gt; get it done.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I overlooked your previous message on this.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I’m actually writing up a proposal for this now, and have an<br>&gt;&gt;&gt; implementation that I’ve done a bit of testing with.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I’m hoping to get the proposal out in the next couple days.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Mark<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/a004f6e1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8e77369a540cf4d35924683e176c7a9c?s=50"></div><header><strong>Optional comparison operators</strong> from <string>Mark Lacey</string> &lt;mark.lacey at apple.com&gt;<p>July 11, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jul 11, 2016, at 4:59 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; Yup, I too would prefer removing the functions over removing coercion.<br></p><p>Hi Xiaodi,<br></p><p>Is there a reason you think the coercion is important to keep?<br></p><p>I see these as somewhat orthogonal issues (allowing or disallowing coercion vs. keeping or removing certain operators that take optionals or for that matter changing the defined behavior in the case of nil operands mixed with non-nil operands).<br></p><p>Mark<br></p><p>&gt; <br>&gt; On Mon, Jul 11, 2016 at 18:57 Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Personally I think we should just remove these optional-taking variants of the comparison operators. Does anyone agree/disagree?<br>&gt; <br>&gt; It does make sense to keep ==(T?, T?) and !=(T?, T?), and if coercion were removed, we might want to add (T, T?) and (T?, T) versions. Are there any other operators that would be affected by your proposal? If not, removing the optional &lt;/&lt;=/&gt;/&gt;= would obviate the need to remove coercion.<br>&gt; <br>&gt; Jacob<br>&gt; <br>&gt; On Mon, Jul 11, 2016 at 4:45 PM, Mark Lacey &lt;mark.lacey at apple.com &lt;mailto:mark.lacey at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Jul 11, 2016, at 4:32 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Great, thanks Mark! I look forward to it.<br>&gt; <br>&gt; To be clear, I’m specifically looking at making the change to remove the coercion from T to T? for operator arguments.<br>&gt; <br>&gt; I agree there might be other things worth looking at regarding operators that take optionals, but I’m not currently looking at those issues.<br>&gt; <br>&gt; Mark<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Mon, Jul 11, 2016 at 4:31 PM, Mark Lacey &lt;mark.lacey at apple.com &lt;mailto:mark.lacey at apple.com&gt;&gt; wrote:<br>&gt;&gt; Hi Jacob,<br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 11, 2016, at 4:23 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Bump for Swift 3.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Thu, Jul 7, 2016 at 2:37 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; These operators cause some potential for confusion:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     public func &lt;&lt;T : Comparable&gt;(lhs: T?, rhs: T?) -&gt; Bool<br>&gt;&gt;&gt;     public func &gt;&lt;T : Comparable&gt;(lhs: T?, rhs: T?) -&gt; Bool<br>&gt;&gt;&gt;     public func &lt;=&lt;T : Comparable&gt;(lhs: T?, rhs: T?) -&gt; Bool<br>&gt;&gt;&gt;     public func &gt;=&lt;T : Comparable&gt;(lhs: T?, rhs: T?) -&gt; Bool<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. The meaning of T? &lt; T? is not immediately obvious (Why is nil &lt; .some(x) for any x? Personally, my intuition says that Optional should only provide a partial order, with .none not being ordered w.r.t. .some(x).)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2. Even if the meaning is understood, it can be surprising when the (T?, T?) -&gt; Bool version is used instead of (T, T) -&gt; Bool.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Prior discussion:<br>&gt;&gt;&gt; - http://thread.gmane.org/gmane.comp.lang.swift.devel/2089 &lt;http://thread.gmane.org/gmane.comp.lang.swift.devel/2089&gt;<br>&gt;&gt;&gt; - http://thread.gmane.org/gmane.comp.lang.swift.evolution/10095 &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/10095&gt;<br>&gt;&gt;&gt; - rdar:// &lt;&gt;16966712&amp;22833869<br>&gt;&gt;&gt; - Replies to https://twitter.com/jtbandes/status/646914031433871364 &lt;https://twitter.com/jtbandes/status/646914031433871364&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In the swift-dev thread from May, Chris said:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One of the ideas that Joe Pamer has been discussing is whether the implicit promotion from T to T? should be disabled when in an operator context.  Doing so would fix problems like this, but making the code invalid.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A change like this would be source-breaking, so if the core team has recommendations for how to handle these issues, now is probably the time to get it done.<br>&gt;&gt; <br>&gt;&gt; I overlooked your previous message on this.<br>&gt;&gt; <br>&gt;&gt; I’m actually writing up a proposal for this now, and have an implementation that I’ve done a bit of testing with.<br>&gt;&gt; <br>&gt;&gt; I’m hoping to get the proposal out in the next couple days.<br>&gt;&gt; <br>&gt;&gt; Mark<br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/1abc750b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Optional comparison operators</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>July 11, 2016 at 05:00:00pm</p></header><div class="content"><p>On Mon, Jul 11, 2016 at 5:32 PM, Mark Lacey &lt;mark.lacey at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Jul 11, 2016, at 4:59 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; Yup, I too would prefer removing the functions over removing coercion.<br>&gt;<br>&gt;<br>&gt; Hi Xiaodi,<br>&gt;<br>&gt; Is there a reason you think the coercion is important to keep?<br>&gt;<br>&gt; I see these as somewhat orthogonal issues (allowing or disallowing<br>&gt; coercion vs. keeping or removing certain operators that take optionals or<br>&gt; for that matter changing the defined behavior in the case of nil operands<br>&gt; mixed with non-nil operands).<br>&gt;<br></p><p>Hypothetically, if the &lt;/&lt;=/&gt;/&gt;= operators taking optionals were removed,<br>coercion would still be useful for ==(T?, T?) and !=(T?, T?).<br></p><p>But, you make a good point about ?? — it probably shouldn&#39;t be allowed to<br>pass a non-optional value on the left-hand side. That&#39;s enough evidence for<br>me to support removing coercion regardless of what happens to these<br>comparison operators.<br></p><p><br>&gt;<br>&gt; Mark<br>&gt;<br>&gt;<br>&gt; On Mon, Jul 11, 2016 at 18:57 Jacob Bandes-Storch via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Personally I think we should just remove these optional-taking variants<br>&gt;&gt; of the comparison operators. Does anyone agree/disagree?<br>&gt;&gt;<br>&gt;&gt; It does make sense to keep ==(T?, T?) and !=(T?, T?), and if coercion<br>&gt;&gt; were removed, we might want to add (T, T?) and (T?, T) versions. Are there<br>&gt;&gt; any other operators that would be affected by your proposal? If not,<br>&gt;&gt; removing the optional &lt;/&lt;=/&gt;/&gt;= would obviate the need to remove coercion.<br>&gt;&gt;<br>&gt;&gt; Jacob<br>&gt;&gt;<br>&gt;&gt; On Mon, Jul 11, 2016 at 4:45 PM, Mark Lacey &lt;mark.lacey at apple.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Jul 11, 2016, at 4:32 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Great, thanks Mark! I look forward to it.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; To be clear, I’m specifically looking at making the change to remove the<br>&gt;&gt;&gt; coercion from T to T? for operator arguments.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I agree there might be other things worth looking at regarding operators<br>&gt;&gt;&gt; that take optionals, but I’m not currently looking at those issues.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Mark<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Mon, Jul 11, 2016 at 4:31 PM, Mark Lacey &lt;mark.lacey at apple.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Hi Jacob,<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Jul 11, 2016, at 4:23 PM, Jacob Bandes-Storch via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Bump for Swift 3.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Thu, Jul 7, 2016 at 2:37 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com<br>&gt;&gt;&gt;&gt; &gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; These operators cause some potential for confusion:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;     public func &lt;&lt;T : Comparable&gt;(lhs: T?, rhs: T?) -&gt; Bool<br>&gt;&gt;&gt;&gt;&gt;     public func &gt;&lt;T : Comparable&gt;(lhs: T?, rhs: T?) -&gt; Bool<br>&gt;&gt;&gt;&gt;&gt;     public func &lt;=&lt;T : Comparable&gt;(lhs: T?, rhs: T?) -&gt; Bool<br>&gt;&gt;&gt;&gt;&gt;     public func &gt;=&lt;T : Comparable&gt;(lhs: T?, rhs: T?) -&gt; Bool<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; 1. The meaning of T? &lt; T? is not immediately obvious (Why is nil &lt;<br>&gt;&gt;&gt;&gt;&gt; .some(x) for any x? Personally, my intuition says that Optional should only<br>&gt;&gt;&gt;&gt;&gt; provide a partial order, with .none not being ordered w.r.t. .some(x).)<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; 2. Even if the meaning is understood, it can be surprising when the<br>&gt;&gt;&gt;&gt;&gt; (T?, T?) -&gt; Bool version is used instead of (T, T) -&gt; Bool.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Prior discussion:<br>&gt;&gt;&gt;&gt;&gt; - http://thread.gmane.org/gmane.comp.lang.swift.devel/2089<br>&gt;&gt;&gt;&gt;&gt; - http://thread.gmane.org/gmane.comp.lang.swift.evolution/10095<br>&gt;&gt;&gt;&gt;&gt; - rdar://16966712&amp;22833869<br>&gt;&gt;&gt;&gt;&gt; - Replies to https://twitter.com/jtbandes/status/646914031433871364<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; In the swift-dev thread from May, Chris said:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; One of the ideas that Joe Pamer has been discussing is whether the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; implicit promotion from T to T? should be disabled when in an operator<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; context.  Doing so would fix problems like this, but making the code<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; invalid.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; A change like this would be source-breaking, so if the core team has<br>&gt;&gt;&gt;&gt;&gt; recommendations for how to handle these issues, now is probably the time to<br>&gt;&gt;&gt;&gt;&gt; get it done.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I overlooked your previous message on this.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I’m actually writing up a proposal for this now, and have an<br>&gt;&gt;&gt;&gt; implementation that I’ve done a bit of testing with.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I’m hoping to get the proposal out in the next couple days.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Mark<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/c459899b/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8e77369a540cf4d35924683e176c7a9c?s=50"></div><header><strong>Optional comparison operators</strong> from <string>Mark Lacey</string> &lt;mark.lacey at apple.com&gt;<p>July 11, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jul 11, 2016, at 4:56 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt; <br>&gt; Personally I think we should just remove these optional-taking variants of the comparison operators. Does anyone agree/disagree?<br></p><p>I believe that a well-defined ordering of optionals and non-optionals is required in order to allow sorting an array of optionals.<br></p><p>You can argue about how useful this is, but it seems like it would be important to support this for generic algorithms.<br></p><p>Having said that, it also seems entirely reasonable (and safer) to disallow comparison of an optional with a non-optional value when done explicitly in code (e.g. x &lt; y where one is a known optional), and require an explicit cast of the other operand to an optional in order to allow this to compile.<br></p><p>&gt; It does make sense to keep ==(T?, T?) and !=(T?, T?), and if coercion were removed, we might want to add (T, T?) and (T?, T) versions. Are there any other operators that would be affected by your proposal? If not, removing the optional &lt;/&lt;=/&gt;/&gt;= would obviate the need to remove coercion.<br></p><p>I haven’t attempted to enumerate all affected operators. One that I’ve run into with very strange behavior today is ?? which currently accepts non-optional values on the left-hand side due coercion, so e.g.:<br>  print(0 ?? 1)<br>will silently compile and print ‘0’ today.<br></p><p>Mark<br></p><p>&gt; <br>&gt; Jacob<br>&gt; <br>&gt; On Mon, Jul 11, 2016 at 4:45 PM, Mark Lacey &lt;mark.lacey at apple.com &lt;mailto:mark.lacey at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Jul 11, 2016, at 4:32 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Great, thanks Mark! I look forward to it.<br>&gt; <br>&gt; To be clear, I’m specifically looking at making the change to remove the coercion from T to T? for operator arguments.<br>&gt; <br>&gt; I agree there might be other things worth looking at regarding operators that take optionals, but I’m not currently looking at those issues.<br>&gt; <br>&gt; Mark<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Mon, Jul 11, 2016 at 4:31 PM, Mark Lacey &lt;mark.lacey at apple.com &lt;mailto:mark.lacey at apple.com&gt;&gt; wrote:<br>&gt;&gt; Hi Jacob,<br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 11, 2016, at 4:23 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Bump for Swift 3.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Thu, Jul 7, 2016 at 2:37 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; These operators cause some potential for confusion:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     public func &lt;&lt;T : Comparable&gt;(lhs: T?, rhs: T?) -&gt; Bool<br>&gt;&gt;&gt;     public func &gt;&lt;T : Comparable&gt;(lhs: T?, rhs: T?) -&gt; Bool<br>&gt;&gt;&gt;     public func &lt;=&lt;T : Comparable&gt;(lhs: T?, rhs: T?) -&gt; Bool<br>&gt;&gt;&gt;     public func &gt;=&lt;T : Comparable&gt;(lhs: T?, rhs: T?) -&gt; Bool<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. The meaning of T? &lt; T? is not immediately obvious (Why is nil &lt; .some(x) for any x? Personally, my intuition says that Optional should only provide a partial order, with .none not being ordered w.r.t. .some(x).)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2. Even if the meaning is understood, it can be surprising when the (T?, T?) -&gt; Bool version is used instead of (T, T) -&gt; Bool.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Prior discussion:<br>&gt;&gt;&gt; - http://thread.gmane.org/gmane.comp.lang.swift.devel/2089 &lt;http://thread.gmane.org/gmane.comp.lang.swift.devel/2089&gt;<br>&gt;&gt;&gt; - http://thread.gmane.org/gmane.comp.lang.swift.evolution/10095 &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/10095&gt;<br>&gt;&gt;&gt; - rdar:// &lt;&gt;16966712&amp;22833869<br>&gt;&gt;&gt; - Replies to https://twitter.com/jtbandes/status/646914031433871364 &lt;https://twitter.com/jtbandes/status/646914031433871364&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In the swift-dev thread from May, Chris said:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One of the ideas that Joe Pamer has been discussing is whether the implicit promotion from T to T? should be disabled when in an operator context.  Doing so would fix problems like this, but making the code invalid.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A change like this would be source-breaking, so if the core team has recommendations for how to handle these issues, now is probably the time to get it done.<br>&gt;&gt; <br>&gt;&gt; I overlooked your previous message on this.<br>&gt;&gt; <br>&gt;&gt; I’m actually writing up a proposal for this now, and have an implementation that I’ve done a bit of testing with.<br>&gt;&gt; <br>&gt;&gt; I’m hoping to get the proposal out in the next couple days.<br>&gt;&gt; <br>&gt;&gt; Mark<br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/b9dceafe/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Optional comparison operators</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>July 11, 2016 at 05:00:00pm</p></header><div class="content"><p>On Mon, Jul 11, 2016 at 5:29 PM, Mark Lacey &lt;mark.lacey at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Jul 11, 2016, at 4:56 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; Personally I think we should just remove these optional-taking variants of<br>&gt; the comparison operators. Does anyone agree/disagree?<br>&gt;<br>&gt;<br>&gt; I believe that a well-defined ordering of optionals and non-optionals is<br>&gt; required in order to allow sorting an array of optionals.<br>&gt;<br>&gt; You can argue about how useful this is, but it seems like it would be<br>&gt; important to support this for generic algorithms.<br>&gt;<br></p><p>I&#39;d be curious whether anyone can come up with a good example of why this<br>would be useful. Optional itself isn&#39;t Comparable (the generics features<br>required for that don&#39;t exist yet), so I don&#39;t think there&#39;s any way to use<br>this in generic code without explicitly handling the values as being<br>Optional, and so you might as well be required to unwrap them.<br></p><p><br>&gt; Having said that, it also seems entirely reasonable (and safer) to<br>&gt; disallow comparison of an optional with a non-optional value when done<br>&gt; explicitly in code (e.g. x &lt; y where one is a known optional), and require<br>&gt; an explicit cast of the other operand to an optional in order to allow this<br>&gt; to compile.<br>&gt;<br></p><p>Just to re-iterate my above paragraph (trying to convince myself), I think<br>that today the operands are *always* &quot;known optional&quot; or &quot;known<br>non-optional&quot;, so there isn&#39;t really a way to distinguish between these<br>cases.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/befe3219/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Optional comparison operators</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>July 11, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jul 11, 2016, at 5:29 PM, Mark Lacey via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 11, 2016, at 4:56 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Personally I think we should just remove these optional-taking variants of the comparison operators. Does anyone agree/disagree?<br>&gt; <br>&gt; I believe that a well-defined ordering of optionals and non-optionals is required in order to allow sorting an array of optionals.<br></p><p>Yes, I agree that this should work in principle.  The problem with this argument (in Swift 3) is that Optional itself can’t conform to comparable, because that requires conditional conformances.  You have to use the closure-taking form of sort, at which point, using a more verbose way to compare the optional isn’t completely terrible.<br></p><p>-Chris<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/7ad46a6d/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Optional comparison operators</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>July 11, 2016 at 05:00:00pm</p></header><div class="content"><p>On Jul 11, 2016, at 4:56 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Personally I think we should just remove these optional-taking variants of the comparison operators. Does anyone agree/disagree?<br>&gt; <br>&gt; It does make sense to keep ==(T?, T?) and !=(T?, T?), and if coercion were removed, we might want to add (T, T?) and (T?, T) versions. Are there any other operators that would be affected by your proposal? If not, removing the optional &lt;/&lt;=/&gt;/&gt;= would obviate the need to remove coercion.<br></p><p>My opinion:<br> - We need to remove T -&gt; T? promotion from operators for a whole lot of reasons.  People are frequently surprised by the behavior of the ?? operator promoting the LHS to optional, for example.  There are a ton of “bugs” that people file that are related to issues like that.<br> - We don’t have conditional conformances, so Optional cannot conditionally conform to Equatable and Comparable in Swift 3.  In a later release, we can consider whether adding them is a good idea.<br> - We currently support equatable comparing an arbitrary optional to nil (one in which T is not necessarily Equatable), which I think is useful to keep around.<br> - If we allow that, then it makes sense to allow == and != operators for optionals where T is Equatable, even though the optional itself cannot conditionally conform to Equatable.  The “surprising” aspect of equatable comparison doing promotions will have been removed.<br></p><p>The questionable piece is what to do with &lt;/&lt;=/&gt;/&gt;=.  I would lean towards removing them in Swift 3 simply because it is easier to &quot;remove now, but add them back later&quot; if they really are important.  The argument for keeping them is that the surprising aspect will be solved by removing the first promotion - &quot;42 &gt; nil” will cease to type-check, so they may not actually be harmful anymore.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Optional comparison operators</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>July 11, 2016 at 06:00:00pm</p></header><div class="content"><p>On Mon, Jul 11, 2016 at 5:58 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br></p><p>&gt; On Jul 11, 2016, at 4:56 PM, Jacob Bandes-Storch via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; Personally I think we should just remove these optional-taking variants<br>&gt; of the comparison operators. Does anyone agree/disagree?<br>&gt; &gt;<br>&gt; &gt; It does make sense to keep ==(T?, T?) and !=(T?, T?), and if coercion<br>&gt; were removed, we might want to add (T, T?) and (T?, T) versions. Are there<br>&gt; any other operators that would be affected by your proposal? If not,<br>&gt; removing the optional &lt;/&lt;=/&gt;/&gt;= would obviate the need to remove coercion.<br>&gt;<br>&gt; My opinion:<br>&gt;  - We need to remove T -&gt; T? promotion from operators for a whole lot of<br>&gt; reasons.  People are frequently surprised by the behavior of the ??<br>&gt; operator promoting the LHS to optional, for example.  There are a ton of<br>&gt; “bugs” that people file that are related to issues like that.<br>&gt;<br></p><p>Thinking about this a bit more, couldn&#39;t the same class of &quot;gotcha&quot; happen<br>with regular functions, too? Why should this be changed for operators<br>specifically?<br></p><p>Maybe it makes more sense to have some kind of &quot;@noncoercing&quot; parameter, so<br>that coercion can still take place, but operator could be defined as `func<br>??&lt;T&gt;(lhs: @noncoercing T?, rhs: T?)`<br></p><p><br>&gt;  - We don’t have conditional conformances, so Optional cannot<br>&gt; conditionally conform to Equatable and Comparable in Swift 3.  In a later<br>&gt; release, we can consider whether adding them is a good idea.<br>&gt;  - We currently support equatable comparing an arbitrary optional to nil<br>&gt; (one in which T is not necessarily Equatable), which I think is useful to<br>&gt; keep around.<br>&gt;  - If we allow that, then it makes sense to allow == and != operators for<br>&gt; optionals where T is Equatable, even though the optional itself cannot<br>&gt; conditionally conform to Equatable.  The “surprising” aspect of equatable<br>&gt; comparison doing promotions will have been removed.<br>&gt;<br>&gt; The questionable piece is what to do with &lt;/&lt;=/&gt;/&gt;=.  I would lean towards<br>&gt; removing them in Swift 3 simply because it is easier to &quot;remove now, but<br>&gt; add them back later&quot; if they really are important.  The argument for<br>&gt; keeping them is that the surprising aspect will be solved by removing the<br>&gt; first promotion - &quot;42 &gt; nil” will cease to type-check, so they may not<br>&gt; actually be harmful anymore.<br>&gt;<br>&gt; -Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/e81a0849/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Optional comparison operators</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 11, 2016 at 08:00:00pm</p></header><div class="content"><p>On Mon, Jul 11, 2016 at 8:02 PM, Jacob Bandes-Storch via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Mon, Jul 11, 2016 at 5:58 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt; On Jul 11, 2016, at 4:56 PM, Jacob Bandes-Storch via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt; Personally I think we should just remove these optional-taking variants<br>&gt;&gt; of the comparison operators. Does anyone agree/disagree?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; It does make sense to keep ==(T?, T?) and !=(T?, T?), and if coercion<br>&gt;&gt; were removed, we might want to add (T, T?) and (T?, T) versions. Are there<br>&gt;&gt; any other operators that would be affected by your proposal? If not,<br>&gt;&gt; removing the optional &lt;/&lt;=/&gt;/&gt;= would obviate the need to remove coercion.<br>&gt;&gt;<br>&gt;&gt; My opinion:<br>&gt;&gt;  - We need to remove T -&gt; T? promotion from operators for a whole lot of<br>&gt;&gt; reasons.  People are frequently surprised by the behavior of the ??<br>&gt;&gt; operator promoting the LHS to optional, for example.  There are a ton of<br>&gt;&gt; “bugs” that people file that are related to issues like that.<br>&gt;&gt;<br>&gt;<br>&gt; Thinking about this a bit more, couldn&#39;t the same class of &quot;gotcha&quot; happen<br>&gt; with regular functions, too? Why should this be changed for operators<br>&gt; specifically?<br>&gt;<br></p><p>You&#39;ve articulated here the gist of my thinking, probably better than I<br>could. Taken narrowly, it&#39;s clear that coercion + these particular<br>functions leads to undesirable effects. But more generally, operators are<br>just a different spelling for functions, and since I&#39;ve had occasion to<br>find this coercion behavior useful in calling functions, I can think of no<br>principled reason why operators could not be similarly make profitable use<br>of it (in particular circumstances). The flip side is, there are bound to<br>be scenarios in which coercion with regular functions would be undesirable<br>as well.<br></p><p>Maybe it makes more sense to have some kind of &quot;@noncoercing&quot; parameter, so<br>&gt; that coercion can still take place, but operator could be defined as `func<br>&gt; ??&lt;T&gt;(lhs: @noncoercing T?, rhs: T?)`<br>&gt;<br>&gt;<br>&gt;&gt;  - We don’t have conditional conformances, so Optional cannot<br>&gt;&gt; conditionally conform to Equatable and Comparable in Swift 3.  In a later<br>&gt;&gt; release, we can consider whether adding them is a good idea.<br>&gt;&gt;  - We currently support equatable comparing an arbitrary optional to nil<br>&gt;&gt; (one in which T is not necessarily Equatable), which I think is useful to<br>&gt;&gt; keep around.<br>&gt;&gt;  - If we allow that, then it makes sense to allow == and != operators for<br>&gt;&gt; optionals where T is Equatable, even though the optional itself cannot<br>&gt;&gt; conditionally conform to Equatable.  The “surprising” aspect of equatable<br>&gt;&gt; comparison doing promotions will have been removed.<br>&gt;&gt;<br>&gt;&gt; The questionable piece is what to do with &lt;/&lt;=/&gt;/&gt;=.  I would lean<br>&gt;&gt; towards removing them in Swift 3 simply because it is easier to &quot;remove<br>&gt;&gt; now, but add them back later&quot; if they really are important.  The argument<br>&gt;&gt; for keeping them is that the surprising aspect will be solved by removing<br>&gt;&gt; the first promotion - &quot;42 &gt; nil” will cease to type-check, so they may not<br>&gt;&gt; actually be harmful anymore.<br>&gt;&gt;<br>&gt;&gt; -Chris<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/5f4c446c/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8e77369a540cf4d35924683e176c7a9c?s=50"></div><header><strong>Optional comparison operators</strong> from <string>Mark Lacey</string> &lt;mark.lacey at apple.com&gt;<p>July 11, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jul 11, 2016, at 6:02 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Mon, Jul 11, 2016 at 5:58 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt; On Jul 11, 2016, at 4:56 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt; Personally I think we should just remove these optional-taking variants of the comparison operators. Does anyone agree/disagree?<br>&gt; &gt;<br>&gt; &gt; It does make sense to keep ==(T?, T?) and !=(T?, T?), and if coercion were removed, we might want to add (T, T?) and (T?, T) versions. Are there any other operators that would be affected by your proposal? If not, removing the optional &lt;/&lt;=/&gt;/&gt;= would obviate the need to remove coercion.<br>&gt; <br>&gt; My opinion:<br>&gt;  - We need to remove T -&gt; T? promotion from operators for a whole lot of reasons.  People are frequently surprised by the behavior of the ?? operator promoting the LHS to optional, for example.  There are a ton of “bugs” that people file that are related to issues like that.<br>&gt; <br>&gt; Thinking about this a bit more, couldn&#39;t the same class of &quot;gotcha&quot; happen with regular functions, too? Why should this be changed for operators specifically?<br></p><p>This occurred to me when I was considering this over the weekend, but operators are already quite special. You can specify whether they are infix, prefix, or postfix, and assign a precedence. They are used without any special syntax to “apply” them, unlike normal functions which are applied with (…). I would go as far as saying that most (non-PL, non-compiler implementor) people wouldn’t consider operators and normal functions to be very closely related at all.<br></p><p>We clearly wouldn’t want to remove the coercion for the regular functions because it’s extremely convenient. I know you’re not suggesting doing so, I’m just pointing out that if we made things uniform we’d clearly have to keep the coercion by default.<br></p><p>&gt; Maybe it makes more sense to have some kind of &quot;@noncoercing&quot; parameter, so that coercion can still take place, but operator could be defined as `func ??&lt;T&gt;(lhs: @noncoercing T?, rhs: T?)`<br></p><p>I’m not sure it’s really worth adding another attribute just for this purpose.<br></p><p>Mark<br></p><p><br>&gt;  <br>&gt;  - We don’t have conditional conformances, so Optional cannot conditionally conform to Equatable and Comparable in Swift 3.  In a later release, we can consider whether adding them is a good idea.<br>&gt;  - We currently support equatable comparing an arbitrary optional to nil (one in which T is not necessarily Equatable), which I think is useful to keep around.<br>&gt;  - If we allow that, then it makes sense to allow == and != operators for optionals where T is Equatable, even though the optional itself cannot conditionally conform to Equatable.  The “surprising” aspect of equatable comparison doing promotions will have been removed.<br>&gt; <br>&gt; The questionable piece is what to do with &lt;/&lt;=/&gt;/&gt;=.  I would lean towards removing them in Swift 3 simply because it is easier to &quot;remove now, but add them back later&quot; if they really are important.  The argument for keeping them is that the surprising aspect will be solved by removing the first promotion - &quot;42 &gt; nil” will cease to type-check, so they may not actually be harmful anymore.<br>&gt; <br>&gt; -Chris<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/639d8e20/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Optional comparison operators</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>July 11, 2016 at 10:00:00pm</p></header><div class="content"><p>Why not have them return a `Bool?`? If both arguments are non-nil, it can return the results of the comparison, otherwise it can return nil.<br></p><p>- Dave Sweeris<br></p><p>&gt; On Jul 7, 2016, at 16:37, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; These operators cause some potential for confusion:<br>&gt; <br>&gt;     public func &lt;&lt;T : Comparable&gt;(lhs: T?, rhs: T?) -&gt; Bool<br>&gt;     public func &gt;&lt;T : Comparable&gt;(lhs: T?, rhs: T?) -&gt; Bool<br>&gt;     public func &lt;=&lt;T : Comparable&gt;(lhs: T?, rhs: T?) -&gt; Bool<br>&gt;     public func &gt;=&lt;T : Comparable&gt;(lhs: T?, rhs: T?) -&gt; Bool<br>&gt; <br>&gt; 1. The meaning of T? &lt; T? is not immediately obvious (Why is nil &lt; .some(x) for any x? Personally, my intuition says that Optional should only provide a partial order, with .none not being ordered w.r.t. .some(x).)<br>&gt; <br>&gt; 2. Even if the meaning is understood, it can be surprising when the (T?, T?) -&gt; Bool version is used instead of (T, T) -&gt; Bool.<br>&gt; <br>&gt; Prior discussion:<br>&gt; - http://thread.gmane.org/gmane.comp.lang.swift.devel/2089<br>&gt; - http://thread.gmane.org/gmane.comp.lang.swift.evolution/10095<br>&gt; - rdar://16966712&amp;22833869<br>&gt; - Replies to https://twitter.com/jtbandes/status/646914031433871364<br>&gt; <br>&gt; In the swift-dev thread from May, Chris said:<br>&gt; <br>&gt;&gt;&gt; One of the ideas that Joe Pamer has been discussing is whether the implicit promotion from T to T? should be disabled when in an operator context.  Doing so would fix problems like this, but making the code invalid.<br>&gt; <br>&gt; A change like this would be source-breaking, so if the core team has recommendations for how to handle these issues, now is probably the time to get it done.<br>&gt; <br>&gt; Jacob<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/4102b257/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2024f9524b1e51a54c4251abf0c34f50?s=50"></div><header><strong>Optional comparison operators</strong> from <string>Saagar Jha</string> &lt;saagarjha28 at gmail.com&gt;<p>July 11, 2016 at 08:00:00pm</p></header><div class="content"><p>Correct me if I’m wrong, but wouldn’t you have to unwrap every comparison then?<br></p><p>&gt; On Jul 11, 2016, at 20:02, David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Why not have them return a `Bool?`? If both arguments are non-nil, it can return the results of the comparison, otherwise it can return nil.<br>&gt; <br>&gt; - Dave Sweeris<br>&gt; <br>&gt; On Jul 7, 2016, at 16:37, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; These operators cause some potential for confusion:<br>&gt;&gt; <br>&gt;&gt;     public func &lt;&lt;T : Comparable&gt;(lhs: T?, rhs: T?) -&gt; Bool<br>&gt;&gt;     public func &gt;&lt;T : Comparable&gt;(lhs: T?, rhs: T?) -&gt; Bool<br>&gt;&gt;     public func &lt;=&lt;T : Comparable&gt;(lhs: T?, rhs: T?) -&gt; Bool<br>&gt;&gt;     public func &gt;=&lt;T : Comparable&gt;(lhs: T?, rhs: T?) -&gt; Bool<br>&gt;&gt; <br>&gt;&gt; 1. The meaning of T? &lt; T? is not immediately obvious (Why is nil &lt; .some(x) for any x? Personally, my intuition says that Optional should only provide a partial order, with .none not being ordered w.r.t. .some(x).)<br>&gt;&gt; <br>&gt;&gt; 2. Even if the meaning is understood, it can be surprising when the (T?, T?) -&gt; Bool version is used instead of (T, T) -&gt; Bool.<br>&gt;&gt; <br>&gt;&gt; Prior discussion:<br>&gt;&gt; - http://thread.gmane.org/gmane.comp.lang.swift.devel/2089 &lt;http://thread.gmane.org/gmane.comp.lang.swift.devel/2089&gt;<br>&gt;&gt; - http://thread.gmane.org/gmane.comp.lang.swift.evolution/10095 &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/10095&gt;<br>&gt;&gt; - rdar:// &lt;rdar://&gt;16966712&amp;22833869<br>&gt;&gt; - Replies to https://twitter.com/jtbandes/status/646914031433871364 &lt;https://twitter.com/jtbandes/status/646914031433871364&gt;<br>&gt;&gt; <br>&gt;&gt; In the swift-dev thread from May, Chris said:<br>&gt;&gt; <br>&gt;&gt; One of the ideas that Joe Pamer has been discussing is whether the implicit promotion from T to T? should be disabled when in an operator context.  Doing so would fix problems like this, but making the code invalid.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; A change like this would be source-breaking, so if the core team has recommendations for how to handle these issues, now is probably the time to get it done.<br>&gt;&gt; <br>&gt;&gt; Jacob<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/32cefd21/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Optional comparison operators</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>July 11, 2016 at 08:00:00pm</p></header><div class="content"><p>You&#39;d have to unwrap it, or use the ??/==/!= operators:<br>https://gist.github.com/jtbandes/9d88cc83ceceb6c62f38<br></p><p>I&#39;d be okay with &lt;/&lt;=/&gt;/&gt;= returning Bool?, as I suggested in an older<br>email (which somehow didn&#39;t make it to gmane&#39;s archive, but it&#39;s quoted in some<br>other messages<br>&lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/10095&gt;). I think<br>it would be more convenient in some cases than unwrapping the individual<br>values before comparing them.<br></p><p>Jacob<br></p><p>On Mon, Jul 11, 2016 at 8:08 PM, Saagar Jha &lt;saagarjha28 at gmail.com&gt; wrote:<br></p><p>&gt; Correct me if I’m wrong, but wouldn’t you have to unwrap every comparison<br>&gt; then?<br>&gt;<br>&gt; On Jul 11, 2016, at 20:02, David Sweeris via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Why not have them return a `Bool?`? If both arguments are non-nil, it can<br>&gt; return the results of the comparison, otherwise it can return nil.<br>&gt;<br>&gt; - Dave Sweeris<br>&gt;<br>&gt; On Jul 7, 2016, at 16:37, Jacob Bandes-Storch via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; These operators cause some potential for confusion:<br>&gt;<br>&gt;     public func &lt;&lt;T : Comparable&gt;(lhs: T?, rhs: T?) -&gt; Bool<br>&gt;     public func &gt;&lt;T : Comparable&gt;(lhs: T?, rhs: T?) -&gt; Bool<br>&gt;     public func &lt;=&lt;T : Comparable&gt;(lhs: T?, rhs: T?) -&gt; Bool<br>&gt;     public func &gt;=&lt;T : Comparable&gt;(lhs: T?, rhs: T?) -&gt; Bool<br>&gt;<br>&gt; 1. The meaning of T? &lt; T? is not immediately obvious (Why is nil &lt;<br>&gt; .some(x) for any x? Personally, my intuition says that Optional should only<br>&gt; provide a partial order, with .none not being ordered w.r.t. .some(x).)<br>&gt;<br>&gt; 2. Even if the meaning is understood, it can be surprising when the (T?,<br>&gt; T?) -&gt; Bool version is used instead of (T, T) -&gt; Bool.<br>&gt;<br>&gt; Prior discussion:<br>&gt; - http://thread.gmane.org/gmane.comp.lang.swift.devel/2089<br>&gt; - http://thread.gmane.org/gmane.comp.lang.swift.evolution/10095<br>&gt; - rdar://16966712&amp;22833869<br>&gt; - Replies to https://twitter.com/jtbandes/status/646914031433871364<br>&gt;<br>&gt; In the swift-dev thread from May, Chris said:<br>&gt;<br>&gt; One of the ideas that Joe Pamer has been discussing is whether the<br>&gt;&gt;&gt; implicit promotion from T to T? should be disabled when in an operator<br>&gt;&gt;&gt; context.  Doing so would fix problems like this, but making the code<br>&gt;&gt;&gt; invalid.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt; A change like this would be source-breaking, so if the core team has<br>&gt; recommendations for how to handle these issues, now is probably the time to<br>&gt; get it done.<br>&gt;<br>&gt; Jacob<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/0be8e6df/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Optional comparison operators</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>July 11, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jul 11, 2016, at 8:14 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; You&#39;d have to unwrap it, or use the ??/==/!= operators: https://gist.github.com/jtbandes/9d88cc83ceceb6c62f38 &lt;https://gist.github.com/jtbandes/9d88cc83ceceb6c62f38&gt;<br>&gt; <br>&gt; I&#39;d be okay with &lt;/&lt;=/&gt;/&gt;= returning Bool?, as I suggested in an older email (which somehow didn&#39;t make it to gmane&#39;s archive, but it&#39;s quoted in some other messages &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/10095&gt;). I think it would be more convenient in some cases than unwrapping the individual values before comparing them.<br></p><p>I’d be strongly opposed to those operator returning “Bool?”.  Doing so would prevent conforming to Comparable and would be extremely surprising.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/cddcd82e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8e77369a540cf4d35924683e176c7a9c?s=50"></div><header><strong>Optional comparison operators</strong> from <string>Mark Lacey</string> &lt;mark.lacey at apple.com&gt;<p>July 11, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jul 11, 2016, at 9:12 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 11, 2016, at 8:14 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; You&#39;d have to unwrap it, or use the ??/==/!= operators: https://gist.github.com/jtbandes/9d88cc83ceceb6c62f38 &lt;https://gist.github.com/jtbandes/9d88cc83ceceb6c62f38&gt;<br>&gt;&gt; <br>&gt;&gt; I&#39;d be okay with &lt;/&lt;=/&gt;/&gt;= returning Bool?, as I suggested in an older email (which somehow didn&#39;t make it to gmane&#39;s archive, but it&#39;s quoted in some other messages &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/10095&gt;). I think it would be more convenient in some cases than unwrapping the individual values before comparing them.<br>&gt; <br>&gt; I’d be strongly opposed to those operator returning “Bool?”.  Doing so would prevent conforming to Comparable and would be extremely surprising.<br>&gt; <br>&gt; -Chris<br></p><p>I just pushed the current draft of the proposal: https://github.com/rudkx/swift-evolution/blob/eliminate-value-to-optional-coercion/proposals/0000-disallow-value-to-optional-coercion-in-operator-arguments.md &lt;https://github.com/rudkx/swift-evolution/blob/eliminate-value-to-optional-coercion/proposals/0000-disallow-value-to-optional-coercion-in-operator-arguments.md&gt;<br></p><p>I haven’t addressed removal of the ordered comparison operators. I suspect this should be a separate proposal, but I can roll that into this one if it’s desired.<br></p><p>I’ll update the proposal as the discussion continues until it’s selected for review.<br></p><p>Mark<br></p><p>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/8d57dbc3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Optional comparison operators</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>July 11, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jul 11, 2016, at 9:35 PM, Mark Lacey &lt;mark.lacey at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 11, 2016, at 9:12 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 11, 2016, at 8:14 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You&#39;d have to unwrap it, or use the ??/==/!= operators: https://gist.github.com/jtbandes/9d88cc83ceceb6c62f38 &lt;https://gist.github.com/jtbandes/9d88cc83ceceb6c62f38&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;d be okay with &lt;/&lt;=/&gt;/&gt;= returning Bool?, as I suggested in an older email (which somehow didn&#39;t make it to gmane&#39;s archive, but it&#39;s quoted in some other messages &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/10095&gt;). I think it would be more convenient in some cases than unwrapping the individual values before comparing them.<br>&gt;&gt; <br>&gt;&gt; I’d be strongly opposed to those operator returning “Bool?”.  Doing so would prevent conforming to Comparable and would be extremely surprising.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt; <br>&gt; I just pushed the current draft of the proposal: https://github.com/rudkx/swift-evolution/blob/eliminate-value-to-optional-coercion/proposals/0000-disallow-value-to-optional-coercion-in-operator-arguments.md &lt;https://github.com/rudkx/swift-evolution/blob/eliminate-value-to-optional-coercion/proposals/0000-disallow-value-to-optional-coercion-in-operator-arguments.md&gt;<br>&gt; <br>&gt; I haven’t addressed removal of the ordered comparison operators. I suspect this should be a separate proposal, but I can roll that into this one if it’s desired.<br>&gt; <br>&gt; I’ll update the proposal as the discussion continues until it’s selected for review.<br></p><p>I think it makes sense to keep removal of the non-equality comparisons a separate proposal.<br></p><p>Here are some nit-picky comments:<br></p><p>I’d suggest adding quotes:<br></p><p>… by making the notion of “having&quot; or &quot;not having&quot; a value explicit. <br></p><p>Missing a let/var before the first x in:<br></p><p>func returnsOptional() -&gt; Int? {<br>  x: Int = ...<br>  return x<br>}<br></p><p><br>I would move “Proposed Solution” before “Motivation” and just call it “Proposal”.  Otherwise the motivation section doesn’t make sense to read in order.<br></p><p><br>I’d add to this:<br>&quot;Both of these examples represent cases where the silent behavior could potentially hide bugs or confuse readers of the code.”  <br></p><p>… “, it would be better to reject the code as a type error.&quot;<br></p><p><br>If this is relating to implementation details of the standard library, then it should be omitted from the proposal.  The following paragraph also makes sense to revise if you drop this:<br>&quot;Additionally the standard library has approximately a half a dozen locations where optionals are compared to non-optional values which will need to be updated to explicitly cast one operand to an optional.”<br></p><p><br>In this paragraph, I’d recommend changing the wording to be specific and opinionated (saying that “Optional” is the right answer).  If you want to raise specific alternatives for consideration, please add it to “alternatives considered” at the end:<br>&quot;This conversion can currently be accomplished by using Optional() (preferable) or alternately .some(). We could also consider adding a new top-level function for this purpose, but unless it provides additional clarity, it seems like Optional() is reasonable and quite prominent.&quot;<br></p><p>Keeping the body of the proposal opinionated makes the review periods more useful because people know what is specifically being proposed.<br></p><p><br></p><p>&quot;In a survey of six projects” -&gt; Can you explicitly share the name of any of the projects?<br></p><p>Otherwise, LGTM.  When you’re happy with it, please submit a PR for swift-evolution repo, I’ll review managerize it,<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/0535723f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8e77369a540cf4d35924683e176c7a9c?s=50"></div><header><strong>Optional comparison operators</strong> from <string>Mark Lacey</string> &lt;mark.lacey at apple.com&gt;<p>July 11, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Jul 11, 2016, at 9:54 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jul 11, 2016, at 9:35 PM, Mark Lacey &lt;mark.lacey at apple.com &lt;mailto:mark.lacey at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 11, 2016, at 9:12 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jul 11, 2016, at 8:14 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You&#39;d have to unwrap it, or use the ??/==/!= operators: https://gist.github.com/jtbandes/9d88cc83ceceb6c62f38 &lt;https://gist.github.com/jtbandes/9d88cc83ceceb6c62f38&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;d be okay with &lt;/&lt;=/&gt;/&gt;= returning Bool?, as I suggested in an older email (which somehow didn&#39;t make it to gmane&#39;s archive, but it&#39;s quoted in some other messages &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/10095&gt;). I think it would be more convenient in some cases than unwrapping the individual values before comparing them.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’d be strongly opposed to those operator returning “Bool?”.  Doing so would prevent conforming to Comparable and would be extremely surprising.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt; I just pushed the current draft of the proposal: https://github.com/rudkx/swift-evolution/blob/eliminate-value-to-optional-coercion/proposals/0000-disallow-value-to-optional-coercion-in-operator-arguments.md &lt;https://github.com/rudkx/swift-evolution/blob/eliminate-value-to-optional-coercion/proposals/0000-disallow-value-to-optional-coercion-in-operator-arguments.md&gt;<br>&gt;&gt; <br>&gt;&gt; I haven’t addressed removal of the ordered comparison operators. I suspect this should be a separate proposal, but I can roll that into this one if it’s desired.<br>&gt;&gt; <br>&gt;&gt; I’ll update the proposal as the discussion continues until it’s selected for review.<br>&gt; <br>&gt; I think it makes sense to keep removal of the non-equality comparisons a separate proposal.<br>&gt; <br>&gt; Here are some nit-picky comments:<br>&gt; <br>&gt; I’d suggest adding quotes:<br>&gt; <br>&gt; … by making the notion of “having&quot; or &quot;not having&quot; a value explicit. <br>&gt; <br>&gt; Missing a let/var before the first x in:<br>&gt; <br>&gt; func returnsOptional() -&gt; Int? {<br>&gt;   x: Int = ...<br>&gt;   return x<br>&gt; }<br>&gt; <br>&gt; <br>&gt; I would move “Proposed Solution” before “Motivation” and just call it “Proposal”.  Otherwise the motivation section doesn’t make sense to read in order.<br>&gt; <br>&gt; <br>&gt; I’d add to this:<br>&gt; &quot;Both of these examples represent cases where the silent behavior could potentially hide bugs or confuse readers of the code.”  <br>&gt; <br>&gt; … “, it would be better to reject the code as a type error.&quot;<br>&gt; <br>&gt; <br>&gt; If this is relating to implementation details of the standard library, then it should be omitted from the proposal.  The following paragraph also makes sense to revise if you drop this:<br>&gt; &quot;Additionally the standard library has approximately a half a dozen locations where optionals are compared to non-optional values which will need to be updated to explicitly cast one operand to an optional.”<br>&gt; <br></p><p>Thanks for the great feedback. I have most of it addressed, but I’m not sure what you’re referring to with “If this is relating to implementation details of the standard library…”? Do you mean the functions I called out that need to be added?<br></p><p>I can remove that, but I thought it was worth calling out despite the fact that they are just overloads. If it’s not necessary to do so, I’ll delete that section (although there aren’t many details left in the “Detailed design” at that point).<br></p><p>Mark<br></p><p>&gt; <br>&gt; In this paragraph, I’d recommend changing the wording to be specific and opinionated (saying that “Optional” is the right answer).  If you want to raise specific alternatives for consideration, please add it to “alternatives considered” at the end:<br>&gt; &quot;This conversion can currently be accomplished by using Optional() (preferable) or alternately .some(). We could also consider adding a new top-level function for this purpose, but unless it provides additional clarity, it seems like Optional() is reasonable and quite prominent.&quot;<br>&gt; <br>&gt; Keeping the body of the proposal opinionated makes the review periods more useful because people know what is specifically being proposed.<br>&gt; <br>&gt; <br>&gt; <br>&gt; &quot;In a survey of six projects” -&gt; Can you explicitly share the name of any of the projects?<br>&gt; <br>&gt; Otherwise, LGTM.  When you’re happy with it, please submit a PR for swift-evolution repo, I’ll review managerize it,<br>&gt; <br>&gt; -Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/9aa3dd52/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>Optional comparison operators</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>July 12, 2016 at 08:00:00am</p></header><div class="content"><p>There’s something I don’t understand about the proposal. How can the following code still be valid if the proposal is accepted:<br></p><p>let x: Int! = 5<br>let y: Int? = 7<br>print(x &lt; y) // true<br></p><p>Isn’t there going to be a problem coercing y?<br></p><p>David.<br></p><p>&gt; On 12 Jul 2016, at 08:22, Mark Lacey via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 11, 2016, at 9:54 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jul 11, 2016, at 9:35 PM, Mark Lacey &lt;mark.lacey at apple.com &lt;mailto:mark.lacey at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jul 11, 2016, at 9:12 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jul 11, 2016, at 8:14 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; You&#39;d have to unwrap it, or use the ??/==/!= operators: https://gist.github.com/jtbandes/9d88cc83ceceb6c62f38 &lt;https://gist.github.com/jtbandes/9d88cc83ceceb6c62f38&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;d be okay with &lt;/&lt;=/&gt;/&gt;= returning Bool?, as I suggested in an older email (which somehow didn&#39;t make it to gmane&#39;s archive, but it&#39;s quoted in some other messages &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/10095&gt;). I think it would be more convenient in some cases than unwrapping the individual values before comparing them.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’d be strongly opposed to those operator returning “Bool?”.  Doing so would prevent conforming to Comparable and would be extremely surprising.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I just pushed the current draft of the proposal: https://github.com/rudkx/swift-evolution/blob/eliminate-value-to-optional-coercion/proposals/0000-disallow-value-to-optional-coercion-in-operator-arguments.md &lt;https://github.com/rudkx/swift-evolution/blob/eliminate-value-to-optional-coercion/proposals/0000-disallow-value-to-optional-coercion-in-operator-arguments.md&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I haven’t addressed removal of the ordered comparison operators. I suspect this should be a separate proposal, but I can roll that into this one if it’s desired.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’ll update the proposal as the discussion continues until it’s selected for review.<br>&gt;&gt; <br>&gt;&gt; I think it makes sense to keep removal of the non-equality comparisons a separate proposal.<br>&gt;&gt; <br>&gt;&gt; Here are some nit-picky comments:<br>&gt;&gt; <br>&gt;&gt; I’d suggest adding quotes:<br>&gt;&gt; <br>&gt;&gt; … by making the notion of “having&quot; or &quot;not having&quot; a value explicit. <br>&gt;&gt; <br>&gt;&gt; Missing a let/var before the first x in:<br>&gt;&gt; <br>&gt;&gt; func returnsOptional() -&gt; Int? {<br>&gt;&gt;   x: Int = ...<br>&gt;&gt;   return x<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I would move “Proposed Solution” before “Motivation” and just call it “Proposal”.  Otherwise the motivation section doesn’t make sense to read in order.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I’d add to this:<br>&gt;&gt; &quot;Both of these examples represent cases where the silent behavior could potentially hide bugs or confuse readers of the code.”  <br>&gt;&gt; <br>&gt;&gt; … “, it would be better to reject the code as a type error.&quot;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; If this is relating to implementation details of the standard library, then it should be omitted from the proposal.  The following paragraph also makes sense to revise if you drop this:<br>&gt;&gt; &quot;Additionally the standard library has approximately a half a dozen locations where optionals are compared to non-optional values which will need to be updated to explicitly cast one operand to an optional.”<br>&gt;&gt; <br>&gt; <br>&gt; Thanks for the great feedback. I have most of it addressed, but I’m not sure what you’re referring to with “If this is relating to implementation details of the standard library…”? Do you mean the functions I called out that need to be added?<br>&gt; <br>&gt; I can remove that, but I thought it was worth calling out despite the fact that they are just overloads. If it’s not necessary to do so, I’ll delete that section (although there aren’t many details left in the “Detailed design” at that point).<br>&gt; <br>&gt; Mark<br>&gt; <br>&gt;&gt; <br>&gt;&gt; In this paragraph, I’d recommend changing the wording to be specific and opinionated (saying that “Optional” is the right answer).  If you want to raise specific alternatives for consideration, please add it to “alternatives considered” at the end:<br>&gt;&gt; &quot;This conversion can currently be accomplished by using Optional() (preferable) or alternately .some(). We could also consider adding a new top-level function for this purpose, but unless it provides additional clarity, it seems like Optional() is reasonable and quite prominent.&quot;<br>&gt;&gt; <br>&gt;&gt; Keeping the body of the proposal opinionated makes the review periods more useful because people know what is specifically being proposed.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; &quot;In a survey of six projects” -&gt; Can you explicitly share the name of any of the projects?<br>&gt;&gt; <br>&gt;&gt; Otherwise, LGTM.  When you’re happy with it, please submit a PR for swift-evolution repo, I’ll review managerize it,<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160712/e9d2ac9e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Optional comparison operators</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>July 11, 2016 at 11:00:00pm</p></header><div class="content"><p>David,<br>The proposal Mark is working on doesn&#39;t remove the operators which accept<br>optional values. It simply removes the ability to pass non-optional values<br>to them without explicit casting/coercion. In that example y doesn&#39;t need<br>to be coerced.<br></p><p>I&#39;m currently writing up a separate proposal to remove these operators. The<br>two issues are largely orthogonal.<br></p><p>Jacob<br></p><p>On Mon, Jul 11, 2016 at 11:49 PM, David Hart via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; There’s something I don’t understand about the proposal. How can the<br>&gt; following code still be valid if the proposal is accepted:<br>&gt;<br>&gt; let x: Int! = 5<br>&gt; let y: Int? = 7<br>&gt; print(x &lt; y) // true<br>&gt;<br>&gt; Isn’t there going to be a problem coercing y?<br>&gt;<br>&gt; David.<br>&gt;<br>&gt; On 12 Jul 2016, at 08:22, Mark Lacey via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Jul 11, 2016, at 9:54 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Jul 11, 2016, at 9:35 PM, Mark Lacey &lt;mark.lacey at apple.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Jul 11, 2016, at 9:12 PM, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Jul 11, 2016, at 8:14 PM, Jacob Bandes-Storch via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; You&#39;d have to unwrap it, or use the ??/==/!= operators:<br>&gt; https://gist.github.com/jtbandes/9d88cc83ceceb6c62f38<br>&gt;<br>&gt; I&#39;d be okay with &lt;/&lt;=/&gt;/&gt;= returning Bool?, as I suggested in an older<br>&gt; email (which somehow didn&#39;t make it to gmane&#39;s archive, but it&#39;s quoted in<br>&gt;  some other messages<br>&gt; &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/10095&gt;). I think<br>&gt; it would be more convenient in some cases than unwrapping the individual<br>&gt; values before comparing them.<br>&gt;<br>&gt;<br>&gt; I’d be strongly opposed to those operator returning “Bool?”.  Doing so<br>&gt; would prevent conforming to Comparable and would be extremely surprising.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br>&gt; I just pushed the current draft of the proposal:<br>&gt; https://github.com/rudkx/swift-evolution/blob/eliminate-value-to-optional-coercion/proposals/0000-disallow-value-to-optional-coercion-in-operator-arguments.md<br>&gt;<br>&gt; I haven’t addressed removal of the ordered comparison operators. I suspect<br>&gt; this should be a separate proposal, but I can roll that into this one if<br>&gt; it’s desired.<br>&gt;<br>&gt; I’ll update the proposal as the discussion continues until it’s selected<br>&gt; for review.<br>&gt;<br>&gt;<br>&gt; I think it makes sense to keep removal of the non-equality comparisons a<br>&gt; separate proposal.<br>&gt;<br>&gt; Here are some nit-picky comments:<br>&gt;<br>&gt; I’d suggest adding quotes:<br>&gt;<br>&gt; … by making the notion of “having&quot; or &quot;not having&quot; a value explicit.<br>&gt;<br>&gt; Missing a let/var before the first x in:<br>&gt;<br>&gt; func returnsOptional() -&gt; Int? {<br>&gt;   x: Int = ...<br>&gt;   return x<br>&gt; }<br>&gt;<br>&gt;<br>&gt;<br>&gt; I would move “Proposed Solution” before “Motivation” and just call it<br>&gt; “Proposal”.  Otherwise the motivation section doesn’t make sense to read in<br>&gt; order.<br>&gt;<br>&gt;<br>&gt; I’d add to this:<br>&gt; &quot;Both of these examples represent cases where the silent behavior could<br>&gt; potentially hide bugs or confuse readers of the code.”<br>&gt;<br>&gt; … “, it would be better to reject the code as a type error.&quot;<br>&gt;<br>&gt;<br>&gt; If this is relating to implementation details of the standard library,<br>&gt; then it should be omitted from the proposal.  The following paragraph also<br>&gt; makes sense to revise if you drop this:<br>&gt; &quot;Additionally the standard library has approximately a half a dozen<br>&gt; locations where optionals are compared to non-optional values which will<br>&gt; need to be updated to explicitly cast one operand to an optional.”<br>&gt;<br>&gt;<br>&gt; Thanks for the great feedback. I have most of it addressed, but I’m not<br>&gt; sure what you’re referring to with “If this is relating to implementation<br>&gt; details of the standard library…”? Do you mean the functions I called out<br>&gt; that need to be added?<br>&gt;<br>&gt; I can remove that, but I thought it was worth calling out despite the fact<br>&gt; that they are just overloads. If it’s not necessary to do so, I’ll delete<br>&gt; that section (although there aren’t many details left in the “Detailed<br>&gt; design” at that point).<br>&gt;<br>&gt; Mark<br>&gt;<br>&gt;<br>&gt; In this paragraph, I’d recommend changing the wording to be specific and<br>&gt; opinionated (saying that “Optional” is the right answer).  If you want to<br>&gt; raise specific alternatives for consideration, please add it to<br>&gt; “alternatives considered” at the end:<br>&gt; &quot;This conversion can currently be accomplished by<br>&gt; using Optional() (preferable) or alternately .some(). We could also<br>&gt; consider adding a new top-level function for this purpose, but unless it<br>&gt; provides additional clarity, it seems like Optional() is reasonable and<br>&gt; quite prominent.&quot;<br>&gt;<br>&gt; Keeping the body of the proposal opinionated makes the review periods more<br>&gt; useful because people know what is specifically being proposed.<br>&gt;<br>&gt;<br>&gt;<br>&gt; &quot;In a survey of six projects” -&gt; Can you explicitly share the name of any<br>&gt; of the projects?<br>&gt;<br>&gt; Otherwise, LGTM.  When you’re happy with it, please submit a PR for<br>&gt; swift-evolution repo, I’ll review managerize it,<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/3691b58e/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Optional comparison operators</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>July 12, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jul 11, 2016, at 11:22 PM, Mark Lacey &lt;mark.lacey at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; If this is relating to implementation details of the standard library, then it should be omitted from the proposal.  The following paragraph also makes sense to revise if you drop this:<br>&gt;&gt; &quot;Additionally the standard library has approximately a half a dozen locations where optionals are compared to non-optional values which will need to be updated to explicitly cast one operand to an optional.”<br>&gt;&gt; <br>&gt; <br>&gt; Thanks for the great feedback. I have most of it addressed, but I’m not sure what you’re referring to with “If this is relating to implementation details of the standard library…”? Do you mean the functions I called out that need to be added?<br>&gt; <br>&gt; I can remove that, but I thought it was worth calling out despite the fact that they are just overloads. If it’s not necessary to do so, I’ll delete that section (although there aren’t many details left in the “Detailed design” at that point).<br></p><p>I’m referring to this part of the proposal:<br></p><p>&quot;Additionally the standard library has approximately a half a dozen locations where optionals are compared to non-optional values which will need to be updated to explicitly cast one operand to an optional.”<br></p><p>I’m just saying that the internal implementation details of the standard library are typically considered part of an evolution proposal, only the public API impact.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160712/5c7058e8/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Optional comparison operators</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>July 12, 2016 at 12:00:00am</p></header><div class="content"><p>On Mon, Jul 11, 2016 at 9:54 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Jul 11, 2016, at 9:35 PM, Mark Lacey &lt;mark.lacey at apple.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Jul 11, 2016, at 9:12 PM, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Jul 11, 2016, at 8:14 PM, Jacob Bandes-Storch via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; You&#39;d have to unwrap it, or use the ??/==/!= operators:<br>&gt; https://gist.github.com/jtbandes/9d88cc83ceceb6c62f38<br>&gt;<br>&gt; I&#39;d be okay with &lt;/&lt;=/&gt;/&gt;= returning Bool?, as I suggested in an older<br>&gt; email (which somehow didn&#39;t make it to gmane&#39;s archive, but it&#39;s quoted in some<br>&gt; other messages<br>&gt; &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/10095&gt;). I think<br>&gt; it would be more convenient in some cases than unwrapping the individual<br>&gt; values before comparing them.<br>&gt;<br>&gt;<br>&gt; I’d be strongly opposed to those operator returning “Bool?”.  Doing so<br>&gt; would prevent conforming to Comparable and would be extremely surprising.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br>&gt; I just pushed the current draft of the proposal:<br>&gt; https://github.com/rudkx/swift-evolution/blob/eliminate-value-to-optional-coercion/proposals/0000-disallow-value-to-optional-coercion-in-operator-arguments.md<br>&gt;<br>&gt; I haven’t addressed removal of the ordered comparison operators. I suspect<br>&gt; this should be a separate proposal, but I can roll that into this one if<br>&gt; it’s desired.<br>&gt;<br>&gt; I’ll update the proposal as the discussion continues until it’s selected<br>&gt; for review.<br>&gt;<br>&gt;<br>&gt; I think it makes sense to keep removal of the non-equality comparisons a<br>&gt; separate proposal.<br>&gt;<br></p><p>Here&#39;s a draft. Feedback welcome:<br></p><p>https://github.com/jtbandes/swift-evolution/blob/master/proposals/0122-remove-optional-comparison-operators.md<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160712/5f2494ae/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Optional comparison operators</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>July 12, 2016 at 10:00:00am</p></header><div class="content"><p>I&#39;ve submitted a PR for my proposal to remove these versions of &lt;/&lt;=/&gt;/&gt;=<br> at  https://github.com/apple/swift-evolution/pull/425.<br></p><p>On Tue, Jul 12, 2016 at 12:03 AM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>wrote:<br></p><p>&gt; On Mon, Jul 11, 2016 at 9:54 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Jul 11, 2016, at 9:35 PM, Mark Lacey &lt;mark.lacey at apple.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Jul 11, 2016, at 9:12 PM, Chris Lattner via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Jul 11, 2016, at 8:14 PM, Jacob Bandes-Storch via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; You&#39;d have to unwrap it, or use the ??/==/!= operators:<br>&gt;&gt; https://gist.github.com/jtbandes/9d88cc83ceceb6c62f38<br>&gt;&gt;<br>&gt;&gt; I&#39;d be okay with &lt;/&lt;=/&gt;/&gt;= returning Bool?, as I suggested in an older<br>&gt;&gt; email (which somehow didn&#39;t make it to gmane&#39;s archive, but it&#39;s quoted in some<br>&gt;&gt; other messages<br>&gt;&gt; &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/10095&gt;). I<br>&gt;&gt; think it would be more convenient in some cases than unwrapping the<br>&gt;&gt; individual values before comparing them.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I’d be strongly opposed to those operator returning “Bool?”.  Doing so<br>&gt;&gt; would prevent conforming to Comparable and would be extremely surprising.<br>&gt;&gt;<br>&gt;&gt; -Chris<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I just pushed the current draft of the proposal:<br>&gt;&gt; https://github.com/rudkx/swift-evolution/blob/eliminate-value-to-optional-coercion/proposals/0000-disallow-value-to-optional-coercion-in-operator-arguments.md<br>&gt;&gt;<br>&gt;&gt; I haven’t addressed removal of the ordered comparison operators. I<br>&gt;&gt; suspect this should be a separate proposal, but I can roll that into this<br>&gt;&gt; one if it’s desired.<br>&gt;&gt;<br>&gt;&gt; I’ll update the proposal as the discussion continues until it’s selected<br>&gt;&gt; for review.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I think it makes sense to keep removal of the non-equality comparisons a<br>&gt;&gt; separate proposal.<br>&gt;&gt;<br>&gt;<br>&gt; Here&#39;s a draft. Feedback welcome:<br>&gt;<br>&gt;<br>&gt; https://github.com/jtbandes/swift-evolution/blob/master/proposals/0122-remove-optional-comparison-operators.md<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160712/b4ae4c93/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Optional comparison operators</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>July 12, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jul 12, 2016, at 10:26 AM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt; <br>&gt; I&#39;ve submitted a PR for my proposal to remove these versions of &lt;/&lt;=/&gt;/&gt;=  at  https://github.com/apple/swift-evolution/pull/425 &lt;https://github.com/apple/swift-evolution/pull/425&gt;.<br></p><p>Thanks, LGTM, I merged and kicked it off.<br></p><p>-Chris<br></p><p>&gt; <br>&gt; On Tue, Jul 12, 2016 at 12:03 AM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt; On Mon, Jul 11, 2016 at 9:54 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Jul 11, 2016, at 9:35 PM, Mark Lacey &lt;mark.lacey at apple.com &lt;mailto:mark.lacey at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 11, 2016, at 9:12 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jul 11, 2016, at 8:14 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You&#39;d have to unwrap it, or use the ??/==/!= operators: https://gist.github.com/jtbandes/9d88cc83ceceb6c62f38 &lt;https://gist.github.com/jtbandes/9d88cc83ceceb6c62f38&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;d be okay with &lt;/&lt;=/&gt;/&gt;= returning Bool?, as I suggested in an older email (which somehow didn&#39;t make it to gmane&#39;s archive, but it&#39;s quoted in some other messages &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/10095&gt;). I think it would be more convenient in some cases than unwrapping the individual values before comparing them.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’d be strongly opposed to those operator returning “Bool?”.  Doing so would prevent conforming to Comparable and would be extremely surprising.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt; I just pushed the current draft of the proposal: https://github.com/rudkx/swift-evolution/blob/eliminate-value-to-optional-coercion/proposals/0000-disallow-value-to-optional-coercion-in-operator-arguments.md &lt;https://github.com/rudkx/swift-evolution/blob/eliminate-value-to-optional-coercion/proposals/0000-disallow-value-to-optional-coercion-in-operator-arguments.md&gt;<br>&gt;&gt; <br>&gt;&gt; I haven’t addressed removal of the ordered comparison operators. I suspect this should be a separate proposal, but I can roll that into this one if it’s desired.<br>&gt;&gt; <br>&gt;&gt; I’ll update the proposal as the discussion continues until it’s selected for review.<br>&gt; <br>&gt; I think it makes sense to keep removal of the non-equality comparisons a separate proposal.<br>&gt; <br>&gt; Here&#39;s a draft. Feedback welcome:<br>&gt; <br>&gt; https://github.com/jtbandes/swift-evolution/blob/master/proposals/0122-remove-optional-comparison-operators.md &lt;https://github.com/jtbandes/swift-evolution/blob/master/proposals/0122-remove-optional-comparison-operators.md&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160712/87b78eab/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Optional comparison operators</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>July 12, 2016 at 12:00:00pm</p></header><div class="content"><p>Here&#39;s another proposal to reinstate mixed-optional versions of<br>==/!=/===/!==, assuming that coercion is removed:<br>https://github.com/apple/swift-evolution/pull/426<br></p><p>Jacob<br></p><p>On Tue, Jul 12, 2016 at 11:29 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Jul 12, 2016, at 10:26 AM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; I&#39;ve submitted a PR for my proposal to remove these versions of &lt;/&lt;=/&gt;/&gt;=<br>&gt;  at  https://github.com/apple/swift-evolution/pull/425.<br>&gt;<br>&gt;<br>&gt; Thanks, LGTM, I merged and kicked it off.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br>&gt; On Tue, Jul 12, 2016 at 12:03 AM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; On Mon, Jul 11, 2016 at 9:54 PM, Chris Lattner &lt;clattner at apple.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Jul 11, 2016, at 9:35 PM, Mark Lacey &lt;mark.lacey at apple.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Jul 11, 2016, at 9:12 PM, Chris Lattner via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Jul 11, 2016, at 8:14 PM, Jacob Bandes-Storch via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; You&#39;d have to unwrap it, or use the ??/==/!= operators:<br>&gt;&gt;&gt; https://gist.github.com/jtbandes/9d88cc83ceceb6c62f38<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;d be okay with &lt;/&lt;=/&gt;/&gt;= returning Bool?, as I suggested in an older<br>&gt;&gt;&gt; email (which somehow didn&#39;t make it to gmane&#39;s archive, but it&#39;s quoted in some<br>&gt;&gt;&gt; other messages<br>&gt;&gt;&gt; &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/10095&gt;). I<br>&gt;&gt;&gt; think it would be more convenient in some cases than unwrapping the<br>&gt;&gt;&gt; individual values before comparing them.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I’d be strongly opposed to those operator returning “Bool?”.  Doing so<br>&gt;&gt;&gt; would prevent conforming to Comparable and would be extremely surprising.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I just pushed the current draft of the proposal:<br>&gt;&gt;&gt; https://github.com/rudkx/swift-evolution/blob/eliminate-value-to-optional-coercion/proposals/0000-disallow-value-to-optional-coercion-in-operator-arguments.md<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I haven’t addressed removal of the ordered comparison operators. I<br>&gt;&gt;&gt; suspect this should be a separate proposal, but I can roll that into this<br>&gt;&gt;&gt; one if it’s desired.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I’ll update the proposal as the discussion continues until it’s selected<br>&gt;&gt;&gt; for review.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I think it makes sense to keep removal of the non-equality comparisons a<br>&gt;&gt;&gt; separate proposal.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Here&#39;s a draft. Feedback welcome:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; https://github.com/jtbandes/swift-evolution/blob/master/proposals/0122-remove-optional-comparison-operators.md<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160712/74ae0748/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Optional comparison operators</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>July 11, 2016 at 11:00:00pm</p></header><div class="content"><p>Mark,<br>Thanks for writing this up. Just to clarify, will these still work if your<br>proposal is implemented?<br></p><p>    let x: Int?<br>    let y: Int<br>    struct NotEquatable {}<br>    let z: NotEquatable?<br></p><p>    x == y; x != y<br>    x == nil; x != nil<br>    z == nil; z != nil<br></p><p>I would hope that these continue to work. If any changes need to be made to<br>ensure that, please make sure they&#39;re included in the proposal too.<br></p><p>Jacob<br></p><p>On Mon, Jul 11, 2016 at 9:35 PM, Mark Lacey &lt;mark.lacey at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Jul 11, 2016, at 9:12 PM, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Jul 11, 2016, at 8:14 PM, Jacob Bandes-Storch via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; You&#39;d have to unwrap it, or use the ??/==/!= operators:<br>&gt; https://gist.github.com/jtbandes/9d88cc83ceceb6c62f38<br>&gt;<br>&gt; I&#39;d be okay with &lt;/&lt;=/&gt;/&gt;= returning Bool?, as I suggested in an older<br>&gt; email (which somehow didn&#39;t make it to gmane&#39;s archive, but it&#39;s quoted in some<br>&gt; other messages<br>&gt; &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/10095&gt;). I think<br>&gt; it would be more convenient in some cases than unwrapping the individual<br>&gt; values before comparing them.<br>&gt;<br>&gt;<br>&gt; I’d be strongly opposed to those operator returning “Bool?”.  Doing so<br>&gt; would prevent conforming to Comparable and would be extremely surprising.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br>&gt; I just pushed the current draft of the proposal:<br>&gt; https://github.com/rudkx/swift-evolution/blob/eliminate-value-to-optional-coercion/proposals/0000-disallow-value-to-optional-coercion-in-operator-arguments.md<br>&gt;<br>&gt; I haven’t addressed removal of the ordered comparison operators. I suspect<br>&gt; this should be a separate proposal, but I can roll that into this one if<br>&gt; it’s desired.<br>&gt;<br>&gt; I’ll update the proposal as the discussion continues until it’s selected<br>&gt; for review.<br>&gt;<br>&gt; Mark<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/d6f00906/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8e77369a540cf4d35924683e176c7a9c?s=50"></div><header><strong>Optional comparison operators</strong> from <string>Mark Lacey</string> &lt;mark.lacey at apple.com&gt;<p>July 12, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On Jul 11, 2016, at 11:55 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt; <br>&gt; Mark,<br>&gt; Thanks for writing this up. Just to clarify, will these still work if your proposal is implemented?<br>&gt; <br>&gt;     let x: Int?<br>&gt;     let y: Int<br>&gt;     struct NotEquatable {}<br>&gt;     let z: NotEquatable?<br>&gt; <br>&gt;     x == y; x != y<br>&gt;     x == nil; x != nil<br>&gt;     z == nil; z != nil<br>&gt; <br>&gt; I would hope that these continue to work. If any changes need to be made to ensure that, please make sure they&#39;re included in the proposal too.<br></p><p>The last four would work, but the first two (x == y and x != y) would not because they still involve coercing y to an optional.<br></p><p>Similarly, === and !== on reference types where one is an optional would require coercing one side, and would not be accepted without an explicit cast using Optional().<br></p><p>I’m curious what the motivation is for further special casing these operators. They do occur more in practice than &lt;, &lt;=, &gt;, &gt;= (in fact most of the source updates I had to make were due to === and !==, with == and != a close second), but overall these are still quite uncommon from what I’ve seen.<br></p><p>If you’d like I can certainly update the “alternatives considered” to include the suggestion that we add overloads for (T, T?) and (T?, T) for those four operators.<br></p><p>Mark<br></p><p>&gt; <br>&gt; Jacob<br>&gt; <br>&gt; On Mon, Jul 11, 2016 at 9:35 PM, Mark Lacey &lt;mark.lacey at apple.com &lt;mailto:mark.lacey at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Jul 11, 2016, at 9:12 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 11, 2016, at 8:14 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You&#39;d have to unwrap it, or use the ??/==/!= operators: https://gist.github.com/jtbandes/9d88cc83ceceb6c62f38 &lt;https://gist.github.com/jtbandes/9d88cc83ceceb6c62f38&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;d be okay with &lt;/&lt;=/&gt;/&gt;= returning Bool?, as I suggested in an older email (which somehow didn&#39;t make it to gmane&#39;s archive, but it&#39;s quoted in some other messages &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/10095&gt;). I think it would be more convenient in some cases than unwrapping the individual values before comparing them.<br>&gt;&gt; <br>&gt;&gt; I’d be strongly opposed to those operator returning “Bool?”.  Doing so would prevent conforming to Comparable and would be extremely surprising.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt; <br>&gt; I just pushed the current draft of the proposal: https://github.com/rudkx/swift-evolution/blob/eliminate-value-to-optional-coercion/proposals/0000-disallow-value-to-optional-coercion-in-operator-arguments.md &lt;https://github.com/rudkx/swift-evolution/blob/eliminate-value-to-optional-coercion/proposals/0000-disallow-value-to-optional-coercion-in-operator-arguments.md&gt;<br>&gt; <br>&gt; I haven’t addressed removal of the ordered comparison operators. I suspect this should be a separate proposal, but I can roll that into this one if it’s desired.<br>&gt; <br>&gt; I’ll update the proposal as the discussion continues until it’s selected for review.<br>&gt; <br>&gt; Mark<br>&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160712/2cdd82dc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Optional comparison operators</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>July 12, 2016 at 12:00:00am</p></header><div class="content"><p>Okay, I guess it&#39;s fair that (T, T?) and (T?, T) overloads should have to<br>be a separate proposal.<br></p><p>My personal motivation is mostly anecdotal; I&#39;ve found them quite useful,<br>and I wouldn&#39;t say they&#39;re uncommon. Some use cases off the top of my head:<br>- checking whether a dictionary contains a particular value for a key<br>- checking whether an optional ivar (such as &quot;selectedIndex: Int?&quot;)<br>contains a particular value (&quot;if tappedIndex == selectedIndex&quot;)<br></p><p>Jacob<br></p><p>On Tue, Jul 12, 2016 at 12:09 AM, Mark Lacey &lt;mark.lacey at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Jul 11, 2016, at 11:55 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; Mark,<br>&gt; Thanks for writing this up. Just to clarify, will these still work if your<br>&gt; proposal is implemented?<br>&gt;<br>&gt;     let x: Int?<br>&gt;     let y: Int<br>&gt;     struct NotEquatable {}<br>&gt;     let z: NotEquatable?<br>&gt;<br>&gt;     x == y; x != y<br>&gt;     x == nil; x != nil<br>&gt;     z == nil; z != nil<br>&gt;<br>&gt; I would hope that these continue to work. If any changes need to be made<br>&gt; to ensure that, please make sure they&#39;re included in the proposal too.<br>&gt;<br>&gt;<br>&gt; The last four would work, but the first two (x == y and x != y) would not<br>&gt; because they still involve coercing y to an optional.<br>&gt;<br>&gt; Similarly, === and !== on reference types where one is an optional would<br>&gt; require coercing one side, and would not be accepted without an explicit<br>&gt; cast using Optional().<br>&gt;<br>&gt; I’m curious what the motivation is for further special casing these<br>&gt; operators. They do occur more in practice than &lt;, &lt;=, &gt;, &gt;= (in fact most<br>&gt; of the source updates I had to make were due to === and !==, with == and !=<br>&gt; a close second), but overall these are still quite uncommon from what I’ve<br>&gt; seen.<br>&gt;<br>&gt; If you’d like I can certainly update the “alternatives considered” to<br>&gt; include the suggestion that we add overloads for (T, T?) and (T?, T) for<br>&gt; those four operators.<br>&gt;<br>&gt; Mark<br>&gt;<br>&gt;<br>&gt; Jacob<br>&gt;<br>&gt; On Mon, Jul 11, 2016 at 9:35 PM, Mark Lacey &lt;mark.lacey at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Jul 11, 2016, at 9:12 PM, Chris Lattner via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Jul 11, 2016, at 8:14 PM, Jacob Bandes-Storch via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; You&#39;d have to unwrap it, or use the ??/==/!= operators:<br>&gt;&gt; https://gist.github.com/jtbandes/9d88cc83ceceb6c62f38<br>&gt;&gt;<br>&gt;&gt; I&#39;d be okay with &lt;/&lt;=/&gt;/&gt;= returning Bool?, as I suggested in an older<br>&gt;&gt; email (which somehow didn&#39;t make it to gmane&#39;s archive, but it&#39;s quoted in some<br>&gt;&gt; other messages<br>&gt;&gt; &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/10095&gt;). I<br>&gt;&gt; think it would be more convenient in some cases than unwrapping the<br>&gt;&gt; individual values before comparing them.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I’d be strongly opposed to those operator returning “Bool?”.  Doing so<br>&gt;&gt; would prevent conforming to Comparable and would be extremely surprising.<br>&gt;&gt;<br>&gt;&gt; -Chris<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I just pushed the current draft of the proposal:<br>&gt;&gt; https://github.com/rudkx/swift-evolution/blob/eliminate-value-to-optional-coercion/proposals/0000-disallow-value-to-optional-coercion-in-operator-arguments.md<br>&gt;&gt;<br>&gt;&gt; I haven’t addressed removal of the ordered comparison operators. I<br>&gt;&gt; suspect this should be a separate proposal, but I can roll that into this<br>&gt;&gt; one if it’s desired.<br>&gt;&gt;<br>&gt;&gt; I’ll update the proposal as the discussion continues until it’s selected<br>&gt;&gt; for review.<br>&gt;&gt;<br>&gt;&gt; Mark<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160712/507f26be/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8e77369a540cf4d35924683e176c7a9c?s=50"></div><header><strong>Optional comparison operators</strong> from <string>Mark Lacey</string> &lt;mark.lacey at apple.com&gt;<p>July 12, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On Jul 12, 2016, at 12:16 AM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt; <br>&gt; Okay, I guess it&#39;s fair that (T, T?) and (T?, T) overloads should have to be a separate proposal.<br>&gt; <br>&gt; My personal motivation is mostly anecdotal; I&#39;ve found them quite useful, and I wouldn&#39;t say they&#39;re uncommon.<br></p><p>Sure, I mean uncommon in the sense that in the projects I’ve looked at I’m seeing them perhaps once every 1,000-2,000 lines of commented code, not uncommon in the sense that you will almost never see them in practice. I’m sure for some projects it’s going to be much more often than others.<br></p><p>Mark<br></p><p>&gt; Some use cases off the top of my head:<br>&gt; - checking whether a dictionary contains a particular value for a key<br>&gt; - checking whether an optional ivar (such as &quot;selectedIndex: Int?&quot;) contains a particular value (&quot;if tappedIndex == selectedIndex”)<br>&gt; <br>&gt; Jacob<br>&gt; <br>&gt; On Tue, Jul 12, 2016 at 12:09 AM, Mark Lacey &lt;mark.lacey at apple.com &lt;mailto:mark.lacey at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Jul 11, 2016, at 11:55 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Mark,<br>&gt;&gt; Thanks for writing this up. Just to clarify, will these still work if your proposal is implemented?<br>&gt;&gt; <br>&gt;&gt;     let x: Int?<br>&gt;&gt;     let y: Int<br>&gt;&gt;     struct NotEquatable {}<br>&gt;&gt;     let z: NotEquatable?<br>&gt;&gt; <br>&gt;&gt;     x == y; x != y<br>&gt;&gt;     x == nil; x != nil<br>&gt;&gt;     z == nil; z != nil<br>&gt;&gt; <br>&gt;&gt; I would hope that these continue to work. If any changes need to be made to ensure that, please make sure they&#39;re included in the proposal too.<br>&gt; <br>&gt; The last four would work, but the first two (x == y and x != y) would not because they still involve coercing y to an optional.<br>&gt; <br>&gt; Similarly, === and !== on reference types where one is an optional would require coercing one side, and would not be accepted without an explicit cast using Optional().<br>&gt; <br>&gt; I’m curious what the motivation is for further special casing these operators. They do occur more in practice than &lt;, &lt;=, &gt;, &gt;= (in fact most of the source updates I had to make were due to === and !==, with == and != a close second), but overall these are still quite uncommon from what I’ve seen.<br>&gt; <br>&gt; If you’d like I can certainly update the “alternatives considered” to include the suggestion that we add overloads for (T, T?) and (T?, T) for those four operators.<br>&gt; <br>&gt; Mark<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Jacob<br>&gt;&gt; <br>&gt;&gt; On Mon, Jul 11, 2016 at 9:35 PM, Mark Lacey &lt;mark.lacey at apple.com &lt;mailto:mark.lacey at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 11, 2016, at 9:12 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jul 11, 2016, at 8:14 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You&#39;d have to unwrap it, or use the ??/==/!= operators: https://gist.github.com/jtbandes/9d88cc83ceceb6c62f38 &lt;https://gist.github.com/jtbandes/9d88cc83ceceb6c62f38&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;d be okay with &lt;/&lt;=/&gt;/&gt;= returning Bool?, as I suggested in an older email (which somehow didn&#39;t make it to gmane&#39;s archive, but it&#39;s quoted in some other messages &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/10095&gt;). I think it would be more convenient in some cases than unwrapping the individual values before comparing them.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’d be strongly opposed to those operator returning “Bool?”.  Doing so would prevent conforming to Comparable and would be extremely surprising.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt; I just pushed the current draft of the proposal: https://github.com/rudkx/swift-evolution/blob/eliminate-value-to-optional-coercion/proposals/0000-disallow-value-to-optional-coercion-in-operator-arguments.md &lt;https://github.com/rudkx/swift-evolution/blob/eliminate-value-to-optional-coercion/proposals/0000-disallow-value-to-optional-coercion-in-operator-arguments.md&gt;<br>&gt;&gt; <br>&gt;&gt; I haven’t addressed removal of the ordered comparison operators. I suspect this should be a separate proposal, but I can roll that into this one if it’s desired.<br>&gt;&gt; <br>&gt;&gt; I’ll update the proposal as the discussion continues until it’s selected for review.<br>&gt;&gt; <br>&gt;&gt; Mark<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160712/fa5b39e0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Optional comparison operators</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 12, 2016 at 02:00:00am</p></header><div class="content"><p>On Tue, Jul 12, 2016 at 2:22 AM, Mark Lacey via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Jul 12, 2016, at 12:16 AM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; Okay, I guess it&#39;s fair that (T, T?) and (T?, T) overloads should have to<br>&gt; be a separate proposal.<br>&gt;<br>&gt; My personal motivation is mostly anecdotal; I&#39;ve found them quite useful,<br>&gt; and I wouldn&#39;t say they&#39;re uncommon.<br>&gt;<br>&gt;<br>&gt; Sure, I mean uncommon in the sense that in the projects I’ve looked at I’m<br>&gt; seeing them perhaps once every 1,000-2,000 lines of commented code, not<br>&gt; uncommon in the sense that you will almost never see them in practice. I’m<br>&gt; sure for some projects it’s going to be much more often than others.<br>&gt;<br>&gt; Mark<br>&gt;<br></p><p>Does this really need to be a separate proposal? I mean, implicit in your<br>proposal is special casing the assignment operator to do the same thing<br>(conceptually, at least). Otherwise, let `y = 1, x: Int? = y` wouldn&#39;t work<br>anymore, right? So it&#39;d probably be in scope to say that those scenarios in<br>which coercion currently makes sense would be preserved by the addition of<br>the appropriate overloads concomitant with removal of coercion generally.<br></p><p><br>&gt;<br>&gt; Some use cases off the top of my head:<br>&gt; - checking whether a dictionary contains a particular value for a key<br>&gt; - checking whether an optional ivar (such as &quot;selectedIndex: Int?&quot;)<br>&gt; contains a particular value (&quot;if tappedIndex == selectedIndex”)<br>&gt;<br>&gt;<br>&gt; Jacob<br>&gt;<br>&gt; On Tue, Jul 12, 2016 at 12:09 AM, Mark Lacey &lt;mark.lacey at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Jul 11, 2016, at 11:55 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Mark,<br>&gt;&gt; Thanks for writing this up. Just to clarify, will these still work if<br>&gt;&gt; your proposal is implemented?<br>&gt;&gt;<br>&gt;&gt;     let x: Int?<br>&gt;&gt;     let y: Int<br>&gt;&gt;     struct NotEquatable {}<br>&gt;&gt;     let z: NotEquatable?<br>&gt;&gt;<br>&gt;&gt;     x == y; x != y<br>&gt;&gt;     x == nil; x != nil<br>&gt;&gt;     z == nil; z != nil<br>&gt;&gt;<br>&gt;&gt; I would hope that these continue to work. If any changes need to be made<br>&gt;&gt; to ensure that, please make sure they&#39;re included in the proposal too.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; The last four would work, but the first two (x == y and x != y) would not<br>&gt;&gt; because they still involve coercing y to an optional.<br>&gt;&gt;<br>&gt;&gt; Similarly, === and !== on reference types where one is an optional would<br>&gt;&gt; require coercing one side, and would not be accepted without an explicit<br>&gt;&gt; cast using Optional().<br>&gt;&gt;<br>&gt;&gt; I’m curious what the motivation is for further special casing these<br>&gt;&gt; operators. They do occur more in practice than &lt;, &lt;=, &gt;, &gt;= (in fact most<br>&gt;&gt; of the source updates I had to make were due to === and !==, with == and !=<br>&gt;&gt; a close second), but overall these are still quite uncommon from what I’ve<br>&gt;&gt; seen.<br>&gt;&gt;<br>&gt;&gt; If you’d like I can certainly update the “alternatives considered” to<br>&gt;&gt; include the suggestion that we add overloads for (T, T?) and (T?, T) for<br>&gt;&gt; those four operators.<br>&gt;&gt;<br>&gt;&gt; Mark<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Jacob<br>&gt;&gt;<br>&gt;&gt; On Mon, Jul 11, 2016 at 9:35 PM, Mark Lacey &lt;mark.lacey at apple.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Jul 11, 2016, at 9:12 PM, Chris Lattner via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Jul 11, 2016, at 8:14 PM, Jacob Bandes-Storch via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; You&#39;d have to unwrap it, or use the ??/==/!= operators:<br>&gt;&gt;&gt; https://gist.github.com/jtbandes/9d88cc83ceceb6c62f38<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;d be okay with &lt;/&lt;=/&gt;/&gt;= returning Bool?, as I suggested in an older<br>&gt;&gt;&gt; email (which somehow didn&#39;t make it to gmane&#39;s archive, but it&#39;s quoted in some<br>&gt;&gt;&gt; other messages<br>&gt;&gt;&gt; &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/10095&gt;). I<br>&gt;&gt;&gt; think it would be more convenient in some cases than unwrapping the<br>&gt;&gt;&gt; individual values before comparing them.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I’d be strongly opposed to those operator returning “Bool?”.  Doing so<br>&gt;&gt;&gt; would prevent conforming to Comparable and would be extremely surprising.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I just pushed the current draft of the proposal:<br>&gt;&gt;&gt; https://github.com/rudkx/swift-evolution/blob/eliminate-value-to-optional-coercion/proposals/0000-disallow-value-to-optional-coercion-in-operator-arguments.md<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I haven’t addressed removal of the ordered comparison operators. I<br>&gt;&gt;&gt; suspect this should be a separate proposal, but I can roll that into this<br>&gt;&gt;&gt; one if it’s desired.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I’ll update the proposal as the discussion continues until it’s selected<br>&gt;&gt;&gt; for review.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Mark<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160712/2fb87cbd/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>Optional comparison operators</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>July 12, 2016 at 09:00:00am</p></header><div class="content"><p>An example to keep in mind:<br></p><p>let dict: [String : String] = ...<br>if dict[&quot;key&quot;] == &quot;value&quot; { // String? == String<br>	// Do something<br>}<br></p><p>If I understand correctly, when the proposal is accepted, you&#39;d need to do something like:<br></p><p>if let value = dict[&quot;key&quot;], value == &quot;value&quot; { } <br>-- OR --<br>if dict[&quot;key&quot;] == Optional(&quot;value&quot;) { }<br></p><p>It&#39;s not an end of the world, but makes life a bit more difficult and such usecase should be kept in mind.<br></p><p><br>&gt; On Jul 12, 2016, at 9:09 AM, Mark Lacey via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 11, 2016, at 11:55 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Mark,<br>&gt;&gt; Thanks for writing this up. Just to clarify, will these still work if your proposal is implemented?<br>&gt;&gt; <br>&gt;&gt;     let x: Int?<br>&gt;&gt;     let y: Int<br>&gt;&gt;     struct NotEquatable {}<br>&gt;&gt;     let z: NotEquatable?<br>&gt;&gt; <br>&gt;&gt;     x == y; x != y<br>&gt;&gt;     x == nil; x != nil<br>&gt;&gt;     z == nil; z != nil<br>&gt;&gt; <br>&gt;&gt; I would hope that these continue to work. If any changes need to be made to ensure that, please make sure they&#39;re included in the proposal too.<br>&gt; <br>&gt; The last four would work, but the first two (x == y and x != y) would not because they still involve coercing y to an optional.<br>&gt; <br>&gt; Similarly, === and !== on reference types where one is an optional would require coercing one side, and would not be accepted without an explicit cast using Optional().<br>&gt; <br>&gt; I’m curious what the motivation is for further special casing these operators. They do occur more in practice than &lt;, &lt;=, &gt;, &gt;= (in fact most of the source updates I had to make were due to === and !==, with == and != a close second), but overall these are still quite uncommon from what I’ve seen.<br>&gt; <br>&gt; If you’d like I can certainly update the “alternatives considered” to include the suggestion that we add overloads for (T, T?) and (T?, T) for those four operators.<br>&gt; <br>&gt; Mark<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Jacob<br>&gt;&gt; <br>&gt;&gt; On Mon, Jul 11, 2016 at 9:35 PM, Mark Lacey &lt;mark.lacey at apple.com &lt;mailto:mark.lacey at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 11, 2016, at 9:12 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jul 11, 2016, at 8:14 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You&#39;d have to unwrap it, or use the ??/==/!= operators: https://gist.github.com/jtbandes/9d88cc83ceceb6c62f38 &lt;https://gist.github.com/jtbandes/9d88cc83ceceb6c62f38&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;d be okay with &lt;/&lt;=/&gt;/&gt;= returning Bool?, as I suggested in an older email (which somehow didn&#39;t make it to gmane&#39;s archive, but it&#39;s quoted in some other messages &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/10095&gt;). I think it would be more convenient in some cases than unwrapping the individual values before comparing them.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’d be strongly opposed to those operator returning “Bool?”.  Doing so would prevent conforming to Comparable and would be extremely surprising.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt; I just pushed the current draft of the proposal: https://github.com/rudkx/swift-evolution/blob/eliminate-value-to-optional-coercion/proposals/0000-disallow-value-to-optional-coercion-in-operator-arguments.md &lt;https://github.com/rudkx/swift-evolution/blob/eliminate-value-to-optional-coercion/proposals/0000-disallow-value-to-optional-coercion-in-operator-arguments.md&gt;<br>&gt;&gt; <br>&gt;&gt; I haven’t addressed removal of the ordered comparison operators. I suspect this should be a separate proposal, but I can roll that into this one if it’s desired.<br>&gt;&gt; <br>&gt;&gt; I’ll update the proposal as the discussion continues until it’s selected for review.<br>&gt;&gt; <br>&gt;&gt; Mark<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160712/0397e539/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>Optional comparison operators</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>July 12, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jul 12, 2016, at 2:58 AM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; An example to keep in mind:<br>&gt; <br>&gt; let dict: [String : String] = ...<br>&gt; if dict[&quot;key&quot;] == &quot;value&quot; { // String? == String<br>&gt; 	// Do something<br>&gt; }<br>&gt; <br>&gt; If I understand correctly, when the proposal is accepted, you&#39;d need to do something like:<br>&gt; <br>&gt; if let value = dict[&quot;key&quot;], value == &quot;value&quot; { } <br>&gt; -- OR --<br>&gt; if dict[&quot;key&quot;] == Optional(&quot;value&quot;) { }<br>&gt; <br>&gt; It&#39;s not an end of the world, but makes life a bit more difficult and such usecase should be kept in mind.<br></p><p>It might not be the end of the world, but I’d argue that it’s terrible and I’d hate it. A lot.<br></p><p>l8r<br>Sean<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8149b5bd66abbc94babfda2995153481?s=50"></div><header><strong>Optional comparison operators</strong> from <string>Nevin Brackett-Rozinsky</string> &lt;nevin.brackettrozinsky at gmail.com&gt;<p>July 12, 2016 at 11:00:00am</p></header><div class="content"><p>Regarding the spelling of optional promotion, I think “postfix ?” could be<br>a solution. Notably, it already works in pattern matching (see the first<br>two case conditions here):<br></p><p>let anInt = 16<br>let anOpt = Optional(anInt)<br></p><p>switch anOpt {<br>case 2? : print(&quot;Deuces&quot;)<br>case anInt? : print(&quot;Huzzah&quot;)<br>default : print(&quot;Eh&quot;)<br>}<br></p><p>I propose we make ”postfix ?” be a general-purpose optionalizing operator,<br>which lets you write:<br></p><p>let anOpt = anInt?      // Optional&lt;Int&gt;.some(anInt)<br>let anotherOpt = 2?     // Optional&lt;Int&gt;.some(2)<br></p><p>Notably “?” would be essentially the inverse of “!”, so given the above we<br>would have:<br></p><p>anInt == anOpt!<br>2 == anotherOpt!<br></p><p>If we could write it ourselves the implementation would be simply,<br></p><p>postfix operator ? {}<br>postfix func ? &lt;T&gt; (value: T) -&gt; T? { return Optional(value) }<br></p><p>The “?” syntax is so light that we could seriously consider removing all<br>implicit promotion to optionals, and just use “?”. Thus:<br></p><p>func takesOptionalInt(_ x: Int?) { }<br></p><p>takesOptionalInt(2?)<br>takesOptionalInt(anInt?)<br>takesOptionalInt(anOpt)<br></p><p>In general, anytime you have a value that you want to promote to an<br>optional, you would just put a “?” after it.<br></p><p>The one place I see where ambiguity can arise is optional chaining. I think<br>“anOpt?.someMethodOnInt()” should use optional chaining, whereas explicit<br>promotion followed by member access would need parentheses:<br>“(anOpt?).someMethodOnDoubleOptional()”.<br></p><p>In particular, “anInt?.something()” should probably be a syntax error<br>(attempting to using optional chaining on non-optional value), it should<br>not silently become “(anInt?).something()” — that would have to use<br>parentheses.<br></p><p>Anyway, that’s my idea: “postfix ?” for general-purpose optional wrapping.<br></p><p>Is this worthy of consideration?<br>Should it be part of the current proposal or spun off separately?<br>Would “postfix ?” sufficiently soften the landing to enable the elimination<br>of implicit optional-promotion across the board?<br>And is there a better way to handle its interaction with optional chaining?<br></p><p>Thanks,<br>Nevin<br></p><p><br></p><p>On Tue, Jul 12, 2016 at 3:58 AM, Charlie Monroe via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; An example to keep in mind:<br>&gt;<br>&gt; let dict: [String : String] = ...<br>&gt; if dict[&quot;key&quot;] == &quot;value&quot; { // String? == String<br>&gt; // Do something<br>&gt; }<br>&gt;<br>&gt; If I understand correctly, when the proposal is accepted, you&#39;d need to do<br>&gt; something like:<br>&gt;<br>&gt; if let value = dict[&quot;key&quot;], value == &quot;value&quot; { }<br>&gt; -- OR --<br>&gt; if dict[&quot;key&quot;] == Optional(&quot;value&quot;) { }<br>&gt;<br>&gt; It&#39;s not an end of the world, but makes life a bit more difficult and such<br>&gt; usecase should be kept in mind.<br>&gt;<br>&gt;<br>&gt; On Jul 12, 2016, at 9:09 AM, Mark Lacey via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Jul 11, 2016, at 11:55 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; Mark,<br>&gt; Thanks for writing this up. Just to clarify, will these still work if your<br>&gt; proposal is implemented?<br>&gt;<br>&gt;     let x: Int?<br>&gt;     let y: Int<br>&gt;     struct NotEquatable {}<br>&gt;     let z: NotEquatable?<br>&gt;<br>&gt;     x == y; x != y<br>&gt;     x == nil; x != nil<br>&gt;     z == nil; z != nil<br>&gt;<br>&gt; I would hope that these continue to work. If any changes need to be made<br>&gt; to ensure that, please make sure they&#39;re included in the proposal too.<br>&gt;<br>&gt;<br>&gt; The last four would work, but the first two (x == y and x != y) would not<br>&gt; because they still involve coercing y to an optional.<br>&gt;<br>&gt; Similarly, === and !== on reference types where one is an optional would<br>&gt; require coercing one side, and would not be accepted without an explicit<br>&gt; cast using Optional().<br>&gt;<br>&gt; I’m curious what the motivation is for further special casing these<br>&gt; operators. They do occur more in practice than &lt;, &lt;=, &gt;, &gt;= (in fact most<br>&gt; of the source updates I had to make were due to === and !==, with == and !=<br>&gt; a close second), but overall these are still quite uncommon from what I’ve<br>&gt; seen.<br>&gt;<br>&gt; If you’d like I can certainly update the “alternatives considered” to<br>&gt; include the suggestion that we add overloads for (T, T?) and (T?, T) for<br>&gt; those four operators.<br>&gt;<br>&gt; Mark<br>&gt;<br>&gt;<br>&gt; Jacob<br>&gt;<br>&gt; On Mon, Jul 11, 2016 at 9:35 PM, Mark Lacey &lt;mark.lacey at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Jul 11, 2016, at 9:12 PM, Chris Lattner via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Jul 11, 2016, at 8:14 PM, Jacob Bandes-Storch via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; You&#39;d have to unwrap it, or use the ??/==/!= operators:<br>&gt;&gt; https://gist.github.com/jtbandes/9d88cc83ceceb6c62f38<br>&gt;&gt;<br>&gt;&gt; I&#39;d be okay with &lt;/&lt;=/&gt;/&gt;= returning Bool?, as I suggested in an older<br>&gt;&gt; email (which somehow didn&#39;t make it to gmane&#39;s archive, but it&#39;s quoted in some<br>&gt;&gt; other messages<br>&gt;&gt; &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/10095&gt;). I<br>&gt;&gt; think it would be more convenient in some cases than unwrapping the<br>&gt;&gt; individual values before comparing them.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I’d be strongly opposed to those operator returning “Bool?”.  Doing so<br>&gt;&gt; would prevent conforming to Comparable and would be extremely surprising.<br>&gt;&gt;<br>&gt;&gt; -Chris<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I just pushed the current draft of the proposal:<br>&gt;&gt; https://github.com/rudkx/swift-evolution/blob/eliminate-value-to-optional-coercion/proposals/0000-disallow-value-to-optional-coercion-in-operator-arguments.md<br>&gt;&gt;<br>&gt;&gt; I haven’t addressed removal of the ordered comparison operators. I<br>&gt;&gt; suspect this should be a separate proposal, but I can roll that into this<br>&gt;&gt; one if it’s desired.<br>&gt;&gt;<br>&gt;&gt; I’ll update the proposal as the discussion continues until it’s selected<br>&gt;&gt; for review.<br>&gt;&gt;<br>&gt;&gt; Mark<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160712/b56d6e69/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Optional comparison operators</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>July 12, 2016 at 10:00:00am</p></header><div class="content"><p>I&#39;ve thought of this before, too, and I agree that it&#39;s light enough it<br>could probably replace implicit promotion. That said, I&#39;m not convinced<br>we&#39;d really want to remove implicit promotion everywhere.<br></p><p>I&#39;d also be concerned that &quot;postfix ?&quot; is becoming too overloaded — it&#39;s<br>already used in optional chaining (where it sort of &quot;removes&quot; a layer of<br>optionality), and it&#39;s the &quot;optional pattern&quot; for case statements...this<br>idea would see it used with non-optional values being passed to optional<br>parameters, and there&#39;s another thread started recently which (although it<br>seems unlikely to happen in the near future) would see it used with<br>optional values being passed to non-optional parameters. &quot;postfix ?&quot; just<br>becomes the &quot;solve all my problems&quot; operator, and I&#39;m pretty sure<br>readability would suffer for it.<br></p><p>Jacob<br></p><p>On Tue, Jul 12, 2016 at 8:33 AM, Nevin Brackett-Rozinsky via<br>swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Regarding the spelling of optional promotion, I think “postfix ?” could be<br>&gt; a solution. Notably, it already works in pattern matching (see the first<br>&gt; two case conditions here):<br>&gt;<br>&gt; let anInt = 16<br>&gt; let anOpt = Optional(anInt)<br>&gt;<br>&gt; switch anOpt {<br>&gt; case 2? : print(&quot;Deuces&quot;)<br>&gt; case anInt? : print(&quot;Huzzah&quot;)<br>&gt; default : print(&quot;Eh&quot;)<br>&gt; }<br>&gt;<br>&gt; I propose we make ”postfix ?” be a general-purpose optionalizing operator,<br>&gt; which lets you write:<br>&gt;<br>&gt; let anOpt = anInt?      // Optional&lt;Int&gt;.some(anInt)<br>&gt; let anotherOpt = 2?     // Optional&lt;Int&gt;.some(2)<br>&gt;<br>&gt; Notably “?” would be essentially the inverse of “!”, so given the above we<br>&gt; would have:<br>&gt;<br>&gt; anInt == anOpt!<br>&gt; 2 == anotherOpt!<br>&gt;<br>&gt; If we could write it ourselves the implementation would be simply,<br>&gt;<br>&gt; postfix operator ? {}<br>&gt; postfix func ? &lt;T&gt; (value: T) -&gt; T? { return Optional(value) }<br>&gt;<br>&gt; The “?” syntax is so light that we could seriously consider removing all<br>&gt; implicit promotion to optionals, and just use “?”. Thus:<br>&gt;<br>&gt; func takesOptionalInt(_ x: Int?) { }<br>&gt;<br>&gt; takesOptionalInt(2?)<br>&gt; takesOptionalInt(anInt?)<br>&gt; takesOptionalInt(anOpt)<br>&gt;<br>&gt; In general, anytime you have a value that you want to promote to an<br>&gt; optional, you would just put a “?” after it.<br>&gt;<br>&gt; The one place I see where ambiguity can arise is optional chaining. I<br>&gt; think “anOpt?.someMethodOnInt()” should use optional chaining, whereas<br>&gt; explicit promotion followed by member access would need parentheses:<br>&gt; “(anOpt?).someMethodOnDoubleOptional()”.<br>&gt;<br>&gt; In particular, “anInt?.something()” should probably be a syntax error<br>&gt; (attempting to using optional chaining on non-optional value), it should<br>&gt; not silently become “(anInt?).something()” — that would have to use<br>&gt; parentheses.<br>&gt;<br>&gt; Anyway, that’s my idea: “postfix ?” for general-purpose optional wrapping.<br>&gt;<br>&gt; Is this worthy of consideration?<br>&gt; Should it be part of the current proposal or spun off separately?<br>&gt; Would “postfix ?” sufficiently soften the landing to enable the<br>&gt; elimination of implicit optional-promotion across the board?<br>&gt; And is there a better way to handle its interaction with optional chaining?<br>&gt;<br>&gt; Thanks,<br>&gt; Nevin<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Tue, Jul 12, 2016 at 3:58 AM, Charlie Monroe via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; An example to keep in mind:<br>&gt;&gt;<br>&gt;&gt; let dict: [String : String] = ...<br>&gt;&gt; if dict[&quot;key&quot;] == &quot;value&quot; { // String? == String<br>&gt;&gt; // Do something<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; If I understand correctly, when the proposal is accepted, you&#39;d need to<br>&gt;&gt; do something like:<br>&gt;&gt;<br>&gt;&gt; if let value = dict[&quot;key&quot;], value == &quot;value&quot; { }<br>&gt;&gt; -- OR --<br>&gt;&gt; if dict[&quot;key&quot;] == Optional(&quot;value&quot;) { }<br>&gt;&gt;<br>&gt;&gt; It&#39;s not an end of the world, but makes life a bit more difficult and<br>&gt;&gt; such usecase should be kept in mind.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Jul 12, 2016, at 9:09 AM, Mark Lacey via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Jul 11, 2016, at 11:55 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Mark,<br>&gt;&gt; Thanks for writing this up. Just to clarify, will these still work if<br>&gt;&gt; your proposal is implemented?<br>&gt;&gt;<br>&gt;&gt;     let x: Int?<br>&gt;&gt;     let y: Int<br>&gt;&gt;     struct NotEquatable {}<br>&gt;&gt;     let z: NotEquatable?<br>&gt;&gt;<br>&gt;&gt;     x == y; x != y<br>&gt;&gt;     x == nil; x != nil<br>&gt;&gt;     z == nil; z != nil<br>&gt;&gt;<br>&gt;&gt; I would hope that these continue to work. If any changes need to be made<br>&gt;&gt; to ensure that, please make sure they&#39;re included in the proposal too.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; The last four would work, but the first two (x == y and x != y) would not<br>&gt;&gt; because they still involve coercing y to an optional.<br>&gt;&gt;<br>&gt;&gt; Similarly, === and !== on reference types where one is an optional would<br>&gt;&gt; require coercing one side, and would not be accepted without an explicit<br>&gt;&gt; cast using Optional().<br>&gt;&gt;<br>&gt;&gt; I’m curious what the motivation is for further special casing these<br>&gt;&gt; operators. They do occur more in practice than &lt;, &lt;=, &gt;, &gt;= (in fact most<br>&gt;&gt; of the source updates I had to make were due to === and !==, with == and !=<br>&gt;&gt; a close second), but overall these are still quite uncommon from what I’ve<br>&gt;&gt; seen.<br>&gt;&gt;<br>&gt;&gt; If you’d like I can certainly update the “alternatives considered” to<br>&gt;&gt; include the suggestion that we add overloads for (T, T?) and (T?, T) for<br>&gt;&gt; those four operators.<br>&gt;&gt;<br>&gt;&gt; Mark<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Jacob<br>&gt;&gt;<br>&gt;&gt; On Mon, Jul 11, 2016 at 9:35 PM, Mark Lacey &lt;mark.lacey at apple.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Jul 11, 2016, at 9:12 PM, Chris Lattner via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Jul 11, 2016, at 8:14 PM, Jacob Bandes-Storch via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; You&#39;d have to unwrap it, or use the ??/==/!= operators:<br>&gt;&gt;&gt; https://gist.github.com/jtbandes/9d88cc83ceceb6c62f38<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;d be okay with &lt;/&lt;=/&gt;/&gt;= returning Bool?, as I suggested in an older<br>&gt;&gt;&gt; email (which somehow didn&#39;t make it to gmane&#39;s archive, but it&#39;s quoted in some<br>&gt;&gt;&gt; other messages<br>&gt;&gt;&gt; &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/10095&gt;). I<br>&gt;&gt;&gt; think it would be more convenient in some cases than unwrapping the<br>&gt;&gt;&gt; individual values before comparing them.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I’d be strongly opposed to those operator returning “Bool?”.  Doing so<br>&gt;&gt;&gt; would prevent conforming to Comparable and would be extremely surprising.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I just pushed the current draft of the proposal:<br>&gt;&gt;&gt; https://github.com/rudkx/swift-evolution/blob/eliminate-value-to-optional-coercion/proposals/0000-disallow-value-to-optional-coercion-in-operator-arguments.md<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I haven’t addressed removal of the ordered comparison operators. I<br>&gt;&gt;&gt; suspect this should be a separate proposal, but I can roll that into this<br>&gt;&gt;&gt; one if it’s desired.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I’ll update the proposal as the discussion continues until it’s selected<br>&gt;&gt;&gt; for review.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Mark<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160712/f8718dd6/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8e77369a540cf4d35924683e176c7a9c?s=50"></div><header><strong>Optional comparison operators</strong> from <string>Mark Lacey</string> &lt;mark.lacey at apple.com&gt;<p>July 12, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jul 12, 2016, at 12:58 AM, Charlie Monroe &lt;charlie at charliemonroe.net&gt; wrote:<br>&gt; <br>&gt; An example to keep in mind:<br>&gt; <br>&gt; let dict: [String : String] = ...<br>&gt; if dict[&quot;key&quot;] == &quot;value&quot; { // String? == String<br>&gt; 	// Do something<br>&gt; }<br>&gt; <br>&gt; If I understand correctly, when the proposal is accepted, you&#39;d need to do something like:<br>&gt; <br>&gt; if let value = dict[&quot;key&quot;], value == &quot;value&quot; { } <br>&gt; -- OR --<br>&gt; if dict[&quot;key&quot;] == Optional(&quot;value&quot;) { }<br>&gt; <br>&gt; It&#39;s not an end of the world, but makes life a bit more difficult and such usecase should be kept in mind.<br></p><p>Yes, Jacob also pointed this out.<br></p><p>Sometime later today I will push out an updated proposal that calls this out, and also discusses the overloads for equality and identity comparisons where one side is optional. I want to take another quick look at some of the changes I had to make to projects I looked at before I do so.<br></p><p>Mark<br></p><p>&gt; <br>&gt; <br>&gt;&gt; On Jul 12, 2016, at 9:09 AM, Mark Lacey via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 11, 2016, at 11:55 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Mark,<br>&gt;&gt;&gt; Thanks for writing this up. Just to clarify, will these still work if your proposal is implemented?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     let x: Int?<br>&gt;&gt;&gt;     let y: Int<br>&gt;&gt;&gt;     struct NotEquatable {}<br>&gt;&gt;&gt;     let z: NotEquatable?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     x == y; x != y<br>&gt;&gt;&gt;     x == nil; x != nil<br>&gt;&gt;&gt;     z == nil; z != nil<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would hope that these continue to work. If any changes need to be made to ensure that, please make sure they&#39;re included in the proposal too.<br>&gt;&gt; <br>&gt;&gt; The last four would work, but the first two (x == y and x != y) would not because they still involve coercing y to an optional.<br>&gt;&gt; <br>&gt;&gt; Similarly, === and !== on reference types where one is an optional would require coercing one side, and would not be accepted without an explicit cast using Optional().<br>&gt;&gt; <br>&gt;&gt; I’m curious what the motivation is for further special casing these operators. They do occur more in practice than &lt;, &lt;=, &gt;, &gt;= (in fact most of the source updates I had to make were due to === and !==, with == and != a close second), but overall these are still quite uncommon from what I’ve seen.<br>&gt;&gt; <br>&gt;&gt; If you’d like I can certainly update the “alternatives considered” to include the suggestion that we add overloads for (T, T?) and (T?, T) for those four operators.<br>&gt;&gt; <br>&gt;&gt; Mark<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Jacob<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Mon, Jul 11, 2016 at 9:35 PM, Mark Lacey &lt;mark.lacey at apple.com &lt;mailto:mark.lacey at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jul 11, 2016, at 9:12 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jul 11, 2016, at 8:14 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; You&#39;d have to unwrap it, or use the ??/==/!= operators: https://gist.github.com/jtbandes/9d88cc83ceceb6c62f38 &lt;https://gist.github.com/jtbandes/9d88cc83ceceb6c62f38&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;d be okay with &lt;/&lt;=/&gt;/&gt;= returning Bool?, as I suggested in an older email (which somehow didn&#39;t make it to gmane&#39;s archive, but it&#39;s quoted in some other messages &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/10095&gt;). I think it would be more convenient in some cases than unwrapping the individual values before comparing them.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’d be strongly opposed to those operator returning “Bool?”.  Doing so would prevent conforming to Comparable and would be extremely surprising.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I just pushed the current draft of the proposal: https://github.com/rudkx/swift-evolution/blob/eliminate-value-to-optional-coercion/proposals/0000-disallow-value-to-optional-coercion-in-operator-arguments.md &lt;https://github.com/rudkx/swift-evolution/blob/eliminate-value-to-optional-coercion/proposals/0000-disallow-value-to-optional-coercion-in-operator-arguments.md&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I haven’t addressed removal of the ordered comparison operators. I suspect this should be a separate proposal, but I can roll that into this one if it’s desired.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’ll update the proposal as the discussion continues until it’s selected for review.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Mark<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160712/61e915ee/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
