<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Revisiting SE-0041 Names</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June 27, 2016 at 07:00:00am</p></header><div class="content"><p>on Wed Jun 22 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; On Jun 22, 2016, at 1:55 PM, Dmitri Gribenko<br>&gt;&gt; &lt;gribozavr at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Wed, Jun 22, 2016 at 11:04 AM, Erica Sadun via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;&gt; Proposal:<br>&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0041-conversion-protocol-conventions.md<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Rejection: &quot;The feedback on the proposal was generally positive about the<br>&gt;&gt;&gt; idea of renaming these protocols, but the specific names in the proposal are<br>&gt;&gt;&gt; not well received, and there is no apparent confluence in the community on<br>&gt;&gt;&gt; better names.  The core team prefers discussion to continue -- if/when there<br>&gt;&gt;&gt; is a strong proposal for a better naming approach, we can reconsider<br>&gt;&gt;&gt; renaming these.&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; John McCall: &quot;To be clear, I don&#39;t care about the name.  If you want to<br>&gt;&gt;&gt; rename IntegerLiteralConvertible to IntegerLiteral or whatever, I won&#39;t drag<br>&gt;&gt;&gt; the conversation into the muck again. :)  It&#39;s the design of the<br>&gt;&gt;&gt; requirements that I&#39;m pretty opposed to revisiting.&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The Problem: This is really the last chance to rationalize this across the<br>&gt;&gt;&gt; language and to evaluate whether other protocol groups should have a core<br>&gt;&gt;&gt; scheme for naming.<br>&gt;&gt; <br>&gt;&gt; Hi Erica,<br>&gt;&gt; <br>&gt;&gt; I would like to re-state the feedback from Dave Abrahams, Max Moiseev<br>&gt;&gt; and me from the last time this was discussed.  Unfortunately I can&#39;t<br>&gt;&gt; find the exact email, so I can&#39;t provide a link.<br>&gt;&gt; <br>&gt;&gt; - The &quot;literal&quot; protocols are not about conversion, they are about<br>&gt;&gt; adopting a certain syntax provided by the language.  &quot;Convertible&quot; in<br>&gt;&gt; the name is a red herring: a type can&#39;t be convertible from an integer<br>&gt;&gt; literal because there is no &quot;IntegerLiteral&quot; entity in the type<br>&gt;&gt; system.  The literal *becomes* typed as the corresponding literal type<br>&gt;&gt; (e.g., Int or String), and as far as the user at the call site is<br>&gt;&gt; concerned, there is no visible conversion (even if one is happening<br>&gt;&gt; behind the scenes).<br>&gt;&gt; <br>&gt;&gt; Our suggestion was to focus on the &quot;adopting the syntax&quot; part.  We<br>&gt;&gt; suggested moving the &quot;literal convertible&quot; protocols into a<br>&gt;&gt; pseudo-namespace &quot;Syntax&quot;.  It could be implemented like this:<br>&gt;&gt; <br>&gt;&gt; protocol _IntegerLiteralSyntax {}<br>&gt;&gt; enum Syntax {<br>&gt;&gt;  typealias IntegerLiteral = _IntegerLiteralSyntax<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; And used like this:<br>&gt;&gt; <br>&gt;&gt; struct Int : Syntax.IntegerLiteral {}<br>&gt;<br>&gt; I’m working on a draft of this proposal right now.  I have a couple questions.  <br>&gt;<br>&gt; First, I’d like to list the standard library team as co-authors if you<br>&gt; desire because this is really your idea.  Let me know what you would<br>&gt; prefer.<br>&gt;<br>&gt; Second, I wonder if it might make more sense to name the protocols<br>&gt; `Syntax.IntegerLiteralInitializable`.  Dave has opposed<br>&gt; `Initializable` as a general convention because it implies pure syntax<br>&gt; and doesn’t carry any semantics.  But in this case the semantics *are*<br>&gt; essentially the syntax.  Erica pointed out to me off list that at the<br>&gt; usage site the `Syntax.IntegerLiteral` names could confuse somebody<br>&gt; into thinking in terms of *isa* rather than *can do* (i.e. Int is an<br>&gt; IntegerLiteral rather than Int can be *initialized* with an<br>&gt; IntegerLiteral).<br></p><p>Really, this is exactly the sense in which we want it to be interpreted.<br>It is *not* a capability.  There is no such thing as an IntegerLiteral<br>instance from which one can initialize an Int.  There are only syntactic<br>integer literals, which, given the right type context, can be-a Int.<br>The intializer one gets from the protocol is merely the mechanism used<br>by the compiler to create this Int.<br></p><p>&gt;<br>&gt; Please let me know if this name change would be acceptable to the<br>&gt; standard library team or may be met with resistance.  I want this<br>&gt; proposal to be acceptable to the team from the start.<br>&gt;<br>&gt; Matthew<br>&gt;<br>&gt;&gt; <br>&gt;&gt; - For protocols that are representing conversions between types that<br>&gt;&gt; actually exist in the library, there is not enough precedent yet to<br>&gt;&gt; make a general conclusion and standardize a pattern.<br>&gt;&gt; <br>&gt;&gt; Dmitri<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt;&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko<br>&gt;&gt; &lt;gribozavr at gmail.com<br>&gt;&gt; &lt;mailto:gribozavr at gmail.com&gt;&gt;*/<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Revisiting SE-0041 Names</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 27, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jun 27, 2016, at 9:29 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Wed Jun 22 2016, Matthew Johnson &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Jun 22, 2016, at 1:55 PM, Dmitri Gribenko<br>&gt;&gt;&gt; &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Wed, Jun 22, 2016 at 11:04 AM, Erica Sadun via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; Proposal:<br>&gt;&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0041-conversion-protocol-conventions.md<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Rejection: &quot;The feedback on the proposal was generally positive about the<br>&gt;&gt;&gt;&gt; idea of renaming these protocols, but the specific names in the proposal are<br>&gt;&gt;&gt;&gt; not well received, and there is no apparent confluence in the community on<br>&gt;&gt;&gt;&gt; better names.  The core team prefers discussion to continue -- if/when there<br>&gt;&gt;&gt;&gt; is a strong proposal for a better naming approach, we can reconsider<br>&gt;&gt;&gt;&gt; renaming these.&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; John McCall: &quot;To be clear, I don&#39;t care about the name.  If you want to<br>&gt;&gt;&gt;&gt; rename IntegerLiteralConvertible to IntegerLiteral or whatever, I won&#39;t drag<br>&gt;&gt;&gt;&gt; the conversation into the muck again. :)  It&#39;s the design of the<br>&gt;&gt;&gt;&gt; requirements that I&#39;m pretty opposed to revisiting.&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The Problem: This is really the last chance to rationalize this across the<br>&gt;&gt;&gt;&gt; language and to evaluate whether other protocol groups should have a core<br>&gt;&gt;&gt;&gt; scheme for naming.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi Erica,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would like to re-state the feedback from Dave Abrahams, Max Moiseev<br>&gt;&gt;&gt; and me from the last time this was discussed.  Unfortunately I can&#39;t<br>&gt;&gt;&gt; find the exact email, so I can&#39;t provide a link.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - The &quot;literal&quot; protocols are not about conversion, they are about<br>&gt;&gt;&gt; adopting a certain syntax provided by the language.  &quot;Convertible&quot; in<br>&gt;&gt;&gt; the name is a red herring: a type can&#39;t be convertible from an integer<br>&gt;&gt;&gt; literal because there is no &quot;IntegerLiteral&quot; entity in the type<br>&gt;&gt;&gt; system.  The literal *becomes* typed as the corresponding literal type<br>&gt;&gt;&gt; (e.g., Int or String), and as far as the user at the call site is<br>&gt;&gt;&gt; concerned, there is no visible conversion (even if one is happening<br>&gt;&gt;&gt; behind the scenes).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Our suggestion was to focus on the &quot;adopting the syntax&quot; part.  We<br>&gt;&gt;&gt; suggested moving the &quot;literal convertible&quot; protocols into a<br>&gt;&gt;&gt; pseudo-namespace &quot;Syntax&quot;.  It could be implemented like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol _IntegerLiteralSyntax {}<br>&gt;&gt;&gt; enum Syntax {<br>&gt;&gt;&gt; typealias IntegerLiteral = _IntegerLiteralSyntax<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And used like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Int : Syntax.IntegerLiteral {}<br>&gt;&gt; <br>&gt;&gt; I’m working on a draft of this proposal right now.  I have a couple questions.  <br>&gt;&gt; <br>&gt;&gt; First, I’d like to list the standard library team as co-authors if you<br>&gt;&gt; desire because this is really your idea.  Let me know what you would<br>&gt;&gt; prefer.<br>&gt;&gt; <br>&gt;&gt; Second, I wonder if it might make more sense to name the protocols<br>&gt;&gt; `Syntax.IntegerLiteralInitializable`.  Dave has opposed<br>&gt;&gt; `Initializable` as a general convention because it implies pure syntax<br>&gt;&gt; and doesn’t carry any semantics.  But in this case the semantics *are*<br>&gt;&gt; essentially the syntax.  Erica pointed out to me off list that at the<br>&gt;&gt; usage site the `Syntax.IntegerLiteral` names could confuse somebody<br>&gt;&gt; into thinking in terms of *isa* rather than *can do* (i.e. Int is an<br>&gt;&gt; IntegerLiteral rather than Int can be *initialized* with an<br>&gt;&gt; IntegerLiteral).<br>&gt; <br>&gt; Really, this is exactly the sense in which we want it to be interpreted.<br>&gt; It is *not* a capability.  There is no such thing as an IntegerLiteral<br>&gt; instance from which one can initialize an Int.  There are only syntactic<br>&gt; integer literals, which, given the right type context, can be-a Int.<br>&gt; The intializer one gets from the protocol is merely the mechanism used<br>&gt; by the compiler to create this Int.<br></p><p>That is a technically correct statement, but I think the model most programmers will have (good or bad) is of initializing with an integer literal.  I think this is evidenced to some degree by the feedback people are providing on the names.<br></p><p>That said, I am trying to stay out of the fray of the bike shedding on this.  IMO the most important thing is to do *something* here as long as its reasonable and the solution suggested by the standard library team is definitely reasonable.  That is why I have written the proposal exactly as the standard library team suggested.  :)  <br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; Please let me know if this name change would be acceptable to the<br>&gt;&gt; standard library team or may be met with resistance.  I want this<br>&gt;&gt; proposal to be acceptable to the team from the start.<br>&gt;&gt; <br>&gt;&gt; Matthew<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - For protocols that are representing conversions between types that<br>&gt;&gt;&gt; actually exist in the library, there is not enough precedent yet to<br>&gt;&gt;&gt; make a general conclusion and standardize a pattern.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Dmitri<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt;&gt;&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko<br>&gt;&gt;&gt; &lt;gribozavr at gmail.com<br>&gt;&gt;&gt; &lt;mailto:gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt;&gt;*/<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/74e70159/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Revisiting SE-0041 Names</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June 27, 2016 at 09:00:00am</p></header><div class="content"><p>on Mon Jun 27 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br></p><p>&gt;&gt; On Jun 27, 2016, at 9:29 AM, Dave Abrahams via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Wed Jun 22 2016, Matthew Johnson &lt;swift-evolution at swift.org<br>&gt;<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 22, 2016, at 1:55 PM, Dmitri Gribenko<br>&gt;&gt;&gt;&gt; &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Wed, Jun 22, 2016 at 11:04 AM, Erica Sadun via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; Proposal:<br>&gt;&gt;&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0041-conversion-protocol-conventions.md<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Rejection: &quot;The feedback on the proposal was generally positive about the<br>&gt;&gt;&gt;&gt;&gt; idea of renaming these protocols, but the specific names in the proposal are<br>&gt;&gt;&gt;&gt;&gt; not well received, and there is no apparent confluence in the community on<br>&gt;&gt;&gt;&gt;&gt; better names.  The core team prefers discussion to continue -- if/when there<br>&gt;&gt;&gt;&gt;&gt; is a strong proposal for a better naming approach, we can reconsider<br>&gt;&gt;&gt;&gt;&gt; renaming these.&quot;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; John McCall: &quot;To be clear, I don&#39;t care about the name.  If you want to<br>&gt;&gt;&gt;&gt;&gt; rename IntegerLiteralConvertible to IntegerLiteral or whatever, I won&#39;t drag<br>&gt;&gt;&gt;&gt;&gt; the conversation into the muck again. :)  It&#39;s the design of the<br>&gt;&gt;&gt;&gt;&gt; requirements that I&#39;m pretty opposed to revisiting.&quot;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The Problem: This is really the last chance to rationalize this across the<br>&gt;&gt;&gt;&gt;&gt; language and to evaluate whether other protocol groups should have a core<br>&gt;&gt;&gt;&gt;&gt; scheme for naming.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi Erica,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I would like to re-state the feedback from Dave Abrahams, Max Moiseev<br>&gt;&gt;&gt;&gt; and me from the last time this was discussed.  Unfortunately I can&#39;t<br>&gt;&gt;&gt;&gt; find the exact email, so I can&#39;t provide a link.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - The &quot;literal&quot; protocols are not about conversion, they are about<br>&gt;&gt;&gt;&gt; adopting a certain syntax provided by the language.  &quot;Convertible&quot; in<br>&gt;&gt;&gt;&gt; the name is a red herring: a type can&#39;t be convertible from an integer<br>&gt;&gt;&gt;&gt; literal because there is no &quot;IntegerLiteral&quot; entity in the type<br>&gt;&gt;&gt;&gt; system.  The literal *becomes* typed as the corresponding literal type<br>&gt;&gt;&gt;&gt; (e.g., Int or String), and as far as the user at the call site is<br>&gt;&gt;&gt;&gt; concerned, there is no visible conversion (even if one is happening<br>&gt;&gt;&gt;&gt; behind the scenes).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Our suggestion was to focus on the &quot;adopting the syntax&quot; part.  We<br>&gt;&gt;&gt;&gt; suggested moving the &quot;literal convertible&quot; protocols into a<br>&gt;&gt;&gt;&gt; pseudo-namespace &quot;Syntax&quot;.  It could be implemented like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol _IntegerLiteralSyntax {}<br>&gt;&gt;&gt;&gt; enum Syntax {<br>&gt;&gt;&gt;&gt; typealias IntegerLiteral = _IntegerLiteralSyntax<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And used like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct Int : Syntax.IntegerLiteral {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m working on a draft of this proposal right now.  I have a couple questions.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; First, I’d like to list the standard library team as co-authors if you<br>&gt;&gt;&gt; desire because this is really your idea.  Let me know what you would<br>&gt;&gt;&gt; prefer.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Second, I wonder if it might make more sense to name the protocols<br>&gt;&gt;&gt; `Syntax.IntegerLiteralInitializable`.  Dave has opposed<br>&gt;&gt;&gt; `Initializable` as a general convention because it implies pure syntax<br>&gt;&gt;&gt; and doesn’t carry any semantics.  But in this case the semantics *are*<br>&gt;&gt;&gt; essentially the syntax.  Erica pointed out to me off list that at the<br>&gt;&gt;&gt; usage site the `Syntax.IntegerLiteral` names could confuse somebody<br>&gt;&gt;&gt; into thinking in terms of *isa* rather than *can do* (i.e. Int is an<br>&gt;&gt;&gt; IntegerLiteral rather than Int can be *initialized* with an<br>&gt;&gt;&gt; IntegerLiteral).<br>&gt;&gt; <br>&gt;&gt; Really, this is exactly the sense in which we want it to be interpreted.<br>&gt;&gt; It is *not* a capability.  There is no such thing as an IntegerLiteral<br>&gt;&gt; instance from which one can initialize an Int.  There are only syntactic<br>&gt;&gt; integer literals, which, given the right type context, can be-a Int.<br>&gt;&gt; The intializer one gets from the protocol is merely the mechanism used<br>&gt;&gt; by the compiler to create this Int.<br>&gt;<br>&gt; That is a technically correct statement, but I think the model most<br>&gt; programmers will have (good or bad) is of initializing with an integer<br>&gt; literal.  I think this is evidenced to some degree by the feedback<br>&gt; people are providing on the names.<br></p><p>Yes, that&#39;s a very strong reason not to name the protocols so as to<br>encourage that misinterpretation. :-)<br></p><p>&gt; That said, I am trying to stay out of the fray of the bike shedding on<br>&gt; this.  IMO the most important thing is to do *something* here as long<br>&gt; as its reasonable and the solution suggested by the standard library<br>&gt; team is definitely reasonable.  That is why I have written the<br>&gt; proposal exactly as the standard library team suggested.  :)<br></p><p>Thank you.<br></p><p>-- <br>-Dave<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Revisiting SE-0041 Names</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June 27, 2016 at 07:00:00pm</p></header><div class="content"><p>Regards<br>LM<br>(From mobile)<br></p><p>&gt; On Jun 27, 2016, at 4:45 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 27, 2016, at 9:29 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Wed Jun 22 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 22, 2016, at 1:55 PM, Dmitri Gribenko<br>&gt;&gt;&gt;&gt; &lt;gribozavr at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Wed, Jun 22, 2016 at 11:04 AM, Erica Sadun via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; Proposal:<br>&gt;&gt;&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0041-conversion-protocol-conventions.md<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Rejection: &quot;The feedback on the proposal was generally positive about the<br>&gt;&gt;&gt;&gt;&gt; idea of renaming these protocols, but the specific names in the proposal are<br>&gt;&gt;&gt;&gt;&gt; not well received, and there is no apparent confluence in the community on<br>&gt;&gt;&gt;&gt;&gt; better names.  The core team prefers discussion to continue -- if/when there<br>&gt;&gt;&gt;&gt;&gt; is a strong proposal for a better naming approach, we can reconsider<br>&gt;&gt;&gt;&gt;&gt; renaming these.&quot;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; John McCall: &quot;To be clear, I don&#39;t care about the name.  If you want to<br>&gt;&gt;&gt;&gt;&gt; rename IntegerLiteralConvertible to IntegerLiteral or whatever, I won&#39;t drag<br>&gt;&gt;&gt;&gt;&gt; the conversation into the muck again. :)  It&#39;s the design of the<br>&gt;&gt;&gt;&gt;&gt; requirements that I&#39;m pretty opposed to revisiting.&quot;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The Problem: This is really the last chance to rationalize this across the<br>&gt;&gt;&gt;&gt;&gt; language and to evaluate whether other protocol groups should have a core<br>&gt;&gt;&gt;&gt;&gt; scheme for naming.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi Erica,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I would like to re-state the feedback from Dave Abrahams, Max Moiseev<br>&gt;&gt;&gt;&gt; and me from the last time this was discussed.  Unfortunately I can&#39;t<br>&gt;&gt;&gt;&gt; find the exact email, so I can&#39;t provide a link.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - The &quot;literal&quot; protocols are not about conversion, they are about<br>&gt;&gt;&gt;&gt; adopting a certain syntax provided by the language.  &quot;Convertible&quot; in<br>&gt;&gt;&gt;&gt; the name is a red herring: a type can&#39;t be convertible from an integer<br>&gt;&gt;&gt;&gt; literal because there is no &quot;IntegerLiteral&quot; entity in the type<br>&gt;&gt;&gt;&gt; system.  The literal *becomes* typed as the corresponding literal type<br>&gt;&gt;&gt;&gt; (e.g., Int or String), and as far as the user at the call site is<br>&gt;&gt;&gt;&gt; concerned, there is no visible conversion (even if one is happening<br>&gt;&gt;&gt;&gt; behind the scenes).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Our suggestion was to focus on the &quot;adopting the syntax&quot; part.  We<br>&gt;&gt;&gt;&gt; suggested moving the &quot;literal convertible&quot; protocols into a<br>&gt;&gt;&gt;&gt; pseudo-namespace &quot;Syntax&quot;.  It could be implemented like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol _IntegerLiteralSyntax {}<br>&gt;&gt;&gt;&gt; enum Syntax {<br>&gt;&gt;&gt;&gt; typealias IntegerLiteral = _IntegerLiteralSyntax<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And used like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct Int : Syntax.IntegerLiteral {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m working on a draft of this proposal right now.  I have a couple questions.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; First, I’d like to list the standard library team as co-authors if you<br>&gt;&gt;&gt; desire because this is really your idea.  Let me know what you would<br>&gt;&gt;&gt; prefer.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Second, I wonder if it might make more sense to name the protocols<br>&gt;&gt;&gt; `Syntax.IntegerLiteralInitializable`.  Dave has opposed<br>&gt;&gt;&gt; `Initializable` as a general convention because it implies pure syntax<br>&gt;&gt;&gt; and doesn’t carry any semantics.  But in this case the semantics *are*<br>&gt;&gt;&gt; essentially the syntax.  Erica pointed out to me off list that at the<br>&gt;&gt;&gt; usage site the `Syntax.IntegerLiteral` names could confuse somebody<br>&gt;&gt;&gt; into thinking in terms of *isa* rather than *can do* (i.e. Int is an<br>&gt;&gt;&gt; IntegerLiteral rather than Int can be *initialized* with an<br>&gt;&gt;&gt; IntegerLiteral).<br>&gt;&gt; <br>&gt;&gt; Really, this is exactly the sense in which we want it to be interpreted.<br>&gt;&gt; It is *not* a capability.  There is no such thing as an IntegerLiteral<br>&gt;&gt; instance from which one can initialize an Int.  There are only syntactic<br>&gt;&gt; integer literals, which, given the right type context, can be-a Int.<br>&gt;&gt; The intializer one gets from the protocol is merely the mechanism used<br>&gt;&gt; by the compiler to create this Int.<br>&gt; <br>&gt; That is a technically correct statement, but I think the model most programmers will have (good or bad) is of initializing with an integer literal.  I think this is evidenced to some degree by the feedback people are providing on the names.<br></p><p>Perpetuating the wrong idea does not make it a good idea... There was Ptolemy and then there was Galileo.<br></p><p>&gt; That said, I am trying to stay out of the fray of the bike shedding on this.  IMO the most important thing is to do *something* here as long as its reasonable and the solution suggested by the standard library team is definitely reasonable.  That is why I have written the proposal exactly as the standard library team suggested.  :)  <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Please let me know if this name change would be acceptable to the<br>&gt;&gt;&gt; standard library team or may be met with resistance.  I want this<br>&gt;&gt;&gt; proposal to be acceptable to the team from the start.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - For protocols that are representing conversions between types that<br>&gt;&gt;&gt;&gt; actually exist in the library, there is not enough precedent yet to<br>&gt;&gt;&gt;&gt; make a general conclusion and standardize a pattern.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Dmitri<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt;&gt;&gt;&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko<br>&gt;&gt;&gt;&gt; &lt;gribozavr at gmail.com<br>&gt;&gt;&gt;&gt; &lt;mailto:gribozavr at gmail.com&gt;&gt;*/<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/8096e7e2/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Revisiting SE-0041 Names</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>June 27, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jun 27, 2016, at 8:29 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Second, I wonder if it might make more sense to name the protocols<br>&gt;&gt; `Syntax.IntegerLiteralInitializable`.  Dave has opposed<br>&gt;&gt; `Initializable` as a general convention because it implies pure syntax<br>&gt;&gt; and doesn’t carry any semantics.  But in this case the semantics *are*<br>&gt;&gt; essentially the syntax.  Erica pointed out to me off list that at the<br>&gt;&gt; usage site the `Syntax.IntegerLiteral` names could confuse somebody<br>&gt;&gt; into thinking in terms of *isa* rather than *can do* (i.e. Int is an<br>&gt;&gt; IntegerLiteral rather than Int can be *initialized* with an<br>&gt;&gt; IntegerLiteral).<br>&gt; <br>&gt; Really, this is exactly the sense in which we want it to be interpreted.<br>&gt; It is *not* a capability.  There is no such thing as an IntegerLiteral<br>&gt; instance from which one can initialize an Int.  There are only syntactic<br>&gt; integer literals, which, given the right type context, can be-a Int.<br>&gt; The intializer one gets from the protocol is merely the mechanism used<br>&gt; by the compiler to create this Int.<br></p><p><br>Starting with this:<br></p><p>    &quot;Conforming to a protocol is supposed to be a strong declaration about not just syntax, but semantics&quot; - D. Abrahams<br></p><p>Current:<br></p><p>	/// Conforming types can be initialized with integer literals.<br>	public protocol IntegerLiteralConvertible {<br>	<br>	    associatedtype IntegerLiteralType<br>	<br>	    /// Create an instance initialized to `value`.<br>	    public init(integerLiteral value: Self.IntegerLiteralType)<br>	}<br></p><p><br>Maybe my issue is that this should really read:<br></p><p>	/// Conforming types accept integer literal syntax for initialization<br>	/// allowing types to use integer literals in statements<br>	///<br>	/// ```<br>	/// let instance: T = *integer literal*<br>	/// ```<br>	/// <br>	/// for example:<br>	/// <br>	/// ```<br>	/// let myDouble: Double = 2 // The literal 2 is automatically cast<br>	/// let anotherDouble: Double = myDouble * 5 // The literal 5 is automatically cast<br>	/// ```<br>	public protocol Syntax.SupportsIntegerLiteralValues {<br></p><p>            ///  For constrained integer literal types, which otherwise default to `Int`.<br>	    associatedtype IntegerLiteralType = Int<br>	<br>             /// Create an instance initialized to `value`. <br>	    ///  Required to enable in-line syntactic substitutions<br>	    public init(integerLiteral value: Self.IntegerLiteralType)<br></p><p>	}<br></p><p>So a protocol of `Syntax.AcceptsIntegerLiteralValues` or `Syntax.AutoconvertsIntegerLiteralValues` might<br>better explain what this is doing and the intent of the protocol. It ain&#39;t short but it&#39;s a hella lot clearer.<br></p><p>-- E<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Revisiting SE-0041 Names</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June 27, 2016 at 11:00:00am</p></header><div class="content"><p>on Mon Jun 27 2016, Erica Sadun &lt;erica-AT-ericasadun.com&gt; wrote:<br></p><p>&gt;&gt; On Jun 27, 2016, at 8:29 AM, Dave Abrahams via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; Second, I wonder if it might make more sense to name the protocols<br>&gt;&gt;&gt; `Syntax.IntegerLiteralInitializable`.  Dave has opposed<br>&gt;&gt;&gt; `Initializable` as a general convention because it implies pure<br>&gt; syntax<br>&gt;&gt;&gt; and doesn’t carry any semantics.  But in this case the semantics<br>&gt; *are*<br>&gt;<br>&gt;&gt;&gt; essentially the syntax.  Erica pointed out to me off list that at the<br>&gt;&gt;&gt; usage site the `Syntax.IntegerLiteral` names could confuse somebody<br>&gt;&gt;&gt; into thinking in terms of *isa* rather than *can do* (i.e. Int is<br>&gt; an<br>&gt;&gt;&gt; IntegerLiteral rather than Int can be *initialized* with an<br>&gt;&gt;&gt; IntegerLiteral).<br>&gt;&gt; <br>&gt;&gt; Really, this is exactly the sense in which we want it to be<br>&gt; interpreted.<br>&gt;&gt; It is *not* a capability.  There is no such thing as an<br>&gt; IntegerLiteral<br>&gt;&gt; instance from which one can initialize an Int.  There are only<br>&gt; syntactic<br>&gt;&gt; integer literals, which, given the right type context, can be-a Int.<br>&gt;&gt; The intializer one gets from the protocol is merely the mechanism<br>&gt; used<br>&gt;&gt; by the compiler to create this Int.<br>&gt;<br>&gt; Starting with this:<br>&gt;<br>&gt;     &quot;Conforming to a protocol is supposed to be a strong declaration<br>&gt; about not just syntax, but semantics&quot; - D. Abrahams<br></p><p>There&#39;s an exception to everything.  In this case, protocols used to<br>interface with the language at the lowest levels may be purely about<br>syntax.<br></p><p>&gt; Current:<br>&gt;<br>&gt; 	/// Conforming types can be initialized with integer literals.<br>&gt; 	public protocol IntegerLiteralConvertible {<br>&gt;<br>&gt; 	    associatedtype IntegerLiteralType<br>&gt;<br>&gt; 	    /// Create an instance initialized to `value`.<br>&gt; 	    public init(integerLiteral value: Self.IntegerLiteralType)<br>&gt; 	}<br>&gt;<br>&gt; Maybe my issue is that this should really read:<br>&gt;<br>&gt; 	/// Conforming types accept integer literal syntax for initialization<br>&gt; 	/// allowing types to use integer literals in statements<br>&gt; 	///<br>&gt; 	/// ```<br>&gt; 	/// let instance: T = *integer literal*<br>&gt; 	/// ```<br>&gt; 	/// <br>&gt; 	/// for example:<br>&gt; 	/// <br>&gt; 	/// ```<br>&gt; 	/// let myDouble: Double = 2 // The literal 2 is automatically<br>&gt; cast<br>&gt; 	/// let anotherDouble: Double = myDouble * 5 // The literal 5<br>&gt; is automatically cast<br>&gt; 	/// ```<br>&gt; 	public protocol Syntax.SupportsIntegerLiteralValues {<br>&gt;<br>&gt;             /// For constrained integer literal types, which otherwise<br>&gt; default to `Int`.<br>&gt; 	    associatedtype IntegerLiteralType = Int<br>&gt;<br>&gt;              /// Create an instance initialized to `value`. <br>&gt; 	    ///  Required to enable in-line syntactic substitutions<br>&gt; 	    public init(integerLiteral value: Self.IntegerLiteralType)<br>&gt;<br>&gt; 	}<br>&gt;<br>&gt; So a protocol of `Syntax.AcceptsIntegerLiteralValues` or<br>&gt; `Syntax.AutoconvertsIntegerLiteralValues` might<br>&gt; better explain what this is doing and the intent of the protocol. It<br>&gt; ain&#39;t short but it&#39;s a hella lot clearer.<br></p><p>Being clear isn&#39;t helpful when it clearly implies the wrong meaning.<br>What&#39;s essential about this protocol neither that it “accepts” nor that<br>it “autoconverts” anything.  It&#39;s that it allows allows an integer<br>literal to be interpreted as an expression having the conforming type,<br>or to put it differently, it confers integer literal syntax upon the<br>conforming type.<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Revisiting SE-0041 Names</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>June 27, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jun 27, 2016, at 12:13 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Mon Jun 27 2016, Erica Sadun &lt;erica-AT-ericasadun.com &lt;http://erica-at-ericasadun.com/&gt;&gt; wrote:<br>&gt;&gt; So a protocol of `Syntax.AcceptsIntegerLiteralValues` or<br>&gt;&gt; `Syntax.AutoconvertsIntegerLiteralValues` might<br>&gt;&gt; better explain what this is doing and the intent of the protocol. It<br>&gt;&gt; ain&#39;t short but it&#39;s a hella lot clearer.<br>&gt; <br>&gt; Being clear isn&#39;t helpful when it clearly implies the wrong meaning.<br>&gt; What&#39;s essential about this protocol neither that it “accepts” nor that<br>&gt; it “autoconverts” anything.  It&#39;s that it allows allows an integer<br>&gt; literal to be interpreted as an expression having the conforming type,<br>&gt; or to put it differently, it confers integer literal syntax upon the<br>&gt; conforming type.<br></p><p>I suppose  &quot;Syntax.AllowsIntegerLiteralToBeInterpretedAsExpressionOfConformingType&quot;<br>is a tiny bit too wordy?<br></p><p>Putting on my hat of extreme pedantry:<br></p><p>Conformance does &quot;accept&quot; integer literals. By conforming, this protocol<br>allows them to be interpreted as expressions of the conforming type. That<br>reads as acceptance to me.<br></p><p>I&#39;m not sure if you could call this promotion, casting, interpretation or whatever<br>but the way you describe it sounds exactly backwards from the way it&#39;s used. <br></p><p>You say &quot;It confers integer literal syntax&quot;, which reads to me as &quot;Oh great, I can<br>use a floating point number as an integer literal. Great, let x: Int = 4.2&quot;.<br></p><p>When I see it used, I think &quot;Conforming types consume integer literal syntax as native&quot;,<br>which is more `let x: Double = 1` and `let y Double = 2.5 * myOtherDouble * 4`.<br></p><p>And then grabbing a paintbrush of many colors, perhaps &quot;Syntax.IntegerLiteralConsumer&quot;?<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/4d9dd22a/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Revisiting SE-0041 Names</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>June 27, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jun 27, 2016, at 13:13, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; There&#39;s an exception to everything.  In this case, protocols used to<br>&gt; interface with the language at the lowest levels may be purely about<br>&gt; syntax.<br></p><p>Should we use a different word to declare such protocols?<br>syntax IntegerLiteral { // where “syntax” is just the lowercase spelling of whatever we end up calling the namespace<br>    // everything from `IntegerLiteralConvertible` goes here<br>}<br></p><p>It would certainly help create the mental distinction between these “syntactic” protocols and &quot;normal” protocols.<br></p><p>- Dave Sweeris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/e21be618/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Revisiting SE-0041 Names</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June 27, 2016 at 03:00:00pm</p></header><div class="content"><p>on Mon Jun 27 2016, David Sweeris &lt;davesweeris-AT-mac.com&gt; wrote:<br></p><p>&gt;&gt; On Jun 27, 2016, at 13:13, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; There&#39;s an exception to everything.  In this case, protocols used to<br>&gt;&gt; interface with the language at the lowest levels may be purely about<br>&gt;&gt; syntax.<br>&gt;<br>&gt; Should we use a different word to declare such protocols?<br></p><p>I don&#39;t think so.<br></p><p>&gt; syntax IntegerLiteral { // where “syntax” is just the lowercase<br>&gt; spelling of whatever we end up calling the namespace<br>&gt;     // everything from `IntegerLiteralConvertible` goes here<br>&gt; }<br>&gt;<br>&gt; It would certainly help create the mental distinction between these<br>&gt; “syntactic” protocols and &quot;normal” protocols.<br></p><p>I doubt this distinction is worth the language complexity.  Expressing<br>it in the library via the “Syntax.” qualification does the same thing<br>without any compiler changes.<br></p><p>-- <br>Dave<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
