<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>Proposal: Pattern Matching Partial Function (#111)</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>February  4, 2016 at 05:00:00pm</p></header><div class="content"><p>-0.5 against keeping &quot;cases&quot;.<br>I see it as a replacement for dictionary literal &quot;pattern matching&quot;:<br></p><p>[1 : &quot;one&quot;, 2 : &quot;two&quot;, 3 : &quot;three&quot;][1] ?? &quot;undefined&quot;<br></p><p>vs<br></p><p>match(1) {<br>    cases 1 : &quot;one&quot;, 2 : &quot;two&quot;, 3 : &quot;three&quot;<br>    default: &quot;undefined&quot;<br>}<br></p><p>&quot;cases&quot; adds exhaustiveness and is relatively concise.<br></p><p>Even though it would be nice to have but I don’t think that I would use it frequently.<br>In addition, to be more consistent with &quot;case&quot;, &quot;cases&quot; would introduce pattern matching which doesn’t seem right with this concise syntax.<br></p><p>&gt; Can we have a vote on removing / keeping the cases clause.  I personally would not typically use it, but there was a split on whether to keep it or delete it so I just kept it in the original until — as I expected — it would be dropped during review (assuming it has a chance of passing).<br>&gt; <br>&gt; I though, do not find cases to be particularly hard to read if you have 10 key/value pairs over two lines…. and no mixture….. readability is of the sample in the document is concise in that example and quite readable for me (but I would probably still not use it).<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160204/46e4963a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e941adb360692446106cebd7f6d2a1a3?s=50"></div><header><strong>Proposal: Pattern Matching Partial Function (#111)</strong> from <string>Charles Constant</string> &lt;charles at charlesism.com&gt;<p>February  4, 2016 at 08:00:00am</p></header><div class="content"><p>I still vote for keeping &quot;cases&quot;<br></p><p>I see it as a replacement for dictionary literal &quot;pattern matching&quot;:<br>&gt; [1 : &quot;one&quot;, 2 : &quot;two&quot;, 3 : &quot;three&quot;][1] ?? &quot;undefined&quot;<br>&gt;<br></p><p>A dictionary needs keys that are Hashable. A dictionary produces an<br>optional. We&#39;ve discussed this, and more, earlier in the thread.<br></p><p>Even though it would be nice to have but I don’t think that I would use it<br>&gt; frequently.<br>&gt;<br></p><p>Granted, it&#39;s a bit ugly, but given the choice, I would pick &quot;cases&quot; over<br>&quot;case case case case ...&quot; every time.<br></p><p>In addition, to be more consistent with &quot;case&quot;, &quot;cases&quot; would introduce<br>&gt; pattern matching which doesn’t seem right with this concise syntax.<br>&gt;<br></p><p>I haven&#39;t thought this through. It just bums me out a little to replace the<br>switch with something that still has imho unnecessary verbosity.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160204/9e8203b3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>Proposal: Pattern Matching Partial Function (#111)</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>February  4, 2016 at 09:00:00am</p></header><div class="content"><p>That is a good point and I forgot about that. There are frequent cases where what I am dealing with is not hashable and it is generally a lot of work to make it hashable, including adding a heading function which if done wrong, can lead to errors.  <br></p><p>Sent from my iPhone<br></p><p>&gt; On Feb 4, 2016, at 8:38 AM, Charles Constant via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I still vote for keeping &quot;cases&quot;<br>&gt; <br>&gt;&gt; I see it as a replacement for dictionary literal &quot;pattern matching&quot;:<br>&gt;&gt; [1 : &quot;one&quot;, 2 : &quot;two&quot;, 3 : &quot;three&quot;][1] ?? &quot;undefined&quot;<br>&gt; <br>&gt; A dictionary needs keys that are Hashable. A dictionary produces an optional. We&#39;ve discussed this, and more, earlier in the thread.<br>&gt; <br>&gt;&gt; Even though it would be nice to have but I don’t think that I would use it frequently.<br>&gt; <br>&gt; Granted, it&#39;s a bit ugly, but given the choice, I would pick &quot;cases&quot; over &quot;case case case case ...&quot; every time.<br>&gt; <br>&gt;&gt; In addition, to be more consistent with &quot;case&quot;, &quot;cases&quot; would introduce pattern matching which doesn’t seem right with this concise syntax.<br>&gt; <br>&gt; I haven&#39;t thought this through. It just bums me out a little to replace the switch with something that still has imho unnecessary verbosity.<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160204/16565ff1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>Proposal: Pattern Matching Partial Function (#111)</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>February  4, 2016 at 07:00:00pm</p></header><div class="content"><p>I definitely see the point against dictionaries but I’m afraid of the actual pattern matching in &quot;cases&quot;.<br></p><p>match(1) {<br>    case 1, 3: 10<br>    case 2, 4: 20<br>    default: 30<br>}<br></p><p>// with &quot;cases&quot;<br></p><p>match(1) { cases<br>    1, 3: 10,<br>    2, 4: 20,<br>    default: 30<br>}<br></p><p>// it is very hard to disambiguate between pattern and return value even though for the compiler it could be doable<br>match(1) { cases<br>    1, 3: 10, 2, 4: 20, default: 30<br>}<br></p><p><br>There should be a more visible distinction between two &quot;case-item-map&quot; like &quot;|&quot;. But we have to consider &quot;expression-patterns&quot; where operators (like &quot;|&quot;) are ambiguous.<br></p><p>- Maximilian<br></p><p>&gt; Am 04.02.2016 um 18:48 schrieb Paul Ossenbruggen &lt;possen at gmail.com&gt;:<br>&gt; <br>&gt; That is a good point and I forgot about that. There are frequent cases where what I am dealing with is not hashable and it is generally a lot of work to make it hashable, including adding a heading function which if done wrong, can lead to errors.  <br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt; On Feb 4, 2016, at 8:38 AM, Charles Constant via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; I still vote for keeping &quot;cases&quot;<br>&gt;&gt; <br>&gt;&gt; I see it as a replacement for dictionary literal &quot;pattern matching&quot;:<br>&gt;&gt; [1 : &quot;one&quot;, 2 : &quot;two&quot;, 3 : &quot;three&quot;][1] ?? &quot;undefined&quot;<br>&gt;&gt; <br>&gt;&gt; A dictionary needs keys that are Hashable. A dictionary produces an optional. We&#39;ve discussed this, and more, earlier in the thread.<br>&gt;&gt; <br>&gt;&gt; Even though it would be nice to have but I don’t think that I would use it frequently.<br>&gt;&gt; <br>&gt;&gt; Granted, it&#39;s a bit ugly, but given the choice, I would pick &quot;cases&quot; over &quot;case case case case ...&quot; every time.<br>&gt;&gt; <br>&gt;&gt; In addition, to be more consistent with &quot;case&quot;, &quot;cases&quot; would introduce pattern matching which doesn’t seem right with this concise syntax.<br>&gt;&gt; <br>&gt;&gt; I haven&#39;t thought this through. It just bums me out a little to replace the switch with something that still has imho unnecessary verbosity.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160204/c71ad499/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>Proposal: Pattern Matching Partial Function (#111)</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>February  5, 2016 at 01:00:00am</p></header><div class="content"><p>cases was added instead of using `cases` because of the potential problems foreseen where the parser would have trouble identifying a list of values.  <br></p><p>cases would be restricted to key: value, key: value, key: value and would be considered syntactic sugar that would expand out to <br>    case key1: value1<br>    case key2: value2<br>    case key3: value3 <br>as far as the compilation was concerned.<br></p><p><br>&gt; On 2016-02-05, at 1:31:09, Maximilian Hünenberger via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I definitely see the point against dictionaries but I’m afraid of the actual pattern matching in &quot;cases&quot;.<br>&gt; <br>&gt; match(1) {<br>&gt;     case 1, 3: 10<br>&gt;     case 2, 4: 20<br>&gt;     default: 30<br>&gt; }<br>&gt; <br>&gt; // with &quot;cases&quot;<br>&gt; <br>&gt; match(1) { cases<br>&gt;     1, 3: 10,<br>&gt;     2, 4: 20,<br>&gt;     default: 30<br>&gt; }<br>&gt; <br>&gt; // it is very hard to disambiguate between pattern and return value even though for the compiler it could be doable<br>&gt; match(1) { cases<br>&gt;     1, 3: 10, 2, 4: 20, default: 30<br>&gt; }<br>&gt; <br>&gt; <br>&gt; There should be a more visible distinction between two &quot;case-item-map&quot; like &quot;|&quot;. But we have to consider &quot;expression-patterns&quot; where operators (like &quot;|&quot;) are ambiguous.<br>&gt; <br>&gt; - Maximilian<br>&gt; <br>&gt;&gt; Am 04.02.2016 um 18:48 schrieb Paul Ossenbruggen &lt;possen at gmail.com &lt;mailto:possen at gmail.com&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt; That is a good point and I forgot about that. There are frequent cases where what I am dealing with is not hashable and it is generally a lot of work to make it hashable, including adding a heading function which if done wrong, can lead to errors.  <br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt; On Feb 4, 2016, at 8:38 AM, Charles Constant via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; I still vote for keeping &quot;cases&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I see it as a replacement for dictionary literal &quot;pattern matching&quot;:<br>&gt;&gt;&gt; [1 : &quot;one&quot;, 2 : &quot;two&quot;, 3 : &quot;three&quot;][1] ?? &quot;undefined&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A dictionary needs keys that are Hashable. A dictionary produces an optional. We&#39;ve discussed this, and more, earlier in the thread.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Even though it would be nice to have but I don’t think that I would use it frequently.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Granted, it&#39;s a bit ugly, but given the choice, I would pick &quot;cases&quot; over &quot;case case case case ...&quot; every time.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In addition, to be more consistent with &quot;case&quot;, &quot;cases&quot; would introduce pattern matching which doesn’t seem right with this concise syntax.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I haven&#39;t thought this through. It just bums me out a little to replace the switch with something that still has imho unnecessary verbosity.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160205/045ace5b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>Proposal: Pattern Matching Partial Function (#111)</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>February  4, 2016 at 07:00:00pm</p></header><div class="content"><p>To what extend should pattern matching be used in &quot;cases&quot;?<br></p><p>Can there be value bindings? The current grammar says &quot;pattern&quot; which means:<br>pattern → wildcard-pattern &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Patterns.html#//apple_ref/swift/grammar/wildcard-pattern&gt;­type-annotation &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/type-annotation&gt;­opt­<br> &lt;&gt;pattern → identifier-pattern &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Patterns.html#//apple_ref/swift/grammar/identifier-pattern&gt;­type-annotation &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/type-annotation&gt;­opt­<br> &lt;&gt;pattern → value-binding-pattern &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Patterns.html#//apple_ref/swift/grammar/value-binding-pattern&gt;­<br> &lt;&gt;pattern → tuple-pattern &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Patterns.html#//apple_ref/swift/grammar/tuple-pattern&gt;­type-annotation &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/type-annotation&gt;­opt­<br> &lt;&gt;pattern → enum-case-pattern &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Patterns.html#//apple_ref/swift/grammar/enum-case-pattern&gt;­<br> &lt;&gt;pattern → optional-pattern &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Patterns.html#//apple_ref/swift/grammar/optional-pattern&gt;­<br> &lt;&gt;pattern → type-casting-pattern &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Patterns.html#//apple_ref/swift/grammar/type-casting-pattern&gt;­<br> &lt;&gt;pattern → expression-pattern &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Patterns.html#//apple_ref/swift/grammar/expression-pattern&gt;­<br> &lt;&gt;<br>&gt; Am 04.02.2016 um 19:35 schrieb Craig Cruden &lt;ccruden at novafore.com&gt;:<br>&gt; <br>&gt; cases was added instead of using `cases` because of the potential problems foreseen where the parser would have trouble identifying a list of values.  <br>&gt; <br>&gt; cases would be restricted to key: value, key: value, key: value and would be considered syntactic sugar that would expand out to <br>&gt;     case key1: value1<br>&gt;     case key2: value2<br>&gt;     case key3: value3 <br>&gt; as far as the compilation was concerned.<br>&gt; <br>&gt; <br>&gt;&gt; On 2016-02-05, at 1:31:09, Maximilian Hünenberger via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I definitely see the point against dictionaries but I’m afraid of the actual pattern matching in &quot;cases&quot;.<br>&gt;&gt; <br>&gt;&gt; match(1) {<br>&gt;&gt;     case 1, 3: 10<br>&gt;&gt;     case 2, 4: 20<br>&gt;&gt;     default: 30<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // with &quot;cases&quot;<br>&gt;&gt; <br>&gt;&gt; match(1) { cases<br>&gt;&gt;     1, 3: 10,<br>&gt;&gt;     2, 4: 20,<br>&gt;&gt;     default: 30<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // it is very hard to disambiguate between pattern and return value even though for the compiler it could be doable<br>&gt;&gt; match(1) { cases<br>&gt;&gt;     1, 3: 10, 2, 4: 20, default: 30<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; There should be a more visible distinction between two &quot;case-item-map&quot; like &quot;|&quot;. But we have to consider &quot;expression-patterns&quot; where operators (like &quot;|&quot;) are ambiguous.<br>&gt;&gt; <br>&gt;&gt; - Maximilian<br>&gt;&gt; <br>&gt;&gt;&gt; Am 04.02.2016 um 18:48 schrieb Paul Ossenbruggen &lt;possen at gmail.com &lt;mailto:possen at gmail.com&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That is a good point and I forgot about that. There are frequent cases where what I am dealing with is not hashable and it is generally a lot of work to make it hashable, including adding a heading function which if done wrong, can lead to errors.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Feb 4, 2016, at 8:38 AM, Charles Constant via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I still vote for keeping &quot;cases&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I see it as a replacement for dictionary literal &quot;pattern matching&quot;:<br>&gt;&gt;&gt;&gt; [1 : &quot;one&quot;, 2 : &quot;two&quot;, 3 : &quot;three&quot;][1] ?? &quot;undefined&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A dictionary needs keys that are Hashable. A dictionary produces an optional. We&#39;ve discussed this, and more, earlier in the thread.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Even though it would be nice to have but I don’t think that I would use it frequently.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Granted, it&#39;s a bit ugly, but given the choice, I would pick &quot;cases&quot; over &quot;case case case case ...&quot; every time.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In addition, to be more consistent with &quot;case&quot;, &quot;cases&quot; would introduce pattern matching which doesn’t seem right with this concise syntax.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I haven&#39;t thought this through. It just bums me out a little to replace the switch with something that still has imho unnecessary verbosity.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160204/c01c2b18/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>Proposal: Pattern Matching Partial Function (#111)</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>February  4, 2016 at 01:00:00pm</p></header><div class="content"><p>I haven&#39;t thought of doing it this way This is why these reviews are great. I agree with Craig that, we would not allow commas before the colon. The proposal probably should be updated to make sure that is clear. <br></p><p>Thanks <br>- Paul <br></p><p>Sent from my iPhone<br></p><p>&gt; On Feb 4, 2016, at 10:31 AM, Maximilian Hünenberger &lt;m.huenenberger at me.com&gt; wrote:<br>&gt; <br>&gt; I definitely see the point against dictionaries but I’m afraid of the actual pattern matching in &quot;cases&quot;.<br>&gt; <br>&gt; match(1) {<br>&gt;     case 1, 3: 10<br>&gt;     case 2, 4: 20<br>&gt;     default: 30<br>&gt; }<br>&gt; <br>&gt; // with &quot;cases&quot;<br>&gt; <br>&gt; match(1) { cases<br>&gt;     1, 3: 10,<br>&gt;     2, 4: 20,<br>&gt;     default: 30<br>&gt; }<br>&gt; <br>&gt; // it is very hard to disambiguate between pattern and return value even though for the compiler it could be doable<br>&gt; match(1) { cases<br>&gt;     1, 3: 10, 2, 4: 20, default: 30<br>&gt; }<br>&gt; <br>&gt; <br>&gt; There should be a more visible distinction between two &quot;case-item-map&quot; like &quot;|&quot;. But we have to consider &quot;expression-patterns&quot; where operators (like &quot;|&quot;) are ambiguous.<br>&gt; <br>&gt; - Maximilian<br>&gt; <br>&gt;&gt; Am 04.02.2016 um 18:48 schrieb Paul Ossenbruggen &lt;possen at gmail.com&gt;:<br>&gt;&gt; <br>&gt;&gt; That is a good point and I forgot about that. There are frequent cases where what I am dealing with is not hashable and it is generally a lot of work to make it hashable, including adding a heading function which if done wrong, can lead to errors.  <br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 4, 2016, at 8:38 AM, Charles Constant via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I still vote for keeping &quot;cases&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I see it as a replacement for dictionary literal &quot;pattern matching&quot;:<br>&gt;&gt;&gt;&gt; [1 : &quot;one&quot;, 2 : &quot;two&quot;, 3 : &quot;three&quot;][1] ?? &quot;undefined&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A dictionary needs keys that are Hashable. A dictionary produces an optional. We&#39;ve discussed this, and more, earlier in the thread.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Even though it would be nice to have but I don’t think that I would use it frequently.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Granted, it&#39;s a bit ugly, but given the choice, I would pick &quot;cases&quot; over &quot;case case case case ...&quot; every time.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In addition, to be more consistent with &quot;case&quot;, &quot;cases&quot; would introduce pattern matching which doesn’t seem right with this concise syntax.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I haven&#39;t thought this through. It just bums me out a little to replace the switch with something that still has imho unnecessary verbosity.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160204/2da87f6f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>Proposal: Pattern Matching Partial Function (#111)</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>February  5, 2016 at 04:00:00am</p></header><div class="content"><p>Off Topic a little.<br></p><p>I was playing around with the equivalent case - partial functions in Scala …. <br></p><p>I have known for whatever reason that they would not work within the Scala `reduce` but would work in other functions….  and it bugged me as to why it would work in most but not all (I was wondering if this was some weird implementation limitation).  <br></p><p>As far as I can tell, there is a little difference that prevents it.  Swift reduce is probably the same as Scala’s foldLeft.  I had thought Scala’s reduce is a specialized form of fold but it is not the case.<br></p><p>The difference has to be that Scala’s `reduce` takes a “commutative monoid” — and case partial functions by their very nature [conditions on accumulator or value prevent it] are not commutative in nature — or at least not guaranteed to be so.  <br></p><p>Scala’s fold is either left to right, or right to left.  `reduce` on the other hand provides no guarantees because it may parallelize it [I am wondering if this is something in common with the concept of big data mapReduce].<br></p><p>——<br></p><p>Paul, I will look at updating the proposal to make that clear. <br></p><p><br>&gt; On 2016-02-05, at 4:17:03, Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I haven&#39;t thought of doing it this way This is why these reviews are great. I agree with Craig that, we would not allow commas before the colon. The proposal probably should be updated to make sure that is clear. <br>&gt; <br>&gt; Thanks <br>&gt; - Paul <br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt; On Feb 4, 2016, at 10:31 AM, Maximilian Hünenberger &lt;m.huenenberger at me.com &lt;mailto:m.huenenberger at me.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; I definitely see the point against dictionaries but I’m afraid of the actual pattern matching in &quot;cases&quot;.<br>&gt;&gt; <br>&gt;&gt; match(1) {<br>&gt;&gt;     case 1, 3: 10<br>&gt;&gt;     case 2, 4: 20<br>&gt;&gt;     default: 30<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // with &quot;cases&quot;<br>&gt;&gt; <br>&gt;&gt; match(1) { cases<br>&gt;&gt;     1, 3: 10,<br>&gt;&gt;     2, 4: 20,<br>&gt;&gt;     default: 30<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // it is very hard to disambiguate between pattern and return value even though for the compiler it could be doable<br>&gt;&gt; match(1) { cases<br>&gt;&gt;     1, 3: 10, 2, 4: 20, default: 30<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; There should be a more visible distinction between two &quot;case-item-map&quot; like &quot;|&quot;. But we have to consider &quot;expression-patterns&quot; where operators (like &quot;|&quot;) are ambiguous.<br>&gt;&gt; <br>&gt;&gt; - Maximilian<br>&gt;&gt; <br>&gt;&gt;&gt; Am 04.02.2016 um 18:48 schrieb Paul Ossenbruggen &lt;possen at gmail.com &lt;mailto:possen at gmail.com&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That is a good point and I forgot about that. There are frequent cases where what I am dealing with is not hashable and it is generally a lot of work to make it hashable, including adding a heading function which if done wrong, can lead to errors.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Feb 4, 2016, at 8:38 AM, Charles Constant via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I still vote for keeping &quot;cases&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I see it as a replacement for dictionary literal &quot;pattern matching&quot;:<br>&gt;&gt;&gt;&gt; [1 : &quot;one&quot;, 2 : &quot;two&quot;, 3 : &quot;three&quot;][1] ?? &quot;undefined&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A dictionary needs keys that are Hashable. A dictionary produces an optional. We&#39;ve discussed this, and more, earlier in the thread.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Even though it would be nice to have but I don’t think that I would use it frequently.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Granted, it&#39;s a bit ugly, but given the choice, I would pick &quot;cases&quot; over &quot;case case case case ...&quot; every time.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In addition, to be more consistent with &quot;case&quot;, &quot;cases&quot; would introduce pattern matching which doesn’t seem right with this concise syntax.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I haven&#39;t thought this through. It just bums me out a little to replace the switch with something that still has imho unnecessary verbosity.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160205/01161043/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Proposal: Pattern Matching Partial Function (#111)</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>February  5, 2016 at 06:00:00am</p></header><div class="content"><p>The reason is simply that partial functions in Scala are unary function, i.e. take only one argument, while reduce takes a binary function.<br></p><p>I already wrote in another mail why I think that the reduce example in the proposal is problematic, because it does argument splatting.<br></p><p>-Thorsten <br></p><p>&gt; Am 04.02.2016 um 22:57 schrieb Craig Cruden via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Off Topic a little.<br>&gt; <br>&gt; I was playing around with the equivalent case - partial functions in Scala …. <br>&gt; <br>&gt; I have known for whatever reason that they would not work within the Scala `reduce` but would work in other functions….  and it bugged me as to why it would work in most but not all (I was wondering if this was some weird implementation limitation).  <br>&gt; <br>&gt; As far as I can tell, there is a little difference that prevents it.  Swift reduce is probably the same as Scala’s foldLeft.  I had thought Scala’s reduce is a specialized form of fold but it is not the case.<br>&gt; <br>&gt; The difference has to be that Scala’s `reduce` takes a “commutative monoid” — and case partial functions by their very nature [conditions on accumulator or value prevent it] are not commutative in nature — or at least not guaranteed to be so.  <br>&gt; <br>&gt; Scala’s fold is either left to right, or right to left.  `reduce` on the other hand provides no guarantees because it may parallelize it [I am wondering if this is something in common with the concept of big data mapReduce].<br>&gt; <br>&gt; ——<br>&gt; <br>&gt; Paul, I will look at updating the proposal to make that clear. <br>&gt; <br>&gt; <br>&gt;&gt; On 2016-02-05, at 4:17:03, Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I haven&#39;t thought of doing it this way This is why these reviews are great. I agree with Craig that, we would not allow commas before the colon. The proposal probably should be updated to make sure that is clear. <br>&gt;&gt; <br>&gt;&gt; Thanks <br>&gt;&gt; - Paul <br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 4, 2016, at 10:31 AM, Maximilian Hünenberger &lt;m.huenenberger at me.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I definitely see the point against dictionaries but I’m afraid of the actual pattern matching in &quot;cases&quot;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; match(1) {<br>&gt;&gt;&gt;     case 1, 3: 10<br>&gt;&gt;&gt;     case 2, 4: 20<br>&gt;&gt;&gt;     default: 30<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // with &quot;cases&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; match(1) { cases<br>&gt;&gt;&gt;     1, 3: 10,<br>&gt;&gt;&gt;     2, 4: 20,<br>&gt;&gt;&gt;     default: 30<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // it is very hard to disambiguate between pattern and return value even though for the compiler it could be doable<br>&gt;&gt;&gt; match(1) { cases<br>&gt;&gt;&gt;     1, 3: 10, 2, 4: 20, default: 30<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There should be a more visible distinction between two &quot;case-item-map&quot; like &quot;|&quot;. But we have to consider &quot;expression-patterns&quot; where operators (like &quot;|&quot;) are ambiguous.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Maximilian<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 04.02.2016 um 18:48 schrieb Paul Ossenbruggen &lt;possen at gmail.com&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That is a good point and I forgot about that. There are frequent cases where what I am dealing with is not hashable and it is generally a lot of work to make it hashable, including adding a heading function which if done wrong, can lead to errors.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Feb 4, 2016, at 8:38 AM, Charles Constant via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I still vote for keeping &quot;cases&quot;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I see it as a replacement for dictionary literal &quot;pattern matching&quot;:<br>&gt;&gt;&gt;&gt;&gt;&gt; [1 : &quot;one&quot;, 2 : &quot;two&quot;, 3 : &quot;three&quot;][1] ?? &quot;undefined&quot;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; A dictionary needs keys that are Hashable. A dictionary produces an optional. We&#39;ve discussed this, and more, earlier in the thread.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Even though it would be nice to have but I don’t think that I would use it frequently.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Granted, it&#39;s a bit ugly, but given the choice, I would pick &quot;cases&quot; over &quot;case case case case ...&quot; every time.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In addition, to be more consistent with &quot;case&quot;, &quot;cases&quot; would introduce pattern matching which doesn’t seem right with this concise syntax.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I haven&#39;t thought this through. It just bums me out a little to replace the switch with something that still has imho unnecessary verbosity.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160205/c0167a0b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>Proposal: Pattern Matching Partial Function (#111)</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>February  5, 2016 at 01:00:00pm</p></header><div class="content"><p>No, that cannot be the reason.<br></p><p>— this works<br>val r2 = a.foldLeft(0)  {<br>  case (acc, x) if x &gt; 4 =&gt; println(x); acc + x<br>  case (acc, x) if x &lt;= 4 =&gt; acc - x<br>}<br></p><p>— this does not.<br>val r3 = a.reduce {<br>  case (acc, x) if x &gt; 4 =&gt; println(x); acc + x<br>  case (acc, x) if x &lt;= 4 =&gt; acc - x<br>}<br></p><p><br>&gt; On 2016-02-05, at 12:59:06, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; The reason is simply that partial functions in Scala are unary function, i.e. take only one argument, while reduce takes a binary function.<br>&gt; <br>&gt; I already wrote in another mail why I think that the reduce example in the proposal is problematic, because it does argument splatting.<br>&gt; <br>&gt; -Thorsten <br>&gt; <br>&gt; Am 04.02.2016 um 22:57 schrieb Craig Cruden via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; <br>&gt;&gt; Off Topic a little.<br>&gt;&gt; <br>&gt;&gt; I was playing around with the equivalent case - partial functions in Scala …. <br>&gt;&gt; <br>&gt;&gt; I have known for whatever reason that they would not work within the Scala `reduce` but would work in other functions….  and it bugged me as to why it would work in most but not all (I was wondering if this was some weird implementation limitation).  <br>&gt;&gt; <br>&gt;&gt; As far as I can tell, there is a little difference that prevents it.  Swift reduce is probably the same as Scala’s foldLeft.  I had thought Scala’s reduce is a specialized form of fold but it is not the case.<br>&gt;&gt; <br>&gt;&gt; The difference has to be that Scala’s `reduce` takes a “commutative monoid” — and case partial functions by their very nature [conditions on accumulator or value prevent it] are not commutative in nature — or at least not guaranteed to be so.  <br>&gt;&gt; <br>&gt;&gt; Scala’s fold is either left to right, or right to left.  `reduce` on the other hand provides no guarantees because it may parallelize it [I am wondering if this is something in common with the concept of big data mapReduce].<br>&gt;&gt; <br>&gt;&gt; ——<br>&gt;&gt; <br>&gt;&gt; Paul, I will look at updating the proposal to make that clear. <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 2016-02-05, at 4:17:03, Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I haven&#39;t thought of doing it this way This is why these reviews are great. I agree with Craig that, we would not allow commas before the colon. The proposal probably should be updated to make sure that is clear. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks <br>&gt;&gt;&gt; - Paul <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Feb 4, 2016, at 10:31 AM, Maximilian Hünenberger &lt;m.huenenberger at me.com &lt;mailto:m.huenenberger at me.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I definitely see the point against dictionaries but I’m afraid of the actual pattern matching in &quot;cases&quot;.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; match(1) {<br>&gt;&gt;&gt;&gt;     case 1, 3: 10<br>&gt;&gt;&gt;&gt;     case 2, 4: 20<br>&gt;&gt;&gt;&gt;     default: 30<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // with &quot;cases&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; match(1) { cases<br>&gt;&gt;&gt;&gt;     1, 3: 10,<br>&gt;&gt;&gt;&gt;     2, 4: 20,<br>&gt;&gt;&gt;&gt;     default: 30<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // it is very hard to disambiguate between pattern and return value even though for the compiler it could be doable<br>&gt;&gt;&gt;&gt; match(1) { cases<br>&gt;&gt;&gt;&gt;     1, 3: 10, 2, 4: 20, default: 30<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There should be a more visible distinction between two &quot;case-item-map&quot; like &quot;|&quot;. But we have to consider &quot;expression-patterns&quot; where operators (like &quot;|&quot;) are ambiguous.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Maximilian<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 04.02.2016 um 18:48 schrieb Paul Ossenbruggen &lt;possen at gmail.com &lt;mailto:possen at gmail.com&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That is a good point and I forgot about that. There are frequent cases where what I am dealing with is not hashable and it is generally a lot of work to make it hashable, including adding a heading function which if done wrong, can lead to errors.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Feb 4, 2016, at 8:38 AM, Charles Constant via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I still vote for keeping &quot;cases&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I see it as a replacement for dictionary literal &quot;pattern matching&quot;:<br>&gt;&gt;&gt;&gt;&gt;&gt; [1 : &quot;one&quot;, 2 : &quot;two&quot;, 3 : &quot;three&quot;][1] ?? &quot;undefined&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; A dictionary needs keys that are Hashable. A dictionary produces an optional. We&#39;ve discussed this, and more, earlier in the thread.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Even though it would be nice to have but I don’t think that I would use it frequently.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Granted, it&#39;s a bit ugly, but given the choice, I would pick &quot;cases&quot; over &quot;case case case case ...&quot; every time.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In addition, to be more consistent with &quot;case&quot;, &quot;cases&quot; would introduce pattern matching which doesn’t seem right with this concise syntax.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I haven&#39;t thought this through. It just bums me out a little to replace the switch with something that still has imho unnecessary verbosity.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160205/5b4a9f39/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Proposal: Pattern Matching Partial Function (#111)</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>February  5, 2016 at 06:00:00am</p></header><div class="content"><p>&gt; Am 04.02.2016 um 19:31 schrieb Maximilian Hünenberger via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; I definitely see the point against dictionaries but I’m afraid of the actual pattern matching in &quot;cases&quot;.<br>&gt; <br>&gt; match(1) {<br>&gt;     case 1, 3: 10<br>&gt;     case 2, 4: 20<br>&gt;     default: 30<br>&gt; }<br>&gt; <br>&gt; // with &quot;cases&quot;<br>&gt; <br>&gt; match(1) { cases<br>&gt;     1, 3: 10,<br>&gt;     2, 4: 20,<br>&gt;     default: 30<br>&gt; }<br>&gt; <br>&gt; // it is very hard to disambiguate between pattern and return value even though for the compiler it could be doable<br>&gt; match(1) { cases<br>&gt;     1, 3: 10, 2, 4: 20, default: 30<br>&gt; }<br>&gt; <br>&gt; <br>&gt; There should be a more visible distinction between two &quot;case-item-map&quot;<br></p><p>That&#39;s why I am against &quot;cases&quot;. The visual distinction is nicely provided by &quot;case&quot;. No need for something else IMO.<br></p><p>-Thorsten <br></p><p><br>&gt; like &quot;|&quot;. But we have to consider &quot;expression-patterns&quot; where operators (like &quot;|&quot;) are ambiguous.<br>&gt; <br>&gt; - Maximilian<br>&gt; <br>&gt;&gt; Am 04.02.2016 um 18:48 schrieb Paul Ossenbruggen &lt;possen at gmail.com&gt;:<br>&gt;&gt; <br>&gt;&gt; That is a good point and I forgot about that. There are frequent cases where what I am dealing with is not hashable and it is generally a lot of work to make it hashable, including adding a heading function which if done wrong, can lead to errors.  <br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 4, 2016, at 8:38 AM, Charles Constant via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I still vote for keeping &quot;cases&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I see it as a replacement for dictionary literal &quot;pattern matching&quot;:<br>&gt;&gt;&gt;&gt; [1 : &quot;one&quot;, 2 : &quot;two&quot;, 3 : &quot;three&quot;][1] ?? &quot;undefined&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A dictionary needs keys that are Hashable. A dictionary produces an optional. We&#39;ve discussed this, and more, earlier in the thread.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Even though it would be nice to have but I don’t think that I would use it frequently.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Granted, it&#39;s a bit ugly, but given the choice, I would pick &quot;cases&quot; over &quot;case case case case ...&quot; every time.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In addition, to be more consistent with &quot;case&quot;, &quot;cases&quot; would introduce pattern matching which doesn’t seem right with this concise syntax.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I haven&#39;t thought this through. It just bums me out a little to replace the switch with something that still has imho unnecessary verbosity.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160205/3788e9c4/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
