<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/42b97d0b2db29ce48d49b01c182c8d6b?s=50"></div><header><strong>Type information containing multiple additional protocols</strong> from <string>Daniel Muhra</string> &lt;daniel.muhra at gmail.com&gt;<p>December  5, 2015 at 12:00:00am</p></header><div class="content"><p>Currently it doesn’t seem possible to define a property or variable of a specific class that also implements one or more protocols.<br>Take as an example the following definition from Objective C:<br></p><p>NSManagedObject&lt;NSCoding, Task&gt;* someObject;<br></p><p>To my knowledge, currently it is only possible to define multiple protocols only:<br></p><p>var object : protocol&lt;NSCoding, Task&gt;<br></p><p>However, given the first example, sometimes it is not possible to restrict to protocols only. This becomes especially cumbersome, if you would need to cast down to such a construct within a single method and perform several steps which would require all those type information:<br></p><p>func doSomething(object: AnyObject) {<br>    if let managedObject = object as? NSManagedObject {<br>        // Do core data related stuff<br>    }<br>    <br>    if let task = object as? Task {<br>        // Do task related stuff<br>    }  <br>}<br></p><p>In this case you now have managedObject and task though you operate on the same object. Also it is not (easily) possible to interleave actions of those two.<br></p><p>My first idea here would be to introduce an Objective C like style of type naming. This also has the benefit, that it is perfectly clear, whether a type name refers to a class or a protocol (without first having to check it).<br>The downside, of course, is that protocol type variables would become something like Any&lt;MyProtocol&gt;<br></p><p>Any other ideas are welcome, but the initial problem still stands and should be addressed.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/fb927de9/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Type information containing multiple additional protocols</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>December  4, 2015 at 11:00:00pm</p></header><div class="content"><p>I think this is a very useful feature of Obj-C that I&#39;ve missed several<br>times while writing Swift code.<br></p><p>However, calling it &quot;TheClass&lt;Protocol1, Protocol2&gt;&quot; directly conflicts<br>with the syntax for specifying generic type parameters.<br></p><p>If we use &quot;protocol&lt;TheClass, Protocol1, Protocol2&gt;&quot; for this case, then<br>`protocol` stops making sense. Maybe the keyword `class` could be allowed<br>instead, like &quot;class&lt;TheClass, Protocol1, Protocol2&gt;&quot;.<br></p><p>Or, it might work to omit the keyword entirely, leaving only the angle<br>brackets:<br></p><p>class C {<br>    weak var delegate: &lt;UIViewController, UICollectionViewDelegate&gt;?<br>}<br></p><p>if let task = object as? &lt;NSManagedObject, Task&gt; {<br>    task.coreDataRelatedFunction()<br>    task.taskRelatedFunction()<br>}<br></p><p>Jacob Bandes-Storch<br></p><p>On Fri, Dec 4, 2015 at 3:07 PM, Daniel Muhra &lt;daniel.muhra at gmail.com&gt; wrote:<br></p><p>&gt; Currently it doesn’t seem possible to define a property or variable of a<br>&gt; specific class that also implements one or more protocols.<br>&gt; Take as an example the following definition from Objective C:<br>&gt;<br>&gt; NSManagedObject&lt;NSCoding, Task&gt;* someObject;<br>&gt;<br>&gt; To my knowledge, currently it is only possible to define multiple<br>&gt; protocols only:<br>&gt;<br>&gt; var object : protocol&lt;NSCoding, Task&gt;<br>&gt;<br>&gt; However, given the first example, sometimes it is not possible to restrict<br>&gt; to protocols only. This becomes especially cumbersome, if you would need to<br>&gt; cast down to such a construct within a single method and perform several<br>&gt; steps which would require all those type information:<br>&gt;<br>&gt; func doSomething(object: AnyObject) {<br>&gt;     if let managedObject = object as? NSManagedObject {<br>&gt;         // Do core data related stuff<br>&gt;     }<br>&gt;<br>&gt;<br>&gt;     if let task = object as? Task {<br>&gt;         // Do task related stuff<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; In this case you now have managedObject and task though you operate on the<br>&gt; same object. Also it is not (easily) possible to interleave actions of<br>&gt; those two.<br>&gt;<br>&gt; My first idea here would be to introduce an Objective C like style of type<br>&gt; naming. This also has the benefit, that it is perfectly clear, whether a<br>&gt; type name refers to a class or a protocol (without first having to check<br>&gt; it).<br>&gt; The downside, of course, is that protocol type variables would become<br>&gt; something like Any&lt;MyProtocol&gt;<br>&gt;<br>&gt; Any other ideas are welcome, but the initial problem still stands and<br>&gt; should be addressed.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/9d522b94/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Type information containing multiple additional protocols</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>December 15, 2015 at 06:00:00pm</p></header><div class="content"><p>At one point we talked about co-opting &quot;Any&quot; for this purpose, i.e. replacing the &quot;protocol&lt;…&gt;&quot; syntax with &quot;Any&lt;…&gt;&quot;. Like a concrete type, you&#39;re not required to provide arguments, so &quot;Any&quot; by itself doesn&#39;t change meaning. Like an inheritance clause, the compiler would check if you ever had more than one class there.<br></p><p>Jordan<br></p><p>&gt; On Dec 4, 2015, at 23:38 , Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt; <br>&gt; I think this is a very useful feature of Obj-C that I&#39;ve missed several times while writing Swift code.<br>&gt; <br>&gt; However, calling it &quot;TheClass&lt;Protocol1, Protocol2&gt;&quot; directly conflicts with the syntax for specifying generic type parameters.<br>&gt; <br>&gt; If we use &quot;protocol&lt;TheClass, Protocol1, Protocol2&gt;&quot; for this case, then `protocol` stops making sense. Maybe the keyword `class` could be allowed instead, like &quot;class&lt;TheClass, Protocol1, Protocol2&gt;&quot;.<br>&gt; <br>&gt; Or, it might work to omit the keyword entirely, leaving only the angle brackets:<br>&gt; <br>&gt; class C {<br>&gt;     weak var delegate: &lt;UIViewController, UICollectionViewDelegate&gt;?<br>&gt; }<br>&gt; <br>&gt; if let task = object as? &lt;NSManagedObject, Task&gt; {<br>&gt;     task.coreDataRelatedFunction()<br>&gt;     task.taskRelatedFunction()<br>&gt; }<br>&gt; <br>&gt; Jacob Bandes-Storch<br>&gt; <br>&gt; On Fri, Dec 4, 2015 at 3:07 PM, Daniel Muhra &lt;daniel.muhra at gmail.com &lt;mailto:daniel.muhra at gmail.com&gt;&gt; wrote:<br>&gt; Currently it doesn’t seem possible to define a property or variable of a specific class that also implements one or more protocols.<br>&gt; Take as an example the following definition from Objective C:<br>&gt; <br>&gt; NSManagedObject&lt;NSCoding, Task&gt;* someObject;<br>&gt; <br>&gt; To my knowledge, currently it is only possible to define multiple protocols only:<br>&gt; <br>&gt; var object : protocol&lt;NSCoding, Task&gt;<br>&gt; <br>&gt; However, given the first example, sometimes it is not possible to restrict to protocols only. This becomes especially cumbersome, if you would need to cast down to such a construct within a single method and perform several steps which would require all those type information:<br>&gt; <br>&gt; func doSomething(object: AnyObject) {<br>&gt;     if let managedObject = object as? NSManagedObject {<br>&gt;         // Do core data related stuff<br>&gt;     }<br>&gt;     <br>&gt;     if let task = object as? Task {<br>&gt;         // Do task related stuff<br>&gt;     }  <br>&gt; }<br>&gt; <br>&gt; In this case you now have managedObject and task though you operate on the same object. Also it is not (easily) possible to interleave actions of those two.<br>&gt; <br>&gt; My first idea here would be to introduce an Objective C like style of type naming. This also has the benefit, that it is perfectly clear, whether a type name refers to a class or a protocol (without first having to check it).<br>&gt; The downside, of course, is that protocol type variables would become something like Any&lt;MyProtocol&gt;<br>&gt; <br>&gt; Any other ideas are welcome, but the initial problem still stands and should be addressed.<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/31de4948/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Type information containing multiple additional protocols</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 15, 2015 at 06:00:00pm</p></header><div class="content"><p>Oh that&#39;s clever. I like that. It doesn&#39;t have a big impact on the<br>language and it makes reasonable sense when read. We could also<br>establish convention (possibly backed up by warnings) that says that if<br>Any&lt;...&gt; contains a class, the class name must come first.<br></p><p>-Kevin Ballard<br></p><p>On Tue, Dec 15, 2015, at 06:27 PM, Jordan Rose via swift-evolution wrote:<br>&gt; At one point we talked about co-opting &quot;Any&quot; for this purpose, i.e.<br>&gt; replacing the &quot;protocol&lt;…&gt;&quot; syntax with &quot;Any&lt;…&gt;&quot;. Like a concrete<br>&gt; type, you&#39;re not required to provide arguments, so &quot;Any&quot; by itself<br>&gt; doesn&#39;t change meaning. Like an inheritance clause, the compiler would<br>&gt; check if you ever had more than one class there.<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt;&gt; On Dec 4, 2015, at 23:38 , Jacob Bandes-Storch<br>&gt;&gt; &lt;jtbandes at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I think this is a very useful feature of Obj-C that I&#39;ve missed<br>&gt;&gt; several times while writing Swift code.<br>&gt;&gt;<br>&gt;&gt; However, calling it &quot;TheClass&lt;Protocol1, Protocol2&gt;&quot; directly<br>&gt;&gt; conflicts with the syntax for specifying generic type parameters.<br>&gt;&gt;<br>&gt;&gt; If we use &quot;protocol&lt;TheClass, Protocol1, Protocol2&gt;&quot; for this case,<br>&gt;&gt; then `protocol` stops making sense. Maybe the keyword `class` could<br>&gt;&gt; be allowed instead, like &quot;class&lt;TheClass, Protocol1, Protocol2&gt;&quot;.<br>&gt;&gt;<br>&gt;&gt; Or, it might work to omit the keyword entirely, leaving only the<br>&gt;&gt; angle brackets:<br>&gt;&gt;<br>&gt;&gt; class C {    weak var delegate: &lt;UIViewController,<br>&gt;&gt; UICollectionViewDelegate&gt;? }<br>&gt;&gt;<br>&gt;&gt; if let task = object as? &lt;NSManagedObject, Task&gt; {<br>&gt;&gt; task.coreDataRelatedFunction()    task.taskRelatedFunction() }<br>&gt;&gt;<br>&gt;&gt; Jacob Bandes-Storch<br>&gt;&gt;<br>&gt;&gt; On Fri, Dec 4, 2015 at 3:07 PM, Daniel<br>&gt;&gt; Muhra&lt;daniel.muhra at gmail.com&gt;wrote:<br>&gt;&gt;&gt; Currently it doesn’t seem possible to define a property or variable<br>&gt;&gt;&gt; of a specific class that also implements one or more protocols. Take<br>&gt;&gt;&gt; as an example the following definition from Objective C:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; NSManagedObject&lt;NSCoding, Task&gt;* someObject;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; To my knowledge, currently it is only possible to define multiple<br>&gt;&gt;&gt; protocols only:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; var object : protocol&lt;NSCoding, Task&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; However, given the first example, sometimes it is not possible to<br>&gt;&gt;&gt; restrict to protocols only. This becomes especially cumbersome, if<br>&gt;&gt;&gt; you would need to cast down to such a construct within a single<br>&gt;&gt;&gt; method and perform several steps which would require all those type<br>&gt;&gt;&gt; information:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; funcdoSomething(object:AnyObject) { ifletmanagedObject =<br>&gt;&gt;&gt; objectas?NSManagedObject{ // Do core data related stuff }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; iflettask = objectas?Task{ // Do task related stuff  } }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In this case you now have managedObject and task though you operate<br>&gt;&gt;&gt; on the same object. Also it is not (easily) possible to interleave<br>&gt;&gt;&gt; actions of those two.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; My first idea here would be to introduce an Objective C like style<br>&gt;&gt;&gt; of type naming. This also has the benefit, that it is perfectly<br>&gt;&gt;&gt; clear, whether a type name refers to a class or a protocol (without<br>&gt;&gt;&gt; first having to check it). The downside, of course, is that protocol<br>&gt;&gt;&gt; type variables would become something like Any&lt;MyProtocol&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Any other ideas are welcome, but the initial problem still stands<br>&gt;&gt;&gt; and should be addressed.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/0df45199/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>Type information containing multiple additional protocols</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>December 16, 2015 at 02:00:00pm</p></header><div class="content"><p>What about an approach like this:<br></p><p>// require value to be of type UIViewController AND conform to protocol<br>MySpecialProtocol<br>let specialViewController: (UIViewController &amp; MySpecialProtocol) = …<br></p><p>// require value to be of type Bool OR Double OR String OR SomeProtocol<br>let value: (Bool | Double | String | SomeProtocol)<br>switch value {<br>   case let _ as Bool: …<br>   case let _ as Double: …<br>   case let _ as String: …<br>   case let _ as SomeProtocol: …<br>   // no default necessary<br>}<br></p><p>No need to mess with the &lt;&gt; syntax or requiring the use of any keyword.<br>Just reusing binary logic for types.<br></p><p>On Wed, Dec 16, 2015 at 3:40 AM, Kevin Ballard via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Oh that&#39;s clever. I like that. It doesn&#39;t have a big impact on the<br>&gt; language and it makes reasonable sense when read. We could also establish<br>&gt; convention (possibly backed up by warnings) that says that if Any&lt;...&gt;<br>&gt; contains a class, the class name must come first.<br>&gt;<br>&gt; -Kevin Ballard<br>&gt;<br>&gt; On Tue, Dec 15, 2015, at 06:27 PM, Jordan Rose via swift-evolution wrote:<br>&gt;<br>&gt; At one point we talked about co-opting &quot;Any&quot; for this purpose, i.e.<br>&gt; replacing the &quot;protocol&lt;…&gt;&quot; syntax with &quot;Any&lt;…&gt;&quot;. Like a concrete type,<br>&gt; you&#39;re not required to provide arguments, so &quot;Any&quot; by itself doesn&#39;t change<br>&gt; meaning. Like an inheritance clause, the compiler would check if you ever<br>&gt; had more than one class there.<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt;<br>&gt; On Dec 4, 2015, at 23:38 , Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt;<br>&gt; I think this is a very useful feature of Obj-C that I&#39;ve missed several<br>&gt; times while writing Swift code.<br>&gt;<br>&gt; However, calling it &quot;TheClass&lt;Protocol1, Protocol2&gt;&quot; directly conflicts<br>&gt; with the syntax for specifying generic type parameters.<br>&gt;<br>&gt; If we use &quot;protocol&lt;TheClass, Protocol1, Protocol2&gt;&quot; for this case, then<br>&gt; `protocol` stops making sense. Maybe the keyword `class` could be allowed<br>&gt; instead, like &quot;class&lt;TheClass, Protocol1, Protocol2&gt;&quot;.<br>&gt;<br>&gt; Or, it might work to omit the keyword entirely, leaving only the angle<br>&gt; brackets:<br>&gt;<br>&gt; class C {<br>&gt;     weak var delegate: &lt;UIViewController, UICollectionViewDelegate&gt;?<br>&gt; }<br>&gt;<br>&gt; if let task = object as? &lt;NSManagedObject, Task&gt; {<br>&gt;     task.coreDataRelatedFunction()<br>&gt;     task.taskRelatedFunction()<br>&gt; }<br>&gt;<br>&gt; Jacob Bandes-Storch<br>&gt;<br>&gt; On Fri, Dec 4, 2015 at 3:07 PM, Daniel Muhra&lt;daniel.muhra at gmail.com&gt;wrote:<br>&gt;<br>&gt; Currently it doesn’t seem possible to define a property or variable of a<br>&gt; specific class that also implements one or more protocols.<br>&gt; Take as an example the following definition from Objective C:<br>&gt;<br>&gt; NSManagedObject&lt;NSCoding, Task&gt;* someObject;<br>&gt;<br>&gt; To my knowledge, currently it is only possible to define multiple<br>&gt; protocols only:<br>&gt;<br>&gt; var object : protocol&lt;NSCoding, Task&gt;<br>&gt;<br>&gt; However, given the first example, sometimes it is not possible to restrict<br>&gt; to protocols only. This becomes especially cumbersome, if you would need to<br>&gt; cast down to such a construct within a single method and perform several<br>&gt; steps which would require all those type information:<br>&gt;<br>&gt; funcdoSomething(object:AnyObject) {<br>&gt; ifletmanagedObject = objectas?NSManagedObject{<br>&gt; // Do core data related stuff<br>&gt; }<br>&gt;<br>&gt; iflettask = objectas?Task{<br>&gt; // Do task related stuff<br>&gt; }<br>&gt; }<br>&gt;<br>&gt; In this case you now have managedObject and task though you operate on the<br>&gt; same object. Also it is not (easily) possible to interleave actions of<br>&gt; those two.<br>&gt;<br>&gt; My first idea here would be to introduce an Objective C like style of type<br>&gt; naming. This also has the benefit, that it is perfectly clear, whether a<br>&gt; type name refers to a class or a protocol (without first having to check<br>&gt; it).<br>&gt; The downside, of course, is that protocol type variables would become<br>&gt; something like Any&lt;MyProtocol&gt;<br>&gt;<br>&gt; Any other ideas are welcome, but the initial problem still stands and<br>&gt; should be addressed.<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; *_______________________________________________*<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/e47c42e8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Type information containing multiple additional protocols</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 16, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; // require value to be of type Bool OR Double OR String OR SomeProtocol<br>&gt; let value: (Bool | Double | String | SomeProtocol)<br>&gt; switch value {<br>&gt;    case let _ as Bool: …<br>&gt;    case let _ as Double: …<br>&gt;    case let _ as String: …<br>&gt;    case let _ as SomeProtocol: …<br>&gt;    // no default necessary<br>&gt; }<br></p><p>This is a structural union type which has received considerable discussion with commentary from core team members already in the with a subject something like &quot;STL and Either&quot;.  You may be interested in reading that discussion.  The summary is that we are unlikely to see it without extremely compelling use cases.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/c625e80b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>Type information containing multiple additional protocols</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>December 16, 2015 at 04:00:00pm</p></header><div class="content"><p>Enumerations are a good example.<br>Or JSON nodes.<br></p><p>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002474.html<br>On Dec 16, 2015 16:05, &quot;Matthew Johnson&quot; &lt;matthew at anandabits.com&gt; wrote:<br></p><p>&gt;<br>&gt; // require value to be of type Bool OR Double OR String OR SomeProtocol<br>&gt; let value: (Bool | Double | String | SomeProtocol)<br>&gt; switch value {<br>&gt;    case let _ as Bool: …<br>&gt;    case let _ as Double: …<br>&gt;    case let _ as String: …<br>&gt;    case let _ as SomeProtocol: …<br>&gt;    // no default necessary<br>&gt; }<br>&gt;<br>&gt;<br>&gt; This is a structural union type which has received considerable discussion<br>&gt; with commentary from core team members already in the with a subject<br>&gt; something like &quot;STL and Either&quot;.  You may be interested in reading that<br>&gt; discussion.  The summary is that we are unlikely to see it without<br>&gt; extremely compelling use cases.<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/c2273bed/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Type information containing multiple additional protocols</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 16, 2015 at 09:00:00am</p></header><div class="content"><p>I don’t believe the implementers who would need to face the complexities in the implementation believe those are compelling examples.  It needs to be clear why a structural union is necessary rather than an enum.  To be clear: structural unions are to enums as tuples are to structs.<br></p><p>&gt; On Dec 16, 2015, at 9:16 AM, Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br>&gt; <br>&gt; Enumerations are a good example. <br>&gt; Or JSON nodes.<br>&gt; <br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002474.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002474.html&gt;<br>&gt; On Dec 16, 2015 16:05, &quot;Matthew Johnson&quot; &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; // require value to be of type Bool OR Double OR String OR SomeProtocol<br>&gt;&gt; let value: (Bool | Double | String | SomeProtocol)<br>&gt;&gt; switch value {<br>&gt;&gt;    case let _ as Bool: …<br>&gt;&gt;    case let _ as Double: …<br>&gt;&gt;    case let _ as String: …<br>&gt;&gt;    case let _ as SomeProtocol: …<br>&gt;&gt;    // no default necessary<br>&gt;&gt; }<br>&gt; <br>&gt; This is a structural union type which has received considerable discussion with commentary from core team members already in the with a subject something like &quot;STL and Either&quot;.  You may be interested in reading that discussion.  The summary is that we are unlikely to see it without extremely compelling use cases.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/176a70aa/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
