<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ea125c5cd93ba84769387c17c973e2b3?s=50"></div><header><strong>SwiftGlibc: Use VFS overlay instead of -fmodule-map-file</strong> from <string>rintaro ishizaki</string> &lt;fs.output at gmail.com&gt;<p>May 21, 2016 at 09:00:00pm</p></header><div class="content"><p>Hi all,<br></p><p>Recently, a couple of PR are posted regarding<br>glibc.modulemap in cross-compiling environment.<br></p><p>https://github.com/apple/swift/pull/2473<br>https://github.com/apple/swift/pull/2486<br></p><p>The problem is that glibc.modulemap contains hardcoded SDKROOT in it.<br>To resolve that, how about using virtual file system feature in Clang?<br></p><p>I mean, prepare YAML like this:<br></p><p>{<br>  &quot;use-external-names&quot;: false,<br>  &quot;roots&quot;: [<br>    {<br>      &quot;type&quot;: &quot;file&quot;,<br>      &quot;name&quot;: &quot;${SYSROOT}/usr/include/module.map&quot;,<br>      &quot;external-contents&quot;: &quot;${RSRC}/${platform}/${arch}/glibc.modulemap&quot;<br>    }<br>  ]<br>}<br></p><p>Then, invoke Clang with -ivfsoverlay argument.<br></p><p>Of course, we have to dynamically create YAML based on -sdk and -target<br>argument of the Swift compiler.<br>Luckily, Clang provides convenient YAML builder for this:<br>http://clang.llvm.org/doxygen/classclang_1_1vfs_1_1YAMLVFSWriter.html<br>It&#39;s easy and trivial work to build that dynamically.<br></p><p>Using this feature, glibc.modulemap can be rather simple.<br>No need to specify absolute path.<br>It can be simple as /usr/include/module.map in Darwin platforms:<br></p><p>    module ctype {<br>      header &quot;ctype.h&quot;<br>      export *<br>    }<br></p><p>And, it makes easy to import Clang builtin headers like &quot;limits.h&quot;.<br></p><p>Here is the PoC code:<br>https://github.com/apple/swift/compare/master...rintaro:clang-vfsoverlay<br>It works, and passes all Swift test suite.<br></p><p>Current my concerns are:<br>* The VFS overlay is the right way in the first place?<br>* Since I&#39;m a very newbie in C++ programming, I&#39;m not sure I&#39;m doing right<br>thing in the code.<br></p><p>Any thought?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160521/076dd41e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>SwiftGlibc: Use VFS overlay instead of -fmodule-map-file</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>May 23, 2016 at 09:00:00am</p></header><div class="content"><p>Hi, Rintaro. That’s a clever solution; it would mean we wouldn’t be blocked by talking to the Clang folks about making module map search paths SDKROOT-relative. That said, the VFS is a fairly, well, hacky piece of Clang, and I’m not sure we’d want to add a new dependency on it. Ben, Daniel, what do you think?<br></p><p>Jordan<br></p><p>&gt; On May 21, 2016, at 05:36, rintaro ishizaki via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi all,<br>&gt; <br>&gt; Recently, a couple of PR are posted regarding<br>&gt; glibc.modulemap in cross-compiling environment.<br>&gt; <br>&gt; https://github.com/apple/swift/pull/2473 &lt;https://github.com/apple/swift/pull/2473&gt;<br>&gt; https://github.com/apple/swift/pull/2486 &lt;https://github.com/apple/swift/pull/2486&gt;<br>&gt; <br>&gt; The problem is that glibc.modulemap contains hardcoded SDKROOT in it.<br>&gt; To resolve that, how about using virtual file system feature in Clang?<br>&gt; <br>&gt; I mean, prepare YAML like this:<br>&gt; <br>&gt; {<br>&gt;   &quot;use-external-names&quot;: false,<br>&gt;   &quot;roots&quot;: [<br>&gt;     {<br>&gt;       &quot;type&quot;: &quot;file&quot;,<br>&gt;       &quot;name&quot;: &quot;${SYSROOT}/usr/include/module.map&quot;,<br>&gt;       &quot;external-contents&quot;: &quot;${RSRC}/${platform}/${arch}/glibc.modulemap&quot;<br>&gt;     }<br>&gt;   ]<br>&gt; }<br>&gt; <br>&gt; Then, invoke Clang with -ivfsoverlay argument.<br>&gt; <br>&gt; Of course, we have to dynamically create YAML based on -sdk and -target<br>&gt; argument of the Swift compiler.<br>&gt; Luckily, Clang provides convenient YAML builder for this:<br>&gt; http://clang.llvm.org/doxygen/classclang_1_1vfs_1_1YAMLVFSWriter.html &lt;http://clang.llvm.org/doxygen/classclang_1_1vfs_1_1YAMLVFSWriter.html&gt;<br>&gt; It&#39;s easy and trivial work to build that dynamically.<br>&gt; <br>&gt; Using this feature, glibc.modulemap can be rather simple.<br>&gt; No need to specify absolute path.<br>&gt; It can be simple as /usr/include/module.map in Darwin platforms:<br>&gt; <br>&gt;     module ctype {<br>&gt;       header &quot;ctype.h&quot;<br>&gt;       export *<br>&gt;     }<br>&gt; <br>&gt; And, it makes easy to import Clang builtin headers like &quot;limits.h&quot;.<br>&gt; <br>&gt; Here is the PoC code:<br>&gt; https://github.com/apple/swift/compare/master...rintaro:clang-vfsoverlay &lt;https://github.com/apple/swift/compare/master...rintaro:clang-vfsoverlay&gt;<br>&gt; It works, and passes all Swift test suite.<br>&gt; <br>&gt; Current my concerns are:<br>&gt; * The VFS overlay is the right way in the first place?<br>&gt; * Since I&#39;m a very newbie in C++ programming, I&#39;m not sure I&#39;m doing right thing in the code.<br>&gt; <br>&gt; Any thought?<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160523/ae457d9e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ea125c5cd93ba84769387c17c973e2b3?s=50"></div><header><strong>SwiftGlibc: Use VFS overlay instead of -fmodule-map-file</strong> from <string>rintaro ishizaki</string> &lt;fs.output at gmail.com&gt;<p>May 26, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; That said, the VFS is a fairly, well, hacky piece of Clang, and I’m not<br>sure we’d want to add a new dependency on it. Ben, Daniel, what do you<br>think?<br></p><p>Actually, VFS overlay seems to be relatively new feature and looks unstable.<br>For instance,<br>https://github.com/apple/swift/compare/master...rintaro:clang-vfsoverlay#diff-3d555304611b40b626f0d2abd95b8e53R412<br>Because, with &quot;-sysroot /&quot;, Clang tries to find the module map<br>with path string //usr/include/module.map.<br>In *real* filesystem, //usr/include/module.map is usually equivalent to<br>/usr/include/module.map.<br>But in overlaid VFS, that needs exact string match. i.e. /usr doesn&#39;t match<br>//usr.<br></p><p>Nevertheless, I think, it&#39;s worth to implement this solution.<br>Even if Clang would have been modified to search headers SYSROOT<br>relative, it would still hard to import Clang builtin headers, I think.<br>To *properly* import them, as far as I understand, Clang requires bare<br>filename<br>in module map, such as header &quot;limits.h&quot;.<br>https://github.com/apple/swift-clang/blob/b9c42fe/lib/Lex/ModuleMap.cpp#L1860<br></p><p><br>2016-05-24 1:20 GMT+09:00 Jordan Rose &lt;jordan_rose at apple.com&gt;:<br></p><p>&gt; Hi, Rintaro. That’s a clever solution; it would mean we wouldn’t be<br>&gt; blocked by talking to the Clang folks about making module map search paths<br>&gt; SDKROOT-relative. That said, the VFS is a fairly, well, hacky piece of<br>&gt; Clang, and I’m not sure we’d want to add a new dependency on it. Ben,<br>&gt; Daniel, what do you think?<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt; On May 21, 2016, at 05:36, rintaro ishizaki via swift-dev &lt;<br>&gt; swift-dev at swift.org&gt; wrote:<br>&gt;<br>&gt; Hi all,<br>&gt;<br>&gt; Recently, a couple of PR are posted regarding<br>&gt; glibc.modulemap in cross-compiling environment.<br>&gt;<br>&gt; https://github.com/apple/swift/pull/2473<br>&gt; https://github.com/apple/swift/pull/2486<br>&gt;<br>&gt; The problem is that glibc.modulemap contains hardcoded SDKROOT in it.<br>&gt; To resolve that, how about using virtual file system feature in Clang?<br>&gt;<br>&gt; I mean, prepare YAML like this:<br>&gt;<br>&gt; {<br>&gt;   &quot;use-external-names&quot;: false,<br>&gt;   &quot;roots&quot;: [<br>&gt;     {<br>&gt;       &quot;type&quot;: &quot;file&quot;,<br>&gt;       &quot;name&quot;: &quot;${SYSROOT}/usr/include/module.map&quot;,<br>&gt;       &quot;external-contents&quot;: &quot;${RSRC}/${platform}/${arch}/glibc.modulemap&quot;<br>&gt;     }<br>&gt;   ]<br>&gt; }<br>&gt;<br>&gt; Then, invoke Clang with -ivfsoverlay argument.<br>&gt;<br>&gt; Of course, we have to dynamically create YAML based on -sdk and -target<br>&gt; argument of the Swift compiler.<br>&gt; Luckily, Clang provides convenient YAML builder for this:<br>&gt; http://clang.llvm.org/doxygen/classclang_1_1vfs_1_1YAMLVFSWriter.html<br>&gt; It&#39;s easy and trivial work to build that dynamically.<br>&gt;<br>&gt; Using this feature, glibc.modulemap can be rather simple.<br>&gt; No need to specify absolute path.<br>&gt; It can be simple as /usr/include/module.map in Darwin platforms:<br>&gt;<br>&gt;     module ctype {<br>&gt;       header &quot;ctype.h&quot;<br>&gt;       export *<br>&gt;     }<br>&gt;<br>&gt; And, it makes easy to import Clang builtin headers like &quot;limits.h&quot;.<br>&gt;<br>&gt; Here is the PoC code:<br>&gt; https://github.com/apple/swift/compare/master...rintaro:clang-vfsoverlay<br>&gt; It works, and passes all Swift test suite.<br>&gt;<br>&gt; Current my concerns are:<br>&gt; * The VFS overlay is the right way in the first place?<br>&gt; * Since I&#39;m a very newbie in C++ programming, I&#39;m not sure I&#39;m doing right<br>&gt; thing in the code.<br>&gt;<br>&gt; Any thought?<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160526/abd0631e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecb50a99bf3b4cc0249312945dce7115?s=50"></div><header><strong>SwiftGlibc: Use VFS overlay instead of -fmodule-map-file</strong> from <string>Ben Langmuir</string> &lt;blangmuir at apple.com&gt;<p>May 26, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On May 25, 2016, at 8:04 PM, rintaro ishizaki &lt;fs.output at gmail.com&gt; wrote:<br>&gt; <br>&gt; &gt; That said, the VFS is a fairly, well, hacky piece of Clang, and I’m not sure we’d want to add a new dependency on it. Ben, Daniel, what do you think?<br></p><p>Sorry for not replying earlier.  Daniel, I believe you considered building on top of the VFS for module maps like this before, and decided against it.  Can you share your reasoning?<br></p><p>&gt; <br>&gt; Actually, VFS overlay seems to be relatively new feature and looks unstable.<br>&gt; For instance, <br>&gt; https://github.com/apple/swift/compare/master...rintaro:clang-vfsoverlay#diff-3d555304611b40b626f0d2abd95b8e53R412 &lt;https://github.com/apple/swift/compare/master...rintaro:clang-vfsoverlay#diff-3d555304611b40b626f0d2abd95b8e53R412&gt;<br>&gt; Because, with &quot;-sysroot /&quot;, Clang tries to find the module map<br>&gt; with path string //usr/include/module.map.<br>&gt; In *real* filesystem, //usr/include/module.map is usually equivalent to /usr/include/module.map.<br>&gt; But in overlaid VFS, that needs exact string match. i.e. /usr doesn&#39;t match //usr.<br></p><p>Neat!  The problem is almost certainly that “//usr” is also a net name, so it would be treated as a single path component by llvm’s path handling code. We would need to explicitly add some fallback case to handle this.  Worth a bug report!<br></p><p>We certainly are not just doing exact string matches against paths :-)<br></p><p>&gt; <br>&gt; Nevertheless, I think, it&#39;s worth to implement this solution.<br>&gt; Even if Clang would have been modified to search headers SYSROOT<br>&gt; relative, it would still hard to import Clang builtin headers, I think.<br>&gt; To properly import them, as far as I understand, Clang requires bare filename<br>&gt; in module map, such as header &quot;limits.h&quot;.<br>&gt; https://github.com/apple/swift-clang/blob/b9c42fe/lib/Lex/ModuleMap.cpp#L1860 &lt;https://github.com/apple/swift-clang/blob/b9c42fe/lib/Lex/ModuleMap.cpp#L1860&gt;<br></p><p>Correct.<br></p><p>&gt; <br>&gt; <br>&gt; 2016-05-24 1:20 GMT+09:00 Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt;:<br>&gt; Hi, Rintaro. That’s a clever solution; it would mean we wouldn’t be blocked by talking to the Clang folks about making module map search paths SDKROOT-relative. That said, the VFS is a fairly, well, hacky piece of Clang, and I’m not sure we’d want to add a new dependency on it. Ben, Daniel, what do you think?<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt;&gt; On May 21, 2016, at 05:36, rintaro ishizaki via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; Recently, a couple of PR are posted regarding<br>&gt;&gt; glibc.modulemap in cross-compiling environment.<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift/pull/2473 &lt;https://github.com/apple/swift/pull/2473&gt;<br>&gt;&gt; https://github.com/apple/swift/pull/2486 &lt;https://github.com/apple/swift/pull/2486&gt;<br>&gt;&gt; <br>&gt;&gt; The problem is that glibc.modulemap contains hardcoded SDKROOT in it.<br>&gt;&gt; To resolve that, how about using virtual file system feature in Clang?<br>&gt;&gt; <br>&gt;&gt; I mean, prepare YAML like this:<br>&gt;&gt; <br>&gt;&gt; {<br>&gt;&gt;   &quot;use-external-names&quot;: false,<br>&gt;&gt;   &quot;roots&quot;: [<br>&gt;&gt;     {<br>&gt;&gt;       &quot;type&quot;: &quot;file&quot;,<br>&gt;&gt;       &quot;name&quot;: &quot;${SYSROOT}/usr/include/module.map&quot;,<br>&gt;&gt;       &quot;external-contents&quot;: &quot;${RSRC}/${platform}/${arch}/glibc.modulemap&quot;<br>&gt;&gt;     }<br>&gt;&gt;   ]<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Then, invoke Clang with -ivfsoverlay argument.<br>&gt;&gt; <br>&gt;&gt; Of course, we have to dynamically create YAML based on -sdk and -target<br>&gt;&gt; argument of the Swift compiler.<br>&gt;&gt; Luckily, Clang provides convenient YAML builder for this:<br>&gt;&gt; http://clang.llvm.org/doxygen/classclang_1_1vfs_1_1YAMLVFSWriter.html &lt;http://clang.llvm.org/doxygen/classclang_1_1vfs_1_1YAMLVFSWriter.html&gt;<br>&gt;&gt; It&#39;s easy and trivial work to build that dynamically.<br>&gt;&gt; <br>&gt;&gt; Using this feature, glibc.modulemap can be rather simple.<br>&gt;&gt; No need to specify absolute path.<br>&gt;&gt; It can be simple as /usr/include/module.map in Darwin platforms:<br>&gt;&gt; <br>&gt;&gt;     module ctype {<br>&gt;&gt;       header &quot;ctype.h&quot;<br>&gt;&gt;       export *<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; And, it makes easy to import Clang builtin headers like &quot;limits.h&quot;.<br>&gt;&gt; <br>&gt;&gt; Here is the PoC code:<br>&gt;&gt; https://github.com/apple/swift/compare/master...rintaro:clang-vfsoverlay &lt;https://github.com/apple/swift/compare/master...rintaro:clang-vfsoverlay&gt;<br>&gt;&gt; It works, and passes all Swift test suite.<br>&gt;&gt; <br>&gt;&gt; Current my concerns are:<br>&gt;&gt; * The VFS overlay is the right way in the first place?<br>&gt;&gt; * Since I&#39;m a very newbie in C++ programming, I&#39;m not sure I&#39;m doing right thing in the code.<br>&gt;&gt; <br>&gt;&gt; Any thought?<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160526/72765ae0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ea125c5cd93ba84769387c17c973e2b3?s=50"></div><header><strong>SwiftGlibc: Use VFS overlay instead of -fmodule-map-file</strong> from <string>rintaro ishizaki</string> &lt;fs.output at gmail.com&gt;<p>May 27, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; Neat!  The problem is almost certainly that “//usr” is also a net name,<br>so it would be treated as a single path component by llvm’s path handling<br>code. We would need to explicitly add some fallback case to handle this.<br>Worth a bug report!<br>&gt;<br>&gt; We certainly are not just doing exact string matches against paths :-)<br></p><p>Thank you for clarifying!<br>Filed a bug report:<br>https://llvm.org/bugs/show_bug.cgi?id=27909<br></p><p><br>2016-05-27 1:41 GMT+09:00 Ben Langmuir &lt;blangmuir at apple.com&gt;:<br></p><p>&gt;<br>&gt; On May 25, 2016, at 8:04 PM, rintaro ishizaki &lt;fs.output at gmail.com&gt; wrote:<br>&gt;<br>&gt; &gt; That said, the VFS is a fairly, well, hacky piece of Clang, and I’m not<br>&gt; sure we’d want to add a new dependency on it. Ben, Daniel, what do you<br>&gt; think?<br>&gt;<br>&gt;<br>&gt; Sorry for not replying earlier.  Daniel, I believe you considered building<br>&gt; on top of the VFS for module maps like this before, and decided against<br>&gt; it.  Can you share your reasoning?<br>&gt;<br>&gt;<br>&gt; Actually, VFS overlay seems to be relatively new feature and looks<br>&gt; unstable.<br>&gt; For instance,<br>&gt;<br>&gt; https://github.com/apple/swift/compare/master...rintaro:clang-vfsoverlay#diff-3d555304611b40b626f0d2abd95b8e53R412<br>&gt; Because, with &quot;-sysroot /&quot;, Clang tries to find the module map<br>&gt; with path string //usr/include/module.map.<br>&gt; In *real* filesystem, //usr/include/module.map is usually equivalent to<br>&gt; /usr/include/module.map.<br>&gt; But in overlaid VFS, that needs exact string match. i.e. /usr doesn&#39;t<br>&gt; match //usr.<br>&gt;<br>&gt;<br>&gt; Neat!  The problem is almost certainly that “//usr” is also a net name, so<br>&gt; it would be treated as a single path component by llvm’s path handling<br>&gt; code. We would need to explicitly add some fallback case to handle this.<br>&gt; Worth a bug report!<br>&gt;<br>&gt; We certainly are not just doing exact string matches against paths :-)<br>&gt;<br>&gt;<br>&gt; Nevertheless, I think, it&#39;s worth to implement this solution.<br>&gt; Even if Clang would have been modified to search headers SYSROOT<br>&gt; relative, it would still hard to import Clang builtin headers, I think.<br>&gt; To *properly* import them, as far as I understand, Clang requires bare<br>&gt; filename<br>&gt; in module map, such as header &quot;limits.h&quot;.<br>&gt;<br>&gt; https://github.com/apple/swift-clang/blob/b9c42fe/lib/Lex/ModuleMap.cpp#L1860<br>&gt;<br>&gt;<br>&gt; Correct.<br>&gt;<br>&gt;<br>&gt;<br>&gt; 2016-05-24 1:20 GMT+09:00 Jordan Rose &lt;jordan_rose at apple.com&gt;:<br>&gt;<br>&gt;&gt; Hi, Rintaro. That’s a clever solution; it would mean we wouldn’t be<br>&gt;&gt; blocked by talking to the Clang folks about making module map search paths<br>&gt;&gt; SDKROOT-relative. That said, the VFS is a fairly, well, hacky piece of<br>&gt;&gt; Clang, and I’m not sure we’d want to add a new dependency on it. Ben,<br>&gt;&gt; Daniel, what do you think?<br>&gt;&gt;<br>&gt;&gt; Jordan<br>&gt;&gt;<br>&gt;&gt; On May 21, 2016, at 05:36, rintaro ishizaki via swift-dev &lt;<br>&gt;&gt; swift-dev at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Hi all,<br>&gt;&gt;<br>&gt;&gt; Recently, a couple of PR are posted regarding<br>&gt;&gt; glibc.modulemap in cross-compiling environment.<br>&gt;&gt;<br>&gt;&gt; https://github.com/apple/swift/pull/2473<br>&gt;&gt; https://github.com/apple/swift/pull/2486<br>&gt;&gt;<br>&gt;&gt; The problem is that glibc.modulemap contains hardcoded SDKROOT in it.<br>&gt;&gt; To resolve that, how about using virtual file system feature in Clang?<br>&gt;&gt;<br>&gt;&gt; I mean, prepare YAML like this:<br>&gt;&gt;<br>&gt;&gt; {<br>&gt;&gt;   &quot;use-external-names&quot;: false,<br>&gt;&gt;   &quot;roots&quot;: [<br>&gt;&gt;     {<br>&gt;&gt;       &quot;type&quot;: &quot;file&quot;,<br>&gt;&gt;       &quot;name&quot;: &quot;${SYSROOT}/usr/include/module.map&quot;,<br>&gt;&gt;       &quot;external-contents&quot;: &quot;${RSRC}/${platform}/${arch}/glibc.modulemap&quot;<br>&gt;&gt;     }<br>&gt;&gt;   ]<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Then, invoke Clang with -ivfsoverlay argument.<br>&gt;&gt;<br>&gt;&gt; Of course, we have to dynamically create YAML based on -sdk and -target<br>&gt;&gt; argument of the Swift compiler.<br>&gt;&gt; Luckily, Clang provides convenient YAML builder for this:<br>&gt;&gt; http://clang.llvm.org/doxygen/classclang_1_1vfs_1_1YAMLVFSWriter.html<br>&gt;&gt; It&#39;s easy and trivial work to build that dynamically.<br>&gt;&gt;<br>&gt;&gt; Using this feature, glibc.modulemap can be rather simple.<br>&gt;&gt; No need to specify absolute path.<br>&gt;&gt; It can be simple as /usr/include/module.map in Darwin platforms:<br>&gt;&gt;<br>&gt;&gt;     module ctype {<br>&gt;&gt;       header &quot;ctype.h&quot;<br>&gt;&gt;       export *<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt; And, it makes easy to import Clang builtin headers like &quot;limits.h&quot;.<br>&gt;&gt;<br>&gt;&gt; Here is the PoC code:<br>&gt;&gt; https://github.com/apple/swift/compare/master...rintaro:clang-vfsoverlay<br>&gt;&gt; It works, and passes all Swift test suite.<br>&gt;&gt;<br>&gt;&gt; Current my concerns are:<br>&gt;&gt; * The VFS overlay is the right way in the first place?<br>&gt;&gt; * Since I&#39;m a very newbie in C++ programming, I&#39;m not sure I&#39;m doing<br>&gt;&gt; right thing in the code.<br>&gt;&gt;<br>&gt;&gt; Any thought?<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160527/0b5312f9/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>SwiftGlibc: Use VFS overlay instead of -fmodule-map-file</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>May 27, 2016 at 09:00:00pm</p></header><div class="content"><p>I’m not sure if we could dynamically generate the YAML because of multiarch, and because the GCC triple isn’t always the same as the LLVM triple.<br></p><p>For example, you might built ‘armv7-linux-gnueabihf’ for Swift/LLVM, but GCC only has ‘arm-linux-gnueabihf’. <br></p><p>But yeah, thats a really good find, it’s a flexible solution that would allow the same glibc.modulemap to be used by a host compiler when cross-compiling, and natively on the target.<br></p><p>Karl<br></p><p>&gt; On 21 May 2016, at 14:36, rintaro ishizaki via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi all,<br>&gt; <br>&gt; Recently, a couple of PR are posted regarding<br>&gt; glibc.modulemap in cross-compiling environment.<br>&gt; <br>&gt; https://github.com/apple/swift/pull/2473 &lt;https://github.com/apple/swift/pull/2473&gt;<br>&gt; https://github.com/apple/swift/pull/2486 &lt;https://github.com/apple/swift/pull/2486&gt;<br>&gt; <br>&gt; The problem is that glibc.modulemap contains hardcoded SDKROOT in it.<br>&gt; To resolve that, how about using virtual file system feature in Clang?<br>&gt; <br>&gt; I mean, prepare YAML like this:<br>&gt; <br>&gt; {<br>&gt;   &quot;use-external-names&quot;: false,<br>&gt;   &quot;roots&quot;: [<br>&gt;     {<br>&gt;       &quot;type&quot;: &quot;file&quot;,<br>&gt;       &quot;name&quot;: &quot;${SYSROOT}/usr/include/module.map&quot;,<br>&gt;       &quot;external-contents&quot;: &quot;${RSRC}/${platform}/${arch}/glibc.modulemap&quot;<br>&gt;     }<br>&gt;   ]<br>&gt; }<br>&gt; <br>&gt; Then, invoke Clang with -ivfsoverlay argument.<br>&gt; <br>&gt; Of course, we have to dynamically create YAML based on -sdk and -target<br>&gt; argument of the Swift compiler.<br>&gt; Luckily, Clang provides convenient YAML builder for this:<br>&gt; http://clang.llvm.org/doxygen/classclang_1_1vfs_1_1YAMLVFSWriter.html &lt;http://clang.llvm.org/doxygen/classclang_1_1vfs_1_1YAMLVFSWriter.html&gt;<br>&gt; It&#39;s easy and trivial work to build that dynamically.<br>&gt; <br>&gt; Using this feature, glibc.modulemap can be rather simple.<br>&gt; No need to specify absolute path.<br>&gt; It can be simple as /usr/include/module.map in Darwin platforms:<br>&gt; <br>&gt;     module ctype {<br>&gt;       header &quot;ctype.h&quot;<br>&gt;       export *<br>&gt;     }<br>&gt; <br>&gt; And, it makes easy to import Clang builtin headers like &quot;limits.h&quot;.<br>&gt; <br>&gt; Here is the PoC code:<br>&gt; https://github.com/apple/swift/compare/master...rintaro:clang-vfsoverlay &lt;https://github.com/apple/swift/compare/master...rintaro:clang-vfsoverlay&gt;<br>&gt; It works, and passes all Swift test suite.<br>&gt; <br>&gt; Current my concerns are:<br>&gt; * The VFS overlay is the right way in the first place?<br>&gt; * Since I&#39;m a very newbie in C++ programming, I&#39;m not sure I&#39;m doing right thing in the code.<br>&gt; <br>&gt; Any thought?<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160527/f9155e15/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ea125c5cd93ba84769387c17c973e2b3?s=50"></div><header><strong>SwiftGlibc: Use VFS overlay instead of -fmodule-map-file</strong> from <string>rintaro ishizaki</string> &lt;fs.output at gmail.com&gt;<p>May 28, 2016 at 04:00:00pm</p></header><div class="content"><p>Hi Karl,<br>(Just re-sending with CC: swift-dev)<br></p><p>I agree. This solution does not solve multiarch problem.<br>The installed module map still contains hardcoded arch directory name<br>of building machine.<br></p><p>e.g.<br>lib/swift/linux/x86_64/glibc.modulemap built on Ubuntu 15.10<br></p><p>    module ioctl {<br>      header &quot;x86_64-linux-gnu/sys/ioctl.h&quot;<br>      export *<br>    }<br></p><p><br>2016-05-28 4:49 GMT+09:00 Karl Wagner &lt;razielim at gmail.com&gt;:<br></p><p>&gt; I’m not sure if we could dynamically generate the YAML because of<br>&gt; multiarch, and because the GCC triple isn’t always the same as the LLVM<br>&gt; triple.<br>&gt;<br>&gt; For example, you might built ‘armv7-linux-gnueabihf’ for Swift/LLVM, but<br>&gt; GCC only has ‘arm-linux-gnueabihf’.<br>&gt;<br>&gt; But yeah, thats a really good find, it’s a flexible solution that would<br>&gt; allow the same glibc.modulemap to be used by a host compiler when<br>&gt; cross-compiling, and natively on the target.<br>&gt;<br>&gt; Karl<br>&gt;<br>&gt; On 21 May 2016, at 14:36, rintaro ishizaki via swift-dev &lt;<br>&gt; swift-dev at swift.org&gt; wrote:<br>&gt;<br>&gt; Hi all,<br>&gt;<br>&gt; Recently, a couple of PR are posted regarding<br>&gt; glibc.modulemap in cross-compiling environment.<br>&gt;<br>&gt; https://github.com/apple/swift/pull/2473<br>&gt; https://github.com/apple/swift/pull/2486<br>&gt;<br>&gt; The problem is that glibc.modulemap contains hardcoded SDKROOT in it.<br>&gt; To resolve that, how about using virtual file system feature in Clang?<br>&gt;<br>&gt; I mean, prepare YAML like this:<br>&gt;<br>&gt; {<br>&gt;   &quot;use-external-names&quot;: false,<br>&gt;   &quot;roots&quot;: [<br>&gt;     {<br>&gt;       &quot;type&quot;: &quot;file&quot;,<br>&gt;       &quot;name&quot;: &quot;${SYSROOT}/usr/include/module.map&quot;,<br>&gt;       &quot;external-contents&quot;: &quot;${RSRC}/${platform}/${arch}/glibc.modulemap&quot;<br>&gt;     }<br>&gt;   ]<br>&gt; }<br>&gt;<br>&gt; Then, invoke Clang with -ivfsoverlay argument.<br>&gt;<br>&gt; Of course, we have to dynamically create YAML based on -sdk and -target<br>&gt; argument of the Swift compiler.<br>&gt; Luckily, Clang provides convenient YAML builder for this:<br>&gt; http://clang.llvm.org/doxygen/classclang_1_1vfs_1_1YAMLVFSWriter.html<br>&gt; It&#39;s easy and trivial work to build that dynamically.<br>&gt;<br>&gt; Using this feature, glibc.modulemap can be rather simple.<br>&gt; No need to specify absolute path.<br>&gt; It can be simple as /usr/include/module.map in Darwin platforms:<br>&gt;<br>&gt;     module ctype {<br>&gt;       header &quot;ctype.h&quot;<br>&gt;       export *<br>&gt;     }<br>&gt;<br>&gt; And, it makes easy to import Clang builtin headers like &quot;limits.h&quot;.<br>&gt;<br>&gt; Here is the PoC code:<br>&gt; https://github.com/apple/swift/compare/master...rintaro:clang-vfsoverlay<br>&gt; It works, and passes all Swift test suite.<br>&gt;<br>&gt; Current my concerns are:<br>&gt; * The VFS overlay is the right way in the first place?<br>&gt; * Since I&#39;m a very newbie in C++ programming, I&#39;m not sure I&#39;m doing right<br>&gt; thing in the code.<br>&gt;<br>&gt; Any thought?<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160528/105b2bfa/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
