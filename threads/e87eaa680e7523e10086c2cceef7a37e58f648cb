<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Localization support for string interpolation</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April 25, 2016 at 03:00:00pm</p></header><div class="content"><p>on Sun Apr 24 2016, Chris Lattner &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; On Apr 24, 2016, at 2:33 PM, Chris Lattner via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Apr 21, 2016, at 12:42 AM, Daniel Höpfl via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;<br>&gt;&gt;&gt; Hi there!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; TL;DR: Here’s my idea for a better localized strings handling in Swift.<br>&gt;&gt;&gt; It includes both, support for string interpolation support for<br>&gt;&gt;&gt; NSLocalizedString, and a new string delimiter `...` that can be<br>&gt; used<br>&gt;&gt;&gt; instead of NSLocalizedString(&quot;...”).<br>&gt;&gt; <br>&gt;&gt; FWIW, this is closely related to the idea of extending string<br>&gt;&gt; interpolation to support generalized “printf” style modifiers, which<br>&gt;&gt; would allow very expressive formatting inline in a string<br>&gt;&gt; interpolation.  This has not yet come to pass, but a write up of the<br>&gt;&gt; ideas are available here:<br>&gt;&gt; https://github.com/apple/swift/blob/master/docs/TextFormatting.rst<br>&gt;<br>&gt; Actually, it looks like the interesting point didn’t make it into the<br>&gt; formal writeup.  The idea was to enable something like this (just a<br>&gt; sketch):<br>&gt;<br>&gt; public protocol CustomStringConvertible {<br>&gt;   /// A textual representation of `self`.<br>&gt;   var description: String { get }<br>&gt;<br>&gt;   func formattedDescription(format: String) -&gt; String { get }<br>&gt; }<br>&gt;<br>&gt; Int could then implement support for “x” to print hexadecimal, we<br>&gt; could support left/right whitespace padding, and custom types could<br>&gt; provide their own custom formatters (e.g. a string could have a title<br>&gt; case formatter, or a &quot;look up localized form of” modifier).  We could<br>&gt; then provide a “printf” that would allow traditional “%x0”<br>&gt; substitutions.  It could also be incorporated into the string literal<br>&gt; syntax by allowing something like:<br>&gt;<br>&gt; 	let hashValue = 42  // not a good hash function<br>&gt; 	print(“Hashcode = \(hashValue:x)”)<br>&gt;<br>&gt; This is just a sketch, but that’s the idea.  It never went anywhere<br>&gt; because we didn’t have the language features in place to make it work,<br>&gt; notably defaulted implementations in protocols were missing at the<br>&gt; time.<br></p><p>I believe I also had concerns about this design because it needlessly<br>misses opportunities for compile-time type safety.  There doesn&#39;t seem<br>to be any reason to embed the format specifier in a dynamic string that<br>has to be parsed at runtime.<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Localization support for string interpolation</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April 25, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; I believe I also had concerns about this design because it needlessly<br>&gt; misses opportunities for compile-time type safety.  There doesn&#39;t seem<br>&gt; to be any reason to embed the format specifier in a dynamic string that<br>&gt; has to be parsed at runtime.<br></p><p>I started drafting a post yesterday making the same point, but got bogged down in writing an example of what I *would* want to see.<br></p><p>In brief: printf()-style specifiers are kind of awful. They&#39;re very cryptic and unnecessarily unsafe. In C, this problem is addressed by compiler warnings, but Swift already has a mechanism to detect inappropriate combinations of data and operations: the type system. We should use it here.<br></p><p>If we had a protocol to handle formatting, I would want the method&#39;s parameter to be of an associated type and typically be something OptionSet-like. It might even be better to structure it as some sort of Formatter protocol. If properly designed, this might allow us to leverage Foundation&#39;s existing, fully-featured formatters rather than writing new ones just for Swift.<br></p><p>(This would be a big new feature, so personally, I would defer it.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Localization support for string interpolation</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April 25, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Apr 25, 2016, at 7:15 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; I believe I also had concerns about this design because it needlessly<br>&gt;&gt; misses opportunities for compile-time type safety.  There doesn&#39;t seem<br>&gt;&gt; to be any reason to embed the format specifier in a dynamic string that<br>&gt;&gt; has to be parsed at runtime.<br>&gt; <br>&gt; I started drafting a post yesterday making the same point, but got bogged down in writing an example of what I *would* want to see.<br>&gt; <br>&gt; In brief: printf()-style specifiers are kind of awful. They&#39;re very cryptic and unnecessarily unsafe. In C, this problem is addressed by compiler warnings, but Swift already has a mechanism to detect inappropriate combinations of data and operations: the type system. We should use it here.<br>&gt; <br>&gt; If we had a protocol to handle formatting, I would want the method&#39;s parameter to be of an associated type and typically be something OptionSet-like. It might even be better to structure it as some sort of Formatter protocol. If properly designed, this might allow us to leverage Foundation&#39;s existing, fully-featured formatters rather than writing new ones just for Swift.<br></p><p><br>Keep in mind that succinctness is a virtue, especially when using embedded annotations. (I really liked your first go at this)<br>Also leveraging training and experience using the (ugly but) time-tested shorthand form is not necessarily bad. The safety<br>issue comes more in matching types, not in doing something like \(foo.#(%06.1f))<br></p><p>-- E<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Localization support for string interpolation</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April 26, 2016 at 04:00:00pm</p></header><div class="content"><p>on Mon Apr 25 2016, Erica Sadun &lt;erica-AT-ericasadun.com&gt; wrote:<br></p><p>&gt;&gt; On Apr 25, 2016, at 7:15 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; I believe I also had concerns about this design because it needlessly<br>&gt;&gt;&gt; misses opportunities for compile-time type safety.  There doesn&#39;t seem<br>&gt;&gt;&gt; to be any reason to embed the format specifier in a dynamic string that<br>&gt;<br>&gt;&gt;&gt; has to be parsed at runtime.<br>&gt;&gt; <br>&gt;&gt; I started drafting a post yesterday making the same point, but got bogged down in writing an example of what I *would* want to see.<br>&gt;&gt; <br>&gt;&gt; In brief: printf()-style specifiers are kind of awful. They&#39;re very<br>&gt;&gt; cryptic and unnecessarily unsafe. In C, this problem is addressed by<br>&gt;&gt; compiler warnings, but Swift already has a mechanism to detect<br>&gt;&gt; inappropriate combinations of data and operations: the type<br>&gt;&gt; system. We should use it here.<br>&gt;&gt; <br>&gt;&gt; If we had a protocol to handle formatting, I would want the method&#39;s<br>&gt;&gt; parameter to be of an associated type and typically be something<br>&gt;&gt; OptionSet-like. It might even be better to structure it as some sort<br>&gt;&gt; of Formatter protocol. If properly designed, this might allow us to<br>&gt;&gt; leverage Foundation&#39;s existing, fully-featured formatters rather<br>&gt;&gt; than writing new ones just for Swift.<br>&gt;<br>&gt; Keep in mind that succinctness is a virtue, especially when using<br>&gt; embedded annotations. (I really liked your first go at this) Also<br>&gt; leveraging training and experience using the (ugly but) time-tested<br>&gt; shorthand form is not necessarily bad. The safety issue comes more in<br>&gt; matching types, not in doing something like \(foo.#(%06.1f))<br></p><p>It&#39;s not a matter of type or memory safety, so maybe I should have said<br>that it misses opportunities for static checking.  The problem is that<br>“.#(%06.1f)” might not apply to foo.<br></p><p>Also, frankly I think printf syntax is arcane and readable only to a<br>small fraction of developers.  Take a complete read through the man page<br>sometime if you really want your mind blown!<br></p><p>If you&#39;re going to take a string interpolation approach, we can instead<br>know *exactly* what formatting options apply to “foo,” express them<br>readably, and check them at compile time.<br></p><p>The problem is that localization may really be incompatible with<br>Swift-style compile-time-checked string interpolation with embedded<br>formatting, because of:<br></p><p>1. The need to look up localized strings in tables for a given language,<br>   making them basically dynamic as far as the compiler is concerned.<br></p><p>2. The need for localizers (i.e. not the application programmer) to<br>   tune both the string content and how the arguments are formatted.<br></p><p>IMO this problem begs for a holistic solution that integrates a DSL for<br>localizers with language and library features in Swift.<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/db7c62d41f9a0504127e52ccceb2e886?s=50"></div><header><strong>Localization support for string interpolation</strong> from <string>Norbert Lindenberg</string> &lt;swift at lindenbergsoftware.com&gt;<p>April 28, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Apr 26, 2016, at 16:16 , Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Also, frankly I think printf syntax is arcane and readable only to a<br>&gt; small fraction of developers.  Take a complete read through the man page<br>&gt; sometime if you really want your mind blown!<br>&gt; <br>&gt; If you&#39;re going to take a string interpolation approach, we can instead<br>&gt; know *exactly* what formatting options apply to “foo,” express them<br>&gt; readably, and check them at compile time.<br>&gt; <br>&gt; The problem is that localization may really be incompatible with<br>&gt; Swift-style compile-time-checked string interpolation with embedded<br>&gt; formatting, because of:<br>&gt; <br>&gt; 1. The need to look up localized strings in tables for a given language,<br>&gt;   making them basically dynamic as far as the compiler is concerned.<br>&gt; <br>&gt; 2. The need for localizers (i.e. not the application programmer) to<br>&gt;   tune both the string content and how the arguments are formatted.<br></p><p>Very true. Separating localizable strings from source code is critical to making the localization process manageable, and the syntax used in localizable strings must be easy to understand for translators, who are hardly ever engineers, or supported by the tools that translators use.<br></p><p>Localization of messages also has some requirements that haven’t been discussed here yet:<br></p><p>– Inserting a number into a sentence often requires adjusting other parts of the sentence (nouns, verbs, articles) to the number. And while English has only singular and plural, other languages distinguish more cases – up to six for Arabic.<br></p><p>– Inserting a name or noun into a sentence often requires adjusting other parts of the sentence to the gender of the person or noun. While in English gender usually is only reflected in pronouns, its impact is pervasive in some other languages.<br></p><p>– Formats for numbers and dates should be specified at a high enough level that they can be automatically translated by internationalization libraries. For example, don’t specify the order of year, month, day and the characters to be used around them; specify just whether you want to have a long or a short form and which components, and let an internationalization library handle the rest.<br></p><p>One well supported and commonly used library handling this is ICU with its MessageFormat class:<br>http://userguide.icu-project.org/formatparse/messages<br>http://icu-project.org/apiref/icu4c/classMessageFormat.html#details<br></p><p>If there is dedicated support for localizable messages in Swift, it should be at least as good as MessageFormat – and translators should have at least as strong a say in what’s good as software engineers.<br></p><p>Norbert<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Localization support for string interpolation</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April 28, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; – Inserting a number into a sentence often requires adjusting other parts of the sentence (nouns, verbs, articles) to the number. And while English has only singular and plural, other languages distinguish more cases – up to six for Arabic.<br>&gt; <br>&gt; – Inserting a name or noun into a sentence often requires adjusting other parts of the sentence to the gender of the person or noun. While in English gender usually is only reflected in pronouns, its impact is pervasive in some other languages.<br>&gt; <br>&gt; – Formats for numbers and dates should be specified at a high enough level that they can be automatically translated by internationalization libraries. For example, don’t specify the order of year, month, day and the characters to be used around them; specify just whether you want to have a long or a short form and which components, and let an internationalization library handle the rest.<br></p><p>This is all true, but it&#39;s also all handled by Foundation on Apple platforms and hopefully by Corelibs Foundation elsewhere. We ought to be able to hook into this existing machinery.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3a02fb5c94ea077d3576e3e830309bee?s=50"></div><header><strong>Localization support for string interpolation</strong> from <string>Daniel Höpfl</string> &lt;daniel at hoepfl.de&gt;<p>May 20, 2016 at 09:00:00am</p></header><div class="content"><p>Hi.<br></p><p>On 29.04.16 05:31, Brent Royal-Gordon via swift-evolution wrote:<br>&gt;&gt; – Inserting a number into a sentence often requires adjusting other parts of the sentence (nouns, verbs, articles) to the number. And while English has only singular and plural, other languages distinguish more cases – up to six for Arabic.<br>&gt;&gt;<br>&gt;&gt; – Inserting a name or noun into a sentence often requires adjusting other parts of the sentence to the gender of the person or noun. While in English gender usually is only reflected in pronouns, its impact is pervasive in some other languages.<br>&gt;&gt;<br>&gt;&gt; – Formats for numbers and dates should be specified at a high enough level that they can be automatically translated by internationalization libraries. For example, don’t specify the order of year, month, day and the characters to be used around them; specify just whether you want to have a long or a short form and which components, and let an internationalization library handle the rest.<br>&gt; <br>&gt; This is all true, but it&#39;s also all handled by Foundation on Apple platforms and hopefully by Corelibs Foundation elsewhere. We ought to be able to hook into this existing machinery.<br></p><p>That&#39;s what I think, too: Let Foundation handle the &quot;how to translate&quot;,<br>my proposal is just &quot;syntactic sugar&quot;.<br></p><p><br></p><p>Since I did not see any more concerns about the proposal, I&#39;d like to<br>push my proposal forward. Can anyone give me a hint what to do next?<br>Would sending a pull request be the next step? (The evolution readme<br>just says &quot;Ideas should be thoroughly discussed on the swift-evolution<br>mailing list first.&quot; Have we reached this point?)<br></p><p>Thanks for your input,<br>   Daniel<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
