<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d569462ac92d4619342b1c5ff305043?s=50"></div><header><strong>[proposal] Union Type</strong> from <string>frogcjn at 163.com</string> &lt;frogcjn at 163.com&gt;<p>May 16, 2016 at 07:00:00pm</p></header><div class="content"><p>Union is far better then generic enum/protocol solution.<br>        * It can extend the original enum and make it powerful.<br>		<br>enum ResultDataType {<br>    case Music<br>    case Video<br>    case File<br>}<br></p><p>enum FailureType {<br>    case HTTP404<br>    case HTTP502<br>}<br></p><p>enum FailureTypev2 {<br>    case HTTP451<br>}<br></p><p>typealias Result = (ResultDataType | FailureType | FailureTypev2)<br></p><p>	* It keeps the code clear and does not need developer to announce some unnecessary protocols or enums.<br>		like UnionOf3&lt;T,U,V&gt; or ProtocolForABC<br></p><p>        * It is easy to wrap original value into an union type.<br>		let a = A()<br>	let union: (A|B|C) = a // Automatically wrap.<br></p><p>	* Compiler might search their common properties, and methods, then mark them as a member of the union type.<br>		print(value.someCommonProperty) // Compiler will know their common properties automatically.<br></p><p><br>	* Compiler know the union type exactly composed with which types, better than only know which protocol.<br>		func input(value: ProtocolForABC) {<br>		if value is A {<br>        <br>    		} else if value is B {<br>        <br>    		} else if value is C {<br>        <br>    		} else {<br>        		// There are other cases? Compiler doesn&#39;t know<br>    		}<br>	}<br></p><p>        * Original types and union types can have a rational relationship between each other. <br>               Original type is a sub-type of union types contain it.<br></p><p>	var fn0: A-&gt;Void = {print(v0)}<br>	var fn1: (A|B)-&gt;Void = {print(v0)}<br></p><p>	fn0 = fn1 // Original Type and Union Type has a sub-typing relationship, OK<br></p><p>	var fn2: (A|B|C)-&gt;Void = {print($0)}<br></p><p>	fn0 = fn2 // OK<br>	fn1 = fn2 // OK<br></p><p><br>        * It is also easy to compare with value of original type.<br>		union == a // Can be compared, Yes for most cases.<br></p><p>	* And the most important part, It can replace Optional&lt;T&gt;.<br>		let string: String?<br>	is same to <br>		let string: (String | None)  instead of let string: Optional&lt;String&gt;<br>		<br></p><p>I really think the union type is a good supplement for Swift. Make the language rational.<br>And the It is also really good for Reactive Programming.           <br></p><p>- Jiannan  <br></p><p>&gt; 下面是被转发的邮件：<br>&gt; <br>&gt; 发件人: Haravikk &lt;swift-evolution at haravikk.me&gt;<br>&gt; 主题: 回复： [swift-evolution] Union instead of Optional<br>&gt; 日期: 2016年5月16日 GMT+8 18:35:25<br>&gt; 收件人: Austin Zheng &lt;austinzheng at gmail.com&gt;<br>&gt; 抄送: Cao Jiannan &lt;frogcjn at 163.com&gt;, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt; <br>&gt; <br>&gt;&gt; On 16 May 2016, at 11:17, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; If A, B, and C are not related via protocol or class inheritance, then there is almost nothing you can do with value. Otherwise you still need to test against the concrete type using a case statement or a if-else ladder.<br>&gt; <br>&gt; I think that a case statement or similar syntax will still be needed, and the case names would just be the types themselves. This would work best with support for type-narrowing, for example:<br>&gt; <br>&gt; 	func someMethod(value:(A|B|C)) {<br>&gt; 		switch (value) {<br>&gt; 			case .A:<br>&gt; 				value.someMethodForTypeA()<br>&gt; 			case .B:<br>&gt; 				value.someMethodForTypeB()<br>&gt; 			case .C:<br>&gt; 				value.someMethodForTypeC()<br>&gt; 		}<br>&gt; 	}<br>&gt; <br>&gt; A union should really just be though of as a lightweight, restricted form of enum that can be declared in a quick ad-hoc fashion, similar to how tuples are a simpler form of struct.<br>&gt; <br>&gt; I’m generally a +1 for the feature, but I’d be interested to hear about how well equipped the compiler is for optimising something like this. In most cases an Optional covers what I need, and in more complex cases I’d probably declare overloads for each type (i.e- someMethod(value:A), someMethod(value:B) etc.); unions could make the latter case simpler, but will the compiler produce the same code behind the scenes, i.e- by isolating what’s unique to each type?<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160516/6728e085/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[proposal] Union Type</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>May 17, 2016 at 08:00:00pm</p></header><div class="content"><p>Jiannan, I agree there is an use for union types, I&#39;m just not really fond<br>of the syntax (I&#39;d really prefer something like &#39;union&lt;...&gt;&#39;) and with<br>using it for optionals. To enable this syntax for optionals, None would<br>have to be a valid type of the language and that would enable one to create<br>the following constructions:<br></p><p>    func something(value: None) -&gt; None { ... }<br></p><p>It wouldn&#39;t be essentially wrong but unnecessary since nil would be the<br>only possible value of the type None. And I don&#39;t really see any need to<br>change the way optionals are implemented to support unions. And we could<br>still have optional unions using either syntax with existing optional<br>syntax (which is very clear to me):<br></p><p>    func something(value: (A | B | C)?) { ... }<br></p><p>or<br></p><p>    func something(value: union&lt;A, B, C&gt;?) { ... }<br></p><p>Just as I said before, I don&#39;t really think unions are necessary (did you<br>mean overloading?) but I don&#39;t oppose them. I just don&#39;t think we need to<br>change the way a feature already works to justify the addition of a new<br>feature.<br></p><p><br>- Leonardo<br></p><p>On 16 May 2016 at 08:26, Cao Jiannan via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Union is far better then generic enum/protocol solution.<br>&gt;         * It can extend the original enum and make it powerful.<br>&gt; enum ResultDataType {<br>&gt;     case Music<br>&gt;     case Video<br>&gt;     case File<br>&gt; }<br>&gt;<br>&gt; enum FailureType {<br>&gt;     case HTTP404<br>&gt;     case HTTP502<br>&gt; }<br>&gt;<br>&gt; enum FailureTypev2 {<br>&gt;     case HTTP451<br>&gt; }<br>&gt;<br>&gt; typealias Result = (ResultDataType | FailureType | FailureTypev2)<br>&gt;<br>&gt; * It keeps the code clear and does not need developer to announce some<br>&gt; unnecessary protocols or enums.<br>&gt; like UnionOf3&lt;T,U,V&gt; or ProtocolForABC<br>&gt;<br>&gt;         * It is easy to wrap original value into an union type.<br>&gt; let a = A()<br>&gt; let union: (A|B|C) = a // Automatically wrap.<br>&gt;<br>&gt; * Compiler might search their common properties, and methods, then mark<br>&gt; them as a member of the union type.<br>&gt; print(value.someCommonProperty) // Compiler will know their common<br>&gt; properties automatically.<br>&gt;<br>&gt;<br>&gt; * Compiler know the union type exactly composed with which types, better<br>&gt; than only know which protocol.<br>&gt; func input(value: ProtocolForABC) {<br>&gt; if value is A {<br>&gt;<br>&gt;     } else if value is B {<br>&gt;<br>&gt;     } else if value is C {<br>&gt;<br>&gt;     } else {<br>&gt;          // There are other cases? Compiler doesn&#39;t know<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt;         * Original types and union types can have a rational relationship<br>&gt; between each other.<br>&gt;                Original type is a sub-type of union types contain it.<br>&gt;<br>&gt; var fn0: A-&gt;Void = {print(v0)}<br>&gt; var fn1: (A|B)-&gt;Void = {print(v0)}<br>&gt;<br>&gt; fn0 = fn1 // Original Type and Union Type has a sub-typing relationship,<br>&gt; OK<br>&gt;<br>&gt; var fn2: (A|B|C)-&gt;Void = {print($0)}<br>&gt;<br>&gt; fn0 = fn2 // OK<br>&gt; fn1 = fn2 // OK<br>&gt;<br>&gt;<br>&gt;         * It is also easy to compare with value of original type.<br>&gt; union == a // Can be compared, Yes for most cases.<br>&gt;<br>&gt; * And the most important part, *It can replace Optional&lt;T&gt;.*<br>&gt; let string: String?<br>&gt; is same to<br>&gt; let string: (String | None)  instead of let string: Optional&lt;String&gt;<br>&gt;<br>&gt; I really think the union type is a good supplement for Swift. Make the<br>&gt; language rational.<br>&gt; And the It is also really good for Reactive Programming.<br>&gt;<br>&gt; - Jiannan<br>&gt;<br>&gt; 下面是被转发的邮件：<br>&gt;<br>&gt; *发件人: *Haravikk &lt;swift-evolution at haravikk.me&gt;<br>&gt; *主题: **回复： [swift-evolution] Union instead of Optional*<br>&gt; *日期: *2016年5月16日 GMT+8 18:35:25<br>&gt; *收件人: *Austin Zheng &lt;austinzheng at gmail.com&gt;<br>&gt; *抄送: *Cao Jiannan &lt;frogcjn at 163.com&gt;, Adrian Zubarev via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;<br>&gt;<br>&gt;<br>&gt; On 16 May 2016, at 11:17, Austin Zheng via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; If A, B, and C are not related via protocol or class inheritance, then<br>&gt; there is almost nothing you can do with value. Otherwise you still need to<br>&gt; test against the concrete type using a case statement or a if-else ladder.<br>&gt;<br>&gt;<br>&gt; I think that a case statement or similar syntax will still be needed, and<br>&gt; the case names would just be the types themselves. This would work best<br>&gt; with support for type-narrowing, for example:<br>&gt;<br>&gt; func someMethod(value:(A|B|C)) {<br>&gt; switch (value) {<br>&gt; case .A:<br>&gt; value.someMethodForTypeA()<br>&gt; case .B:<br>&gt; value.someMethodForTypeB()<br>&gt; case .C:<br>&gt; value.someMethodForTypeC()<br>&gt; }<br>&gt; }<br>&gt;<br>&gt; A union should really just be though of as a lightweight, restricted form<br>&gt; of enum that can be declared in a quick ad-hoc fashion, similar to how<br>&gt; tuples are a simpler form of struct.<br>&gt;<br>&gt; I’m generally a +1 for the feature, but I’d be interested to hear about<br>&gt; how well equipped the compiler is for optimising something like this. In<br>&gt; most cases an Optional covers what I need, and in more complex cases I’d<br>&gt; probably declare overloads for each type (i.e- someMethod(value:A),<br>&gt; someMethod(value:B) etc.); unions could make the latter case simpler, but<br>&gt; will the compiler produce the same code behind the scenes, i.e- by<br>&gt; isolating what’s unique to each type?<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160517/ea1d5fd4/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>[proposal] Union Type</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>May 17, 2016 at 06:00:00pm</p></header><div class="content"><p>Cavet: I have not been following this, so probably someone has said this somewhere and flaws were pointed out.<br></p><p>I don’t really understand the need for union types when you can have multiple methods of the same name that differ only by the type of their parameter:<br></p><p>func something(value: A) {}<br>func something(value: B) {}<br>func something(value: C) {}<br></p><p>Doesn’t this more or less accomplish the same thing without needing a switch/if tree or whatever else inside the method to break the types back apart again in the method body and without even needing any new mechanism in the language at all?<br></p><p>Again, sorry for the (very likely) redundant noise on my part.<br></p><p>l8r<br>Sean<br></p><p><br></p><p>&gt; On May 17, 2016, at 6:09 PM, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Jiannan, I agree there is an use for union types, I&#39;m just not really fond of the syntax (I&#39;d really prefer something like &#39;union&lt;...&gt;&#39;) and with using it for optionals. To enable this syntax for optionals, None would have to be a valid type of the language and that would enable one to create the following constructions:<br>&gt; <br>&gt;     func something(value: None) -&gt; None { ... }<br>&gt; <br>&gt; It wouldn&#39;t be essentially wrong but unnecessary since nil would be the only possible value of the type None. And I don&#39;t really see any need to change the way optionals are implemented to support unions. And we could still have optional unions using either syntax with existing optional syntax (which is very clear to me):<br>&gt; <br>&gt;     func something(value: (A | B | C)?) { ... }<br>&gt; <br>&gt; or<br>&gt; <br>&gt;     func something(value: union&lt;A, B, C&gt;?) { ... }<br>&gt; <br>&gt; Just as I said before, I don&#39;t really think unions are necessary (did you mean overloading?) but I don&#39;t oppose them. I just don&#39;t think we need to change the way a feature already works to justify the addition of a new feature.<br>&gt; <br>&gt; <br>&gt; - Leonardo<br>&gt; <br>&gt; On 16 May 2016 at 08:26, Cao Jiannan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Union is far better then generic enum/protocol solution.<br>&gt;         * It can extend the original enum and make it powerful.<br>&gt; 		<br>&gt; enum ResultDataType {<br>&gt;     case Music<br>&gt;     case Video<br>&gt;     case File<br>&gt; }<br>&gt; <br>&gt; enum FailureType {<br>&gt;     case HTTP404<br>&gt;     case HTTP502<br>&gt; }<br>&gt; <br>&gt; enum FailureTypev2 {<br>&gt;     case HTTP451<br>&gt; }<br>&gt; <br>&gt; typealias Result = (ResultDataType | FailureType | FailureTypev2)<br>&gt; <br>&gt; 	* It keeps the code clear and does not need developer to announce some unnecessary protocols or enums.<br>&gt; 		like UnionOf3&lt;T,U,V&gt; or ProtocolForABC<br>&gt; <br>&gt;         * It is easy to wrap original value into an union type.<br>&gt; 		let a = A()<br>&gt; 	let union: (A|B|C) = a // Automatically wrap.<br>&gt; <br>&gt; 	* Compiler might search their common properties, and methods, then mark them as a member of the union type.<br>&gt; 		print(value.someCommonProperty) // Compiler will know their common properties automatically.<br>&gt; <br>&gt; <br>&gt; 	* Compiler know the union type exactly composed with which types, better than only know which protocol.<br>&gt; 		func input(value: ProtocolForABC) {<br>&gt; 		if value is A {<br>&gt;         <br>&gt;     		} else if value is B {<br>&gt;         <br>&gt;     		} else if value is C {<br>&gt;         <br>&gt;     		} else {<br>&gt;         		// There are other cases? Compiler doesn&#39;t know<br>&gt;     		}<br>&gt; 	}<br>&gt; <br>&gt;         * Original types and union types can have a rational relationship between each other. <br>&gt;                Original type is a sub-type of union types contain it.<br>&gt; <br>&gt; 	var fn0: A-&gt;Void = {print(v0)}<br>&gt; 	var fn1: (A|B)-&gt;Void = {print(v0)}<br>&gt; <br>&gt; 	fn0 = fn1 // Original Type and Union Type has a sub-typing relationship, OK<br>&gt; <br>&gt; 	var fn2: (A|B|C)-&gt;Void = {print($0)}<br>&gt; <br>&gt; 	fn0 = fn2 // OK<br>&gt; 	fn1 = fn2 // OK<br>&gt; <br>&gt; <br>&gt;         * It is also easy to compare with value of original type.<br>&gt; 		union == a // Can be compared, Yes for most cases.<br>&gt; <br>&gt; 	* And the most important part, It can replace Optional&lt;T&gt;.<br>&gt; 		let string: String?<br>&gt; 	is same to <br>&gt; 		let string: (String | None)  instead of let string: Optional&lt;String&gt;<br>&gt; 		<br>&gt; <br>&gt; I really think the union type is a good supplement for Swift. Make the language rational.<br>&gt; And the It is also really good for Reactive Programming.           <br>&gt; <br>&gt; - Jiannan  <br>&gt; <br>&gt;&gt; 下面是被转发的邮件：<br>&gt;&gt; <br>&gt;&gt; 发件人: Haravikk &lt;swift-evolution at haravikk.me&gt;<br>&gt;&gt; 主题: 回复： [swift-evolution] Union instead of Optional<br>&gt;&gt; 日期: 2016年5月16日 GMT+8 18:35:25<br>&gt;&gt; 收件人: Austin Zheng &lt;austinzheng at gmail.com&gt;<br>&gt;&gt; 抄送: Cao Jiannan &lt;frogcjn at 163.com&gt;, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 16 May 2016, at 11:17, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If A, B, and C are not related via protocol or class inheritance, then there is almost nothing you can do with value. Otherwise you still need to test against the concrete type using a case statement or a if-else ladder.<br>&gt;&gt; <br>&gt;&gt; I think that a case statement or similar syntax will still be needed, and the case names would just be the types themselves. This would work best with support for type-narrowing, for example:<br>&gt;&gt; <br>&gt;&gt; 	func someMethod(value:(A|B|C)) {<br>&gt;&gt; 		switch (value) {<br>&gt;&gt; 			case .A:<br>&gt;&gt; 				value.someMethodForTypeA()<br>&gt;&gt; 			case .B:<br>&gt;&gt; 				value.someMethodForTypeB()<br>&gt;&gt; 			case .C:<br>&gt;&gt; 				value.someMethodForTypeC()<br>&gt;&gt; 		}<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; A union should really just be though of as a lightweight, restricted form of enum that can be declared in a quick ad-hoc fashion, similar to how tuples are a simpler form of struct.<br>&gt;&gt; <br>&gt;&gt; I’m generally a +1 for the feature, but I’d be interested to hear about how well equipped the compiler is for optimising something like this. In most cases an Optional covers what I need, and in more complex cases I’d probably declare overloads for each type (i.e- someMethod(value:A), someMethod(value:B) etc.); unions could make the latter case simpler, but will the compiler produce the same code behind the scenes, i.e- by isolating what’s unique to each type?<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[proposal] Union Type</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>May 17, 2016 at 08:00:00pm</p></header><div class="content"><p>That&#39;s exactly my point, Sean.<br></p><p>- Leonardo<br></p><p>On 17 May 2016 at 20:31, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br></p><p>&gt; Cavet: I have not been following this, so probably someone has said this<br>&gt; somewhere and flaws were pointed out.<br>&gt;<br>&gt; I don’t really understand the need for union types when you can have<br>&gt; multiple methods of the same name that differ only by the type of their<br>&gt; parameter:<br>&gt;<br>&gt; func something(value: A) {}<br>&gt; func something(value: B) {}<br>&gt; func something(value: C) {}<br>&gt;<br>&gt; Doesn’t this more or less accomplish the same thing without needing a<br>&gt; switch/if tree or whatever else inside the method to break the types back<br>&gt; apart again in the method body and without even needing any new mechanism<br>&gt; in the language at all?<br>&gt;<br>&gt; Again, sorry for the (very likely) redundant noise on my part.<br>&gt;<br>&gt; l8r<br>&gt; Sean<br>&gt;<br>&gt;<br>&gt;<br>&gt; &gt; On May 17, 2016, at 6:09 PM, Leonardo Pessoa via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Jiannan, I agree there is an use for union types, I&#39;m just not really<br>&gt; fond of the syntax (I&#39;d really prefer something like &#39;union&lt;...&gt;&#39;) and with<br>&gt; using it for optionals. To enable this syntax for optionals, None would<br>&gt; have to be a valid type of the language and that would enable one to create<br>&gt; the following constructions:<br>&gt; &gt;<br>&gt; &gt;     func something(value: None) -&gt; None { ... }<br>&gt; &gt;<br>&gt; &gt; It wouldn&#39;t be essentially wrong but unnecessary since nil would be the<br>&gt; only possible value of the type None. And I don&#39;t really see any need to<br>&gt; change the way optionals are implemented to support unions. And we could<br>&gt; still have optional unions using either syntax with existing optional<br>&gt; syntax (which is very clear to me):<br>&gt; &gt;<br>&gt; &gt;     func something(value: (A | B | C)?) { ... }<br>&gt; &gt;<br>&gt; &gt; or<br>&gt; &gt;<br>&gt; &gt;     func something(value: union&lt;A, B, C&gt;?) { ... }<br>&gt; &gt;<br>&gt; &gt; Just as I said before, I don&#39;t really think unions are necessary (did<br>&gt; you mean overloading?) but I don&#39;t oppose them. I just don&#39;t think we need<br>&gt; to change the way a feature already works to justify the addition of a new<br>&gt; feature.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; - Leonardo<br>&gt; &gt;<br>&gt; &gt; On 16 May 2016 at 08:26, Cao Jiannan via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; Union is far better then generic enum/protocol solution.<br>&gt; &gt;         * It can extend the original enum and make it powerful.<br>&gt; &gt;<br>&gt; &gt; enum ResultDataType {<br>&gt; &gt;     case Music<br>&gt; &gt;     case Video<br>&gt; &gt;     case File<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; enum FailureType {<br>&gt; &gt;     case HTTP404<br>&gt; &gt;     case HTTP502<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; enum FailureTypev2 {<br>&gt; &gt;     case HTTP451<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; typealias Result = (ResultDataType | FailureType | FailureTypev2)<br>&gt; &gt;<br>&gt; &gt;       * It keeps the code clear and does not need developer to announce<br>&gt; some unnecessary protocols or enums.<br>&gt; &gt;               like UnionOf3&lt;T,U,V&gt; or ProtocolForABC<br>&gt; &gt;<br>&gt; &gt;         * It is easy to wrap original value into an union type.<br>&gt; &gt;               let a = A()<br>&gt; &gt;       let union: (A|B|C) = a // Automatically wrap.<br>&gt; &gt;<br>&gt; &gt;       * Compiler might search their common properties, and methods, then<br>&gt; mark them as a member of the union type.<br>&gt; &gt;               print(value.someCommonProperty) // Compiler will know<br>&gt; their common properties automatically.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;       * Compiler know the union type exactly composed with which types,<br>&gt; better than only know which protocol.<br>&gt; &gt;               func input(value: ProtocolForABC) {<br>&gt; &gt;               if value is A {<br>&gt; &gt;<br>&gt; &gt;               } else if value is B {<br>&gt; &gt;<br>&gt; &gt;               } else if value is C {<br>&gt; &gt;<br>&gt; &gt;               } else {<br>&gt; &gt;                       // There are other cases? Compiler doesn&#39;t know<br>&gt; &gt;               }<br>&gt; &gt;       }<br>&gt; &gt;<br>&gt; &gt;         * Original types and union types can have a rational<br>&gt; relationship between each other.<br>&gt; &gt;                Original type is a sub-type of union types contain it.<br>&gt; &gt;<br>&gt; &gt;       var fn0: A-&gt;Void = {print(v0)}<br>&gt; &gt;       var fn1: (A|B)-&gt;Void = {print(v0)}<br>&gt; &gt;<br>&gt; &gt;       fn0 = fn1 // Original Type and Union Type has a sub-typing<br>&gt; relationship, OK<br>&gt; &gt;<br>&gt; &gt;       var fn2: (A|B|C)-&gt;Void = {print($0)}<br>&gt; &gt;<br>&gt; &gt;       fn0 = fn2 // OK<br>&gt; &gt;       fn1 = fn2 // OK<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;         * It is also easy to compare with value of original type.<br>&gt; &gt;               union == a // Can be compared, Yes for most cases.<br>&gt; &gt;<br>&gt; &gt;       * And the most important part, It can replace Optional&lt;T&gt;.<br>&gt; &gt;               let string: String?<br>&gt; &gt;       is same to<br>&gt; &gt;               let string: (String | None)  instead of let string:<br>&gt; Optional&lt;String&gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; I really think the union type is a good supplement for Swift. Make the<br>&gt; language rational.<br>&gt; &gt; And the It is also really good for Reactive Programming.<br>&gt; &gt;<br>&gt; &gt; - Jiannan<br>&gt; &gt;<br>&gt; &gt;&gt; 下面是被转发的邮件：<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; 发件人: Haravikk &lt;swift-evolution at haravikk.me&gt;<br>&gt; &gt;&gt; 主题: 回复： [swift-evolution] Union instead of Optional<br>&gt; &gt;&gt; 日期: 2016年5月16日 GMT+8 18:35:25<br>&gt; &gt;&gt; 收件人: Austin Zheng &lt;austinzheng at gmail.com&gt;<br>&gt; &gt;&gt; 抄送: Cao Jiannan &lt;frogcjn at 163.com&gt;, Adrian Zubarev via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On 16 May 2016, at 11:17, Austin Zheng via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; If A, B, and C are not related via protocol or class inheritance, then<br>&gt; there is almost nothing you can do with value. Otherwise you still need to<br>&gt; test against the concrete type using a case statement or a if-else ladder.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I think that a case statement or similar syntax will still be needed,<br>&gt; and the case names would just be the types themselves. This would work best<br>&gt; with support for type-narrowing, for example:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;      func someMethod(value:(A|B|C)) {<br>&gt; &gt;&gt;              switch (value) {<br>&gt; &gt;&gt;                      case .A:<br>&gt; &gt;&gt;                              value.someMethodForTypeA()<br>&gt; &gt;&gt;                      case .B:<br>&gt; &gt;&gt;                              value.someMethodForTypeB()<br>&gt; &gt;&gt;                      case .C:<br>&gt; &gt;&gt;                              value.someMethodForTypeC()<br>&gt; &gt;&gt;              }<br>&gt; &gt;&gt;      }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; A union should really just be though of as a lightweight, restricted<br>&gt; form of enum that can be declared in a quick ad-hoc fashion, similar to how<br>&gt; tuples are a simpler form of struct.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I’m generally a +1 for the feature, but I’d be interested to hear about<br>&gt; how well equipped the compiler is for optimising something like this. In<br>&gt; most cases an Optional covers what I need, and in more complex cases I’d<br>&gt; probably declare overloads for each type (i.e- someMethod(value:A),<br>&gt; someMethod(value:B) etc.); unions could make the latter case simpler, but<br>&gt; will the compiler produce the same code behind the scenes, i.e- by<br>&gt; isolating what’s unique to each type?<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160517/ec54301c/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
