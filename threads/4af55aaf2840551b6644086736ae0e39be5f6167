<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: CollectionType.cycle property for an infinite sequence</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 27, 2015 at 11:00:00pm</p></header><div class="content"><p>## Introduction<br></p><p>Add a new property `cycle` to CollectionType that returns an infinite SequenceType that yields the elements of the collection in a loop.<br></p><p>## Motivation<br></p><p>It&#39;s sometimes useful to be able to have an infinite sequence. For example, `CollectionOfOne(x).cycle` could be used to have an infinite sequence of a single element (similar to Repeat but without a count). A common use for infinite sequences is zipping with a finite sequence. As far as I&#39;m aware, the stdlib does not currently provide any way to create such an infinite sequence.<br></p><p>## Proposed solution<br></p><p>Extend CollectionType with a new property `cycle` that yields a type that conforms to SequenceType. This sequence yields each element of the collection in an infinite loop.<br></p><p>## Detailed design<br></p><p>2 new types would be added:<br></p><p>struct CycleSequence&lt;Base : CollectionType&gt; : LazySequenceType { ... }<br>struct CycleGenerator&lt;Base : CollectionType&gt; : GeneratorType { ... }<br></p><p>CollectionType would be extended with a property:<br></p><p>extension CollectionType {<br>    public var cycle: CycleSequence&lt;Self&gt; { get }<br>}<br></p><p>This is an extension of CollectionType instead of SequenceType because it requires a multi-pass sequence (and SequenceType does not provide that guarantee). The returned type conforms to SequenceType instead of CollectionType because there is no possible `endIndex` that satisfies the requirement of being reachable from `startIndex` by zero or more applications of `successor()`.<br></p><p>Because the default eager versions of map and filter will execute forever on an infinite sequence, CycleSequence conforms to LazySequenceType instead of SequenceType in order to provide lazy versions of those functions. Additionally, it will provide implementations of the eager versions that simply trigger a fatalError(), as the alternative is an infinite loop that consumes more and more memory.<br></p><p>## Impact on existing code<br></p><p>None<br></p><p>-Kevin Ballard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>Proposal: CollectionType.cycle property for an infinite sequence</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>December 28, 2015 at 02:00:00am</p></header><div class="content"><p>+1.  Stream support is long overdue.<br></p><p>~Robert Widmann<br></p><p>2015/12/28 2:20、Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br></p><p>&gt; ## Introduction<br>&gt; <br>&gt; Add a new property `cycle` to CollectionType that returns an infinite SequenceType that yields the elements of the collection in a loop.<br>&gt; <br>&gt; ## Motivation<br>&gt; <br>&gt; It&#39;s sometimes useful to be able to have an infinite sequence. For example, `CollectionOfOne(x).cycle` could be used to have an infinite sequence of a single element (similar to Repeat but without a count). A common use for infinite sequences is zipping with a finite sequence. As far as I&#39;m aware, the stdlib does not currently provide any way to create such an infinite sequence.<br>&gt; <br>&gt; ## Proposed solution<br>&gt; <br>&gt; Extend CollectionType with a new property `cycle` that yields a type that conforms to SequenceType. This sequence yields each element of the collection in an infinite loop.<br>&gt; <br>&gt; ## Detailed design<br>&gt; <br>&gt; 2 new types would be added:<br>&gt; <br>&gt; struct CycleSequence&lt;Base : CollectionType&gt; : LazySequenceType { ... }<br>&gt; struct CycleGenerator&lt;Base : CollectionType&gt; : GeneratorType { ... }<br>&gt; <br>&gt; CollectionType would be extended with a property:<br>&gt; <br>&gt; extension CollectionType {<br>&gt;    public var cycle: CycleSequence&lt;Self&gt; { get }<br>&gt; }<br>&gt; <br>&gt; This is an extension of CollectionType instead of SequenceType because it requires a multi-pass sequence (and SequenceType does not provide that guarantee). The returned type conforms to SequenceType instead of CollectionType because there is no possible `endIndex` that satisfies the requirement of being reachable from `startIndex` by zero or more applications of `successor()`.<br>&gt; <br>&gt; Because the default eager versions of map and filter will execute forever on an infinite sequence, CycleSequence conforms to LazySequenceType instead of SequenceType in order to provide lazy versions of those functions. Additionally, it will provide implementations of the eager versions that simply trigger a fatalError(), as the alternative is an infinite loop that consumes more and more memory.<br>&gt; <br>&gt; ## Impact on existing code<br>&gt; <br>&gt; None<br>&gt; <br>&gt; -Kevin Ballard<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>Proposal: CollectionType.cycle property for an infinite sequence</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>December 29, 2015 at 09:00:00pm</p></header><div class="content"><p>+1 looks good, I had a go at implementing it and I think it may require<br>changes not discussed in the proposal.<br></p><p>You&#39;ve covered the potential issues fairly well, to be a little more<br>explicit these are the issues I&#39;ve found:<br></p><p> 1) LazySequenceType&#39;s property array cannot be defined without an infinite<br>sized array.<br> 2) what should [1,2,3].cycle.suffix(4) return? [3,1,2,3] probably has the<br>least surprises, but it&#39;s like asking what&#39;s the number before infinity.<br></p><p> 3) dropLast should return AnySequence(self), but requires specialisation,<br>this may have to also be a fatalError (see below).<br></p><p><br>One issue I don&#39;t think you&#39;ve mentioned, and I don&#39;t seem to be able to<br>resolve is this:<br></p><p>let mySequence = [1,2,3].cycle.dropLast(1)<br></p><p>mySequence.suffix(7)<br></p><p><br>This could have well defined behaviour (see part 2 above), however the<br>implementation has some issues.<br></p><p>In this case mySequence is an AnySequence&lt;Int&gt;, mySequence.suffix(7) uses<br>AnySequence&#39;s specialisation and so tries to iterate over the entire<br>sequence to find the suffix. AnySequence&lt;Int&gt; is type-erased so there&#39;s no<br>way to specialise when the underlying sequence is infinite (to get a valid<br>implementation of suffix).<br></p><p>Potential solutions:<br> * Replace erased Any* types with a more flexible alternative that doesn&#39;t<br>remove type information (higher kinded types perhaps).<br> * Replace SequenceType with two protocols FiniteSequenceType and<br>InfiniteSequenceType, have type erased versions of each, duplicate all the<br>things.<br> * Add a property to SequenceType to indicate if it&#39;s definitely finite<br>(undefined?), AnySequence uses a different backing implementation depending<br>on this boolean.<br></p><p>Here&#39;s the implementation I used in a playground to toy with this:<br></p><p>public struct CycleSequence&lt;Base : CollectionType&gt; : LazySequenceType {<br></p><p>    private let base: Base<br></p><p>    private init(_ collection: Base) {<br></p><p>        self.base = collection<br></p><p>    }<br></p><p>    @warn_unused_result<br></p><p>    public func generate() -&gt; CycleGenerator&lt;Base&gt; {<br></p><p>        return CycleGenerator&lt;Base&gt;(base.generate)<br></p><p>    }<br></p><p>    public var array: [Base.Generator.Element] {<br></p><p>        fatalError(&quot;This is undefined!&quot;)<br></p><p>    }<br></p><p>}<br></p><p><br>public struct CycleGenerator&lt;Base : CollectionType&gt; : GeneratorType {<br></p><p>    private let generatorProducer: () -&gt; Base.Generator<br></p><p>    private var generator: Base.Generator<br></p><p>    private init(_ generatorProducer: () -&gt; Base.Generator) {<br></p><p>        self.generatorProducer = generatorProducer<br></p><p>        self.generator = generatorProducer()<br></p><p>    }<br></p><p>    @warn_unused_result<br></p><p>    public mutating func next() -&gt; Base.Generator.Element? {<br></p><p>        if let element = generator.next() {<br></p><p>            return element<br></p><p>        }<br></p><p>        generator = generatorProducer()<br></p><p>        return generator.next()<br></p><p>    }<br></p><p>}<br></p><p><br>extension CycleSequence {<br></p><p>    @warn_unused_result<br></p><p>    public func dropLast(n: Int) -&gt; AnySequence&lt;Base.Generator.Element&gt; {<br></p><p>        return AnySequence(self)<br></p><p>    }<br></p><p>    @warn_unused_result<br></p><p>    public func suffix(maxLength: Int) -&gt; AnySequence&lt;Base.Generator.Element&gt;<br>{<br></p><p>        let maxCount = base.count.toIntMax()<br></p><p>        let sequenceLength = maxCount &gt;= Int.max.toIntMax() ? Int.max : Int<br>(maxCount)<br></p><p>        if maxLength &lt; sequenceLength {<br></p><p>            return AnySequence(base.suffix(maxLength))<br></p><p>        }<br></p><p>        return self.dropFirst(sequenceLength - (maxLength %<br>sequenceLength)).prefix(maxLength)<br></p><p>    }<br></p><p>}<br></p><p><br>extension CollectionType {<br></p><p>    public var cycle: CycleSequence&lt;Self&gt; { return CycleSequence(self) }<br></p><p>}<br></p><p><br></p><p>// this produces an infinite loop when evaluating .suffix(7)<br></p><p>let cycle = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].cycle<br></p><p>cycle.dropLast(1).suffix(7).forEach { print(&quot;suffix: \($0)&quot;) }<br></p><p><br></p><p>On Mon, Dec 28, 2015 at 6:35 PM, Developer via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; +1.  Stream support is long overdue.<br>&gt;<br>&gt; ~Robert Widmann<br>&gt;<br>&gt; 2015/12/28 2:20、Kevin Ballard via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; のメッセージ:<br>&gt;<br>&gt; &gt; ## Introduction<br>&gt; &gt;<br>&gt; &gt; Add a new property `cycle` to CollectionType that returns an infinite<br>&gt; SequenceType that yields the elements of the collection in a loop.<br>&gt; &gt;<br>&gt; &gt; ## Motivation<br>&gt; &gt;<br>&gt; &gt; It&#39;s sometimes useful to be able to have an infinite sequence. For<br>&gt; example, `CollectionOfOne(x).cycle` could be used to have an infinite<br>&gt; sequence of a single element (similar to Repeat but without a count). A<br>&gt; common use for infinite sequences is zipping with a finite sequence. As far<br>&gt; as I&#39;m aware, the stdlib does not currently provide any way to create such<br>&gt; an infinite sequence.<br>&gt; &gt;<br>&gt; &gt; ## Proposed solution<br>&gt; &gt;<br>&gt; &gt; Extend CollectionType with a new property `cycle` that yields a type<br>&gt; that conforms to SequenceType. This sequence yields each element of the<br>&gt; collection in an infinite loop.<br>&gt; &gt;<br>&gt; &gt; ## Detailed design<br>&gt; &gt;<br>&gt; &gt; 2 new types would be added:<br>&gt; &gt;<br>&gt; &gt; struct CycleSequence&lt;Base : CollectionType&gt; : LazySequenceType { ... }<br>&gt; &gt; struct CycleGenerator&lt;Base : CollectionType&gt; : GeneratorType { ... }<br>&gt; &gt;<br>&gt; &gt; CollectionType would be extended with a property:<br>&gt; &gt;<br>&gt; &gt; extension CollectionType {<br>&gt; &gt;    public var cycle: CycleSequence&lt;Self&gt; { get }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; This is an extension of CollectionType instead of SequenceType because<br>&gt; it requires a multi-pass sequence (and SequenceType does not provide that<br>&gt; guarantee). The returned type conforms to SequenceType instead of<br>&gt; CollectionType because there is no possible `endIndex` that satisfies the<br>&gt; requirement of being reachable from `startIndex` by zero or more<br>&gt; applications of `successor()`.<br>&gt; &gt;<br>&gt; &gt; Because the default eager versions of map and filter will execute<br>&gt; forever on an infinite sequence, CycleSequence conforms to LazySequenceType<br>&gt; instead of SequenceType in order to provide lazy versions of those<br>&gt; functions. Additionally, it will provide implementations of the eager<br>&gt; versions that simply trigger a fatalError(), as the alternative is an<br>&gt; infinite loop that consumes more and more memory.<br>&gt; &gt;<br>&gt; &gt; ## Impact on existing code<br>&gt; &gt;<br>&gt; &gt; None<br>&gt; &gt;<br>&gt; &gt; -Kevin Ballard<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151229/6ac7c741/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: CollectionType.cycle property for an infinite sequence</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 29, 2015 at 10:00:00am</p></header><div class="content"><p>On Tue, Dec 29, 2015, at 02:27 AM, Andrew Bennett wrote:<br>&gt; +1 looks good, I had a go at implementing it and I think it may<br>&gt; require changes not discussed in the proposal.<br>&gt;<br>&gt; You&#39;ve covered the potential issues fairly well, to be a little more<br>&gt; explicit these are the issues I&#39;ve found:<br>&gt;&gt; 1) LazySequenceType&#39;s property array cannot be defined without an<br>&gt;&gt; infinite sized array.<br></p><p>Good point, I forgot about that one. But that&#39;s really just the same<br>thing as saying `Array(seq)`, so I don&#39;t have any problems with just<br>saying that it&#39;s an error to access that property on an infinite<br>sequence (in this case I&#39;d just make it fatalError()).<br></p><p>I do wish I could mark those sorts of things with @available(*,<br>unavailable, message=&quot;this cannot be used on an infinite sequence&quot;) to<br>provide a compile-time error for anyone accessing it on the concrete<br>type (generic access via the protocol wouldn&#39;t catch that of course),<br>but I discovered that if you try and use that on a function like map(),<br>Swift actually goes ahead and adds the default implementation to your<br>type anyway (basically throwing away your marked-as-unavailable method).<br>Which I suppose makes some sense, but I wish there was an alternative<br>that worked.<br></p><p>&gt;&gt; 2) what should [1,2,3].cycle.suffix(4) return? [3,1,2,3] probably has<br>&gt;&gt; the least surprises, but it&#39;s like asking what&#39;s the number before<br>&gt;&gt; infinity.<br></p><p>Nothing. You can&#39;t take a suffix on an infinite list. There is no end to<br>it. That method should be overridden to fatalError() (or if not, it<br>would just loop forever).<br></p><p>&gt;&gt; 3) dropLast should return AnySequence(self), but requires<br>&gt;&gt; specialisation, this may have to also be a fatalError (see below).<br></p><p>Good point. Since there is no end to the sequence, dropLast() on an<br>infinite sequence is still an infinite sequence. Honestly, the default<br>implementation should work fine, but it&#39;s probably a good idea to just<br>override it to return AnySequence(self) as you suggest anyway because<br>it&#39;s an easy win.<br></p><p>&gt; One issue I don&#39;t think you&#39;ve mentioned, and I don&#39;t seem to be able<br>&gt; to resolve is this:<br>&gt;&gt; let mySequence = [1,2,3].cycle.dropLast(1) mySequence.suffix(7)<br>&gt;<br>&gt; This could have well defined behaviour (see part 2 above), however the<br>&gt; implementation has some issues.<br></p><p>The only well-defined behavior this can have is to loop forever (or to<br>abort with a fatalError). It&#39;s simply an error to take a suffix() of an<br>infinite sequence.<br></p><p>&gt; In this case mySequence is an AnySequence&lt;Int&gt;, mySequence.suffix(7)<br>&gt; uses AnySequence&#39;s specialisation and so tries to iterate over the<br>&gt; entire sequence to find the suffix. AnySequence&lt;Int&gt; is type-erased so<br>&gt; there&#39;s no way to specialise when the underlying sequence is infinite<br>&gt; (to get a valid implementation of suffix).<br></p><p>That&#39;s fine, looping forever is a perfectly reasonable course of action<br>when you try and take a suffix() of an infinite sequence.<br></p><p>&gt; Potential solutions: * Replace erased Any* types with a more flexible<br>&gt; alternative that doesn&#39;t remove type information (higher kinded types<br>&gt; perhaps).<br></p><p>The whole point of the Any* types is they do remove type information.<br></p><p>&gt; * Replace SequenceType with two protocols FiniteSequenceType and<br>&gt; InfiniteSequenceType, have type erased versions of each, duplicate all<br>&gt; the things.<br></p><p>What&#39;s the point of this? All you can do with that is get rid of a<br>couple of methods that would loop forever on infinite sequences, but<br>it&#39;s a lot of work and a lot of duplication for what seems like an<br>extremely small win.<br></p><p>I&#39;d much rather just come up with some alternative to @available(*,<br>unavailable) that actually leaves the method intact but provides a compile-<br>time error if you call it. This would be strictly intended for protocol<br>methods, as you&#39;d still need to provide an implementation (such as<br>`fatalError(&quot;not supported&quot;)`) that would be called when the method is<br>accessed via a generic type bound on the protocol (or via an existential<br>protocol value, for protocols that support that).<br></p><p>&gt; * Add a property to SequenceType to indicate if it&#39;s definitely finite<br>&gt; (undefined?), AnySequence uses a different backing implementation<br>&gt; depending on this boolean.<br></p><p>And what would AnySequence do with that information? All it could really<br>do is make sure to call fatalError() instead of looping forever when a<br>method like suffix() is called.<br></p><p>-Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151229/94be5bd9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>Proposal: CollectionType.cycle property for an infinite sequence</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>December 30, 2015 at 05:00:00pm</p></header><div class="content"><p>Hi Kevin,<br></p><p>The issue I was seeing was because AnySequence uses the protocol extension<br>on SequenceType for its implementations of filter/suffix/prefix etc. So I<br>don&#39;t think it&#39;s taking into account any implementations of those on the<br>base sequence&#39;s type.<br></p><p>The problem basically comes down to this:<br></p><p>AnySequence([1,2,3].cycle).suffix(1) uses SequenceType&#39;s implementation of<br>suffix.<br>[1,2,3].cycle.suffix(1) uses CycleSequence&#39;s implementation of suffix.<br></p><p>If you provide any custom implementations for CycleSequence AnySequence<br>will not preserve that intent. This is probably a bug.<br></p><p>Another side-effect of AnySequence is that @available(*, unavailable,<br>message=&quot;this cannot be used on an infinite sequence&quot;) on CycleSequence will<br>not work if you wrap it with AnySequence. It would still be nice to do<br>this, it&#39;s just not robust.<br></p><p>I&#39;ve added a bug report (SR-413 &lt;https://bugs.swift.org/browse/SR-413&gt;) to<br>add missing SequenceType methods to AnySequence so that they use the<br>correct version. I think this should address my concerns.<br></p><p>If that bug is fixed then the only remaining problem I have is to decide is<br>if suffix/array should enter an infinite loop or fatalError. Personally I&#39;m<br>leaning towards fatalError as it&#39;s more likely to let a developer know<br>what&#39;s wrong.<br></p><p><br>On Wed, Dec 30, 2015 at 5:44 AM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br></p><p>&gt; On Tue, Dec 29, 2015, at 02:27 AM, Andrew Bennett wrote:<br>&gt;<br>&gt; +1 looks good, I had a go at implementing it and I think it may require<br>&gt; changes not discussed in the proposal.<br>&gt;<br>&gt; You&#39;ve covered the potential issues fairly well, to be a little more<br>&gt; explicit these are the issues I&#39;ve found:<br>&gt;<br>&gt;  1) LazySequenceType&#39;s property array cannot be defined without an<br>&gt; infinite sized array.<br>&gt;<br>&gt;<br>&gt; Good point, I forgot about that one. But that&#39;s really just the same thing<br>&gt; as saying `Array(seq)`, so I don&#39;t have any problems with just saying that<br>&gt; it&#39;s an error to access that property on an infinite sequence (in this case<br>&gt; I&#39;d just make it fatalError()).<br>&gt;<br>&gt; I do wish I could mark those sorts of things with @available(*,<br>&gt; unavailable, message=&quot;this cannot be used on an infinite sequence&quot;) to<br>&gt; provide a compile-time error for anyone accessing it on the concrete type<br>&gt; (generic access via the protocol wouldn&#39;t catch that of course), but I<br>&gt; discovered that if you try and use that on a function like map(), Swift<br>&gt; actually goes ahead and adds the default implementation to your type anyway<br>&gt; (basically throwing away your marked-as-unavailable method). Which I<br>&gt; suppose makes some sense, but I wish there was an alternative that worked.<br>&gt;<br>&gt;<br>&gt;  2) what should [1,2,3].cycle.suffix(4) return? [3,1,2,3] probably has the<br>&gt; least surprises, but it&#39;s like asking what&#39;s the number before infinity.<br>&gt;<br>&gt;<br>&gt; Nothing. You can&#39;t take a suffix on an infinite list. There is no end to<br>&gt; it. That method should be overridden to fatalError() (or if not, it would<br>&gt; just loop forever).<br>&gt;<br>&gt;<br>&gt;  3) dropLast should return AnySequence(self), but requires specialisation,<br>&gt; this may have to also be a fatalError (see below).<br>&gt;<br>&gt;<br>&gt; Good point. Since there is no end to the sequence, dropLast() on an<br>&gt; infinite sequence is still an infinite sequence. Honestly, the default<br>&gt; implementation should work fine, but it&#39;s probably a good idea to just<br>&gt; override it to return AnySequence(self) as you suggest anyway because it&#39;s<br>&gt; an easy win.<br>&gt;<br>&gt;<br>&gt; One issue I don&#39;t think you&#39;ve mentioned, and I don&#39;t seem to be able to<br>&gt; resolve is this:<br>&gt;<br>&gt; let mySequence = [1,2,3].cycle.dropLast(1)<br>&gt;<br>&gt; mySequence.suffix(7)<br>&gt;<br>&gt;<br>&gt; This could have well defined behaviour (see part 2 above), however the<br>&gt; implementation has some issues.<br>&gt;<br>&gt;<br>&gt; The only well-defined behavior this can have is to loop forever (or to<br>&gt; abort with a fatalError). It&#39;s simply an error to take a suffix() of an<br>&gt; infinite sequence.<br>&gt;<br>&gt;<br>&gt; In this case mySequence is an AnySequence&lt;Int&gt;, mySequence.suffix(7) uses<br>&gt; AnySequence&#39;s specialisation and so tries to iterate over the entire<br>&gt; sequence to find the suffix. AnySequence&lt;Int&gt; is type-erased so there&#39;s no<br>&gt; way to specialise when the underlying sequence is infinite (to get a valid<br>&gt; implementation of suffix).<br>&gt;<br>&gt;<br>&gt; That&#39;s fine, looping forever is a perfectly reasonable course of action<br>&gt; when you try and take a suffix() of an infinite sequence.<br>&gt;<br>&gt;<br>&gt; Potential solutions:<br>&gt;  * Replace erased Any* types with a more flexible alternative that doesn&#39;t<br>&gt; remove type information (higher kinded types perhaps).<br>&gt;<br>&gt;<br>&gt; The whole point of the Any* types is they do remove type information.<br>&gt;<br>&gt;<br>&gt;  * Replace SequenceType with two protocols FiniteSequenceType and<br>&gt; InfiniteSequenceType, have type erased versions of each, duplicate all the<br>&gt; things.<br>&gt;<br>&gt;<br>&gt; What&#39;s the point of this? All you can do with that is get rid of a couple<br>&gt; of methods that would loop forever on infinite sequences, but it&#39;s a lot of<br>&gt; work and a lot of duplication for what seems like an extremely small win.<br>&gt;<br>&gt; I&#39;d much rather just come up with some alternative to @available(*,<br>&gt; unavailable) that actually leaves the method intact but provides a<br>&gt; compile-time error if you call it. This would be strictly intended for<br>&gt; protocol methods, as you&#39;d still need to provide an implementation (such as<br>&gt; `fatalError(&quot;not supported&quot;)`) that would be called when the method is<br>&gt; accessed via a generic type bound on the protocol (or via an existential<br>&gt; protocol value, for protocols that support that).<br>&gt;<br>&gt;<br>&gt;  * Add a property to SequenceType to indicate if it&#39;s definitely finite<br>&gt; (undefined?), AnySequence uses a different backing implementation depending<br>&gt; on this boolean.<br>&gt;<br>&gt;<br>&gt; And what would AnySequence do with that information? All it could really<br>&gt; do is make sure to call fatalError() instead of looping forever when a<br>&gt; method like suffix() is called.<br>&gt;<br>&gt; -Kevin Ballard<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/7ee7db11/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: CollectionType.cycle property for an infinite sequence</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 29, 2015 at 11:00:00pm</p></header><div class="content"><p>On Tue, Dec 29, 2015, at 10:12 PM, Andrew Bennett wrote:<br>&gt; Hi Kevin,<br>&gt;<br>&gt; The issue I was seeing was because AnySequence uses the protocol<br>&gt; extension on SequenceType for its implementations of<br>&gt; filter/suffix/prefix etc. So I don&#39;t think it&#39;s taking into account<br>&gt; any implementations of those on the base sequence&#39;s type.<br>&gt;<br>&gt; The problem basically comes down to this:<br>&gt;&gt; AnySequence([1,2,3].cycle).suffix(1) uses SequenceType&#39;s<br>&gt;&gt; implementation of suffix. [1,2,3].cycle.suffix(1) uses<br>&gt;&gt; CycleSequence&#39;s implementation of suffix.<br>&gt; If you provide any custom implementations for CycleSequence<br>&gt; AnySequence will not preserve that intent. This is probably a bug.<br></p><p>The only way to actually fix this is to have AnySequence contain a<br>closure for each method defined in SequenceType that calls the<br>underlying implementation (and wraps the result in AnySequence as<br>necessary). This is rather heavy-weight, which is probably why it<br>doesn&#39;t do that.<br></p><p>Really, I don&#39;t think it&#39;s particularly surprising that wrapping a<br>sequence in AnySequence causes the sequence&#39;s own implementations of the<br>optional methods to not be called. It would be great if there was a<br>simple way to fix this, but it&#39;s not worth the cost of reifying all the<br>runtime type information necessary.<br></p><p>&gt; Another side-effect of AnySequence is that @available(*, unavailable,<br>&gt; message=&quot;this cannot be used on an infinite sequence&quot;) onCycleSequence<br>&gt; will not work if you wrap it with AnySequence. It would still be nice<br>&gt; to do this, it&#39;s just not robust.<br></p><p>Since that&#39;s a compile-time check, it is quite impossible to ever<br>support that on a sequence that&#39;s wrapped in AnySequence.<br></p><p>-Kevin Ballard<br></p><p>&gt; I&#39;ve added a bug report (SR-413[1]) to add missing SequenceType<br>&gt; methods to AnySequence so that they use the correct version. I think<br>&gt; this should address my concerns.<br>&gt;<br>&gt; If that bug is fixed then the only remaining problem I have is to<br>&gt; decide is if suffix/array should enter an infinite loop or fatalError.<br>&gt; Personally I&#39;m leaning towards fatalError as it&#39;s more likely to let a<br>&gt; developer know what&#39;s wrong.<br>&gt;<br>&gt;<br>&gt; On Wed, Dec 30, 2015 at 5:44 AM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt;&gt; __<br>&gt;&gt;<br>&gt;&gt; On Tue, Dec 29, 2015, at 02:27 AM, Andrew Bennett wrote:<br>&gt;&gt;&gt; +1 looks good, I had a go at implementing it and I think it may<br>&gt;&gt;&gt; require changes not discussed in the proposal.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; You&#39;ve covered the potential issues fairly well, to be a little more<br>&gt;&gt;&gt; explicit these are the issues I&#39;ve found:<br>&gt;&gt;&gt;&gt; 1) LazySequenceType&#39;s property array cannot be defined without an<br>&gt;&gt;&gt;&gt; infinite sized array.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Good point, I forgot about that one. But that&#39;s really just the same<br>&gt;&gt; thing as saying `Array(seq)`, so I don&#39;t have any problems with just<br>&gt;&gt; saying that it&#39;s an error to access that property on an infinite<br>&gt;&gt; sequence (in this case I&#39;d just make it fatalError()).<br>&gt;&gt;<br>&gt;&gt; I do wish I could mark those sorts of things with @available(*,<br>&gt;&gt; unavailable, message=&quot;this cannot be used on an infinite sequence&quot;)<br>&gt;&gt; to provide a compile-time error for anyone accessing it on the<br>&gt;&gt; concrete type (generic access via the protocol wouldn&#39;t catch that of<br>&gt;&gt; course), but I discovered that if you try and use that on a function<br>&gt;&gt; like map(), Swift actually goes ahead and adds the default<br>&gt;&gt; implementation to your type anyway (basically throwing away your marked-as-<br>&gt;&gt; unavailable method). Which I suppose makes some sense, but I wish<br>&gt;&gt; there was an alternative that worked.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;&gt; 2) what should [1,2,3].cycle.suffix(4) return? [3,1,2,3] probably<br>&gt;&gt;&gt;&gt; has the least surprises, but it&#39;s like asking what&#39;s the number<br>&gt;&gt;&gt;&gt; before infinity.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Nothing. You can&#39;t take a suffix on an infinite list. There is no end<br>&gt;&gt; to it. That method should be overridden to fatalError() (or if not,<br>&gt;&gt; it would just loop forever).<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;&gt; 3) dropLast should return AnySequence(self), but requires<br>&gt;&gt;&gt;&gt; specialisation, this may have to also be a fatalError (see below).<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Good point. Since there is no end to the sequence, dropLast() on an<br>&gt;&gt; infinite sequence is still an infinite sequence. Honestly, the<br>&gt;&gt; default implementation should work fine, but it&#39;s probably a good<br>&gt;&gt; idea to just override it to return AnySequence(self) as you suggest<br>&gt;&gt; anyway because it&#39;s an easy win.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; One issue I don&#39;t think you&#39;ve mentioned, and I don&#39;t seem to be<br>&gt;&gt;&gt; able to resolve is this:<br>&gt;&gt;&gt;&gt; let mySequence = [1,2,3].cycle.dropLast(1) mySequence.suffix(7)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This could have well defined behaviour (see part 2 above), however<br>&gt;&gt;&gt; the implementation has some issues.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; The only well-defined behavior this can have is to loop forever (or<br>&gt;&gt; to abort with a fatalError). It&#39;s simply an error to take a suffix()<br>&gt;&gt; of an infinite sequence.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; In this case mySequence is an AnySequence&lt;Int&gt;, mySequence.suffix(7)<br>&gt;&gt;&gt; uses AnySequence&#39;s specialisation and so tries to iterate over the<br>&gt;&gt;&gt; entire sequence to find the suffix. AnySequence&lt;Int&gt; is type-erased<br>&gt;&gt;&gt; so there&#39;s no way to specialise when the underlying sequence is<br>&gt;&gt;&gt; infinite (to get a valid implementation of suffix).<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; That&#39;s fine, looping forever is a perfectly reasonable course of<br>&gt;&gt; action when you try and take a suffix() of an infinite sequence.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; Potential solutions: * Replace erased Any* types with a more<br>&gt;&gt;&gt; flexible alternative that doesn&#39;t remove type information (higher<br>&gt;&gt;&gt; kinded types perhaps).<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; The whole point of the Any* types is they do remove type information.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; * Replace SequenceType with two protocols FiniteSequenceType and<br>&gt;&gt;&gt; InfiniteSequenceType, have type erased versions of each, duplicate<br>&gt;&gt;&gt; all the things.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; What&#39;s the point of this? All you can do with that is get rid of a<br>&gt;&gt; couple of methods that would loop forever on infinite sequences, but<br>&gt;&gt; it&#39;s a lot of work and a lot of duplication for what seems like an<br>&gt;&gt; extremely small win.<br>&gt;&gt;<br>&gt;&gt; I&#39;d much rather just come up with some alternative to @available(*,<br>&gt;&gt; unavailable) that actually leaves the method intact but provides a<br>&gt;&gt; compile-time error if you call it. This would be strictly intended<br>&gt;&gt; for protocol methods, as you&#39;d still need to provide an<br>&gt;&gt; implementation (such as `fatalError(&quot;not supported&quot;)`) that would be<br>&gt;&gt; called when the method is accessed via a generic type bound on the<br>&gt;&gt; protocol (or via an existential protocol value, for protocols that<br>&gt;&gt; support that).<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; * Add a property to SequenceType to indicate if it&#39;s definitely<br>&gt;&gt;&gt; finite (undefined?), AnySequence uses a different backing<br>&gt;&gt;&gt; implementation depending on this boolean.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; And what would AnySequence do with that information? All it could<br>&gt;&gt; really do is make sure to call fatalError() instead of looping<br>&gt;&gt; forever when a method like suffix() is called.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; -Kevin Ballard<br>&gt;&gt;<br></p><p><br></p><p>Links:<br></p><p>  1. https://bugs.swift.org/browse/SR-413<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151229/bc4871dd/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Proposal: CollectionType.cycle property for an infinite sequence</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 29, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; On Dec 27, 2015, at 11:35 PM, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; +1.  Stream support is long overdue.<br></p><p>Could you define what you mean by “stream support?”  Whatever it is, I doubt simply adding an infinitely-repeating sequence type is enough to get you there.<br></p><p>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>Proposal: CollectionType.cycle property for an infinite sequence</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>December 30, 2015 at 07:00:00am</p></header><div class="content"><p>&gt; Could you define what you mean by “stream support?”  Whatever it is, I doubt simply adding an infinitely-repeating sequence type is enough to get you there.<br></p><p><br>I can guess — but it is only a guess.  <br></p><p>A function defines an infinite “set” of values (like the digits of pi).  A stream is just a special type of traversable (lazy) which does not evaluate until asked for the next in a sequence of the set.  A function defined in a stream will thus only continue calculating next digits when asked for them.  Similarly you could have a collection (head/tail) and you ask for the head and you get it, but the rest (tail) is just the tail as a whole and none of the values in it are really defined until you traverse down to the next head of the rest of the tail.  Once it is evaluated it is stored in memory for future evaluations.  If you were to fully evaluate the function it would never finish, and if it were to finish — you would probably run out of memory.<br></p><p><br></p><p><br>As usual I created these examples with the Scala 2.8 REPL but I think most if not all should work in 2.7.<br>&gt; On 2015-12-30, at 7:12:41, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 27, 2015, at 11:35 PM, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; +1.  Stream support is long overdue.<br>&gt; <br>&gt; Could you define what you mean by “stream support?”  Whatever it is, I doubt simply adding an infinitely-repeating sequence type is enough to get you there.<br>&gt; <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/dab981af/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Proposal: CollectionType.cycle property for an infinite sequence</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 29, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; On Dec 29, 2015, at 4:29 PM, Craig Cruden &lt;ccruden at novafore.com&gt; wrote:<br>&gt; <br>&gt;&gt; Could you define what you mean by “stream support?”  Whatever it is, I doubt simply adding an infinitely-repeating sequence type is enough to get you there.<br>&gt; <br>&gt; <br>&gt; I can guess — but it is only a guess.  <br>&gt; <br>&gt; A function defines an infinite “set” of values (like the digits of pi).  A stream is just a special type of traversable (lazy) which does not evaluate until asked for the next in a sequence of the set.  A function defined in a stream will thus only continue calculating next digits when asked for them.  Similarly you could have a collection (head/tail) and you ask for the head and you get it, but the rest (tail) is just the tail as a whole and none of the values in it are really defined until you traverse down to the next head of the rest of the tail.  Once it is evaluated it is stored in memory for future evaluations.  If you were to fully evaluate the function it would never finish, and if it were to finish — you would probably run out of memory.<br></p><p>Yes, I understand the usual concept of a “stream,&quot; but it doesn’t help me understand what  stream *support* entails.<br></p><p>-Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151229/2430571a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>Proposal: CollectionType.cycle property for an infinite sequence</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>December 30, 2015 at 08:00:00am</p></header><div class="content"><p>I have never tried to implement a “stream” in Swift, so I am not sure if there is an easy way to do it…. but I don’t see a collection of type stream as I have in Scala.  <br></p><p>http://www.scala-lang.org/api/current/index.html#scala.collection.immutable.Stream &lt;http://www.scala-lang.org/api/current/index.html#scala.collection.immutable.Stream&gt;<br></p><p><br>&gt; On 2015-12-30, at 7:39:54, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 29, 2015, at 4:29 PM, Craig Cruden &lt;ccruden at novafore.com &lt;mailto:ccruden at novafore.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Could you define what you mean by “stream support?”  Whatever it is, I doubt simply adding an infinitely-repeating sequence type is enough to get you there.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I can guess — but it is only a guess.  <br>&gt;&gt; <br>&gt;&gt; A function defines an infinite “set” of values (like the digits of pi).  A stream is just a special type of traversable (lazy) which does not evaluate until asked for the next in a sequence of the set.  A function defined in a stream will thus only continue calculating next digits when asked for them.  Similarly you could have a collection (head/tail) and you ask for the head and you get it, but the rest (tail) is just the tail as a whole and none of the values in it are really defined until you traverse down to the next head of the rest of the tail.  Once it is evaluated it is stored in memory for future evaluations.  If you were to fully evaluate the function it would never finish, and if it were to finish — you would probably run out of memory.<br>&gt; <br>&gt; Yes, I understand the usual concept of a “stream,&quot; but it doesn’t help me understand what  stream *support* entails.<br>&gt; <br>&gt; -Dave<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/86f4f07c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>Proposal: CollectionType.cycle property for an infinite sequence</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>December 29, 2015 at 09:00:00pm</p></header><div class="content"><p>I think we have to make some things clear.  Unfortunately, I used the word stream when I meant cycle, they are very different things from an implementer&#39;s perspective.  A stream is a generalized version of a cycle, where the latter admits infinite sequences of any kind or mix of data (say, the Fibonacci example here), the latter admits only infinite representations based on an initial finite input.  This makes many divergent cases in the former perfectly valid in the latter through proper manipulation of an underlying finite sequence.  If you want to see what a Cycle looks like, Rust has std::iter::Cycle.  Swiftz, on the other hand, shows what a proper stream would look like (and having written the thing, I do not wish to see support for it in the Swift Standard Library). <br></p><p>~Robert Widmann<br></p><p>2015/12/29 18:39、Craig Cruden &lt;ccruden at novafore.com&gt; のメッセージ:<br></p><p>&gt; I have never tried to implement a “stream” in Swift, so I am not sure if there is an easy way to do it…. but I don’t see a collection of type stream as I have in Scala.  <br>&gt; <br>&gt; http://www.scala-lang.org/api/current/index.html#scala.collection.immutable.Stream<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On 2015-12-30, at 7:39:54, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 29, 2015, at 4:29 PM, Craig Cruden &lt;ccruden at novafore.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Could you define what you mean by “stream support?”  Whatever it is, I doubt simply adding an infinitely-repeating sequence type is enough to get you there.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I can guess ― but it is only a guess.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A function defines an infinite “set” of values (like the digits of pi).  A stream is just a special type of traversable (lazy) which does not evaluate until asked for the next in a sequence of the set.  A function defined in a stream will thus only continue calculating next digits when asked for them.  Similarly you could have a collection (head/tail) and you ask for the head and you get it, but the rest (tail) is just the tail as a whole and none of the values in it are really defined until you traverse down to the next head of the rest of the tail.  Once it is evaluated it is stored in memory for future evaluations.  If you were to fully evaluate the function it would never finish, and if it were to finish ― you would probably run out of memory.<br>&gt;&gt; <br>&gt;&gt; Yes, I understand the usual concept of a “stream,&quot; but it doesn’t help me understand what  stream *support* entails.<br>&gt;&gt; <br>&gt;&gt; -Dave<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151229/ab2c1fbe/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>Proposal: CollectionType.cycle property for an infinite sequence</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>December 29, 2015 at 10:00:00am</p></header><div class="content"><p>Personally I’d say this should be a -1 for standard-library inclusion.<br></p><p>Swift’s not really built to handle infinite sequences right now; until they are handed better by the standard library convenience methods for creating them shouldn’t be in the standard library.<br></p><p>You’d also want to call `fatalError` for at least `reduce`, `reverse`, `sort`, `split`(?), `flatMap`, `dropLast`, `suffix`, and `forEach`.<br></p><p>`startsWith` and `elementsEqual` and `lexicographicComparison` are all broken if you call them like e.g. `self.startsWith(self)`.<br></p><p>You can conceivably implement a non-crashing `contains`, `minElement` and `maxElement` on `CycleSequence` by calling through to the wrapped collection, but that’ll seemingly evaporate as soon as your `CycleSequence` winds up hidden inside an `AnySequence`.<br></p><p>Which illustrates why this is a -1 for me; there&#39;s nothing wrong with the functionality in isolation and there’s nothing wrong with infinite sequences, but the standard library should play well with itself, and this wouldn’t play well with the rest of the standard library.<br></p><p>That opinion could change as the language changes or the standard library evolves.<br></p><p>&gt; On Dec 28, 2015, at 1:20 AM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; ## Introduction<br>&gt; <br>&gt; Add a new property `cycle` to CollectionType that returns an infinite SequenceType that yields the elements of the collection in a loop.<br>&gt; <br>&gt; ## Motivation<br>&gt; <br>&gt; It&#39;s sometimes useful to be able to have an infinite sequence. For example, `CollectionOfOne(x).cycle` could be used to have an infinite sequence of a single element (similar to Repeat but without a count). A common use for infinite sequences is zipping with a finite sequence. As far as I&#39;m aware, the stdlib does not currently provide any way to create such an infinite sequence.<br>&gt; <br>&gt; ## Proposed solution<br>&gt; <br>&gt; Extend CollectionType with a new property `cycle` that yields a type that conforms to SequenceType. This sequence yields each element of the collection in an infinite loop.<br>&gt; <br>&gt; ## Detailed design<br>&gt; <br>&gt; 2 new types would be added:<br>&gt; <br>&gt; struct CycleSequence&lt;Base : CollectionType&gt; : LazySequenceType { ... }<br>&gt; struct CycleGenerator&lt;Base : CollectionType&gt; : GeneratorType { ... }<br>&gt; <br>&gt; CollectionType would be extended with a property:<br>&gt; <br>&gt; extension CollectionType {<br>&gt;    public var cycle: CycleSequence&lt;Self&gt; { get }<br>&gt; }<br>&gt; <br>&gt; This is an extension of CollectionType instead of SequenceType because it requires a multi-pass sequence (and SequenceType does not provide that guarantee). The returned type conforms to SequenceType instead of CollectionType because there is no possible `endIndex` that satisfies the requirement of being reachable from `startIndex` by zero or more applications of `successor()`.<br>&gt; <br>&gt; Because the default eager versions of map and filter will execute forever on an infinite sequence, CycleSequence conforms to LazySequenceType instead of SequenceType in order to provide lazy versions of those functions. Additionally, it will provide implementations of the eager versions that simply trigger a fatalError(), as the alternative is an infinite loop that consumes more and more memory.<br>&gt; <br>&gt; ## Impact on existing code<br>&gt; <br>&gt; None<br>&gt; <br>&gt; -Kevin Ballard<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: CollectionType.cycle property for an infinite sequence</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 29, 2015 at 11:00:00am</p></header><div class="content"><p>On Tue, Dec 29, 2015, at 08:14 AM, plx via swift-evolution wrote:<br>&gt; Personally I’d say this should be a -1 for standard-library inclusion.<br>&gt; <br>&gt; Swift’s not really built to handle infinite sequences right now; until they are handed better by the standard library convenience methods for creating them shouldn’t be in the standard library.<br></p><p>As far as I can tell, the only way in which it&#39;s &quot;not really built&quot; to handle this is that there are multiple constructs that attempt to eagerly consume an entire sequence, and using these with an infinite sequence would end up looping forever. But I don&#39;t consider that to be a particularly serious problem. You could &quot;fix&quot; it by refactoring SequenceType into two protocols, SequenceType (for possibly-infinite sequences) and FiniteSequenceType (for known-finite sequences) and then going over the entire standard library and updating various spots to use FiniteSequenceType, except this would be very limiting (sequences that are not known if they&#39;re infinite to the compiler could still be valid for various eager algorithms if the programmer knows it will be finite in practice).<br></p><p>&gt; You’d also want to call `fatalError` for at least `reduce`, `reverse`, `sort`, `split`(?), `flatMap`, `dropLast`, `suffix`, and `forEach`.<br></p><p>You can only do it for the ones defined in the protocol, not ones defined in extensions. This means map, filter, forEach, and suffix.<br></p><p>split is actually perfectly implementable for a CycleSequence, although it does need a custom implementation. split is bounded by at most Int.max splits, which means it is guaranteed to terminate even for an infinite sequence (although the final subsequence does need to be infinite[1]). Even if there are no separators in the cycle, it can just return the cycle itself.<br></p><p>[1] Interestingly, the current implementation actually dumps the remainder into an Array and returns that (wrapped in AnySequence), which is curious because it would be perfectly legal for it to just wrap the generator up in AnySequence and return that instead. I&#39;m tempted to submit a PR to change that now, as it just seems like unnecessary work to use an array.<br></p><p>&gt; `startsWith` and `elementsEqual` and `lexicographicComparison` are all broken if you call them like e.g. `self.startsWith(self)`.<br></p><p>That&#39;s true, but what do you really expect when you&#39;re calling them with two infinite sequences? It&#39;s not so much that they&#39;re broken as it is that you&#39;re creating an infinite loop without any way to break out. And FWIW, lexicographicalCompare is actually something you might want to explicitly support on infinite sequences if you know your sequences aren&#39;t equal and want to find out which one is less than the other.<br></p><p>There are plenty of ways to shoot yourself in the foot. I don&#39;t think infinite sequences are really the big problem you&#39;re making them out to be.<br></p><p>&gt; You can conceivably implement a non-crashing `contains`, `minElement` and `maxElement` on `CycleSequence` by calling through to the wrapped collection, but that’ll seemingly evaporate as soon as your `CycleSequence` winds up hidden inside an `AnySequence`.<br></p><p>You can&#39;t override those anyway in a generic context, because they&#39;re not members of the protocol, they&#39;re just extensions. You could implement them such that your implementation is called when working on the concrete CycleSequence type, but I&#39;m not sure if that&#39;s a great idea to do that when the actual behavior differs from calling it generically on SequenceType (well, triggering a fatalError() instead of an infinite loop is fine because they&#39;re both Bottom, but returning a valid result in one context and looping infinitely in the other seems bad).<br></p><p>Of course, these methods could actually be moved into the protocol itself, which would let us override them. I&#39;m not entirely sure why they aren&#39;t in the protocol to begin with, I guess because there&#39;s not much need for overriding these outside of infinite sequences (well, finite sorted sequences could provide an optimized min/maxElement, and an optimized version of contains(_: Self.Generator.Element), but maybe there&#39;s tradeoffs to doing this, e.g. maybe there&#39;s some reason why having a large protocol witness table is a bad idea).<br></p><p>&gt; Which illustrates why this is a -1 for me; there&#39;s nothing wrong with the functionality in isolation and there’s nothing wrong with infinite sequences, but the standard library should play well with itself, and this wouldn’t play well with the rest of the standard library.<br></p><p>Ultimately, there&#39;s not much difference between an infinite sequence and a sequence of Int.max elements. The latter is finite, but it&#39;s so massive (especially on 64-bit) that any kind of eager processing is going to hit the same problems as an infinite sequence. Every problem you describe will be a problem with the simple sequence `(0..&lt;Int.max)` as well.<br></p><p>-Kevin Ballard<br></p><p>&gt; That opinion could change as the language changes or the standard library evolves.<br>&gt; <br>&gt; &gt; On Dec 28, 2015, at 1:20 AM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; <br>&gt; &gt; ## Introduction<br>&gt; &gt; <br>&gt; &gt; Add a new property `cycle` to CollectionType that returns an infinite SequenceType that yields the elements of the collection in a loop.<br>&gt; &gt; <br>&gt; &gt; ## Motivation<br>&gt; &gt; <br>&gt; &gt; It&#39;s sometimes useful to be able to have an infinite sequence. For example, `CollectionOfOne(x).cycle` could be used to have an infinite sequence of a single element (similar to Repeat but without a count). A common use for infinite sequences is zipping with a finite sequence. As far as I&#39;m aware, the stdlib does not currently provide any way to create such an infinite sequence.<br>&gt; &gt; <br>&gt; &gt; ## Proposed solution<br>&gt; &gt; <br>&gt; &gt; Extend CollectionType with a new property `cycle` that yields a type that conforms to SequenceType. This sequence yields each element of the collection in an infinite loop.<br>&gt; &gt; <br>&gt; &gt; ## Detailed design<br>&gt; &gt; <br>&gt; &gt; 2 new types would be added:<br>&gt; &gt; <br>&gt; &gt; struct CycleSequence&lt;Base : CollectionType&gt; : LazySequenceType { ... }<br>&gt; &gt; struct CycleGenerator&lt;Base : CollectionType&gt; : GeneratorType { ... }<br>&gt; &gt; <br>&gt; &gt; CollectionType would be extended with a property:<br>&gt; &gt; <br>&gt; &gt; extension CollectionType {<br>&gt; &gt;    public var cycle: CycleSequence&lt;Self&gt; { get }<br>&gt; &gt; }<br>&gt; &gt; <br>&gt; &gt; This is an extension of CollectionType instead of SequenceType because it requires a multi-pass sequence (and SequenceType does not provide that guarantee). The returned type conforms to SequenceType instead of CollectionType because there is no possible `endIndex` that satisfies the requirement of being reachable from `startIndex` by zero or more applications of `successor()`.<br>&gt; &gt; <br>&gt; &gt; Because the default eager versions of map and filter will execute forever on an infinite sequence, CycleSequence conforms to LazySequenceType instead of SequenceType in order to provide lazy versions of those functions. Additionally, it will provide implementations of the eager versions that simply trigger a fatalError(), as the alternative is an infinite loop that consumes more and more memory.<br>&gt; &gt; <br>&gt; &gt; ## Impact on existing code<br>&gt; &gt; <br>&gt; &gt; None<br>&gt; &gt; <br>&gt; &gt; -Kevin Ballard<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>Proposal: CollectionType.cycle property for an infinite sequence</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>December 29, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt; On Dec 29, 2015, at 1:17 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Tue, Dec 29, 2015, at 08:14 AM, plx via swift-evolution wrote:<br>&gt;&gt; Personally I’d say this should be a -1 for standard-library inclusion.<br>&gt;&gt; <br>&gt;&gt; Swift’s not really built to handle infinite sequences right now; until they are handed better by the standard library convenience methods for creating them shouldn’t be in the standard library.<br>&gt; <br>&gt; As far as I can tell, the only way in which it&#39;s &quot;not really built&quot; to handle this is that there are multiple constructs that attempt to eagerly consume an entire sequence, and using these with an infinite sequence would end up looping forever. But I don&#39;t consider that to be a particularly serious problem. You could &quot;fix&quot; it by refactoring SequenceType into two protocols, SequenceType (for possibly-infinite sequences) and FiniteSequenceType (for known-finite sequences) and then going over the entire standard library and updating various spots to use FiniteSequenceType, except this would be very limiting (sequences that are not known if they&#39;re infinite to the compiler could still be valid for various eager algorithms if the programmer knows it will be finite in practice).<br></p><p>Indeed, on my wishlist I would like to see the standard protocols refactored to something more like this:<br></p><p>SequenceType // can be iterated<br>FiniteSequenceType : SequenceType, // of finite length<br>StableSequenceType : SequenceType, // can be re-iterated identically<br>CollectionType : StableSequenceType, FiniteSequenceType, (etc.) // otherwise as it is now<br></p><p>…but can understand the wish to not overly-complicate the basic protocol hierarchy (and also to avoid baking-in nice-to-have, but impossible-to-really-enforce semantic requirements; I’d trust the standard library to use them properly, but not typical 3rd party code, somewhat defeating the purpose).<br></p><p>Everything else is a difference of outlook; we agree on the facts and differ in interpretation.<br></p><p>I consider concrete types that adopt a protocol only to simply call `fatalError` for most of the protocol methods to be pathological — often useful, but still pathological — and thus far the standard library doesn’t contain any such pathological types (to my knowledge).<br></p><p>`cycle` is useful but not useful enough to be the standard library’s first “pathological” type, so it’s still a -1 as proposed.<br></p><p>This is nothing specific to `cycle` and my opinion here could change were the language or the standard library to evolve in various ways.<br>&gt; <br>&gt;&gt; You’d also want to call `fatalError` for at least `reduce`, `reverse`, `sort`, `split`(?), `flatMap`, `dropLast`, `suffix`, and `forEach`.<br>&gt; <br>&gt; You can only do it for the ones defined in the protocol, not ones defined in extensions. This means map, filter, forEach, and suffix.<br>&gt; <br>&gt; split is actually perfectly implementable for a CycleSequence, although it does need a custom implementation. split is bounded by at most Int.max splits, which means it is guaranteed to terminate even for an infinite sequence (although the final subsequence does need to be infinite[1]). Even if there are no separators in the cycle, it can just return the cycle itself.<br>&gt; <br>&gt; [1] Interestingly, the current implementation actually dumps the remainder into an Array and returns that (wrapped in AnySequence), which is curious because it would be perfectly legal for it to just wrap the generator up in AnySequence and return that instead. I&#39;m tempted to submit a PR to change that now, as it just seems like unnecessary work to use an array.<br>&gt; <br>&gt;&gt; `startsWith` and `elementsEqual` and `lexicographicComparison` are all broken if you call them like e.g. `self.startsWith(self)`.<br>&gt; <br>&gt; That&#39;s true, but what do you really expect when you&#39;re calling them with two infinite sequences? It&#39;s not so much that they&#39;re broken as it is that you&#39;re creating an infinite loop without any way to break out. And FWIW, lexicographicalCompare is actually something you might want to explicitly support on infinite sequences if you know your sequences aren&#39;t equal and want to find out which one is less than the other.<br>&gt; <br>&gt; There are plenty of ways to shoot yourself in the foot. I don&#39;t think infinite sequences are really the big problem you&#39;re making them out to be.<br>&gt; <br>&gt;&gt; You can conceivably implement a non-crashing `contains`, `minElement` and `maxElement` on `CycleSequence` by calling through to the wrapped collection, but that’ll seemingly evaporate as soon as your `CycleSequence` winds up hidden inside an `AnySequence`.<br>&gt; <br>&gt; You can&#39;t override those anyway in a generic context, because they&#39;re not members of the protocol, they&#39;re just extensions. You could implement them such that your implementation is called when working on the concrete CycleSequence type, but I&#39;m not sure if that&#39;s a great idea to do that when the actual behavior differs from calling it generically on SequenceType (well, triggering a fatalError() instead of an infinite loop is fine because they&#39;re both Bottom, but returning a valid result in one context and looping infinitely in the other seems bad).<br>&gt; <br>&gt; Of course, these methods could actually be moved into the protocol itself, which would let us override them. I&#39;m not entirely sure why they aren&#39;t in the protocol to begin with, I guess because there&#39;s not much need for overriding these outside of infinite sequences (well, finite sorted sequences could provide an optimized min/maxElement, and an optimized version of contains(_: Self.Generator.Element), but maybe there&#39;s tradeoffs to doing this, e.g. maybe there&#39;s some reason why having a large protocol witness table is a bad idea).<br></p><p>I don’t think `contains` or `minElement/maxElement` *can* be part of the protocol (in the sense of overridable) at this time (they require `Element` satisfy certain type constraints), but they certainly should be if the type system someday would support that.<br></p><p>&gt; <br>&gt;&gt; Which illustrates why this is a -1 for me; there&#39;s nothing wrong with the functionality in isolation and there’s nothing wrong with infinite sequences, but the standard library should play well with itself, and this wouldn’t play well with the rest of the standard library.<br>&gt; <br>&gt; Ultimately, there&#39;s not much difference between an infinite sequence and a sequence of Int.max elements. The latter is finite, but it&#39;s so massive (especially on 64-bit) that any kind of eager processing is going to hit the same problems as an infinite sequence. Every problem you describe will be a problem with the simple sequence `(0..&lt;Int.max)` as well.<br>&gt; <br>&gt; -Kevin Ballard<br>&gt; <br>&gt;&gt; That opinion could change as the language changes or the standard library evolves.<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 28, 2015, at 1:20 AM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Add a new property `cycle` to CollectionType that returns an infinite SequenceType that yields the elements of the collection in a loop.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It&#39;s sometimes useful to be able to have an infinite sequence. For example, `CollectionOfOne(x).cycle` could be used to have an infinite sequence of a single element (similar to Repeat but without a count). A common use for infinite sequences is zipping with a finite sequence. As far as I&#39;m aware, the stdlib does not currently provide any way to create such an infinite sequence.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Extend CollectionType with a new property `cycle` that yields a type that conforms to SequenceType. This sequence yields each element of the collection in an infinite loop.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Detailed design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2 new types would be added:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct CycleSequence&lt;Base : CollectionType&gt; : LazySequenceType { ... }<br>&gt;&gt;&gt; struct CycleGenerator&lt;Base : CollectionType&gt; : GeneratorType { ... }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; CollectionType would be extended with a property:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension CollectionType {<br>&gt;&gt;&gt;   public var cycle: CycleSequence&lt;Self&gt; { get }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is an extension of CollectionType instead of SequenceType because it requires a multi-pass sequence (and SequenceType does not provide that guarantee). The returned type conforms to SequenceType instead of CollectionType because there is no possible `endIndex` that satisfies the requirement of being reachable from `startIndex` by zero or more applications of `successor()`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Because the default eager versions of map and filter will execute forever on an infinite sequence, CycleSequence conforms to LazySequenceType instead of SequenceType in order to provide lazy versions of those functions. Additionally, it will provide implementations of the eager versions that simply trigger a fatalError(), as the alternative is an infinite loop that consumes more and more memory.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Impact on existing code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; None<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151229/c4e56e3a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: CollectionType.cycle property for an infinite sequence</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 29, 2015 at 04:00:00pm</p></header><div class="content"><p>On Tue, Dec 29, 2015, at 03:39 PM, plx via swift-evolution wrote:<br>&gt;<br>&gt;&gt; On Dec 29, 2015, at 1:17 PM, Kevin Ballard via swift-evolution &lt;swift-<br>&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Tue, Dec 29, 2015, at 08:14 AM, plx via swift-evolution wrote:<br>&gt;&gt;&gt; Personally I’d say this should be a -1 for standard-library<br>&gt;&gt;&gt; inclusion.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Swift’s not really built to handle infinite sequences right now;<br>&gt;&gt;&gt; until they are handed better by the standard library convenience<br>&gt;&gt;&gt; methods for creating them shouldn’t be in the standard library.<br>&gt;&gt;<br>&gt;&gt; As far as I can tell, the only way in which it&#39;s &quot;not really built&quot;<br>&gt;&gt; to handle this is that there are multiple constructs that attempt to<br>&gt;&gt; eagerly consume an entire sequence, and using these with an infinite<br>&gt;&gt; sequence would end up looping forever. But I don&#39;t consider that to<br>&gt;&gt; be a particularly serious problem. You could &quot;fix&quot; it by refactoring<br>&gt;&gt; SequenceType into two protocols, SequenceType (for possibly-infinite<br>&gt;&gt; sequences) and FiniteSequenceType (for known-finite sequences) and<br>&gt;&gt; then going over the entire standard library and updating various<br>&gt;&gt; spots to use FiniteSequenceType, except this would be very limiting<br>&gt;&gt; (sequences that are not known if they&#39;re infinite to the compiler<br>&gt;&gt; could still be valid for various eager algorithms if the programmer<br>&gt;&gt; knows it will be finite in practice).<br>&gt;<br>&gt; Indeed, on my wishlist I would like to see the standard protocols<br>&gt; refactored to something more like this:<br>&gt;<br>&gt; SequenceType // can be iterated FiniteSequenceType : SequenceType, //<br>&gt; of finite length StableSequenceType : SequenceType, // can be re-<br>&gt; iterated identically CollectionType : StableSequenceType,<br>&gt; FiniteSequenceType, (etc.) // otherwise as it is now<br>&gt;<br>&gt; …but can understand the wish to not overly-complicate the basic<br>&gt; protocol hierarchy (and also to avoid baking-in nice-to-have, but impossible-to-really-<br>&gt; enforce semantic requirements; I’d trust the standard library to use<br>&gt; them properly, but not typical 3rd party code, somewhat defeating the<br>&gt; purpose).<br>&gt;<br>&gt; Everything else is a difference of outlook; we agree on the facts and<br>&gt; differ in interpretation.<br>&gt;<br>&gt; I consider concrete types that adopt a protocol only to simply call<br>&gt; `fatalError` for most of the protocol methods to be pathological —<br>&gt; often useful, but still pathological — and thus far the standard<br>&gt; library doesn’t contain any such pathological types (to my knowledge).<br></p><p>It only calls `fatalError` because the default implementation would loop<br>forever anyway (and consume more and more memory until this eventually<br>causes a crash). You can trivially remove the `fatalError()`<br>implementations and still have the CycleSequence type, the only reason<br>to have them is because we may as well tell the user exactly what they<br>did wrong instead of letting the program enter an infinite loop that<br>tries to eat all the memory in the system.<br></p><p>&gt; `cycle` is useful but not useful enough to be the standard library’s<br>&gt; first “pathological” type, so it’s still a -1 as proposed.<br></p><p>There&#39;s plenty of use for infinite sequences. And all infinite sequences<br>are &quot;pathological&quot; in the same sense. The fact that the stdlib doesn&#39;t<br>provide any convenient ways to produce infinite sequences right now is a<br>deficiency, not an advantage. As previously stated, the issues with<br>infinite sequences also manifest with extremely long finite sequences<br>(such as `(1..&lt;Int.max)`). Also, the stdlib does already provide a way<br>to make your own infinite sequences already, which is to use<br>`anyGenerator()` with a function that can never return `nil`.<br></p><p>Which is to say, the only thing special about Cycle is that it can<br>eagerly detect some infinite loops and trigger a fatalError().<br></p><p>It&#39;s also worth pointing out here that CycleSequence is inherently lazy<br>(it conforms to LazySequenceType), which provides lazy versions of<br>map/filter/etc., so you&#39;re only ever going to actually hit the eager<br>SequenceType variants when either working generically with &lt;T:<br>SequenceType&gt; or if you explicitly constrain the return value of<br>map()/filter() to Array (which will cause it to resolve to the<br>SequenceType version). But in both cases, the problems with Cycle are,<br>as I said before, the same problems you&#39;d get with something like<br>`(1..&lt;Int.max)`.<br></p><p>&gt;&gt;&gt; You can conceivably implement a non-crashing `contains`,<br>&gt;&gt;&gt; `minElement` and `maxElement` on `CycleSequence` by calling through<br>&gt;&gt;&gt; to the wrapped collection, but that’ll seemingly evaporate as soon<br>&gt;&gt;&gt; as your `CycleSequence` winds up hidden inside an `AnySequence`.<br>&gt;&gt;<br>&gt;&gt; You can&#39;t override those anyway in a generic context, because they&#39;re<br>&gt;&gt; not members of the protocol, they&#39;re just extensions. You could<br>&gt;&gt; implement them such that your implementation is called when working<br>&gt;&gt; on the concrete CycleSequence type, but I&#39;m not sure if that&#39;s a<br>&gt;&gt; great idea to do that when the actual behavior differs from calling<br>&gt;&gt; it generically on SequenceType (well, triggering a fatalError()<br>&gt;&gt; instead of an infinite loop is fine because they&#39;re both Bottom, but<br>&gt;&gt; returning a valid result in one context and looping infinitely in the<br>&gt;&gt; other seems bad).<br>&gt;&gt;<br>&gt;&gt; Of course, these methods could actually be moved into the protocol<br>&gt;&gt; itself, which would let us override them. I&#39;m not entirely sure why<br>&gt;&gt; they aren&#39;t in the protocol to begin with, I guess because there&#39;s<br>&gt;&gt; not much need for overriding these outside of infinite sequences<br>&gt;&gt; (well, finite sorted sequences could provide an optimized<br>&gt;&gt; min/maxElement, and an optimized version of contains(_:<br>&gt;&gt; Self.Generator.Element), but maybe there&#39;s tradeoffs to doing this,<br>&gt;&gt; e.g. maybe there&#39;s some reason why having a large protocol witness<br>&gt;&gt; table is a bad idea).<br>&gt;<br>&gt; I don’t think `contains` or `minElement/maxElement` *can* be part of<br>&gt; the protocol (in the sense of overridable) at this time (they require<br>&gt; `Element` satisfy certain type constraints), but they certainly should<br>&gt; be if the type system someday would support that.<br></p><p>They actually can. There&#39;s two variants of each function; one which<br>takes a comparison function, and one which requires the<br>Comparable/Equatable bound. The version for Comparable/Equatable can&#39;t<br>be part of the protocol itself (and shouldn&#39;t be; it&#39;s just a<br>convenience for providing the appropriate comparison function), but the<br>version that takes a function has no bounds on it and could be part of<br>the protocol itself.<br></p><p>-Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151229/60574d98/attachment-0001.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Proposal: CollectionType.cycle property for an infinite sequence</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 29, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; On Dec 29, 2015, at 3:39 PM, plx via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 29, 2015, at 1:17 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Tue, Dec 29, 2015, at 08:14 AM, plx via swift-evolution wrote:<br>&gt;&gt;&gt; Personally I’d say this should be a -1 for standard-library inclusion.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift’s not really built to handle infinite sequences right now; until they are handed better by the standard library convenience methods for creating them shouldn’t be in the standard library.<br>&gt;&gt; <br>&gt;&gt; As far as I can tell, the only way in which it&#39;s &quot;not really built&quot; to handle this is that there are multiple constructs that attempt to eagerly consume an entire sequence, and using these with an infinite sequence would end up looping forever. But I don&#39;t consider that to be a particularly serious problem. You could &quot;fix&quot; it by refactoring SequenceType into two protocols, SequenceType (for possibly-infinite sequences) and FiniteSequenceType (for known-finite sequences) and then going over the entire standard library and updating various spots to use FiniteSequenceType, except this would be very limiting (sequences that are not known if they&#39;re infinite to the compiler could still be valid for various eager algorithms if the programmer knows it will be finite in practice).<br>&gt; <br>&gt; Indeed, on my wishlist I would like to see the standard protocols refactored to something more like this:<br>&gt; <br>&gt; SequenceType // can be iterated<br>&gt; FiniteSequenceType : SequenceType, // of finite length<br>&gt; StableSequenceType : SequenceType, // can be re-iterated identically<br>&gt; CollectionType : StableSequenceType, FiniteSequenceType, (etc.) // otherwise as it is now<br></p><p>This is interesting. A few concerns:<br></p><p>First, we have tried not to create any distinct protocols with identical syntactic requirements, because we think it makes the world clearer; we think people are more likely to assign incorrect protocols when all the operations they want are available, but don’t have the right semantics.  That isn’t to say we shouldn’t start doing it, but it would be a break from the past.<br></p><p>Higher protocol granularity has a high comprehensibility cost.  Distinguishing protocols based on semantic requirements alone may make the library harder to understand.  I’ve heard some people’s heads have exploded from simply encountering CollectionType. <br></p><p>Next, it’s a principle of generic programming that every protocol should be justified by both algorithms that exploit its requirements (e.g. extension methods) and some real-world models that can’t reasonably also conform to a more-refined protocol.  For example, we have a ForwardIndexType because a singly-linked list has multipass forward traversal and can’t do bidirectional traversal.  In order to evaluate any proposal for new protocols, we’d need to see all of these things.<br></p><p>&gt; …but can understand the wish to not overly-complicate the basic protocol hierarchy (and also to avoid baking-in nice-to-have, but impossible-to-really-enforce semantic requirements; I’d trust the standard library to use them properly, but not typical 3rd party code, somewhat defeating the purpose).<br></p><p>Well, I guess I should have read ahead and most of my lecture above was needless!  I’m posting it anyway because I think it spells out some important principles we’ll need to refer to later.<br></p><p>&gt; Everything else is a difference of outlook; we agree on the facts and differ in interpretation.<br>&gt; <br>&gt; I consider concrete types that adopt a protocol only to simply call `fatalError` for most of the protocol methods to be pathological — often useful, but still pathological — and thus far the standard library doesn’t contain any such pathological types (to my knowledge).<br>&gt; <br>&gt; `cycle` is useful but not useful enough to be the standard library’s first “pathological” type, so it’s still a -1 as proposed.<br>&gt; <br>&gt; This is nothing specific to `cycle` and my opinion here could change were the language or the standard library to evolve in various ways.<br>&gt;&gt; <br>&gt;&gt;&gt; You’d also want to call `fatalError` for at least `reduce`, `reverse`, `sort`, `split`(?), `flatMap`, `dropLast`, `suffix`, and `forEach`.<br>&gt;&gt; <br>&gt;&gt; You can only do it for the ones defined in the protocol, not ones defined in extensions. This means map, filter, forEach, and suffix.<br>&gt;&gt; <br>&gt;&gt; split is actually perfectly implementable for a CycleSequence, although it does need a custom implementation. split is bounded by at most Int.max splits, which means it is guaranteed to terminate even for an infinite sequence (although the final subsequence does need to be infinite[1]). Even if there are no separators in the cycle, it can just return the cycle itself.<br>&gt;&gt; <br>&gt;&gt; [1] Interestingly, the current implementation actually dumps the remainder into an Array and returns that (wrapped in AnySequence), which is curious because it would be perfectly legal for it to just wrap the generator up in AnySequence and return that instead. I&#39;m tempted to submit a PR to change that now, as it just seems like unnecessary work to use an array.<br>&gt;&gt; <br>&gt;&gt;&gt; `startsWith` and `elementsEqual` and `lexicographicComparison` are all broken if you call them like e.g. `self.startsWith(self)`.<br>&gt;&gt; <br>&gt;&gt; That&#39;s true, but what do you really expect when you&#39;re calling them with two infinite sequences? It&#39;s not so much that they&#39;re broken as it is that you&#39;re creating an infinite loop without any way to break out. And FWIW, lexicographicalCompare is actually something you might want to explicitly support on infinite sequences if you know your sequences aren&#39;t equal and want to find out which one is less than the other.<br>&gt;&gt; <br>&gt;&gt; There are plenty of ways to shoot yourself in the foot. I don&#39;t think infinite sequences are really the big problem you&#39;re making them out to be.<br>&gt;&gt; <br>&gt;&gt;&gt; You can conceivably implement a non-crashing `contains`, `minElement` and `maxElement` on `CycleSequence` by calling through to the wrapped collection, but that’ll seemingly evaporate as soon as your `CycleSequence` winds up hidden inside an `AnySequence`.<br>&gt;&gt; <br>&gt;&gt; You can&#39;t override those anyway in a generic context, because they&#39;re not members of the protocol, they&#39;re just extensions. You could implement them such that your implementation is called when working on the concrete CycleSequence type, but I&#39;m not sure if that&#39;s a great idea to do that when the actual behavior differs from calling it generically on SequenceType (well, triggering a fatalError() instead of an infinite loop is fine because they&#39;re both Bottom, but returning a valid result in one context and looping infinitely in the other seems bad).<br>&gt;&gt; <br>&gt;&gt; Of course, these methods could actually be moved into the protocol itself, which would let us override them. I&#39;m not entirely sure why they aren&#39;t in the protocol to begin with, I guess because there&#39;s not much need for overriding these outside of infinite sequences (well, finite sorted sequences could provide an optimized min/maxElement, and an optimized version of contains(_: Self.Generator.Element), but maybe there&#39;s tradeoffs to doing this, e.g. maybe there&#39;s some reason why having a large protocol witness table is a bad idea).<br>&gt; <br>&gt; I don’t think `contains` or `minElement/maxElement` *can* be part of the protocol (in the sense of overridable) at this time (they require `Element` satisfy certain type constraints), but they certainly should be if the type system someday would support that.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Which illustrates why this is a -1 for me; there&#39;s nothing wrong with the functionality in isolation and there’s nothing wrong with infinite sequences, but the standard library should play well with itself, and this wouldn’t play well with the rest of the standard library.<br>&gt;&gt; <br>&gt;&gt; Ultimately, there&#39;s not much difference between an infinite sequence and a sequence of Int.max elements. The latter is finite, but it&#39;s so massive (especially on 64-bit) that any kind of eager processing is going to hit the same problems as an infinite sequence. Every problem you describe will be a problem with the simple sequence `(0..&lt;Int.max)` as well.<br>&gt;&gt; <br>&gt;&gt; -Kevin Ballard<br>&gt;&gt; <br>&gt;&gt;&gt; That opinion could change as the language changes or the standard library evolves.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 28, 2015, at 1:20 AM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ## Introduction<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Add a new property `cycle` to CollectionType that returns an infinite SequenceType that yields the elements of the collection in a loop.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ## Motivation<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It&#39;s sometimes useful to be able to have an infinite sequence. For example, `CollectionOfOne(x).cycle` could be used to have an infinite sequence of a single element (similar to Repeat but without a count). A common use for infinite sequences is zipping with a finite sequence. As far as I&#39;m aware, the stdlib does not currently provide any way to create such an infinite sequence.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ## Proposed solution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Extend CollectionType with a new property `cycle` that yields a type that conforms to SequenceType. This sequence yields each element of the collection in an infinite loop.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ## Detailed design<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2 new types would be added:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct CycleSequence&lt;Base : CollectionType&gt; : LazySequenceType { ... }<br>&gt;&gt;&gt;&gt; struct CycleGenerator&lt;Base : CollectionType&gt; : GeneratorType { ... }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; CollectionType would be extended with a property:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension CollectionType {<br>&gt;&gt;&gt;&gt;   public var cycle: CycleSequence&lt;Self&gt; { get }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is an extension of CollectionType instead of SequenceType because it requires a multi-pass sequence (and SequenceType does not provide that guarantee). The returned type conforms to SequenceType instead of CollectionType because there is no possible `endIndex` that satisfies the requirement of being reachable from `startIndex` by zero or more applications of `successor()`.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Because the default eager versions of map and filter will execute forever on an infinite sequence, CycleSequence conforms to LazySequenceType instead of SequenceType in order to provide lazy versions of those functions. Additionally, it will provide implementations of the eager versions that simply trigger a fatalError(), as the alternative is an infinite loop that consumes more and more memory.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ## Impact on existing code<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; None<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151229/53289f6b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>Proposal: CollectionType.cycle property for an infinite sequence</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>December 30, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 29, 2015, at 6:38 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 29, 2015, at 3:39 PM, plx via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 29, 2015, at 1:17 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Tue, Dec 29, 2015, at 08:14 AM, plx via swift-evolution wrote:<br>&gt;&gt;&gt;&gt; Personally I’d say this should be a -1 for standard-library inclusion.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Swift’s not really built to handle infinite sequences right now; until they are handed better by the standard library convenience methods for creating them shouldn’t be in the standard library.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As far as I can tell, the only way in which it&#39;s &quot;not really built&quot; to handle this is that there are multiple constructs that attempt to eagerly consume an entire sequence, and using these with an infinite sequence would end up looping forever. But I don&#39;t consider that to be a particularly serious problem. You could &quot;fix&quot; it by refactoring SequenceType into two protocols, SequenceType (for possibly-infinite sequences) and FiniteSequenceType (for known-finite sequences) and then going over the entire standard library and updating various spots to use FiniteSequenceType, except this would be very limiting (sequences that are not known if they&#39;re infinite to the compiler could still be valid for various eager algorithms if the programmer knows it will be finite in practice).<br>&gt;&gt; <br>&gt;&gt; Indeed, on my wishlist I would like to see the standard protocols refactored to something more like this:<br>&gt;&gt; <br>&gt;&gt; SequenceType // can be iterated<br>&gt;&gt; FiniteSequenceType : SequenceType, // of finite length<br>&gt;&gt; StableSequenceType : SequenceType, // can be re-iterated identically<br>&gt;&gt; CollectionType : StableSequenceType, FiniteSequenceType, (etc.) // otherwise as it is now<br>&gt; <br>&gt; This is interesting. A few concerns:<br>&gt; <br>&gt; First, we have tried not to create any distinct protocols with identical syntactic requirements, because we think it makes the world clearer; we think people are more likely to assign incorrect protocols when all the operations they want are available, but don’t have the right semantics.  That isn’t to say we shouldn’t start doing it, but it would be a break from the past.<br>&gt; <br>&gt; Higher protocol granularity has a high comprehensibility cost.  Distinguishing protocols based on semantic requirements alone may make the library harder to understand.  I’ve heard some people’s heads have exploded from simply encountering CollectionType. <br>&gt; <br>&gt; Next, it’s a principle of generic programming that every protocol should be justified by both algorithms that exploit its requirements (e.g. extension methods) and some real-world models that can’t reasonably also conform to a more-refined protocol.  For example, we have a ForwardIndexType because a singly-linked list has multipass forward traversal and can’t do bidirectional traversal.  In order to evaluate any proposal for new protocols, we’d need to see all of these things.<br></p><p>Speaking frankly, I’d say that there are few benefits to a refactoring along the lines sketched above until/unless you want to have solid support for things like a product-sequence or product-collection; you would gain *significant* advantages from such a refactored hierarchy in such scenarios, but I can’t think of any meaningful improvement the refactoring would offer in the essentially-linear case. (Note that this is distinct from examples of concrete models that are naturally e.g. finite-but-not-stable and vice-versa; they exist, but the rest is already long enough as it is).<br></p><p>A full example is beyond my time-budget here, but I can give the flavor of where it makes a difference somewhat quickly.<br></p><p>Consider a hypothetical `ProductSequence2&lt;A:SequenceType,B:SequenceType&gt;` that enumerates the cartesian product of two sequences (in an unspecified order); the naive implementation has problems with non-stable sequences and with infinite-sequences, but I’ll only discuss the infinite case b/c it’s more relevant here.<br></p><p>When either—or both—of the sequences are infinite, the order-of-iteration has actual observable consequences; as a concrete example, if you want this to work out:<br></p><p>	ProductSequence2([1,2].cycle,[1,2].cycle).contains((2,2)) == true<br></p><p>…then we have this:<br></p><p>- if `a` is finite and `b` is not, you want to iterate like (a0,b0), (a1,b0), (a2, b0) … , (a0, b1), (a1, b1), …, etc<br>- if `b` is finite and `a` is not, you want to iterate like (a0,b0), (a0,b1), (a0, b2) … , (a1, b0), (a1, b1), …, etc <br>- if neither `a` nor `b` is finite, you want to iterate like (a0, b0), (a1,b0), (a0,b1), (a2, b0), (a1, b1), (a0, b2), … etc<br></p><p>…as with those orderings you *will* eventually reach each pair in the product (which seems strictly superior to an iteration order which will leave many members of the product forever un-visited).<br></p><p>Importantly, the third ordering is inefficient in the general case, and thus isn’t a suitable default; you’d only want it in places where you’re *intentionally* using infinite series.<br></p><p>This is a concrete example of the sort of thing that leaves me preferring that the standard library *not* contain infinite sequences at this time: such sequences *highly* benefit from special handling, but there’s no good way at this time to generically provide such handling in a general context within the bounds of the current language and standard library .<br></p><p>If there’s a realistic chance of such a refactoring being accepted if sufficiently-well-proposed I can prepare something, but I’m admittedly skeptical given the likely magnitude of the associated changes. In particular, the API on types like `ForwardIndexType` is rather unfortunate for things like a hypothetical product-collection scenario; since such products are among the stronger motivating uses, this means it’s a protocol refactoring + a lot of API changes to the existing standard library, and probably making things clunkier in the common / linear cases.<br></p><p>&gt; <br>&gt;&gt; …but can understand the wish to not overly-complicate the basic protocol hierarchy (and also to avoid baking-in nice-to-have, but impossible-to-really-enforce semantic requirements; I’d trust the standard library to use them properly, but not typical 3rd party code, somewhat defeating the purpose).<br>&gt; <br>&gt; Well, I guess I should have read ahead and most of my lecture above was needless!  I’m posting it anyway because I think it spells out some important principles we’ll need to refer to later.<br>&gt; <br>&gt;&gt; Everything else is a difference of outlook; we agree on the facts and differ in interpretation.<br>&gt;&gt; <br>&gt;&gt; I consider concrete types that adopt a protocol only to simply call `fatalError` for most of the protocol methods to be pathological — often useful, but still pathological — and thus far the standard library doesn’t contain any such pathological types (to my knowledge).<br>&gt;&gt; <br>&gt;&gt; `cycle` is useful but not useful enough to be the standard library’s first “pathological” type, so it’s still a -1 as proposed.<br>&gt;&gt; <br>&gt;&gt; This is nothing specific to `cycle` and my opinion here could change were the language or the standard library to evolve in various ways.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You’d also want to call `fatalError` for at least `reduce`, `reverse`, `sort`, `split`(?), `flatMap`, `dropLast`, `suffix`, and `forEach`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You can only do it for the ones defined in the protocol, not ones defined in extensions. This means map, filter, forEach, and suffix.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; split is actually perfectly implementable for a CycleSequence, although it does need a custom implementation. split is bounded by at most Int.max splits, which means it is guaranteed to terminate even for an infinite sequence (although the final subsequence does need to be infinite[1]). Even if there are no separators in the cycle, it can just return the cycle itself.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; [1] Interestingly, the current implementation actually dumps the remainder into an Array and returns that (wrapped in AnySequence), which is curious because it would be perfectly legal for it to just wrap the generator up in AnySequence and return that instead. I&#39;m tempted to submit a PR to change that now, as it just seems like unnecessary work to use an array.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; `startsWith` and `elementsEqual` and `lexicographicComparison` are all broken if you call them like e.g. `self.startsWith(self)`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That&#39;s true, but what do you really expect when you&#39;re calling them with two infinite sequences? It&#39;s not so much that they&#39;re broken as it is that you&#39;re creating an infinite loop without any way to break out. And FWIW, lexicographicalCompare is actually something you might want to explicitly support on infinite sequences if you know your sequences aren&#39;t equal and want to find out which one is less than the other.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are plenty of ways to shoot yourself in the foot. I don&#39;t think infinite sequences are really the big problem you&#39;re making them out to be.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You can conceivably implement a non-crashing `contains`, `minElement` and `maxElement` on `CycleSequence` by calling through to the wrapped collection, but that’ll seemingly evaporate as soon as your `CycleSequence` winds up hidden inside an `AnySequence`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You can&#39;t override those anyway in a generic context, because they&#39;re not members of the protocol, they&#39;re just extensions. You could implement them such that your implementation is called when working on the concrete CycleSequence type, but I&#39;m not sure if that&#39;s a great idea to do that when the actual behavior differs from calling it generically on SequenceType (well, triggering a fatalError() instead of an infinite loop is fine because they&#39;re both Bottom, but returning a valid result in one context and looping infinitely in the other seems bad).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Of course, these methods could actually be moved into the protocol itself, which would let us override them. I&#39;m not entirely sure why they aren&#39;t in the protocol to begin with, I guess because there&#39;s not much need for overriding these outside of infinite sequences (well, finite sorted sequences could provide an optimized min/maxElement, and an optimized version of contains(_: Self.Generator.Element), but maybe there&#39;s tradeoffs to doing this, e.g. maybe there&#39;s some reason why having a large protocol witness table is a bad idea).<br>&gt;&gt; <br>&gt;&gt; I don’t think `contains` or `minElement/maxElement` *can* be part of the protocol (in the sense of overridable) at this time (they require `Element` satisfy certain type constraints), but they certainly should be if the type system someday would support that.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Which illustrates why this is a -1 for me; there&#39;s nothing wrong with the functionality in isolation and there’s nothing wrong with infinite sequences, but the standard library should play well with itself, and this wouldn’t play well with the rest of the standard library.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Ultimately, there&#39;s not much difference between an infinite sequence and a sequence of Int.max elements. The latter is finite, but it&#39;s so massive (especially on 64-bit) that any kind of eager processing is going to hit the same problems as an infinite sequence. Every problem you describe will be a problem with the simple sequence `(0..&lt;Int.max)` as well.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That opinion could change as the language changes or the standard library evolves.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 28, 2015, at 1:20 AM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ## Introduction<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Add a new property `cycle` to CollectionType that returns an infinite SequenceType that yields the elements of the collection in a loop.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ## Motivation<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It&#39;s sometimes useful to be able to have an infinite sequence. For example, `CollectionOfOne(x).cycle` could be used to have an infinite sequence of a single element (similar to Repeat but without a count). A common use for infinite sequences is zipping with a finite sequence. As far as I&#39;m aware, the stdlib does not currently provide any way to create such an infinite sequence.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ## Proposed solution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Extend CollectionType with a new property `cycle` that yields a type that conforms to SequenceType. This sequence yields each element of the collection in an infinite loop.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ## Detailed design<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2 new types would be added:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; struct CycleSequence&lt;Base : CollectionType&gt; : LazySequenceType { ... }<br>&gt;&gt;&gt;&gt;&gt; struct CycleGenerator&lt;Base : CollectionType&gt; : GeneratorType { ... }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; CollectionType would be extended with a property:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; extension CollectionType {<br>&gt;&gt;&gt;&gt;&gt;   public var cycle: CycleSequence&lt;Self&gt; { get }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This is an extension of CollectionType instead of SequenceType because it requires a multi-pass sequence (and SequenceType does not provide that guarantee). The returned type conforms to SequenceType instead of CollectionType because there is no possible `endIndex` that satisfies the requirement of being reachable from `startIndex` by zero or more applications of `successor()`.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Because the default eager versions of map and filter will execute forever on an infinite sequence, CycleSequence conforms to LazySequenceType instead of SequenceType in order to provide lazy versions of those functions. Additionally, it will provide implementations of the eager versions that simply trigger a fatalError(), as the alternative is an infinite loop that consumes more and more memory.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ## Impact on existing code<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; None<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/80dcf99e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: CollectionType.cycle property for an infinite sequence</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 30, 2015 at 01:00:00pm</p></header><div class="content"><p>Refactoring like that can always be done later; introducing infinite<br>sequences now shouldn&#39;t make it any harder to refactor the protocols. If<br>anything, it will provide more practical experience with how infinite<br>sequences interact with the current protocol hierarchy that would help<br>guide the design of any refactoring (or, perhaps more importantly, help<br>determine if such a refactoring is worthwhile).<br></p><p>A big concern I have with refactoring like that is you&#39;d rarely ever be<br>able to actually bound an algorithm on FiniteSequenceType, because there<br>will always be ways of constructing sequences that the compiler can&#39;t<br>tell if it&#39;s infinite. Trivial example is `ary.cycle.takeWhile(pred)`.<br>This is infinite if `pred(elt)` is true for every element of `ary` and<br>finite otherwise. But there&#39;s tons of other ways of creating such<br>indeterminate sequences. Bounding algorithms (such as `map(..) -&gt; [T]`<br>or `reduce()`) on finite sequences only would be rather limiting, as<br>users who know their sequence must be finite but can&#39;t prove it to the<br>compiler would be unable to use methods that are in fact perfectly safe.<br></p><p>What you could do with such a refactoring is optimize certain algorithms<br>if they use a more precise sequence type, but I&#39;m not actually sure what<br>sort of optimizations you can make with your proposed protocol<br>hierarchy. In fact, the only real optimizations that come to mind are<br>optimizing when you know you&#39;re working with a CycleSequence, because<br>for various algorithms you really only have to iterate the underlying<br>elements once (e.g. assuming a pure predicate, CycleSequence can<br>implement contains() safely, although we don&#39;t actually have pure in the<br>language right now so that&#39;s not necessarily a safe assumption; also,<br>contains() isn&#39;t a protocol method, just an extension method, so we<br>can&#39;t actually do that anyway).<br></p><p>On that note, core language team, anyone know offhand why SequenceType<br>has a bunch of extension methods that aren&#39;t part of the protocol? For<br>example, contains(_ predicate:). The only real reason I can think of is<br>to shrink the protocol witness table, but surely that&#39;s not particularly<br>meaningful. I warrant that contains(_ predicate:) doesn&#39;t really have<br>any reason to be overridden by anything except sequences that knowingly<br>repeat elements (e.g. CycleSequence and Repeat), and even that&#39;s only if<br>you assume the predicate is pure, but there&#39;s some other methods that<br>make sense to override on some sequences (like minElement(_<br>isOrderedBefore:) for any sequence that has a defined ordering).<br></p><p>-Kevin Ballard<br></p><p>On Wed, Dec 30, 2015, at 11:01 AM, plx via swift-evolution wrote:<br>&gt;<br>&gt;&gt; On Dec 29, 2015, at 6:38 PM, Dave Abrahams<br>&gt;&gt; &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; On Dec 29, 2015, at 3:39 PM, plx via swift-evolution &lt;swift-<br>&gt;&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Dec 29, 2015, at 1:17 PM, Kevin Ballard via swift-evolution &lt;swift-<br>&gt;&gt;&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Tue, Dec 29, 2015, at 08:14 AM, plx via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt; Personally I’d say this should be a -1 for standard-library<br>&gt;&gt;&gt;&gt;&gt; inclusion.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Swift’s not really built to handle infinite sequences right now;<br>&gt;&gt;&gt;&gt;&gt; until they are handed better by the standard library convenience<br>&gt;&gt;&gt;&gt;&gt; methods for creating them shouldn’t be in the standard library.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; As far as I can tell, the only way in which it&#39;s &quot;not really built&quot;<br>&gt;&gt;&gt;&gt; to handle this is that there are multiple constructs that attempt<br>&gt;&gt;&gt;&gt; to eagerly consume an entire sequence, and using these with an<br>&gt;&gt;&gt;&gt; infinite sequence would end up looping forever. But I don&#39;t<br>&gt;&gt;&gt;&gt; consider that to be a particularly serious problem. You could &quot;fix&quot;<br>&gt;&gt;&gt;&gt; it by refactoring SequenceType into two protocols, SequenceType<br>&gt;&gt;&gt;&gt; (for possibly-infinite sequences) and FiniteSequenceType (for known-<br>&gt;&gt;&gt;&gt; finite sequences) and then going over the entire standard library<br>&gt;&gt;&gt;&gt; and updating various spots to use FiniteSequenceType, except this<br>&gt;&gt;&gt;&gt; would be very limiting (sequences that are not known if they&#39;re<br>&gt;&gt;&gt;&gt; infinite to the compiler could still be valid for various eager<br>&gt;&gt;&gt;&gt; algorithms if the programmer knows it will be finite in practice).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Indeed, on my wishlist I would like to see the standard protocols<br>&gt;&gt;&gt; refactored to something more like this:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; SequenceType // can be iterated FiniteSequenceType : SequenceType,<br>&gt;&gt;&gt; // of finite length StableSequenceType : SequenceType, // can be re-<br>&gt;&gt;&gt; iterated identically CollectionType : StableSequenceType,<br>&gt;&gt;&gt; FiniteSequenceType, (etc.) // otherwise as it is now<br>&gt;&gt;<br>&gt;&gt; This is interesting. A few concerns:<br>&gt;&gt;<br>&gt;&gt; First, we have tried not to create any distinct protocols with<br>&gt;&gt; identical syntactic requirements, because we think it makes the world<br>&gt;&gt; clearer; we think people are more likely to assign incorrect<br>&gt;&gt; protocols when all the operations they want are available, but don’t<br>&gt;&gt; have the right semantics.  That isn’t to say we shouldn’t start doing<br>&gt;&gt; it, but it would be a break from the past.<br>&gt;&gt;<br>&gt;&gt; Higher protocol granularity has a high comprehensibility cost.<br>&gt;&gt; Distinguishing protocols based on semantic requirements alone may<br>&gt;&gt; make the library harder to understand.  I’ve heard some people’s<br>&gt;&gt; heads have exploded from simply encountering CollectionType.<br>&gt;&gt;<br>&gt;&gt; Next, it’s a principle of generic programming that every protocol<br>&gt;&gt; should be justified by both algorithms that exploit its requirements<br>&gt;&gt; (e.g. extension methods) and some real-world models that can’t<br>&gt;&gt; reasonably also conform to a more-refined protocol.  For example, we<br>&gt;&gt; have a ForwardIndexType because a singly-linked list has multipass<br>&gt;&gt; forward traversal and can’t do bidirectional traversal.  In order to<br>&gt;&gt; evaluate any proposal for new protocols, we’d need to see all of<br>&gt;&gt; these things.<br>&gt;<br>&gt; Speaking frankly, I’d say that there are few benefits to a refactoring<br>&gt; along the lines sketched above until/unless you want to have solid<br>&gt; support for things like a product-sequence or product-collection; you<br>&gt; would gain *significant* advantages from such a refactored hierarchy<br>&gt; in such scenarios, but I can’t think of any meaningful improvement the<br>&gt; refactoring would offer in the essentially-linear case. (Note that<br>&gt; this is distinct from examples of concrete models that are naturally<br>&gt; e.g. finite-but-not-stable and vice-versa; they exist, but the rest is<br>&gt; already long enough as it is).<br>&gt;<br>&gt; A full example is beyond my time-budget here, but I can give the<br>&gt; flavor of where it makes a difference somewhat quickly.<br>&gt;<br>&gt; Consider a hypothetical<br>&gt; `ProductSequence2&lt;A:SequenceType,B:SequenceType&gt;` that enumerates the<br>&gt; cartesian product of two sequences (in an unspecified order); the<br>&gt; naive implementation has problems with non-stable sequences and with<br>&gt; infinite-sequences, but I’ll only discuss the infinite case b/c it’s<br>&gt; more relevant here.<br>&gt;<br>&gt; When either—or both—of the sequences are infinite, the order-of-<br>&gt; iteration has actual observable consequences; as a concrete example,<br>&gt; if you want this to work out:<br>&gt;<br>&gt; ProductSequence2([1,2].cycle,[1,2].cycle).contains((2,2)) == true<br>&gt;<br>&gt; …then we have this:<br>&gt;<br>&gt; - if `a` is finite and `b` is not, you want to iterate like (a0,b0),<br>&gt;   (a1,b0), (a2, b0) … , (a0, b1), (a1, b1), …, etc<br>&gt; - if `b` is finite and `a` is not, you want to iterate like (a0,b0),<br>&gt;   (a0,b1), (a0, b2) … , (a1, b0), (a1, b1), …, etc<br>&gt; - if neither `a` nor `b` is finite, you want to iterate like (a0, b0),<br>&gt;   (a1,b0), (a0,b1), (a2, b0), (a1, b1), (a0, b2), … etc<br>&gt;<br>&gt; …as with those orderings you *will* eventually reach each pair in the<br>&gt; product (which seems strictly superior to an iteration order which<br>&gt; will leave many members of the product forever un-visited).<br>&gt;<br>&gt; Importantly, the third ordering is inefficient in the general case,<br>&gt; and thus isn’t a suitable default; you’d only want it in places where<br>&gt; you’re *intentionally* using infinite series.<br>&gt;<br>&gt; This is a concrete example of the sort of thing that leaves me<br>&gt; preferring that the standard library *not* contain infinite sequences<br>&gt; at this time: such sequences *highly* benefit from special handling,<br>&gt; but there’s no good way at this time to generically provide such<br>&gt; handling in a general context within the bounds of the current<br>&gt; language and standard library .<br>&gt;<br>&gt; If there’s a realistic chance of such a refactoring being accepted if<br>&gt; sufficiently-well-proposed I can prepare something, but I’m admittedly<br>&gt; skeptical given the likely magnitude of the associated changes. In<br>&gt; particular, the API on types like `ForwardIndexType` is rather<br>&gt; unfortunate for things like a hypothetical product-collection<br>&gt; scenario; since such products are among the stronger motivating uses,<br>&gt; this means it’s a protocol refactoring + a lot of API changes to the<br>&gt; existing standard library, and probably making things clunkier in the<br>&gt; common / linear cases.<br>&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; …but can understand the wish to not overly-complicate the basic<br>&gt;&gt;&gt; protocol hierarchy (and also to avoid baking-in nice-to-have, but<br>&gt;&gt;&gt; impossible-to-really-enforce semantic requirements; I’d trust the<br>&gt;&gt;&gt; standard library to use them properly, but not typical 3rd party<br>&gt;&gt;&gt; code, somewhat defeating the purpose).<br>&gt;&gt;<br>&gt;&gt; Well, I guess I should have read ahead and most of my lecture above<br>&gt;&gt; was needless!  I’m posting it anyway because I think it spells out<br>&gt;&gt; some important principles we’ll need to refer to later.<br>&gt;&gt;<br>&gt;&gt;&gt; Everything else is a difference of outlook; we agree on the facts<br>&gt;&gt;&gt; and differ in interpretation.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I consider concrete types that adopt a protocol only to simply call<br>&gt;&gt;&gt; `fatalError` for most of the protocol methods to be pathological —<br>&gt;&gt;&gt; often useful, but still pathological — and thus far the standard<br>&gt;&gt;&gt; library doesn’t contain any such pathological types (to my<br>&gt;&gt;&gt; knowledge).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; `cycle` is useful but not useful enough to be the standard library’s<br>&gt;&gt;&gt; first “pathological” type, so it’s still a -1 as proposed.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This is nothing specific to `cycle` and my opinion here could change<br>&gt;&gt;&gt; were the language or the standard library to evolve in various ways.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; You’d also want to call `fatalError` for at least `reduce`,<br>&gt;&gt;&gt;&gt;&gt; `reverse`, `sort`, `split`(?), `flatMap`, `dropLast`, `suffix`,<br>&gt;&gt;&gt;&gt;&gt; and `forEach`.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; You can only do it for the ones defined in the protocol, not ones<br>&gt;&gt;&gt;&gt; defined in extensions. This means map, filter, forEach, and suffix.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; split is actually perfectly implementable for a CycleSequence,<br>&gt;&gt;&gt;&gt; although it does need a custom implementation. split is bounded by<br>&gt;&gt;&gt;&gt; at most Int.max splits, which means it is guaranteed to terminate<br>&gt;&gt;&gt;&gt; even for an infinite sequence (although the final subsequence does<br>&gt;&gt;&gt;&gt; need to be infinite[1]). Even if there are no separators in the<br>&gt;&gt;&gt;&gt; cycle, it can just return the cycle itself.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; [1] Interestingly, the current implementation actually dumps the<br>&gt;&gt;&gt;&gt;     remainder into an Array and returns that (wrapped in<br>&gt;&gt;&gt;&gt;     AnySequence), which is curious because it would be perfectly<br>&gt;&gt;&gt;&gt;     legal for it to just wrap the generator up in AnySequence and<br>&gt;&gt;&gt;&gt;     return that instead. I&#39;m tempted to submit a PR to change that<br>&gt;&gt;&gt;&gt;     now, as it just seems like unnecessary work to use an array.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; `startsWith` and `elementsEqual` and `lexicographicComparison` are<br>&gt;&gt;&gt;&gt;&gt; all broken if you call them like e.g. `self.startsWith(self)`.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; That&#39;s true, but what do you really expect when you&#39;re calling them<br>&gt;&gt;&gt;&gt; with two infinite sequences? It&#39;s not so much that they&#39;re broken<br>&gt;&gt;&gt;&gt; as it is that you&#39;re creating an infinite loop without any way to<br>&gt;&gt;&gt;&gt; break out. And FWIW, lexicographicalCompare is actually something<br>&gt;&gt;&gt;&gt; you might want to explicitly support on infinite sequences if you<br>&gt;&gt;&gt;&gt; know your sequences aren&#39;t equal and want to find out which one is<br>&gt;&gt;&gt;&gt; less than the other.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; There are plenty of ways to shoot yourself in the foot. I don&#39;t<br>&gt;&gt;&gt;&gt; think infinite sequences are really the big problem you&#39;re making<br>&gt;&gt;&gt;&gt; them out to be.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; You can conceivably implement a non-crashing `contains`,<br>&gt;&gt;&gt;&gt;&gt; `minElement` and `maxElement` on `CycleSequence` by calling<br>&gt;&gt;&gt;&gt;&gt; through to the wrapped collection, but that’ll seemingly evaporate<br>&gt;&gt;&gt;&gt;&gt; as soon as your `CycleSequence` winds up hidden inside an<br>&gt;&gt;&gt;&gt;&gt; `AnySequence`.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; You can&#39;t override those anyway in a generic context, because<br>&gt;&gt;&gt;&gt; they&#39;re not members of the protocol, they&#39;re just extensions. You<br>&gt;&gt;&gt;&gt; could implement them such that your implementation is called when<br>&gt;&gt;&gt;&gt; working on the concrete CycleSequence type, but I&#39;m not sure if<br>&gt;&gt;&gt;&gt; that&#39;s a great idea to do that when the actual behavior differs<br>&gt;&gt;&gt;&gt; from calling it generically on SequenceType (well, triggering a<br>&gt;&gt;&gt;&gt; fatalError() instead of an infinite loop is fine because they&#39;re<br>&gt;&gt;&gt;&gt; both Bottom, but returning a valid result in one context and<br>&gt;&gt;&gt;&gt; looping infinitely in the other seems bad).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Of course, these methods could actually be moved into the protocol<br>&gt;&gt;&gt;&gt; itself, which would let us override them. I&#39;m not entirely sure why<br>&gt;&gt;&gt;&gt; they aren&#39;t in the protocol to begin with, I guess because there&#39;s<br>&gt;&gt;&gt;&gt; not much need for overriding these outside of infinite sequences<br>&gt;&gt;&gt;&gt; (well, finite sorted sequences could provide an optimized<br>&gt;&gt;&gt;&gt; min/maxElement, and an optimized version of contains(_:<br>&gt;&gt;&gt;&gt; Self.Generator.Element), but maybe there&#39;s tradeoffs to doing this,<br>&gt;&gt;&gt;&gt; e.g. maybe there&#39;s some reason why having a large protocol witness<br>&gt;&gt;&gt;&gt; table is a bad idea).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I don’t think `contains` or `minElement/maxElement` *can* be part of<br>&gt;&gt;&gt; the protocol (in the sense of overridable) at this time (they<br>&gt;&gt;&gt; require `Element` satisfy certain type constraints), but they<br>&gt;&gt;&gt; certainly should be if the type system someday would support that.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Which illustrates why this is a -1 for me; there&#39;s nothing wrong<br>&gt;&gt;&gt;&gt;&gt; with the functionality in isolation and there’s nothing wrong with<br>&gt;&gt;&gt;&gt;&gt; infinite sequences, but the standard library should play well with<br>&gt;&gt;&gt;&gt;&gt; itself, and this wouldn’t play well with the rest of the standard<br>&gt;&gt;&gt;&gt;&gt; library.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Ultimately, there&#39;s not much difference between an infinite<br>&gt;&gt;&gt;&gt; sequence and a sequence of Int.max elements. The latter is finite,<br>&gt;&gt;&gt;&gt; but it&#39;s so massive (especially on 64-bit) that any kind of eager<br>&gt;&gt;&gt;&gt; processing is going to hit the same problems as an infinite<br>&gt;&gt;&gt;&gt; sequence. Every problem you describe will be a problem with the<br>&gt;&gt;&gt;&gt; simple sequence `(0..&lt;Int.max)` as well.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; That opinion could change as the language changes or the standard<br>&gt;&gt;&gt;&gt;&gt; library evolves.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 28, 2015, at 1:20 AM, Kevin Ballard via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; ## Introduction<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Add a new property `cycle` to CollectionType that returns an<br>&gt;&gt;&gt;&gt;&gt;&gt; infinite SequenceType that yields the elements of the collection<br>&gt;&gt;&gt;&gt;&gt;&gt; in a loop.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; ## Motivation<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; It&#39;s sometimes useful to be able to have an infinite sequence.<br>&gt;&gt;&gt;&gt;&gt;&gt; For example, `CollectionOfOne(x).cycle` could be used to have an<br>&gt;&gt;&gt;&gt;&gt;&gt; infinite sequence of a single element (similar to Repeat but<br>&gt;&gt;&gt;&gt;&gt;&gt; without a count). A common use for infinite sequences is zipping<br>&gt;&gt;&gt;&gt;&gt;&gt; with a finite sequence. As far as I&#39;m aware, the stdlib does not<br>&gt;&gt;&gt;&gt;&gt;&gt; currently provide any way to create such an infinite sequence.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; ## Proposed solution<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Extend CollectionType with a new property `cycle` that yields a<br>&gt;&gt;&gt;&gt;&gt;&gt; type that conforms to SequenceType. This sequence yields each<br>&gt;&gt;&gt;&gt;&gt;&gt; element of the collection in an infinite loop.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; ## Detailed design<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; 2 new types would be added:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; struct CycleSequence&lt;Base : CollectionType&gt; : LazySequenceType {<br>&gt;&gt;&gt;&gt;&gt;&gt; ... } struct CycleGenerator&lt;Base : CollectionType&gt; :<br>&gt;&gt;&gt;&gt;&gt;&gt; GeneratorType { ... }<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; CollectionType would be extended with a property:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; extension CollectionType {  public var cycle: CycleSequence&lt;Self&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; { get } }<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; This is an extension of CollectionType instead of SequenceType<br>&gt;&gt;&gt;&gt;&gt;&gt; because it requires a multi-pass sequence (and SequenceType does<br>&gt;&gt;&gt;&gt;&gt;&gt; not provide that guarantee). The returned type conforms to<br>&gt;&gt;&gt;&gt;&gt;&gt; SequenceType instead of CollectionType because there is no<br>&gt;&gt;&gt;&gt;&gt;&gt; possible `endIndex` that satisfies the requirement of being<br>&gt;&gt;&gt;&gt;&gt;&gt; reachable from `startIndex` by zero or more applications of<br>&gt;&gt;&gt;&gt;&gt;&gt; `successor()`.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Because the default eager versions of map and filter will execute<br>&gt;&gt;&gt;&gt;&gt;&gt; forever on an infinite sequence, CycleSequence conforms to<br>&gt;&gt;&gt;&gt;&gt;&gt; LazySequenceType instead of SequenceType in order to provide lazy<br>&gt;&gt;&gt;&gt;&gt;&gt; versions of those functions. Additionally, it will provide<br>&gt;&gt;&gt;&gt;&gt;&gt; implementations of the eager versions that simply trigger a<br>&gt;&gt;&gt;&gt;&gt;&gt; fatalError(), as the alternative is an infinite loop that<br>&gt;&gt;&gt;&gt;&gt;&gt; consumes more and more memory.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; ## Impact on existing code<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; None<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/781c8465/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>Proposal: CollectionType.cycle property for an infinite sequence</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>December 30, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; On Dec 30, 2015, at 3:39 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Refactoring like that can always be done later; introducing infinite sequences now shouldn&#39;t make it any harder to refactor the protocols. If anything, it will provide more practical experience with how infinite sequences interact with the current protocol hierarchy that would help guide the design of any refactoring (or, perhaps more importantly, help determine if such a refactoring is worthwhile).<br>&gt;  <br>&gt; A big concern I have with refactoring like that is you&#39;d rarely ever be able to actually bound an algorithm on FiniteSequenceType, because there will always be ways of constructing sequences that the compiler can&#39;t tell if it&#39;s infinite. Trivial example is `ary.cycle.takeWhile(pred)`. This is infinite if `pred(elt)` is true for every element of `ary` and finite otherwise. But there&#39;s tons of other ways of creating such indeterminate sequences. Bounding algorithms (such as `map(..) -&gt; [T]` or `reduce()`) on finite sequences only would be rather limiting, as users who know their sequence must be finite but can&#39;t prove it to the compiler would be unable to use methods that are in fact perfectly safe.<br></p><p>If you will accept that I would prefer the standard library types to interpret the standard library protocols as having already made such a binding — as, indeed, the type signatures necessarily imply — the rest of my objection should be comprehensible.<br></p><p>I don’t find the repeated points about what can happen due to user error to be interesting.<br></p><p>&gt; <br>&gt; What you could do with such a refactoring is optimize certain algorithms if they use a more precise sequence type, but I&#39;m not actually sure what sort of optimizations you can make with your proposed protocol hierarchy. In fact, the only real optimizations that come to mind are optimizing when you know you&#39;re working with a CycleSequence, because for various algorithms you really only have to iterate the underlying elements once (e.g. assuming a pure predicate, CycleSequence can implement contains() safely, although we don&#39;t actually have pure in the language right now so that&#39;s not necessarily a safe assumption; also, contains() isn&#39;t a protocol method, just an extension method, so we can&#39;t actually do that anyway).<br></p><p>I already gave the example of a product sequence. There’s a simple implementation that is correct when both input sequences are finite-and-stable, but not necessarily if otherwise; the proposed refactoring would statically provides enough information to allow one to choose the minimally-*pessimal* implementation that is still correct for such inputs. <br></p><p>How much correctness matters is, of course, essentially subjective.<br></p><p>&gt;  <br>&gt; On that note, core language team, anyone know offhand why SequenceType has a bunch of extension methods that aren&#39;t part of the protocol? For example, contains(_ predicate:). The only real reason I can think of is to shrink the protocol witness table, but surely that&#39;s not particularly meaningful. I warrant that contains(_ predicate:) doesn&#39;t really have any reason to be overridden by anything except sequences that knowingly repeat elements (e.g. CycleSequence and Repeat), and even that&#39;s only if you assume the predicate is pure, but there&#39;s some other methods that make sense to override on some sequences (like minElement(_ isOrderedBefore:) for any sequence that has a defined ordering).<br></p><p>I am not sure how, precisely, you would propose to override the closure-taking variant of `minElement` to take advantage of an intrinsic ordering, but I’d be curious to see it.<br></p><p>I’d hope that the non-closure-accepting variants would be made overridable once the type system supports it.<br></p><p>&gt;  <br>&gt; -Kevin Ballard<br>&gt;  <br>&gt; On Wed, Dec 30, 2015, at 11:01 AM, plx via swift-evolution wrote:<br>&gt;&gt;  <br>&gt;&gt;&gt; On Dec 29, 2015, at 6:38 PM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; On Dec 29, 2015, at 3:39 PM, plx via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; On Dec 29, 2015, at 1:17 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; On Tue, Dec 29, 2015, at 08:14 AM, plx via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; Personally I’d say this should be a -1 for standard-library inclusion.<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; Swift’s not really built to handle infinite sequences right now; until they are handed better by the standard library convenience methods for creating them shouldn’t be in the standard library.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; As far as I can tell, the only way in which it&#39;s &quot;not really built&quot; to handle this is that there are multiple constructs that attempt to eagerly consume an entire sequence, and using these with an infinite sequence would end up looping forever. But I don&#39;t consider that to be a particularly serious problem. You could &quot;fix&quot; it by refactoring SequenceType into two protocols, SequenceType (for possibly-infinite sequences) and FiniteSequenceType (for known-finite sequences) and then going over the entire standard library and updating various spots to use FiniteSequenceType, except this would be very limiting (sequences that are not known if they&#39;re infinite to the compiler could still be valid for various eager algorithms if the programmer knows it will be finite in practice).<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Indeed, on my wishlist I would like to see the standard protocols refactored to something more like this:<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; SequenceType // can be iterated<br>&gt;&gt;&gt;&gt; FiniteSequenceType : SequenceType, // of finite length<br>&gt;&gt;&gt;&gt; StableSequenceType : SequenceType, // can be re-iterated identically<br>&gt;&gt;&gt;&gt; CollectionType : StableSequenceType, FiniteSequenceType, (etc.) // otherwise as it is now<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; This is interesting. A few concerns:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; First, we have tried not to create any distinct protocols with identical syntactic requirements, because we think it makes the world clearer; we think people are more likely to assign incorrect protocols when all the operations they want are available, but don’t have the right semantics.  That isn’t to say we shouldn’t start doing it, but it would be a break from the past.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Higher protocol granularity has a high comprehensibility cost.  Distinguishing protocols based on semantic requirements alone may make the library harder to understand.  I’ve heard some people’s heads have exploded from simply encountering CollectionType. <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Next, it’s a principle of generic programming that every protocol should be justified by both algorithms that exploit its requirements (e.g. extension methods) and some real-world models that can’t reasonably also conform to a more-refined protocol.  For example, we have a ForwardIndexType because a singly-linked list has multipass forward traversal and can’t do bidirectional traversal.  In order to evaluate any proposal for new protocols, we’d need to see all of these things.<br>&gt;&gt;  <br>&gt;&gt; Speaking frankly, I’d say that there are few benefits to a refactoring along the lines sketched above until/unless you want to have solid support for things like a product-sequence or product-collection; you would gain *significant* advantages from such a refactored hierarchy in such scenarios, but I can’t think of any meaningful improvement the refactoring would offer in the essentially-linear case. (Note that this is distinct from examples of concrete models that are naturally e.g. finite-but-not-stable and vice-versa; they exist, but the rest is already long enough as it is).<br>&gt;&gt;  <br>&gt;&gt; A full example is beyond my time-budget here, but I can give the flavor of where it makes a difference somewhat quickly.<br>&gt;&gt;  <br>&gt;&gt; Consider a hypothetical `ProductSequence2&lt;A:SequenceType,B:SequenceType&gt;` that enumerates the cartesian product of two sequences (in an unspecified order); the naive implementation has problems with non-stable sequences and with infinite-sequences, but I’ll only discuss the infinite case b/c it’s more relevant here.<br>&gt;&gt;  <br>&gt;&gt; When either—or both—of the sequences are infinite, the order-of-iteration has actual observable consequences; as a concrete example, if you want this to work out:<br>&gt;&gt;  <br>&gt;&gt; ProductSequence2([1,2].cycle,[1,2].cycle).contains((2,2)) == true<br>&gt;&gt;  <br>&gt;&gt; …then we have this:<br>&gt;&gt;  <br>&gt;&gt; - if `a` is finite and `b` is not, you want to iterate like (a0,b0), (a1,b0), (a2, b0) … , (a0, b1), (a1, b1), …, etc<br>&gt;&gt; - if `b` is finite and `a` is not, you want to iterate like (a0,b0), (a0,b1), (a0, b2) … , (a1, b0), (a1, b1), …, etc <br>&gt;&gt; - if neither `a` nor `b` is finite, you want to iterate like (a0, b0), (a1,b0), (a0,b1), (a2, b0), (a1, b1), (a0, b2), … etc<br>&gt;&gt;  <br>&gt;&gt; …as with those orderings you *will* eventually reach each pair in the product (which seems strictly superior to an iteration order which will leave many members of the product forever un-visited).<br>&gt;&gt;  <br>&gt;&gt; Importantly, the third ordering is inefficient in the general case, and thus isn’t a suitable default; you’d only want it in places where you’re *intentionally* using infinite series.<br>&gt;&gt;  <br>&gt;&gt; This is a concrete example of the sort of thing that leaves me preferring that the standard library *not* contain infinite sequences at this time: such sequences *highly* benefit from special handling, but there’s no good way at this time to generically provide such handling in a general context within the bounds of the current language and standard library .<br>&gt;&gt;  <br>&gt;&gt; If there’s a realistic chance of such a refactoring being accepted if sufficiently-well-proposed I can prepare something, but I’m admittedly skeptical given the likely magnitude of the associated changes. In particular, the API on types like `ForwardIndexType` is rather unfortunate for things like a hypothetical product-collection scenario; since such products are among the stronger motivating uses, this means it’s a protocol refactoring + a lot of API changes to the existing standard library, and probably making things clunkier in the common / linear cases.<br>&gt;&gt;  <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; …but can understand the wish to not overly-complicate the basic protocol hierarchy (and also to avoid baking-in nice-to-have, but impossible-to-really-enforce semantic requirements; I’d trust the standard library to use them properly, but not typical 3rd party code, somewhat defeating the purpose).<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Well, I guess I should have read ahead and most of my lecture above was needless!  I’m posting it anyway because I think it spells out some important principles we’ll need to refer to later.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Everything else is a difference of outlook; we agree on the facts and differ in interpretation.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; I consider concrete types that adopt a protocol only to simply call `fatalError` for most of the protocol methods to be pathological — often useful, but still pathological — and thus far the standard library doesn’t contain any such pathological types (to my knowledge).<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; `cycle` is useful but not useful enough to be the standard library’s first “pathological” type, so it’s still a -1 as proposed.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; This is nothing specific to `cycle` and my opinion here could change were the language or the standard library to evolve in various ways.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; You’d also want to call `fatalError` for at least `reduce`, `reverse`, `sort`, `split`(?), `flatMap`, `dropLast`, `suffix`, and `forEach`.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; You can only do it for the ones defined in the protocol, not ones defined in extensions. This means map, filter, forEach, and suffix.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; split is actually perfectly implementable for a CycleSequence, although it does need a custom implementation. split is bounded by at most Int.max splits, which means it is guaranteed to terminate even for an infinite sequence (although the final subsequence does need to be infinite[1]). Even if there are no separators in the cycle, it can just return the cycle itself.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; [1] Interestingly, the current implementation actually dumps the remainder into an Array and returns that (wrapped in AnySequence), which is curious because it would be perfectly legal for it to just wrap the generator up in AnySequence and return that instead. I&#39;m tempted to submit a PR to change that now, as it just seems like unnecessary work to use an array.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; `startsWith` and `elementsEqual` and `lexicographicComparison` are all broken if you call them like e.g. `self.startsWith(self)`.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; That&#39;s true, but what do you really expect when you&#39;re calling them with two infinite sequences? It&#39;s not so much that they&#39;re broken as it is that you&#39;re creating an infinite loop without any way to break out. And FWIW, lexicographicalCompare is actually something you might want to explicitly support on infinite sequences if you know your sequences aren&#39;t equal and want to find out which one is less than the other.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; There are plenty of ways to shoot yourself in the foot. I don&#39;t think infinite sequences are really the big problem you&#39;re making them out to be.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; You can conceivably implement a non-crashing `contains`, `minElement` and `maxElement` on `CycleSequence` by calling through to the wrapped collection, but that’ll seemingly evaporate as soon as your `CycleSequence` winds up hidden inside an `AnySequence`.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; You can&#39;t override those anyway in a generic context, because they&#39;re not members of the protocol, they&#39;re just extensions. You could implement them such that your implementation is called when working on the concrete CycleSequence type, but I&#39;m not sure if that&#39;s a great idea to do that when the actual behavior differs from calling it generically on SequenceType (well, triggering a fatalError() instead of an infinite loop is fine because they&#39;re both Bottom, but returning a valid result in one context and looping infinitely in the other seems bad).<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; Of course, these methods could actually be moved into the protocol itself, which would let us override them. I&#39;m not entirely sure why they aren&#39;t in the protocol to begin with, I guess because there&#39;s not much need for overriding these outside of infinite sequences (well, finite sorted sequences could provide an optimized min/maxElement, and an optimized version of contains(_: Self.Generator.Element), but maybe there&#39;s tradeoffs to doing this, e.g. maybe there&#39;s some reason why having a large protocol witness table is a bad idea).<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; I don’t think `contains` or `minElement/maxElement` *can* be part of the protocol (in the sense of overridable) at this time (they require `Element` satisfy certain type constraints), but they certainly should be if the type system someday would support that.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; Which illustrates why this is a -1 for me; there&#39;s nothing wrong with the functionality in isolation and there’s nothing wrong with infinite sequences, but the standard library should play well with itself, and this wouldn’t play well with the rest of the standard library.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; Ultimately, there&#39;s not much difference between an infinite sequence and a sequence of Int.max elements. The latter is finite, but it&#39;s so massive (especially on 64-bit) that any kind of eager processing is going to hit the same problems as an infinite sequence. Every problem you describe will be a problem with the simple sequence `(0..&lt;Int.max)` as well.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; That opinion could change as the language changes or the standard library evolves.<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 28, 2015, at 1:20 AM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ## Introduction<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Add a new property `cycle` to CollectionType that returns an infinite SequenceType that yields the elements of the collection in a loop.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ## Motivation<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; It&#39;s sometimes useful to be able to have an infinite sequence. For example, `CollectionOfOne(x).cycle` could be used to have an infinite sequence of a single element (similar to Repeat but without a count). A common use for infinite sequences is zipping with a finite sequence. As far as I&#39;m aware, the stdlib does not currently provide any way to create such an infinite sequence.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ## Proposed solution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Extend CollectionType with a new property `cycle` that yields a type that conforms to SequenceType. This sequence yields each element of the collection in an infinite loop.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ## Detailed design<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2 new types would be added:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; struct CycleSequence&lt;Base : CollectionType&gt; : LazySequenceType { ... }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; struct CycleGenerator&lt;Base : CollectionType&gt; : GeneratorType { ... }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; CollectionType would be extended with a property:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; extension CollectionType {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   public var cycle: CycleSequence&lt;Self&gt; { get }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This is an extension of CollectionType instead of SequenceType because it requires a multi-pass sequence (and SequenceType does not provide that guarantee). The returned type conforms to SequenceType instead of CollectionType because there is no possible `endIndex` that satisfies the requirement of being reachable from `startIndex` by zero or more applications of `successor()`.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Because the default eager versions of map and filter will execute forever on an infinite sequence, CycleSequence conforms to LazySequenceType instead of SequenceType in order to provide lazy versions of those functions. Additionally, it will provide implementations of the eager versions that simply trigger a fatalError(), as the alternative is an infinite loop that consumes more and more memory.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ## Impact on existing code<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; None<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/a7381cbf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: CollectionType.cycle property for an infinite sequence</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 30, 2015 at 03:00:00pm</p></header><div class="content"><p>On Wed, Dec 30, 2015, at 02:27 PM, plx via swift-evolution wrote:<br>&gt;<br>&gt;&gt; On that note, core language team, anyone know offhand why<br>&gt;&gt; SequenceType has a bunch of extension methods that aren&#39;t part of the<br>&gt;&gt; protocol? For example, contains(_ predicate:). The only real reason I<br>&gt;&gt; can think of is to shrink the protocol witness table, but surely<br>&gt;&gt; that&#39;s not particularly meaningful. I warrant that contains(_<br>&gt;&gt; predicate:) doesn&#39;t really have any reason to be overridden by<br>&gt;&gt; anything except sequences that knowingly repeat elements (e.g.<br>&gt;&gt; CycleSequence and Repeat), and even that&#39;s only if you assume the<br>&gt;&gt; predicate is pure, but there&#39;s some other methods that make sense to<br>&gt;&gt; override on some sequences (like minElement(_ isOrderedBefore:) for<br>&gt;&gt; any sequence that has a defined ordering).<br>&gt;<br>&gt; I am not sure how, precisely, you would propose to override the closure-<br>&gt; taking variant of `minElement` to take advantage of an intrinsic<br>&gt; ordering, but I’d be curious to see it.<br></p><p>Oops, you&#39;re entirely right. I wasn&#39;t thinking carefully about it; it&#39;s<br>the Comparable version that would be able to take advantage of an<br>intrinsic ordering, but of course we can&#39;t override that using the<br>current language rules as it requires the Equatable bound. Of course,<br>once we add the ability to have conditional protocol conformance, then<br>we can move things like that into a separate protocol and declare<br>SequenceType as conforming to it whenever Element : Equatable, which<br>would let those methods then become overridable.<br></p><p>Although interestingly, contains() actually has a hack right now where<br>it invokes a hidden SequenceType method called<br>_customContainsEquatableElement(). This is explicitly intended to let<br>sequences override the Equatable version of contains() if the sequence<br>knows it can do better than a linear search.<br></p><p>&gt; I’d hope that the non-closure-accepting variants would be made<br>&gt; overridable once the type system supports it.<br></p><p>Agreed.<br></p><p>-Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/c7eb555c/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Proposal: CollectionType.cycle property for an infinite sequence</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 29, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; On Dec 27, 2015, at 11:20 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; ## Introduction<br>&gt; <br>&gt; Add a new property `cycle` to CollectionType that returns an infinite SequenceType that yields the elements of the collection in a loop.<br></p><p>The name should give an explicit indication that the result is infinite, e.g. “repeatedForever&quot;.  <br></p><p>&gt; ## Motivation<br>&gt; <br>&gt; It&#39;s sometimes useful to be able to have an infinite sequence. For example, `CollectionOfOne(x).cycle` could be used to have an infinite sequence of a single element (similar to Repeat but without a count). A common use for infinite sequences is zipping with a finite sequence. As far as I&#39;m aware, the stdlib does not currently provide any way to create such an infinite sequence.<br></p><p>If this is, as I suspect, the primary use case, I would prefer a much clearer incantation than CollectionOfOne(x).repeatedForever.  The part before the parentheses is mostly irrelevant.  I suppose [x].repeatedForever could work, but needing an array allocation makes me sad.  I wish I had something better to suggest… This may in fact be the best we can do.<br></p><p>&gt; ## Proposed solution<br>&gt; <br>&gt; Extend CollectionType with a new property `cycle` that yields a type that conforms to SequenceType. This sequence yields each element of the collection in an infinite loop.<br>&gt; <br>&gt; ## Detailed design<br>&gt; <br>&gt; 2 new types would be added:<br>&gt; <br>&gt; struct CycleSequence&lt;Base : CollectionType&gt; : LazySequenceType { ... }<br>&gt; struct CycleGenerator&lt;Base : CollectionType&gt; : GeneratorType { ... }<br>&gt; <br>&gt; CollectionType would be extended with a property:<br>&gt; <br>&gt; extension CollectionType {<br>&gt;    public var cycle: CycleSequence&lt;Self&gt; { get }<br>&gt; }<br>&gt; <br>&gt; This is an extension of CollectionType instead of SequenceType because it requires a multi-pass sequence (and SequenceType does not provide that guarantee).<br></p><p>You can copy the elements into an array in that case.  Whether or not we should provide that is an open question, but we do similar things for, e.g., reverse().<br></p><p>&gt; The returned type conforms to SequenceType instead of CollectionType because there is no possible `endIndex` that satisfies the requirement of being reachable from `startIndex` by zero or more applications of `successor()`.<br></p><p>Yeah… I’m not sure we want to do so, but we should consider loosening that requirement.  After all, x.repeatedForever.prefix(1000) is in principle a perfectly cromulent collection that shouldn’t require copying x’s elements into new storage.<br></p><p>&gt; Because the default eager versions of map and filter will execute forever on an infinite sequence, CycleSequence conforms to LazySequenceType instead of SequenceType in order to provide lazy versions of those functions.<br></p><p>It would arguably be more appropriate to only provide repeatedForever on instances of LazySequenceType.  The idea has always been that users are surprised when they see their map/filter closure’s side-effects happen multiple times, or at odd times, so we make them write “.lazy” to specifically opt into that behavior.  I’ve always had mixed feelings about this, thinking that maybe it would be better to educate people about laziness, but that’s what we currently do.  <br></p><p>We could weasel out of the “multiple side-effects” problem by declaring that since the result is not a collection you can only make one pass through any part of the result, so if your side-effect over-fires, it’s on you.  I wouldn’t be in favor of making this sequence *actually* single-pass though, and this doesn’t solve the “side-effects at odd times” issue.<br></p><p>&gt; Additionally, it will provide implementations of the eager versions that simply trigger a fatalError(), as the alternative is an infinite loop that consumes more and more memory.<br></p><p>Why do this?  What would these eager APIs look like?<br></p><p>&gt; <br>&gt; ## Impact on existing code<br>&gt; <br>&gt; None<br>&gt; <br>&gt; -Kevin Ballard<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: CollectionType.cycle property for an infinite sequence</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 29, 2015 at 04:00:00pm</p></header><div class="content"><p>On Tue, Dec 29, 2015, at 04:11 PM, Dave Abrahams wrote:<br>&gt; <br>&gt; &gt; On Dec 27, 2015, at 11:20 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; <br>&gt; &gt; ## Introduction<br>&gt; &gt; <br>&gt; &gt; Add a new property `cycle` to CollectionType that returns an infinite SequenceType that yields the elements of the collection in a loop.<br>&gt; <br>&gt; The name should give an explicit indication that the result is infinite, e.g. “repeatedForever&quot;.  <br></p><p>All of the precedent I&#39;m aware of calls this operation &quot;cycle&quot;.<br></p><p>Haskell: http://hackage.haskell.org/package/base-4.8.1.0/docs/Prelude.html#v:cycle<br>Rust: https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html#method.cycle<br>Ruby: http://ruby-doc.org/core-2.2.3/Enumerable.html#method-i-cycle<br>Python: https://docs.python.org/3/library/itertools.html?highlight=cycle#itertools.cycle<br>D: http://dlang.org/phobos/std_range.html#cycle<br></p><p>I&#39;m not sure offhand what other languages to even look to for this.<br></p><p>&gt; &gt; ## Motivation<br>&gt; &gt; <br>&gt; &gt; It&#39;s sometimes useful to be able to have an infinite sequence. For example, `CollectionOfOne(x).cycle` could be used to have an infinite sequence of a single element (similar to Repeat but without a count). A common use for infinite sequences is zipping with a finite sequence. As far as I&#39;m aware, the stdlib does not currently provide any way to create such an infinite sequence.<br>&gt; <br>&gt; If this is, as I suspect, the primary use case, I would prefer a much clearer incantation than CollectionOfOne(x).repeatedForever.  The part before the parentheses is mostly irrelevant.  I suppose [x].repeatedForever could work, but needing an array allocation makes me sad.  I wish I had something better to suggest… This may in fact be the best we can do.<br></p><p>Honestly, I&#39;d actually like to take Repeat and remove the count. I&#39;ve never used this type and I&#39;ve never seen any code that uses this type. The current counted behavior of Repeat could then be recovered by saying `Repeat(elt).prefix(count)`. Of course, this would only repeat a single element, so we&#39;d still need Cycle to repeat sequences (which is why I suggested `CollectionOfOne(x).cycle` as that has the same behavior, although of course Repeat then just becomes a special case of `CollectionOfOne(x).cycle.prefix(count)`).<br></p><p>&gt; &gt; ## Proposed solution<br>&gt; &gt; <br>&gt; &gt; Extend CollectionType with a new property `cycle` that yields a type that conforms to SequenceType. This sequence yields each element of the collection in an infinite loop.<br>&gt; &gt; <br>&gt; &gt; ## Detailed design<br>&gt; &gt; <br>&gt; &gt; 2 new types would be added:<br>&gt; &gt; <br>&gt; &gt; struct CycleSequence&lt;Base : CollectionType&gt; : LazySequenceType { ... }<br>&gt; &gt; struct CycleGenerator&lt;Base : CollectionType&gt; : GeneratorType { ... }<br>&gt; &gt; <br>&gt; &gt; CollectionType would be extended with a property:<br>&gt; &gt; <br>&gt; &gt; extension CollectionType {<br>&gt; &gt;    public var cycle: CycleSequence&lt;Self&gt; { get }<br>&gt; &gt; }<br>&gt; &gt; <br>&gt; &gt; This is an extension of CollectionType instead of SequenceType because it requires a multi-pass sequence (and SequenceType does not provide that guarantee).<br>&gt; <br>&gt; You can copy the elements into an array in that case.  Whether or not we should provide that is an open question, but we do similar things for, e.g., reverse().<br></p><p>You can, but I prefer not to hide array creation like that whenever possible. If I need to cycle some SequenceType I can just wrap it in Array myself, e.g. `Array(seq).cycle`.<br></p><p>&gt; &gt; The returned type conforms to SequenceType instead of CollectionType because there is no possible `endIndex` that satisfies the requirement of being reachable from `startIndex` by zero or more applications of `successor()`.<br>&gt; <br>&gt; Yeah… I’m not sure we want to do so, but we should consider loosening that requirement.  After all, x.repeatedForever.prefix(1000) is in principle a perfectly cromulent collection that shouldn’t require copying x’s elements into new storage.<br></p><p>Loosening this breaks the `count` property. There&#39;s no valid value of `count` that can be returned for an infinite sequence. The property could of course just loop infinitely (or fatalError), but that strikes me as being a much worse idea than e.g. map() looping forever, because with map() we have a lazy replacement but there is no lazy replacement for count.<br></p><p>We could of course give CycleSequence a separate prefix() function that returns a collection (but the prefix() from SequenceType must return SubSequence, which cannot be a collection).<br></p><p>&gt; &gt; Because the default eager versions of map and filter will execute forever on an infinite sequence, CycleSequence conforms to LazySequenceType instead of SequenceType in order to provide lazy versions of those functions.<br>&gt; <br>&gt; It would arguably be more appropriate to only provide repeatedForever on instances of LazySequenceType.  The idea has always been that users are surprised when they see their map/filter closure’s side-effects happen multiple times, or at odd times, so we make them write “.lazy” to specifically opt into that behavior.  I’ve always had mixed feelings about this, thinking that maybe it would be better to educate people about laziness, but that’s what we currently do.<br>&gt;<br>&gt; We could weasel out of the “multiple side-effects” problem by declaring that since the result is not a collection you can only make one pass through any part of the result, so if your side-effect over-fires, it’s on you.  I wouldn’t be in favor of making this sequence *actually* single-pass though, and this doesn’t solve the “side-effects at odd times” issue.<br></p><p>Good point. I figured that an infinite sequence is &quot;obviously&quot; lazy, but we do have a precedent right now of requiring `lazy` to get lazy sequences. I also have mixed feelings about this (the strongest argument in favor of the status quo is being able to use @noescape functions for the array versions, but I end up having to use `lazy` very often anyway to avoid intermediate array creation anyway).<br></p><p>The reason why I didn&#39;t put this on LazySequenceType to begin with is so far we only require `lazy` directly before invoking an operation that takes a closure. `cycle()` doesn&#39;t take a closure, so no need to ask that it be lazy. But since operations chained off of it (like `map()`) should be lazy, it makes sense to require the `lazy` anyway.<br></p><p>&gt; &gt; Additionally, it will provide implementations of the eager versions that simply trigger a fatalError(), as the alternative is an infinite loop that consumes more and more memory.<br>&gt; <br>&gt; Why do this?  What would these eager APIs look like?<br></p><p>The only reason to do this is because the default implementations of the functions will crash the program anyway, after entering an infinite loop and gobbling up memory. So I figured it&#39;s nicer to just fatalError() immediately as we can provide a much better error that way.<br></p><p>Of course, technically, these eager functions could terminate anyway, if they throw an error. I still think fatalError() is a good idea because nobody writes code that calls one of these methods and expects to get an error in 100% of cases, but if this is a contentious point we can easily remove the fatalError() implementations from the proposal.<br></p><p>-Kevin Ballard<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
