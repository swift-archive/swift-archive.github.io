<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2336c8e31c674e78add6bb0e4550746a?s=50"></div><header><strong>Eliminate inconsistencies among primary collection types</strong> from <string>swiftevo.w.husmann at spamgourmet.com</string> &lt;swiftevo.w.husmann at spamgourmet.com&gt;<p>April 29, 2016 at 07:00:00pm</p></header><div class="content"><p>A. When trying to declare nested collection types an inconsistency<br>   is unveiled:<br></p><p><br>A.1. “Array” as outer type allows for every collection type as inner<br>     type (“Int” used as a placeholder for “some other type”):<br></p><p>    let test_aa: Array&lt;Array&lt;Int&gt;&gt; = []<br>        // ok<br></p><p>    let test_as: Array&lt;Set&lt;Int&gt;&gt; = []<br>        // ok<br></p><p>    let test_ad: Array&lt;Dictionary&lt;Int, Int&gt;&gt; = []<br>        // ok<br></p><p><br>A.2. “Set” as outer type allows for “Set” as inner type only:<br></p><p>    let test_sa: Set&lt;Array&lt;Int&gt;&gt; = []<br>        // compile time error “Type &#39;Array&lt;Int&gt;&#39; does not conform to <br>        // protocol &#39;Hashable&#39;”<br></p><p>    let test_ss: Set&lt;Set&lt;Int&gt;&gt; = []<br>        // ok<br></p><p>    let test_sd: Set&lt;Dictionary&lt;Int, Int&gt;&gt; = []<br>        // compile time error “Type &#39;Dictionary&lt;Int, Int&gt;&#39; does not <br>        // conform to protocol &#39;Hashable&#39;”<br></p><p><br>A.3. The same is true for “Dictionary” as outer type:<br></p><p>    let test_da: Dictionary&lt;Array&lt;Int&gt;, Int&gt; = [:]<br>        // compile time error “Type &#39;Array&lt;Int&gt;&#39; does not conform to <br>        // protocol &#39;Hashable&#39;”<br></p><p>    let test_ds: Dictionary&lt;Set&lt;Int&gt;, Int&gt; = [:]<br>        // ok<br></p><p>    let test_dd: Dictionary&lt;Dictionary&lt;Int, Int&gt;, Int&gt; = [:]<br>        // compile time error “Type &#39;Dictionary&lt;Int, Int&gt;&#39; does not <br>        // conform to protocol &#39;Hashable&#39;”<br></p><p><br>B. When letting Swift infer the type of collections of “Array” from<br>   literals another inconsistency comes to light:<br></p><p><br>B.1. “Array” as outer type behaves IMHO perfectly:<br></p><p>    var testArray = [ [ 1, 2, 4, 8 ], [ 1, 3, 9, 27 ] ]<br>    print(testArray.dynamicType)<br>        // prints “Array&lt;Array&lt;Int&gt;&gt;”<br>    testArray.append( [ 1, &quot;five&quot;, 25, 625 ] );<br>        // compile time error “Cannot convert value of &#39;String&#39; to<br>        // expected element type &#39;Int&#39;”; type safe<br></p><p><br>B.2. “Set” as outer type works but there is no type safety:<br></p><p>    var testSet: Set = [ [ 1, 2, 4, 8 ], [ 1, 3, 9, 27 ] ]<br>    print(testSet.dynamicType)<br>        // prints “Set&lt;NSArray&gt;”<br>    testSet.insert( [ 1, &quot;five&quot;, 25, 625 ] )<br>        // neither run time nor compile time errors; no type safety<br></p><p><br>B.3. The same goes for “Dictionary” as outer type:<br></p><p>    var testDictionary = [<br>        [ 1, 2, 4, 8 ]: &quot;Powers of Two&quot;,<br>        [ 1, 3, 9, 27 ]: &quot;Powers of Three&quot;,<br>    ]<br>    print(testDictionary.dynamicType)<br>        // prints &quot;Dictionary&lt;NSArray, String&gt;&quot;<br>    testDictionary[ [ 1, &quot;five&quot;, 25, 625 ] ] = &quot;Powers of Five&quot;<br>        // neither run time nor compile time errors; no type safety<br></p><p><br></p><p>— — - Wolfgang H.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Eliminate inconsistencies among primary collection types</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April 29, 2016 at 06:00:00pm</p></header><div class="content"><p>I&#39;m not sure I understand the inconsistency you see. Set and Dictionary<br>require hashable values and keys, respectively. That&#39;s just in the nature<br>of what these types are. Do you want Set itself to conform to Hashable?<br></p><p>On Fri, Apr 29, 2016 at 12:57 Wolfgang H. via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; A. When trying to declare nested collection types an inconsistency<br>&gt;    is unveiled:<br>&gt;<br>&gt;<br>&gt; A.1. “Array” as outer type allows for every collection type as inner<br>&gt;      type (“Int” used as a placeholder for “some other type”):<br>&gt;<br>&gt;     let test_aa: Array&lt;Array&lt;Int&gt;&gt; = []<br>&gt;         // ok<br>&gt;<br>&gt;     let test_as: Array&lt;Set&lt;Int&gt;&gt; = []<br>&gt;         // ok<br>&gt;<br>&gt;     let test_ad: Array&lt;Dictionary&lt;Int, Int&gt;&gt; = []<br>&gt;         // ok<br>&gt;<br>&gt;<br>&gt; A.2. “Set” as outer type allows for “Set” as inner type only:<br>&gt;<br>&gt;     let test_sa: Set&lt;Array&lt;Int&gt;&gt; = []<br>&gt;         // compile time error “Type &#39;Array&lt;Int&gt;&#39; does not conform to<br>&gt;         // protocol &#39;Hashable&#39;”<br>&gt;<br>&gt;     let test_ss: Set&lt;Set&lt;Int&gt;&gt; = []<br>&gt;         // ok<br>&gt;<br>&gt;     let test_sd: Set&lt;Dictionary&lt;Int, Int&gt;&gt; = []<br>&gt;         // compile time error “Type &#39;Dictionary&lt;Int, Int&gt;&#39; does not<br>&gt;         // conform to protocol &#39;Hashable&#39;”<br>&gt;<br>&gt;<br>&gt; A.3. The same is true for “Dictionary” as outer type:<br>&gt;<br>&gt;     let test_da: Dictionary&lt;Array&lt;Int&gt;, Int&gt; = [:]<br>&gt;         // compile time error “Type &#39;Array&lt;Int&gt;&#39; does not conform to<br>&gt;         // protocol &#39;Hashable&#39;”<br>&gt;<br>&gt;     let test_ds: Dictionary&lt;Set&lt;Int&gt;, Int&gt; = [:]<br>&gt;         // ok<br>&gt;<br>&gt;     let test_dd: Dictionary&lt;Dictionary&lt;Int, Int&gt;, Int&gt; = [:]<br>&gt;         // compile time error “Type &#39;Dictionary&lt;Int, Int&gt;&#39; does not<br>&gt;         // conform to protocol &#39;Hashable&#39;”<br>&gt;<br>&gt;<br>&gt; B. When letting Swift infer the type of collections of “Array” from<br>&gt;    literals another inconsistency comes to light:<br>&gt;<br>&gt;<br>&gt; B.1. “Array” as outer type behaves IMHO perfectly:<br>&gt;<br>&gt;     var testArray = [ [ 1, 2, 4, 8 ], [ 1, 3, 9, 27 ] ]<br>&gt;     print(testArray.dynamicType)<br>&gt;         // prints “Array&lt;Array&lt;Int&gt;&gt;”<br>&gt;     testArray.append( [ 1, &quot;five&quot;, 25, 625 ] );<br>&gt;         // compile time error “Cannot convert value of &#39;String&#39; to<br>&gt;         // expected element type &#39;Int&#39;”; type safe<br>&gt;<br>&gt;<br>&gt; B.2. “Set” as outer type works but there is no type safety:<br>&gt;<br>&gt;     var testSet: Set = [ [ 1, 2, 4, 8 ], [ 1, 3, 9, 27 ] ]<br>&gt;     print(testSet.dynamicType)<br>&gt;         // prints “Set&lt;NSArray&gt;”<br>&gt;     testSet.insert( [ 1, &quot;five&quot;, 25, 625 ] )<br>&gt;         // neither run time nor compile time errors; no type safety<br>&gt;<br>&gt;<br>&gt; B.3. The same goes for “Dictionary” as outer type:<br>&gt;<br>&gt;     var testDictionary = [<br>&gt;         [ 1, 2, 4, 8 ]: &quot;Powers of Two&quot;,<br>&gt;         [ 1, 3, 9, 27 ]: &quot;Powers of Three&quot;,<br>&gt;     ]<br>&gt;     print(testDictionary.dynamicType)<br>&gt;         // prints &quot;Dictionary&lt;NSArray, String&gt;&quot;<br>&gt;     testDictionary[ [ 1, &quot;five&quot;, 25, 625 ] ] = &quot;Powers of Five&quot;<br>&gt;         // neither run time nor compile time errors; no type safety<br>&gt;<br>&gt;<br>&gt;<br>&gt; — — - Wolfgang H.<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160429/97cbc9ae/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2336c8e31c674e78add6bb0e4550746a?s=50"></div><header><strong>Eliminate inconsistencies among primary collection types</strong> from <string>swiftevo.w.husmann at spamgourmet.com</string> &lt;swiftevo.w.husmann at spamgourmet.com&gt;<p>April 29, 2016 at 08:00:00pm</p></header><div class="content"><p>Inconsistency A. is that “Set” currently is the only collection type conforming to protocol &#39;Hashable&#39;”. IMHO both “Array” and “Dictionary” should conform to protocol “Hashable”, too.<br></p><p>Inconsistency B. is that “Array&lt;Int&gt;” is typesafe if used as element of an “Array” but is non-typesafe if used as element of “Set” or “Dictionary”. The non-typesafety may result from the mapping of “Array&lt;Int&gt;” to “NSArray“.<br></p><p>- - - Wolfgang H.<br></p><p><br>&gt; Am 2016-04-29 17/Fr um 20:18 schrieb Xiaodi Wu - xiaodi.wu at gmail.com:<br>&gt; <br>&gt; I&#39;m not sure I understand the inconsistency you see. Set and Dictionary require hashable values and keys, respectively. That&#39;s just in the nature of what these types are. Do you want Set itself to conform to Hashable?<br>&gt; <br>&gt; On Fri, Apr 29, 2016 at 12:57 Wolfgang H. via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; A. When trying to declare nested collection types an inconsistency<br>&gt;   is unveiled:<br>&gt; <br>&gt; <br>&gt; A.1. “Array” as outer type allows for every collection type as inner<br>&gt;     type (“Int” used as a placeholder for “some other type”):<br>&gt; <br>&gt;    let test_aa: Array&lt;Array&lt;Int&gt;&gt; = []<br>&gt;        // ok<br>&gt; <br>&gt;    let test_as: Array&lt;Set&lt;Int&gt;&gt; = []<br>&gt;        // ok<br>&gt; <br>&gt;    let test_ad: Array&lt;Dictionary&lt;Int, Int&gt;&gt; = []<br>&gt;        // ok<br>&gt; <br>&gt; <br>&gt; A.2. “Set” as outer type allows for “Set” as inner type only:<br>&gt; <br>&gt;    let test_sa: Set&lt;Array&lt;Int&gt;&gt; = []<br>&gt;        // compile time error “Type &#39;Array&lt;Int&gt;&#39; does not conform to<br>&gt;        // protocol &#39;Hashable&#39;”<br>&gt; <br>&gt;    let test_ss: Set&lt;Set&lt;Int&gt;&gt; = []<br>&gt;        // ok<br>&gt; <br>&gt;    let test_sd: Set&lt;Dictionary&lt;Int, Int&gt;&gt; = []<br>&gt;        // compile time error “Type &#39;Dictionary&lt;Int, Int&gt;&#39; does not<br>&gt;        // conform to protocol &#39;Hashable&#39;”<br>&gt; <br>&gt; <br>&gt; A.3. The same is true for “Dictionary” as outer type:<br>&gt; <br>&gt;    let test_da: Dictionary&lt;Array&lt;Int&gt;, Int&gt; = [:]<br>&gt;        // compile time error “Type &#39;Array&lt;Int&gt;&#39; does not conform to<br>&gt;        // protocol &#39;Hashable&#39;”<br>&gt; <br>&gt;    let test_ds: Dictionary&lt;Set&lt;Int&gt;, Int&gt; = [:]<br>&gt;        // ok<br>&gt; <br>&gt;    let test_dd: Dictionary&lt;Dictionary&lt;Int, Int&gt;, Int&gt; = [:]<br>&gt;        // compile time error “Type &#39;Dictionary&lt;Int, Int&gt;&#39; does not<br>&gt;        // conform to protocol &#39;Hashable&#39;”<br>&gt; <br>&gt; <br>&gt; B. When letting Swift infer the type of collections of “Array” from<br>&gt;   literals another inconsistency comes to light:<br>&gt; <br>&gt; <br>&gt; B.1. “Array” as outer type behaves IMHO perfectly:<br>&gt; <br>&gt;    var testArray = [ [ 1, 2, 4, 8 ], [ 1, 3, 9, 27 ] ]<br>&gt;    print(testArray.dynamicType)<br>&gt;        // prints “Array&lt;Array&lt;Int&gt;&gt;”<br>&gt;    testArray.append( [ 1, &quot;five&quot;, 25, 625 ] );<br>&gt;        // compile time error “Cannot convert value of &#39;String&#39; to<br>&gt;        // expected element type &#39;Int&#39;”; type safe<br>&gt; <br>&gt; <br>&gt; B.2. “Set” as outer type works but there is no type safety:<br>&gt; <br>&gt;    var testSet: Set = [ [ 1, 2, 4, 8 ], [ 1, 3, 9, 27 ] ]<br>&gt;    print(testSet.dynamicType)<br>&gt;        // prints “Set&lt;NSArray&gt;”<br>&gt;    testSet.insert( [ 1, &quot;five&quot;, 25, 625 ] )<br>&gt;        // neither run time nor compile time errors; no type safety<br>&gt; <br>&gt; <br>&gt; B.3. The same goes for “Dictionary” as outer type:<br>&gt; <br>&gt;    var testDictionary = [<br>&gt;        [ 1, 2, 4, 8 ]: &quot;Powers of Two&quot;,<br>&gt;        [ 1, 3, 9, 27 ]: &quot;Powers of Three&quot;,<br>&gt;    ]<br>&gt;    print(testDictionary.dynamicType)<br>&gt;        // prints &quot;Dictionary&lt;NSArray, String&gt;&quot;<br>&gt;    testDictionary[ [ 1, &quot;five&quot;, 25, 625 ] ] = &quot;Powers of Five&quot;<br>&gt;        // neither run time nor compile time errors; no type safety<br>&gt; <br>&gt; <br>&gt; <br>&gt; — — - Wolfgang H.<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5f463dd4e7af28b64ad8f0e032ee82dc?s=50"></div><header><strong>Eliminate inconsistencies among primary collection types</strong> from <string>Nate Cook</string> &lt;natecook at gmail.com&gt;<p>April 29, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Apr 29, 2016, at 1:57 PM, Wolfgang H. via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Inconsistency A. is that “Set” currently is the only collection type conforming to protocol &#39;Hashable&#39;”. IMHO both “Array” and “Dictionary” should conform to protocol “Hashable”, too.<br></p><p>Set is the only Hashable* collection type because it&#39;s the only collection type where all of its values are always Hashable themselves. Array&lt;Element&gt; can be an array of a non-Hashable type; Dictionary&lt;Key: Value&gt; can have a non-Hashable type for Value. If/when Swift gains conditional protocol compliance, arrays and dictionaries of Hashable types could themselves be Hashable, but not until then.<br></p><p>&gt; Inconsistency B. is that “Array&lt;Int&gt;” is typesafe if used as element of an “Array” but is non-typesafe if used as element of “Set” or “Dictionary”. The non-typesafety may result from the mapping of “Array&lt;Int&gt;” to “NSArray“.<br></p><p>Since Array&lt;Element&gt; isn&#39;t Hashable, you can&#39;t create a Set&lt;Array&lt;Int&gt;&gt;. The type system therefore falls back to using the bridged Objective-C type for Array&lt;Int&gt;, which can provide a hash value based on object identity.<br></p><p>Nate<br></p><p><br>*For my spell checker&#39;s sake, could we rename Hashable to Washable? Thanks<br></p><p>&gt; - - - Wolfgang H.<br>&gt; <br>&gt; <br>&gt;&gt; Am 2016-04-29 17/Fr um 20:18 schrieb Xiaodi Wu - xiaodi.wu at gmail.com:<br>&gt;&gt; <br>&gt;&gt; I&#39;m not sure I understand the inconsistency you see. Set and Dictionary require hashable values and keys, respectively. That&#39;s just in the nature of what these types are. Do you want Set itself to conform to Hashable?<br>&gt;&gt; <br>&gt;&gt; On Fri, Apr 29, 2016 at 12:57 Wolfgang H. via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; A. When trying to declare nested collection types an inconsistency<br>&gt;&gt;  is unveiled:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; A.1. “Array” as outer type allows for every collection type as inner<br>&gt;&gt;    type (“Int” used as a placeholder for “some other type”):<br>&gt;&gt; <br>&gt;&gt;   let test_aa: Array&lt;Array&lt;Int&gt;&gt; = []<br>&gt;&gt;       // ok<br>&gt;&gt; <br>&gt;&gt;   let test_as: Array&lt;Set&lt;Int&gt;&gt; = []<br>&gt;&gt;       // ok<br>&gt;&gt; <br>&gt;&gt;   let test_ad: Array&lt;Dictionary&lt;Int, Int&gt;&gt; = []<br>&gt;&gt;       // ok<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; A.2. “Set” as outer type allows for “Set” as inner type only:<br>&gt;&gt; <br>&gt;&gt;   let test_sa: Set&lt;Array&lt;Int&gt;&gt; = []<br>&gt;&gt;       // compile time error “Type &#39;Array&lt;Int&gt;&#39; does not conform to<br>&gt;&gt;       // protocol &#39;Hashable&#39;”<br>&gt;&gt; <br>&gt;&gt;   let test_ss: Set&lt;Set&lt;Int&gt;&gt; = []<br>&gt;&gt;       // ok<br>&gt;&gt; <br>&gt;&gt;   let test_sd: Set&lt;Dictionary&lt;Int, Int&gt;&gt; = []<br>&gt;&gt;       // compile time error “Type &#39;Dictionary&lt;Int, Int&gt;&#39; does not<br>&gt;&gt;       // conform to protocol &#39;Hashable&#39;”<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; A.3. The same is true for “Dictionary” as outer type:<br>&gt;&gt; <br>&gt;&gt;   let test_da: Dictionary&lt;Array&lt;Int&gt;, Int&gt; = [:]<br>&gt;&gt;       // compile time error “Type &#39;Array&lt;Int&gt;&#39; does not conform to<br>&gt;&gt;       // protocol &#39;Hashable&#39;”<br>&gt;&gt; <br>&gt;&gt;   let test_ds: Dictionary&lt;Set&lt;Int&gt;, Int&gt; = [:]<br>&gt;&gt;       // ok<br>&gt;&gt; <br>&gt;&gt;   let test_dd: Dictionary&lt;Dictionary&lt;Int, Int&gt;, Int&gt; = [:]<br>&gt;&gt;       // compile time error “Type &#39;Dictionary&lt;Int, Int&gt;&#39; does not<br>&gt;&gt;       // conform to protocol &#39;Hashable&#39;”<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; B. When letting Swift infer the type of collections of “Array” from<br>&gt;&gt;  literals another inconsistency comes to light:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; B.1. “Array” as outer type behaves IMHO perfectly:<br>&gt;&gt; <br>&gt;&gt;   var testArray = [ [ 1, 2, 4, 8 ], [ 1, 3, 9, 27 ] ]<br>&gt;&gt;   print(testArray.dynamicType)<br>&gt;&gt;       // prints “Array&lt;Array&lt;Int&gt;&gt;”<br>&gt;&gt;   testArray.append( [ 1, &quot;five&quot;, 25, 625 ] );<br>&gt;&gt;       // compile time error “Cannot convert value of &#39;String&#39; to<br>&gt;&gt;       // expected element type &#39;Int&#39;”; type safe<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; B.2. “Set” as outer type works but there is no type safety:<br>&gt;&gt; <br>&gt;&gt;   var testSet: Set = [ [ 1, 2, 4, 8 ], [ 1, 3, 9, 27 ] ]<br>&gt;&gt;   print(testSet.dynamicType)<br>&gt;&gt;       // prints “Set&lt;NSArray&gt;”<br>&gt;&gt;   testSet.insert( [ 1, &quot;five&quot;, 25, 625 ] )<br>&gt;&gt;       // neither run time nor compile time errors; no type safety<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; B.3. The same goes for “Dictionary” as outer type:<br>&gt;&gt; <br>&gt;&gt;   var testDictionary = [<br>&gt;&gt;       [ 1, 2, 4, 8 ]: &quot;Powers of Two&quot;,<br>&gt;&gt;       [ 1, 3, 9, 27 ]: &quot;Powers of Three&quot;,<br>&gt;&gt;   ]<br>&gt;&gt;   print(testDictionary.dynamicType)<br>&gt;&gt;       // prints &quot;Dictionary&lt;NSArray, String&gt;&quot;<br>&gt;&gt;   testDictionary[ [ 1, &quot;five&quot;, 25, 625 ] ] = &quot;Powers of Five&quot;<br>&gt;&gt;       // neither run time nor compile time errors; no type safety<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; — — - Wolfgang H.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Eliminate inconsistencies among primary collection types</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April 29, 2016 at 03:00:00pm</p></header><div class="content"><p>On Fri, Apr 29, 2016 at 2:49 PM, Nate Cook via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; On Apr 29, 2016, at 1:57 PM, Wolfgang H. via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Inconsistency A. is that “Set” currently is the only collection type<br>&gt; conforming to protocol &#39;Hashable&#39;”. IMHO both “Array” and “Dictionary”<br>&gt; should conform to protocol “Hashable”, too.<br>&gt;<br>&gt; Set is the only Hashable* collection type because it&#39;s the only collection<br>&gt; type where all of its values are always Hashable themselves. Array&lt;Element&gt;<br>&gt; can be an array of a non-Hashable type; Dictionary&lt;Key: Value&gt; can have a<br>&gt; non-Hashable type for Value. If/when Swift gains conditional protocol<br>&gt; compliance, arrays and dictionaries of Hashable types could themselves be<br>&gt; Hashable, but not until then.<br>&gt;<br>&gt; &gt; Inconsistency B. is that “Array&lt;Int&gt;” is typesafe if used as element of<br>&gt; an “Array” but is non-typesafe if used as element of “Set” or “Dictionary”.<br>&gt; The non-typesafety may result from the mapping of “Array&lt;Int&gt;” to “NSArray“.<br>&gt;<br>&gt; Since Array&lt;Element&gt; isn&#39;t Hashable, you can&#39;t create a Set&lt;Array&lt;Int&gt;&gt;.<br>&gt; The type system therefore falls back to using the bridged Objective-C type<br>&gt; for Array&lt;Int&gt;, which can provide a hash value based on object identity.<br>&gt;<br>&gt; Nate<br>&gt;<br>&gt;<br>&gt; *For my spell checker&#39;s sake, could we rename Hashable to Washable? Thanks<br></p><p><br></p><p>Well put, Nate.<br>It will be a great day when conditional protocol compliance comes to Swift.<br>Until then, there&#39;s good reason why Array and Dictionary can&#39;t be washed.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160429/c4334445/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Eliminate inconsistencies among primary collection types</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>April 29, 2016 at 07:00:00pm</p></header><div class="content"><p>The only way to do this would be to require a hashing closure as an alternative to requiring Hashable, which is certainly do-able, but would be just as inconsistent.<br></p><p>I think the real problem is that Set and Dictionary are just types, but really they should conform to some kind of protocol instead, as it’s entirely conceivable to want to implement a key/value type that uses a tree structure for storage, in which case Hashable isn’t a requirement (but Comparable might be).<br></p><p>The solution therefore is to define general purpose Set and Map protocols, and maybe rename Set to HashSet or something, so that we have a similar distinction as is the case between CollectionType (protocol) and Array (implementing type). I’ve been trying to do this retroactively to implement some specialised map-types, but it leads to all kinds of compiler issues since Dictionary is being extended in a somewhat unusual way, I expect Set might have similar issues, so it would be better if the protocols were official.<br></p><p>&gt; On 29 Apr 2016, at 18:57, Wolfgang H. via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; A. When trying to declare nested collection types an inconsistency<br>&gt;   is unveiled:<br>&gt; <br>&gt; <br>&gt; A.1. “Array” as outer type allows for every collection type as inner<br>&gt;     type (“Int” used as a placeholder for “some other type”):<br>&gt; <br>&gt;    let test_aa: Array&lt;Array&lt;Int&gt;&gt; = []<br>&gt;        // ok<br>&gt; <br>&gt;    let test_as: Array&lt;Set&lt;Int&gt;&gt; = []<br>&gt;        // ok<br>&gt; <br>&gt;    let test_ad: Array&lt;Dictionary&lt;Int, Int&gt;&gt; = []<br>&gt;        // ok<br>&gt; <br>&gt; <br>&gt; A.2. “Set” as outer type allows for “Set” as inner type only:<br>&gt; <br>&gt;    let test_sa: Set&lt;Array&lt;Int&gt;&gt; = []<br>&gt;        // compile time error “Type &#39;Array&lt;Int&gt;&#39; does not conform to <br>&gt;        // protocol &#39;Hashable&#39;”<br>&gt; <br>&gt;    let test_ss: Set&lt;Set&lt;Int&gt;&gt; = []<br>&gt;        // ok<br>&gt; <br>&gt;    let test_sd: Set&lt;Dictionary&lt;Int, Int&gt;&gt; = []<br>&gt;        // compile time error “Type &#39;Dictionary&lt;Int, Int&gt;&#39; does not <br>&gt;        // conform to protocol &#39;Hashable&#39;”<br>&gt; <br>&gt; <br>&gt; A.3. The same is true for “Dictionary” as outer type:<br>&gt; <br>&gt;    let test_da: Dictionary&lt;Array&lt;Int&gt;, Int&gt; = [:]<br>&gt;        // compile time error “Type &#39;Array&lt;Int&gt;&#39; does not conform to <br>&gt;        // protocol &#39;Hashable&#39;”<br>&gt; <br>&gt;    let test_ds: Dictionary&lt;Set&lt;Int&gt;, Int&gt; = [:]<br>&gt;        // ok<br>&gt; <br>&gt;    let test_dd: Dictionary&lt;Dictionary&lt;Int, Int&gt;, Int&gt; = [:]<br>&gt;        // compile time error “Type &#39;Dictionary&lt;Int, Int&gt;&#39; does not <br>&gt;        // conform to protocol &#39;Hashable&#39;”<br>&gt; <br>&gt; <br>&gt; B. When letting Swift infer the type of collections of “Array” from<br>&gt;   literals another inconsistency comes to light:<br>&gt; <br>&gt; <br>&gt; B.1. “Array” as outer type behaves IMHO perfectly:<br>&gt; <br>&gt;    var testArray = [ [ 1, 2, 4, 8 ], [ 1, 3, 9, 27 ] ]<br>&gt;    print(testArray.dynamicType)<br>&gt;        // prints “Array&lt;Array&lt;Int&gt;&gt;”<br>&gt;    testArray.append( [ 1, &quot;five&quot;, 25, 625 ] );<br>&gt;        // compile time error “Cannot convert value of &#39;String&#39; to<br>&gt;        // expected element type &#39;Int&#39;”; type safe<br>&gt; <br>&gt; <br>&gt; B.2. “Set” as outer type works but there is no type safety:<br>&gt; <br>&gt;    var testSet: Set = [ [ 1, 2, 4, 8 ], [ 1, 3, 9, 27 ] ]<br>&gt;    print(testSet.dynamicType)<br>&gt;        // prints “Set&lt;NSArray&gt;”<br>&gt;    testSet.insert( [ 1, &quot;five&quot;, 25, 625 ] )<br>&gt;        // neither run time nor compile time errors; no type safety<br>&gt; <br>&gt; <br>&gt; B.3. The same goes for “Dictionary” as outer type:<br>&gt; <br>&gt;    var testDictionary = [<br>&gt;        [ 1, 2, 4, 8 ]: &quot;Powers of Two&quot;,<br>&gt;        [ 1, 3, 9, 27 ]: &quot;Powers of Three&quot;,<br>&gt;    ]<br>&gt;    print(testDictionary.dynamicType)<br>&gt;        // prints &quot;Dictionary&lt;NSArray, String&gt;&quot;<br>&gt;    testDictionary[ [ 1, &quot;five&quot;, 25, 625 ] ] = &quot;Powers of Five&quot;<br>&gt;        // neither run time nor compile time errors; no type safety<br>&gt; <br>&gt; <br>&gt; <br>&gt; — — - Wolfgang H.<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
