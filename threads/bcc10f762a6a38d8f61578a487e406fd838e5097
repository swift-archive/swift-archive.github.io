<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b35b44357e4cca3a1de39ba1199c9ab5?s=50"></div><header><strong>Seriously! Freeze Swift For Two Years After Release 3.0 !</strong> from <string>ted van gaalen</string> &lt;tedvgiosdev at gmail.com&gt;<p>July  6, 2016 at 08:00:00pm</p></header><div class="content"><p>Hi there<br></p><p>From the perspective from many active programmers<br>that use Swift (not objective C anymore) I am  not<br>very happy by having to change<br>program source all the time:   <br> <br>Therefore after Swift 3.0 is released I’d recommend kindly:<br></p><p><br>Freeze Swift For Some Time! <br>Do Not Change AnyThing For At Least 2 Years.<br>(Yes you’ve read that correctly: two years.)<br></p><p>Still there? OK, read on:<br></p><p>In the mean time, you’ll have the great opportunity<br>to fine-tune compiler and run time systems, to eliminate<br>the few bugs there and make it blazingly fast!<br></p><p>In two (or more) years,  there are enough Real Users (programmers) <br>that by then will have enough practical experience with Swift, which<br>might play a more solid role in improving Swift, and of course,<br>are extremely happy with Swift, and that it is not changed<br>all the time, So that they can concentrate on writing cool,<br>reliable and decent programs, instead of revising it all<br>the time! <br></p><p>After such time, and much more intensive and practical usage, <br>it becomes clear, what is good in Swift and what is not.  <br>What happens now, for instance, is that some base their “statistics” of which <br>language elements etc. are frequently used or not, merely upon scanning <br>a codebase of the relatively few (compared with e.g. ObjC, Java or C#) programmers<br>that use Swift now<br></p><p>Imho, Swift has not yet been in use long enough. It needs a prolonged time <br>because now, most users have relatively little experience using Swift, <br>thus the way they program now is not really representative with what one really can do<br>with this powerful language, compared to experienced (years, not months) <br>programmers in other languages. <br>Still a lot has to be discovered, has to settle and form good mental pictures in <br>programmer’s minds. It is all going a bit too fast, I think.<br></p><p><br>Please (if you did’t already) realize that already many source<br>code all over the world is written in Swift therefore it is very, very<br>important that backwards compatibility should be preserved as much <br>as possible. because  backwards-breaking-changes are a disaster<br>to companies/individuals that have already hundreds or thousands<br>of programs written in Swift.<br></p><p>For comparison, until recently I did also programming projects on IBM<br>mainframes for banks, insurance companies etc. The systems they use consists<br>(per company) of literally thousands of Cobol and/or PL/1 programs written<br>in all the years from ca 1970 until now. Still, one can take a program written<br>in 1970 which compiles and runs flawlessly without any modification!<br>All is backward compatible. If you would break backward<br>compatibility in this domain you would probably be kicked of the planet..<br></p><p><br>But even if we remain in macOS or iOS development, a huge amount of source<br>code has been written in Objective C. Everyone would scream hell if you took<br>out or change language elements.. <br>So please don’t. (it’s unnecessary) <br></p><p><br>When Swift arrived, to me, it had already everything I need, not really missing anything.<br>Of course, a programming language -like all things in life- is never perfect.<br></p><p>To me it was also perfectly OK that Swift wasn’t open source, because those that<br>have made Swift did a very good job. So one could even start thinking, why<br>open source Swift? Why not leave it to Apple? <br>But I guess I won’t make many friends asking this..<br>And I also realize that many good ideas comes from open source.<br></p><p><br>To me, Swift 2.2 and also 3.0  is fine. <br>so, after that:<br>you don’t have to change a thing.<br>it works and has everything I need<br>and is fast and stable. <br>stop removing things.<br>thanks.<br></p><p><br>Kind Regards from beautiful Speyer.de in Germany<br></p><p>TedvG<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2024f9524b1e51a54c4251abf0c34f50?s=50"></div><header><strong>Seriously! Freeze Swift For Two Years After Release 3.0 !</strong> from <string>Saagar Jha</string> &lt;saagarjha28 at gmail.com&gt;<p>July  6, 2016 at 06:00:00pm</p></header><div class="content"><p>Most source breaking changes will be made in Swift 3. From now on code<br>should be mostly backwards compatible.<br></p><p>On Wed, Jul 6, 2016 at 11:28 AM Ted F.A. van Gaalen via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hi there<br>&gt;<br>&gt; From the perspective from many active programmers<br>&gt; that use Swift (not objective C anymore) I am  not<br>&gt; very happy by having to change<br>&gt; program source all the time:<br>&gt;<br>&gt; Therefore after Swift 3.0 is released I’d recommend kindly:<br>&gt;<br>&gt;<br>&gt; Freeze Swift For Some Time!<br>&gt; Do Not Change AnyThing For At Least 2 Years.<br>&gt; (Yes you’ve read that correctly: two years.)<br>&gt;<br>&gt; Still there? OK, read on:<br>&gt;<br>&gt; In the mean time, you’ll have the great opportunity<br>&gt; to fine-tune compiler and run time systems, to eliminate<br>&gt; the few bugs there and make it blazingly fast!<br>&gt;<br>&gt; In two (or more) years,  there are enough Real Users (programmers)<br>&gt; that by then will have enough practical experience with Swift, which<br>&gt; might play a more solid role in improving Swift, and of course,<br>&gt; are extremely happy with Swift, and that it is not changed<br>&gt; all the time, So that they can concentrate on writing cool,<br>&gt; reliable and decent programs, instead of revising it all<br>&gt; the time!<br>&gt;<br>&gt; After such time, and much more intensive and practical usage,<br>&gt; it becomes clear, what is good in Swift and what is not.<br>&gt; What happens now, for instance, is that some base their “statistics” of<br>&gt; which<br>&gt; language elements etc. are frequently used or not, merely upon scanning<br>&gt; a codebase of the relatively few (compared with e.g. ObjC, Java or C#)<br>&gt; programmers<br>&gt; that use Swift now<br>&gt;<br>&gt; Imho, Swift has not yet been in use long enough. It needs a prolonged time<br>&gt; because now, most users have relatively little experience using Swift,<br>&gt; thus the way they program now is not really representative with what one<br>&gt; really can do<br>&gt; with this powerful language, compared to experienced (years, not months)<br>&gt; programmers in other languages.<br>&gt; Still a lot has to be discovered, has to settle and form good mental<br>&gt; pictures in<br>&gt; programmer’s minds. It is all going a bit too fast, I think.<br>&gt;<br>&gt;<br>&gt; Please (if you did’t already) realize that already many source<br>&gt; code all over the world is written in Swift therefore it is very, very<br>&gt; important that backwards compatibility should be preserved as much<br>&gt; as possible. because  backwards-breaking-changes are a disaster<br>&gt; to companies/individuals that have already hundreds or thousands<br>&gt; of programs written in Swift.<br>&gt;<br>&gt; For comparison, until recently I did also programming projects on IBM<br>&gt; mainframes for banks, insurance companies etc. The systems they use<br>&gt; consists<br>&gt; (per company) of literally thousands of Cobol and/or PL/1 programs written<br>&gt; in all the years from ca 1970 until now. Still, one can take a program<br>&gt; written<br>&gt; in 1970 which compiles and runs flawlessly without any modification!<br>&gt; All is backward compatible. If you would break backward<br>&gt; compatibility in this domain you would probably be kicked of the planet..<br>&gt;<br>&gt;<br>&gt; But even if we remain in macOS or iOS development, a huge amount of source<br>&gt; code has been written in Objective C. Everyone would scream hell if you<br>&gt; took<br>&gt; out or change language elements..<br>&gt; So please don’t. (it’s unnecessary)<br>&gt;<br>&gt;<br>&gt; When Swift arrived, to me, it had already everything I need, not really<br>&gt; missing anything.<br>&gt; Of course, a programming language -like all things in life- is never<br>&gt; perfect.<br>&gt;<br>&gt; To me it was also perfectly OK that Swift wasn’t open source, because<br>&gt; those that<br>&gt; have made Swift did a very good job. So one could even start thinking, why<br>&gt; open source Swift? Why not leave it to Apple?<br>&gt; But I guess I won’t make many friends asking this..<br>&gt; And I also realize that many good ideas comes from open source.<br>&gt;<br>&gt;<br>&gt; To me, Swift 2.2 and also 3.0  is fine.<br>&gt; so, after that:<br>&gt; you don’t have to change a thing.<br>&gt; it works and has everything I need<br>&gt; and is fast and stable.<br>&gt; stop removing things.<br>&gt; thanks.<br>&gt;<br>&gt;<br>&gt; Kind Regards from beautiful Speyer.de in Germany<br>&gt;<br>&gt; TedvG<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-- <br>-Saagar Jha<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160706/cffc9623/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Seriously! Freeze Swift For Two Years After Release 3.0 !</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>July  7, 2016 at 08:00:00am</p></header><div class="content"><p>Regards<br>LM<br>(From mobile)<br></p><p>&gt; On Jul 6, 2016, at 8:28 PM, Ted F.A. van Gaalen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi there<br>&gt; <br>&gt; From the perspective from many active programmers<br>&gt; that use Swift (not objective C anymore) I am  not<br>&gt; very happy by having to change<br>&gt; program source all the time:   <br>&gt; <br>&gt; Therefore after Swift 3.0 is released I’d recommend kindly:<br>&gt; <br>&gt; <br>&gt; Freeze Swift For Some Time! <br>&gt; Do Not Change AnyThing For At Least 2 Years.<br>&gt; (Yes you’ve read that correctly: two years.)<br>&gt; <br>&gt; Still there? OK, read on:<br>&gt; <br>&gt; In the mean time, you’ll have the great opportunity<br>&gt; to fine-tune compiler and run time systems, to eliminate<br>&gt; the few bugs there and make it blazingly fast!<br>&gt; <br>&gt; In two (or more) years,  there are enough Real Users (programmers) <br>&gt; that by then will have enough practical experience with Swift, which<br>&gt; might play a more solid role in improving Swift, and of course,<br>&gt; are extremely happy with Swift, and that it is not changed<br>&gt; all the time, So that they can concentrate on writing cool,<br>&gt; reliable and decent programs, instead of revising it all<br>&gt; the time! <br>&gt; <br>&gt; After such time, and much more intensive and practical usage, <br>&gt; it becomes clear, what is good in Swift and what is not.  <br>&gt; What happens now, for instance, is that some base their “statistics” of which <br>&gt; language elements etc. are frequently used or not, merely upon scanning <br>&gt; a codebase of the relatively few (compared with e.g. ObjC, Java or C#) programmers<br>&gt; that use Swift now<br>&gt; <br>&gt; Imho, Swift has not yet been in use long enough. It needs a prolonged time <br>&gt; because now, most users have relatively little experience using Swift, <br>&gt; thus the way they program now is not really representative with what one really can do<br>&gt; with this powerful language, compared to experienced (years, not months) <br>&gt; programmers in other languages. <br>&gt; Still a lot has to be discovered, has to settle and form good mental pictures in <br>&gt; programmer’s minds. It is all going a bit too fast, I think.<br>&gt; <br>&gt; <br>&gt; Please (if you did’t already) realize that already many source<br>&gt; code all over the world is written in Swift therefore it is very, very<br>&gt; important that backwards compatibility should be preserved as much <br>&gt; as possible. because  backwards-breaking-changes are a disaster<br>&gt; to companies/individuals that have already hundreds or thousands<br>&gt; of programs written in Swift.<br></p><p>The fact that some people jumped early on a not yet finished language should not constitute a jail for everyone else. Swift3 is starting to make a lot more sense, but it is still IMHO far from polished. We will live with 3, but if i knew this was the end of the road, i&#39;d immediately push every large corp project i know to c#/xamarin, or even phonegap/typescript.<br></p><p><br>&gt; <br>&gt; For comparison, until recently I did also programming projects on IBM<br>&gt; mainframes for banks, insurance companies etc. The systems they use consists<br>&gt; (per company) of literally thousands of Cobol and/or PL/1 programs written<br>&gt; in all the years from ca 1970 until now. Still, one can take a program written<br>&gt; in 1970 which compiles and runs flawlessly without any modification!<br></p><p>I had an interesting conversation with the manager of the java group at apple 7 years ago who equated this behavior with being attributes of a &#39;failed technology&#39; (then equally applied to java and cobol).<br></p><p><br>&gt; All is backward compatible. If you would break backward<br>&gt; compatibility in this domain you would probably be kicked of the planet..<br>&gt; <br>&gt; <br>&gt; But even if we remain in macOS or iOS development, a huge amount of source<br>&gt; code has been written in Objective C. Everyone would scream hell if you took<br>&gt; out or change language elements.. <br>&gt; So please don’t. (it’s unnecessary) <br>&gt; <br>&gt; <br>&gt; When Swift arrived, to me, it had already everything I need, not really missing anything.<br>&gt; Of course, a programming language -like all things in life- is never perfect.<br>&gt; <br>&gt; To me it was also perfectly OK that Swift wasn’t open source, because those that<br>&gt; have made Swift did a very good job. So one could even start thinking, why<br>&gt; open source Swift? Why not leave it to Apple? <br>&gt; But I guess I won’t make many friends asking this..<br>&gt; And I also realize that many good ideas comes from open source.<br>&gt; <br>&gt; <br>&gt; To me, Swift 2.2 and also 3.0  is fine. <br>&gt; so, after that:<br>&gt; you don’t have to change a thing.<br>&gt; it works and has everything I need<br>&gt; and is fast and stable. <br>&gt; stop removing things.<br>&gt; thanks.<br>&gt; <br>&gt; <br>&gt; Kind Regards from beautiful Speyer.de in Germany<br>&gt; <br>&gt; TedvG<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e9b374b9587bd8da1a1a027c8716ac0d?s=50"></div><header><strong>Seriously! Freeze Swift For Two Years After Release 3.0 !</strong> from <string>Rod Brown</string> &lt;rodney.brown6 at icloud.com&gt;<p>July  7, 2016 at 07:00:00pm</p></header><div class="content"><p>Comments inline (resent to swift evolution)<br></p><p>&gt; On 7 Jul. 2016, at 4:28 am, Ted F.A. van Gaalen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi there<br>&gt; <br>&gt; From the perspective from many active programmers<br>&gt; that use Swift (not objective C anymore) I am  not<br>&gt; very happy by having to change<br>&gt; program source all the time:   <br>&gt; <br>&gt; Therefore after Swift 3.0 is released I’d recommend kindly:<br>&gt; <br>&gt; <br>&gt; Freeze Swift For Some Time! <br>&gt; Do Not Change AnyThing For At Least 2 Years.<br>&gt; (Yes you’ve read that correctly: two years.)<br></p><p>Freezing seems antithetical to the evolution of new features. Avoiding source-breaking changes is reasonable, and I believe this is plan going forward. Even then, making this a hard rule still ends up with the same issue: the more we delay changes, the more we just push out the inevitable and drag the pain out longer.<br></p><p>&gt; <br>&gt; Still there? OK, read on:<br>&gt; <br>&gt; In the mean time, you’ll have the great opportunity<br>&gt; to fine-tune compiler and run time systems, to eliminate<br>&gt; the few bugs there and make it blazingly fast!<br></p><p>This discounts the fact that a lot of the speed improvements don&#39;t simply come from a smarter compiler. Many improvements in speed and compilation are held back by a lack of guarantees that the compiler can rely on due to the language&#39;s limitations. Swift&#39;s efficiency and performance comes from the language-specific guarantees that the compiler can leverage. While there are some guarantees that aren&#39;t currently leveraged in the compiler, this statement appears to some extent contradictory. &quot;Make it faster, but don&#39;t change anything!”<br></p><p>&gt; In two (or more) years,  there are enough Real Users (programmers) <br>&gt; that by then will have enough practical experience with Swift, which<br>&gt; might play a more solid role in improving Swift, and of course,<br>&gt; are extremely happy with Swift, and that it is not changed<br>&gt; all the time, So that they can concentrate on writing cool,<br>&gt; reliable and decent programs, instead of revising it all<br>&gt; the time! <br></p><p>So we wait to get a larger user base so we hurt *more* people when we do this? Why?<br></p><p>&gt; <br>&gt; After such time, and much more intensive and practical usage, <br>&gt; it becomes clear, what is good in Swift and what is not. <br></p><p>Because the current team don&#39;t have enough experience with swift to work it out, but a year or two more of doing the same thing without any changes will somehow give them that experience?<br></p><p>&gt; What happens now, for instance, is that some base their “statistics” of which <br>&gt; language elements etc. are frequently used or not, merely upon scanning <br>&gt; a codebase of the relatively few (compared with e.g. ObjC, Java or C#) programmers<br>&gt; that use Swift now<br></p><p>Statistics aren&#39;t everything. Focusing on a few language elements at the neglect of the rest is ill-advised. Do you build a house but only focus on building a foundation well only in the rooms you expect people to walk in?<br></p><p>&gt; <br>&gt; Imho, Swift has not yet been in use long enough. It needs a prolonged time <br>&gt; because now, most users have relatively little experience using Swift, <br>&gt; thus the way they program now is not really representative with what one really can do<br>&gt; with this powerful language, compared to experienced (years, not months) <br>&gt; programmers in other languages. <br>&gt; Still a lot has to be discovered, has to settle and form good mental pictures in <br>&gt; programmer’s minds. It is all going a bit too fast, I think.<br>&gt; <br>&gt; <br>&gt; Please (if you did’t already) realize that already many source<br>&gt; code all over the world is written in Swift therefore it is very, very<br>&gt; important that backwards compatibility should be preserved as much <br>&gt; as possible. because  backwards-breaking-changes are a disaster<br>&gt; to companies/individuals that have already hundreds or thousands<br>&gt; of programs written in Swift.<br></p><p>I think everyone is aware there are commercial and logistical issues with continuing to change Swift. That&#39;s why there was such a rush to bake every source-breaking change into Swift 3. There will have to be a very good justification going forward for source breaking changes.<br></p><p>&gt; <br>&gt; For comparison, until recently I did also programming projects on IBM<br>&gt; mainframes for banks, insurance companies etc. The systems they use consists<br>&gt; (per company) of literally thousands of Cobol and/or PL/1 programs written<br>&gt; in all the years from ca 1970 until now. Still, one can take a program written<br>&gt; in 1970 which compiles and runs flawlessly without any modification!<br>&gt; All is backward compatible. If you would break backward<br>&gt; compatibility in this domain you would probably be kicked of the planet..<br></p><p>If we went by this reasoning they should never have changed anything since Swift 1. If backwards compatibility and guaranteed compilation is a requirement, nothing would ever improve.<br></p><p>&gt; <br>&gt; But even if we remain in macOS or iOS development, a huge amount of source<br>&gt; code has been written in Objective C. Everyone would scream hell if you took<br>&gt; out or change language elements.. <br>&gt; So please don’t. (it’s unnecessary) <br></p><p>In the opinion of the vast majority here, the benefits of quickly changing things at the start of Swift&#39;s life will outweigh the pain to the early adopters, and there are mitigation strategies in place.<br></p><p>&gt; <br>&gt; <br>&gt; When Swift arrived, to me, it had already everything I need, not really missing anything.<br>&gt; Of course, a programming language -like all things in life- is never perfect.<br></p><p>And yet there have been massive changes to swift that have radically improved it since then.<br></p><p>&gt; <br>&gt; To me it was also perfectly OK that Swift wasn’t open source, because those that<br>&gt; have made Swift did a very good job. So one could even start thinking, why<br>&gt; open source Swift? Why not leave it to Apple? <br>&gt; But I guess I won’t make many friends asking this..<br>&gt; And I also realize that many good ideas comes from open source.<br>&gt; <br>&gt; <br>&gt; To me, Swift 2.2 and also 3.0  is fine. <br>&gt; so, after that:<br>&gt; you don’t have to change a thing.<br>&gt; it works and has everything I need<br>&gt; and is fast and stable. <br>&gt; stop removing things.<br>&gt; thanks.<br></p><p>The crux of your argument seems to be: &quot;Make it better, but don&#39;t change anything!&quot;<br></p><p>&gt; <br>&gt; <br>&gt; Kind Regards from beautiful Speyer.de &lt;http://speyer.de/&gt; in Germany<br>&gt; <br>&gt; TedvG<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160707/8cd30230/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/32d8eca60f1bbb516804a3857528b2e1?s=50"></div><header><strong>Seriously! Freeze Swift For Two Years After Release 3.0 !</strong> from <string>ChanMaxthon</string> &lt;xcvista at me.com&gt;<p>July  7, 2016 at 07:00:00pm</p></header><div class="content"><p>Code compiled well with the original ISO C compiler still compiles well with the latest C standards.<br></p><p>I just found some of my original Visual Basic .net 2002 code written just after it was released, and it builds and works beautifully in Visual Basic .net 2015. (I did not join the Apple Developer family until 2012, before that I was a Windows desktop and Windows Mobile developer)<br></p><p>One of my projects written in 2010 and using Visual Studio 2010 still works bug-free on Windows 10 and still builds under Visual Studio 2015, despite the project being long abandoned.<br></p><p><br></p><p>Sent from my iPhone<br></p><p>&gt; On Jul 7, 2016, at 17:38, Rod Brown via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Comments inline (resent to swift evolution)<br>&gt; <br>&gt;&gt; On 7 Jul. 2016, at 4:28 am, Ted F.A. van Gaalen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi there<br>&gt;&gt; <br>&gt;&gt; From the perspective from many active programmers<br>&gt;&gt; that use Swift (not objective C anymore) I am  not<br>&gt;&gt; very happy by having to change<br>&gt;&gt; program source all the time:   <br>&gt;&gt; <br>&gt;&gt; Therefore after Swift 3.0 is released I’d recommend kindly:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Freeze Swift For Some Time! <br>&gt;&gt; Do Not Change AnyThing For At Least 2 Years.<br>&gt;&gt; (Yes you’ve read that correctly: two years.)<br>&gt; <br>&gt; Freezing seems antithetical to the evolution of new features. Avoiding source-breaking changes is reasonable, and I believe this is plan going forward. Even then, making this a hard rule still ends up with the same issue: the more we delay changes, the more we just push out the inevitable and drag the pain out longer.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Still there? OK, read on:<br>&gt;&gt; <br>&gt;&gt; In the mean time, you’ll have the great opportunity<br>&gt;&gt; to fine-tune compiler and run time systems, to eliminate<br>&gt;&gt; the few bugs there and make it blazingly fast!<br>&gt; <br>&gt; This discounts the fact that a lot of the speed improvements don&#39;t simply come from a smarter compiler. Many improvements in speed and compilation are held back by a lack of guarantees that the compiler can rely on due to the language&#39;s limitations. Swift&#39;s efficiency and performance comes from the language-specific guarantees that the compiler can leverage. While there are some guarantees that aren&#39;t currently leveraged in the compiler, this statement appears to some extent contradictory. &quot;Make it faster, but don&#39;t change anything!”<br>&gt; <br>&gt;&gt; In two (or more) years,  there are enough Real Users (programmers) <br>&gt;&gt; that by then will have enough practical experience with Swift, which<br>&gt;&gt; might play a more solid role in improving Swift, and of course,<br>&gt;&gt; are extremely happy with Swift, and that it is not changed<br>&gt;&gt; all the time, So that they can concentrate on writing cool,<br>&gt;&gt; reliable and decent programs, instead of revising it all<br>&gt;&gt; the time! <br>&gt; <br>&gt; So we wait to get a larger user base so we hurt *more* people when we do this? Why?<br>&gt; <br>&gt;&gt; <br>&gt;&gt; After such time, and much more intensive and practical usage, <br>&gt;&gt; it becomes clear, what is good in Swift and what is not. <br>&gt; <br>&gt; Because the current team don&#39;t have enough experience with swift to work it out, but a year or two more of doing the same thing without any changes will somehow give them that experience?<br>&gt; <br>&gt;&gt; What happens now, for instance, is that some base their “statistics” of which <br>&gt;&gt; language elements etc. are frequently used or not, merely upon scanning <br>&gt;&gt; a codebase of the relatively few (compared with e.g. ObjC, Java or C#) programmers<br>&gt;&gt; that use Swift now<br>&gt; <br>&gt; Statistics aren&#39;t everything. Focusing on a few language elements at the neglect of the rest is ill-advised. Do you build a house but only focus on building a foundation well only in the rooms you expect people to walk in?<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Imho, Swift has not yet been in use long enough. It needs a prolonged time <br>&gt;&gt; because now, most users have relatively little experience using Swift, <br>&gt;&gt; thus the way they program now is not really representative with what one really can do<br>&gt;&gt; with this powerful language, compared to experienced (years, not months) <br>&gt;&gt; programmers in other languages. <br>&gt;&gt; Still a lot has to be discovered, has to settle and form good mental pictures in <br>&gt;&gt; programmer’s minds. It is all going a bit too fast, I think.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Please (if you did’t already) realize that already many source<br>&gt;&gt; code all over the world is written in Swift therefore it is very, very<br>&gt;&gt; important that backwards compatibility should be preserved as much <br>&gt;&gt; as possible. because  backwards-breaking-changes are a disaster<br>&gt;&gt; to companies/individuals that have already hundreds or thousands<br>&gt;&gt; of programs written in Swift.<br>&gt; <br>&gt; I think everyone is aware there are commercial and logistical issues with continuing to change Swift. That&#39;s why there was such a rush to bake every source-breaking change into Swift 3. There will have to be a very good justification going forward for source breaking changes.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; For comparison, until recently I did also programming projects on IBM<br>&gt;&gt; mainframes for banks, insurance companies etc. The systems they use consists<br>&gt;&gt; (per company) of literally thousands of Cobol and/or PL/1 programs written<br>&gt;&gt; in all the years from ca 1970 until now. Still, one can take a program written<br>&gt;&gt; in 1970 which compiles and runs flawlessly without any modification!<br>&gt;&gt; All is backward compatible. If you would break backward<br>&gt;&gt; compatibility in this domain you would probably be kicked of the planet..<br>&gt; <br>&gt; If we went by this reasoning they should never have changed anything since Swift 1. If backwards compatibility and guaranteed compilation is a requirement, nothing would ever improve.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; But even if we remain in macOS or iOS development, a huge amount of source<br>&gt;&gt; code has been written in Objective C. Everyone would scream hell if you took<br>&gt;&gt; out or change language elements.. <br>&gt;&gt; So please don’t. (it’s unnecessary) <br>&gt; <br>&gt; In the opinion of the vast majority here, the benefits of quickly changing things at the start of Swift&#39;s life will outweigh the pain to the early adopters, and there are mitigation strategies in place.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; When Swift arrived, to me, it had already everything I need, not really missing anything.<br>&gt;&gt; Of course, a programming language -like all things in life- is never perfect.<br>&gt; <br>&gt; And yet there have been massive changes to swift that have radically improved it since then.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; To me it was also perfectly OK that Swift wasn’t open source, because those that<br>&gt;&gt; have made Swift did a very good job. So one could even start thinking, why<br>&gt;&gt; open source Swift? Why not leave it to Apple? <br>&gt;&gt; But I guess I won’t make many friends asking this..<br>&gt;&gt; And I also realize that many good ideas comes from open source.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; To me, Swift 2.2 and also 3.0  is fine. <br>&gt;&gt; so, after that:<br>&gt;&gt; you don’t have to change a thing.<br>&gt;&gt; it works and has everything I need<br>&gt;&gt; and is fast and stable. <br>&gt;&gt; stop removing things.<br>&gt;&gt; thanks.<br>&gt; <br>&gt; The crux of your argument seems to be: &quot;Make it better, but don&#39;t change anything!&quot;<br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Kind Regards from beautiful Speyer.de in Germany<br>&gt;&gt; <br>&gt;&gt; TedvG<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160707/1f99eada/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>Seriously! Freeze Swift For Two Years After Release 3.0 !</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>July  7, 2016 at 01:00:00pm</p></header><div class="content"><p>Both are examples of languages that do not have a lot of sytax/features/complexity. Such languages are more easily production-ready from day 1.<br></p><p>The major issue with Swift and its evolution is how to interact with existing APIs that are written in another language (ObjC), which is vastly different. When you look at the proposals for Swift 3, lot of them are focused on interoperability and refining the Foundation API.<br></p><p>These things aren&#39;t easy to design and they even may look well at the design stage, but time proves that they need some tweaking. It also requires a lot of work and some features require others to be present first for the others to be implemented.<br></p><p>Sure, we could maintain backward compatibility by having name aliases, etc. but it was clearly noted that neither API nor ABI is final for Swift 1 or 2. It&#39;s better to shed these off rather than litter the language.<br></p><p>Moreover, most changes will be automatically migrated by Xcode&#39;s Migration Assistant...<br></p><p>&gt; On Jul 7, 2016, at 1:17 PM, ChanMaxthon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Code compiled well with the original ISO C compiler still compiles well with the latest C standards.<br>&gt; <br>&gt; I just found some of my original Visual Basic .net 2002 code written just after it was released, and it builds and works beautifully in Visual Basic .net 2015. (I did not join the Apple Developer family until 2012, before that I was a Windows desktop and Windows Mobile developer)<br>&gt; <br>&gt; One of my projects written in 2010 and using Visual Studio 2010 still works bug-free on Windows 10 and still builds under Visual Studio 2015, despite the project being long abandoned.<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt; On Jul 7, 2016, at 17:38, Rod Brown via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Comments inline (resent to swift evolution)<br>&gt;&gt; <br>&gt;&gt;&gt; On 7 Jul. 2016, at 4:28 am, Ted F.A. van Gaalen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi there<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; From the perspective from many active programmers<br>&gt;&gt;&gt; that use Swift (not objective C anymore) I am  not<br>&gt;&gt;&gt; very happy by having to change<br>&gt;&gt;&gt; program source all the time:   <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Therefore after Swift 3.0 is released I’d recommend kindly:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Freeze Swift For Some Time! <br>&gt;&gt;&gt; Do Not Change AnyThing For At Least 2 Years.<br>&gt;&gt;&gt; (Yes you’ve read that correctly: two years.)<br>&gt;&gt; <br>&gt;&gt; Freezing seems antithetical to the evolution of new features. Avoiding source-breaking changes is reasonable, and I believe this is plan going forward. Even then, making this a hard rule still ends up with the same issue: the more we delay changes, the more we just push out the inevitable and drag the pain out longer.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Still there? OK, read on:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In the mean time, you’ll have the great opportunity<br>&gt;&gt;&gt; to fine-tune compiler and run time systems, to eliminate<br>&gt;&gt;&gt; the few bugs there and make it blazingly fast!<br>&gt;&gt; <br>&gt;&gt; This discounts the fact that a lot of the speed improvements don&#39;t simply come from a smarter compiler. Many improvements in speed and compilation are held back by a lack of guarantees that the compiler can rely on due to the language&#39;s limitations. Swift&#39;s efficiency and performance comes from the language-specific guarantees that the compiler can leverage. While there are some guarantees that aren&#39;t currently leveraged in the compiler, this statement appears to some extent contradictory. &quot;Make it faster, but don&#39;t change anything!”<br>&gt;&gt; <br>&gt;&gt;&gt; In two (or more) years,  there are enough Real Users (programmers) <br>&gt;&gt;&gt; that by then will have enough practical experience with Swift, which<br>&gt;&gt;&gt; might play a more solid role in improving Swift, and of course,<br>&gt;&gt;&gt; are extremely happy with Swift, and that it is not changed<br>&gt;&gt;&gt; all the time, So that they can concentrate on writing cool,<br>&gt;&gt;&gt; reliable and decent programs, instead of revising it all<br>&gt;&gt;&gt; the time! <br>&gt;&gt; <br>&gt;&gt; So we wait to get a larger user base so we hurt *more* people when we do this? Why?<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; After such time, and much more intensive and practical usage, <br>&gt;&gt;&gt; it becomes clear, what is good in Swift and what is not. <br>&gt;&gt; <br>&gt;&gt; Because the current team don&#39;t have enough experience with swift to work it out, but a year or two more of doing the same thing without any changes will somehow give them that experience?<br>&gt;&gt; <br>&gt;&gt;&gt; What happens now, for instance, is that some base their “statistics” of which <br>&gt;&gt;&gt; language elements etc. are frequently used or not, merely upon scanning <br>&gt;&gt;&gt; a codebase of the relatively few (compared with e.g. ObjC, Java or C#) programmers<br>&gt;&gt;&gt; that use Swift now<br>&gt;&gt; <br>&gt;&gt; Statistics aren&#39;t everything. Focusing on a few language elements at the neglect of the rest is ill-advised. Do you build a house but only focus on building a foundation well only in the rooms you expect people to walk in?<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Imho, Swift has not yet been in use long enough. It needs a prolonged time <br>&gt;&gt;&gt; because now, most users have relatively little experience using Swift, <br>&gt;&gt;&gt; thus the way they program now is not really representative with what one really can do<br>&gt;&gt;&gt; with this powerful language, compared to experienced (years, not months) <br>&gt;&gt;&gt; programmers in other languages. <br>&gt;&gt;&gt; Still a lot has to be discovered, has to settle and form good mental pictures in <br>&gt;&gt;&gt; programmer’s minds. It is all going a bit too fast, I think.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Please (if you did’t already) realize that already many source<br>&gt;&gt;&gt; code all over the world is written in Swift therefore it is very, very<br>&gt;&gt;&gt; important that backwards compatibility should be preserved as much <br>&gt;&gt;&gt; as possible. because  backwards-breaking-changes are a disaster<br>&gt;&gt;&gt; to companies/individuals that have already hundreds or thousands<br>&gt;&gt;&gt; of programs written in Swift.<br>&gt;&gt; <br>&gt;&gt; I think everyone is aware there are commercial and logistical issues with continuing to change Swift. That&#39;s why there was such a rush to bake every source-breaking change into Swift 3. There will have to be a very good justification going forward for source breaking changes.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For comparison, until recently I did also programming projects on IBM<br>&gt;&gt;&gt; mainframes for banks, insurance companies etc. The systems they use consists<br>&gt;&gt;&gt; (per company) of literally thousands of Cobol and/or PL/1 programs written<br>&gt;&gt;&gt; in all the years from ca 1970 until now. Still, one can take a program written<br>&gt;&gt;&gt; in 1970 which compiles and runs flawlessly without any modification!<br>&gt;&gt;&gt; All is backward compatible. If you would break backward<br>&gt;&gt;&gt; compatibility in this domain you would probably be kicked of the planet..<br>&gt;&gt; <br>&gt;&gt; If we went by this reasoning they should never have changed anything since Swift 1. If backwards compatibility and guaranteed compilation is a requirement, nothing would ever improve.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But even if we remain in macOS or iOS development, a huge amount of source<br>&gt;&gt;&gt; code has been written in Objective C. Everyone would scream hell if you took<br>&gt;&gt;&gt; out or change language elements.. <br>&gt;&gt;&gt; So please don’t. (it’s unnecessary) <br>&gt;&gt; <br>&gt;&gt; In the opinion of the vast majority here, the benefits of quickly changing things at the start of Swift&#39;s life will outweigh the pain to the early adopters, and there are mitigation strategies in place.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When Swift arrived, to me, it had already everything I need, not really missing anything.<br>&gt;&gt;&gt; Of course, a programming language -like all things in life- is never perfect.<br>&gt;&gt; <br>&gt;&gt; And yet there have been massive changes to swift that have radically improved it since then.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To me it was also perfectly OK that Swift wasn’t open source, because those that<br>&gt;&gt;&gt; have made Swift did a very good job. So one could even start thinking, why<br>&gt;&gt;&gt; open source Swift? Why not leave it to Apple? <br>&gt;&gt;&gt; But I guess I won’t make many friends asking this..<br>&gt;&gt;&gt; And I also realize that many good ideas comes from open source.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To me, Swift 2.2 and also 3.0  is fine. <br>&gt;&gt;&gt; so, after that:<br>&gt;&gt;&gt; you don’t have to change a thing.<br>&gt;&gt;&gt; it works and has everything I need<br>&gt;&gt;&gt; and is fast and stable. <br>&gt;&gt;&gt; stop removing things.<br>&gt;&gt;&gt; thanks.<br>&gt;&gt; <br>&gt;&gt; The crux of your argument seems to be: &quot;Make it better, but don&#39;t change anything!&quot;<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Kind Regards from beautiful Speyer.de &lt;http://speyer.de/&gt; in Germany<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; TedvG<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;_______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160707/fbc50fe6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/46439321e8b5b5ba0944eef50e18c3a3?s=50"></div><header><strong>Seriously! Freeze Swift For Two Years After Release 3.0 !</strong> from <string>Jean-Denis Muys</string> &lt;jdmuys at gmail.com&gt;<p>July  7, 2016 at 02:00:00pm</p></header><div class="content"><p>Ted,<br></p><p>I basically disagree 100% with everything you wrote. I will not got into much details, but for me, technology that doesn’t evolve is dead technology.<br></p><p>Moreover, your main argument about large code bases, is not a good one: we now have migration tools that work quite well. They could be made even better, with some investment, that most (I think) would rather see invested in the leading edge.<br></p><p>Aversion to change is everywhere. It’s deeply engrained in us human beings. That’s why consultant make a living selling change management. I have seen people complain a lot about Apple releasing new versions of iOS for example. I have seen developers complain that Apple releases new versions of Xcode too frequently. I was even not too long ago in a position to do a web development job for a customer who wanted to support Internet Explorer 6. I have very little sympathy for such plights.<br></p><p>If you don’t want to maintain your Swift 2 code, don’t. But don’t prevent the rest of us from doing it, despite the efforts required.<br></p><p>I applaud the way the Swift team is handling those breaking changes, piling them up as early as possible, postponing additive changes to post 3.0. This is the way to minimise the efforts as much as possible. I hope that even then, source-breaking changes will continue to happen when they make sense. I am looking forward to a language that will get constantly better at enabling me to evolve my code in the most productive way. If my source code breaks, that is a very small price to pay.<br></p><p>Jean-Denis<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>Seriously! Freeze Swift For Two Years After Release 3.0 !</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>July  7, 2016 at 03:00:00pm</p></header><div class="content"><p>The designers of Swift have adopted a pragmatic approach to things: get a language that can be useful practically quickly, then improve it as things go. Its very Apple-like and I think it makes a lot of sense. We have a lot of useful changes in Swift 3.0, but the language is still far from complete. Recent discussions make it very obvious that some fundamental features are still in flux or are misunderstood (e.g the function argument label discussion), and the generics implementation has a lot of important stuff missing. Freezing Swift now  would mean suspending it in a beta state. <br></p><p>So, no, a strong disagree with the premise of this thread from me. <br></p><p>Best, <br></p><p> Taras<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Seriously! Freeze Swift For Two Years After Release 3.0 !</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>July  7, 2016 at 03:00:00pm</p></header><div class="content"><p>I&#39;m very much in the camp that doesn&#39;t mind breaking changes; of course we shouldn&#39;t be too cavalier about them either, but if a sound case can be made for why a breaking change is required, then we shouldn&#39;t be afraid to make the change either.<br></p><p>The biggest example that&#39;s impacted me in Swift 3, besides all the renaming, is probably the new Collection indexing scheme; while the previous system was functional enough in many cases, the new one is simply better, and takes a lot of burden away from the indices themselves to track minutia required for them to operate. It&#39;s been a bit of pain to transition some of my code, and I put a lot of time into working around the old system, but on the whole my code is now cleaner and more efficient.<br></p><p>So yeah, if the choice is between a language that is willing to make breaking changes that improve the language overall, compared to one that will remain stagnant and struggle to improve, then I&#39;m willing to suffer some broken code that needs tweaking every time; we have developer previews and now support for multiple toolchains to make this much easier to work with and to preview potential breakages and fix them in advance.<br></p><p>Lastly, I&#39;d say that even with version 3 fast approaching, Swift is still a very new language; some of its ideas were more successful than others, and some have been reevaluated in view of new features that overlap or replace them. I fully expect that in future there will be fewer breaking changes, but I think that trying to force that state too early is counterproductive, as it may restrict far more desirable improvements.<br></p><p>&gt; On 7 Jul 2016, at 14:16, Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The designers of Swift have adopted a pragmatic approach to things: get a language that can be useful practically quickly, then improve it as things go. Its very Apple-like and I think it makes a lot of sense. We have a lot of useful changes in Swift 3.0, but the language is still far from complete. Recent discussions make it very obvious that some fundamental features are still in flux or are misunderstood (e.g the function argument label discussion), and the generics implementation has a lot of important stuff missing. Freezing Swift now  would mean suspending it in a beta state. <br>&gt; <br>&gt; So, no, a strong disagree with the premise of this thread from me. <br>&gt; <br>&gt; Best, <br>&gt; <br>&gt; Taras<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/68d21c811b4f037d9cbd43013319f9b4?s=50"></div><header><strong>Seriously! Freeze Swift For Two Years After Release 3.0 !</strong> from <string>Muse M</string> &lt;james.lei65 at gmail.com&gt;<p>July  7, 2016 at 10:00:00pm</p></header><div class="content"><p>I would disagree to freeze API for 2 years when a large parts of proposal<br>by brilliants programmers and scientists (that where performance is) have<br>yet to implement features in 3.1, 3.5 to 4.0​ would be ideally to move<br>fast, break fast before it reach mature stage.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160707/071fde0f/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b35b44357e4cca3a1de39ba1199c9ab5?s=50"></div><header><strong>Avoiding back breaking changes and removals.</strong> from <string>ted van gaalen</string> &lt;tedvgiosdev at gmail.com&gt;<p>July 12, 2016 at 07:00:00pm</p></header><div class="content"><p>Hi Jean-Denis<br></p><p>please look at my response in-line further down.<br></p><p>I am also writing this text because I think<br>that the implications of back breaking chances<br>are severely underestimated.<br></p><p>Again, the scope of my writing concerns the situation after Swift 3.0<br></p><p>Veuillez recevoir, Monsieur, nos salutations distinguées.<br></p><p>Ted<br></p><p><br>&gt; On 07.07.2016, at 14:12, Jean-Denis Muys &lt;jdmuys at gmail.com&gt; wrote:<br>&gt; <br>&gt; Ted,<br>&gt; <br>&gt; I basically disagree 100% with everything you wrote.<br>Ok, it was a bit supercharged as in effect, I meant<br>only source breaking changes.<br></p><p>However also my recommendation to move a bit slower <br>for a year or two so that people (not only the Swift-evolution participants)<br>really have started using Swift is a consideration… to get<br>more matured feedback, which then can play an important<br>role in improving Swift further. <br></p><p>&gt; I will not got into much details, but for me, technology that doesn’t evolve is dead technology.<br></p><p>I agree with this of course! <br></p><p> The subject title I gave this thread: <br>&gt; &quot;Seriously! Freeze Swift For Two Years	After Release 3.0 !”<br></p><p>and also what I wrote was a bit over-dramatic. That is a bit my nature…:o) sorry. <br>Now  it has a more appropriate subject title as you can see above.<br></p><p>What I (but who am I?) would prefer is:<br></p><p>All improvements and changes should be supplemental only.<br>thus leaving what is already there intact.<br>      <br> ===================================================================<br> This Would 100%  Guarantee That  Everything Ever Built, Never Needs To Be Changed.<br> ===================================================================<br></p><p>(that is, within the scope and context of the programming language itself, of course) <br></p><p>This is certainly feasible and proven: there are a number of programming languages that<br>adhere to this basic rule. This is e.g. the case with the classical languages Cobol and PL/1 for<br>C, C++ for  example.<br> <br>&gt; <br>&gt; Moreover, your main argument about large code bases, is not a good one: we now have migration tools that work quite well. They could be made even better, with some investment, that most (I think) would rather see invested in the leading edge.<br></p><p>As I wrote before, I think that in many cases converters/ migration tools <br>are certainly helpful,however they work mostly scanning on a <br>statement-by-statement basis, <br>having &quot;not enough AI” to grasp and process the context <br>e.g. for a cluster of source lines…<br></p><p>Imho, it is nearly impossible to write a migration tool that catches everything<br>and automatically converts flawlessly.<br>Making such a migrator would probably use as much or even more effort<br>as making the Swift compiler itself.<br></p><p>I have worked for many years in IT-environments with extremely large<br>and often ancient code bases (Mainframe, banks insurance companies etc.)<br></p><p>In these environments,- even without source migration - <br>it is extremely difficult to apply changes to existing software, thousands of<br>sources scattered al over the place: a myriad of chaotic intertwined sub systems, <br>often badly connected via middle ware, chaotic file systems etc.  Yes, from time to time<br>change managers/firms are hired, however,  in many cases this makes it even worse.<br>Note that this is not a worst case scenario but the average large systems scenario.<br></p><p><br>&gt; Aversion to change is everywhere. It’s deeply engrained in us human beings.<br></p><p>Yes, very true, albeit that it is a very understandable feature of human intuition<br>as changes are risky in many cases. This does not imply that change<br>should be avoided at all times of course! Apparently I gave this impression <br>unintentionally in my previous writing. <br></p><p>Especially in IT , the reluctancy to change is very plausible if changes bring <br>severe risk of malfunctioning systems. For example changes to large bank’s <br>accounting systems literally consisting of thousands of programs, modules<br>and files and a few different databases simultaneously.. These systems are<br>extremely fragile.<br></p><p>When changes applied go wrong, it cause severe financial damage. <br>It happens many times as it is very hard to foresee the impact <br>and side-efects these changes might have in <br>large (and mostly hybrid) systems.<br></p><p>So imagine something so trivial as changing the Cobol assignment statement<br>&quot;MOVE A TO B.”  to  &quot;COPY A INTO B.&quot;<br>(which btw would have been more correct, because basically that is what it does)<br> <br>Even such a small change  can have an enormous impact. On top of that,<br>as changes to sources also need a conversion cycle when there is backwards <br>breaking the situation will be extremely difficult. <br>The example here is just a trivial case.  <br></p><p>A hypothetic but realistic example:<br></p><p>Swift is intended as a general purpose language, so, what prevents<br>us from writing a complete accounting system with Swift? <br></p><p>Let’s assume a company decides to (re)built its complete company-wide <br>accounting system using Swift as its main programming language. <br>About 40 Swift programmers are hired, they manage<br>to built this accounting system in even less that a year. <br>(which might be feasible because Swift is flexible and powerful) <br></p><p>The codebase for this hypothetic accounting system<br> (compared with codebases in say Java and/or Cobol)<br>could  contain (among other software, database etc.) <br>more than thousand Swift source files.<br>This is a realistic estimation.  <br></p><p>If, say, a year after completing this accounting system source compatibility<br>breaks, they are in real trouble.  (as with Java sometimes)<br>No, there is no time and  budget to rewrite and test! say, about 700 source files.<br>This is not an exaggeration. <br></p><p>Ergo: <br>If it can, the project management will only accept Swift<br> (or for that matter any other language/system ) <br>if and only if <br>there is an 100% guarantee that future changes <br>of the programming language <br>will not break existing code.<br></p><p><br>Chris has emphasized to me the following Swift goal / intention:<br></p><p>&gt; &quot;The primary goal of this release is to solidify and mature the Swift language and development experience.<br>&gt;  While source breaking changes to the language have been the norm for Swift 1 through 3, <br>&gt; we would like the Swift 3.x (and Swift 4+) languages to be as <br>&gt; source compatible with Swift 3.0 as reasonably possible.”<br></p><p>Well, that is positive, but imho not good enough.<br>There should be no source breaking changes at all.<br></p><p><br>&gt; That’s why consultant make a living selling change management.<br>Definitely not a job for me… :o)   <br></p><p><br>&gt; I have seen people complain a lot about Apple releasing new versions of iOS for example. I have seen developers complain that Apple releases new versions of Xcode too frequently.<br>Yes, people often complain and it is true imho that releases come a bit to often these days. <br>Oh the other hand, there are many large iOS  apps out there. <br></p><p>&gt; I was even not too long ago in a position to do a web development job for a customer who wanted to support Internet Explorer 6. I have very little sympathy for such plights.<br>It really depends on the situation: <br>I know of the case of of a large German company where<br>there was a very large system (and probably still is) based on IE 6,<br> but sometimes there is no money and/or time to upgrade it. <br>Have you read about air traffic systems? <br>There is a lot of “old” software, mature and stable, <br>in many businesses, functioning very well and if it were<br>not from pressure from “outside” and evaporating OS s <br>they would still be quite happy.<br>Yes, missing out on progress of course, <br>but in some businesses this is irrelevant.<br> <br></p><p>&gt; If you don’t want to maintain your Swift 2 code, don’t. But don’t prevent the rest of us from doing it, despite the efforts required.<br>No, I don’t want to remain with older Swift versions, but move on with newest versions. <br>These however, should flawlessly compile everything written in older versions.<br>&gt; <br>&gt; I applaud the way the Swift team is handling those breaking changes, piling them up as early as possible, postponing additive changes to post 3.0.<br>&gt; This is the way to minimise the efforts as much as possible.<br>I subscribe to that.<br></p><p>&gt; I hope that even then, source-breaking changes will continue to happen when they make sense.<br>I certainly hope not. <br></p><p>&gt; I am looking forward to a language that will get constantly better at enabling me to evolve my code in the most productive way.<br>Yes, me too!<br></p><p>&gt; If my source code breaks, that is a very small price to pay.<br></p><p>Would you still have this opinion if you (or your team)<br>after two years or so would have to edit hundreds of source files manually?<br>(because the source breaking change cannot be automatically converted?)<br></p><p>For example, after the removal of the classical for-loop with floats like this one:<br></p><p>        for var x:Float = -60;    x &lt; 60;    x += w * 1.2<br>        {<br>            for var y:Float = -30;    y &lt; 60;    y += h * 1.2<br>            {<br>               let pos = SCNVector3(x: x,   y: y,   z: z)<br>                <br>                let tile = TGStaticTile(pos: pos,<br>                                w:  CGFloat(w), h: CGFloat(h), l: CGFloat(l),<br>                                color: UIColor.randomColor(), naam: &quot;Tile\(tiles.count + 1)&quot;)<br></p><p>                tiles.append(tile)<br>           }<br>	}<br></p><p>I have more that a few of these in my AppleTV app under construction<br>which I all have to rewire manually when Swift 3.0 arrives,<br>because the migrator can not do it. <br></p><p><br>AFAIK, there is no automatic source conversion possible<br>in the above example.<br>(Also, there is no alternative in Swift yet for classical for-loops.<br>(I brought this forward extensively a few months ago,<br>but no one seems to care. I still can write a proposal<br>to reinstate the classical for-loop, but I guess it would be rejected))  <br> <br></p><p>N.B. an example: Some time ago, I was in favor to remove<br>variadic parameters from functions. This contradicts<br>the way I think now about removing language elements<br>I now think it should not be removed: <br>it is still there then, but one doesn’t need to use it.<br> <br>met vriendelijke groeten<br>Ted<br>https://www.tedvg.com<br>https://www.ravelnotes.com<br>https://soundcloud.com/ted-van-gaalen<br>https://tedvg.deviantart.com<br></p><p>&gt; <br>&gt; Jean-Denis<br>&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>Seriously! Freeze Swift For Two Years After Release 3.0 !</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>July  7, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On 6 Jul 2016, at 20:28, Ted F.A. van Gaalen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi there<br>&gt; <br>&gt; From the perspective from many active programmers<br>&gt; that use Swift (not objective C anymore) I am  not<br>&gt; very happy by having to change<br>&gt; program source all the time:   <br>&gt; <br>&gt; Therefore after Swift 3.0 is released I’d recommend kindly:<br>&gt; <br>&gt; <br>&gt; Freeze Swift For Some Time! <br>&gt; Do Not Change AnyThing For At Least 2 Years.<br>&gt; (Yes you’ve read that correctly: two years.)<br>&gt; <br>&gt; Still there? OK, read on:<br>&gt; <br>&gt; In the mean time, you’ll have the great opportunity<br>&gt; to fine-tune compiler and run time systems, to eliminate<br>&gt; the few bugs there and make it blazingly fast!<br>&gt; <br>&gt; In two (or more) years,  there are enough Real Users (programmers) <br>&gt; that by then will have enough practical experience with Swift, which<br>&gt; might play a more solid role in improving Swift, and of course,<br>&gt; are extremely happy with Swift, and that it is not changed<br>&gt; all the time, So that they can concentrate on writing cool,<br>&gt; reliable and decent programs, instead of revising it all<br>&gt; the time! <br>&gt; <br>&gt; After such time, and much more intensive and practical usage, <br>&gt; it becomes clear, what is good in Swift and what is not.  <br>&gt; What happens now, for instance, is that some base their “statistics” of which <br>&gt; language elements etc. are frequently used or not, merely upon scanning <br>&gt; a codebase of the relatively few (compared with e.g. ObjC, Java or C#) programmers<br>&gt; that use Swift now<br>&gt; <br>&gt; Imho, Swift has not yet been in use long enough. It needs a prolonged time <br>&gt; because now, most users have relatively little experience using Swift, <br>&gt; thus the way they program now is not really representative with what one really can do<br>&gt; with this powerful language, compared to experienced (years, not months) <br>&gt; programmers in other languages. <br>&gt; Still a lot has to be discovered, has to settle and form good mental pictures in <br>&gt; programmer’s minds. It is all going a bit too fast, I think.<br>&gt; <br>&gt; <br>&gt; Please (if you did’t already) realize that already many source<br>&gt; code all over the world is written in Swift therefore it is very, very<br>&gt; important that backwards compatibility should be preserved as much <br>&gt; as possible. because  backwards-breaking-changes are a disaster<br>&gt; to companies/individuals that have already hundreds or thousands<br>&gt; of programs written in Swift.<br>&gt; <br>&gt; For comparison, until recently I did also programming projects on IBM<br>&gt; mainframes for banks, insurance companies etc. The systems they use consists<br>&gt; (per company) of literally thousands of Cobol and/or PL/1 programs written<br>&gt; in all the years from ca 1970 until now. Still, one can take a program written<br>&gt; in 1970 which compiles and runs flawlessly without any modification!<br>&gt; All is backward compatible. If you would break backward<br>&gt; compatibility in this domain you would probably be kicked of the planet..<br>&gt; <br>&gt; <br>&gt; But even if we remain in macOS or iOS development, a huge amount of source<br>&gt; code has been written in Objective C. Everyone would scream hell if you took<br>&gt; out or change language elements.. <br>&gt; So please don’t. (it’s unnecessary) <br>&gt; <br>&gt; <br>&gt; When Swift arrived, to me, it had already everything I need, not really missing anything.<br>&gt; Of course, a programming language -like all things in life- is never perfect.<br>&gt; <br>&gt; To me it was also perfectly OK that Swift wasn’t open source, because those that<br>&gt; have made Swift did a very good job. So one could even start thinking, why<br>&gt; open source Swift? Why not leave it to Apple? <br>&gt; But I guess I won’t make many friends asking this..<br>&gt; And I also realize that many good ideas comes from open source.<br>&gt; <br>&gt; <br>&gt; To me, Swift 2.2 and also 3.0  is fine. <br>&gt; so, after that:<br>&gt; you don’t have to change a thing.<br>&gt; it works and has everything I need<br>&gt; and is fast and stable. <br>&gt; stop removing things.<br>&gt; thanks.<br>&gt; <br>&gt; <br>&gt; Kind Regards from beautiful Speyer.de in Germany<br>&gt; <br>&gt; TedvG<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br>It’s nice that you like Swift 3.0 so much, but it still has holes - there are plans in the generics manifesto for instance which are basically just limited by implementation. We don’t have a stable ABI. Reflection is still fairly rudimentary.<br></p><p>I don’t think the changes from Swift 2.2 -&gt; Swift 3.0 are that dramatic, but overall I feel they have made the language much better. The new indexing model, for instance, is a significant improvement; it’s now much easier to write custom collections. I was initially opposed to moving the “where” clause for generics outside of the angle brackets, but I’ve come around and I’m really looking forward to it, now. I’m even glad we got rid of C-style ‘for’ loops - it has helped me write safer, more readable code. There have been some really great performance improvements and I’m seeing more and more really big ones in the Github PR list every day (it’s really fascinating, I do love seeing how the language is getting improved piece-by-piece, in parallel, by so many people - I like to just flick through it sometimes and click on every title I don’t understand, sometimes you discover really cool things).<br></p><p>Not only that, but we have compiler fix-its. When there are renaming changes or argument-label changes, I just filter down my Xcode error list, click each one, give it a quick eyeball and hit “enter”. I don’t know of other languages that have had such good migration infrastructure for existing code. I don’t know how Linux users get the benefit of these fixits, though. Maybe a command-line interface for applying those fixits would be a neat idea, if they don’t have something else already. On Apple&#39;s platforms, they’ve got Swift 2.3 to help ease the migration pain (which is something I wish they’d done for Swift 2.0, but at least it’s nice to see they listened to the feedback).<br></p><p>Not only that, but you need to appreciate that comparing Swift, a language which has only been public for a couple of years, to a C language specification that has gone through ISO-certification process, is not really fair. Even then, C has had to evolve and so there are many newer specifications. I would guess the Swift core team won’t want to follow that approach - they’ve said a few times that they don’t want there to be multiple ‘flavours’ or ‘dialects’ of Swift.<br></p><p>So long as Swift keeps moving in the right direction, I’m happy for it to keep going at this pace. What I’ve seen of the project so far indicates that it’s run pretty well, and that the core team are very fair when it comes to source-breaking changes. For instance, I didn’t expect SE-0108 to get rejected recently, but the core team took the side of language users over compiler developers (i.e. Themselves) and are willing to go back to the drawing board because they considered it an unacceptable user regression. I thought that was pretty cool.<br></p><p>Basically, I think it’s blown out of proportion a bit. All languages must evolve, and the Swift team provide lots of supporting infrastructure to help users through those transitions. <br></p><p>&quot;Weiter so!”, as we say in Germany ;)<br></p><p>Karl<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Seriously! Freeze Swift For Two Years After Release 3.0 !</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>July  7, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jul 7, 2016, at 8:46 AM, Karl via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; It’s nice that you like Swift 3.0 so much, but it still has holes - there are plans in the generics manifesto for instance which are basically just limited by implementation. We don’t have a stable ABI. Reflection is still fairly rudimentary.<br>&gt; <br>&gt; I don’t think the changes from Swift 2.2 -&gt; Swift 3.0 are that dramatic, but overall I feel they have made the language much better. The new indexing model, for instance, is a significant improvement; it’s now much easier to write custom collections. I was initially opposed to moving the “where” clause for generics outside of the angle brackets, but I’ve come around and I’m really looking forward to it, now. I’m even glad we got rid of C-style ‘for’ loops - it has helped me write safer, more readable code. There have been some really great performance improvements and I’m seeing more and more really big ones in the Github PR list every day (it’s really fascinating, I do love seeing how the language is getting improved piece-by-piece, in parallel, by so many people - I like to just flick through it sometimes and click on every title I don’t understand, sometimes you discover really cool things).<br></p><p>I don&#39;t want to freeze Swift 3.0 either.<br></p><p>I&#39;d much prefer to push out Swift 3.0 to grant it time to mature and perfect (and get those generics right, add some great features, etc) than to freeze Swift 3.0 under the currently announced timeline. Swift 2.2/2.3 is pretty great. <br></p><p>The obvious problem with doing this is that it encourages the development of a wider codebase that *will* break on the Swift 3 transition. On the other hand, Swift will have much better and more mature migration tools with additional time, not just a better language.<br></p><p>-- E<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Seriously! Freeze Swift For Two Years After Release 3.0 !</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>July  7, 2016 at 03:00:00pm</p></header><div class="content"><p>On Jul 7, 2016, at 7:46 AM, Karl &lt;razielim at gmail.com&gt; wrote:<br>&gt; Not only that, but we have compiler fix-its. When there are renaming changes or argument-label changes, I just filter down my Xcode error list, click each one, give it a quick eyeball and hit “enter”. I don’t know of other languages that have had such good migration infrastructure for existing code. I don’t know how Linux users get the benefit of these fixits, though. <br></p><p>Helpful hint for folks moving from Xcode 8.0 beta 1 to beta 2 (and beyond): when you open your project in a new beta, make sure to go to &quot;Edit -&gt; Convert -&gt; To Modern Swift Syntax…”, which will help move you up by automatically applying the migration fixits that correspond to the changes in the new beta.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/32d8eca60f1bbb516804a3857528b2e1?s=50"></div><header><strong>Seriously! Freeze Swift For Two Years After Release 3.0 !</strong> from <string>ChanMaxthon</string> &lt;xcvista at me.com&gt;<p>July  8, 2016 at 02:00:00pm</p></header><div class="content"><p>For JSONFusion this won&#39;t work at all, as the code base is largely Objective-C with lots of Swift-related annotations and depend on Objective-C and Swift ABI details to work. The main trick in JSONFusion is property introspection which don&#39;t play nice with Swift yet, and for JSFRemote the main trick is message forwarding interception.<br></p><p>Sent from my iPhone<br></p><p>&gt; On Jul 8, 2016, at 06:33, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Jul 7, 2016, at 7:46 AM, Karl &lt;razielim at gmail.com&gt; wrote:<br>&gt;&gt; Not only that, but we have compiler fix-its. When there are renaming changes or argument-label changes, I just filter down my Xcode error list, click each one, give it a quick eyeball and hit “enter”. I don’t know of other languages that have had such good migration infrastructure for existing code. I don’t know how Linux users get the benefit of these fixits, though.<br>&gt; <br>&gt; Helpful hint for folks moving from Xcode 8.0 beta 1 to beta 2 (and beyond): when you open your project in a new beta, make sure to go to &quot;Edit -&gt; Convert -&gt; To Modern Swift Syntax…”, which will help move you up by automatically applying the migration fixits that correspond to the changes in the new beta.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b35b44357e4cca3a1de39ba1199c9ab5?s=50"></div><header><strong>Seriously! Freeze Swift For Two Years After Release 3.0 !</strong> from <string>ted van gaalen</string> &lt;tedvgiosdev at gmail.com&gt;<p>July  9, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On 08.07.2016, at 00:33, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; On Jul 7, 2016, at 7:46 AM, Karl &lt;razielim at gmail.com&gt; wrote:<br>&gt;&gt; Not only that, but we have compiler fix-its. When there are renaming changes or argument-label changes, I just filter down my Xcode error list, click each one, give it a quick eyeball and hit “enter”. I don’t know of other languages that have had such good migration infrastructure for existing code. I don’t know how Linux users get the benefit of these fixits, though. <br>&gt; <br>&gt; Helpful hint for folks moving from Xcode 8.0 beta 1 to beta 2 (and beyond): when you open your project in a new beta, make sure to go to &quot;Edit -&gt; Convert -&gt; To Modern Swift Syntax…”, which will help move you up by automatically applying the migration fixits that correspond to the changes in the new beta.<br>&gt; <br>&gt; -Chris<br>&gt; <br>Hi Chris, sorry for the delayed response.<br></p><p>In many cases Swift converters/ migration tools are certainly helpful,<br>however they work mostly scanning on a statement-by-statement basis, <br>having &quot;not enough AI” to grasp and process the context <br>e.g. for a cluster of source lines...<br></p><p>So, e.g. if one has programmed a function with its logic heavily based<br>on deprecating or removed Swift language elements, one still has to edit and<br>retest that code, which mostly consumes lots of time. Additionally, <br>in many cases - albeit somewhat reduced by good structured design -<br>these changes influences also other parts of the application. <br>(but we all know that of course)<br></p><p><br>imho and after releasing Swift 3.0: <br>               ===================<br></p><p>Existing language elements should never be removed,<br>    (even if they are frowned upon, which occasionally is caused<br>     by aspects of subjective opinion, lack of experience and premature vague statistics, we’re human aren’t we?)<br>and even if much better newer solutions are available. <br></p><p>New language elements should be supplements, standing on their own,<br>with the purpose of extending Swift, not as changes of existing code, <br>thus leaving the older equivalents intact as not to break older source code. <br></p><p>         (it would then to be expected that,<br>          if better alternatives are made available<br>         these would of course be preferred,<br>         causing the older alternatives to be forgotten <br>         after some time. Like the classical for-loop for instance.<br>         but, they’re still there to stay compatible with older source code) <br></p><p>-Even renaming language elements makes revisiting<br>and editing often large amounts of source code necessary.<br></p><p>Yes, I know this can be quite a challenge, nevertheless<br>it is necessary, i think. <br></p><p>In a (often unforgiving and stressed) production-environment<br>we used to write code in a “fire and forget” modus,<br>that is once written and tested it should run forever! <br></p><p>There simply is no time for revisiting. For instance, if one<br>would have to re-edit an old source to make minor<br>changes, then it wouldn’t be enough to just correct<br>this perhaps minor error, as one would have to edit<br>many source lines because the compiler won’t accept<br>language elements used some time ago and<br>now rendered obsolete.<br></p><p>Unless you allow to compile conditionally for each and every version<br>of the language. But conditional compiling creates a<br>mess, and makes source code hard to maintain.<br></p><p>Changing language elements or, even worse, removing them<br>makes it a tedious and very costly necessity to revisit and <br>re-edit all previously written source code, not to mention<br>that after that, all application/libraries involved need to be <br>tested again! <br></p><p>If it is just a trivial application, then this still could be done<br>without too much effort, however, in more complex cases<br>this could result in a real nightmare, consuming lots of time and money.<br></p><p>If i am not mistaken, the word “deprecated” originated in the Java<br>world. There the questionable culture of rücksichtslos throwing<br>things away started, I guess. Trendy perhaps? <br>In this culture, tons of Java code needs to be revised, <br>tested and re-released almost yearly because of that.<br></p><p>I think we should not make the same mistake.<br></p><p>Changing things all the time would certainly diminish Swift’s <br>popularity by professional developers.<br></p><p>In all these years as a programmer my general experience is,<br>that  improvements in programming languages are supplemental*<br>not changes or removal from existing language elements. <br></p><p>As perhaps misunderstood (from my previous writing) by some of us:<br>Of course I am not in favor of stopping development of Swift. <br>but imho as described above, changes should be supplemental<br>and not replacing existing language elements or removing them. <br></p><p>In this perspective “Freezing Swift” is meant here to keep all <br>new supplements in beta, yes, for a prolonged time, 2 years or so. <br>In that time Swift will have many more users, that no doubt, will <br>come with valuable feedback allowing to <br>improve the language even better.  <br></p><p>Please note that all the writing and considerations above concerns the<br>time AFTER the release of Swift 3.0.<br></p><p>I see a lot of good ideas and enthusiasm here, but<br>i might perhaps assume that many here didn’t work in a tight an<br>tense production environment?   <br></p><p>At least please try to imagine what it would be <br>if you would have to maintain source code that:<br>  -was written a few (ten?) years ago<br>  -cryptic sources worked on through by many people, of talented and often rookies,<br>    hired and fired and hired again.<br>  -a lot of times you wouldn’t have time to solve problems decently, or<br>   rewrite it, it just has to be patchwork.<br></p><p>I had to work many years like that and some projects almost drove crazy.<br>burn outs and so. <br>could tell you things that make you cry.. (but hey also positive things too) <br></p><p>I’d say one should pay more attention to these aspects.<br></p><p>Also, Swift has the very powerful feature to write one’s own<br>extensions, protocols and forms of inheritance.<br>This imho reduces the need to chance the language.<br></p><p>Thanks for reading.<br>Kind Regards<br>Ted<br></p><p><br></p><p><br></p><p><br></p><p>@ Karl :<br></p><p>Yes, it was blown a bit out of proportion, I hope the<br>above has  nuanced it a bit. <br></p><p><br>@Charlie Monroe:<br></p><p>Your assumption:<br></p><p>&gt; Both are examples of languages that do not have a lot of sytax/features/complexity. Such languages are more easily production-ready from day 1.<br></p><p>Forget it :o)<br>On the contrary, both languages PL/1 and Cobol are much more complex than Swift.<br>Take a look at the programming manuals, language specs. <br></p><p>Kind Regards<br>Ted<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Seriously! Freeze Swift For Two Years After Release 3.0 !</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>July  9, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jul 9, 2016, at 12:41 PM, Ted F.A. van Gaalen &lt;tedvgiosdev at gmail.com&gt; wrote:<br>&gt; <br>&gt; imho and after releasing Swift 3.0: <br>&gt;               ===================<br>&gt; <br>&gt; Existing language elements should never be removed,<br>&gt;    (even if they are frowned upon, which occasionally is caused<br>&gt;     by aspects of subjective opinion, lack of experience and premature vague statistics, we’re human aren’t we?)<br>&gt; and even if much better newer solutions are available. <br>&gt; <br>&gt; New language elements should be supplements, standing on their own,<br>&gt; with the purpose of extending Swift, not as changes of existing code, <br>&gt; thus leaving the older equivalents intact as not to break older source code. <br></p><p>Ted,<br></p><p>I recommend that you familiarize yourself with the goals for Swift 3, which are described here:<br>https://github.com/apple/swift-evolution<br></p><p>An excerpt:<br></p><p>&quot;The primary goal of this release is to solidify and mature the Swift language and development experience. While source breaking changes to the language have been the norm for Swift 1 through 3, we would like the Swift 3.x (and Swift 4+) languages to be as source compatible with Swift 3.0 as reasonably possible.”<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b35b44357e4cca3a1de39ba1199c9ab5?s=50"></div><header><strong>Seriously! Freeze Swift For Two Years After Release 3.0 !</strong> from <string>ted van gaalen</string> &lt;tedvgiosdev at gmail.com&gt;<p>July 10, 2016 at 02:00:00pm</p></header><div class="content"><p>Hi Chris,<br></p><p>Yes, I did read it again, subscribe to that strategy.<br></p><p>I’ve perhaps over-emphasized the importance of the impact back-breaking changes<br>.. Still..   <br></p><p>The subject title was a bit overloaded too.<br></p><p>I guess it’s between two extremes: that is, between (1) really freezing it and<br>(2) using Swift as a continuous &quot;software laboratory”   :o)<br>neither would be OK, (as with all extremities)...<br></p><p>thanks<br>Ted  <br></p><p><br>&gt; On 10.07.2016, at 00:20, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 9, 2016, at 12:41 PM, Ted F.A. van Gaalen &lt;tedvgiosdev at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; imho and after releasing Swift 3.0: <br>&gt;&gt;              ===================<br>&gt;&gt; <br>&gt;&gt; Existing language elements should never be removed,<br>&gt;&gt;   (even if they are frowned upon, which occasionally is caused<br>&gt;&gt;    by aspects of subjective opinion, lack of experience and premature vague statistics, we’re human aren’t we?)<br>&gt;&gt; and even if much better newer solutions are available. <br>&gt;&gt; <br>&gt;&gt; New language elements should be supplements, standing on their own,<br>&gt;&gt; with the purpose of extending Swift, not as changes of existing code, <br>&gt;&gt; thus leaving the older equivalents intact as not to break older source code. <br>&gt; <br>&gt; Ted,<br>&gt; <br>&gt; I recommend that you familiarize yourself with the goals for Swift 3, which are described here:<br>&gt; https://github.com/apple/swift-evolution<br>&gt; <br>&gt; An excerpt:<br>&gt; <br>&gt; &quot;The primary goal of this release is to solidify and mature the Swift language and development experience. While source breaking changes to the language have been the norm for Swift 1 through 3, we would like the Swift 3.x (and Swift 4+) languages to be as source compatible with Swift 3.0 as reasonably possible.”<br>&gt; <br>&gt; -Chris<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
