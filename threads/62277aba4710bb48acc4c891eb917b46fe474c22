<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c155243169db74a7787bab9d57a1c3d6?s=50"></div><header><strong>[SE-0088] Dispatch API names</strong> from <string>Darren Mo</string> &lt;darren.mo at me.com&gt;<p>June 20, 2016 at 08:00:00pm</p></header><div class="content"><p>SE-0088 was accepted with revisions a month ago. However, some of the APIs just don’t feel right to me. I’ve only used DispatchQueue and DispatchSource so far, so I will only comment on those.<br></p><p>DispatchQueue.async(execute:) and DispatchQueue.sync(execute:)<br>--------------------------------------------------------------<br>The lack of verb in the base name bothers me. The API Design Guidelines say “methods with side-effects should read as imperative verb phrases”. You could argue that the argument label “execute” serves as the verb. However, .async and .sync are most commonly used with trailing closures where the argument label is not present.<br></p><p>This issue was brought up during the review, but I did not see it being addressed. Why not name the methods something like .executeAsync(_:) and .executeSync(_:)?<br></p><p>DispatchQueue.after(when:execute:)<br>----------------------------------<br>This one simply doesn’t read grammatically. For example, `queue.after(when: .now) { … }` becomes “queue, after when now …”. Since dispatch_after is semantically just an extended version of dispatch_async (I think), we can name this .executeAsync(after:_:).<br></p><p>DispatchSource subclass names<br>-----------------------------<br>Why is it DispatchSourceMemoryPressure instead of MemoryPressureDispatchSource? I don’t think I’ve ever seen subclass names where the superclass part is at the beginning of the name.<br></p><p>DispatchSource factory methods<br>------------------------------<br>e.g. DispatchSource.read(fileDescriptor:queue:). The API Design Guidelines mandate that factory methods begin with the prefix “make”. Indeed, DispatchSource.read might mislead people to think that a read will be performed by this method. A better name would be .makeReadSource(fileDescriptor:queue:).<br></p><p>And why are these factory methods on DispatchSource instead of initializers on the subclasses? ReadDispatchSource.init(fileDescriptor:queue:) would be way clearer.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160620/62274c22/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[SE-0088] Dispatch API names</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June 20, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; DispatchQueue.async(execute:) and DispatchQueue.sync(execute:)<br>&gt; --------------------------------------------------------------<br>&gt; The lack of verb in the base name bothers me. The API Design Guidelines say “methods with side-effects should read as imperative verb phrases”. You could argue that the argument label “execute” serves as the verb. However, .async and .sync are most commonly used with trailing closures where the argument label is not present.<br>&gt; <br>&gt; This issue was brought up during the review, but I did not see it being addressed. Why not name the methods something like .executeAsync(_:) and .executeSync(_:)?<br></p><p>That feels a little redundant to me. It&#39;s worth remembering that the API Guidelines are a means of creating clear APIs, not an end in themselves. It&#39;s okay to deviate a little if you get a better result.<br></p><p>However, I could see us borrowing (and slightly modifying) terminology from Core Data:<br></p><p>	queue.perform { … }<br>	queue.performAndWait { … }<br></p><p>Compared to the status quo, this is clearer, a better fit for the guidelines, and better at penalizing the disfavored API.<br></p><p>&gt; DispatchQueue.after(when:execute:)<br>&gt; ----------------------------------<br>&gt; This one simply doesn’t read grammatically. For example, `queue.after(when: .now) { … }` becomes “queue, after when now …”. Since dispatch_after is semantically just an extended version of dispatch_async (I think), we can name this .executeAsync(after:_:).<br></p><p>Yeah, I gave a talk about the renaming on Saturday and somebody noted that `when` reads poorly here. Fortunately, `queue.perform(after: .now() + 0.5)` reads pretty well too. :^)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[SE-0088] Dispatch API names</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 20, 2016 at 09:00:00pm</p></header><div class="content"><p>On Mon, Jun 20, 2016 at 9:05 PM, Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; DispatchQueue.async(execute:) and DispatchQueue.sync(execute:)<br>&gt; &gt; --------------------------------------------------------------<br>&gt; &gt; The lack of verb in the base name bothers me. The API Design Guidelines<br>&gt; say “methods with side-effects should read as imperative verb phrases”. You<br>&gt; could argue that the argument label “execute” serves as the verb. However,<br>&gt; .async and .sync are most commonly used with trailing closures where the<br>&gt; argument label is not present.<br>&gt; &gt;<br>&gt; &gt; This issue was brought up during the review, but I did not see it being<br>&gt; addressed. Why not name the methods something like .executeAsync(_:) and<br>&gt; .executeSync(_:)?<br>&gt;<br>&gt; That feels a little redundant to me. It&#39;s worth remembering that the API<br>&gt; Guidelines are a means of creating clear APIs, not an end in themselves.<br>&gt; It&#39;s okay to deviate a little if you get a better result.<br>&gt;<br></p><p>The guideline that methods should &quot;read as imperative verb phrases&quot; applies<br>to the full name, labels and arguments and all, and not just the base name.<br>You&#39;ll recall that the original proposal had .asynchronously(execute:),<br>which is very much an imperative phrase. `.async(execute:)` was substituted<br>by popular demand, with &quot;async&quot; being regarded as a term-of-art exception.<br></p><p><br>&gt;<br>&gt; However, I could see us borrowing (and slightly modifying) terminology<br>&gt; from Core Data:<br>&gt;<br>&gt;         queue.perform { … }<br>&gt;         queue.performAndWait { … }<br>&gt;<br>&gt; Compared to the status quo, this is clearer, a better fit for the<br>&gt; guidelines, and better at penalizing the disfavored API.<br>&gt;<br>&gt; &gt; DispatchQueue.after(when:execute:)<br>&gt; &gt; ----------------------------------<br>&gt; &gt; This one simply doesn’t read grammatically. For example,<br>&gt; `queue.after(when: .now) { … }` becomes “queue, after when now …”. Since<br>&gt; dispatch_after is semantically just an extended version of dispatch_async<br>&gt; (I think), we can name this .executeAsync(after:_:).<br>&gt;<br>&gt; Yeah, I gave a talk about the renaming on Saturday and somebody noted that<br>&gt; `when` reads poorly here. Fortunately, `queue.perform(after: .now() + 0.5)`<br>&gt; reads pretty well too. :^)<br></p><p><br>Or just `queue.after(_:execute:)`, i.e. &quot;after [this time], execute [that<br>routine].&quot;<br></p><p>--<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160620/9d7039a0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[SE-0088] Dispatch API names</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June 20, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; The guideline that methods should &quot;read as imperative verb phrases&quot; applies to the full name, labels and arguments and all, and not just the base name. You&#39;ll recall that the original proposal had .asynchronously(execute:), which is very much an imperative phrase. `.async(execute:)` was substituted by popular demand, with &quot;async&quot; being regarded as a term-of-art exception.<br></p><p>Right, I forgot about that. I had a vague feeling that `execute` was the verb, but the shortening obscured `async`&#39;s role as an adverb.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[SE-0088] Dispatch API names</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>June 21, 2016 at 10:00:00am</p></header><div class="content"><p>Just yesterday I filed a bug because Data and DispatchData overlap but the api is not consistent: https://bugs.swift.org/browse/SR–1843<br></p><p>I never used libdispatch in depth but wanted to learn how it works to evolve my TCP module.<br></p><p>At first glance I spotted one wrong label name on DispatchIO:<br></p><p>public class func write(fromFileDescriptor: Int32, data: DispatchData, runningHandlerOn queue: DispatchQueue, handler: (data: DispatchData?, error: Int32) -&gt; Swift.Void)<br>This should look like (because we write TO a file):<br></p><p>public class func write(toFileDescriptor: Int32, data: DispatchData, runningHandlerOn queue: DispatchQueue, handler: (data: DispatchData?, error: Int32) -&gt; Swift.Void)<br>Interesting thing is also that this wasn’t proposed that way at all:<br></p><p>class func write(fileDescriptor: Int32, data: DispatchData, queue: DispatchQueue, handler: (DispatchData?, Int32) -&gt; Void)<br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 21. Juni 2016 um 08:40:55, Brent Royal-Gordon via swift-evolution (swift-evolution at swift.org) schrieb:<br></p><p>&gt; The guideline that methods should &quot;read as imperative verb phrases&quot; applies to the full name, labels and arguments and all, and not just the base name. You&#39;ll recall that the original proposal had .asynchronously(execute:), which is very much an imperative phrase. `.async(execute:)` was substituted by popular demand, with &quot;async&quot; being regarded as a term-of-art exception.<br></p><p>Right, I forgot about that. I had a vague feeling that `execute` was the verb, but the shortening obscured `async`&#39;s role as an adverb.<br></p><p>--  <br>Brent Royal-Gordon<br>Architechies<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160621/47091986/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/901d914d4288b1c11599f55e0a452e8c?s=50"></div><header><strong>[SE-0088] Dispatch API names</strong> from <string>Matt Wright</string> &lt;mww at apple.com&gt;<p>June 21, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jun 21, 2016, at 1:24 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Just yesterday I filed a bug because Data and DispatchData overlap but the api is not consistent: https://bugs.swift.org/browse/SR–1843<br>&gt; <br>&gt; I never used libdispatch in depth but wanted to learn how it works to evolve my TCP module.<br>&gt; <br>&gt; At first glance I spotted one wrong label name on DispatchIO:<br>&gt; <br>&gt; public class func write(fromFileDescriptor: Int32, data: DispatchData, runningHandlerOn queue: DispatchQueue, handler: (data: DispatchData?, error: Int32) -&gt; Swift.Void)<br>&gt; <br>&gt; This should look like (because we write TO a file):<br>&gt; <br>&gt; public class func write(toFileDescriptor: Int32, data: DispatchData, runningHandlerOn queue: DispatchQueue, handler: (data: DispatchData?, error: Int32) -&gt; Swift.Void)<br></p><p>Please file a bug for this and I’ll get it fixed.<br></p><p>&gt; <br>&gt; Interesting thing is also that this wasn’t proposed that way at all:<br>&gt; <br>&gt; class func write(fileDescriptor: Int32, data: DispatchData, queue: DispatchQueue, handler: (DispatchData?, Int32) -&gt; Void)<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; Am 21. Juni 2016 um 08:40:55, Brent Royal-Gordon via swift-evolution (swift-evolution at swift.org) schrieb:<br>&gt; <br>&gt;&gt; &gt; The guideline that methods should &quot;read as imperative verb phrases&quot; applies to the full name, labels and arguments and all, and not just the base name. You&#39;ll recall that the original proposal had .asynchronously(execute:), which is very much an imperative phrase. `.async(execute:)` was substituted by popular demand, with &quot;async&quot; being regarded as a term-of-art exception.<br>&gt;&gt; <br>&gt;&gt; Right, I forgot about that. I had a vague feeling that `execute` was the verb, but the shortening obscured `async`&#39;s role as an adverb.<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/901d914d4288b1c11599f55e0a452e8c?s=50"></div><header><strong>[SE-0088] Dispatch API names</strong> from <string>Matt Wright</string> &lt;mww at apple.com&gt;<p>June 21, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jun 20, 2016, at 7:12 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Mon, Jun 20, 2016 at 9:05 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; DispatchQueue.async(execute:) and DispatchQueue.sync(execute:)<br>&gt; &gt; --------------------------------------------------------------<br>&gt; &gt; The lack of verb in the base name bothers me. The API Design Guidelines say “methods with side-effects should read as imperative verb phrases”. You could argue that the argument label “execute” serves as the verb. However, .async and .sync are most commonly used with trailing closures where the argument label is not present.<br>&gt; &gt;<br>&gt; &gt; This issue was brought up during the review, but I did not see it being addressed. Why not name the methods something like .executeAsync(_:) and .executeSync(_:)?<br>&gt; <br>&gt; That feels a little redundant to me. It&#39;s worth remembering that the API Guidelines are a means of creating clear APIs, not an end in themselves. It&#39;s okay to deviate a little if you get a better result.<br>&gt; <br>&gt; The guideline that methods should &quot;read as imperative verb phrases&quot; applies to the full name, labels and arguments and all, and not just the base name. You&#39;ll recall that the original proposal had .asynchronously(execute:), which is very much an imperative phrase. `.async(execute:)` was substituted by popular demand, with &quot;async&quot; being regarded as a term-of-art exception.<br></p><p>Right, the naming here strayed from the guidelines here under the term-of-art exception. None of the various alternatives really fit amazingly well, the async{,hronous} part of the API name communicates an important facet of what the call does. In that it goes away and executes the closure “somewhere else”. I feel this particular point is lost in example such as perform{andWait}. `.asynchronously` was an attempt to move towards the guidelines but it still missed that mark. I believe it’s still clearer to have `.async` as an exception.<br></p><p>&gt; <br>&gt; However, I could see us borrowing (and slightly modifying) terminology from Core Data:<br>&gt; <br>&gt;         queue.perform { … }<br>&gt;         queue.performAndWait { … }<br>&gt; <br>&gt; Compared to the status quo, this is clearer, a better fit for the guidelines, and better at penalizing the disfavored API.<br>&gt; <br>&gt; &gt; DispatchQueue.after(when:execute:)<br>&gt; &gt; ----------------------------------<br>&gt; &gt; This one simply doesn’t read grammatically. For example, `queue.after(when: .now) { … }` becomes “queue, after when now …”. Since dispatch_after is semantically just an extended version of dispatch_async (I think), we can name this .executeAsync(after:_:).<br>&gt; <br>&gt; Yeah, I gave a talk about the renaming on Saturday and somebody noted that `when` reads poorly here. Fortunately, `queue.perform(after: .now() + 0.5)` reads pretty well too. :^)<br>&gt; <br>&gt; Or just `queue.after(_:execute:)`, i.e. &quot;after [this time], execute [that routine].”<br></p><p>.after is already going to need some tweaking as I don’t believe the current incarnation is sufficiently named to avoid being ambiguous in the common case. Though, removing the label will also not help in that regard. I agree, there is probably merit in the idea of moving after to being an optional argument on `.async`.<br></p><p>&gt; <br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c155243169db74a7787bab9d57a1c3d6?s=50"></div><header><strong>[SE-0088] Dispatch API names</strong> from <string>Darren Mo</string> &lt;darren.mo at me.com&gt;<p>June 21, 2016 at 07:00:00pm</p></header><div class="content"><p>On Jun 21, 2016, at 5:24 PM, Matt Wright &lt;mww at apple.com&gt; wrote:<br>&gt;&gt; On Jun 20, 2016, at 7:12 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; On Mon, Jun 20, 2016 at 9:05 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; DispatchQueue.async(execute:) and DispatchQueue.sync(execute:)<br>&gt;&gt;&gt; --------------------------------------------------------------<br>&gt;&gt;&gt; The lack of verb in the base name bothers me. The API Design Guidelines say “methods with side-effects should read as imperative verb phrases”. You could argue that the argument label “execute” serves as the verb. However, .async and .sync are most commonly used with trailing closures where the argument label is not present.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This issue was brought up during the review, but I did not see it being addressed. Why not name the methods something like .executeAsync(_:) and .executeSync(_:)?<br>&gt;&gt; <br>&gt;&gt; That feels a little redundant to me. It&#39;s worth remembering that the API Guidelines are a means of creating clear APIs, not an end in themselves. It&#39;s okay to deviate a little if you get a better result.<br>&gt;&gt; <br>&gt;&gt; The guideline that methods should &quot;read as imperative verb phrases&quot; applies to the full name, labels and arguments and all, and not just the base name. You&#39;ll recall that the original proposal had .asynchronously(execute:), which is very much an imperative phrase. `.async(execute:)` was substituted by popular demand, with &quot;async&quot; being regarded as a term-of-art exception.<br>&gt; <br>&gt; Right, the naming here strayed from the guidelines here under the term-of-art exception. None of the various alternatives really fit amazingly well, the async{,hronous} part of the API name communicates an important facet of what the call does. In that it goes away and executes the closure “somewhere else”. I feel this particular point is lost in example such as perform{andWait}. `.asynchronously` was an attempt to move towards the guidelines but it still missed that mark. I believe it’s still clearer to have `.async` as an exception.<br></p><p>What do you think of the names .executeAsync/.executeSync or .asyncExecute/.syncExecute?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160621/4b407f33/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[SE-0088] Dispatch API names</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>July  7, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Jun 21, 2016, at 16:46, Darren Mo via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Jun 21, 2016, at 5:24 PM, Matt Wright &lt;mww at apple.com &lt;mailto:mww at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; On Jun 20, 2016, at 7:12 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; On Mon, Jun 20, 2016 at 9:05 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; DispatchQueue.async(execute:) and DispatchQueue.sync(execute:)<br>&gt;&gt;&gt;&gt; --------------------------------------------------------------<br>&gt;&gt;&gt;&gt; The lack of verb in the base name bothers me. The API Design Guidelines say “methods with side-effects should read as imperative verb phrases”. You could argue that the argument label “execute” serves as the verb. However, .async and .sync are most commonly used with trailing closures where the argument label is not present.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This issue was brought up during the review, but I did not see it being addressed. Why not name the methods something like .executeAsync(_:) and .executeSync(_:)?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That feels a little redundant to me. It&#39;s worth remembering that the API Guidelines are a means of creating clear APIs, not an end in themselves. It&#39;s okay to deviate a little if you get a better result.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The guideline that methods should &quot;read as imperative verb phrases&quot; applies to the full name, labels and arguments and all, and not just the base name. You&#39;ll recall that the original proposal had .asynchronously(execute:), which is very much an imperative phrase. `.async(execute:)` was substituted by popular demand, with &quot;async&quot; being regarded as a term-of-art exception.<br>&gt;&gt; <br>&gt;&gt; Right, the naming here strayed from the guidelines here under the term-of-art exception. None of the various alternatives really fit amazingly well, the async{,hronous} part of the API name communicates an important facet of what the call does. In that it goes away and executes the closure “somewhere else”. I feel this particular point is lost in example such as perform{andWait}. `.asynchronously` was an attempt to move towards the guidelines but it still missed that mark. I believe it’s still clearer to have `.async` as an exception.<br>&gt; <br>&gt; What do you think of the names .executeAsync/.executeSync or .asyncExecute/.syncExecute?<br></p><p>I honestly want these to stay light. I like perform/performAndWait fine, but executeAsync/asyncExecute seem overly verbose. They’re more English-like but don’t actually add any clarity, in that I think it’s really quite clear what the API does.<br></p><p>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160707/6d0ce48a/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c155243169db74a7787bab9d57a1c3d6?s=50"></div><header><strong>[SE-0088] Dispatch API names</strong> from <string>Darren Mo</string> &lt;darren.mo at me.com&gt;<p>June 21, 2016 at 07:00:00pm</p></header><div class="content"><p>On Jun 20, 2016, at 10:12 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; On Mon, Jun 20, 2016 at 9:05 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt; DispatchQueue.async(execute:) and DispatchQueue.sync(execute:)<br>&gt; &gt; --------------------------------------------------------------<br>&gt; &gt; The lack of verb in the base name bothers me. The API Design Guidelines say “methods with side-effects should read as imperative verb phrases”. You could argue that the argument label “execute” serves as the verb. However, .async and .sync are most commonly used with trailing closures where the argument label is not present.<br>&gt; &gt;<br>&gt; &gt; This issue was brought up during the review, but I did not see it being addressed. Why not name the methods something like .executeAsync(_:) and .executeSync(_:)?<br>&gt; <br>&gt; That feels a little redundant to me. It&#39;s worth remembering that the API Guidelines are a means of creating clear APIs, not an end in themselves. It&#39;s okay to deviate a little if you get a better result.<br>&gt; <br>&gt; The guideline that methods should &quot;read as imperative verb phrases&quot; applies to the full name, labels and arguments and all, and not just the base name. You&#39;ll recall that the original proposal had .asynchronously(execute:), which is very much an imperative phrase. `.async(execute:)` was substituted by popular demand, with &quot;async&quot; being regarded as a term-of-art exception.<br></p><p>Can you link me something that says it applies to the full name? In all the examples, the verb is always in the base name and the argument labels are always prepositions or objects (the grammar version).<br></p><p>And what about when a trailing closure is used? Then the verb disappears.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160621/3afa3358/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[SE-0088] Dispatch API names</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 21, 2016 at 06:00:00pm</p></header><div class="content"><p>On Tue, Jun 21, 2016 at 6:44 PM, Darren Mo &lt;darren.mo at me.com&gt; wrote:<br></p><p>&gt; On Jun 20, 2016, at 10:12 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Mon, Jun 20, 2016 at 9:05 PM, Brent Royal-Gordon via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; &gt; DispatchQueue.async(execute:) and DispatchQueue.sync(execute:)<br>&gt;&gt; &gt; --------------------------------------------------------------<br>&gt;&gt; &gt; The lack of verb in the base name bothers me. The API Design Guidelines<br>&gt;&gt; say “methods with side-effects should read as imperative verb phrases”. You<br>&gt;&gt; could argue that the argument label “execute” serves as the verb. However,<br>&gt;&gt; .async and .sync are most commonly used with trailing closures where the<br>&gt;&gt; argument label is not present.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; This issue was brought up during the review, but I did not see it being<br>&gt;&gt; addressed. Why not name the methods something like .executeAsync(_:) and<br>&gt;&gt; .executeSync(_:)?<br>&gt;&gt;<br>&gt;&gt; That feels a little redundant to me. It&#39;s worth remembering that the API<br>&gt;&gt; Guidelines are a means of creating clear APIs, not an end in themselves.<br>&gt;&gt; It&#39;s okay to deviate a little if you get a better result.<br>&gt;&gt;<br>&gt;<br>&gt; The guideline that methods should &quot;read as imperative verb phrases&quot;<br>&gt; applies to the full name, labels and arguments and all, and not just the<br>&gt; base name. You&#39;ll recall that the original proposal had<br>&gt; .asynchronously(execute:), which is very much an imperative phrase.<br>&gt; `.async(execute:)` was substituted by popular demand, with &quot;async&quot; being<br>&gt; regarded as a term-of-art exception.<br>&gt;<br>&gt;<br>&gt; Can you link me something that says it applies to the full name?<br>&gt;<br></p><p>In the document, all examples for verb phrases and noun phrases include the<br>labels and arguments (e.g.: &quot;distance to y&quot;). In the subsequent section, it<br>outlines scenarios for labeling the first argument when it forms part of a<br>prepositional phrase or other grammatical phrase; in either case, the label<br>is read as part of the phrase. The only exception to this convention is<br>explicitly outlined: &quot;Initializer and factory method calls should form a<br>phrase that does not include the first argument.&quot;<br></p><p><br>&gt; In all the examples, the verb is always in the base name and the argument<br>&gt; labels are always prepositions or objects (the grammar version).<br>&gt;<br></p><p>Yes; these names are exceptional in that way. But it is apt: the base name<br>holds the distinguishing feature (async vs. sync), whereas the verb here is<br>correctly a label for the argument, which is a code block to be executed.<br></p><p><br>&gt; And what about when a trailing closure is used? Then the verb disappears.<br>&gt;<br></p><p>Which is fine, because the verb couldn&#39;t really be anything else<br>(`doNotExecute`?). To me, at least, braces surrounding code blocks<br>satisfactorily imply &#39;do&#39; or &#39;execute,&#39; much like parentheses around<br>arguments are sometimes taken to imply &#39;with&#39; or &#39;using.&#39;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160621/bd81c0ce/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9ce70a6cb7175e7a5e5db5658186a31?s=50"></div><header><strong>[SE-0088] Dispatch API names</strong> from <string>Brandon Knope</string> &lt;bknope at me.com&gt;<p>June 21, 2016 at 04:00:00pm</p></header><div class="content"><p>I&#39;m not convinced that perform is clearer than async.<br></p><p>performAndWait *is* clearer than sync but only in context: you wouldn&#39;t know perform was async until you read it or noticed the difference with performAndWait. Nothing about *perform* on its own conveys that it&#39;s asynchronous. <br></p><p>Brandon <br></p><p>Sent from my iPad<br></p><p>On Jun 20, 2016, at 10:05 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; DispatchQueue.async(execute:) and DispatchQueue.sync(execute:)<br>&gt;&gt; --------------------------------------------------------------<br>&gt;&gt; The lack of verb in the base name bothers me. The API Design Guidelines say “methods with side-effects should read as imperative verb phrases”. You could argue that the argument label “execute” serves as the verb. However, .async and .sync are most commonly used with trailing closures where the argument label is not present.<br>&gt;&gt; <br>&gt;&gt; This issue was brought up during the review, but I did not see it being addressed. Why not name the methods something like .executeAsync(_:) and .executeSync(_:)?<br>&gt; <br>&gt; That feels a little redundant to me. It&#39;s worth remembering that the API Guidelines are a means of creating clear APIs, not an end in themselves. It&#39;s okay to deviate a little if you get a better result.<br>&gt; <br>&gt; However, I could see us borrowing (and slightly modifying) terminology from Core Data:<br>&gt; <br>&gt;    queue.perform { … }<br>&gt;    queue.performAndWait { … }<br>&gt; <br>&gt; Compared to the status quo, this is clearer, a better fit for the guidelines, and better at penalizing the disfavored API.<br>&gt; <br>&gt;&gt; DispatchQueue.after(when:execute:)<br>&gt;&gt; ----------------------------------<br>&gt;&gt; This one simply doesn’t read grammatically. For example, `queue.after(when: .now) { … }` becomes “queue, after when now …”. Since dispatch_after is semantically just an extended version of dispatch_async (I think), we can name this .executeAsync(after:_:).<br>&gt; <br>&gt; Yeah, I gave a talk about the renaming on Saturday and somebody noted that `when` reads poorly here. Fortunately, `queue.perform(after: .now() + 0.5)` reads pretty well too. :^)<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/901d914d4288b1c11599f55e0a452e8c?s=50"></div><header><strong>[SE-0088] Dispatch API names</strong> from <string>Matt Wright</string> &lt;mww at apple.com&gt;<p>June 21, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jun 20, 2016, at 5:50 PM, Darren Mo via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; SE-0088 was accepted with revisions a month ago. However, some of the APIs just don’t feel right to me. I’ve only used DispatchQueue and DispatchSource so far, so I will only comment on those.<br>&gt; <br>&gt; DispatchQueue.async(execute:) and DispatchQueue.sync(execute:)<br>&gt; --------------------------------------------------------------<br>&gt; The lack of verb in the base name bothers me. The API Design Guidelines say “methods with side-effects should read as imperative verb phrases”. You could argue that the argument label “execute” serves as the verb. However, .async and .sync are most commonly used with trailing closures where the argument label is not present.<br>&gt; <br>&gt; This issue was brought up during the review, but I did not see it being addressed. Why not name the methods something like .executeAsync(_:) and .executeSync(_:)?<br>&gt; <br>&gt; DispatchQueue.after(when:execute:)<br>&gt; ----------------------------------<br>&gt; This one simply doesn’t read grammatically. For example, `queue.after(when: .now) { … }` becomes “queue, after when now …”. Since dispatch_after is semantically just an extended version of dispatch_async (I think), we can name this .executeAsync(after:_:).<br></p><p>I replied to messages out of order but I agree, moving `.after` onto .async seems like the more natural place for it to live.<br></p><p>&gt; <br>&gt; DispatchSource subclass names<br>&gt; -----------------------------<br>&gt; Why is it DispatchSourceMemoryPressure instead of MemoryPressureDispatchSource? I don’t think I’ve ever seen subclass names where the superclass part is at the beginning of the name.<br></p><p>I’m not so keen to remove the Dispatch prefix from the front of the source types, given that we avoided doing that for the remainder of the module.<br></p><p>&gt; <br>&gt; DispatchSource factory methods<br>&gt; ------------------------------<br>&gt; e.g. DispatchSource.read(fileDescriptor:queue:). The API Design Guidelines mandate that factory methods begin with the prefix “make”. Indeed, DispatchSource.read might mislead people to think that a read will be performed by this method. A better name would be .makeReadSource(fileDescriptor:queue:).<br></p><p>Agreed, these should probably be brought into line with that guideline.<br></p><p>&gt; And why are these factory methods on DispatchSource instead of initializers on the subclasses? ReadDispatchSource.init(fileDescriptor:queue:) would be way clearer.<br></p><p>The source types are not subclasses, due to implementation details they are protocols.<br></p><p>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c155243169db74a7787bab9d57a1c3d6?s=50"></div><header><strong>[SE-0088] Dispatch API names</strong> from <string>Darren Mo</string> &lt;darren.mo at me.com&gt;<p>June 21, 2016 at 07:00:00pm</p></header><div class="content"><p>On Jun 21, 2016, at 5:28 PM, Matt Wright &lt;mww at apple.com&gt; wrote:<br>&gt;&gt; On Jun 20, 2016, at 5:50 PM, Darren Mo via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; DispatchQueue.after(when:execute:)<br>&gt;&gt; ----------------------------------<br>&gt;&gt; This one simply doesn’t read grammatically. For example, `queue.after(when: .now) { … }` becomes “queue, after when now …”. Since dispatch_after is semantically just an extended version of dispatch_async (I think), we can name this .executeAsync(after:_:).<br>&gt; <br>&gt; I replied to messages out of order but I agree, moving `.after` onto .async seems like the more natural place for it to live.<br></p><p>Yay!<br></p><p>&gt;&gt; DispatchSource subclass names<br>&gt;&gt; -----------------------------<br>&gt;&gt; Why is it DispatchSourceMemoryPressure instead of MemoryPressureDispatchSource? I don’t think I’ve ever seen subclass names where the superclass part is at the beginning of the name.<br>&gt; <br>&gt; I’m not so keen to remove the Dispatch prefix from the front of the source types, given that we avoided doing that for the remainder of the module.<br></p><p>What is the rationale for keeping the Dispatch prefix anyways? (I couldn’t find it in the archives.)<br></p><p>&gt;&gt; DispatchSource factory methods<br>&gt;&gt; ------------------------------<br>&gt;&gt; e.g. DispatchSource.read(fileDescriptor:queue:). The API Design Guidelines mandate that factory methods begin with the prefix “make”. Indeed, DispatchSource.read might mislead people to think that a read will be performed by this method. A better name would be .makeReadSource(fileDescriptor:queue:).<br>&gt; <br>&gt; Agreed, these should probably be brought into line with that guideline.<br></p><p>Yay!<br></p><p>&gt;&gt; And why are these factory methods on DispatchSource instead of initializers on the subclasses? ReadDispatchSource.init(fileDescriptor:queue:) would be way clearer.<br>&gt; <br>&gt; The source types are not subclasses, due to implementation details they are protocols.<br></p><p>Oops, missed that. Sorry.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160621/f84a2e18/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c155243169db74a7787bab9d57a1c3d6?s=50"></div><header><strong>[SE-0088] Dispatch API names</strong> from <string>Darren Mo</string> &lt;darren.mo at me.com&gt;<p>July  7, 2016 at 10:00:00pm</p></header><div class="content"><p>Should I create a bug report for changing `DispatchQueue.after` and `DispatchSource.read`?<br></p><p>Darren<br></p><p>&gt; On Jun 21, 2016, at 7:35 PM, Darren Mo &lt;darren.mo at me.com&gt; wrote:<br>&gt; <br>&gt; On Jun 21, 2016, at 5:28 PM, Matt Wright &lt;mww at apple.com &lt;mailto:mww at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; On Jun 20, 2016, at 5:50 PM, Darren Mo via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; DispatchQueue.after(when:execute:)<br>&gt;&gt;&gt; ----------------------------------<br>&gt;&gt;&gt; This one simply doesn’t read grammatically. For example, `queue.after(when: .now) { … }` becomes “queue, after when now …”. Since dispatch_after is semantically just an extended version of dispatch_async (I think), we can name this .executeAsync(after:_:).<br>&gt;&gt; <br>&gt;&gt; I replied to messages out of order but I agree, moving `.after` onto .async seems like the more natural place for it to live.<br>&gt; <br>&gt; Yay!<br>&gt; <br>&gt;&gt;&gt; DispatchSource subclass names<br>&gt;&gt;&gt; -----------------------------<br>&gt;&gt;&gt; Why is it DispatchSourceMemoryPressure instead of MemoryPressureDispatchSource? I don’t think I’ve ever seen subclass names where the superclass part is at the beginning of the name.<br>&gt;&gt; <br>&gt;&gt; I’m not so keen to remove the Dispatch prefix from the front of the source types, given that we avoided doing that for the remainder of the module.<br>&gt; <br>&gt; What is the rationale for keeping the Dispatch prefix anyways? (I couldn’t find it in the archives.)<br>&gt; <br>&gt;&gt;&gt; DispatchSource factory methods<br>&gt;&gt;&gt; ------------------------------<br>&gt;&gt;&gt; e.g. DispatchSource.read(fileDescriptor:queue:). The API Design Guidelines mandate that factory methods begin with the prefix “make”. Indeed, DispatchSource.read might mislead people to think that a read will be performed by this method. A better name would be .makeReadSource(fileDescriptor:queue:).<br>&gt;&gt; <br>&gt;&gt; Agreed, these should probably be brought into line with that guideline.<br>&gt; <br>&gt; Yay!<br>&gt; <br>&gt;&gt;&gt; And why are these factory methods on DispatchSource instead of initializers on the subclasses? ReadDispatchSource.init(fileDescriptor:queue:) would be way clearer.<br>&gt;&gt; <br>&gt;&gt; The source types are not subclasses, due to implementation details they are protocols.<br>&gt; <br>&gt; Oops, missed that. Sorry.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160707/74852904/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/901d914d4288b1c11599f55e0a452e8c?s=50"></div><header><strong>[SE-0088] Dispatch API names</strong> from <string>Matt Wright</string> &lt;mww at apple.com&gt;<p>July  7, 2016 at 09:00:00pm</p></header><div class="content"><p>Feel free to create one for .read, I already have a radar that covers .after<br></p><p>&gt; On Jul 7, 2016, at 7:16 PM, Darren Mo &lt;darren.mo at me.com&gt; wrote:<br>&gt; <br>&gt; Should I create a bug report for changing `DispatchQueue.after` and `DispatchSource.read`?<br>&gt; <br>&gt; Darren<br>&gt; <br>&gt;&gt; On Jun 21, 2016, at 7:35 PM, Darren Mo &lt;darren.mo at me.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Jun 21, 2016, at 5:28 PM, Matt Wright &lt;mww at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; On Jun 20, 2016, at 5:50 PM, Darren Mo via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; DispatchQueue.after(when:execute:)<br>&gt;&gt;&gt;&gt; ----------------------------------<br>&gt;&gt;&gt;&gt; This one simply doesn’t read grammatically. For example, `queue.after(when: .now) { … }` becomes “queue, after when now …”. Since dispatch_after is semantically just an extended version of dispatch_async (I think), we can name this .executeAsync(after:_:).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I replied to messages out of order but I agree, moving `.after` onto .async seems like the more natural place for it to live.<br>&gt;&gt; <br>&gt;&gt; Yay!<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; DispatchSource subclass names<br>&gt;&gt;&gt;&gt; -----------------------------<br>&gt;&gt;&gt;&gt; Why is it DispatchSourceMemoryPressure instead of MemoryPressureDispatchSource? I don’t think I’ve ever seen subclass names where the superclass part is at the beginning of the name.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m not so keen to remove the Dispatch prefix from the front of the source types, given that we avoided doing that for the remainder of the module.<br>&gt;&gt; <br>&gt;&gt; What is the rationale for keeping the Dispatch prefix anyways? (I couldn’t find it in the archives.)<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; DispatchSource factory methods<br>&gt;&gt;&gt;&gt; ------------------------------<br>&gt;&gt;&gt;&gt; e.g. DispatchSource.read(fileDescriptor:queue:). The API Design Guidelines mandate that factory methods begin with the prefix “make”. Indeed, DispatchSource.read might mislead people to think that a read will be performed by this method. A better name would be .makeReadSource(fileDescriptor:queue:).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Agreed, these should probably be brought into line with that guideline.<br>&gt;&gt; <br>&gt;&gt; Yay!<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; And why are these factory methods on DispatchSource instead of initializers on the subclasses? ReadDispatchSource.init(fileDescriptor:queue:) would be way clearer.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The source types are not subclasses, due to implementation details they are protocols.<br>&gt;&gt; <br>&gt;&gt; Oops, missed that. Sorry.<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[SE-0088] Dispatch API names</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>July 14, 2016 at 12:00:00pm</p></header><div class="content"><p>I just discovered this thread by accident - thank the Lord I’m not the only one who feels like this about the new Dispatch API!<br></p><p>&gt; On 8 Jul 2016, at 04:16, Darren Mo via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Should I create a bug report for changing `DispatchQueue.after` and `DispatchSource.read`?<br>&gt; <br>&gt; Darren<br>&gt; <br>&gt;&gt; On Jun 21, 2016, at 7:35 PM, Darren Mo &lt;darren.mo at me.com &lt;mailto:darren.mo at me.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Jun 21, 2016, at 5:28 PM, Matt Wright &lt;mww at apple.com &lt;mailto:mww at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; On Jun 20, 2016, at 5:50 PM, Darren Mo via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; DispatchQueue.after(when:execute:)<br>&gt;&gt;&gt;&gt; ----------------------------------<br>&gt;&gt;&gt;&gt; This one simply doesn’t read grammatically. For example, `queue.after(when: .now) { … }` becomes “queue, after when now …”. Since dispatch_after is semantically just an extended version of dispatch_async (I think), we can name this .executeAsync(after:_:).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I replied to messages out of order but I agree, moving `.after` onto .async seems like the more natural place for it to live.<br>&gt;&gt; <br>&gt;&gt; Yay!<br>&gt;&gt; <br></p><p>So long as the signature then reads grammatically - I had a little battle about this yesterday: http://comments.gmane.org/gmane.comp.lang.swift.evolution/23867<br></p><p>To summarise:<br>- “after” should take a plain time interval<br>- “deadline” is just simply the wrong word - means something else entirely<br>- since we can’t take an interval without a clock, we need a default clock<br>- but the nuances with those clocks are very important and a source of subtle bugs, so we should also ask for precise intention<br></p><p>=&gt; I think we should split DispatchQueue.after() based on clock type. This would allow us to provide a default value for “now”, meaning we can also accept plain time intervals, as the resulting API would be explicit about the clock nuances that are often overlooked.<br></p><p>&gt;&gt;&gt;&gt; DispatchSource subclass names<br>&gt;&gt;&gt;&gt; -----------------------------<br>&gt;&gt;&gt;&gt; Why is it DispatchSourceMemoryPressure instead of MemoryPressureDispatchSource? I don’t think I’ve ever seen subclass names where the superclass part is at the beginning of the name.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m not so keen to remove the Dispatch prefix from the front of the source types, given that we avoided doing that for the remainder of the module.<br>&gt;&gt; <br>&gt;&gt; What is the rationale for keeping the Dispatch prefix anyways? (I couldn’t find it in the archives.)<br></p><p>I would also like to know this. I really don’t like typing Dispatch... every time. It doesn’t seem to be very forgiving with code-completion.<br></p><p>Also, dispatch code tends to contain a fair amount of nested closures. It’s nice to keep the line lengths short in that case.<br></p><p>Karl<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160714/ff45f856/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/901d914d4288b1c11599f55e0a452e8c?s=50"></div><header><strong>[SE-0088] Dispatch API names</strong> from <string>Matt Wright</string> &lt;mww at apple.com&gt;<p>July 14, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jul 14, 2016, at 3:44 AM, Karl &lt;razielim at gmail.com&gt; wrote:<br>&gt; <br>&gt; I just discovered this thread by accident - thank the Lord I’m not the only one who feels like this about the new Dispatch API!<br>&gt; <br>&gt;&gt; On 8 Jul 2016, at 04:16, Darren Mo via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Should I create a bug report for changing `DispatchQueue.after` and `DispatchSource.read`?<br>&gt;&gt; <br>&gt;&gt; Darren<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 21, 2016, at 7:35 PM, Darren Mo &lt;darren.mo at me.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jun 21, 2016, at 5:28 PM, Matt Wright &lt;mww at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; On Jun 20, 2016, at 5:50 PM, Darren Mo via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; DispatchQueue.after(when:execute:)<br>&gt;&gt;&gt;&gt;&gt; ----------------------------------<br>&gt;&gt;&gt;&gt;&gt; This one simply doesn’t read grammatically. For example, `queue.after(when: .now) { … }` becomes “queue, after when now …”. Since dispatch_after is semantically just an extended version of dispatch_async (I think), we can name this .executeAsync(after:_:).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I replied to messages out of order but I agree, moving `.after` onto .async seems like the more natural place for it to live.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yay!<br>&gt;&gt;&gt; <br></p><p>To somewhat follow up on Darren’s suggestion: after internal discussion, moving `.after` into `.async` isn’t as good an idea as I had hoped. The behaviour of `.after`, both in execution and performance, differ substantially from `.async`.<br></p><p>&gt; <br>&gt; So long as the signature then reads grammatically - I had a little battle about this yesterday: http://comments.gmane.org/gmane.comp.lang.swift.evolution/23867<br>&gt; <br>&gt; To summarise:<br>&gt; - “after” should take a plain time interval<br>&gt; - “deadline” is just simply the wrong word - means something else entirely<br>&gt; - since we can’t take an interval without a clock, we need a default clock<br>&gt; - but the nuances with those clocks are very important and a source of subtle bugs, so we should also ask for precise intention<br>&gt; <br>&gt; =&gt; I think we should split DispatchQueue.after() based on clock type. This would allow us to provide a default value for “now”, meaning we can also accept plain time intervals, as the resulting API would be explicit about the clock nuances that are often overlooked.<br></p><p>I don’t think this topic needs forking and rehashing on this thread too.<br></p><p>&gt; <br>&gt;&gt;&gt;&gt;&gt; DispatchSource subclass names<br>&gt;&gt;&gt;&gt;&gt; -----------------------------<br>&gt;&gt;&gt;&gt;&gt; Why is it DispatchSourceMemoryPressure instead of MemoryPressureDispatchSource? I don’t think I’ve ever seen subclass names where the superclass part is at the beginning of the name.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m not so keen to remove the Dispatch prefix from the front of the source types, given that we avoided doing that for the remainder of the module.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What is the rationale for keeping the Dispatch prefix anyways? (I couldn’t find it in the archives.)<br>&gt; <br>&gt; I would also like to know this. I really don’t like typing Dispatch... every time. It doesn’t seem to be very forgiving with code-completion.<br></p><p>This was covered somewhat during initial evolution, after discussion with the core team we decided to keep the Dispatch prefix. Several of the class names make more contextual sense with a Dispatch prefix, where they would not otherwise; Queues, Groups, etc. Secondly, Dispatch is implicitly imported by Foundation and we feel that keeping the prefix is clearer to the developer what it is you’re actually using.<br></p><p>&gt; <br>&gt; Also, dispatch code tends to contain a fair amount of nested closures. It’s nice to keep the line lengths short in that case.<br>&gt; <br>&gt; Karl<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
