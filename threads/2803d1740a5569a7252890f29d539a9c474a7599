<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c753185b2c9261f9da6bf4372036cd07?s=50"></div><header><strong>Spread Operator as Shorthand for Map</strong> from <string>Sean Kosanovich</string> &lt;sean7512 at me.com&gt;<p>December 16, 2015 at 07:00:00am</p></header><div class="content"><p>As a Groovy user, I really enjoy the shorthand Spread Operator over the Collect Closure (Map is the equivalent in Swift).<br></p><p>Consider the following Swift code:<br></p><p>struct Car {<br>    let make: String<br>    let model: String<br>}<br></p><p>let cars = [Car(make: &quot;Jeep&quot;, model: &quot;Grand Cherokee&quot;), Car(make: &quot;Dodge&quot;, model: &quot;Challenger&quot;)]<br>let makes = cars.map() { $0.make }<br></p><p> <br></p><p>Now consider the same code using a Spread Operator:<br></p><p>let makes = cars*.make<br></p><p><br>The other distinction in Groovy is that the Spread Operator is null safe, meaning it won’t throw a NPE if an element is null, whereas the Collect Closure would.  So in Swift, I would propose the Spread Operator implicitly does this when operating on an array of Optionals:<br></p><p>let makes = cars.map() { $0?.make }<br></p><p><br>Thanks!<br>Sean<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/28037599/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>Spread Operator as Shorthand for Map</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>December 17, 2015 at 01:00:00am</p></header><div class="content"><p>That&#39;s a pretty nifty shorthand, although I don&#39;t personally think it adds<br>enough on top of map to be worthwhile:<br></p><p>let makes = cars*.make<br>let makes = cars.map{$0.make}<br></p><p>My reasons:<br> * It adds new things to learn, and only saves 4 characters on map<br> * Perhaps I&#39;m missing your point, but your code example is also null safe,<br>this doesn&#39;t seem to add an advantage.<br></p><p><br>On Wed, Dec 16, 2015 at 11:47 PM, Sean Kosanovich via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; As a Groovy user, I really enjoy the shorthand Spread Operator over the<br>&gt; Collect Closure (Map is the equivalent in Swift).<br>&gt;<br>&gt; Consider the following Swift code:<br>&gt;<br>&gt; struct Car {<br>&gt;     let make: String<br>&gt;     let model: String<br>&gt; }<br>&gt;<br>&gt; let cars = [Car(make: &quot;Jeep&quot;, model: &quot;Grand Cherokee&quot;), Car(make: &quot;Dodge&quot;,<br>&gt; model: &quot;Challenger&quot;)]<br>&gt; let makes = cars.map() { $0.make }<br>&gt;<br>&gt;<br>&gt;<br>&gt; Now consider the same code using a Spread Operator:<br>&gt;<br>&gt; let makes = cars*.make<br>&gt;<br>&gt;<br>&gt; The other distinction in Groovy is that the Spread Operator is null safe,<br>&gt; meaning it won’t throw a NPE if an element is null, whereas the Collect<br>&gt; Closure would.  So in Swift, I would propose the Spread Operator implicitly<br>&gt; does this when operating on an array of Optionals:<br>&gt;<br>&gt; let makes = cars.map() { $0?.make }<br>&gt;<br>&gt;<br>&gt; Thanks!<br>&gt; Sean<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/80a7efee/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Spread Operator as Shorthand for Map</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 16, 2015 at 09:00:00am</p></header><div class="content"><p>You can already define an infix operator that does this.  Are you proposing one be in the standard library?  I would be opposed to adding new syntax for this.<br></p><p>&gt; On Dec 16, 2015, at 6:47 AM, Sean Kosanovich via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; As a Groovy user, I really enjoy the shorthand Spread Operator over the Collect Closure (Map is the equivalent in Swift).<br>&gt; <br>&gt; Consider the following Swift code:<br>&gt; <br>&gt; struct Car {<br>&gt;     let make: String<br>&gt;     let model: String<br>&gt; }<br>&gt; <br>&gt; let cars = [Car(make: &quot;Jeep&quot;, model: &quot;Grand Cherokee&quot;), Car(make: &quot;Dodge&quot;, model: &quot;Challenger&quot;)]<br>&gt; let makes = cars.map() { $0.make }<br>&gt; <br>&gt;  <br>&gt; <br>&gt; Now consider the same code using a Spread Operator:<br>&gt; <br>&gt; let makes = cars*.make<br>&gt; <br>&gt; <br>&gt; The other distinction in Groovy is that the Spread Operator is null safe, meaning it won’t throw a NPE if an element is null, whereas the Collect Closure would.  So in Swift, I would propose the Spread Operator implicitly does this when operating on an array of Optionals:<br>&gt; <br>&gt; let makes = cars.map() { $0?.make }<br>&gt; <br>&gt; <br>&gt; Thanks!<br>&gt; Sean<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/9a15c8d6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c753185b2c9261f9da6bf4372036cd07?s=50"></div><header><strong>Spread Operator as Shorthand for Map</strong> from <string>Sean Kosanovich</string> &lt;sean7512 at me.com&gt;<p>December 16, 2015 at 10:00:00am</p></header><div class="content"><p>Yes, I am proposing this be part of the standard library.<br></p><p>Additional use cases that are possible in Groovy are using it for setting variables or calling methods, like the following (ignore the example of changing a car’s make doesn’t make much since):<br></p><p>cars*.make = “Chevrolet”<br></p><p>or <br></p><p>cars*.notifyOfLowFuel()<br></p><p><br>&gt; On Dec 16, 2015, at 10:14 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; You can already define an infix operator that does this.  Are you proposing one be in the standard library?  I would be opposed to adding new syntax for this.<br>&gt; <br>&gt;&gt; On Dec 16, 2015, at 6:47 AM, Sean Kosanovich via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; As a Groovy user, I really enjoy the shorthand Spread Operator over the Collect Closure (Map is the equivalent in Swift).<br>&gt;&gt; <br>&gt;&gt; Consider the following Swift code:<br>&gt;&gt; <br>&gt;&gt; struct Car {<br>&gt;&gt;     let make: String<br>&gt;&gt;     let model: String<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let cars = [Car(make: &quot;Jeep&quot;, model: &quot;Grand Cherokee&quot;), Car(make: &quot;Dodge&quot;, model: &quot;Challenger&quot;)]<br>&gt;&gt; let makes = cars.map() { $0.make }<br>&gt;&gt; <br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt; Now consider the same code using a Spread Operator:<br>&gt;&gt; <br>&gt;&gt; let makes = cars*.make<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; The other distinction in Groovy is that the Spread Operator is null safe, meaning it won’t throw a NPE if an element is null, whereas the Collect Closure would.  So in Swift, I would propose the Spread Operator implicitly does this when operating on an array of Optionals:<br>&gt;&gt; <br>&gt;&gt; let makes = cars.map() { $0?.make }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Thanks!<br>&gt;&gt; Sean<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/a84ac950/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Spread Operator as Shorthand for Map</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 16, 2015 at 09:00:00am</p></header><div class="content"><p>I see, this consists of a map operator as well as shorthand for referring to members of the type provided to the map function (similar to shorthand for referring to enum cases).  The latter does seem like it could be pretty useful if it doesn’t introduce any ambiguities.  <br></p><p>A standard map operator might also be useful but I would expect to see it as part of a suite of functional operators if the standard ever adds one (I hope it does).<br></p><p><br>&gt; On Dec 16, 2015, at 9:18 AM, Sean Kosanovich &lt;sean7512 at me.com&gt; wrote:<br>&gt; <br>&gt; Yes, I am proposing this be part of the standard library.<br>&gt; <br>&gt; Additional use cases that are possible in Groovy are using it for setting variables or calling methods, like the following (ignore the example of changing a car’s make doesn’t make much since):<br>&gt; <br>&gt; cars*.make = “Chevrolet”<br>&gt; <br>&gt; or <br>&gt; <br>&gt; cars*.notifyOfLowFuel()<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 16, 2015, at 10:14 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; You can already define an infix operator that does this.  Are you proposing one be in the standard library?  I would be opposed to adding new syntax for this.<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 16, 2015, at 6:47 AM, Sean Kosanovich via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As a Groovy user, I really enjoy the shorthand Spread Operator over the Collect Closure (Map is the equivalent in Swift).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Consider the following Swift code:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Car {<br>&gt;&gt;&gt;     let make: String<br>&gt;&gt;&gt;     let model: String<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let cars = [Car(make: &quot;Jeep&quot;, model: &quot;Grand Cherokee&quot;), Car(make: &quot;Dodge&quot;, model: &quot;Challenger&quot;)]<br>&gt;&gt;&gt; let makes = cars.map() { $0.make }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Now consider the same code using a Spread Operator:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let makes = cars*.make<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The other distinction in Groovy is that the Spread Operator is null safe, meaning it won’t throw a NPE if an element is null, whereas the Collect Closure would.  So in Swift, I would propose the Spread Operator implicitly does this when operating on an array of Optionals:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let makes = cars.map() { $0?.make }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks!<br>&gt;&gt;&gt; Sean<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/1170b728/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2861bfeb71de9de58206bb6ae750bc2f?s=50"></div><header><strong>Spread Operator as Shorthand for Map</strong> from <string>ilya</string> &lt;ilya.nikokoshev at gmail.com&gt;<p>December 16, 2015 at 03:00:00pm</p></header><div class="content"><p>I think you would be able to define such an operator if .make was<br>recognized as Car.make in the Car context.<br>Which would be a cool addition to current rules.<br></p><p>On Wed, Dec 16, 2015 at 18:15 Matthew Johnson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; You can already define an infix operator that does this.  Are you<br>&gt; proposing one be in the standard library?  I would be opposed to adding new<br>&gt; syntax for this.<br>&gt;<br>&gt; On Dec 16, 2015, at 6:47 AM, Sean Kosanovich via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; As a Groovy user, I really enjoy the shorthand Spread Operator over the<br>&gt; Collect Closure (Map is the equivalent in Swift).<br>&gt;<br>&gt; Consider the following Swift code:<br>&gt;<br>&gt; struct Car {<br>&gt;     let make: String<br>&gt;     let model: String<br>&gt; }<br>&gt;<br>&gt; let cars = [Car(make: &quot;Jeep&quot;, model: &quot;Grand Cherokee&quot;), Car(make: &quot;Dodge&quot;,<br>&gt; model: &quot;Challenger&quot;)]<br>&gt; let makes = cars.map() { $0.make }<br>&gt;<br>&gt;<br>&gt;<br>&gt; Now consider the same code using a Spread Operator:<br>&gt;<br>&gt; let makes = cars*.make<br>&gt;<br>&gt;<br>&gt; The other distinction in Groovy is that the Spread Operator is null safe,<br>&gt; meaning it won’t throw a NPE if an element is null, whereas the Collect<br>&gt; Closure would.  So in Swift, I would propose the Spread Operator implicitly<br>&gt; does this when operating on an array of Optionals:<br>&gt;<br>&gt; let makes = cars.map() { $0?.make }<br>&gt;<br>&gt;<br>&gt; Thanks!<br>&gt; Sean<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/65c2e833/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/abf891ba571d5a819ddf547917abe1e1?s=50"></div><header><strong>Spread Operator as Shorthand for Map</strong> from <string>Al Skipp</string> &lt;al_skipp at fastmail.fm&gt;<p>December 16, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; On 16 Dec 2015, at 12:47, Sean Kosanovich via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; As a Groovy user, I really enjoy the shorthand Spread Operator over the Collect Closure (Map is the equivalent in Swift).<br>&gt; <br>&gt; Consider the following Swift code:<br>&gt; <br>&gt; struct Car {<br>&gt;     let make: String<br>&gt;     let model: String<br>&gt; }<br>&gt; <br>&gt; let cars = [Car(make: &quot;Jeep&quot;, model: &quot;Grand Cherokee&quot;), Car(make: &quot;Dodge&quot;, model: &quot;Challenger&quot;)]<br>&gt; let makes = cars.map() { $0.make }<br>&gt; <br>&gt;  <br>&gt; <br>&gt; Now consider the same code using a Spread Operator:<br>&gt; <br>&gt; let makes = cars*.make<br></p><p>I think there is a tension in Swift between its object oriented nature and higher-order functions which leads to a lot of repetition of { $0.property }<br></p><p>In this example:<br>cars.map { $0.make }<br></p><p>I’d like to write the following, but ‘make’ is a member, not a free function:<br>cars.map(make)<br></p><p>Is anyone else irked by the preponderance of { $0.property } in Swift (or is it just me being grumpy)? Not sure what the solution would be, but I can’t say I’m keen on the suggestion of:<br></p><p>cars*.make<br></p><p>It’s too mysterious.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/54bdb8dd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Spread Operator as Shorthand for Map</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 16, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; <br>&gt; I’d like to write the following, but ‘make’ is a member, not a free function:<br>&gt; cars.map(make)<br></p><p>If we peel off just the contextual shorthand aspect of this proposal you could write:<br></p><p>cars.map(.make)<br></p><p>That does seem like a big win if it is feasible (doesn’t introduce ambiguity or cause other significant challenges in implementation).  <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/6ee908d7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/abf891ba571d5a819ddf547917abe1e1?s=50"></div><header><strong>Spread Operator as Shorthand for Map</strong> from <string>Al Skipp</string> &lt;al_skipp at fastmail.fm&gt;<p>December 16, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; On 16 Dec 2015, at 15:50, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; If we peel off just the contextual shorthand aspect of this proposal you could write:<br>&gt; <br>&gt; cars.map(.make)<br>&gt; <br>&gt; That does seem like a big win if it is feasible (doesn’t introduce ambiguity or cause other significant challenges in implementation).  <br></p><p>Assuming the implementation is feasible, it looks pretty good to me.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/6c35b710/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d68c97e8e2f1653b54c24493caf236ae?s=50"></div><header><strong>Spread Operator as Shorthand for Map</strong> from <string>Stephen Celis</string> &lt;stephen.celis at gmail.com&gt;<p>December 16, 2015 at 11:00:00am</p></header><div class="content"><p>On Wed, Dec 16, 2015 at 10:50 AM, Matthew Johnson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>If we peel off just the contextual shorthand aspect of this proposal you<br>&gt; could write:<br>&gt;<br>&gt; cars.map(.make)<br>&gt;<br>&gt; That does seem like a big win if it is feasible (doesn’t introduce<br>&gt; ambiguity or cause other significant challenges in implementation).<br>&gt;<br></p><p>The above creates ambiguity if there were a `map` function that takes a<br>type with a static member `make`.<br></p><p>Alternatively:<br></p><p>    cars.map{.make}<br></p><p>Both create an additional meaning for dot abbreviation, though, which is<br>confusing. I think I&#39;m &quot;-1&quot; on this proposal as is. The existing form is<br>clearer and relatively short as is.<br></p><p>Stephen<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/ea51aea0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Spread Operator as Shorthand for Map</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 16, 2015 at 10:00:00am</p></header><div class="content"><p>This wouldn’t be ambiguous with static methods.  Confusing to some developers possibly, but not ambiguous.  Map would be expecting a function that takes an instance.  Depending on the details of how it was defined in the language it could be ambiguous with a static property of a function type:<br></p><p>Car {<br>  static let make: Car -&gt; SomeOtherType<br>}<br></p><p>This potential ambiguity could probably be defined away by making the shorthand specifically apply to instance methods or something like that.<br></p><p>There would not be an entirely new meaning for the . shorthand.  It would be an extrapolation of the shorthand for enum cases.<br></p><p>That said, I was replying quickly and my example was not quite accurate.  “make&quot; is a getter which cannot be accessed in unbound form today.  There are proposals to allow this to be done in other threads.  Syntax from one example is Car.make#get (lets not get caught up on syntax of that here).  So correcting my example it would look like:<br></p><p>cars.map(.make#get)<br></p><p>If make was a method we would need to bind all of the arguments except the curried instance argument so it would look like this:<br></p><p>cars.map(.make())<br></p><p>And a method with more arguments would look like this:<br></p><p>cars.map(.methodWithInt(1, string: “hello&quot;))<br></p><p>I’m not necessarily advocating for something like this, just trying to think through the implications of it at this point.<br></p><p>Matthew<br></p><p>&gt; On Dec 16, 2015, at 10:18 AM, Stephen Celis &lt;stephen.celis at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Wed, Dec 16, 2015 at 10:50 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; If we peel off just the contextual shorthand aspect of this proposal you could write:<br>&gt; <br>&gt; cars.map(.make)<br>&gt; <br>&gt; That does seem like a big win if it is feasible (doesn’t introduce ambiguity or cause other significant challenges in implementation).<br>&gt; <br>&gt; The above creates ambiguity if there were a `map` function that takes a type with a static member `make`.<br>&gt; <br>&gt; Alternatively:<br>&gt; <br>&gt;     cars.map{.make}<br>&gt; <br>&gt; Both create an additional meaning for dot abbreviation, though, which is confusing. I think I&#39;m &quot;-1&quot; on this proposal as is. The existing form is clearer and relatively short as is.<br>&gt; <br>&gt; Stephen<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/39bc91ad/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d68c97e8e2f1653b54c24493caf236ae?s=50"></div><header><strong>Spread Operator as Shorthand for Map</strong> from <string>Stephen Celis</string> &lt;stephen.celis at gmail.com&gt;<p>December 16, 2015 at 12:00:00pm</p></header><div class="content"><p>On Wed, Dec 16, 2015 at 11:34 AM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt; This wouldn’t be ambiguous with static methods.  Confusing to some<br>&gt; developers possibly, but not ambiguous.  Map would be expecting a function<br>&gt; that takes an instance.  Depending on the details of how it was defined in<br>&gt; the language it could be ambiguous with a static property of a function<br>&gt; type:<br>&gt;<br></p><p>Sorry, I meant ambiguous via extension (on a sequence type). Super<br>contrived example:<br></p><p>    struct Foo {<br>        static var bar = Foo()<br>    }<br>    extension Array {<br>        func map(foo: Foo) {}<br>    }<br>    [1, 2, 3].map(.bar)<br></p><p>I doubt there would be much ambiguity in practice, as disambiguation would<br>come naturally at the call site.<br></p><p>There would not be an entirely new meaning for the . shorthand.  It would<br>&gt; be an extrapolation of the shorthand for enum cases.<br>&gt;<br></p><p>I merely meant that dot-abbreviation now specifically resolves to a static<br>member that returns the type. The dot-abbreviation in your examples is a<br>different behavior and adds a bit of complexity to learning Swift.<br></p><p>Stephen<br></p><p>On Wed, Dec 16, 2015 at 11:34 AM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt; This wouldn’t be ambiguous with static methods.  Confusing to some<br>&gt; developers possibly, but not ambiguous.  Map would be expecting a function<br>&gt; that takes an instance.  Depending on the details of how it was defined in<br>&gt; the language it could be ambiguous with a static property of a function<br>&gt; type:<br>&gt;<br>&gt; Car {<br>&gt;   static let make: Car -&gt; SomeOtherType<br>&gt; }<br>&gt;<br>&gt; This potential ambiguity could probably be defined away by making the<br>&gt; shorthand specifically apply to instance methods or something like that.<br>&gt;<br>&gt; There would not be an entirely new meaning for the . shorthand.  It would<br>&gt; be an extrapolation of the shorthand for enum cases.<br>&gt;<br>&gt; That said, I was replying quickly and my example was not quite accurate.<br>&gt;  “make&quot; is a getter which cannot be accessed in unbound form today.  There<br>&gt; are proposals to allow this to be done in other threads.  Syntax from one<br>&gt; example is Car.make#get (lets not get caught up on syntax of that here).<br>&gt; So correcting my example it would look like:<br>&gt;<br>&gt; cars.map(.make#get)<br>&gt;<br>&gt; If make was a method we would need to bind all of the arguments except the<br>&gt; curried instance argument so it would look like this:<br>&gt;<br>&gt; cars.map(.make())<br>&gt;<br>&gt; And a method with more arguments would look like this:<br>&gt;<br>&gt; cars.map(.methodWithInt(1, string: “hello&quot;))<br>&gt;<br>&gt; I’m not necessarily advocating for something like this, just trying to<br>&gt; think through the implications of it at this point.<br>&gt;<br>&gt; Matthew<br>&gt;<br>&gt; On Dec 16, 2015, at 10:18 AM, Stephen Celis &lt;stephen.celis at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; On Wed, Dec 16, 2015 at 10:50 AM, Matthew Johnson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; If we peel off just the contextual shorthand aspect of this proposal you<br>&gt;&gt; could write:<br>&gt;&gt;<br>&gt;&gt; cars.map(.make)<br>&gt;&gt;<br>&gt;&gt; That does seem like a big win if it is feasible (doesn’t introduce<br>&gt;&gt; ambiguity or cause other significant challenges in implementation).<br>&gt;&gt;<br>&gt;<br>&gt; The above creates ambiguity if there were a `map` function that takes a<br>&gt; type with a static member `make`.<br>&gt;<br>&gt; Alternatively:<br>&gt;<br>&gt;     cars.map{.make}<br>&gt;<br>&gt; Both create an additional meaning for dot abbreviation, though, which is<br>&gt; confusing. I think I&#39;m &quot;-1&quot; on this proposal as is. The existing form is<br>&gt; clearer and relatively short as is.<br>&gt;<br>&gt; Stephen<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/418d41e3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Spread Operator as Shorthand for Map</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 16, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; <br>&gt; Sorry, I meant ambiguous via extension (on a sequence type). Super contrived example:<br>&gt; <br>&gt;     struct Foo {<br>&gt;         static var bar = Foo()<br>&gt;     }<br>&gt;     extension Array {<br>&gt;         func map(foo: Foo) {}<br>&gt;     }<br>&gt;     [1, 2, 3].map(.bar)<br>&gt; <br>&gt; I doubt there would be much ambiguity in practice, as disambiguation would come naturally at the call site.<br>&gt; <br>&gt; There would not be an entirely new meaning for the . shorthand.  It would be an extrapolation of the shorthand for enum cases.<br>&gt; <br>&gt; I merely meant that dot-abbreviation now specifically resolves to a static member that returns the type. The dot-abbreviation in your examples is a different behavior and adds a bit of complexity to learning Swift.<br></p><p>This is still not correct for a couple of reasons.  The meaning of the dot-abbreviation could be defined in several ways.  A static member returning the type is not one of them.  In the context of the current map example the type returned by the dot-abbreviation expression would be ‘Element -&gt; OtherType’.  (Element being the type contained in the array, which would be Self in the context of that type)<br></p><p>Here are some examples:<br></p><p>struct Foo {<br>    var bar: Foo<br></p><p>    func bar() -&gt; OtherType<br>    func bar(s: String) -&gt; OtherType<br></p><p>    // the property shadows the static function when accessed with Foo.bar syntax<br>    // the same behavior would be exhibited in the shorthand if it applied to static members<br>    static func bar(f: Foo) -&gt; OtherType {}<br>    static var bar: Foo -&gt; OtherType = { _ in OtherType() }<br>}<br></p><p>[Foo]().map(.bar()) // instance method<br>[Foo]().map(.bar(“hello&quot;)) // instance method<br>[Foo]().map(.bar#get) // instance property<br></p><p>// this would reference a static property or static function if that is allowed<br>// however if we define the dot-abbreviation to access only unbound instance members<br>// this could be a shorthand for .bar#get as it would be the only unbound instance member with the correct type<br>[Foo]().map(.bar) <br></p><p>// <br>[Foo]().map(.bar) <br></p><p>If we do add a dot-abbreviation like this it would probably make sense to define it such that it only applies to curried functions where the first argument is of the type required in the context.  Because curried syntax is getting dropped that would mean only unbound instance methods / properties / subscripts would be eligible.  Because the dot-abbreviation would be defined as an unbound reference we probably don’t need the special syntax for getters and subscripts.<br></p><p>It is possible this syntax would be confusing for some developers, at least until they learn how it works.  But I don’t think we’ve seen any examples of ambiguity yet (of course there may be some we just haven’t discussed yet).<br></p><p>There is precedent for dot-abrreviation in the language already related to enums and this definitely improves clarity and readability.  I think it definitely deserves further consideration.<br></p><p>Matthew<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/f77b459d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d68c97e8e2f1653b54c24493caf236ae?s=50"></div><header><strong>Spread Operator as Shorthand for Map</strong> from <string>Stephen Celis</string> &lt;stephen.celis at gmail.com&gt;<p>December 16, 2015 at 01:00:00pm</p></header><div class="content"><p>On Wed, Dec 16, 2015 at 1:13 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>This is still not correct for a couple of reasons.  The meaning of the<br>&gt; dot-abbreviation could be defined in several ways.  A static member<br>&gt; returning the type is not one of them.  In the context of the current map<br>&gt; example the type returned by the dot-abbreviation expression would be<br>&gt; ‘Element -&gt; OtherType’.  (Element being the type contained in the array,<br>&gt; which would be Self in the context of that type)<br>&gt;<br></p><p>I&#39;m confused. Isn&#39;t a static member returning the type the _only_ way dot<br>abbreviation works right right now? Please correct me with an example if<br>I&#39;m wrong.<br></p><p>Here are some examples:<br>&gt;<br></p><p>I think I understand your examples. They just don&#39;t work right now and<br>behave differently than dot abbreviation currently works.<br></p><p><br>&gt; It is possible this syntax would be *confusing* for some developers, at<br>&gt; least until they learn how it works.  But I don’t think we’ve seen any<br>&gt; examples of ambiguity yet (of course there may be some we just haven’t<br>&gt; discussed yet).<br>&gt;<br></p><p>The shadowing you propose in your example attempts to resolve the ambiguity<br>I was referring to.<br></p><p>Let&#39;s take my earlier example. It would theoretically produce ambiguity if<br>`Int` had a `bar` method. The resolver wouldn&#39;t have enough type<br>information to resolve things. E.g.:<br></p><p>    struct Foo {<br>        static var bar = Foo()<br>    }<br>    extension Array {<br>        func map(foo: Foo) {}<br>    }<br>    extension Int {<br>        func bar() -&gt; String { return String(self) }<br>    }<br>    [1, 2, 3].map(.bar) // would this refer to `Foo.bar` or `Int.bar`?<br></p><p>Your example would seem to prefer `Int.bar`. This kind of<br>complexity/gotcha/learning moment is something I&#39;d rather avoid.<br></p><p>There is precedent for dot-abrreviation in the language already related to<br>&gt; enums and this definitely improves clarity and readability.  I think it<br>&gt; definitely deserves further consideration.<br>&gt;<br></p><p>Enum cases are static members (e.g., `enum Foo { case Bar }` allows you to<br>reference the `Bar` case as `Foo.Bar`, or abbreviated as `.Bar` where type<br>`Foo` is expected). This is what I was trying to communicate before. (The<br>same static resolution lets you pass `.redColor()` where a `UIColor` is<br>expected.) I&#39;m just not sure co-opting dot abbreviation to also work with<br>instance methods is worth the added complexity.<br></p><p>Hope I&#39;m being clearer this time around, and let me know if I&#39;m still not<br>making sense or if I&#39;m missing anything.<br></p><p>Stephen<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/e5b0e4af/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Spread Operator as Shorthand for Map</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 16, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; <br>&gt; I&#39;m confused. Isn&#39;t a static member returning the type the _only_ way dot abbreviation works right right now? Please correct me with an example if I&#39;m wrong.<br></p><p>I believe the dot abbreviation only works for enum cases right now.  I suppose those can be viewed as static members in some sense but they really something different than that.  If I am mistaken I would like to be corrected.<br></p><p>&gt; <br>&gt; I think I understand your examples. They just don&#39;t work right now and behave differently than dot abbreviation currently works.<br></p><p>Yes, they behave somewhat differently as they are an extension of the behavior to struct and class instance members.<br></p><p>&gt;  <br>&gt; It is possible this syntax would be confusing for some developers, at least until they learn how it works.  But I don’t think we’ve seen any examples of ambiguity yet (of course there may be some we just haven’t discussed yet).<br>&gt; <br>&gt; The shadowing you propose in your example attempts to resolve the ambiguity I was referring to.<br></p><p>The shadowing is *current* behavior in the language.  It is not something I propose.<br></p><p>&gt; <br>&gt; Let&#39;s take my earlier example. It would theoretically produce ambiguity if `Int` had a `bar` method. The resolver wouldn&#39;t have enough type information to resolve things. E.g.:<br>&gt; <br>&gt;     struct Foo {<br>&gt;         static var bar = Foo()<br>&gt;     }<br>&gt;     extension Array {<br>&gt;         func map(foo: Foo) {}<br>&gt;     }<br>&gt;     extension Int {<br>&gt;         func bar() -&gt; String { return String(self) }<br>&gt;     }<br>&gt;     [1, 2, 3].map(.bar) // would this refer to `Foo.bar` or `Int.bar`?<br></p><p>This would not refer to either.  It cannot refer to Foo.bar because Foo has nothing to do with the array you are mapping over.  The syntax matching my example would be:<br></p><p>[1, 2, 3].map(.bar())<br></p><p><br>&gt; Your example would seem to prefer `Int.bar`. This kind of complexity/gotcha/learning moment is something I&#39;d rather avoid.<br>&gt; <br>&gt; There is precedent for dot-abrreviation in the language already related to enums and this definitely improves clarity and readability.  I think it definitely deserves further consideration.<br>&gt; <br>&gt; Enum cases are static members (e.g., `enum Foo { case Bar }` allows you to reference the `Bar` case as `Foo.Bar`, or abbreviated as `.Bar` where type `Foo` is expected). This is what I was trying to communicate before. (The same static resolution lets you pass `.redColor()` where a `UIColor` is expected.) I&#39;m just not sure co-opting dot abbreviation to also work with instance methods is worth the added complexity.<br></p><p>In the enum example here you cannot refer to .Bar in an arbitrary context.  It must be known by context that you are referring to a case of Foo.  It appears to me like your understanding of the existing dot abbreviation for enums is not quite correct and this misunderstanding is probably contributing to your misunderstanding and confusion regarding my examples.<br></p><p>Matthew<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/aecbfaf7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d68c97e8e2f1653b54c24493caf236ae?s=50"></div><header><strong>Spread Operator as Shorthand for Map</strong> from <string>Stephen Celis</string> &lt;stephen.celis at gmail.com&gt;<p>December 16, 2015 at 02:00:00pm</p></header><div class="content"><p>On Wed, Dec 16, 2015 at 2:18 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>I believe the dot abbreviation only works for enum cases right now.<br>&gt;<br></p><p>Nope :)<br></p><p><br>&gt; I suppose those can be viewed as static members in some sense but they<br>&gt; really something different than that.  If I am mistaken I would like to be<br>&gt; corrected.<br>&gt;<br></p><p>I&#39;ll do my best!<br></p><p>It works as I was trying to describe earlier. Any static member that<br>returns Self. Try the following in a playground/REPL:<br></p><p>    struct Foo {<br>        static var bar: Foo {<br>            return Foo()<br>        }<br>        static func baz() -&gt; Foo {<br>            return Foo()<br>        }<br>    }<br>    let bar: Foo = .bar<br>    let baz: Foo = .baz()<br></p><p>Here&#39;s a SwiftStub demonstrating the behavior:<br>http://swiftstub.com/579553153<br></p><p>Enum cases work with dot abbreviation _because_ they are static members<br>that return Self. Enumerations aren&#39;t special-cased for dot abbreviation.<br></p><p>The shadowing is *current* behavior in the language.  It is not something I<br>&gt; propose.<br>&gt;<br></p><p>Is this true? Can you provide a full example that works in the playground<br>and demonstrates this? The hypothetical you paste already has certain<br>ambiguous issues (e.g. `var foo` and `func foo()` cannot compile together<br>because of redefinition).<br></p><p><br>&gt; This would not refer to either.  It cannot refer to Foo.bar because Foo<br>&gt; has nothing to do with the array you are mapping over.<br>&gt;<br></p><p>The example I give works in the playground. Try it! :)<br></p><p><br>&gt; The syntax matching my example would be:<br>&gt;<br>&gt; [1, 2, 3].map(.bar())<br>&gt;<br></p><p>This would be ambiguous with a static function, `bar()`, that return Self.<br></p><p><br>&gt; In the enum example here you cannot refer to .Bar in an arbitrary<br>&gt; context.  It must be known by context that you are referring to a case of<br>&gt; Foo.  It appears to me like your understanding of the existing dot<br>&gt; abbreviation for enums is not quite correct and this misunderstanding is<br>&gt; probably contributing to your misunderstanding and confusion regarding my<br>&gt; examples.<br>&gt;<br></p><p>I don&#39;t believe that I&#39;m misunderstanding, but I&#39;ll take working examples<br>to the contrary.<br></p><p>Please try the examples I&#39;ve provided in a playground (and the SwiftStub<br>link, above). I hope I&#39;ve clarified how dot abbreviation works! Let me know<br>if you have any questions.<br></p><p>Stephen<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/54c72f16/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Spread Operator as Shorthand for Map</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 16, 2015 at 10:00:00pm</p></header><div class="content"><p>&gt; On Dec 16, 2015, at 1:32 PM, Stephen Celis &lt;stephen.celis at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Wed, Dec 16, 2015 at 2:18 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt; <br>&gt; I believe the dot abbreviation only works for enum cases right now.<br>&gt; <br>&gt; Nope :)<br>&gt;  <br>&gt; I suppose those can be viewed as static members in some sense but they really something different than that.  If I am mistaken I would like to be corrected.<br>&gt; <br>&gt; I&#39;ll do my best!<br>&gt; <br>&gt; It works as I was trying to describe earlier. Any static member that returns Self. Try the following in a playground/REPL:<br>&gt; <br>&gt;     struct Foo {<br>&gt;         static var bar: Foo {<br>&gt;             return Foo()<br>&gt;         }<br>&gt;         static func baz() -&gt; Foo {<br>&gt;             return Foo()<br>&gt;         }<br>&gt;     }<br>&gt;     let bar: Foo = .bar<br>&gt;     let baz: Foo = .baz()<br>&gt; <br>&gt; Here&#39;s a SwiftStub demonstrating the behavior: http://swiftstub.com/579553153 &lt;http://swiftstub.com/579553153&gt;<br>&gt; <br>&gt; Enum cases work with dot abbreviation _because_ they are static members that return Self. Enumerations aren&#39;t special-cased for dot abbreviation.<br>&gt; <br></p><p>I stand corrected.  This is pretty interesting.  Is this covered in any documentation?  I haven’t seen anything about it nor any code that uses this until now.  It would be useful with factory methods.  I appreciate your calling this to my attention!<br></p><p>&gt; The shadowing is *current* behavior in the language.  It is not something I propose.<br>&gt; <br>&gt; Is this true? Can you provide a full example that works in the playground and demonstrates this? The hypothetical you paste already has certain ambiguous issues (e.g. `var foo` and `func foo()` cannot compile together because of redefinition).<br></p><p>Here is an example.  I tested it in an app rather than a playground (moving the print line into main).<br></p><p>struct Foo {<br>    //static var bar: Foo -&gt; String = { _ in return &quot;var&quot; }<br>    static func bar(f: Foo) -&gt; String { return &quot;func&quot; }<br>}<br>// prints “func”, but will compile and print “bar” if you uncomment the var<br>print(Foo.bar(Foo())) <br></p><p><br>&gt;  <br>&gt; This would not refer to either.  It cannot refer to Foo.bar because Foo has nothing to do with the array you are mapping over.<br>&gt; <br>&gt; The example I give works in the playground. Try it! :)<br></p><p>You are right here as well.  I didn’t read closely enough and didn’t notice the overload of map you added to Array.<br></p><p>If you remove that overload your code will fail to compile.  This is because the dot abbreviation is context sensitive.  It only works when the type system knows the type the expression is expected to produce.<br></p><p>Because of this context sensitivity no ambiguity would arise from the example you provided.  As you note, the type of the static property or method must always be Self, which is never going to be a function type.  This means that it is never going to have the same type as an unbound instance method (that its non-self arguments bound).  <br></p><p>Because of this the two shorthand notations will never be applicable in the same type context.  I can see how the similarity could be confusing but it is not ambiguous.  The potential confusion might even be enough to avoid introducing it into the language, but I’m not sure about that.  <br></p><p>I still think it’s an interesting idea.<br></p><p>Matthew<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/fed42cb2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d68c97e8e2f1653b54c24493caf236ae?s=50"></div><header><strong>Spread Operator as Shorthand for Map</strong> from <string>Stephen Celis</string> &lt;stephen.celis at gmail.com&gt;<p>December 16, 2015 at 11:00:00pm</p></header><div class="content"><p>&gt; On Dec 16, 2015, at 11:28 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; I stand corrected.  This is pretty interesting.  Is this covered in any documentation?  I haven’t seen anything about it nor any code that uses this until now.  It would be useful with factory methods.  I appreciate your calling this to my attention!<br></p><p>I think it&#39;s described, but obviously not clearly enough. Might be worth opening a bug requesting better documentation around the behavior.<br></p><p>&gt;&gt; The shadowing is *current* behavior in the language.  It is not something I propose.<br>&gt;&gt; <br>&gt;&gt; Is this true? Can you provide a full example that works in the playground and demonstrates this? The hypothetical you paste already has certain ambiguous issues (e.g. `var foo` and `func foo()` cannot compile together because of redefinition).<br>&gt; <br>&gt; Here is an example.  I tested it in an app rather than a playground (moving the print line into main).<br>&gt; <br>&gt; struct Foo {<br>&gt;     //static var bar: Foo -&gt; String = { _ in return &quot;var&quot; }<br>&gt;     static func bar(f: Foo) -&gt; String { return &quot;func&quot; }<br>&gt; }<br>&gt; // prints “func”, but will compile and print “bar” if you uncomment the var<br>&gt; print(Foo.bar(Foo())) <br></p><p>Ah, yeah, the fact that there are arguments disambiguates (which is interesting in itself). If you make a variable and then a function without arguments, per your earlier example, it won’t compile:<br></p><p>    struct Foo {<br>        //static var bar: String = &quot;var&quot;<br>        static func bar() -&gt; String { return &quot;func&quot; }<br>    }<br>    // prints &quot;func&quot; and won&#39;t compile if you uncomment the var<br>    print(Foo.bar(Foo())) <br></p><p>&gt;&gt; This would not refer to either.  It cannot refer to Foo.bar because Foo has nothing to do with the array you are mapping over.<br>&gt;&gt; <br>&gt;&gt; The example I give works in the playground. Try it! :)<br>&gt; <br>&gt; You are right here as well.  I didn’t read closely enough and didn’t notice the overload of map you added to Array.<br>&gt; <br>&gt; If you remove that overload your code will fail to compile.  This is because the dot abbreviation is context sensitive.  It only works when the type system knows the type the expression is expected to produce.<br></p><p>Of course :) And if the overload stays and your suggested syntax were added, it would be ambiguous and also fail to compile.<br></p><p>&gt; Because of this context sensitivity no ambiguity would arise from the example you provided.  As you note, the type of the static property or method must always be Self, which is never going to be a function type.  This means that it is never going to have the same type as an unbound instance method (that its non-self arguments bound).  <br>&gt; <br>&gt; Because of this the two shorthand notations will never be applicable in the same type context.  I can see how the similarity could be confusing but it is not ambiguous.  The potential confusion might even be enough to avoid introducing it into the language, but I’m not sure about that.<br></p><p>This was my exact point earlier. It&#39;s unlikely to be ambiguous (because context _generally_ disambiguates), but in the examples I give, they certainly are ambiguous (and thus can be).<br></p><p>My general stance remains that, while an interesting idea, adding a second behavior around dot abbreviation causes more confusion than it&#39;s worth (especially given that the behavior is not well understood—this thread being an example), and that {$0.whatever} is not a big burden over (.whatever).<br></p><p>Stephen<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/d6013997/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Spread Operator as Shorthand for Map</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 16, 2015 at 09:00:00pm</p></header><div class="content"><p>&gt; My general stance remains that, while an interesting idea, adding a second behavior around dot abbreviation causes more confusion than it&#39;s worth (especially given that the behavior is not well understood—this thread being an example), and that {$0.whatever} is not a big burden over (.whatever).<br></p><p>Who says it’s a different behavior? If `var foo: Bar` implies `static func foo(self: Self) -&gt; Bar`, then this falls out of that behavior.<br></p><p>As for conflicts, the same issue exists with the unbound methods declared on a type, and in practice it doesn’t cause any problems.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d68c97e8e2f1653b54c24493caf236ae?s=50"></div><header><strong>Spread Operator as Shorthand for Map</strong> from <string>Stephen Celis</string> &lt;stephen.celis at gmail.com&gt;<p>December 17, 2015 at 07:00:00am</p></header><div class="content"><p>&gt; On Dec 17, 2015, at 12:20 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; My general stance remains that, while an interesting idea, adding a second behavior around dot abbreviation causes more confusion than it&#39;s worth (especially given that the behavior is not well understood—this thread being an example), and that {$0.whatever} is not a big burden over (.whatever).<br>&gt; <br>&gt; Who says it’s a different behavior? If `var foo: Bar` implies `static func foo(self: Self) -&gt; Bar`, then this falls out of that behavior.<br></p><p>Ah, maybe my brain was just wired to look at things differently :) Where the rule right now is:<br></p><p>    where (Self) is expected<br>        accept .foo where (Self).foo -&gt; (Self)<br></p><p>The rule suggested here is:<br></p><p>    where (Self -&gt; T) is expected<br>        accept .foo where (Self).foo -&gt; (Self -&gt; T)<br></p><p>Really close, but the method signature needs to unravel to resolve, since `.foo` isn&#39;t on type (Self -&gt; T). Not to say that it shouldn&#39;t, just that it doesn&#39;t.<br></p><p>&gt; As for conflicts, the same issue exists with the unbound methods declared on a type, and in practice it doesn’t cause any problems.<br></p><p>Yup, that&#39;s because those unbound methods take arguments. The upstream discussion around a `.foo#get` makes sense for disambiguation, and type resolution generally avoids ambiguity.<br></p><p>I&#39;m interested in more complex examples than mapping to a property. This kind of function unraveling could have interesting applications.<br></p><p>Stephen<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Spread Operator as Shorthand for Map</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 16, 2015 at 11:00:00pm</p></header><div class="content"><p>&gt;&gt; <br>&gt;&gt; If you remove that overload your code will fail to compile.  This is because the dot abbreviation is context sensitive.  It only works when the type system knows the type the expression is expected to produce.<br>&gt; <br>&gt; Of course :) And if the overload stays and your suggested syntax were added, it would be ambiguous and also fail to compile.<br></p><p>This is not true.  They would have different types and therefore would not be ambiguous.  <br></p><p>But it’s not central to your position anyway since you are opposed on the grounds of potential for confusion rather than actual ambiguity.  :)  That is a fair and reasonable position with or without ambiguity. <br></p><p>&gt; My general stance remains that, while an interesting idea, adding a second behavior around dot abbreviation causes more confusion than it&#39;s worth (especially given that the behavior is not well understood—this thread being an example), and that {$0.whatever} is not a big burden over (.whatever).<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/7f3c3b2a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d68c97e8e2f1653b54c24493caf236ae?s=50"></div><header><strong>Spread Operator as Shorthand for Map</strong> from <string>Stephen Celis</string> &lt;stephen.celis at gmail.com&gt;<p>December 17, 2015 at 07:00:00am</p></header><div class="content"><p>&gt; On Dec 17, 2015, at 12:33 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; If you remove that overload your code will fail to compile.  This is because the dot abbreviation is context sensitive.  It only works when the type system knows the type the expression is expected to produce.<br>&gt;&gt; <br>&gt;&gt; Of course :) And if the overload stays and your suggested syntax were added, it would be ambiguous and also fail to compile.<br>&gt; <br>&gt; This is not true.  They would have different types and therefore would not be ambiguous.<br></p><p>It&#39;s true in my example, but my example is an unlikely, type-ambiguous situation and is unlikely to occur in usage.<br></p><p>&gt; But it’s not central to your position anyway since you are opposed on the grounds of potential for confusion rather than actual ambiguity.  :)  That is a fair and reasonable position with or without ambiguity.<br></p><p>I&#39;m not opposed to the idea if it has broad applications and the type resolution is predictable. I think I&#39;m probably doing a bad job of predicting.<br></p><p>Stephen<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/cfc28639/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Spread Operator as Shorthand for Map</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 17, 2015 at 08:00:00am</p></header><div class="content"><p>&gt; On Dec 17, 2015, at 6:47 AM, Stephen Celis &lt;stephen.celis at gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Dec 17, 2015, at 12:33 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; If you remove that overload your code will fail to compile.  This is because the dot abbreviation is context sensitive.  It only works when the type system knows the type the expression is expected to produce.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Of course :) And if the overload stays and your suggested syntax were added, it would be ambiguous and also fail to compile.<br>&gt;&gt; <br>&gt;&gt; This is not true.  They would have different types and therefore would not be ambiguous.<br>&gt; <br>&gt; It&#39;s true in my example, but my example is an unlikely, type-ambiguous situation and is unlikely to occur in usage.<br></p><p>I finally managed to see the ambiguity in your example and now I feel foolish for not seeing it right away.  Thanks for sticking with it until I understood your example correctly.  :)  I think it’s because I just kept thinking of the usual signature of map and maybe also because I was thinking more in terms of grammatical ambiguity.<br></p><p>The overload in your example is possible but doesn’t really make any sense.  Nonetheless, it does show that a certain kind of ambiguity is possible.  <br></p><p>The good news is that this is a kind of ambiguity that already exists in the language today.  The compiler catches it and just requires you to resolve it manually when it arises.  The same would be true if we adopt the instance method shorthand.<br></p><p>struct Foo {<br>    static var ambiguous: Foo = Foo()<br>}<br></p><p>struct Bar {<br>    static var ambiguous: Bar = Bar()<br>}<br></p><p>func overloaded(foo: Foo) { }<br>func overloaded(bar: Bar) { }<br></p><p>overloaded(.ambiguous) // compile error<br></p><p>&gt; <br>&gt;&gt; But it’s not central to your position anyway since you are opposed on the grounds of potential for confusion rather than actual ambiguity.  :)  That is a fair and reasonable position with or without ambiguity.<br>&gt; <br>&gt; I&#39;m not opposed to the idea if it has broad applications and the type resolution is predictable. I think I&#39;m probably doing a bad job of predicting.<br></p><p>Glad to hear you’re not completely opposed.  I think it would have pretty broad applicability.  It wouldn’t do anything you couldn’t achieve with a closure: { $0.method() }, but it would improve clarity and readability by removing syntactic noise.  <br></p><p>I’m going to start a new thread to bring more people into the discussion about this.<br></p><p>Matthew<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/277c7144/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/caa7226ca750e974668243476ffbafd5?s=50"></div><header><strong>Spread Operator as Shorthand for Map</strong> from <string>Greg Titus</string> &lt;greg at omnigroup.com&gt;<p>December 16, 2015 at 08:00:00am</p></header><div class="content"><p>&gt; On Dec 16, 2015, at 8:18 AM, Stephen Celis via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Wed, Dec 16, 2015 at 10:50 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; If we peel off just the contextual shorthand aspect of this proposal you could write:<br>&gt; <br>&gt; cars.map(.make)<br>&gt; <br>&gt; That does seem like a big win if it is feasible (doesn’t introduce ambiguity or cause other significant challenges in implementation).<br>&gt; <br>&gt; The above creates ambiguity if there were a `map` function that takes a type with a static member `make`.<br>&gt; <br>&gt; Alternatively:<br>&gt; <br>&gt;     cars.map{.make}<br>&gt; <br>&gt; Both create an additional meaning for dot abbreviation, though, which is confusing. I think I&#39;m &quot;-1&quot; on this proposal as is. The existing form is clearer and relatively short as is.<br></p><p>This last alternative looks a lot like a special (single expression) case of the Method Cascading proposal &lt;https://bugs.swift.org/browse/SR-160&gt;. If you want to go forward with this shorthand, I’d suggest adding it to method cascading as a rule: Invoking a closure with a single anonymous argument also implicitly begins a cascade with $0 as the default receiver.<br></p><p>	- Greg<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/e86e213d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Spread Operator as Shorthand for Map</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 16, 2015 at 11:00:00am</p></header><div class="content"><p>&gt;&gt; <br>&gt;&gt;     cars.map{.make}<br>&gt; <br>&gt; This last alternative looks a lot like a special (single expression) case of the Method Cascading proposal &lt;https://bugs.swift.org/browse/SR-160 &lt;https://bugs.swift.org/browse/SR-160&gt;&gt;. If you want to go forward with this shorthand, I’d suggest adding it to method cascading as a rule: Invoking a closure with a single anonymous argument also implicitly begins a cascade with $0 as the default receiver.<br></p><p>Thanks for bringing this up!  It is not a special case of that specific proposal but it is a special case of a variation of the proposal that was discussed.  Seeing it applied in this context is really interesting.  <br></p><p>Joe Groff noted syntactic ambiguity caused by omitting $0.  Unless that potential ambiguity could be resolved in some way this wouldn’t actually work.  It does work if you include $0:<br></p><p>cars.map{$0.make}<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/ccbf2cc8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/abf891ba571d5a819ddf547917abe1e1?s=50"></div><header><strong>Spread Operator as Shorthand for Map</strong> from <string>Al Skipp</string> &lt;al_skipp at fastmail.fm&gt;<p>December 16, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt; On 16 Dec 2015, at 17:20, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Joe Groff noted syntactic ambiguity caused by omitting $0.  Unless that potential ambiguity could be resolved in some way this wouldn’t actually work.  It does work if you include $0:<br>&gt; <br>&gt; cars.map{$0.make}<br></p><p>Hey, we’re back where we started! ; )<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/b7067e20/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Spread Operator as Shorthand for Map</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>December 16, 2015 at 05:00:00pm</p></header><div class="content"><p>Worth noting this can be achieved in Ruby using a shorthand syntax that<br>turns a symbol into a method:<br></p><p>cars.map(&amp;:make)<br>On Wed, Dec 16, 2015 at 9:32 AM Al Skipp via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On 16 Dec 2015, at 17:20, Matthew Johnson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Joe Groff noted syntactic ambiguity caused by omitting $0.  Unless that<br>&gt; potential ambiguity could be resolved in some way this wouldn’t actually<br>&gt; work.  It does work if you include $0:<br>&gt;<br>&gt; cars.map{$0.make}<br>&gt;<br>&gt;<br>&gt; Hey, we’re back where we started! ; )<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/c0197982/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4de621aec7ff90a03f5b9b21e790bc66?s=50"></div><header><strong>Spread Operator as Shorthand for Map</strong> from <string>Dennis Lysenko</string> &lt;dennis.s.lysenko at gmail.com&gt;<p>December 16, 2015 at 04:00:00pm</p></header><div class="content"><p>Perhaps cars.map(Car.make)? We already have method references, why define a<br>new syntax?<br></p><p>On Wed, Dec 16, 2015, 11:18 AM Stephen Celis via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Wed, Dec 16, 2015 at 10:50 AM, Matthew Johnson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; If we peel off just the contextual shorthand aspect of this proposal you<br>&gt;&gt; could write:<br>&gt;&gt;<br>&gt;&gt; cars.map(.make)<br>&gt;&gt;<br>&gt;&gt; That does seem like a big win if it is feasible (doesn’t introduce<br>&gt;&gt; ambiguity or cause other significant challenges in implementation).<br>&gt;&gt;<br>&gt;<br>&gt; The above creates ambiguity if there were a `map` function that takes a<br>&gt; type with a static member `make`.<br>&gt;<br>&gt; Alternatively:<br>&gt;<br>&gt;     cars.map{.make}<br>&gt;<br>&gt; Both create an additional meaning for dot abbreviation, though, which is<br>&gt; confusing. I think I&#39;m &quot;-1&quot; on this proposal as is. The existing form is<br>&gt; clearer and relatively short as is.<br>&gt;<br>&gt; Stephen<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/ca252a48/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4de621aec7ff90a03f5b9b21e790bc66?s=50"></div><header><strong>Spread Operator as Shorthand for Map</strong> from <string>Dennis Lysenko</string> &lt;dennis.s.lysenko at gmail.com&gt;<p>December 16, 2015 at 04:00:00pm</p></header><div class="content"><p>Ignore the above. Thought make was a method for some reason. Still, it<br>would be possible if the parallel proposal for adding method references for<br>getters were approved.<br></p><p>On Wed, Dec 16, 2015, 11:51 AM Dennis Lysenko &lt;dennis.s.lysenko at gmail.com&gt;<br>wrote:<br></p><p>&gt; Perhaps cars.map(Car.make)? We already have method references, why define<br>&gt; a new syntax?<br>&gt;<br>&gt; On Wed, Dec 16, 2015, 11:18 AM Stephen Celis via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; On Wed, Dec 16, 2015 at 10:50 AM, Matthew Johnson via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; If we peel off just the contextual shorthand aspect of this proposal you<br>&gt;&gt;&gt; could write:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; cars.map(.make)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; That does seem like a big win if it is feasible (doesn’t introduce<br>&gt;&gt;&gt; ambiguity or cause other significant challenges in implementation).<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; The above creates ambiguity if there were a `map` function that takes a<br>&gt;&gt; type with a static member `make`.<br>&gt;&gt;<br>&gt;&gt; Alternatively:<br>&gt;&gt;<br>&gt;&gt;     cars.map{.make}<br>&gt;&gt;<br>&gt;&gt; Both create an additional meaning for dot abbreviation, though, which is<br>&gt;&gt; confusing. I think I&#39;m &quot;-1&quot; on this proposal as is. The existing form is<br>&gt;&gt; clearer and relatively short as is.<br>&gt;&gt;<br>&gt;&gt; Stephen<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/b078b51e/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/abf891ba571d5a819ddf547917abe1e1?s=50"></div><header><strong>Spread Operator as Shorthand for Map</strong> from <string>Al Skipp</string> &lt;al_skipp at fastmail.fm&gt;<p>December 16, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt; On 16 Dec 2015, at 16:51, Dennis Lysenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Perhaps cars.map(Car.make)? We already have method references, why define a new syntax? <br></p><p>That would actually refer to a static function on ‘Car’, not a method, or property on an instance of ‘Car’.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/07fdfb43/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>Spread Operator as Shorthand for Map</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>December 16, 2015 at 10:00:00am</p></header><div class="content"><p>I’m not a macro expert, but I suspect that once there’s a macro system this sort of thing would be pretty easy to construct - possibly with something like:<br></p><p>macro using(x) { $0.x }<br>cars.map using(make)<br></p><p>I’d like this sort of thing to be possible, too, but I’m not sure it needs to be explicitly added to the language if a macro system is (eventually) coming.<br></p><p>l8r<br>Sean<br></p><p><br>&gt; On Dec 16, 2015, at 9:50 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; I’d like to write the following, but ‘make’ is a member, not a free function:<br>&gt;&gt; cars.map(make)<br>&gt; <br>&gt; If we peel off just the contextual shorthand aspect of this proposal you could write:<br>&gt; <br>&gt; cars.map(.make)<br>&gt; <br>&gt; That does seem like a big win if it is feasible (doesn’t introduce ambiguity or cause other significant challenges in implementation).  <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Spread Operator as Shorthand for Map</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>December 28, 2015 at 06:00:00pm</p></header><div class="content"><p>+1 for being able to use cars.map(make)<br></p><p>&gt; Am 16.12.2015 um 16:23 schrieb Al Skipp via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt;&gt; On 16 Dec 2015, at 12:47, Sean Kosanovich via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; As a Groovy user, I really enjoy the shorthand Spread Operator over the Collect Closure (Map is the equivalent in Swift).<br>&gt;&gt; <br>&gt;&gt; Consider the following Swift code:<br>&gt;&gt; <br>&gt;&gt; struct Car {<br>&gt;&gt;     let make: String<br>&gt;&gt;     let model: String<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let cars = [Car(make: &quot;Jeep&quot;, model: &quot;Grand Cherokee&quot;), Car(make: &quot;Dodge&quot;, model: &quot;Challenger&quot;)]<br>&gt;&gt; let makes = cars.map() { $0.make }<br>&gt;&gt; <br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt; Now consider the same code using a Spread Operator:<br>&gt;&gt; <br>&gt;&gt; let makes = cars*.make<br>&gt; <br>&gt; I think there is a tension in Swift between its object oriented nature and higher-order functions which leads to a lot of repetition of { $0.property }<br>&gt; <br>&gt; In this example:<br>&gt; cars.map { $0.make }<br>&gt; <br>&gt; I’d like to write the following, but ‘make’ is a member, not a free function:<br>&gt; cars.map(make)<br>&gt; <br>&gt; Is anyone else irked by the preponderance of { $0.property } in Swift (or is it just me being grumpy)? Not sure what the solution would be, but I can’t say I’m keen on the suggestion of:<br>&gt; <br>&gt; cars*.make<br>&gt; <br>&gt; It’s too mysterious.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151228/f41ae574/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e5b8fa5e4f9e527ea335031bf2ec9a03?s=50"></div><header><strong>Spread Operator as Shorthand for Map</strong> from <string>Árpád Goretity</string> &lt;arpad.goretity at gmail.com&gt;<p>December 28, 2015 at 06:00:00pm</p></header><div class="content"><p>Seems sensible; here&#39;s my $0.02:<br></p><p>I don&#39;t know whether that kind of thing has been proposed, but it would be interesting to explore two different language features and their interaction with first-class getters and setters. This way, I believe, we could avoid introducing non-orthogonality and special cases into the language.<br></p><p>The first feature is uniform function call syntax:<br> - for structs and final classes (where there&#39;s no inheritance), if a function is declared with the struct type as its first parameter, e.g. some_property(self: MyStruct) {…}, it could be called as if it was a method on the struct (cf. Go&#39;s behavior). With this behavior would be consistent the ability to simply map getters and setters over a collection of structs (or otherwise treat technically free functions as methods if the types match).<br> - for non-final classes, inheritance kicks in. In this case, I think it&#39;s a little too magical (albeit certainly not hard to implement) to have one function name map to several functions (i.e. have inheritance semantics), especially without visual indication of the object being manipulated. There&#39;s a source of mental tension here, though: specifically, this behavior would however be consistent with the notion of overridden functions at the same time.<br></p><p>The second feature is macros - I know that they have been discussed and postponed for now, but theoretically they&#39;d be capable of solving the kinds of syntactic repetition that can&#39;t otherwise be refactored into functions. The standard library could then contain macros which would expand to appropriate getters and setters - pseudocode follows:<br></p><p>    macro get(name: Identifier) {<br>        return { $0.`name` }<br>    }<br></p><p>    macro set(name: Identifier) {<br>        return { $0.`name` = $1 }<br>    }<br></p><p>What do you think about this?<br></p><p>Sent from my iPhone<br></p><p>&gt; On 28 Dec 2015, at 18:10, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; +1 for being able to use cars.map(make)<br>&gt; <br>&gt;&gt; Am 16.12.2015 um 16:23 schrieb Al Skipp via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; On 16 Dec 2015, at 12:47, Sean Kosanovich via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As a Groovy user, I really enjoy the shorthand Spread Operator over the Collect Closure (Map is the equivalent in Swift).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Consider the following Swift code:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Car {<br>&gt;&gt;&gt;     let make: String<br>&gt;&gt;&gt;     let model: String<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let cars = [Car(make: &quot;Jeep&quot;, model: &quot;Grand Cherokee&quot;), Car(make: &quot;Dodge&quot;, model: &quot;Challenger&quot;)]<br>&gt;&gt;&gt; let makes = cars.map() { $0.make }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Now consider the same code using a Spread Operator:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let makes = cars*.make<br>&gt;&gt; <br>&gt;&gt; I think there is a tension in Swift between its object oriented nature and higher-order functions which leads to a lot of repetition of { $0.property }<br>&gt;&gt; <br>&gt;&gt; In this example:<br>&gt;&gt; cars.map { $0.make }<br>&gt;&gt; <br>&gt;&gt; I’d like to write the following, but ‘make’ is a member, not a free function:<br>&gt;&gt; cars.map(make)<br>&gt;&gt; <br>&gt;&gt; Is anyone else irked by the preponderance of { $0.property } in Swift (or is it just me being grumpy)? Not sure what the solution would be, but I can’t say I’m keen on the suggestion of:<br>&gt;&gt; <br>&gt;&gt; cars*.make<br>&gt;&gt; <br>&gt;&gt; It’s too mysterious.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151228/d67c236c/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Spread Operator as Shorthand for Map</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 28, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; On Dec 28, 2015, at 11:10 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; +1 for being able to use cars.map(make)<br></p><p>Check out the thread &quot;[Proposal Idea] dot shorthand for instance members” which discusses an idea that gets as close to that as possible.  <br></p><p>Something like this is also mentioned in the &quot;Alternatives considered” section of Joe Groff’s “Removing currying func declaration syntax” proposal: https://github.com/apple/swift-evolution/blob/master/proposals/0002-remove-currying.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0002-remove-currying.md&gt;<br></p><p><br>&gt; <br>&gt; Am 16.12.2015 um 16:23 schrieb Al Skipp via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; <br>&gt;&gt;&gt; On 16 Dec 2015, at 12:47, Sean Kosanovich via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As a Groovy user, I really enjoy the shorthand Spread Operator over the Collect Closure (Map is the equivalent in Swift).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Consider the following Swift code:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Car {<br>&gt;&gt;&gt;     let make: String<br>&gt;&gt;&gt;     let model: String<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let cars = [Car(make: &quot;Jeep&quot;, model: &quot;Grand Cherokee&quot;), Car(make: &quot;Dodge&quot;, model: &quot;Challenger&quot;)]<br>&gt;&gt;&gt; let makes = cars.map() { $0.make }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Now consider the same code using a Spread Operator:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let makes = cars*.make<br>&gt;&gt; <br>&gt;&gt; I think there is a tension in Swift between its object oriented nature and higher-order functions which leads to a lot of repetition of { $0.property }<br>&gt;&gt; <br>&gt;&gt; In this example:<br>&gt;&gt; cars.map { $0.make }<br>&gt;&gt; <br>&gt;&gt; I’d like to write the following, but ‘make’ is a member, not a free function:<br>&gt;&gt; cars.map(make)<br>&gt;&gt; <br>&gt;&gt; Is anyone else irked by the preponderance of { $0.property } in Swift (or is it just me being grumpy)? Not sure what the solution would be, but I can’t say I’m keen on the suggestion of:<br>&gt;&gt; <br>&gt;&gt; cars*.make<br>&gt;&gt; <br>&gt;&gt; It’s too mysterious.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151228/68c210dc/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
