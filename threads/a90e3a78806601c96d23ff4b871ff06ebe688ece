<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[SHORT Review] SE-0132: Rationalizing Sequence end-operation names</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>July 24, 2016 at 11:00:00pm</p></header><div class="content"><p>Hello Swift community,<br></p><p>The review of &quot;SE-0132: Rationalizing Sequence end-operation names&quot; begins now and runs through July 26.  Apologies for the short review cycle, but we’re right up against the end of source breaking changes for Swift 3.  The proposal is available here:<br></p><p>	https://github.com/apple/swift-evolution/blob/master/proposals/0132-sequence-end-ops.md<br></p><p>Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br></p><p>	https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>or, if you would like to keep your feedback private, directly to the review manager.<br></p><p>What goes into a review?<br></p><p>The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br></p><p>	* What is your evaluation of the proposal?<br>	* Is the problem being addressed significant enough to warrant a change to Swift?<br>	* Does this proposal fit well with the feel and direction of Swift?<br>	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>More information about the Swift evolution process is available at<br></p><p>	https://github.com/apple/swift-evolution/blob/master/process.md<br></p><p>Thank you,<br></p><p>-Chris Lattner<br>Review Manager<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[SHORT Review] SE-0132: Rationalizing Sequence end-operation names</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 25, 2016 at 01:00:00am</p></header><div class="content"><p>On Mon, Jul 25, 2016 at 1:10 AM, Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hello Swift community,<br>&gt;<br>&gt; The review of &quot;SE-0132: Rationalizing Sequence end-operation names&quot; begins<br>&gt; now and runs through July 26.  Apologies for the short review cycle, but<br>&gt; we’re right up against the end of source breaking changes for Swift 3.  The<br>&gt; proposal is available here:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0132-sequence-end-ops.md<br>&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt; should be sent to the swift-evolution mailing list at<br>&gt;<br>&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the<br>&gt; review manager.<br>&gt;<br>&gt; What goes into a review?<br>&gt;<br>&gt; The goal of the review process is to improve the proposal under review<br>&gt; through constructive criticism and contribute to the direction of Swift.<br>&gt; When writing your review, here are some questions you might want to answer<br>&gt; in your review:<br>&gt;<br>&gt;         * What is your evaluation of the proposal?<br>&gt;<br></p><p>The end product is really quite beautiful. This proposal very much succeeds<br>at rationalizing all names without introducing terminology that&#39;s<br>unprecedented. I very much appreciate that properties or functions named<br>`first` now always return one or zero elements and that ranges are always<br>indicated with range operators. The only quibble is that `hasPrefix(_:by:)`<br>might be more appropriately `hasPrefix(_:comparingBy:)`, as the standalone<br>preposition doesn&#39;t quite make sense IMO.<br></p><p><br>&gt;         * Is the problem being addressed significant enough to warrant a<br>&gt; change to Swift?<br>&gt;<br></p><p>Yes.<br></p><p><br>&gt;         * Does this proposal fit well with the feel and direction of Swift?<br>&gt;<br></p><p>Yes, very much so.<br></p><p><br>&gt;         * If you have used other languages or libraries with a similar<br>&gt; feature, how do you feel that this proposal compares to those?<br>&gt;<br></p><p>This proposal rationalizes Swift-specific names, so not sure how to compare<br>to other languages.<br></p><p><br>&gt;         * How much effort did you put into your review? A glance, a quick<br>&gt; reading, or an in-depth study?<br>&gt;<br></p><p>A quick reading of this version; I followed the original discussion and<br>thought about it more in-depth then.<br></p><p><br>&gt; More information about the Swift evolution process is available at<br>&gt;<br>&gt;         https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;<br>&gt; Thank you,<br>&gt;<br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160725/aaaa62e2/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[SHORT Review] SE-0132: Rationalizing Sequence end-operation names</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>July 25, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jul 25, 2016, at 8:10 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;SE-0132: Rationalizing Sequence end-operation names&quot; begins now and runs through July 26.  Apologies for the short review cycle, but we’re right up against the end of source breaking changes for Swift 3.  The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0132-sequence-end-ops.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br></p><p>The updated API is more consistent and seems the right step to take.<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes.<br></p><p>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>Read the proposal and skimmed through the discussion.<br></p><p>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/242e18b243022bcb7573443e06444423?s=50"></div><header><strong>[SHORT Review] SE-0132: Rationalizing Sequence end-operation names</strong> from <string>Boris Wang</string> &lt;kona.ming at gmail.com&gt;<p>July 25, 2016 at 08:00:00am</p></header><div class="content"><p>My suggest:<br></p><p>* Change removing to exclude. For exam, S.excludeFirst<br>* Keep shorthand for first and last element<br>* Change pop to removeXXXCheck. For exam, C.popFirst =&gt;C.removeFirstCheck<br></p><p>Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt;于2016年7月25日<br>周一15:45写道：<br></p><p>&gt;<br>&gt; &gt; On Jul 25, 2016, at 8:10 AM, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Hello Swift community,<br>&gt; &gt;<br>&gt; &gt; The review of &quot;SE-0132: Rationalizing Sequence end-operation names&quot;<br>&gt; begins now and runs through July 26.  Apologies for the short review cycle,<br>&gt; but we’re right up against the end of source breaking changes for Swift 3.<br>&gt; The proposal is available here:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0132-sequence-end-ops.md<br>&gt; &gt;<br>&gt; &gt; Reviews are an important part of the Swift evolution process. All<br>&gt; reviews should be sent to the swift-evolution mailing list at<br>&gt; &gt;<br>&gt; &gt;       https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt; or, if you would like to keep your feedback private, directly to the<br>&gt; review manager.<br>&gt; &gt;<br>&gt; &gt; What goes into a review?<br>&gt; &gt;<br>&gt; &gt; The goal of the review process is to improve the proposal under review<br>&gt; through constructive criticism and contribute to the direction of Swift.<br>&gt; When writing your review, here are some questions you might want to answer<br>&gt; in your review:<br>&gt; &gt;<br>&gt; &gt;       * What is your evaluation of the proposal?<br>&gt;<br>&gt; The updated API is more consistent and seems the right step to take.<br>&gt;<br>&gt; &gt;       * Is the problem being addressed significant enough to warrant a<br>&gt; change to Swift?<br>&gt;<br>&gt; Yes.<br>&gt;<br>&gt; &gt;       * Does this proposal fit well with the feel and direction of Swift?<br>&gt;<br>&gt; Yes.<br>&gt;<br>&gt; &gt;       * If you have used other languages or libraries with a similar<br>&gt; feature, how do you feel that this proposal compares to those?<br>&gt; &gt;       * How much effort did you put into your review? A glance, a quick<br>&gt; reading, or an in-depth study?<br>&gt;<br>&gt; Read the proposal and skimmed through the discussion.<br>&gt;<br>&gt; &gt;<br>&gt; &gt; More information about the Swift evolution process is available at<br>&gt; &gt;<br>&gt; &gt;       https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; &gt;<br>&gt; &gt; Thank you,<br>&gt; &gt;<br>&gt; &gt; -Chris Lattner<br>&gt; &gt; Review Manager<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160725/81ab2a3b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/242e18b243022bcb7573443e06444423?s=50"></div><header><strong>[SHORT Review] SE-0132: Rationalizing Sequence end-operation names</strong> from <string>Boris Wang</string> &lt;kona.ming at gmail.com&gt;<p>July 25, 2016 at 08:00:00am</p></header><div class="content"><p>And try to use overloading more:<br></p><p>exclude(index: Int)<br>exclude(part: Range)<br>exclude({closure})<br></p><p>Boris Wang &lt;kona.ming at gmail.com&gt;于2016年7月25日 周一16:09写道：<br></p><p>&gt; My suggest:<br>&gt;<br>&gt; * Change removing to exclude. For exam, S.excludeFirst<br>&gt; * Keep shorthand for first and last element<br>&gt; * Change pop to removeXXXCheck. For exam, C.popFirst =&gt;C.removeFirstCheck<br>&gt;<br>&gt; Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt;于2016年7月25日<br>&gt; 周一15:45写道：<br>&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; On Jul 25, 2016, at 8:10 AM, Chris Lattner via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Hello Swift community,<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The review of &quot;SE-0132: Rationalizing Sequence end-operation names&quot;<br>&gt;&gt; begins now and runs through July 26.  Apologies for the short review cycle,<br>&gt;&gt; but we’re right up against the end of source breaking changes for Swift 3.<br>&gt;&gt; The proposal is available here:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0132-sequence-end-ops.md<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Reviews are an important part of the Swift evolution process. All<br>&gt;&gt; reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;       https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; or, if you would like to keep your feedback private, directly to the<br>&gt;&gt; review manager.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; What goes into a review?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The goal of the review process is to improve the proposal under review<br>&gt;&gt; through constructive criticism and contribute to the direction of Swift.<br>&gt;&gt; When writing your review, here are some questions you might want to answer<br>&gt;&gt; in your review:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;       * What is your evaluation of the proposal?<br>&gt;&gt;<br>&gt;&gt; The updated API is more consistent and seems the right step to take.<br>&gt;&gt;<br>&gt;&gt; &gt;       * Is the problem being addressed significant enough to warrant a<br>&gt;&gt; change to Swift?<br>&gt;&gt;<br>&gt;&gt; Yes.<br>&gt;&gt;<br>&gt;&gt; &gt;       * Does this proposal fit well with the feel and direction of<br>&gt;&gt; Swift?<br>&gt;&gt;<br>&gt;&gt; Yes.<br>&gt;&gt;<br>&gt;&gt; &gt;       * If you have used other languages or libraries with a similar<br>&gt;&gt; feature, how do you feel that this proposal compares to those?<br>&gt;&gt; &gt;       * How much effort did you put into your review? A glance, a quick<br>&gt;&gt; reading, or an in-depth study?<br>&gt;&gt;<br>&gt;&gt; Read the proposal and skimmed through the discussion.<br>&gt;&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; More information about the Swift evolution process is available at<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;       https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Thank you,<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; -Chris Lattner<br>&gt;&gt; &gt; Review Manager<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160725/a9532e9d/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>[SHORT Review] SE-0132: Rationalizing Sequence end-operation names</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>July 25, 2016 at 01:00:00am</p></header><div class="content"><p>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0132-sequence-end-ops.md<br>&gt;<br>&gt;         * What is your evaluation of the proposal?<br>&gt;<br></p><p>+1 on drop{First,Last}() → removing{First,Last}().<br>+1 on drop{First,Last}(_:) → removing{Prefix,Suffix}(_:).<br>+1 on drop(while:) → removingPrefix(while:).<br>+1 on starts(with:[by:]) → hasPrefix(_:[by:]).<br>+1 on index({of:,where:}) → firstIndex({of:,where:}).<br>+1 on prefix and postfix versions of ..&lt; and the prefix version of the ...<br>operator. For a while I thought I might prefer labeled subscripts, but<br>after writing them out I agree the operators are better.<br></p><p>The rest is a stream of consciousness:.<br></p><p>I don&#39;t think postfix ... is necessary. When does one ever combine a<br>ClosedRange with endIndex?<br></p><p>I don&#39;t agree that &quot;drop&quot; sounds particularly scary, but I&#39;m fine with<br>&quot;removing&quot; as an alternative to &quot;drop&quot;/&quot;dropping&quot;. Scatologists will be<br>disappointed, I&#39;m sure.<br></p><p>I&#39;d forgotten about prefix(while:), which apparently isn&#39;t implemented yet.<br>I think I&#39;d prefer if this were named prefix(where:) instead.<br></p><p>I&#39;m struggling a little with the distinction between length-based and<br>index-based methods/subscripts. Are &quot;prefix(_ length: Int)&quot; and<br>&quot;prefix(upTo end: Index)&quot; really different enough that one of them should<br>be a subscript and the other a method? The same question applies to<br>prefix(through:) and suffix(from:). I kinda wish these could all be methods<br>or all subscripts.<br></p><p>I have to say I don&#39;t fully understand the need for (or benefits of)<br>RangeExpression and the relative(to:) API (perhaps because I don&#39;t have<br>much experience using the most recent collection/index/range APIs). Since<br>the conforming type&#39;s Bound is already required to be the collection&#39;s<br>Index, it seems pointless to have an API to access this as a Range...there<br>should just be Collection subscript methods which accept the conforming<br>types. I suppose it&#39;s nice to get all these for free by implementing just<br>one subscript function (excepting the current lack of generic<br>subscripts)...but is it even possible to express every RangeExpression as a<br>Range? What about a ClosedRange&lt;Int&gt; whose upperBound is Int.max? (Wasn&#39;t<br>that the whole point of introducing ClosedRange in the first place?)<br></p><p>Random question: why do we have both removeFirst and popFirst?  ...on<br>further reading I see you covered this in Future Directions. I&#39;d be happy<br>to discuss merging these. I wonder if it&#39;s important to do for Swift 3<br>(although we&#39;re basically out of time)?<br></p><p>The name IncompleteRange makes sense, but could be a little misleading if<br>..&lt;(Bound?,Bound?) is called with two non-nil operands: based on my<br>reading, it sounds like the returned IncompleteRange wouldn&#39;t actually<br>change when you call completed(by:) (since it&#39;s not actually incomplete).<br>However, I can&#39;t come up with any better naming suggestions.<br></p><p><br>&gt;         * Is the problem being addressed significant enough to warrant a<br>&gt; change to Swift?<br>&gt;<br></p><p>Yes.<br></p><p><br>&gt;         * Does this proposal fit well with the feel and direction of Swift?<br>&gt;<br></p><p>Mostly. Not sure there&#39;s enough consistency between<br>subsequence-length-based and index-based APIs, namely that prefix(upTo:)<br>becomes a subscript but prefix(_:) doesn&#39;t.<br></p><p>        * If you have used other languages or libraries with a similar<br>&gt; feature, how do you feel that this proposal compares to those?<br>&gt;<br></p><p>I&#39;ve used Python and Mathematica, which both have functionality similar to<br>&quot;incomplete range subscripts&quot;:<br></p><p>    Python: http://stackoverflow.com/a/509295/23649<br>    Mathematica: https://reference.wolfram.com/language/ref/Span.html<br></p><p>Based on my experience there, this is a good first (second?) step for Swift<br>to take.<br></p><p>Both Mathematica and Python support a *stride* as well as start/end indices<br>in their subscripting syntax. It would be nice for Swift to support<br>something like this, but some versions of that would require custom ternary<br>operators (or weird intermediate types to fake a custom ternary operator).<br>We might also consider labelled multi-argument subscripts like<br>&quot;collection[start..&lt;end, by: 2]&quot;.<br></p><p>They also both support *negative indices *which count from the end. Swift&#39;s<br>suffix-based APIs are limited; I&#39;d like to see an in-depth consideration of<br>this down the line. Now is probably not the time, unless anyone can think<br>of reasons it would affect the syntax/naming we choose in this proposal.<br></p><p>(It&#39;s also interesting to note that Mathematica&#39;s subscripts (Part<br>&lt;https://reference.wolfram.com/language/ref/Part.html&gt;) support<br>multi-dimensional arrays:  matrix[[3;;4, -5;;]] would be the submatrix<br>containing the last 5 entries in rows 3 and 4 of the original matrix.)<br></p><p><br>&gt;         * How much effort did you put into your review? A glance, a quick<br>&gt; reading, or an in-depth study?<br>&gt;<br></p><p>A mostly-thorough reading of the proposal.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160725/40944dbe/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[SHORT Review] SE-0132: Rationalizing Sequence end-operation names</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July 25, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br></p><p>I was not totally happy with early drafts of this proposal.  The final draft is a significant improvement.  I am mostly +1, with a couple of minor critiques.  <br></p><p>I think this proposal pushes a bit too hard on consistency of “first / last” vs “prefix / suffix”.  Specifically, I think first(n) and last(n) are significantly more clear than prefix(n) and suffix(n) (and removingFirst(n) / removingLast(n) instead of removingPrefix(n) / removingSuffix(n).  I think the former are immediately clear.  The latter, while consistent in terms of matching semantics with a naming convention suffer in terms of clarity at the call site.  I do not think it is immediately clear that the parameter specifies the *length* of the prefix or suffix.  removingPrefix(ofLength: n) would solve the clarity issue at the expense of verbosity.  I would prefer we just keep first / last in these cases.<br></p><p>Another comment is that you have generally moved index based methods to subscripts rather than named methods.  Why didn’t you take this all the way and change `replaceSubrange` to be a subscript setter?<br></p><p><br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes, the new names have more consistency.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes.<br></p><p>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>I don’t believed I have used any languages that emphasize consistent naming and API guidelines as strongly as Swift.  This is a good direction.<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>A relatively quick read.<br></p><p>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a5a2cebcb5559ab317c1ce5a5ed9a064?s=50"></div><header><strong>[SHORT Review] SE-0132: Rationalizing Sequence end-operation names</strong> from <string>Garth Snyder</string> &lt;garth at garthsnyder.com&gt;<p>July 25, 2016 at 02:00:00pm</p></header><div class="content"><p>A warm -0.5 from me, meaning that I agree that this issue is important to address, and that I concur with many of the particulars. (I agree that removing is way better than drop, for example.)<br></p><p>However, I suspect that this approach may open more Pandora’s boxes than it closes. Most of my discomfort centers on the idea of incomplete ranges. This seems like a major thing to introduce to the language, and although I like the concept, it raises questions that deserve to be addressed independently. Incomplete ranges shouldn’t be allowed to just sneak in the back door as part of an API cleanup in one particular area.<br></p><p>Really, it seems like ranges could do with some attention in their own right. In their current form, they feel like largely pragmatic constructions that aren&#39;t yet fully baked. A lot of elaborations have already been piled onto them, and they’re responsible for a lot of API-level complexity. But as yet, they’re not capable of representing, e.g., intervals that are open or half-open on the left. <br></p><p>Incomplete ranges seem to push the idea of ranges even further in the direction of abstract predicates or mathematically general models of intervals. For example, SE-0132 suggests<br></p><p>    ..&lt; 3<br></p><p>as a syntax for an upper-bounded range. But wouldn’t <br></p><p>   &lt; 3<br></p><p>be a more natural syntax for this? From a logical perspective, you’re not really creating a range so much as expressing the condition that something is less than 3, which happens to be encoded by a range. If we had incomplete ranges, wouldn’t you want to be able to use them naturally in, e.g., case statements?<br></p><p>    switch (value) {<br>        case &lt; 3: <br>            // Small value<br>        case 3…5:<br>            // Medium value<br>        case &gt; 5:<br>            // Large value<br>    }<br></p><p>Doesn’t it seem odd that &lt; 3 is representable as a range but &gt; 5 is not? <br></p><p>(I’ve shown all these with reasonable spacing, but IIRC, the odd no-space-around-range-operators rule is still in effect. That would be worth addressing, too, if ranges are really going to be first-class citizens.)<br></p><p>&gt; Matthew Johnson: I think this proposal pushes a bit too hard on consistency of “first / last” vs “prefix / suffix”.  Specifically, I think first(n) and last(n) are significantly more clear than prefix(n) and suffix(n) (and removingFirst(n) / removingLast(n) instead of removingPrefix(n) / removingSuffix(n).  I think the former are immediately clear.  The latter, while consistent in terms of matching semantics with a naming convention suffer in terms of clarity at the call site.  I do not think it is immediately clear that the parameter specifies the *length* of the prefix or suffix.<br></p><p><br>Agreed. According to the API standards, a method removePrefix() seem like it should accept a prefix as an argument.<br></p><p>&gt; Matthew Johnson: Another comment is that you have generally moved index based methods to subscripts rather than named methods.  Why didn’t you take this all the way and change `replaceSubrange` to be a subscript setter?<br></p><p>That’s a good point also.<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>A complete reading of the proposal, but without existing knowledge of the subtleties of Range implementation.<br></p><p>Garth<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d9dbc0dfeb74eab8dd9bbd9cbd84680?s=50"></div><header><strong>[SHORT Review] SE-0132: Rationalizing Sequence end-operation names</strong> from <string>Jose Cheyo Jimenez</string> &lt;cheyo at masters3d.com&gt;<p>July 25, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Jul 24, 2016, at 11:10 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;SE-0132: Rationalizing Sequence end-operation names&quot; begins now and runs through July 26.  Apologies for the short review cycle, but we’re right up against the end of source breaking changes for Swift 3.  The proposal is available here:<br>&gt; <br>&gt;    https://github.com/apple/swift-evolution/blob/master/proposals/0132-sequence-end-ops.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt;    https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt;    * What is your evaluation of the proposal?<br></p><p>+1 <br></p><p>In the future section :<br></p><p>I strongly dislike every(where:) but I would not be opposed to select(where:) but I think filter, map, reduce etc are way better names. <br></p><p><br>&gt;    * Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes. There was too much inconsistency.  <br></p><p><br>&gt;    * Does this proposal fit well with the feel and direction of Swift?<br>Yes<br>&gt;    * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;    * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>Quick study. <br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt;    https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d9dbc0dfeb74eab8dd9bbd9cbd84680?s=50"></div><header><strong>[SHORT Review] SE-0132: Rationalizing Sequence end-operation names</strong> from <string>Jose Cheyo Jimenez</string> &lt;cheyo at masters3d.com&gt;<p>July 26, 2016 at 09:00:00pm</p></header><div class="content"><p>On Jul 25, 2016, at 8:17 AM, Jose Cheyo Jimenez &lt;cheyo at masters3d.com&gt; wrote:<br></p><p>&gt;&gt; On Jul 24, 2016, at 11:10 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello Swift community,<br>&gt;&gt; <br>&gt;&gt; The review of &quot;SE-0132: Rationalizing Sequence end-operation names&quot; begins now and runs through July 26.  Apologies for the short review cycle, but we’re right up against the end of source breaking changes for Swift 3.  The proposal is available here:<br>&gt;&gt; <br>&gt;&gt;   https://github.com/apple/swift-evolution/blob/master/proposals/0132-sequence-end-ops.md<br>&gt;&gt; <br>&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt; <br>&gt;&gt;   https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt;&gt; <br>&gt;&gt; What goes into a review?<br>&gt;&gt; <br>&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt; <br>&gt;&gt;   * What is your evaluation of the proposal?<br>&gt; <br>&gt; +1 <br>&gt; <br>I got to add that while I do like the renaming section of the proposal I do have reservations about RangeExpression and IncompleteRange. <br></p><p>I think these additions will make index based operations harder to discover by autocomplete. Unnecessary feels like ranges would get much complicated and I feel that is a regression from the simplification treatment that they just received. They don&#39;t feel swifty to me. :)<br></p><p>-1 for IncompleteRange <br>-1 collection[to/through/from]  // don&#39;t like this much. <br>-1 for RangeExpression<br></p><p>Perhaps something similar could be introduced later but I think the proposal just stick to just renaming like it claims in the scope section. <br></p><p>&gt; In the future section :<br>&gt; <br>&gt; I strongly dislike every(where:) but I would not be opposed to select(where:) but I think filter, map, reduce etc are way better names. <br>&gt; <br>&gt; <br>&gt;&gt;   * Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; <br>&gt; Yes. There was too much inconsistency.  <br>&gt; <br>&gt; <br>&gt;&gt;   * Does this proposal fit well with the feel and direction of Swift?<br>&gt; Yes<br>&gt;&gt;   * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt;   * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; Quick study. <br>&gt;&gt; <br>&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt; <br>&gt;&gt;   https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt; <br>&gt;&gt; Thank you,<br>&gt;&gt; <br>&gt;&gt; -Chris Lattner<br>&gt;&gt; Review Manager<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5f463dd4e7af28b64ad8f0e032ee82dc?s=50"></div><header><strong>[SHORT Review] SE-0132: Rationalizing Sequence end-operation names</strong> from <string>Nate Cook</string> &lt;natecook at gmail.com&gt;<p>July 25, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0132-sequence-end-ops.md<br></p><p>First, a big thanks to Brent for all the work in categorizing, describing, and justifying all these changes! I&#39;m largely in favor of the new method names—several of the renamings lead to better grouping of related methods, and I think the compromises that have been made make lots of sense.<br></p><p>However, I&#39;m not in favor of replacing the existing slicing methods with new subscript syntax that uses partial ranges. These represent a significant new vernacular for Swift that none of us has used before in the language. I&#39;m additionally worried about the discoverability and clarity of this kind of slicing. In the other languages I&#39;ve used that support similar kinds of subscripting, it always seems too clever by half—fussy to write and frequently confusing to read.<br></p><p>At this late date, I propose keeping the slicing methods (i.e., prefix(upTo:), prefix(through:), and suffix(from:)) and considering adopting the new slicing-via-subscript syntax in a future proposal.<br></p><p>Best,<br>Nate<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[SHORT Review] SE-0132: Rationalizing Sequence end-operation names</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July 25, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jul 25, 2016, at 3:22 PM, Nate Cook via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0132-sequence-end-ops.md<br>&gt; <br>&gt; First, a big thanks to Brent for all the work in categorizing, describing, and justifying all these changes! I&#39;m largely in favor of the new method names—several of the renamings lead to better grouping of related methods, and I think the compromises that have been made make lots of sense.<br>&gt; <br>&gt; However, I&#39;m not in favor of replacing the existing slicing methods with new subscript syntax that uses partial ranges. These represent a significant new vernacular for Swift that none of us has used before in the language. I&#39;m additionally worried about the discoverability and clarity of this kind of slicing. In the other languages I&#39;ve used that support similar kinds of subscripting, it always seems too clever by half—fussy to write and frequently confusing to read.<br>&gt; <br>&gt; At this late date, I propose keeping the slicing methods (i.e., prefix(upTo:), prefix(through:), and suffix(from:)) and considering adopting the new slicing-via-subscript syntax in a future proposal.<br></p><p>This seems like a reasonable alternative.  The slicing / subscript syntax can reasonably be viewed as sugar for the named methods.<br></p><p>&gt; <br>&gt; Best,<br>&gt; Nate<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[SHORT Review] SE-0132: Rationalizing Sequence end-operation names</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>July 25, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On 25 Jul 2016, at 09:10, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;SE-0132: Rationalizing Sequence end-operation names&quot; begins now and runs through July 26.  Apologies for the short review cycle, but we’re right up against the end of source breaking changes for Swift 3.  The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0132-sequence-end-ops.md<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br></p><p>+1 to the method renames.<br>-1 to the slice syntax proposed.<br></p><p>I find the introduction of unary operators confusing. I don&#39;t think it&#39;s good design that you need to remove a space when moving from the old syntax to the new one:<br></p><p>    array[array.startIndex ..&lt; someIndex] // before<br>    array[..&lt;someIndex]                   // after<br></p><p>and likewise, that you need to add parentheses here:<br></p><p>    array[array.startIndex ..&lt; someIndex - 1] // before<br>    array[..&lt;(someIndex - 1)]                 // after<br></p><p>OTOH, I would be okay if the proposal didn&#39;t implement unary operators but only the Optional&lt;Index&gt; overloads of `...` and `..&lt;`:<br></p><p>    array[nil ..&lt; someIndex]     // first example<br>    array[nil ..&lt; someIndex - 1] // second example<br></p><p>That said, maybe it&#39;s best to defer that part of the proposal until a later time and stick to prefix(upTo:), prefix(through:), and suffix(from:) for now.<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes.<br></p><p>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>N/A<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p><br>Quick reading.<br></p><p>Thanks to Brent for the effort!<br></p><p>— Pyry<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160725/8321a007/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[SHORT Review] SE-0132: Rationalizing Sequence end-operation names</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>July 26, 2016 at 02:00:00am</p></header><div class="content"><p>&gt; On Jul 25, 2016, at 1:46 PM, Pyry Jahkola via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I find the introduction of unary operators confusing. I don&#39;t think it&#39;s good design that you need to remove a space when moving from the old syntax to the new one:<br>&gt; <br>&gt;     array[array.startIndex ..&lt; someIndex] // before<br>&gt;     array[..&lt;someIndex]                   // after<br>&gt; <br>&gt; and likewise, that you need to add parentheses here:<br>&gt; <br>&gt;     array[array.startIndex ..&lt; someIndex - 1] // before<br>&gt;     array[..&lt;(someIndex - 1)]                 // after<br>&gt; <br>&gt; OTOH, I would be okay if the proposal didn&#39;t implement unary operators but only the Optional&lt;Index&gt; overloads of `...` and `..&lt;`:<br>&gt; <br>&gt;     array[nil ..&lt; someIndex]     // first example<br>&gt;     array[nil ..&lt; someIndex - 1] // second example<br></p><p>The proposal includes both infix and prefix/postfix forms because the tradeoff between the two is rather complex.<br></p><p>The advantages of infix are:<br></p><p>* Closer to the non-incomplete Range syntax<br>* Permits spacing for readability<br>* Allows for `Index?` bounds, so you can choose at runtime whether or not to provide a particular bound<br>* Doesn&#39;t take leading or trailing `...`, which we may want for other purposes<br>* Doesn&#39;t require new operators to be declared<br></p><p>The advantages of prefix and postfix are:<br></p><p>* Don&#39;t add overloads (and thus type checker complexity) on existing ranges<br>* Don&#39;t use `nil` for &quot;choose the end&quot;, which might be a little opaque <br>* Won&#39;t become potentially ambiguous if Optional becomes Comparable later<br></p><p>I think both syntaxes have a role to play, with the prefix and postfix syntaxes being useful for simple situations while infix can help with more complex ones. But I also think that it&#39;s a complex enough question that it&#39;s better to present both to the reviewers and core team so that more people can weigh in. I anticipated that one set might not survive review, and the design would be fine with only prefix/postfix, only infix, or both.<br></p><p>&gt; That said, maybe it&#39;s best to defer that part of the proposal until a later time and stick to prefix(upTo:), prefix(through:), and suffix(from:) for now.<br></p><p>This is also an option. I hoped to make it in before Swift 3 so we could avoid a deprecation cycle, but the two parts *are* essentially severable.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[SHORT Review] SE-0132: Rationalizing Sequence end-operation names</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>July 25, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; 	* What is your evaluation of the proposal?<br></p><p>+1 for most of the proposal<br>-1 for the slicing subscripts<br></p><p>This proposal is well researched, and well written and makes total sense. I totally agree that a renaming is required and I agree with most of the proposal for the exception of the slicing subscripts. If the goal of the proposal was to make those APIs easily discoverable, then those subscripts go completely against that:<br></p><p>You need to know that the subscripts exist and if you are looking for a method, you will never find them.<br>They use a new type which is never used anywhere else.<br></p><p>On a more general note, creating new types in the Standard Library only to serve as arguments for those fairly rarely used subscripts sounds very heavy-weight.<br></p><p>I vote for keeping functions for those operations.<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes, except for the subscripts, which look fairly alien to me.<br></p><p>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>No.<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>Followed the original pitch, gave some feedback, re-read the proposal for the official review and spent a day pondering it.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160725/b9e37c14/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/242e18b243022bcb7573443e06444423?s=50"></div><header><strong>[SHORT Review] SE-0132: Rationalizing Sequence end-operation names</strong> from <string>Boris Wang</string> &lt;kona.ming at gmail.com&gt;<p>July 26, 2016 at 03:00:00am</p></header><div class="content"><p>I am curious about the reason using &quot;removing&quot;,<br>What we are doing is not remove, just selecting some elements from the<br>original collection.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160726/d8997ab2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f6b7154fd1d6a470d0b521a2e484bffc?s=50"></div><header><strong>[SHORT Review] SE-0132: Rationalizing Sequence end-operation names</strong> from <string>Daniel Duan</string> &lt;daniel at duan.org&gt;<p>July 25, 2016 at 08:00:00pm</p></header><div class="content"><p>Please read the naming section in Swift API design guidelines https://swift.org/documentation/api-design-guidelines/#naming<br></p><p>Daniel Duan<br>Sent from my iPhone<br></p><p>&gt; On Jul 25, 2016, at 8:29 PM, Boris Wang via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I am curious about the reason using &quot;removing&quot;,<br>&gt; What we are doing is not remove, just selecting some elements from the original collection.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160725/d408ba3f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/242e18b243022bcb7573443e06444423?s=50"></div><header><strong>[SHORT Review] SE-0132: Rationalizing Sequence end-operation names</strong> from <string>Boris Wang</string> &lt;kona.ming at gmail.com&gt;<p>July 26, 2016 at 04:00:00am</p></header><div class="content"><p>&quot;When the operation is naturally described by a verb, use the verb’s<br>imperative for the mutating method and apply the “ed” or “ing” suffix to<br>name its nonmutating counterpart.&quot;<br></p><p>I known it. But, the &quot;verb&quot; here should be a action will change the object.<br>Not every verb will change the object.<br></p><p>Like the word: peek ,copy.<br></p><p>In socket program, there&#39;s a action &quot;peek&quot;, just check if there has new<br>data in socket data buffer, not move out the data(like the API receive()).<br>It&#39;s not &quot;receiving&quot;.<br></p><p><br>Daniel Duan &lt;daniel at duan.org&gt;于2016年7月26日 周二11:39写道：<br></p><p>&gt; Please read the naming section in Swift API design guidelines<br>&gt; https://swift.org/documentation/api-design-guidelines/#naming<br>&gt;<br>&gt;<br>&gt; Daniel Duan<br>&gt; Sent from my iPhone<br>&gt;<br>&gt; On Jul 25, 2016, at 8:29 PM, Boris Wang via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I am curious about the reason using &quot;removing&quot;,<br>&gt; What we are doing is not remove, just selecting some elements from the<br>&gt; original collection.<br>&gt;<br>&gt; _______________________________________________<br>&gt;<br>&gt;<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160726/0faded0b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2024f9524b1e51a54c4251abf0c34f50?s=50"></div><header><strong>[SHORT Review] SE-0132: Rationalizing Sequence end-operation names</strong> from <string>Saagar Jha</string> &lt;saagarjha28 at gmail.com&gt;<p>July 25, 2016 at 09:00:00pm</p></header><div class="content"><p>There’s remove, which is mutating in that it actually removes the elements from the target. removing, on the other hand is nonmutating and basically gives a copy and then removes from the copy.<br>Saagar Jha<br></p><p><br></p><p>&gt; On Jul 25, 2016, at 21:21, Boris Wang via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; &quot;When the operation is naturally described by a verb, use the verb’s imperative for the mutating method and apply the “ed” or “ing” suffix to name its nonmutating counterpart.&quot;<br>&gt; <br>&gt; I known it. But, the &quot;verb&quot; here should be a action will change the object. Not every verb will change the object.<br>&gt; <br>&gt; Like the word: peek ,copy.<br>&gt; <br>&gt; In socket program, there&#39;s a action &quot;peek&quot;, just check if there has new data in socket data buffer, not move out the data(like the API receive()). It&#39;s not &quot;receiving&quot;.<br>&gt; <br>&gt; <br>&gt; Daniel Duan &lt;daniel at duan.org &lt;mailto:daniel at duan.org&gt;&gt;于2016年7月26日 周二11:39写道：<br>&gt; Please read the naming section in Swift API design guidelines https://swift.org/documentation/api-design-guidelines/#naming &lt;https://swift.org/documentation/api-design-guidelines/#naming&gt;<br>&gt; <br>&gt; <br>&gt; Daniel Duan<br>&gt; Sent from my iPhone<br>&gt; <br>&gt; On Jul 25, 2016, at 8:29 PM, Boris Wang via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; I am curious about the reason using &quot;removing&quot;,<br>&gt;&gt; What we are doing is not remove, just selecting some elements from the original collection.<br>&gt; <br>&gt;&gt; _______________________________________________<br>&gt; <br>&gt;&gt; <br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160725/53a849d7/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8149b5bd66abbc94babfda2995153481?s=50"></div><header><strong>[SHORT Review] SE-0132: Rationalizing Sequence end-operation names</strong> from <string>Nevin Brackett-Rozinsky</string> &lt;nevin.brackettrozinsky at gmail.com&gt;<p>July 26, 2016 at 11:00:00am</p></header><div class="content"><p>* What is your evaluation of the proposal?<br></p><p>“It’s complicated”<br></p><p>First, I agree with the prevailing sentiment that the incomplete-range<br>portion ought to be separated and postponed.<br></p><p>Second, the proposed renaming of methods brings great consistency. However,<br>I believe that `first(n)` and `last(n)` read more clearly at the point of<br>use than `prefix(n)` and `suffix(n)`.<br></p><p>The best bikeshed labels I can devise for parameters on the latter are<br>`prefix(limit: n)` and `suffix(limit: n)`. That would narrow the gap in<br>readability, though not close it completely.<br></p><p>Moreover, `removingPrefix(limit: n)` and `removingSuffix(limit: n)` are<br>noticeably verboser (and still a bit less clear) than `removingFirst(n)`<br>and `removingLast(n)`.<br></p><p><br>        * Does this proposal fit well with the feel and direction of Swift?<br></p><p>Changing `drop` to `removing` certainly fits the API naming guidelines.<br></p><p><br>        * Is the problem being addressed significant enough to warrant a<br>change to Swift?<br></p><p>I am not sure. Rather, the drop-becomes-removing part is significant<br>enough, because the problem being solved is “method names don’t match the<br>API guidelines”, but I am not sure about the rest of the proposal.<br></p><p><br>        * If you have used other languages or libraries with a similar<br>feature, how do you feel that this proposal compares to those?<br></p><p>Regarding incomplete ranges, Matlab uses `end` as a placeholder for the end<br>index, so arr(6:end), and a middle number for step size, so arr(6:2:end).<br></p><p>I think that designing a range-with-stride system is worth considering in<br>the future, so we should not haphazardly introduce an incomplete-range<br>system which might unduly constrain the syntax.<br></p><p><br>        * How much effort did you put into your review? A glance, a quick<br>reading, or an in-depth study?<br></p><p>Medium.<br></p><p><br>Nevin<br></p><p><br>On Mon, Jul 25, 2016 at 2:10 AM, Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hello Swift community,<br>&gt;<br>&gt; The review of &quot;SE-0132: Rationalizing Sequence end-operation names&quot; begins<br>&gt; now and runs through July 26.  Apologies for the short review cycle, but<br>&gt; we’re right up against the end of source breaking changes for Swift 3.  The<br>&gt; proposal is available here:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0132-sequence-end-ops.md<br>&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt; should be sent to the swift-evolution mailing list at<br>&gt;<br>&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the<br>&gt; review manager.<br>&gt;<br>&gt; What goes into a review?<br>&gt;<br>&gt; The goal of the review process is to improve the proposal under review<br>&gt; through constructive criticism and contribute to the direction of Swift.<br>&gt; When writing your review, here are some questions you might want to answer<br>&gt; in your review:<br>&gt;<br>&gt;         * What is your evaluation of the proposal?<br>&gt;         * Is the problem being addressed significant enough to warrant a<br>&gt; change to Swift?<br>&gt;         * Does this proposal fit well with the feel and direction of Swift?<br>&gt;         * If you have used other languages or libraries with a similar<br>&gt; feature, how do you feel that this proposal compares to those?<br>&gt;         * How much effort did you put into your review? A glance, a quick<br>&gt; reading, or an in-depth study?<br>&gt;<br>&gt; More information about the Swift evolution process is available at<br>&gt;<br>&gt;         https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;<br>&gt; Thank you,<br>&gt;<br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160726/e7b18b8d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[SHORT Review] SE-0132: Rationalizing Sequence end-operation names</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July 26, 2016 at 11:00:00am</p></header><div class="content"><p>on Tue Jul 26 2016, Nevin Brackett-Rozinsky &lt;nevin.brackettrozinsky-AT-gmail.com&gt; wrote:<br></p><p>&gt;         * What is your evaluation of the proposal?<br>&gt;<br>&gt; “It’s complicated”<br>&gt;<br>&gt; First, I agree with the prevailing sentiment that the incomplete-range<br>&gt; portion ought to be separated and postponed.<br></p><p>FWIW, I don&#39;t see any evidence that such a sentiment prevails.<br></p><p>tail-wagging-the-dog?-ly y&#39;rs,<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[SHORT Review] SE-0132: Rationalizing Sequence end-operation names</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>July 26, 2016 at 09:00:00pm</p></header><div class="content"><p>I double Nevin on everything he said, especially about incomplete ranges.<br></p><p>2016-07-26 21:13 GMT+03:00 Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt;:<br></p><p>&gt;<br>&gt; on Tue Jul 26 2016, Nevin Brackett-Rozinsky &lt;<br>&gt; nevin.brackettrozinsky-AT-gmail.com&gt; wrote:<br>&gt;<br>&gt; &gt;         * What is your evaluation of the proposal?<br>&gt; &gt;<br>&gt; &gt; “It’s complicated”<br>&gt; &gt;<br>&gt; &gt; First, I agree with the prevailing sentiment that the incomplete-range<br>&gt; &gt; portion ought to be separated and postponed.<br>&gt;<br>&gt; FWIW, I don&#39;t see any evidence that such a sentiment prevails.<br>&gt;<br>&gt; tail-wagging-the-dog?-ly y&#39;rs,<br>&gt;<br>&gt; --<br>&gt; Dave<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160726/76ba409f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[SHORT Review] SE-0132: Rationalizing Sequence end-operation names</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July 26, 2016 at 01:00:00pm</p></header><div class="content"><p>on Tue Jul 26 2016, Anton Zhilin &lt;antonyzhilin-AT-gmail.com&gt; wrote:<br></p><p>&gt; I double Nevin on everything he said, especially about incomplete ranges.<br>&gt;<br>&gt; 2016-07-26 21:13 GMT+03:00 Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; on Tue Jul 26 2016, Nevin Brackett-Rozinsky &lt;<br>&gt;&gt; nevin.brackettrozinsky-AT-gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; &gt;         * What is your evaluation of the proposal?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; “It’s complicated”<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; First, I agree with the prevailing sentiment that the incomplete-range<br>&gt;&gt; &gt; portion ought to be separated and postponed.<br>&gt;&gt;<br>&gt;&gt; FWIW, I don&#39;t see any evidence that such a sentiment prevails.<br>&gt;&gt;<br>&gt;&gt; tail-wagging-the-dog?-ly y&#39;rs,<br></p><p>Looks like I had missed some messages in the thread.  I see the evidence<br>now.<br></p><p>Sorry,<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d9dbc0dfeb74eab8dd9bbd9cbd84680?s=50"></div><header><strong>[SHORT Review] SE-0132: Rationalizing Sequence end-operation names</strong> from <string>Jose Cheyo Jimenez</string> &lt;cheyo at masters3d.com&gt;<p>July 26, 2016 at 03:00:00pm</p></header><div class="content"><p>I think we are missing some sort of diff to show the impact of this proposal similar to what we had for the “grand renaming&quot;<br></p><p><br>&gt; On Jul 26, 2016, at 1:23 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Tue Jul 26 2016, Anton Zhilin &lt;antonyzhilin-AT-gmail.com &lt;http://antonyzhilin-at-gmail.com/&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; I double Nevin on everything he said, especially about incomplete ranges.<br>&gt;&gt; <br>&gt;&gt; 2016-07-26 21:13 GMT+03:00 Dave Abrahams via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Tue Jul 26 2016, Nevin Brackett-Rozinsky &lt;<br>&gt;&gt;&gt; nevin.brackettrozinsky-AT-gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;        * What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; “It’s complicated”<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; First, I agree with the prevailing sentiment that the incomplete-range<br>&gt;&gt;&gt;&gt; portion ought to be separated and postponed.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; FWIW, I don&#39;t see any evidence that such a sentiment prevails.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; tail-wagging-the-dog?-ly y&#39;rs,<br>&gt; <br>&gt; Looks like I had missed some messages in the thread.  I see the evidence<br>&gt; now.<br>&gt; <br>&gt; Sorry,<br>&gt; <br>&gt; -- <br>&gt; Dave<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160726/0bedb1c8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[SHORT Review] SE-0132: Rationalizing Sequence end-operation names</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>July 26, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jul 26, 2016, at 3:51 PM, Jose Cheyo Jimenez via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I think we are missing some sort of diff to show the impact of this proposal similar to what we had for the “grand renaming&quot;<br></p><p>The proposal itself shows the impact.<br></p><p>* Full list of renamed methods: &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0132-sequence-end-ops.md#sequence-end-operations-1&gt;<br></p><p>* New patterns for redesigned `prefix(upTo/through:)` and `suffix(from:)` APIs: &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0132-sequence-end-ops.md#impact-on-existing-code&gt;<br></p><p>* Source-compatible method/subscript signature changes to work with RangeExpression: &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0132-sequence-end-ops.md#index-based-operations-1&gt;<br></p><p>Compared to the Great Renaming, this proposal has a tiny footprint:<br></p><p>• 11 methods renamed, with stubs for @available attributes left in extensions on Sequence or Collection<br>• 3 methods removed (replaced with new subrange syntax)<br>• 2 types and 6 operators added for incomplete ranges<br>• 1 protocol added for RangeExpression<br>• 2 subscripts and 2 methods in 3 protocols changed to work with RangeExpression<br></p><p>I&#39;m working on an implementation (so far I just have `dropFirst` renamed, but I&#39;ve only spent about half an hour on it, mostly waiting for tests), but the diff isn&#39;t really going to tell you much.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[SHORT Review] SE-0132: Rationalizing Sequence end-operation names</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>July 27, 2016 at 05:00:00am</p></header><div class="content"><p>&gt; On Jul 26, 2016, at 5:45 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt; I&#39;m working on an implementation (so far I just have `dropFirst` renamed, but I&#39;ve only spent about half an hour on it, mostly waiting for tests), but the diff isn&#39;t really going to tell you much.<br></p><p>Now finished: https://github.com/apple/swift/pull/3793/files<br></p><p>The diff shows a lot of lines touched, but that&#39;s mainly unrelated documentation—it turns out an awful lot of examples use `index(of:)`!—and tests.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d9dbc0dfeb74eab8dd9bbd9cbd84680?s=50"></div><header><strong>[SHORT Review] SE-0132: Rationalizing Sequence end-operation names</strong> from <string>Jose Cheyo Jimenez</string> &lt;cheyo at masters3d.com&gt;<p>July 27, 2016 at 06:00:00am</p></header><div class="content"><p>&gt; On Jul 27, 2016, at 5:58 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Jul 26, 2016, at 5:45 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;m working on an implementation (so far I just have `dropFirst` renamed, but I&#39;ve only spent about half an hour on it, mostly waiting for tests), but the diff isn&#39;t really going to tell you much.<br>&gt; <br>&gt; Now finished: https://github.com/apple/swift/pull/3793/files<br>&gt; <br>&gt; The diff shows a lot of lines touched, but that&#39;s mainly unrelated documentation—it turns out an awful lot of examples use `index(of:)`!—and tests.<br></p><p>Nice work! Thanks for putting this together. Very helpful. <br></p><p>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[SHORT Review] SE-0132: Rationalizing Sequence end-operation names</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>July 26, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jul 26, 2016, at 8:30 AM, Nevin Brackett-Rozinsky &lt;nevin.brackettrozinsky at gmail.com&gt; wrote:<br>&gt; <br>&gt; However, I believe that `first(n)` and `last(n)` read more clearly at the point of use than `prefix(n)` and `suffix(n)`.<br></p><p>I&#39;ve seen this a couple of times. It&#39;s something I bring up in &quot;Other alternatives&quot;:<br></p><p>&gt; * We considered using `first` and `last` as the basis for both <br>&gt;   single-element and multiple-element operations (such that `prefix(3)` <br>&gt;   would become `first(3)`, etc.), but:<br>&gt;   <br>&gt;   1. These seemed like distinct functionalities, particularly since <br>&gt;      their types are different.<br>&gt;   <br>&gt;   2. We&#39;re not comfortable with heavily overloading a property with a <br>&gt;      bunch of methods, and didn&#39;t want to make `first` and `last` into <br>&gt; 	 methods.<br>&gt;   <br>&gt;   3. Most APIs work fine, but `hasFirst(_:)` is atrocious, and we see <br>&gt;      no better alternative which includes the word `first`.<br></p><p>To give you an idea of what I mean by #3:<br></p><p>	if numbers.hasFirst([1, 2, 3, 4, 5]) &amp;&amp; numbers.hasLast([5, 4, 3, 2, 1]) { … }<br></p><p>Keeping those issues in mind, do you still prefer `first(n)` over `prefix(n)`?<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/242e18b243022bcb7573443e06444423?s=50"></div><header><strong>[SHORT Review] SE-0132: Rationalizing Sequence end-operation names</strong> from <string>Boris Wang</string> &lt;kona.ming at gmail.com&gt;<p>July 26, 2016 at 10:00:00pm</p></header><div class="content"><p>the single word “first” only means one element，<br>but “prefix” can means multiple element.<br></p><p><br>Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt;于2016年7月27日<br>周三03:46写道：<br></p><p>&gt; &gt; On Jul 26, 2016, at 8:30 AM, Nevin Brackett-Rozinsky &lt;<br>&gt; nevin.brackettrozinsky at gmail.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; However, I believe that `first(n)` and `last(n)` read more clearly at<br>&gt; the point of use than `prefix(n)` and `suffix(n)`.<br>&gt;<br>&gt; I&#39;ve seen this a couple of times. It&#39;s something I bring up in &quot;Other<br>&gt; alternatives&quot;:<br>&gt;<br>&gt; &gt; * We considered using `first` and `last` as the basis for both<br>&gt; &gt;   single-element and multiple-element operations (such that `prefix(3)`<br>&gt; &gt;   would become `first(3)`, etc.), but:<br>&gt; &gt;<br>&gt; &gt;   1. These seemed like distinct functionalities, particularly since<br>&gt; &gt;      their types are different.<br>&gt; &gt;<br>&gt; &gt;   2. We&#39;re not comfortable with heavily overloading a property with a<br>&gt; &gt;      bunch of methods, and didn&#39;t want to make `first` and `last` into<br>&gt; &gt;        methods.<br>&gt; &gt;<br>&gt; &gt;   3. Most APIs work fine, but `hasFirst(_:)` is atrocious, and we see<br>&gt; &gt;      no better alternative which includes the word `first`.<br>&gt;<br>&gt; To give you an idea of what I mean by #3:<br>&gt;<br>&gt;         if numbers.hasFirst([1, 2, 3, 4, 5]) &amp;&amp; numbers.hasLast([5, 4, 3,<br>&gt; 2, 1]) { … }<br>&gt;<br>&gt; Keeping those issues in mind, do you still prefer `first(n)` over<br>&gt; `prefix(n)`?<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160726/faffe0de/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8149b5bd66abbc94babfda2995153481?s=50"></div><header><strong>[SHORT Review] SE-0132: Rationalizing Sequence end-operation names</strong> from <string>Nevin Brackett-Rozinsky</string> &lt;nevin.brackettrozinsky at gmail.com&gt;<p>July 26, 2016 at 07:00:00pm</p></header><div class="content"><p>On Tue, Jul 26, 2016 at 6:58 PM, Boris Wang &lt;kona.ming at gmail.com&gt; wrote:<br></p><p>&gt; the single word “first” only means one element，<br>&gt; but “prefix” can means multiple element.<br>&gt;<br></p><p>I dispute the former claim. As evidence I cite:<br></p><p>• The first four letters of the alphabet are A, B, C, and D.<br>• The first three Presidents of the United States were George Washington,<br>John Adams, and Thomas Jefferson.<br>• The first two humans to walk on the moon were Neil Armstrong and Buzz<br>Aldrin.<br></p><p>The defense rests.<br></p><p>Nevin<br></p><p><br></p><p>&gt;<br>&gt; Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt;于2016年7月27日<br>&gt; 周三03:46写道：<br>&gt;<br>&gt;&gt; &gt; On Jul 26, 2016, at 8:30 AM, Nevin Brackett-Rozinsky &lt;<br>&gt;&gt; nevin.brackettrozinsky at gmail.com&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; However, I believe that `first(n)` and `last(n)` read more clearly at<br>&gt;&gt; the point of use than `prefix(n)` and `suffix(n)`.<br>&gt;&gt;<br>&gt;&gt; I&#39;ve seen this a couple of times. It&#39;s something I bring up in &quot;Other<br>&gt;&gt; alternatives&quot;:<br>&gt;&gt;<br>&gt;&gt; &gt; * We considered using `first` and `last` as the basis for both<br>&gt;&gt; &gt;   single-element and multiple-element operations (such that `prefix(3)`<br>&gt;&gt; &gt;   would become `first(3)`, etc.), but:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;   1. These seemed like distinct functionalities, particularly since<br>&gt;&gt; &gt;      their types are different.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;   2. We&#39;re not comfortable with heavily overloading a property with a<br>&gt;&gt; &gt;      bunch of methods, and didn&#39;t want to make `first` and `last` into<br>&gt;&gt; &gt;        methods.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;   3. Most APIs work fine, but `hasFirst(_:)` is atrocious, and we see<br>&gt;&gt; &gt;      no better alternative which includes the word `first`.<br>&gt;&gt;<br>&gt;&gt; To give you an idea of what I mean by #3:<br>&gt;&gt;<br>&gt;&gt;         if numbers.hasFirst([1, 2, 3, 4, 5]) &amp;&amp; numbers.hasLast([5, 4, 3,<br>&gt;&gt; 2, 1]) { … }<br>&gt;&gt;<br>&gt;&gt; Keeping those issues in mind, do you still prefer `first(n)` over<br>&gt;&gt; `prefix(n)`?<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160726/3e7e6302/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8149b5bd66abbc94babfda2995153481?s=50"></div><header><strong>[SHORT Review] SE-0132: Rationalizing Sequence end-operation names</strong> from <string>Nevin Brackett-Rozinsky</string> &lt;nevin.brackettrozinsky at gmail.com&gt;<p>July 26, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt;<br>&gt; * We considered using `first` and `last` as the basis for both<br>&gt;    single-element and multiple-element operations (such that `prefix(3)`<br>&gt;    would become `first(3)`, etc.), but:<br>&gt;<br></p><p><br>   1. These seemed like distinct functionalities, particularly since<br>&gt;       their types are different.<br></p><p><br>I think the functionality of “Please give me the first 1 element” is<br>extremely similar to “Please give me the first n elements”.<br></p><p><br></p><p><br>Keeping those issues in mind, do you still prefer `first(n)` over<br>&gt; `prefix(n)`?<br></p><p><br>In my subjective opinion, `.first`, `.first(n)`, and `starts(with: [1, 2,<br>3])` are crystal-clear at the use site, and coexist just fine.<br>Additionally, `hasPrefix([1, 2, 3])` is equally clear and I would be fine<br>with that—in particular I am fine with the “get” and “test” methods using<br>different words.<br></p><p>By contrast, I find `prefix(n)` to be unclear about the role of `n`.<br>Something like `prefix(limit: n)`<br></p><p><br>On Tue, Jul 26, 2016 at 3:46 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>wrote:<br></p><p>&gt; &gt; On Jul 26, 2016, at 8:30 AM, Nevin Brackett-Rozinsky &lt;<br>&gt; nevin.brackettrozinsky at gmail.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; However, I believe that `first(n)` and `last(n)` read more clearly at<br>&gt; the point of use than `prefix(n)` and `suffix(n)`.<br>&gt;<br>&gt; I&#39;ve seen this a couple of times. It&#39;s something I bring up in &quot;Other<br>&gt; alternatives&quot;:<br>&gt;<br>&gt; &gt; * We considered using `first` and `last` as the basis for both<br>&gt; &gt;   single-element and multiple-element operations (such that `prefix(3)`<br>&gt; &gt;   would become `first(3)`, etc.), but:<br>&gt; &gt;<br>&gt; &gt;   1. These seemed like distinct functionalities, particularly since<br>&gt; &gt;      their types are different.<br>&gt; &gt;<br>&gt; &gt;   2. We&#39;re not comfortable with heavily overloading a property with a<br>&gt; &gt;      bunch of methods, and didn&#39;t want to make `first` and `last` into<br>&gt; &gt;        methods.<br>&gt; &gt;<br>&gt; &gt;   3. Most APIs work fine, but `hasFirst(_:)` is atrocious, and we see<br>&gt; &gt;      no better alternative which includes the word `first`.<br>&gt;<br>&gt; To give you an idea of what I mean by #3:<br>&gt;<br>&gt;         if numbers.hasFirst([1, 2, 3, 4, 5]) &amp;&amp; numbers.hasLast([5, 4, 3,<br>&gt; 2, 1]) { … }<br>&gt;<br>&gt; Keeping those issues in mind, do you still prefer `first(n)` over<br>&gt; `prefix(n)`?<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160726/df6243c6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8149b5bd66abbc94babfda2995153481?s=50"></div><header><strong>[SHORT Review] SE-0132: Rationalizing Sequence end-operation names</strong> from <string>Nevin Brackett-Rozinsky</string> &lt;nevin.brackettrozinsky at gmail.com&gt;<p>July 26, 2016 at 07:00:00pm</p></header><div class="content"><p>Whoops, hit reply too soon. Please consider the following inserted in the<br>gap in my last email:<br></p><p>2. We&#39;re not comfortable with heavily overloading a property with a bunch<br>&gt; of methods, and didn&#39;t want to make `first` and `last` into methods.<br></p><p><br>I am okay with this overload precisely *because* the functionality is so<br>similar.<br></p><p><br>3. Most APIs work fine, but `hasFirst(_:)` is atrocious, and we see no<br>&gt; better alternative which includes the word `first`.<br></p><p><br>Agreed. Both `starts(with:)` or `hasPrefix(_:)` are much better, and I<br>would be happy with either.<br></p><p><br>…and I seem to have cut off a sentence at the end of my last email:<br></p><p>Something like `prefix(limit: n)` is more descriptive than the bare<br>`prefix(n)` form, however in my view it still falls short of clarity<br>achieved by `first(n)`.<br></p><p>Nevin<br></p><p><br>On Tue, Jul 26, 2016 at 7:16 PM, Nevin Brackett-Rozinsky &lt;<br>nevin.brackettrozinsky at gmail.com&gt; wrote:<br></p><p>&gt; * We considered using `first` and `last` as the basis for both<br>&gt;&gt;    single-element and multiple-element operations (such that `prefix(3)`<br>&gt;&gt;    would become `first(3)`, etc.), but:<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt;    1. These seemed like distinct functionalities, particularly since<br>&gt;&gt;       their types are different.<br>&gt;<br>&gt;<br>&gt; I think the functionality of “Please give me the first 1 element” is<br>&gt; extremely similar to “Please give me the first n elements”.<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; Keeping those issues in mind, do you still prefer `first(n)` over<br>&gt;&gt; `prefix(n)`?<br>&gt;<br>&gt;<br>&gt; In my subjective opinion, `.first`, `.first(n)`, and `starts(with: [1, 2,<br>&gt; 3])` are crystal-clear at the use site, and coexist just fine.<br>&gt; Additionally, `hasPrefix([1, 2, 3])` is equally clear and I would be fine<br>&gt; with that—in particular I am fine with the “get” and “test” methods using<br>&gt; different words.<br>&gt;<br>&gt; By contrast, I find `prefix(n)` to be unclear about the role of `n`.<br>&gt; Something like `prefix(limit: n)`<br>&gt;<br>&gt;<br>&gt; On Tue, Jul 26, 2016 at 3:46 PM, Brent Royal-Gordon &lt;<br>&gt; brent at architechies.com&gt; wrote:<br>&gt;<br>&gt;&gt; &gt; On Jul 26, 2016, at 8:30 AM, Nevin Brackett-Rozinsky &lt;<br>&gt;&gt; nevin.brackettrozinsky at gmail.com&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; However, I believe that `first(n)` and `last(n)` read more clearly at<br>&gt;&gt; the point of use than `prefix(n)` and `suffix(n)`.<br>&gt;&gt;<br>&gt;&gt; I&#39;ve seen this a couple of times. It&#39;s something I bring up in &quot;Other<br>&gt;&gt; alternatives&quot;:<br>&gt;&gt;<br>&gt;&gt; &gt; * We considered using `first` and `last` as the basis for both<br>&gt;&gt; &gt;   single-element and multiple-element operations (such that `prefix(3)`<br>&gt;&gt; &gt;   would become `first(3)`, etc.), but:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;   1. These seemed like distinct functionalities, particularly since<br>&gt;&gt; &gt;      their types are different.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;   2. We&#39;re not comfortable with heavily overloading a property with a<br>&gt;&gt; &gt;      bunch of methods, and didn&#39;t want to make `first` and `last` into<br>&gt;&gt; &gt;        methods.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;   3. Most APIs work fine, but `hasFirst(_:)` is atrocious, and we see<br>&gt;&gt; &gt;      no better alternative which includes the word `first`.<br>&gt;&gt;<br>&gt;&gt; To give you an idea of what I mean by #3:<br>&gt;&gt;<br>&gt;&gt;         if numbers.hasFirst([1, 2, 3, 4, 5]) &amp;&amp; numbers.hasLast([5, 4, 3,<br>&gt;&gt; 2, 1]) { … }<br>&gt;&gt;<br>&gt;&gt; Keeping those issues in mind, do you still prefer `first(n)` over<br>&gt;&gt; `prefix(n)`?<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160726/96a6a528/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
