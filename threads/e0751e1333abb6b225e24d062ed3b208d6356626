<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d9baa679148bd83458d11df12327ce0?s=50"></div><header><strong>Clarification on the role of `CustomStringConvertible`</strong> from <string>Daniel Dunbar</string> &lt;daniel_dunbar at apple.com&gt;<p>June 29, 2016 at 01:00:00pm</p></header><div class="content"><p>I would like some clarification regarding the expected role of `CustomStringConvertible` for types which have a natural, lossless, string representation.<br></p><p>I don&#39;t have good terminology to use here, but is the expectation that the &quot;textual string representation&quot; is a readable description of the object? This seems to correspond to the synthesized (?) default definition for struct types, as well as some of the uses for Foundation types without natural string representations (i.e. `Foundation.Notification` reports something like &quot;name = foo, object = ..., userInfo = ...&quot;).<br></p><p>Or, is the expectation that it provide a string *representation* of the object, for objects where that makes sense. This corresponds to the use in `Foundation.UUID`, or the example of `Point.description` from the stdlib&#39;s `CustomStringConvertible` documentation.<br></p><p>Another way of phrasing this question is: for types which have a reversible string representation, should I expect `CustomStringConvertible.description` to give me a string I could use to reconstruct an instance _without_ knowing its type?<br></p><p>And another way (my actual question) is, given a `struct Path` object which contains a path string, what should `print(Path(&quot;a&quot;))` print?<br></p><p> - Daniel<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Clarification on the role of `CustomStringConvertible`</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>June 29, 2016 at 02:00:00pm</p></header><div class="content"><p>On Jun 29, 2016, at 2:33 PM, Daniel Dunbar via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; I would like some clarification regarding the expected role of `CustomStringConvertible` for types which have a natural, lossless, string representation.<br></p><p>And this is why we started down the road towards clarifying that it wasn&#39;t <br>convertible but a lossy representation. What you really want is a protocol that<br>represents an isomorphic relationship. RawRepresentable is about as close as <br>you can get right now.<br></p><p>And &quot;representation&quot; in RawRepresentable actually means &quot;isomorphic conversion<br>between types&quot;. (ish.)<br></p><p>-- E, paging Matthew Johnson to the SE-0041 courtesy phone<br></p><p>p.s. https://github.com/apple/swift-evolution/blob/master/proposals/0041-conversion-protocol-conventions.md<br></p><p><br>&gt; I don&#39;t have good terminology to use here, but is the expectation that the &quot;textual string representation&quot; is a readable description of the object? This seems to correspond to the synthesized (?) default definition for struct types, as well as some of the uses for Foundation types without natural string representations (i.e. `Foundation.Notification` reports something like &quot;name = foo, object = ..., userInfo = ...&quot;).<br>&gt; <br>&gt; Or, is the expectation that it provide a string *representation* of the object, for objects where that makes sense. This corresponds to the use in `Foundation.UUID`, or the example of `Point.description` from the stdlib&#39;s `CustomStringConvertible` documentation.<br>&gt; <br>&gt; Another way of phrasing this question is: for types which have a reversible string representation, should I expect `CustomStringConvertible.description` to give me a string I could use to reconstruct an instance _without_ knowing its type?<br>&gt; <br>&gt; And another way (my actual question) is, given a `struct Path` object which contains a path string, what should `print(Path(&quot;a&quot;))` print?<br>&gt; <br>&gt; - Daniel<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Clarification on the role of `CustomStringConvertible`</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 29, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 3:51 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; On Jun 29, 2016, at 2:33 PM, Daniel Dunbar via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I would like some clarification regarding the expected role of `CustomStringConvertible` for types which have a natural, lossless, string representation.<br>&gt; <br>&gt; And this is why we started down the road towards clarifying that it wasn&#39;t <br>&gt; convertible but a lossy representation. What you really want is a protocol that<br>&gt; represents an isomorphic relationship. RawRepresentable is about as close as <br>&gt; you can get right now.<br>&gt; <br>&gt; And &quot;representation&quot; in RawRepresentable actually means &quot;isomorphic conversion<br>&gt; between types&quot;. (ish.)<br>&gt; <br>&gt; -- E, paging Matthew Johnson to the SE-0041 courtesy phone<br></p><p><br>RawRepresentable does not require isomorphism and in fact conforming types *cannot* express isomorphm through conformances to this protocol due to the failable initializer.  RawRepresentable expresses an injective conversion making the inverse a partial function which is why the initializer is failable (https://en.wikipedia.org/wiki/Injective_function).  RawRepresentable conformance with a String `RawValue` is exactly the right way to express a lossless String representation in Swift.  <br></p><p>Isomorphic relationships require a precise one-to-one correspondence between values of two types (sets in mathematics).  They are usually bijective (I didn’t know they aren’t always bijective until I consulted wikipedia!).  https://en.wikipedia.org/wiki/Isomorphism https://en.wikipedia.org/wiki/Bijection<br></p><p>A good example of an isomorphism in Swift is CGFloat and Double on platforms where CGFloat is a Double.  For any value of one you can convert to the other and convert back to the original type without losing any information in either direction.<br></p><p>&gt; <br>&gt; p.s. https://github.com/apple/swift-evolution/blob/master/proposals/0041-conversion-protocol-conventions.md<br>&gt; <br>&gt; <br>&gt;&gt; I don&#39;t have good terminology to use here, but is the expectation that the &quot;textual string representation&quot; is a readable description of the object? This seems to correspond to the synthesized (?) default definition for struct types, as well as some of the uses for Foundation types without natural string representations (i.e. `Foundation.Notification` reports something like &quot;name = foo, object = ..., userInfo = ...&quot;).<br>&gt;&gt; <br>&gt;&gt; Or, is the expectation that it provide a string *representation* of the object, for objects where that makes sense. This corresponds to the use in `Foundation.UUID`, or the example of `Point.description` from the stdlib&#39;s `CustomStringConvertible` documentation.<br>&gt;&gt; <br>&gt;&gt; Another way of phrasing this question is: for types which have a reversible string representation, should I expect `CustomStringConvertible.description` to give me a string I could use to reconstruct an instance _without_ knowing its type?<br>&gt;&gt; <br>&gt;&gt; And another way (my actual question) is, given a `struct Path` object which contains a path string, what should `print(Path(&quot;a&quot;))` print?<br>&gt;&gt; <br>&gt;&gt; - Daniel<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d9baa679148bd83458d11df12327ce0?s=50"></div><header><strong>Clarification on the role of `CustomStringConvertible`</strong> from <string>Daniel Dunbar</string> &lt;daniel_dunbar at apple.com&gt;<p>June 29, 2016 at 02:00:00pm</p></header><div class="content"><p>Thanks for the pointers!<br></p><p>I agree with the motivation in the proposal, unfortunately this doesn&#39;t really help address the question of how to understand the current protocol though, unless I am mistaken?<br></p><p> - Daniel<br></p><p>&gt; On Jun 29, 2016, at 2:37 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jun 29, 2016, at 3:51 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Jun 29, 2016, at 2:33 PM, Daniel Dunbar via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would like some clarification regarding the expected role of `CustomStringConvertible` for types which have a natural, lossless, string representation.<br>&gt;&gt; <br>&gt;&gt; And this is why we started down the road towards clarifying that it wasn&#39;t <br>&gt;&gt; convertible but a lossy representation. What you really want is a protocol that<br>&gt;&gt; represents an isomorphic relationship. RawRepresentable is about as close as <br>&gt;&gt; you can get right now.<br>&gt;&gt; <br>&gt;&gt; And &quot;representation&quot; in RawRepresentable actually means &quot;isomorphic conversion<br>&gt;&gt; between types&quot;. (ish.)<br>&gt;&gt; <br>&gt;&gt; -- E, paging Matthew Johnson to the SE-0041 courtesy phone<br>&gt; <br>&gt; <br>&gt; RawRepresentable does not require isomorphism and in fact conforming types *cannot* express isomorphm through conformances to this protocol due to the failable initializer.  RawRepresentable expresses an injective conversion making the inverse a partial function which is why the initializer is failable (https://en.wikipedia.org/wiki/Injective_function &lt;https://en.wikipedia.org/wiki/Injective_function&gt;).  RawRepresentable conformance with a String `RawValue` is exactly the right way to express a lossless String representation in Swift.  <br>&gt; <br>&gt; Isomorphic relationships require a precise one-to-one correspondence between values of two types (sets in mathematics).  They are usually bijective (I didn’t know they aren’t always bijective until I consulted wikipedia!).  https://en.wikipedia.org/wiki/Isomorphism &lt;https://en.wikipedia.org/wiki/Isomorphism&gt; https://en.wikipedia.org/wiki/Bijection &lt;https://en.wikipedia.org/wiki/Bijection&gt;<br>&gt; <br>&gt; A good example of an isomorphism in Swift is CGFloat and Double on platforms where CGFloat is a Double.  For any value of one you can convert to the other and convert back to the original type without losing any information in either direction.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; p.s. https://github.com/apple/swift-evolution/blob/master/proposals/0041-conversion-protocol-conventions.md<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t have good terminology to use here, but is the expectation that the &quot;textual string representation&quot; is a readable description of the object? This seems to correspond to the synthesized (?) default definition for struct types, as well as some of the uses for Foundation types without natural string representations (i.e. `Foundation.Notification` reports something like &quot;name = foo, object = ..., userInfo = ...&quot;).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Or, is the expectation that it provide a string *representation* of the object, for objects where that makes sense. This corresponds to the use in `Foundation.UUID`, or the example of `Point.description` from the stdlib&#39;s `CustomStringConvertible` documentation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another way of phrasing this question is: for types which have a reversible string representation, should I expect `CustomStringConvertible.description` to give me a string I could use to reconstruct an instance _without_ knowing its type?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And another way (my actual question) is, given a `struct Path` object which contains a path string, what should `print(Path(&quot;a&quot;))` print?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Daniel<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt; swift-users at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160629/4e056148/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Clarification on the role of `CustomStringConvertible`</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June 29, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 1:33 PM, Daniel Dunbar via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; I would like some clarification regarding the expected role of `CustomStringConvertible` for types which have a natural, lossless, string representation.<br>&gt; <br>&gt; I don&#39;t have good terminology to use here, but is the expectation that the &quot;textual string representation&quot; is a readable description of the object? This seems to correspond to the synthesized (?) default definition for struct types, as well as some of the uses for Foundation types without natural string representations (i.e. `Foundation.Notification` reports something like &quot;name = foo, object = ..., userInfo = ...&quot;).<br>&gt; <br>&gt; Or, is the expectation that it provide a string *representation* of the object, for objects where that makes sense. This corresponds to the use in `Foundation.UUID`, or the example of `Point.description` from the stdlib&#39;s `CustomStringConvertible` documentation.<br></p><p>CustomStringConvertible is intended to be a non-localized but human-readable representation of the instance. It is permitted to be imprecise or lossy.<br></p><p>Swift takes the position that it should always be possible to convert an instance into some kind of string. For pure Swift types, no default implementation is provided, but String&#39;s from-anything initializer itself attempts a number of increasingly desperate fallbacks, like the debugDescription and reflection. Objective-C is a little different; there, NSObject has a `description` property which subclasses can override, and a separate `debugDescription` property which calls through to `description` by default.<br></p><p>What I would suggest is:<br></p><p>* If there&#39;s an end-user-readable representation that captures the gist of the instance, use CustomStringConvertible.<br></p><p>* If you want to customize the way it&#39;s displayed but the audience is programers, use CustomDebugStringConvertible.<br></p><p>* Always use `String(_:)` (which is going to become `String(describing:)`) or string interpolation, rather than calling .description or .debugDescription directly. That will automatically choose the most human-readable representation available. (If you prefer the debug description, use `String(reflecting:)`.)<br></p><p>&gt; Another way of phrasing this question is: for types which have a reversible string representation, should I expect `CustomStringConvertible.description` to give me a string I could use to reconstruct an instance _without_ knowing its type?<br></p><p>In some cases, like Ints or (potentially) UUIDs, the CustomStringConvertible representation actually is lossless and unambiguous and can be converted back into an identical instance. SE-0089 introduces a LosslessStringConvertible protocol which refines CustomStringConvertible to add an `init?(_ description: String)` initializer. There&#39;s no guarantee it&#39;ll make Swift 3, but people are working on implementing it.<br></p><p>https://github.com/apple/swift-evolution/blob/master/proposals/0089-rename-string-reflection-init.md<br></p><p>However, LosslessStringConvertible should only be used when the *human-readable* representation happens to be machine-readable as well. Human readability is the first priority with `description`.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
