<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5a37f99aa1daf8c27aaa81e4f019484d?s=50"></div><header><strong>Reconsidering the (Element -&gt; T?) variant of SequenceType.flatMap</strong> from <string>Andy Matuschak</string> &lt;andy at andymatuschak.org&gt;<p>December  4, 2015 at 03:00:00pm</p></header><div class="content"><p>Hello, all! This SequenceType-implemented flatMap recently caused some confusion on my team:<br></p><p>func flatMap&lt;T&gt;(@noescape transform: (Self.Generator.Element) throws -&gt; T?) rethrows -&gt; [T]<br></p><p>I’m a big fan of this operator in various functional libraries, but I admit I was a bit surprised to see the “flatMap” terminology appear in the Swift stdlib in the first place—its naming is certainly a notch obscure!<br></p><p>From the reactions of teammates in code reviews involving these methods, there was a significant difference in comprehensibility between the Element -&gt; [T] variant and the Element -&gt; T? variant. The former was easily explained by “it’s a map, followed by a flatten,” whereas the same explanation failed in the latter case.<br></p><p>I expect that the inspiration came from Scala, where the equivalent definition has a transformer essentially of type  Element -&gt; GeneratorType&lt;T&gt;; separately, their optionals are implicitly convertible to (their equivalent of) GeneratorType. So, in the end, in Scala, you can effectively flatMap with an Element -&gt; T? transformer.<br></p><p>But Optional doesn’t implement GeneratorType, and I’d (weakly) argue that it shouldn’t. And if we think about flatMap in the context of a monadic bind (I do, anyway!), it’s especially surprising that the transformer is operating in a different monadic context (Optional) than the receiver (SequenceType). Unless we made Optional adopt SequenceType, in which case we could consider the bind to be happening in that context.<br></p><p>In conclusion, I argue that this overload is confusing both to folks unfamiliar with FP (because it doesn’t feel like Optionals can be flattened) and to folks familiar with FP (because it implies binding across monadic contexts).<br></p><p>~<br></p><p>In terms of what to do instead: I do think that this is a useful method, and I’d like to keep this functionality easily accessible! Two ideas:<br></p><p>1. We expose a separate operator like:<br></p><p>extension SequenceType where Generator.Element: OptionalType {<br>	func filterNils() -&gt; [Generator.Element.Wrapped]<br>}<br></p><p>// To deal with limitations on protocol extension type restriction:<br>protocol OptionalType {<br>	typealias Wrapped<br>	func flatMap&lt;Result&gt;(@noescape f: Wrapped -&gt; Result?) -&gt; Result?<br>}<br>extension Optional: OptionalType {}<br></p><p>Clients would do myArray.map(optionalReturningTransform).filterNils(). There would be some performance impact from the intermediate array.<br></p><p>2. We give the foo variant a more specific name, e.g. mappedArrayFilteringNils etc. Naming this is tricky (which probably implies it should be decomposed?).<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/0b5b792e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Reconsidering the (Element -&gt; T?) variant of SequenceType.flatMap</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December  4, 2015 at 03:00:00pm</p></header><div class="content"><p>I use that flatMap() variant on sequences very often. I don&#39;t think I&#39;ve<br>actually _ever_ used the variant that returns [T]. I understand the<br>monadic argument you&#39;re making, but I believe the practical choice here<br>is to keep this flatMap() variant as-is. Giving it a different name<br>would I think reduce clarity, since it&#39;s conceptually performing the<br>same operation (e.g. the closure returns some value that is flattened;<br>whether the values an array or an optional it doesn&#39;t matter), and<br>adding .filterNils() would not only reduce clarity but would, as you<br>said, have a performance impact.<br></p><p>Personally, I&#39;d be in favor of making Optional conform to SequenceType.<br>I&#39;ve filed a radar on it before, and I seem to recall a message<br>(probably to this list) yesterday suggesting the exact same thing. It<br>may even want to go ahead and adopt CollectionType too, completely<br>replacing CollectionOfOne (though the ability to subscript an optional<br>may be confusing, so it may be better to just adopt SequenceType and<br>keep CollectionOfOne around for CollectionType use-cases).<br></p><p>-Kevin Ballard<br></p><p>On Fri, Dec 4, 2015, at 03:26 PM, Andy Matuschak wrote:<br>&gt; Hello, all! This SequenceType-implemented flatMap recently caused some<br>&gt; confusion on my team:<br>&gt;<br>&gt;&gt; func flatMap&lt;T&gt;(@noescape transform: (Self.Generator.Element) throws<br>&gt;&gt; -&gt; T?) rethrows -&gt; [T]<br>&gt;<br>&gt; I’m a big fan of this operator in various functional libraries, but I<br>&gt; admit I was a bit surprised to see the “flatMap” terminology appear in<br>&gt; the Swift stdlib in the first place—its naming is certainly a notch<br>&gt; obscure!<br>&gt;<br>&gt; From the reactions of teammates in code reviews involving these<br>&gt; methods, there was a significant difference in comprehensibility<br>&gt; between the Element -&gt; [T] variant and the Element -&gt; T? variant. The<br>&gt; former was easily explained by “it’s a map, followed by a flatten,”<br>&gt; whereas the same explanation failed in the latter case.<br>&gt;<br>&gt; I expect that the inspiration came from Scala, where the equivalent<br>&gt; definition has a transformer essentially of type  Element -&gt;<br>&gt; GeneratorType&lt;T&gt;; separately, their optionals are implicitly<br>&gt; convertible to (their equivalent of) GeneratorType. So, in the end, in<br>&gt; Scala, you can effectively flatMap with an Element -&gt; T? transformer.<br>&gt;<br>&gt; But Optional doesn’t implement GeneratorType, and I’d (weakly) argue<br>&gt; that it shouldn’t. And if we think about flatMap in the context of a<br>&gt; monadic bind (I do, anyway!), it’s especially surprising that the<br>&gt; transformer is operating in a different monadic context (Optional)<br>&gt; than the receiver (SequenceType). Unless we made Optional adopt<br>&gt; SequenceType, in which case we could consider the bind to be happening<br>&gt; in that context.<br>&gt;<br>&gt; In conclusion, I argue that this overload is confusing both to folks<br>&gt; unfamiliar with FP (because it doesn’t feel like Optionals can be<br>&gt; flattened) and to folks familiar with FP (because it implies binding<br>&gt; across monadic contexts).<br>&gt;<br>&gt; ~<br>&gt;<br>&gt; In terms of what to do instead: I do think that this is a useful<br>&gt; method, and I’d like to keep this functionality easily accessible!<br>&gt; Two ideas:<br>&gt;<br>&gt; 1. We expose a separate operator like:<br>&gt;<br>&gt;&gt; extension SequenceType where Generator.Element: OptionalType { func<br>&gt;&gt; filterNils() -&gt; [Generator.Element.Wrapped] }<br>&gt;&gt;<br>&gt;&gt; // To deal with limitations on protocol extension type restriction:<br>&gt;&gt; protocol OptionalType { typealias Wrapped func<br>&gt;&gt; flatMap&lt;Result&gt;(@noescape f: Wrapped -&gt; Result?) -&gt; Result? }<br>&gt;&gt; extension Optional: OptionalType {}<br>&gt;&gt;<br>&gt; Clients would do myArray.map(optionalReturningTransform).filterNils().<br>&gt; There would be some performance impact from the intermediate array.<br>&gt;<br>&gt; 2. We give the foo variant a more specific name, e.g.<br>&gt;    mappedArrayFilteringNils etc. Naming this is tricky (which probably<br>&gt;    implies it should be decomposed?).<br>&gt;<br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/ea5637ce/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Reconsidering the (Element -&gt; T?) variant of SequenceType.flatMap</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December  4, 2015 at 03:00:00pm</p></header><div class="content"><p>On Fri, Dec 4, 2015 at 3:34 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; Personally, I&#39;d be in favor of making Optional conform to SequenceType. I&#39;ve filed a radar on it before, and I seem to recall a message (probably to this list) yesterday suggesting the exact same thing.<br></p><p>This would be an interesting direction, but we have discussed it a<br>long time ago, and found an issue in the way it would interact with<br>implicit promotions to optionals.  Basically, in a call to a function<br>accepting a Sequence, one would be able to write any non-sequence,<br>non-optional value, that would be implicitly promoted to optional, and<br>thus eligible to be passed as a Sequence.  This is the only argument<br>for not adding this conformance that I know of, but it is a show<br>stopper unfortunately.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Reconsidering the (Element -&gt; T?) variant of SequenceType.flatMap</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December  4, 2015 at 03:00:00pm</p></header><div class="content"><p>Can implicit optional promotion not be redefined to only occur when the<br>destination type is explicitly optional (as opposed to being generic)?<br>The problem you describe sounds like it could affect third-party code as<br>well if anyone has a reason to declare a protocol and extend Optional to<br>conform to it.<br></p><p>-Kevin Ballard<br></p><p>On Fri, Dec 4, 2015, at 03:37 PM, Dmitri Gribenko wrote:<br>&gt; On Fri, Dec 4, 2015 at 3:34 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; &gt; Personally, I&#39;d be in favor of making Optional conform to SequenceType. I&#39;ve filed a radar on it before, and I seem to recall a message (probably to this list) yesterday suggesting the exact same thing.<br>&gt; <br>&gt; This would be an interesting direction, but we have discussed it a<br>&gt; long time ago, and found an issue in the way it would interact with<br>&gt; implicit promotions to optionals.  Basically, in a call to a function<br>&gt; accepting a Sequence, one would be able to write any non-sequence,<br>&gt; non-optional value, that would be implicitly promoted to optional, and<br>&gt; thus eligible to be passed as a Sequence.  This is the only argument<br>&gt; for not adding this conformance that I know of, but it is a show<br>&gt; stopper unfortunately.<br>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Reconsidering the (Element -&gt; T?) variant of SequenceType.flatMap</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December  4, 2015 at 03:00:00pm</p></header><div class="content"><p>On Fri, Dec 4, 2015 at 3:52 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; Can implicit optional promotion not be redefined to only occur when the<br>&gt; destination type is explicitly optional (as opposed to being generic)?<br>&gt; The problem you describe sounds like it could affect third-party code as<br>&gt; well if anyone has a reason to declare a protocol and extend Optional to<br>&gt; conform to it.<br></p><p>It can be created by third-party code, but many other problems can be<br>created by third-party code, too (like making String conform to<br>IntegerLiteralConvertible), so it is not a concern for me in that<br>sense.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/92213e4823cdfe88f0ba5113540d386c?s=50"></div><header><strong>Reconsidering the (Element -&gt; T?) variant of SequenceType.flatMap</strong> from <string>Maxwell Swadling</string> &lt;maxs at apple.com&gt;<p>December  4, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; On 4 Dec 2015, at 3:37 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Fri, Dec 4, 2015 at 3:34 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt;&gt; Personally, I&#39;d be in favor of making Optional conform to SequenceType. I&#39;ve filed a radar on it before, and I seem to recall a message (probably to this list) yesterday suggesting the exact same thing.<br>&gt; <br>&gt; This would be an interesting direction, but we have discussed it a<br>&gt; long time ago, and found an issue in the way it would interact with<br>&gt; implicit promotions to optionals.  Basically, in a call to a function<br>&gt; accepting a Sequence, one would be able to write any non-sequence,<br>&gt; non-optional value, that would be implicitly promoted to optional, and<br>&gt; thus eligible to be passed as a Sequence.  This is the only argument<br>&gt; for not adding this conformance that I know of, but it is a show<br>&gt; stopper unfortunately.<br>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>I can not reproduce this behaviour. I&#39;m not sure which version of the compiler had this behaviour.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Reconsidering the (Element -&gt; T?) variant of SequenceType.flatMap</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December  4, 2015 at 04:00:00pm</p></header><div class="content"><p>On Fri, Dec 4, 2015 at 4:00 PM, Maxwell Swadling &lt;maxs at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt; On 4 Dec 2015, at 3:37 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Fri, Dec 4, 2015 at 3:34 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt;&gt;&gt; Personally, I&#39;d be in favor of making Optional conform to SequenceType. I&#39;ve filed a radar on it before, and I seem to recall a message (probably to this list) yesterday suggesting the exact same thing.<br>&gt;&gt;<br>&gt;&gt; This would be an interesting direction, but we have discussed it a<br>&gt;&gt; long time ago, and found an issue in the way it would interact with<br>&gt;&gt; implicit promotions to optionals.  Basically, in a call to a function<br>&gt;&gt; accepting a Sequence, one would be able to write any non-sequence,<br>&gt;&gt; non-optional value, that would be implicitly promoted to optional, and<br>&gt;&gt; thus eligible to be passed as a Sequence.  This is the only argument<br>&gt;&gt; for not adding this conformance that I know of, but it is a show<br>&gt;&gt; stopper unfortunately.<br>&gt;&gt;<br>&gt;&gt; Dmitri<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt;&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; I can not reproduce this behaviour. I&#39;m not sure which version of the compiler had this behaviour.<br></p><p>The fact that the compiler does not do it means it is not implementing<br>the language model.  The compiler is not the source of truth about the<br>language, or we wouldn&#39;t have any bugs -- they all would be features.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/92213e4823cdfe88f0ba5113540d386c?s=50"></div><header><strong>Reconsidering the (Element -&gt; T?) variant of SequenceType.flatMap</strong> from <string>Maxwell Swadling</string> &lt;maxs at apple.com&gt;<p>December  4, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; On 4 Dec 2015, at 4:01 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Fri, Dec 4, 2015 at 4:00 PM, Maxwell Swadling &lt;maxs at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On 4 Dec 2015, at 3:37 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Fri, Dec 4, 2015 at 3:34 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt;&gt;&gt;&gt; Personally, I&#39;d be in favor of making Optional conform to SequenceType. I&#39;ve filed a radar on it before, and I seem to recall a message (probably to this list) yesterday suggesting the exact same thing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This would be an interesting direction, but we have discussed it a<br>&gt;&gt;&gt; long time ago, and found an issue in the way it would interact with<br>&gt;&gt;&gt; implicit promotions to optionals.  Basically, in a call to a function<br>&gt;&gt;&gt; accepting a Sequence, one would be able to write any non-sequence,<br>&gt;&gt;&gt; non-optional value, that would be implicitly promoted to optional, and<br>&gt;&gt;&gt; thus eligible to be passed as a Sequence.  This is the only argument<br>&gt;&gt;&gt; for not adding this conformance that I know of, but it is a show<br>&gt;&gt;&gt; stopper unfortunately.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Dmitri<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt;&gt;&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; I can not reproduce this behaviour. I&#39;m not sure which version of the compiler had this behaviour.<br>&gt; <br>&gt; The fact that the compiler does not do it means it is not implementing<br>&gt; the language model.  The compiler is not the source of truth about the<br>&gt; language, or we wouldn&#39;t have any bugs -- they all would be features.<br>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p><p>I think you were observing a bug at the time and it is safe to say it isn&#39;t part of the language. Otherwise programs like this would be accepted:<br></p><p>func f&lt;a: CustomDebugStringConvertible&gt;(x: a) {<br>    print(x.debugDescription)<br>}<br>f(1)<br></p><p>or<br></p><p>1.debugDescription<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/44b256b6/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
