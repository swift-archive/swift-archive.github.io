<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Pitch: Progress Tracking in Swift</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>January 17, 2016 at 09:00:00pm</p></header><div class="content"><p>Introduction:<br></p><p>This is a proposal for a native progress-tracking mechanism in Swift.<br></p><p>Motivation:<br></p><p>As most of us know, Foundation includes NSProgress, a class that makes <br>it fairly simple to implement progress tracking in complex applications. <br>What makes NSProgress nice is the way that it builds a tree of progress <br>objects, so that each method or function only needs to take into account <br>the work that needs to be done in that specific context, and the parent <br>NSProgress object can interpret that progress in the context of its own <br>work to be done. NSProgress also provides a support for common issues <br>like checking whether the user has cancelled an operation. However, <br>there are a few issues with NSProgress:<br></p><p>1. Because NSProgress relies on a thread-local global variable to store <br>the current progress object, it is impossible to know, outside of <br>documentation, whether any particular method supports NSProgress or not, <br>and if the documentation is inadequate, one must resort to <br>trial-and-error to determine whether NSProgress is supported (this has <br>been noted before: http://oleb.net/blog/2014/03/nsprogress/).<br></p><p>2. NSProgress relies on a paired register-deregister pattern in order to <br>obtain and release &quot;current&quot; status. One must balance every <br>becomeCurrentWithPendingUnitCount() call with a resignCurrent() call, or <br>Bad Things™ will happen. However, this pattern does not work well with <br>Swift&#39;s error handling mechanism:<br></p><p>progress.becomeCurrentWithPendingUnitCount(1)<br>try self.doSomeThingThatMightThrow()<br>progress.resignCurrent() // If an error occurs, this will never be <br>called!<br></p><p>3. It is very easy to accidentally add a child NSProgress object if one <br>does not realize that a particular method supports NSProgress. A couple <br>ways this can happen:<br></p><p>func doSomething() {<br>     let progress = NSProgress(totalUnitCount: 10)<br></p><p>     progress.becomeCurrentWithPendingUnitCount(10)<br>     doSomethingThatSupportsNSProgress()<br>     doSomethingThatWeDontExpectSupportsNSProgressButDoes() // whoops, we <br>just picked up a child accidentally<br>     progress.resignCurrent()<br>}<br></p><p>func doSomething() {<br>     let progress = NSProgress(totalUnitCount: 10)<br></p><p>     progress.becomeCurrentWithPendingUnitCount(10)<br>     doSomethingThatSupportsNSProgress()<br>     progress.resignCurrent()<br></p><p>     doSomethingThatWeDontExpectSupportsNSProgressButDoes() // whoops, <br>this one just picked up our parent&#39;s NSProgress and made it our sibling<br>}<br></p><p>This is particularly problematic when you consider the obvious <br>workaround for the problem described in #2:<br></p><p>func doSomething() {<br>     let progress = NSProgress(totalUnitCount: 10)<br></p><p>     progress.becomeCurrentWithPendingUnitCount(10)<br>     defer { progress.resignCurrent() }<br></p><p>     doSomethingThatSupportsNSProgress()<br>     doSomethingThatWeDontExpectSupportsNSProgressButDoes() // whoops<br>}<br></p><p>I haven&#39;t figured out exactly how to reproduce this reliably yet, but I <br>have noticed that NSProgress objects can sometimes end up with a <br>fractionCompleted larger than 1.0 when this occurs.<br></p><p>4. Because NSProgress uses a thread-local global variable for the <br>current progress, one must be vigilant about jumping through specific <br>hoops when spinning off a task in a new thread, or else the child task&#39;s <br>NSProgress object will not be properly connected to its parent.<br></p><p>5. NSProgress posts KVO notifications on the main thread. In addition to <br>complicating the interface and causing undefined behavior if one <br>mistakenly binds it to a UI element without inserting something in <br>between to forward the KVO notifications to the main thread, this also <br>hurts performance in the worker thread, since KVO notifications carry a <br>non-trivial performance penalty, involving not only message sends but <br>also packaging things into an NSDictionary for the &quot;change&quot; parameter. <br>Notifications for multiple properties are fired every time <br>completedUnitCount is changed, which then can cause similar KVO <br>notifications to occur up the family tree, depending on how many KVO <br>observers are installed. This can show up as a non-trivial performance <br>cost in Instruments if the NSProgress object is updated frequently <br>enough.<br></p><p>Proposed Solution:<br></p><p>I propose a system that follows the example of Swift&#39;s excellent <br>do/try/catch error-handling system. A &quot;reports&quot; keyword can be added to <br>a function or method&#39;s declaration, similar to &quot;throws&quot;:<br></p><p>func myFunc() reports -&gt; () {<br>     ...<br>}<br></p><p>By default, the &quot;reports&quot; keyword will introduce a &quot;let&quot; constant named <br>&quot;progress&quot; to the function&#39;s scope, much like &quot;catch&quot; implicitly adds <br>&quot;error&quot;. The name of this constant could be customized, if desired:<br></p><p>func myFunc() reports(myNiftyProgressObject) {<br>     ...<br>}<br></p><p>The created progress object is automatically added as a child to the <br>progress object which is implicitly passed into the function by the <br>calling function or method.<br></p><p>The interface to the progress object would be similar to NSProgress, <br>with a &quot;prepare&quot; method taking the total unit count, as well as a <br>&quot;cancelled&quot; property and a &quot;cancel()&quot; function helping keep track of <br>whether or not an operation is cancelled. However, the &quot;becomeCurrent&quot; <br>and &quot;resignCurrent&quot; methods are replaced with a &quot;report&quot; keyword which <br>precedes a function or method call, similar to &quot;try&quot;, although the <br>&quot;report&quot; keyword includes a parameter taking the number of units <br>corresponding to this operation:<br></p><p>func myFunc() throws, reports {<br>     progress.prepare(10)<br></p><p>     report(5) foo()<br></p><p>     if progress.cancelled { throw NSCocoaError.UserCancelledError }<br></p><p>     report(5) try bar() // yes, &quot;report&quot; can be combined with &quot;try&quot;<br>}<br></p><p>Spinning off an operation onto another thread or queue is no problem:<br></p><p>func myFunc() reports {<br>     progress.prepare(10)<br></p><p>     <br>dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <br>0)) {<br>         report(10) foo() // the progress object is passed as a parameter <br>to the function, so no need to specially make it current on this thread <br>first<br>     }<br>}<br></p><p>Unlike &quot;try&quot;, &quot;report&quot; is not required. If we don&#39;t care about the <br>progress of a method or function, we can call it without &quot;report&quot; and <br>its progress will be ignored. In this example, the <br>&quot;someRelativelyTrivialOperationThatReports&quot;&#39;s progress object will *not* <br>be added as a child to &quot;progress&quot;:<br></p><p>func myFunc() reports {<br>     progress.prepare(10)<br></p><p>     someRelativelyTrivialOperationThatReports()<br>     report(10) someNonTrivialOperationThatReports()<br>}<br></p><p>If a function calls only one reporting function, the &quot;prepare&quot; method <br>can be omitted and the parameter can be left off of &quot;report&quot;, and the <br>parent progress object will simply be passed through:<br></p><p>func myFunc() reports {<br>     report doAllTheActualWork()<br>}<br></p><p>To pass in a progress object other than the default progress object (for <br>example, when creating the object at the very top of the tree), simply <br>pass the progress object in as an optional second parameter to <br>&quot;reports&quot;:<br></p><p>func startEverything() {<br>     let progress = Progress()<br></p><p>     progress.prepare(10)<br></p><p>     report(10, progress) someFuncThatReports()<br>}<br></p><p>In the function that does the actual work, of course the progress object <br>has a &quot;completed&quot; property that tracks the completed units:<br></p><p>func doTheActualWork() reports {<br>     let someArrayOfThings = ...<br></p><p>     progress.prepare(someArrayOfThings.count)<br></p><p>     for eachThing in someArrayOfThings {<br>         // do the work<br></p><p>         progress.completed += 1<br>     }<br>}<br></p><p>Observing the progress object uses a closure-based system, containing a <br>&quot;willUpdateHandler&quot;, a &quot;didUpdateHandler&quot;, and a &quot;cancelHandler&quot;:<br></p><p>progress.didUpdateHandler = { (completed: Int, total: Int) -&gt; () in<br>     print(&quot;\(completed) units complete out of \(total)&quot;)<br>}<br></p><p>progress.cancelHandler = {<br>     print(&quot;the user cancelled the operation&quot;)<br>}<br></p><p>The separation between will- and did- handlers is to facilitate <br>interoperability with NSProgressIndicator and other Objective-C objects; <br>one could call willChangeValueForKey() and didChangeValueForKey() in the <br>handlers to let the KVO system know about the changes if needed. If <br>desired, a small wrapper could be added to Foundation to translate the <br>progress object&#39;s notifications into KVO notifications.<br></p><p>The progress object also includes a property specifying the dispatch <br>queue on which the handlers will be run. By default this is the main <br>queue, but this can be customized as needed:<br></p><p>progress.dispatchQueue = myDispatchQueue<br></p><p>Of course, any changes to the &quot;completed&quot; property in a child progress <br>object would be bubbled up the family tree, causing any handlers on the <br>parent progress objects to fire, and any changes to the &quot;cancelled&quot; <br>property in a parent progress object would be propagated to its <br>children, similar to how NSProgress currently works.<br></p><p>If there is interest in this, I could flesh out the interface and <br>implementation to the progress object a bit.<br></p><p>What do you all think?<br></p><p>Charles<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Pitch: Progress Tracking in Swift</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>January 17, 2016 at 09:00:00pm</p></header><div class="content"><p>Typo here: This should have said &quot;on the current thread.&quot; The fact that <br>NSProgress bogs down the worker thread with the work involved in <br>creating the KVO notifications is part of my issue with it.<br></p><p>Charles<br></p><p>On 2016-01-17 21:14, Charles Srstka via swift-evolution wrote:<br></p><p>&gt; 5. NSProgress posts KVO notifications on the main thread.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce6825f55ba05353e3652d8989b6137?s=50"></div><header><strong>Pitch: Progress Tracking in Swift</strong> from <string>Will Entriken</string> &lt;fulldecent at gmail.com&gt;<p>January 18, 2016 at 12:00:00pm</p></header><div class="content"><p>Charles,<br></p><p>I think this is interesting. And discussion on replacing/updating<br>NSProgress is important.<br></p><p>Just a note: optional parameters make this possible without changing the<br>language. A very rough example follows:<br></p><p>func delete(files: FileList, withProgress progress: Progress? = nil) {<br>    progress.totalUnits = 10<br>    print(&quot;Getting started&quot;)<br>    progress.completedUnits = 5 // that was easy!<br>    actuallyDelete(files, withProgress: progress.childWithUnits: 5)<br>}<br></p><p>let progress = Progress()<br>// watch progress.totalPortion using KVO 2.0<br>delete(files: allTheFiles, withProgress: progress)<br></p><p>Regards,<br>Will<br></p><p><br></p><p><br></p><p>On Sun, Jan 17, 2016 at 9:42 PM, Charles Srstka via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Typo here: This should have said &quot;on the current thread.&quot; The fact that<br>&gt; NSProgress bogs down the worker thread with the work involved in creating<br>&gt; the KVO notifications is part of my issue with it.<br>&gt;<br>&gt; Charles<br>&gt;<br>&gt; On 2016-01-17 21:14, Charles Srstka via swift-evolution wrote:<br>&gt;<br>&gt; 5. NSProgress posts KVO notifications on the main thread.<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160118/4ede3da6/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5a72880ffed1a30cb9b8e3f372507145?s=50"></div><header><strong>Pitch: Progress Tracking in Swift</strong> from <string>Rob Mayoff</string> &lt;mayoff at dqd.com&gt;<p>January 18, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt;<br>&gt; 1. Because NSProgress relies on a thread-local global variable to store<br>&gt; the current progress object, it is impossible to know, outside of<br>&gt; documentation, whether any particular method supports NSProgress or not,<br>&gt; and if the documentation is inadequate, one must resort to trial-and-error<br>&gt; to determine whether NSProgress is supported (this has been noted before:<br>&gt; http://oleb.net/blog/2014/03/nsprogress/).<br>&gt;<br></p><p>iOS 9 and OS X 10.11 support explicit progress composition through the<br>addChild:withPendingUnitCount: message, and vending of an NSProgress<br>instance (for use with the addChild:withPendingUnitCount: message) through<br>the NSProgressReporting protocol. You no longer have to rely on implicit<br>composition, and in WWDC 2015 session 232 you&#39;re encouraged to use explicit<br>composition.<br></p><p>I have a hard time believing this is something that needs dedicated<br>language syntax.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160118/4d0189ec/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Pitch: Progress Tracking in Swift</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>January 18, 2016 at 09:00:00pm</p></header><div class="content"><p>On 2016-01-18 21:12, Rob Mayoff via swift-evolution wrote:<br>&gt;&gt; 1. Because NSProgress relies on a thread-local global variable to<br>&gt;&gt; store the current progress object, it is impossible to know, outside<br>&gt;&gt; of documentation, whether any particular method supports NSProgress<br>&gt;&gt; or not, and if the documentation is inadequate, one must resort to<br>&gt;&gt; trial-and-error to determine whether NSProgress is supported (this<br>&gt;&gt; has been noted before: http://oleb.net/blog/2014/03/nsprogress/<br>&gt;&gt; [1]).<br>&gt; <br>&gt; iOS 9 and OS X 10.11 support explicit progress composition through the<br>&gt; addChild:withPendingUnitCount: message, and vending of an NSProgress<br>&gt; instance (for use with the addChild:withPendingUnitCount: message)<br>&gt; through the NSProgressReporting protocol. You no longer have to rely<br>&gt; on implicit composition, and in WWDC 2015 session 232 you&#39;re<br>&gt; encouraged to use explicit composition.<br></p><p>While this is technically true, 1) it is awkward, bloating method <br>signatures by requiring you to add a &quot;progress:&quot; parameter to all of <br>them, much like the NSError** pointers of old, 2) it doesn&#39;t solve the <br>performance issues that NSProgress has with all of its KVO notifications <br>being sent on the worker thread, and 3) you can&#39;t even use it, anyway, <br>if you can&#39;t require OS X 10.11 or iOS 9.<br></p><p>&gt; I have a hard time believing this is something that needs dedicated<br>&gt; language syntax.<br></p><p>It&#39;s an incredibly common problem; almost every app that spawns a worker <br>thread is going to need some way to report progress on the task, and a <br>way to cancel it. The more primitive methods are written to support <br>progress reporting, the easier it is for larger operations to report <br>their own progress effectively, so it makes sense to introduce a <br>mechanism that makes progress reporting as easy to implement as <br>possible. I think this is what Apple was hoping for with the original <br>NSProgress implementation; the implicit composition suggests an <br>expectation that all code that does work would support NSProgress, and <br>that you could just expect it. Sadly, that hasn&#39;t been the case, but by <br>giving it first-class language support and making it dead easy to use, <br>perhaps we could get closer to that point. At any rate, given Swift&#39;s <br>focus on performance (and subsequently, the appropriateness of using <br>pure Swift in a worker thread), it seems a shame to bog everything down <br>with a low-performing progress API like what we have currently.<br></p><p>Charles<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Pitch: Progress Tracking in Swift</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>January 18, 2016 at 10:00:00pm</p></header><div class="content"><p>In terms of which functions need it, I think that reporting progress is a relatively niche feature. I would by far prefer that we work on infrastructure to implement a library-driven solution. To me, it would be a missed opportunity to show off what the language can (will be able to) do without having to bake it into the compiler.<br></p><p>For instance, this could probably be solved without specific compiler support if Swift had a macro system and resumable functions.<br></p><p>Also, the first two arguments have merit, but it&#39;s highly improbable that you&#39;ll be able to use whatever solution we come up with in OSes older than OS X 10.11 or iOS 9 anyway.<br></p><p>Félix<br></p><p>&gt; Le 18 janv. 2016 à 21:59:09, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; On 2016-01-18 21:12, Rob Mayoff via swift-evolution wrote:<br>&gt;&gt;&gt; 1. Because NSProgress relies on a thread-local global variable to<br>&gt;&gt;&gt; store the current progress object, it is impossible to know, outside<br>&gt;&gt;&gt; of documentation, whether any particular method supports NSProgress<br>&gt;&gt;&gt; or not, and if the documentation is inadequate, one must resort to<br>&gt;&gt;&gt; trial-and-error to determine whether NSProgress is supported (this<br>&gt;&gt;&gt; has been noted before: http://oleb.net/blog/2014/03/nsprogress/<br>&gt;&gt;&gt; [1]).<br>&gt;&gt; iOS 9 and OS X 10.11 support explicit progress composition through the<br>&gt;&gt; addChild:withPendingUnitCount: message, and vending of an NSProgress<br>&gt;&gt; instance (for use with the addChild:withPendingUnitCount: message)<br>&gt;&gt; through the NSProgressReporting protocol. You no longer have to rely<br>&gt;&gt; on implicit composition, and in WWDC 2015 session 232 you&#39;re<br>&gt;&gt; encouraged to use explicit composition.<br>&gt; <br>&gt; While this is technically true, 1) it is awkward, bloating method signatures by requiring you to add a &quot;progress:&quot; parameter to all of them, much like the NSError** pointers of old, 2) it doesn&#39;t solve the performance issues that NSProgress has with all of its KVO notifications being sent on the worker thread, and 3) you can&#39;t even use it, anyway, if you can&#39;t require OS X 10.11 or iOS 9.<br>&gt; <br>&gt;&gt; I have a hard time believing this is something that needs dedicated<br>&gt;&gt; language syntax.<br>&gt; <br>&gt; It&#39;s an incredibly common problem; almost every app that spawns a worker thread is going to need some way to report progress on the task, and a way to cancel it. The more primitive methods are written to support progress reporting, the easier it is for larger operations to report their own progress effectively, so it makes sense to introduce a mechanism that makes progress reporting as easy to implement as possible. I think this is what Apple was hoping for with the original NSProgress implementation; the implicit composition suggests an expectation that all code that does work would support NSProgress, and that you could just expect it. Sadly, that hasn&#39;t been the case, but by giving it first-class language support and making it dead easy to use, perhaps we could get closer to that point. At any rate, given Swift&#39;s focus on performance (and subsequently, the appropriateness of using pure Swift in a worker thread), it seems a shame to bog everything down with a low-performing progress API like what we have currently.<br>&gt; <br>&gt; Charles<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160118/3abc09bc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Pitch: Progress Tracking in Swift</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>January 18, 2016 at 10:00:00pm</p></header><div class="content"><p>On 2016-01-18 22:24, Félix Cloutier wrote:<br>&gt; In terms of which functions need it, I think that reporting progress<br>&gt; is a relatively niche feature.<br></p><p>How is it niche? Very few apps don&#39;t have any places where progress <br>tracking (and user cancellation) would be useful, and it&#39;s currently <br>something that has to be done with workarounds that are either clunky or <br>unsafe.<br></p><p>&gt; I would by far prefer that we work on<br>&gt; infrastructure to implement a library-driven solution. To me, it would<br>&gt; be a missed opportunity to show off what the language can (will be<br>&gt; able to) do without having to bake it into the compiler.<br>&gt; <br>&gt; For instance, this could probably be solved without specific compiler<br>&gt; support if Swift had a macro system and resumable functions.<br></p><p>Apple has repeatedly stated in the past that the lack of macros/a <br>preprocessor is supposed to be a feature, not a bug (cf. <br>https://developer.apple.com/swift/blog/?id=4). I know there have <br>occasionally been some statements on the lists contradicting the <br>official stance, but nonetheless I&#39;m not sure we can count on Swift <br>gaining a macro system. Also, implementing things like this via macros <br>seems a bit... icky to my personal tastes.<br></p><p>Are there any plans to add resumable functions to Swift? I know it&#39;s <br>been pitched a few times, but it didn&#39;t seem to me like it gained much <br>traction.<br></p><p>&gt; Also, the first two arguments have merit, but it&#39;s highly improbable<br>&gt; that you&#39;ll be able to use whatever solution we come up with in OSes<br>&gt; older than OS X 10.11 or iOS 9 anyway.<br></p><p>All additions to Swift so far have been back-portable to 10.9, given <br>that the runtime gets bundled into the app.<br></p><p>Charles<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Pitch: Progress Tracking in Swift</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 18, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Jan 18, 2016, at 7:39 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On 2016-01-18 22:24, Félix Cloutier wrote:<br>&gt;&gt; In terms of which functions need it, I think that reporting progress<br>&gt;&gt; is a relatively niche feature.<br>&gt; <br>&gt; How is it niche? Very few apps don&#39;t have any places where progress tracking (and user cancellation) would be useful, and it&#39;s currently something that has to be done with workarounds that are either clunky or unsafe.<br>&gt; <br>&gt;&gt; I would by far prefer that we work on<br>&gt;&gt; infrastructure to implement a library-driven solution. To me, it would<br>&gt;&gt; be a missed opportunity to show off what the language can (will be<br>&gt;&gt; able to) do without having to bake it into the compiler.<br>&gt;&gt; For instance, this could probably be solved without specific compiler<br>&gt;&gt; support if Swift had a macro system and resumable functions.<br>&gt; <br>&gt; Apple has repeatedly stated in the past that the lack of macros/a preprocessor is supposed to be a feature, not a bug (cf. https://developer.apple.com/swift/blog/?id=4). I know there have occasionally been some statements on the lists contradicting the official stance, but nonetheless I&#39;m not sure we can count on Swift gaining a macro system. Also, implementing things like this via macros seems a bit... icky to my personal tastes.<br></p><p>Lacking the C preprocessor is a feature, lacking a macro system isn&#39;t.<br></p><p>-Joe<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c965d88fab90b7e85514d0e3011c3caf?s=50"></div><header><strong>Pitch: Progress Tracking in Swift</strong> from <string>Tim Hawkins</string> &lt;tim.thawkins at gmail.com&gt;<p>January 19, 2016 at 11:00:00am</p></header><div class="content"><p>How would this work on linux or windows?, on linux there are several dozen<br>possible GUI targets, this sounds far more like a standard patterm<br>recomendation that GUI binding library authors should provide than<br>something that should be a language feature.<br>On Jan 19, 2016 11:39 AM, &quot;Charles Srstka via swift-evolution&quot; &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On 2016-01-18 22:24, Félix Cloutier wrote:<br>&gt;<br>&gt;&gt; In terms of which functions need it, I think that reporting progress<br>&gt;&gt; is a relatively niche feature.<br>&gt;&gt;<br>&gt;<br>&gt; How is it niche? Very few apps don&#39;t have any places where progress<br>&gt; tracking (and user cancellation) would be useful, and it&#39;s currently<br>&gt; something that has to be done with workarounds that are either clunky or<br>&gt; unsafe.<br>&gt;<br>&gt; I would by far prefer that we work on<br>&gt;&gt; infrastructure to implement a library-driven solution. To me, it would<br>&gt;&gt; be a missed opportunity to show off what the language can (will be<br>&gt;&gt; able to) do without having to bake it into the compiler.<br>&gt;&gt;<br>&gt;&gt; For instance, this could probably be solved without specific compiler<br>&gt;&gt; support if Swift had a macro system and resumable functions.<br>&gt;&gt;<br>&gt;<br>&gt; Apple has repeatedly stated in the past that the lack of macros/a<br>&gt; preprocessor is supposed to be a feature, not a bug (cf.<br>&gt; https://developer.apple.com/swift/blog/?id=4). I know there have<br>&gt; occasionally been some statements on the lists contradicting the official<br>&gt; stance, but nonetheless I&#39;m not sure we can count on Swift gaining a macro<br>&gt; system. Also, implementing things like this via macros seems a bit... icky<br>&gt; to my personal tastes.<br>&gt;<br>&gt; Are there any plans to add resumable functions to Swift? I know it&#39;s been<br>&gt; pitched a few times, but it didn&#39;t seem to me like it gained much traction.<br>&gt;<br>&gt; Also, the first two arguments have merit, but it&#39;s highly improbable<br>&gt;&gt; that you&#39;ll be able to use whatever solution we come up with in OSes<br>&gt;&gt; older than OS X 10.11 or iOS 9 anyway.<br>&gt;&gt;<br>&gt;<br>&gt; All additions to Swift so far have been back-portable to 10.9, given that<br>&gt; the runtime gets bundled into the app.<br>&gt;<br>&gt; Charles<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160119/49e5618c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Pitch: Progress Tracking in Swift</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>January 18, 2016 at 11:00:00pm</p></header><div class="content"><p>It&#39;s completely platform independent. Notifications would be possible <br>via closures that are given to the progress object as handlers. Those <br>closures could do whatever is appropriate for the GUI framework that the <br>app is using.<br></p><p>Tying progress notifications to GUI frameworks is a bad idea, because it <br>precludes low-level functions that are independent of the GUI from being <br>able to report progress effectively.<br></p><p>Charles<br></p><p>On 2016-01-18 22:45, Tim Hawkins wrote:<br>&gt; How would this work on linux or windows?, on linux there are several<br>&gt; dozen possible GUI targets, this sounds far more like a standard<br>&gt; patterm recomendation that GUI binding library authors should provide<br>&gt; than something that should be a language feature.<br>&gt; On Jan 19, 2016 11:39 AM, &quot;Charles Srstka via swift-evolution&quot;<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On 2016-01-18 22:24, Félix Cloutier wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; In terms of which functions need it, I think that reporting<br>&gt;&gt;&gt; progress<br>&gt;&gt;&gt; is a relatively niche feature.<br>&gt;&gt; <br>&gt;&gt; How is it niche? Very few apps don&#39;t have any places where progress<br>&gt;&gt; tracking (and user cancellation) would be useful, and it&#39;s currently<br>&gt;&gt; something that has to be done with workarounds that are either<br>&gt;&gt; clunky or unsafe.<br>&gt;&gt; <br>&gt;&gt;&gt; I would by far prefer that we work on<br>&gt;&gt;&gt; infrastructure to implement a library-driven solution. To me, it<br>&gt;&gt;&gt; would<br>&gt;&gt;&gt; be a missed opportunity to show off what the language can (will<br>&gt;&gt;&gt; be<br>&gt;&gt;&gt; able to) do without having to bake it into the compiler.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For instance, this could probably be solved without specific<br>&gt;&gt;&gt; compiler<br>&gt;&gt;&gt; support if Swift had a macro system and resumable functions.<br>&gt;&gt; <br>&gt;&gt; Apple has repeatedly stated in the past that the lack of macros/a<br>&gt;&gt; preprocessor is supposed to be a feature, not a bug (cf.<br>&gt;&gt; https://developer.apple.com/swift/blog/?id=4 [1]). I know there have<br>&gt;&gt; occasionally been some statements on the lists contradicting the<br>&gt;&gt; official stance, but nonetheless I&#39;m not sure we can count on Swift<br>&gt;&gt; gaining a macro system. Also, implementing things like this via<br>&gt;&gt; macros seems a bit... icky to my personal tastes.<br>&gt;&gt; <br>&gt;&gt; Are there any plans to add resumable functions to Swift? I know<br>&gt;&gt; it&#39;s been pitched a few times, but it didn&#39;t seem to me like it<br>&gt;&gt; gained much traction.<br>&gt;&gt; <br>&gt;&gt;&gt; Also, the first two arguments have merit, but it&#39;s highly<br>&gt;&gt;&gt; improbable<br>&gt;&gt;&gt; that you&#39;ll be able to use whatever solution we come up with in<br>&gt;&gt;&gt; OSes<br>&gt;&gt;&gt; older than OS X 10.11 or iOS 9 anyway.<br>&gt;&gt; <br>&gt;&gt; All additions to Swift so far have been back-portable to 10.9,<br>&gt;&gt; given that the runtime gets bundled into the app.<br>&gt;&gt; <br>&gt;&gt; Charles<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution [2]<br>&gt; <br>&gt; <br>&gt; Links:<br>&gt; ------<br>&gt; [1] https://developer.apple.com/swift/blog/?id=4<br>&gt; [2] https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Pitch: Progress Tracking in Swift</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>January 18, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; Le 18 janv. 2016 à 22:39:19, cocoadev at charlessoft.com a écrit :<br>&gt; <br>&gt; On 2016-01-18 22:24, Félix Cloutier wrote:<br>&gt;&gt; In terms of which functions need it, I think that reporting progress<br>&gt;&gt; is a relatively niche feature.<br>&gt; <br>&gt; How is it niche? Very few apps don&#39;t have any places where progress tracking (and user cancellation) would be useful, and it&#39;s currently something that has to be done with workarounds that are either clunky or unsafe.<br></p><p>It&#39;s niche in that even if most applications will have functions that use it, most functions don&#39;t need it.<br></p><p>&gt;&gt; I would by far prefer that we work on<br>&gt;&gt; infrastructure to implement a library-driven solution. To me, it would<br>&gt;&gt; be a missed opportunity to show off what the language can (will be<br>&gt;&gt; able to) do without having to bake it into the compiler.<br>&gt;&gt; For instance, this could probably be solved without specific compiler<br>&gt;&gt; support if Swift had a macro system and resumable functions.<br>&gt; <br>&gt; Apple has repeatedly stated in the past that the lack of macros/a preprocessor is supposed to be a feature, not a bug (cf. https://developer.apple.com/swift/blog/?id=4). I know there have occasionally been some statements on the lists contradicting the official stance, but nonetheless I&#39;m not sure we can count on Swift gaining a macro system. Also, implementing things like this via macros seems a bit... icky to my personal tastes.<br>&gt; <br>&gt; Are there any plans to add resumable functions to Swift? I know it&#39;s been pitched a few times, but it didn&#39;t seem to me like it gained much traction.<br></p><p>As far as I can tell, support for the feature is positive; except that the core team said &quot;not yet &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151221/004158.html&gt;&quot;. I, for sure, will be on the yes side when we get there.<br></p><p>For the macro system, I&#39;m talking about a system that lets you modify Swift code at compile-time. An example system would be to allow Swift code to modify an AST. I&#39;m absolutely not an expert in this domain, I hope a LISPy person will write a proposal about it!<br></p><p>&gt;&gt; Also, the first two arguments have merit, but it&#39;s highly improbable<br>&gt;&gt; that you&#39;ll be able to use whatever solution we come up with in OSes<br>&gt;&gt; older than OS X 10.11 or iOS 9 anyway.<br>&gt; <br>&gt; All additions to Swift so far have been back-portable to 10.9, given that the runtime gets bundled into the app.<br></p><p>I&#39;m not at Apple, but my gut feeling is that it won&#39;t be possible for much longer, given that Swift 3 should stabilize the ABI and make bundling unnecessary.<br></p><p>Félix<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160118/27c7f05a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Pitch: Progress Tracking in Swift</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>January 19, 2016 at 01:00:00am</p></header><div class="content"><p>On 2016-01-18 23:34, Félix Cloutier wrote:<br>&gt;&gt;&gt; Also, the first two arguments have merit, but it&#39;s highly<br>&gt;&gt;&gt; improbable<br>&gt;&gt;&gt; that you&#39;ll be able to use whatever solution we come up with in<br>&gt;&gt;&gt; OSes<br>&gt;&gt;&gt; older than OS X 10.11 or iOS 9 anyway.<br>&gt;&gt; <br>&gt;&gt; All additions to Swift so far have been back-portable to 10.9, given<br>&gt;&gt; that the runtime gets bundled into the app.<br>&gt; <br>&gt; I&#39;m not at Apple, but my gut feeling is that it won&#39;t be possible for<br>&gt; much longer, given that Swift 3 should stabilize the ABI and make<br>&gt; bundling unnecessary.<br></p><p>This is OT, but I don&#39;t think that will happen for a while, for the <br>basic reason that if Apple removed bundling, it would break not only <br>10.9 and 10.10, but 10.11 as well, since none of the currently-shipping <br>OS X (or iOS) releases include the Swift runtime or standard library. <br>We&#39;d be looking at forcing a minimum requirement of 10.12 at the <br>earliest, which I&#39;d expect most developers wouldn&#39;t be ready to target <br>for quite some time.<br></p><p>My expectation is that once the ABI has been stabilized, and the runtime <br>and stdlib have been bundled with some OS version (let&#39;s say 10.12), <br>Xcode will switch to leaving out the runtime if you target 10.12 or <br>later, and bundle them if you target something earlier.<br></p><p>Charles<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Pitch: Progress Tracking in Swift</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January 18, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; What do you all think?<br></p><p>I think this is really thin syntactic sugar over `-&gt; NSProgress`, and doesn&#39;t add enough value to justify itself. Unlike the error handling system:<br></p><p>- The fact that a function *can* provide progress doesn&#39;t mean that any particular caller needs that progress.<br>- Progress monitoring doesn&#39;t require a lot of convoluted control flow.<br>- There is no need to customize the progress monitoring system in the way that, for instance, `ErrorType` allows.<br>- Progress monitoring doesn&#39;t require convoluted ways of returning the progress, since most progress-reporting operations are asynchronous and have no other immediate return value.<br>- Progress monitoring is actually done fairly infrequently.<br></p><p>I think that all Swift needs to support progress monitoring is to make sure that `NSProgress` returns can be ignored without a warning even if we make `@warn_unused_return` the default, and perhaps to overload `+=` on two `NSProgress`es if we can find an appropriate way to do it.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Pitch: Progress Tracking in Swift</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>January 19, 2016 at 02:00:00am</p></header><div class="content"><p>On 2016-01-19 00:35, Brent Royal-Gordon wrote:<br>&gt;&gt; What do you all think?<br>&gt; <br>&gt; I think this is really thin syntactic sugar over `-&gt; NSProgress`, and<br>&gt; doesn&#39;t add enough value to justify itself. Unlike the error handling<br>&gt; system:<br>&gt; <br>&gt; - The fact that a function *can* provide progress doesn&#39;t mean that<br>&gt; any particular caller needs that progress.<br>&gt; - Progress monitoring doesn&#39;t require a lot of convoluted control flow.<br>&gt; - Progress monitoring doesn&#39;t require convoluted ways of returning the<br>&gt; progress, since most progress-reporting operations are asynchronous<br>&gt; and have no other immediate return value.<br></p><p>This all seems to be under the assumption that NSProgress is an API <br>which is returned to the calling function. This is not how NSProgress <br>works, and in my proposal, progress objects wouldn&#39;t be returned; they&#39;d <br>be passed in as a parameter and added as a child to the current progress <br>object. So it&#39;s syntactic sugar, yes, but rather than being over -&gt; <br>NSProgress, it&#39;s over really quite a lot more than that.<br></p><p>The proposal would reduce this (explicit style):<br></p><p>func doSomethingWithProgress(progress: NSProgress) {<br>     progress.totalUnitCount = 10<br></p><p>     let childProgress1 = NSProgress()<br>     progress.addChild(childProgress1, withPendingUnitCount: 5)<br>     childFunc1WithProgress(childProgress1)<br></p><p>     let childProgress2 = NSProgress()<br>     progress.addChild(childProgress2, withPendingUnitCount: 5)<br>     childFunc2WithProgress(childProgress2)<br>}<br></p><p>func childFunc1WithProgress(progress: NSProgress) {<br>     progress.totalUnitCount = 10<br></p><p>     for i in 0..&lt;10 {<br>         // do some work<br>         progress.completedUnitCount += 1<br>     }<br>}<br></p><p>(childFunc2WithProgress looks like childFunc1WithProgress)<br></p><p>or this (implicit style):<br></p><p>func doSomethingWithProgress() {<br>     let progress = NSProgress(totalUnitCount: 10)<br></p><p>     progress.becomeCurrentWithPendingUnitCount(5)<br>     childFunc1()<br>     progress.resignCurrent()<br></p><p>     progress.becomeCurrentWithPendingUnitCount(5)<br>     childFunc2()<br>     progress.resignCurrent()<br>}<br></p><p>func childFunc1() {<br>     let progress = NSProgress(totalUnitCount: 10)<br></p><p>     for i in 0..&lt;10 {<br>         progress.completedUnitCount += 1<br>     }<br>}<br></p><p>(childFunc2 looks like childFunc1)<br></p><p>to simply this:<br></p><p>func doSomethingWithProgress() reports {<br>     progress.prepare(10)<br></p><p>     report(5) childFunc1()<br>     report(5) childFunc2()<br>}<br></p><p>func childFunc1() reports {<br>     progress.prepare(something)<br></p><p>     for i in 0..&lt;10 {<br>         progress.completed += 1<br>     }<br>}<br></p><p>(childFunc2 looks like childFunc1)<br></p><p>I don&#39;t know about you, but this seems a lot cleaner, and a lot more <br>Swifty, to me. It also combines the safety of the explicit method with <br>the flexibility of the implicit method, while requiring a heck of a lot <br>less code than both.<br></p><p>&gt; - Progress monitoring is actually done fairly infrequently.<br></p><p>If the progress object were intelligent and efficient enough to not send <br>notifications on the current thread, the progress object could be <br>updated a lot more than NSProgress is able to. You could optionally <br>apply other optimizations as well, such as coalescing updates rather <br>than firing notifications each time, which would reduce the cost of <br>updating the progress object to a few integer stores and could possibly <br>cut down some more on the code you&#39;d need to clutter your worker loop <br>with.<br></p><p>&gt; - There is no need to customize the progress monitoring system in the<br>&gt; way that, for instance, `ErrorType` allows.<br></p><p>I don&#39;t know about that; the whole reason I came up with this idea in <br>the first place was because I was wishing I could customize NSProgress <br>in certain ways, the inefficient notification system being chief among <br>them.<br></p><p>&gt; I think that all Swift needs to support progress monitoring is to make<br>&gt; sure that `NSProgress` returns can be ignored without a warning even<br>&gt; if we make `@warn_unused_return` the default, and perhaps to overload<br>&gt; `+=` on two `NSProgress`es if we can find an appropriate way to do it.<br></p><p>Again, NSProgress objects are passed in, not returned. += really would <br>have no meaning that I can see for NSProgress.<br></p><p>Charles<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be4c3c3b76631a155e1358db48066692?s=50"></div><header><strong>Pitch: Progress Tracking in Swift</strong> from <string>Tony Parker</string> &lt;anthony.parker at apple.com&gt;<p>January 19, 2016 at 11:00:00am</p></header><div class="content"><p>Hi Charles,<br></p><p>I see Rob already pointed this out, but I’ll respond as well since I own NSProgress and I also was involved in the WWDC session he references.<br></p><p>NSProgress actually received a significant upgrade in iOS 9 and OS X 10.11 to address most of your concerns. I’ve never really liked the ‘current’ progress idea either, so I’ve changed Foundation to make using explicit progress objects possible (and encouraged). There are still cases where the idea of having a current progress is useful. For example, when there is no opportunity to grab a progress object, because the method you are calling is a proxy, or a global function, etc.).<br></p><p>&gt; On Jan 17, 2016, at 6:14 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Introduction:<br>&gt; <br>&gt; This is a proposal for a native progress-tracking mechanism in Swift.<br>&gt; <br>&gt; Motivation:<br>&gt; <br>&gt; As most of us know, Foundation includes NSProgress, a class that makes it fairly simple to implement progress tracking in complex applications. What makes NSProgress nice is the way that it builds a tree of progress objects, so that each method or function only needs to take into account the work that needs to be done in that specific context, and the parent NSProgress object can interpret that progress in the context of its own work to be done. NSProgress also provides a support for common issues like checking whether the user has cancelled an operation. However, there are a few issues with NSProgress:<br>&gt; <br>&gt; 1. Because NSProgress relies on a thread-local global variable to store the current progress object, it is impossible to know, outside of documentation, whether any particular method supports NSProgress or not, and if the documentation is inadequate, one must resort to trial-and-error to determine whether NSProgress is supported (this has been noted before: http://oleb.net/blog/2014/03/nsprogress/).<br></p><p><br>You can now create progress trees explicitly. There are two parts to this:<br></p><p>    @available(OSX 10.11, *)<br>    public /*not inherited*/ init(totalUnitCount unitCount: Int64, parent: NSProgress, pendingUnitCount portionOfParentTotalUnitCount: Int64)<br></p><p>and a new protocol:<br></p><p>public protocol NSProgressReporting : NSObjectProtocol {<br>    @available(OSX 10.9, *)<br>    public var progress: NSProgress { get }<br>}<br></p><p>So you can mark classes that publish progress with the protocol, and clients can create their trees using the new initializer.<br></p><p>&gt; <br>&gt; 2. NSProgress relies on a paired register-deregister pattern in order to obtain and release &quot;current&quot; status. One must balance every becomeCurrentWithPendingUnitCount() call with a resignCurrent() call, or Bad Things™ will happen. However, this pattern does not work well with Swift&#39;s error handling mechanism:<br>&gt; <br>&gt; progress.becomeCurrentWithPendingUnitCount(1)<br>&gt; try self.doSomeThingThatMightThrow()<br>&gt; progress.resignCurrent() // If an error occurs, this will never be called!<br></p><p>Yes, agreed. I would encourage the discrete progress if possible, but I’ve had lots of requests for a block-based version of becomeCurrent. This is another good reason to add one.<br></p><p>&gt; <br>&gt; 3. It is very easy to accidentally add a child NSProgress object if one does not realize that a particular method supports NSProgress. A couple ways this can happen:<br>&gt; <br>&gt; func doSomething() {<br>&gt;    let progress = NSProgress(totalUnitCount: 10)<br>&gt; <br>&gt;    progress.becomeCurrentWithPendingUnitCount(10)<br>&gt;    doSomethingThatSupportsNSProgress()<br>&gt;    doSomethingThatWeDontExpectSupportsNSProgressButDoes() // whoops, we just picked up a child accidentally<br>&gt;    progress.resignCurrent()<br>&gt; }<br>&gt; <br>&gt; func doSomething() {<br>&gt;    let progress = NSProgress(totalUnitCount: 10)<br>&gt; <br>&gt;    progress.becomeCurrentWithPendingUnitCount(10)<br>&gt;    doSomethingThatSupportsNSProgress()<br>&gt;    progress.resignCurrent()<br>&gt; <br>&gt;    doSomethingThatWeDontExpectSupportsNSProgressButDoes() // whoops, this one just picked up our parent&#39;s NSProgress and made it our sibling<br>&gt; }<br>&gt; <br>&gt; This is particularly problematic when you consider the obvious workaround for the problem described in #2:<br>&gt; <br>&gt; func doSomething() {<br>&gt;    let progress = NSProgress(totalUnitCount: 10)<br>&gt; <br>&gt;    progress.becomeCurrentWithPendingUnitCount(10)<br>&gt;    defer { progress.resignCurrent() }<br>&gt; <br>&gt;    doSomethingThatSupportsNSProgress()<br>&gt;    doSomethingThatWeDontExpectSupportsNSProgressButDoes() // whoops<br>&gt; }<br>&gt; <br>&gt; I haven&#39;t figured out exactly how to reproduce this reliably yet, but I have noticed that NSProgress objects can sometimes end up with a fractionCompleted larger than 1.0 when this occurs.<br></p><p>I changed the algorithm for how we add child progress objects, so now we only will add the first one. This wasn’t strictly backwards compatible, but it was far too easy to add more progress objects than you intended.<br></p><p>&gt; <br>&gt; 4. Because NSProgress uses a thread-local global variable for the current progress, one must be vigilant about jumping through specific hoops when spinning off a task in a new thread, or else the child task&#39;s NSProgress object will not be properly connected to its parent.<br>&gt; <br></p><p>Yup, again another problem solved by using the discrete progress objects.<br></p><p>&gt; 5. NSProgress posts KVO notifications on the main thread.<br></p><p>This actually isn’t true. NSProgress posts KVO notifications on the thread in which the change was made.<br></p><p>&gt; In addition to complicating the interface and causing undefined behavior if one mistakenly binds it to a UI element without inserting something in between to forward the KVO notifications to the main thread, this also hurts performance in the worker thread, since KVO notifications carry a non-trivial performance penalty, involving not only message sends but also packaging things into an NSDictionary for the &quot;change&quot; parameter. Notifications for multiple properties are fired every time completedUnitCount is changed, which then can cause similar KVO notifications to occur up the family tree, depending on how many KVO observers are installed. This can show up as a non-trivial performance cost in Instruments if the NSProgress object is updated frequently enough.<br>&gt; <br></p><p>There is a cost associated with updating progress, it’s true. We can always do more to optimize it (and we continue to do so), but there comes a point at which the updater of the progress object has to add some intelligence of its own. This is why the documentation and release notes encourage callers to avoid doing things like updating the progress for each byte in a file (because that is far too many updates).<br></p><p>- Tony<br></p><p>&gt; Proposed Solution:<br>&gt; <br>&gt; I propose a system that follows the example of Swift&#39;s excellent do/try/catch error-handling system. A &quot;reports&quot; keyword can be added to a function or method&#39;s declaration, similar to &quot;throws&quot;:<br>&gt; <br>&gt; func myFunc() reports -&gt; () {<br>&gt;    ...<br>&gt; }<br>&gt; <br>&gt; By default, the &quot;reports&quot; keyword will introduce a &quot;let&quot; constant named &quot;progress&quot; to the function&#39;s scope, much like &quot;catch&quot; implicitly adds &quot;error&quot;. The name of this constant could be customized, if desired:<br>&gt; <br>&gt; func myFunc() reports(myNiftyProgressObject) {<br>&gt;    ...<br>&gt; }<br>&gt; <br>&gt; The created progress object is automatically added as a child to the progress object which is implicitly passed into the function by the calling function or method.<br>&gt; <br>&gt; The interface to the progress object would be similar to NSProgress, with a &quot;prepare&quot; method taking the total unit count, as well as a &quot;cancelled&quot; property and a &quot;cancel()&quot; function helping keep track of whether or not an operation is cancelled. However, the &quot;becomeCurrent&quot; and &quot;resignCurrent&quot; methods are replaced with a &quot;report&quot; keyword which precedes a function or method call, similar to &quot;try&quot;, although the &quot;report&quot; keyword includes a parameter taking the number of units corresponding to this operation:<br>&gt; <br>&gt; func myFunc() throws, reports {<br>&gt;    progress.prepare(10)<br>&gt; <br>&gt;    report(5) foo()<br>&gt; <br>&gt;    if progress.cancelled { throw NSCocoaError.UserCancelledError }<br>&gt; <br>&gt;    report(5) try bar() // yes, &quot;report&quot; can be combined with &quot;try&quot;<br>&gt; }<br>&gt; <br>&gt; Spinning off an operation onto another thread or queue is no problem:<br>&gt; <br>&gt; func myFunc() reports {<br>&gt;    progress.prepare(10)<br>&gt; <br>&gt;    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)) {<br>&gt;        report(10) foo() // the progress object is passed as a parameter to the function, so no need to specially make it current on this thread first<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; Unlike &quot;try&quot;, &quot;report&quot; is not required. If we don&#39;t care about the progress of a method or function, we can call it without &quot;report&quot; and its progress will be ignored. In this example, the &quot;someRelativelyTrivialOperationThatReports&quot;&#39;s progress object will *not* be added as a child to &quot;progress&quot;:<br>&gt; <br>&gt; func myFunc() reports {<br>&gt;    progress.prepare(10)<br>&gt; <br>&gt;    someRelativelyTrivialOperationThatReports()<br>&gt;    report(10) someNonTrivialOperationThatReports()<br>&gt; }<br>&gt; <br>&gt; If a function calls only one reporting function, the &quot;prepare&quot; method can be omitted and the parameter can be left off of &quot;report&quot;, and the parent progress object will simply be passed through:<br>&gt; <br>&gt; func myFunc() reports {<br>&gt;    report doAllTheActualWork()<br>&gt; }<br>&gt; <br>&gt; To pass in a progress object other than the default progress object (for example, when creating the object at the very top of the tree), simply pass the progress object in as an optional second parameter to &quot;reports&quot;:<br>&gt; <br>&gt; func startEverything() {<br>&gt;    let progress = Progress()<br>&gt; <br>&gt;    progress.prepare(10)<br>&gt; <br>&gt;    report(10, progress) someFuncThatReports()<br>&gt; }<br>&gt; <br>&gt; In the function that does the actual work, of course the progress object has a &quot;completed&quot; property that tracks the completed units:<br>&gt; <br>&gt; func doTheActualWork() reports {<br>&gt;    let someArrayOfThings = ...<br>&gt; <br>&gt;    progress.prepare(someArrayOfThings.count)<br>&gt; <br>&gt;    for eachThing in someArrayOfThings {<br>&gt;        // do the work<br>&gt; <br>&gt;        progress.completed += 1<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; Observing the progress object uses a closure-based system, containing a &quot;willUpdateHandler&quot;, a &quot;didUpdateHandler&quot;, and a &quot;cancelHandler&quot;:<br>&gt; <br>&gt; progress.didUpdateHandler = { (completed: Int, total: Int) -&gt; () in<br>&gt;    print(&quot;\(completed) units complete out of \(total)&quot;)<br>&gt; }<br>&gt; <br>&gt; progress.cancelHandler = {<br>&gt;    print(&quot;the user cancelled the operation&quot;)<br>&gt; }<br>&gt; <br>&gt; The separation between will- and did- handlers is to facilitate interoperability with NSProgressIndicator and other Objective-C objects; one could call willChangeValueForKey() and didChangeValueForKey() in the handlers to let the KVO system know about the changes if needed. If desired, a small wrapper could be added to Foundation to translate the progress object&#39;s notifications into KVO notifications.<br>&gt; <br>&gt; The progress object also includes a property specifying the dispatch queue on which the handlers will be run. By default this is the main queue, but this can be customized as needed:<br>&gt; <br>&gt; progress.dispatchQueue = myDispatchQueue<br>&gt; <br>&gt; Of course, any changes to the &quot;completed&quot; property in a child progress object would be bubbled up the family tree, causing any handlers on the parent progress objects to fire, and any changes to the &quot;cancelled&quot; property in a parent progress object would be propagated to its children, similar to how NSProgress currently works.<br>&gt; <br>&gt; If there is interest in this, I could flesh out the interface and implementation to the progress object a bit.<br>&gt; <br>&gt; What do you all think?<br>&gt; <br>&gt; Charles<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160119/48b2580a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Pitch: Progress Tracking in Swift</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>January 19, 2016 at 05:00:00pm</p></header><div class="content"><p>On 2016-01-19 14:01, Tony Parker wrote:<br>&gt; Hi Charles,<br></p><p>Hi Tony,<br></p><p>Thanks very much for responding. I do really appreciate the opportunity <br>to communicate with members of the development team on these lists.<br></p><p>&gt; I see Rob already pointed this out, but I’ll respond as well since I<br>&gt; own NSProgress and I also was involved in the WWDC session he<br>&gt; references.<br>&gt; <br>&gt; NSProgress actually received a significant upgrade in iOS 9 and OS X<br>&gt; 10.11 to address most of your concerns. I’ve never really liked the<br>&gt; ‘current’ progress idea either, so I’ve changed Foundation to<br>&gt; make using explicit progress objects possible (and encouraged). There<br>&gt; are still cases where the idea of having a current progress is useful.<br>&gt; For example, when there is no opportunity to grab a progress object,<br>&gt; because the method you are calling is a proxy, or a global function,<br>&gt; etc.).<br></p><p>While this is true, I feel that the syntax for using it is quite <br>verbose, which feels out of place in Swift code. Mainly what it comes <br>down to, though, is that I actually rather like the concept behind what <br>they were trying to do with the &quot;current&quot; progress object, which was to <br>make it possible for all sorts of low-level methods and functions (like <br>-[NSData dataWithContentsOfURL:options:error:]) to automatically and <br>painlessly support progress operations, so that an application that was <br>doing time-consuming operations could get a lot of this &quot;for free.&quot; It&#39;s <br>just the *implementation* that I quibble with, due to various issues it <br>brings up. I feel like my pitch *works* like the explicit composition <br>method while *feeling* like the implicit composition method, if that <br>makes sense. At any rate, anything that would make progress more <br>attractive to implement, thus increasing its prevalence in the <br>frameworks, would be a plus; I would love to see something like <br>NSFileManager&#39;s file copy APIs supporting some sort of progress <br>reporting (in an extension, of course, unless we had some way for <br>Objective-C to call into the Swift progress-reporting mechanism). I also <br>feel like writing it in pure Swift and minimizing the amount of work <br>that is done on the current thread could reduce the performance costs of <br>using it, which is important for these sorts of APIs since you don&#39;t <br>want to add unnecessary overhead in the case where you&#39;re not interested <br>in monitoring the progress.<br></p><p>&gt; You can now create progress trees explicitly. There are two parts to<br>&gt; this:<br>&gt; <br>&gt;  @available(OSX 10.11, *)<br>&gt;  public /*not inherited*/ init(totalUnitCount unitCount: Int64,<br>&gt; parent: NSProgress, pendingUnitCount portionOfParentTotalUnitCount:<br>&gt; Int64)<br>&gt; <br>&gt; and a new protocol:<br>&gt; <br>&gt; public protocol NSProgressReporting : NSObjectProtocol {<br>&gt;  @available(OSX 10.9, *)<br>&gt;  public var progress: NSProgress { get }<br>&gt; }<br>&gt; <br>&gt; So you can mark classes that publish progress with the protocol, and<br>&gt; clients can create their trees using the new initializer.<br></p><p>This seems oriented toward classes such as NSOperation subclasses that <br>represent a singular operation of some sort, but doesn&#39;t seem as <br>applicable to single-function APIs like <br>NSFileManager.copyItemAtURL(toURL:). It can of course be used that way, <br>but it feels somewhat awkward. It also encourages the use of one big <br>monolithic NSProgress object for the whole operation/thread/dispatch <br>queue, which undermines some of what makes NSProgress so cool; the <br>tree-based approach is really great for complex operations which are <br>composed of a lot of separate steps, each of which may have distinct <br>sub-steps of their own.<br></p><p>&gt; Yes, agreed. I would encourage the discrete progress if possible, but<br>&gt; I’ve had lots of requests for a block-based version of<br>&gt; becomeCurrent. This is another good reason to add one.<br></p><p>I&#39;ve been using this rather simple one, which alleviates things quite a <br>bit:<br></p><p>(caveat: written from memory in Mail, as I&#39;m not at my main development <br>machine at the moment)<br></p><p>extension NSProgress {<br>     public func doWithPendingUnitCount&lt;T&gt;(unitCount: Int64, block: () <br>throws -&gt; T) rethrows -&gt; T {<br>         self.becomeCurrentWithPendingUnitCount(unitCount)<br>         defer { self.resignCurrent() }<br>         return try block()<br>     }<br>}<br></p><p>It does not, however, address the performance concerns, nor is it quite <br>as clean (IMO of course) as my suggestion.<br></p><p>&gt; I changed the algorithm for how we add child progress objects, so now<br>&gt; we only will add the first one. This wasn’t strictly backwards<br>&gt; compatible, but it was far too easy to add more progress objects than<br>&gt; you intended.<br></p><p>When did this change occur? I feel like I&#39;ve managed to get the <br>fractionCompleted to go over 1.0 this way on El Capitan, but don&#39;t <br>remember exactly how I did it. Good to know this is being worked on, <br>though; if I manage to get this to happen again, I&#39;ll file a Radar.<br></p><p>&gt;&gt; 5. NSProgress posts KVO notifications on the main thread.<br>&gt; <br>&gt; This actually isn’t true. NSProgress posts KVO notifications on the<br>&gt; thread in which the change was made.<br></p><p>As I mentioned in my followup post written a few minutes after the <br>original one, this was a typo (or, perhaps, a Freudian slip, since <br>posting on the main thread, or more generally on a dispatch queue <br>settable by the user, is what I wish it did). Sorry about that.<br></p><p>&gt;&gt; In addition to complicating the interface and causing undefined<br>&gt;&gt; behavior if one mistakenly binds it to a UI element without<br>&gt;&gt; inserting something in between to forward the KVO notifications to<br>&gt;&gt; the main thread, this also hurts performance in the worker thread,<br>&gt;&gt; since KVO notifications carry a non-trivial performance penalty,<br>&gt;&gt; involving not only message sends but also packaging things into an<br>&gt;&gt; NSDictionary for the &quot;change&quot; parameter. Notifications for multiple<br>&gt;&gt; properties are fired every time completedUnitCount is changed, which<br>&gt;&gt; then can cause similar KVO notifications to occur up the family<br>&gt;&gt; tree, depending on how many KVO observers are installed. This can<br>&gt;&gt; show up as a non-trivial performance cost in Instruments if the<br>&gt;&gt; NSProgress object is updated frequently enough.<br>&gt; <br>&gt; There is a cost associated with updating progress, it’s true. We can<br>&gt; always do more to optimize it (and we continue to do so), but there<br>&gt; comes a point at which the updater of the progress object has to add<br>&gt; some intelligence of its own. This is why the documentation and<br>&gt; release notes encourage callers to avoid doing things like updating<br>&gt; the progress for each byte in a file (because that is far too many<br>&gt; updates).<br></p><p>It seems to me that a lot of the work for this could be handled by the <br>progress object. Of course, you still wouldn&#39;t want to update after <br>every byte, but you wouldn&#39;t need to be nearly as vigilant as you do <br>currently. I also feel like it would be better for this to be in pure <br>Swift and to use mechanisms more performant than KVO, since by its very <br>nature this is an API that is intended to run in worker code, which is <br>where you really do care about performance. I realize of course the need <br>for NSProgress to exist, since a Swift-native solution would not be <br>available to pure Objective-C code, but moving forward it would be <br>really nice to have a Swift-native way to do this.<br></p><p>My ideal implementation for the progress objects would probably look <br>something like this:<br></p><p>- The progress object contains some simple integer and boolean <br>properties for the usual things: total units, completed units, and <br>cancelled.<br></p><p>- When one of these properties is changed, the change is propagated to <br>the parent progress for completed units, or to the children for <br>cancelled. This is the only real work that&#39;s done on the current thread.<br></p><p>- If and only if someone has set something for at least one of our <br>handlers:<br>     * Optionally: Check if we&#39;ve fired the handlers within some <br>threshold, either time based (only fire if we haven&#39;t fired in some <br>interval of time) or fraction-based (only fire if the fraction changed <br>has increased enough for us to care about the change), and exit if the <br>threshold hasn&#39;t been reached.<br>     * Fire any handlers that are non-nil, on the dispatch queue which we <br>have as a separate property (defaulting to the main thread). Calculated <br>properties such as fractionCompleted, localizedDescription (in its <br>default implementation), etc. are computed on the dispatch queue as <br>well, rather on the current thread.<br></p><p>This way, the overhead on the current thread when nothing&#39;s watching <br>would be limited to a few integer stores, which are fast in Swift, and <br>some nil checks. In the case where we have handlers, we add whatever it <br>costs to run dispatch_async (and some floating-point operations if we <br>implement the coalescing behavior). This should be much more performant <br>than all the dynamic lookups, message sends, change dictionary building, <br>multiple string operations (I&#39;m finding that the KVO notification for <br>localizedDescription seems to get called twice per change when I test <br>it, busting out NSNumberFormatter to rebuild the &quot;X% completed&quot; string <br>each time), and other overhead that we have now.<br></p><p>I could of course end up writing my own implementation, and I may end up <br>doing that. It would be nice to have something like this available as <br>part of the standard distribution, though.<br></p><p>Charles<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be4c3c3b76631a155e1358db48066692?s=50"></div><header><strong>Pitch: Progress Tracking in Swift</strong> from <string>Tony Parker</string> &lt;anthony.parker at apple.com&gt;<p>January 20, 2016 at 12:00:00pm</p></header><div class="content"><p>Hi Charles,<br></p><p>&gt; On Jan 19, 2016, at 2:24 PM, cocoadev at charlessoft.com wrote:<br>&gt; <br>&gt; On 2016-01-19 14:01, Tony Parker wrote:<br>&gt;&gt; Hi Charles,<br>&gt; <br>&gt; Hi Tony,<br>&gt; <br>&gt; Thanks very much for responding. I do really appreciate the opportunity to communicate with members of the development team on these lists.<br>&gt; <br></p><p>Sure, and thanks for your thoughts on this.<br></p><p>&gt;&gt; I see Rob already pointed this out, but I’ll respond as well since I<br>&gt;&gt; own NSProgress and I also was involved in the WWDC session he<br>&gt;&gt; references.<br>&gt;&gt; NSProgress actually received a significant upgrade in iOS 9 and OS X<br>&gt;&gt; 10.11 to address most of your concerns. I’ve never really liked the<br>&gt;&gt; ‘current’ progress idea either, so I’ve changed Foundation to<br>&gt;&gt; make using explicit progress objects possible (and encouraged). There<br>&gt;&gt; are still cases where the idea of having a current progress is useful.<br>&gt;&gt; For example, when there is no opportunity to grab a progress object,<br>&gt;&gt; because the method you are calling is a proxy, or a global function,<br>&gt;&gt; etc.).<br>&gt; <br>&gt; While this is true, I feel that the syntax for using it is quite verbose, which feels out of place in Swift code. Mainly what it comes down to, though, is that I actually rather like the concept behind what they were trying to do with the &quot;current&quot; progress object, which was to make it possible for all sorts of low-level methods and functions (like -[NSData dataWithContentsOfURL:options:error:]) to automatically and painlessly support progress operations, so that an application that was doing time-consuming operations could get a lot of this &quot;for free.&quot; It&#39;s just the *implementation* that I quibble with, due to various issues it brings up. I feel like my pitch *works* like the explicit composition method while *feeling* like the implicit composition method, if that makes sense. At any rate, anything that would make progress more attractive to implement, thus increasing its prevalence in the frameworks, would be a plus; I would love to see something like NSFileManager&#39;s file copy APIs supporting some sort of progress reporting (in an extension, of course, unless we had some way for Objective-C to call into the Swift progress-reporting mechanism). I also feel like writing it in pure Swift and minimizing the amount of work that is done on the current thread could reduce the performance costs of using it, which is important for these sorts of APIs since you don&#39;t want to add unnecessary overhead in the case where you&#39;re not interested in monitoring the progress.<br>&gt; <br>&gt;&gt; You can now create progress trees explicitly. There are two parts to<br>&gt;&gt; this:<br>&gt;&gt; @available(OSX 10.11, *)<br>&gt;&gt; public /*not inherited*/ init(totalUnitCount unitCount: Int64,<br>&gt;&gt; parent: NSProgress, pendingUnitCount portionOfParentTotalUnitCount:<br>&gt;&gt; Int64)<br>&gt;&gt; and a new protocol:<br>&gt;&gt; public protocol NSProgressReporting : NSObjectProtocol {<br>&gt;&gt; @available(OSX 10.9, *)<br>&gt;&gt; public var progress: NSProgress { get }<br>&gt;&gt; }<br>&gt;&gt; So you can mark classes that publish progress with the protocol, and<br>&gt;&gt; clients can create their trees using the new initializer.<br>&gt; <br>&gt; This seems oriented toward classes such as NSOperation subclasses that represent a singular operation of some sort, but doesn&#39;t seem as applicable to single-function APIs like NSFileManager.copyItemAtURL(toURL:). It can of course be used that way, but it feels somewhat awkward. It also encourages the use of one big monolithic NSProgress object for the whole operation/thread/dispatch queue, which undermines some of what makes NSProgress so cool; the tree-based approach is really great for complex operations which are composed of a lot of separate steps, each of which may have distinct sub-steps of their own.<br>&gt; <br></p><p>Yes, those cases are why we kept the ‘current’ idea around instead of deprecating it completely. Note that the discrete progress objects still totally embrace the composition pattern that NSProgress is all about. We went into some detail about this in the WWDC presentation.<br></p><p>&gt;&gt; Yes, agreed. I would encourage the discrete progress if possible, but<br>&gt;&gt; I’ve had lots of requests for a block-based version of<br>&gt;&gt; becomeCurrent. This is another good reason to add one.<br>&gt; <br>&gt; I&#39;ve been using this rather simple one, which alleviates things quite a bit:<br>&gt; <br>&gt; (caveat: written from memory in Mail, as I&#39;m not at my main development machine at the moment)<br>&gt; <br>&gt; extension NSProgress {<br>&gt;    public func doWithPendingUnitCount&lt;T&gt;(unitCount: Int64, block: () throws -&gt; T) rethrows -&gt; T {<br>&gt;        self.becomeCurrentWithPendingUnitCount(unitCount)<br>&gt;        defer { self.resignCurrent() }<br>&gt;        return try block()<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; It does not, however, address the performance concerns, nor is it quite as clean (IMO of course) as my suggestion.<br></p><p>I see you filed a bug for this - Thanks for that, and I’ll take it into consideration.<br></p><p>&gt; <br>&gt;&gt; I changed the algorithm for how we add child progress objects, so now<br>&gt;&gt; we only will add the first one. This wasn’t strictly backwards<br>&gt;&gt; compatible, but it was far too easy to add more progress objects than<br>&gt;&gt; you intended.<br>&gt; <br>&gt; When did this change occur? I feel like I&#39;ve managed to get the fractionCompleted to go over 1.0 this way on El Capitan, but don&#39;t remember exactly how I did it. Good to know this is being worked on, though; if I manage to get this to happen again, I&#39;ll file a Radar.<br></p><p>This change was made for 10.11 and 9.0.<br></p><p>&gt; <br>&gt;&gt;&gt; 5. NSProgress posts KVO notifications on the main thread.<br>&gt;&gt; This actually isn’t true. NSProgress posts KVO notifications on the<br>&gt;&gt; thread in which the change was made.<br>&gt; <br>&gt; As I mentioned in my followup post written a few minutes after the original one, this was a typo (or, perhaps, a Freudian slip, since posting on the main thread, or more generally on a dispatch queue settable by the user, is what I wish it did). Sorry about that.<br>&gt; <br>&gt;&gt;&gt; In addition to complicating the interface and causing undefined<br>&gt;&gt;&gt; behavior if one mistakenly binds it to a UI element without<br>&gt;&gt;&gt; inserting something in between to forward the KVO notifications to<br>&gt;&gt;&gt; the main thread, this also hurts performance in the worker thread,<br>&gt;&gt;&gt; since KVO notifications carry a non-trivial performance penalty,<br>&gt;&gt;&gt; involving not only message sends but also packaging things into an<br>&gt;&gt;&gt; NSDictionary for the &quot;change&quot; parameter. Notifications for multiple<br>&gt;&gt;&gt; properties are fired every time completedUnitCount is changed, which<br>&gt;&gt;&gt; then can cause similar KVO notifications to occur up the family<br>&gt;&gt;&gt; tree, depending on how many KVO observers are installed. This can<br>&gt;&gt;&gt; show up as a non-trivial performance cost in Instruments if the<br>&gt;&gt;&gt; NSProgress object is updated frequently enough.<br>&gt;&gt; There is a cost associated with updating progress, it’s true. We can<br>&gt;&gt; always do more to optimize it (and we continue to do so), but there<br>&gt;&gt; comes a point at which the updater of the progress object has to add<br>&gt;&gt; some intelligence of its own. This is why the documentation and<br>&gt;&gt; release notes encourage callers to avoid doing things like updating<br>&gt;&gt; the progress for each byte in a file (because that is far too many<br>&gt;&gt; updates).<br>&gt; <br>&gt; It seems to me that a lot of the work for this could be handled by the progress object. Of course, you still wouldn&#39;t want to update after every byte, but you wouldn&#39;t need to be nearly as vigilant as you do currently. I also feel like it would be better for this to be in pure Swift and to use mechanisms more performant than KVO, since by its very nature this is an API that is intended to run in worker code, which is where you really do care about performance. I realize of course the need for NSProgress to exist, since a Swift-native solution would not be available to pure Objective-C code, but moving forward it would be really nice to have a Swift-native way to do this.<br>&gt; <br>&gt; My ideal implementation for the progress objects would probably look something like this:<br>&gt; <br>&gt; - The progress object contains some simple integer and boolean properties for the usual things: total units, completed units, and cancelled.<br>&gt; <br>&gt; - When one of these properties is changed, the change is propagated to the parent progress for completed units, or to the children for cancelled. This is the only real work that&#39;s done on the current thread.<br>&gt; <br>&gt; - If and only if someone has set something for at least one of our handlers:<br>&gt;    * Optionally: Check if we&#39;ve fired the handlers within some threshold, either time based (only fire if we haven&#39;t fired in some interval of time) or fraction-based (only fire if the fraction changed has increased enough for us to care about the change), and exit if the threshold hasn&#39;t been reached.<br>&gt;    * Fire any handlers that are non-nil, on the dispatch queue which we have as a separate property (defaulting to the main thread). Calculated properties such as fractionCompleted, localizedDescription (in its default implementation), etc. are computed on the dispatch queue as well, rather on the current thread.<br>&gt; <br>&gt; This way, the overhead on the current thread when nothing&#39;s watching would be limited to a few integer stores, which are fast in Swift, and some nil checks. In the case where we have handlers, we add whatever it costs to run dispatch_async (and some floating-point operations if we implement the coalescing behavior). This should be much more performant than all the dynamic lookups, message sends, change dictionary building, multiple string operations (I&#39;m finding that the KVO notification for localizedDescription seems to get called twice per change when I test it, busting out NSNumberFormatter to rebuild the &quot;X% completed&quot; string each time), and other overhead that we have now.<br>&gt; <br>&gt; I could of course end up writing my own implementation, and I may end up doing that. It would be nice to have something like this available as part of the standard distribution, though.<br>&gt; <br>&gt; Charles<br>&gt; <br></p><p>NSProgress actually has some throttling in place for cross-process progress, and I’ve found it to be very tricky to get right. As far as dropping notifications on the floor, you have to be careful that they aren’t the ones that certain clients care a lot about (e.g., getting to 100% finished). If attempting to limit it to a certain percentage, remember that any given progress object’s idea of a significant percentage may be an insignificant one for the parent progress object - and therefore too frequent. Some clients may really want every progress update and some will want it limited to something like 60Hz.<br></p><p>I don’t think anything about this problem is going to be solved by simply reimplementing the entire thing in Swift. Ditching KVO may seem like a way to increase performance, but then you have to think about the global picture - how is anyone supposed to know when the progress has been updated? You will likely have to invent a different notification mechanism to replace it. At that point you’ve reinvented a chunk of KVO itself instead of focusing on the primary domain of progress reporting. Plus, the notification mechanism we’ve invented is specific to NSProgress and not general enough to plug into other systems effectively.<br></p><p>- Tony<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Pitch: Progress Tracking in Swift</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>January 20, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jan 20, 2016, at 2:16 PM, Tony Parker &lt;anthony.parker at apple.com&gt; wrote:<br>&gt; <br>&gt; NSProgress actually has some throttling in place for cross-process progress, and I’ve found it to be very tricky to get right. As far as dropping notifications on the floor, you have to be careful that they aren’t the ones that certain clients care a lot about (e.g., getting to 100% finished). If attempting to limit it to a certain percentage, remember that any given progress object’s idea of a significant percentage may be an insignificant one for the parent progress object - and therefore too frequent. Some clients may really want every progress update and some will want it limited to something like 60Hz.<br></p><p>My thinking about it is that what the child process considers important doesn’t really matter, because it’s the progress object at the root of the tree that’s going to have listeners on it. When the child progress objects are updated, they will bubble their changes up the tree to the root object, and only there, where the notification handlers are registered. Any coalescing would be done in the code that calls the handlers, and thus, in the common case, in the root object.<br></p><p>The coalescing idea was just an idle thought, however; that’s part of the idea that I haven’t fleshed out yet. It shouldn’t be considered as essential to the idea (which is why I prefaced it with “Optional” in the description of it). If a good implementation of it could be found, though, it could be pretty useful, to clean up and streamline the worker code by removing a bunch of boilerplate that’s not directly related to the work it’s doing.<br></p><p>&gt; I don’t think anything about this problem is going to be solved by simply reimplementing the entire thing in Swift. Ditching KVO may seem like a way to increase performance, but then you have to think about the global picture - how is anyone supposed to know when the progress has been updated? You will likely have to invent a different notification mechanism to replace it. At that point you’ve reinvented a chunk of KVO itself instead of focusing on the primary domain of progress reporting. Plus, the notification mechanism we’ve invented is specific to NSProgress and not general enough to plug into other systems effectively.<br></p><p>The Swift way to handle notifications would be simply to have the user register a closure with the progress object. I was thinking putting a few closure properties on the object, called things like progressHandler, cancellationHandler, and so on. These closures could do whatever the developer asks them to; they could update UI elements, send KVO notifications, update a property on some other object that’s bound to a UI element, etc.<br></p><p>KVO has its uses, to be sure; it&#39;s great for wiring things up to Interface Builder objects, for instance. However, that advantage is gone in the case of NSProgress, since the notifications don’t fire on the main thread. It’s not safe to update a view object on a secondary thread, making it unsafe to bind something like an NSProgressIndicator directly to a property on NSProgress; you have to use KVO’s awkward observation API in code to catch the notifications and forward them on to the main thread. Meanwhile, the non-trivial costs of KVO are accruing on the worker thread, slowing things down (including things like string ops to calculate properties such as localizedDescription). If things were set up such that the KVO notifications always occurred on the main thread, the value of using KVO here would be obvious, but as it’s implemented, there’s not much benefit to the KVO approach; it&#39;s just the wrong tool for the job. All IMO of course.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160120/c8c929f6/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
