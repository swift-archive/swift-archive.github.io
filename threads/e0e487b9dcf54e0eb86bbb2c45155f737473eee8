<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>February 11, 2016 at 10:00:00pm</p></header><div class="content"><p>on Thu Feb 11 2016, Xiaodi Wu &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Thu, Feb 11, 2016 at 7:31 PM, Dave Abrahams via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; on Thu Feb 11 2016, Jarod Long &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;&gt; On Feb 11, 2016, at 15:20, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;<br>&gt;&gt;&gt;&gt;&gt; On Feb 11, 2016, at 4:17 PM, Dave Abrahams<br>&gt;&gt;&gt;&gt;&gt; &lt;dabrahams at apple.com<br>&gt;&gt;&gt;&gt;&gt; &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; For the record, I do not feel at all confident anything like this will<br>&gt;&gt;&gt;&gt;&gt; end up in swift.  This feature was proposed back in 2013, before Swift<br>&gt;&gt;&gt;&gt;&gt; was released, eventually accepted then not implemented because we were<br>&gt;&gt;&gt;&gt;&gt; out of time, then revised, then re-accepted and implemented, then ripped<br>&gt;&gt;&gt;&gt;&gt; out of the compiler because of various concerns about what it does to<br>&gt;&gt;&gt;&gt;&gt; the shape of the language (e.g. is this just a second version of<br>&gt;&gt;&gt;&gt;&gt; “mutating?”  What about classes?).  Based on history, I don&#39;t think it&#39;s<br>&gt;&gt;&gt;&gt;&gt; a sure bet, and I personally may be out of energy and time to fight for<br>&gt;&gt;&gt;&gt;&gt; it.  But we&#39;ll have to see...<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Interesting -- I wasn&#39;t aware of the history of the proposal. I would<br>&gt;&gt;&gt; be very interested in revisiting it to get the consideration of the<br>&gt;&gt;&gt; larger Swift community. Is this something that would be reasonable in<br>&gt;&gt;&gt; the Swift 3 timeframe, or should this wait until we can discuss Swift<br>&gt;&gt;&gt; 4?<br>&gt;&gt;<br>&gt;&gt; Realistically, I think that proposal cannot be considered for Swift 3.<br>&gt;<br>&gt; Understandable. FWIW, if one believes in autocomplete, superscript<br>&gt; equal sign is already a valid identifier head character (per<br>&gt; documentation and experimentation in a playground). So, if the gist of<br>&gt; the proposal is acceptable, one can already name a pair of functions<br>&gt; union() and union=() if the &quot;=&quot; is replaced with its superscript (and<br>&gt; for that matter, =union(), but autocomplete might not help with that<br>&gt; one). <br></p><p>Hmm, use the fullwidth equal sign; it reads better, and compiles:<br></p><p>  mutating func ＝union(other: Self) { ... }<br></p><p>Heh, that is awesome; we could do some real fun proofs-of-concept for<br>the proposal using that trick.  The autocomplete problem can/should be<br>fixed by tooling.<br></p><p>&gt; Not sure this idea will gain too much traction, but if the union<br>&gt; operator ∪ is being thrown out as a possibility, I thought I&#39;d put it<br>&gt; out there.<br></p><p>I think the biggest obstacle to the operator ∪ by itself is that it&#39;s<br>hard to type, and autocomplete doesn&#39;t have any ordinary ASCII<br>characters to work with.  At least with ＝union, “u n i&lt;TAB&gt;” could be<br>made to find it.<br></p><p>&gt; In terms of symbols easily accessible on the keyboard not reserved for<br>&gt; operators, Xcode doesn&#39;t seem to complain about a function named<br>&gt; union$(), but that is a pretty bizarre-looking function name. More<br>&gt; horrifying than unioning() though?<br></p><p>Eye of the beholder, apparently.<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>February 11, 2016 at 10:00:00pm</p></header><div class="content"><p>on Thu Feb 11 2016, Dave Abrahams &lt;swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org&gt; wrote:<br></p><p>&gt; Heh, that is awesome; we could do some real fun proofs-of-concept for<br>&gt; the proposal using that trick.  The autocomplete problem can/should be<br>&gt; fixed by tooling.<br></p><p>In the attached, try typing &quot;x.unio&quot; and then hitting backspace :-)<br></p><p>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: Inplace.playground.zip<br>Type: application/zip<br>Size: 7312 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/4bb14fb9/attachment.zip&gt;<br>-------------- next part --------------<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>February 12, 2016 at 01:00:00am</p></header><div class="content"><p>No luck for me with Xcode 7.2.1. If I use the function once, then I<br>have it highlighted the next time I type &quot;x.&quot;, but &quot;x.unio^H&quot; or<br>&quot;x.unio^H^H^H^H&quot; don&#39;t seem to do it :/ Still, that&#39;s something that&#39;s<br>solvable...<br></p><p>Fullwidth equal sign certainly reads better; I mentioned superscript<br>partly because the line spacing gets thrown off in Xcode when bringing<br>in a fullwidth character and the jumping lines were starting to bother<br>me. Again, solvable...<br></p><p><br>On Fri, Feb 12, 2016 at 12:26 AM, Dave Abrahams via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; on Thu Feb 11 2016, Dave Abrahams &lt;swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org&gt; wrote:<br>&gt;<br>&gt;&gt; Heh, that is awesome; we could do some real fun proofs-of-concept for<br>&gt;&gt; the proposal using that trick.  The autocomplete problem can/should be<br>&gt;&gt; fixed by tooling.<br>&gt;<br>&gt; In the attached, try typing &quot;x.unio&quot; and then hitting backspace :-)<br>&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; -Dave<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>February 11, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Feb 11, 2016, at 10:05 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; on Thu Feb 11 2016, Xiaodi Wu &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Understandable. FWIW, if one believes in autocomplete, superscript<br>&gt;&gt; equal sign is already a valid identifier head character (per<br>&gt;&gt; documentation and experimentation in a playground). So, if the gist of<br>&gt;&gt; the proposal is acceptable, one can already name a pair of functions<br>&gt;&gt; union() and union=() if the &quot;=&quot; is replaced with its superscript (and<br>&gt;&gt; for that matter, =union(), but autocomplete might not help with that<br>&gt;&gt; one). <br>&gt; <br>&gt; Hmm, use the fullwidth equal sign; it reads better, and compiles:<br>&gt; <br>&gt;  mutating func ＝union(other: Self) { ... }<br>&gt; <br>&gt; Heh, that is awesome; we could do some real fun proofs-of-concept for<br>&gt; the proposal using that trick.  The autocomplete problem can/should be<br>&gt; fixed by tooling.<br></p><p>Now y&#39;all are approaching the syntax of a proposal I made long ago for a .= operator. Here&#39;s what I wrote then (with a handful of syntax updates).<br></p><p>&quot;<br></p><p>I suggest eliminating &quot;…InPlace&quot; as follows:<br>1. Use the same method name for value-creating methods and in-place mutation methods. No &quot;…InPlace&quot; suffix.<br>2. Write all client code syntactically as if the in-place implementations did not exist. Rely on the compiler to choose the in-place implementation when possible.<br>3. Add a new operator .= for in-place modification, to shorten the &quot;expr = expr.method()&quot; case.<br></p><p><br>1. Use the same method name for value-creating methods and in-place mutation methods<br></p><p>struct String {<br>   func upper() -&gt; String { ... }  // value-creating / out-of-place implementation<br>   @inplace func upper() { ... }   // in-place implementation<br>}<br></p><p>struct String2 {<br>   @inplace func upper() { ... }   // in-place implementation<br>}<br></p><p>The value-creating implementation is optional. If it is not present, the compiler will generate a default value-creating implementation that copies the object and calls the in-place implementation. There is no default in-place implementation; if there is no in-place implementation of a value-creating method then the compiler simply fails to optimize to it.<br></p><p><br>2. Write all client code syntactically as if the in-place implementations did not exist.<br></p><p>Instead of this<br>   s.upperInPlace()<br>write this<br>   s = s.upper()<br></p><p>The compiler optimizer can choose the in-place upper() implementation if it is present.<br></p><p>Instead of this <br>   t = s.upper().trim().truncate(toLength: 5)                // oops, there&#39;s an extra copy here<br>   t = s.upper().trimInPlace().truncateInPlace(toLength: 5)  // oops, compile error<br>write this<br>   t = s.upper().trim().truncate(toLength: 5)<br></p><p>The developer can chain methods together and let the compiler optimizer choose which in-place implementations to use. In this case, if all in-place implementations are available, it should call value-creating upper() followed by in-place trim() and in-place truncate(toLength:).<br></p><p><br>3. Add operator .= for in-place modification.<br></p><p>Operator .= is analogous to arithmetic operators like += . It is shorthand for `expr = expr.stuff` for the case where `expr` is inconveniently long. (It also doesn&#39;t evaluate `expr` twice, if Swift&#39;s optimization rules otherwise would allow it or require it for the longhand case.)<br></p><p>s .= upper()  <br>// like s = s.upper()<br></p><p>p .= next<br>// like p = p.next<br></p><p>some().long().expression .= upper().trim().truncateToLength(5)<br>// like some().long().expression = some().long().expression.upper().trim().truncateToLength(5)<br></p><p>As seen in this last example, one advantage of this syntax is that it allows chained mutations but cleanly separates the &quot;lookup&quot; calls from the &quot;mutate&quot; calls. This is an improvement upon language and API designs with mutating methods where the property being changed is buried in the middle of the expression somewhere.<br></p><p>some().long().expression.upperInPlace().trimInPlace().truncateInPlace(toLength: 5)<br>some().long().expression().upper.trimInPlace().truncateInPlace(toLength: 5)<br></p><p>some().long().expression .= upper().trim().truncate(toLength: 5)<br>some().long().expression().upper .= trim().truncate(toLength: 5)<br></p><p><br>One consequence of these changes is that compiler optimizations to take advantage of in-place implementation are much more important for performance, because there isn&#39;t any syntax to call the in-place implementation directly.<br></p><p>&quot;<br></p><p><br>-- <br>Greg Parker     gparker at apple.com     Runtime Wrangler<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>February 12, 2016 at 01:00:00am</p></header><div class="content"><p>I could get behind that. At the call site there would be little<br>visible difference between this and the alternative where functions<br>beginning with &quot;=&quot; are allowed. One I can think of would be that the<br>`.=` operator would require some instances (of classes that have<br>properties that are reference types) declared with `let` to be<br>declared with `var`.<br></p><p><br>On Fri, Feb 12, 2016 at 1:26 AM, Greg Parker via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; On Feb 11, 2016, at 10:05 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; on Thu Feb 11 2016, Xiaodi Wu &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Understandable. FWIW, if one believes in autocomplete, superscript<br>&gt;&gt;&gt; equal sign is already a valid identifier head character (per<br>&gt;&gt;&gt; documentation and experimentation in a playground). So, if the gist of<br>&gt;&gt;&gt; the proposal is acceptable, one can already name a pair of functions<br>&gt;&gt;&gt; union() and union=() if the &quot;=&quot; is replaced with its superscript (and<br>&gt;&gt;&gt; for that matter, =union(), but autocomplete might not help with that<br>&gt;&gt;&gt; one).<br>&gt;&gt;<br>&gt;&gt; Hmm, use the fullwidth equal sign; it reads better, and compiles:<br>&gt;&gt;<br>&gt;&gt;  mutating func ＝union(other: Self) { ... }<br>&gt;&gt;<br>&gt;&gt; Heh, that is awesome; we could do some real fun proofs-of-concept for<br>&gt;&gt; the proposal using that trick.  The autocomplete problem can/should be<br>&gt;&gt; fixed by tooling.<br>&gt;<br>&gt; Now y&#39;all are approaching the syntax of a proposal I made long ago for a .= operator. Here&#39;s what I wrote then (with a handful of syntax updates).<br>&gt;<br>&gt; &quot;<br>&gt;<br>&gt; I suggest eliminating &quot;…InPlace&quot; as follows:<br>&gt; 1. Use the same method name for value-creating methods and in-place mutation methods. No &quot;…InPlace&quot; suffix.<br>&gt; 2. Write all client code syntactically as if the in-place implementations did not exist. Rely on the compiler to choose the in-place implementation when possible.<br>&gt; 3. Add a new operator .= for in-place modification, to shorten the &quot;expr = expr.method()&quot; case.<br>&gt;<br>&gt;<br>&gt; 1. Use the same method name for value-creating methods and in-place mutation methods<br>&gt;<br>&gt; struct String {<br>&gt;    func upper() -&gt; String { ... }  // value-creating / out-of-place implementation<br>&gt;    @inplace func upper() { ... }   // in-place implementation<br>&gt; }<br>&gt;<br>&gt; struct String2 {<br>&gt;    @inplace func upper() { ... }   // in-place implementation<br>&gt; }<br>&gt;<br>&gt; The value-creating implementation is optional. If it is not present, the compiler will generate a default value-creating implementation that copies the object and calls the in-place implementation. There is no default in-place implementation; if there is no in-place implementation of a value-creating method then the compiler simply fails to optimize to it.<br>&gt;<br>&gt;<br>&gt; 2. Write all client code syntactically as if the in-place implementations did not exist.<br>&gt;<br>&gt; Instead of this<br>&gt;    s.upperInPlace()<br>&gt; write this<br>&gt;    s = s.upper()<br>&gt;<br>&gt; The compiler optimizer can choose the in-place upper() implementation if it is present.<br>&gt;<br>&gt; Instead of this<br>&gt;    t = s.upper().trim().truncate(toLength: 5)                // oops, there&#39;s an extra copy here<br>&gt;    t = s.upper().trimInPlace().truncateInPlace(toLength: 5)  // oops, compile error<br>&gt; write this<br>&gt;    t = s.upper().trim().truncate(toLength: 5)<br>&gt;<br>&gt; The developer can chain methods together and let the compiler optimizer choose which in-place implementations to use. In this case, if all in-place implementations are available, it should call value-creating upper() followed by in-place trim() and in-place truncate(toLength:).<br>&gt;<br>&gt;<br>&gt; 3. Add operator .= for in-place modification.<br>&gt;<br>&gt; Operator .= is analogous to arithmetic operators like += . It is shorthand for `expr = expr.stuff` for the case where `expr` is inconveniently long. (It also doesn&#39;t evaluate `expr` twice, if Swift&#39;s optimization rules otherwise would allow it or require it for the longhand case.)<br>&gt;<br>&gt; s .= upper()<br>&gt; // like s = s.upper()<br>&gt;<br>&gt; p .= next<br>&gt; // like p = p.next<br>&gt;<br>&gt; some().long().expression .= upper().trim().truncateToLength(5)<br>&gt; // like some().long().expression = some().long().expression.upper().trim().truncateToLength(5)<br>&gt;<br>&gt; As seen in this last example, one advantage of this syntax is that it allows chained mutations but cleanly separates the &quot;lookup&quot; calls from the &quot;mutate&quot; calls. This is an improvement upon language and API designs with mutating methods where the property being changed is buried in the middle of the expression somewhere.<br>&gt;<br>&gt; some().long().expression.upperInPlace().trimInPlace().truncateInPlace(toLength: 5)<br>&gt; some().long().expression().upper.trimInPlace().truncateInPlace(toLength: 5)<br>&gt;<br>&gt; some().long().expression .= upper().trim().truncate(toLength: 5)<br>&gt; some().long().expression().upper .= trim().truncate(toLength: 5)<br>&gt;<br>&gt;<br>&gt; One consequence of these changes is that compiler optimizations to take advantage of in-place implementation are much more important for performance, because there isn&#39;t any syntax to call the in-place implementation directly.<br>&gt;<br>&gt; &quot;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Greg Parker     gparker at apple.com     Runtime Wrangler<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7b4f0271043628eecd950f1e3cdd1a84?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at googlemail.com&gt;<p>February 12, 2016 at 12:00:00pm</p></header><div class="content"><p>IMO, using the converb/gerund/participle (whatever you call it) here is a terrible idea (I say that as someone with a PhD in linguistics :) ). It appears very counter-intuitive to me that ‘union’ should be the in-place version, as it goes agains any convention I am aware of.  I’d rather just keep InPlace here or, as Greg suggests, rely on compiler optimisations.<br></p><p>— Taras<br></p><p>&gt; On 12 Feb 2016, at 08:43, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I could get behind that. At the call site there would be little<br>&gt; visible difference between this and the alternative where functions<br>&gt; beginning with &quot;=&quot; are allowed. One I can think of would be that the<br>&gt; `.=` operator would require some instances (of classes that have<br>&gt; properties that are reference types) declared with `let` to be<br>&gt; declared with `var`.<br>&gt; <br>&gt; <br>&gt; On Fri, Feb 12, 2016 at 1:26 AM, Greg Parker via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 11, 2016, at 10:05 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Thu Feb 11 2016, Xiaodi Wu &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Understandable. FWIW, if one believes in autocomplete, superscript<br>&gt;&gt;&gt;&gt; equal sign is already a valid identifier head character (per<br>&gt;&gt;&gt;&gt; documentation and experimentation in a playground). So, if the gist of<br>&gt;&gt;&gt;&gt; the proposal is acceptable, one can already name a pair of functions<br>&gt;&gt;&gt;&gt; union() and union=() if the &quot;=&quot; is replaced with its superscript (and<br>&gt;&gt;&gt;&gt; for that matter, =union(), but autocomplete might not help with that<br>&gt;&gt;&gt;&gt; one).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hmm, use the fullwidth equal sign; it reads better, and compiles:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; mutating func ＝union(other: Self) { ... }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Heh, that is awesome; we could do some real fun proofs-of-concept for<br>&gt;&gt;&gt; the proposal using that trick.  The autocomplete problem can/should be<br>&gt;&gt;&gt; fixed by tooling.<br>&gt;&gt; <br>&gt;&gt; Now y&#39;all are approaching the syntax of a proposal I made long ago for a .= operator. Here&#39;s what I wrote then (with a handful of syntax updates).<br>&gt;&gt; <br>&gt;&gt; &quot;<br>&gt;&gt; <br>&gt;&gt; I suggest eliminating &quot;…InPlace&quot; as follows:<br>&gt;&gt; 1. Use the same method name for value-creating methods and in-place mutation methods. No &quot;…InPlace&quot; suffix.<br>&gt;&gt; 2. Write all client code syntactically as if the in-place implementations did not exist. Rely on the compiler to choose the in-place implementation when possible.<br>&gt;&gt; 3. Add a new operator .= for in-place modification, to shorten the &quot;expr = expr.method()&quot; case.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; 1. Use the same method name for value-creating methods and in-place mutation methods<br>&gt;&gt; <br>&gt;&gt; struct String {<br>&gt;&gt;   func upper() -&gt; String { ... }  // value-creating / out-of-place implementation<br>&gt;&gt;   @inplace func upper() { ... }   // in-place implementation<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct String2 {<br>&gt;&gt;   @inplace func upper() { ... }   // in-place implementation<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; The value-creating implementation is optional. If it is not present, the compiler will generate a default value-creating implementation that copies the object and calls the in-place implementation. There is no default in-place implementation; if there is no in-place implementation of a value-creating method then the compiler simply fails to optimize to it.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; 2. Write all client code syntactically as if the in-place implementations did not exist.<br>&gt;&gt; <br>&gt;&gt; Instead of this<br>&gt;&gt;   s.upperInPlace()<br>&gt;&gt; write this<br>&gt;&gt;   s = s.upper()<br>&gt;&gt; <br>&gt;&gt; The compiler optimizer can choose the in-place upper() implementation if it is present.<br>&gt;&gt; <br>&gt;&gt; Instead of this<br>&gt;&gt;   t = s.upper().trim().truncate(toLength: 5)                // oops, there&#39;s an extra copy here<br>&gt;&gt;   t = s.upper().trimInPlace().truncateInPlace(toLength: 5)  // oops, compile error<br>&gt;&gt; write this<br>&gt;&gt;   t = s.upper().trim().truncate(toLength: 5)<br>&gt;&gt; <br>&gt;&gt; The developer can chain methods together and let the compiler optimizer choose which in-place implementations to use. In this case, if all in-place implementations are available, it should call value-creating upper() followed by in-place trim() and in-place truncate(toLength:).<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; 3. Add operator .= for in-place modification.<br>&gt;&gt; <br>&gt;&gt; Operator .= is analogous to arithmetic operators like += . It is shorthand for `expr = expr.stuff` for the case where `expr` is inconveniently long. (It also doesn&#39;t evaluate `expr` twice, if Swift&#39;s optimization rules otherwise would allow it or require it for the longhand case.)<br>&gt;&gt; <br>&gt;&gt; s .= upper()<br>&gt;&gt; // like s = s.upper()<br>&gt;&gt; <br>&gt;&gt; p .= next<br>&gt;&gt; // like p = p.next<br>&gt;&gt; <br>&gt;&gt; some().long().expression .= upper().trim().truncateToLength(5)<br>&gt;&gt; // like some().long().expression = some().long().expression.upper().trim().truncateToLength(5)<br>&gt;&gt; <br>&gt;&gt; As seen in this last example, one advantage of this syntax is that it allows chained mutations but cleanly separates the &quot;lookup&quot; calls from the &quot;mutate&quot; calls. This is an improvement upon language and API designs with mutating methods where the property being changed is buried in the middle of the expression somewhere.<br>&gt;&gt; <br>&gt;&gt; some().long().expression.upperInPlace().trimInPlace().truncateInPlace(toLength: 5)<br>&gt;&gt; some().long().expression().upper.trimInPlace().truncateInPlace(toLength: 5)<br>&gt;&gt; <br>&gt;&gt; some().long().expression .= upper().trim().truncate(toLength: 5)<br>&gt;&gt; some().long().expression().upper .= trim().truncate(toLength: 5)<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; One consequence of these changes is that compiler optimizations to take advantage of in-place implementation are much more important for performance, because there isn&#39;t any syntax to call the in-place implementation directly.<br>&gt;&gt; <br>&gt;&gt; &quot;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; Greg Parker     gparker at apple.com     Runtime Wrangler<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>February 12, 2016 at 08:00:00am</p></header><div class="content"><p>+1 to this direction. This is correct version of what I was alluding with my ill-thougthout post from last night.<br></p><p>I&#39;m not 100% convinced on the `.=` operator, but I really like the rest.<br></p><p>This would seem like a good win for updates to libraries as well. A library vendor could add an `@inplace` version, and your code could get better performance without changing your API surface.<br></p><p>Also, to me, it has a nice conceptual parity to copy-on-write semantics. <br></p><p>-David<br></p><p><br>&gt; On Feb 11, 2016, at 11:26 PM, Greg Parker via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 11, 2016, at 10:05 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; on Thu Feb 11 2016, Xiaodi Wu &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Understandable. FWIW, if one believes in autocomplete, superscript<br>&gt;&gt;&gt; equal sign is already a valid identifier head character (per<br>&gt;&gt;&gt; documentation and experimentation in a playground). So, if the gist of<br>&gt;&gt;&gt; the proposal is acceptable, one can already name a pair of functions<br>&gt;&gt;&gt; union() and union=() if the &quot;=&quot; is replaced with its superscript (and<br>&gt;&gt;&gt; for that matter, =union(), but autocomplete might not help with that<br>&gt;&gt;&gt; one). <br>&gt;&gt; <br>&gt;&gt; Hmm, use the fullwidth equal sign; it reads better, and compiles:<br>&gt;&gt; <br>&gt;&gt; mutating func ＝union(other: Self) { ... }<br>&gt;&gt; <br>&gt;&gt; Heh, that is awesome; we could do some real fun proofs-of-concept for<br>&gt;&gt; the proposal using that trick.  The autocomplete problem can/should be<br>&gt;&gt; fixed by tooling.<br>&gt; <br>&gt; Now y&#39;all are approaching the syntax of a proposal I made long ago for a .= operator. Here&#39;s what I wrote then (with a handful of syntax updates).<br>&gt; <br>&gt; &quot;<br>&gt; <br>&gt; I suggest eliminating &quot;…InPlace&quot; as follows:<br>&gt; 1. Use the same method name for value-creating methods and in-place mutation methods. No &quot;…InPlace&quot; suffix.<br>&gt; 2. Write all client code syntactically as if the in-place implementations did not exist. Rely on the compiler to choose the in-place implementation when possible.<br>&gt; 3. Add a new operator .= for in-place modification, to shorten the &quot;expr = expr.method()&quot; case.<br>&gt; <br>&gt; <br>&gt; 1. Use the same method name for value-creating methods and in-place mutation methods<br>&gt; <br>&gt; struct String {<br>&gt;   func upper() -&gt; String { ... }  // value-creating / out-of-place implementation<br>&gt;   @inplace func upper() { ... }   // in-place implementation<br>&gt; }<br>&gt; <br>&gt; struct String2 {<br>&gt;   @inplace func upper() { ... }   // in-place implementation<br>&gt; }<br>&gt; <br>&gt; The value-creating implementation is optional. If it is not present, the compiler will generate a default value-creating implementation that copies the object and calls the in-place implementation. There is no default in-place implementation; if there is no in-place implementation of a value-creating method then the compiler simply fails to optimize to it.<br>&gt; <br>&gt; <br>&gt; 2. Write all client code syntactically as if the in-place implementations did not exist.<br>&gt; <br>&gt; Instead of this<br>&gt;   s.upperInPlace()<br>&gt; write this<br>&gt;   s = s.upper()<br>&gt; <br>&gt; The compiler optimizer can choose the in-place upper() implementation if it is present.<br>&gt; <br>&gt; Instead of this <br>&gt;   t = s.upper().trim().truncate(toLength: 5)                // oops, there&#39;s an extra copy here<br>&gt;   t = s.upper().trimInPlace().truncateInPlace(toLength: 5)  // oops, compile error<br>&gt; write this<br>&gt;   t = s.upper().trim().truncate(toLength: 5)<br>&gt; <br>&gt; The developer can chain methods together and let the compiler optimizer choose which in-place implementations to use. In this case, if all in-place implementations are available, it should call value-creating upper() followed by in-place trim() and in-place truncate(toLength:).<br>&gt; <br>&gt; <br>&gt; 3. Add operator .= for in-place modification.<br>&gt; <br>&gt; Operator .= is analogous to arithmetic operators like += . It is shorthand for `expr = expr.stuff` for the case where `expr` is inconveniently long. (It also doesn&#39;t evaluate `expr` twice, if Swift&#39;s optimization rules otherwise would allow it or require it for the longhand case.)<br>&gt; <br>&gt; s .= upper()  <br>&gt; // like s = s.upper()<br>&gt; <br>&gt; p .= next<br>&gt; // like p = p.next<br>&gt; <br>&gt; some().long().expression .= upper().trim().truncateToLength(5)<br>&gt; // like some().long().expression = some().long().expression.upper().trim().truncateToLength(5)<br>&gt; <br>&gt; As seen in this last example, one advantage of this syntax is that it allows chained mutations but cleanly separates the &quot;lookup&quot; calls from the &quot;mutate&quot; calls. This is an improvement upon language and API designs with mutating methods where the property being changed is buried in the middle of the expression somewhere.<br>&gt; <br>&gt; some().long().expression.upperInPlace().trimInPlace().truncateInPlace(toLength: 5)<br>&gt; some().long().expression().upper.trimInPlace().truncateInPlace(toLength: 5)<br>&gt; <br>&gt; some().long().expression .= upper().trim().truncate(toLength: 5)<br>&gt; some().long().expression().upper .= trim().truncate(toLength: 5)<br>&gt; <br>&gt; <br>&gt; One consequence of these changes is that compiler optimizations to take advantage of in-place implementation are much more important for performance, because there isn&#39;t any syntax to call the in-place implementation directly.<br>&gt; <br>&gt; &quot;<br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Greg Parker     gparker at apple.com     Runtime Wrangler<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/49f329a0267f5a1773a77017882a82a8?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Rainer Brockerhoff</string> &lt;rainer at brockerhoff.net&gt;<p>February 12, 2016 at 11:00:00am</p></header><div class="content"><p>On 2/12/16 05:26, Greg Parker via swift-evolution wrote:<br>&gt; Now y&#39;all are approaching the syntax of a proposal I made long ago for a .= operator. Here&#39;s what I wrote then (with a handful of syntax updates).<br>&gt; ...&lt;snip&gt;<br>&gt; 3. Add operator .= for in-place modification.<br>&gt; <br>&gt; Operator .= is analogous to arithmetic operators like += . It is shorthand for `expr = expr.stuff` for the case where `expr` is inconveniently long. (It also doesn&#39;t evaluate `expr` twice, if Swift&#39;s optimization rules otherwise would allow it or require it for the longhand case.)<br>&gt; <br>&gt; s .= upper()  <br>&gt; // like s = s.upper()<br>&gt; <br>&gt; p .= next<br>&gt; // like p = p.next<br>&gt; <br>&gt; some().long().expression .= upper().trim().truncateToLength(5)<br>&gt; // like some().long().expression = some().long().expression.upper().trim().truncateToLength(5)<br>&gt; <br>&gt; As seen in this last example, one advantage of this syntax is that it allows chained mutations but cleanly separates the &quot;lookup&quot; calls from the &quot;mutate&quot; calls. This is an improvement upon language and API designs with mutating methods where the property being changed is buried in the middle of the expression somewhere.<br>&gt; <br>&gt; some().long().expression.upperInPlace().trimInPlace().truncateInPlace(toLength: 5)<br>&gt; some().long().expression().upper.trimInPlace().truncateInPlace(toLength: 5)<br>&gt; <br>&gt; some().long().expression .= upper().trim().truncate(toLength: 5)<br>&gt; some().long().expression().upper .= trim().truncate(toLength: 5)<br>&gt; <br>&gt; <br>&gt; One consequence of these changes is that compiler optimizations to take advantage of in-place implementation are much more important for performance, because there isn&#39;t any syntax to call the in-place implementation directly.<br></p><p>+1 for the .= operator!<br></p><p>In general, I&#39;m in favor of limiting the use of subtleties of English to<br>denote semantics in programming languages; for non-native English<br>speakers it&#39;s much easier to memorize operators and sigils instead of<br>having to remember what, say, a past participle is.<br></p><p>FWIW English is my 4th language, but I successfully avoided learning<br>grammar details in all of them :-). Then again, this rendered me<br>incapable of learning English-like programming languages such as<br>Hypertalk, AppleScript and &lt;shudder&gt;COBOL...<br></p><p>-- <br>Rainer Brockerhoff  &lt;rainer at brockerhoff.net&gt;<br>Belo Horizonte, Brazil<br>&quot;In the affairs of others even fools are wise<br>In their own business even sages err.&quot;<br>http://brockerhoff.net/blog/<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>February 12, 2016 at 09:00:00am</p></header><div class="content"><p>On Feb 11, 2016, at 11:26 PM, Greg Parker via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; 3. Add a new operator .= for in-place modification, to shorten the &quot;expr = expr.method()&quot; case.<br></p><p>.= doesn’t really make sense in the context of Swift.  Proposal’s like the (obsolete and unlikely to happen) inplace proposal work by making the = part of the name.  This is important because methods (including the in place assignment operations) should be curryable.  <br></p><p>IOW, the Equal is part of the name of the method, it isn’t part of the “operation of calling the method”.<br></p><p>That said, as Dave mentioned before, we discussed this extensively in the Swift 2 timeframe because it introduces yet-another concept very similar but different to the existing “mutating” keyword, and doesn’t have obvious semantics for classes.  After trying very hard to make something like it work, we agreed that it was better to put the complexity of this back into the space of naming, rather than adding confusing new language features.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/dd033b3ed46d65c7d7394eab52d53e6b?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Evan Maloney</string> &lt;emaloney at gilt.com&gt;<p>February 12, 2016 at 05:00:00pm</p></header><div class="content"><p>With a little tweak to Swift&#39;s type inference with respect to return values, you could provide two parallel signatures for in-place/not-in-place variants.<br></p><p>Imagine a FakeSortable that provided two sort() functions, one in-place and one not:<br></p><p>struct FakeSortable<br>{<br>    private var sortMe: [Int]<br></p><p>    init() { sortMe = [3, 5, 4, 2, 1] }<br>    init(_ sort: FakeSortable) { sortMe = sort.sortMe }<br></p><p>    mutating func sort()<br>    {<br>        print(&quot;sorting in place&quot;)<br>        <br>        sortMe = [1, 2, 3, 4, 5]<br>    }<br>    <br>    func sort() -&gt; FakeSortable<br>    {<br>        print(&quot;returning new FakeSortable&quot;)<br></p><p>        var sort = FakeSortable(self)<br>        sort.sort() as Void<br>        return sort<br>    }<br>}<br></p><p>The thing that makes it unwieldy is that Swift can&#39;t infer the return type correctly without explicit help.<br></p><p>As a result, you have to call the in-place sort like this:<br></p><p>var toSort = FakeSortable()<br>toSort.sort() as Void<br></p><p>...and you have to call the sort-that-returns-a-new-instance as:<br></p><p>var another: FakeSortable = toSort.sort()<br></p><p>or as:<br></p><p>var another = toSort.sort() as FakeSortable<br></p><p>It seems to be Swift should be able to disambiguate purely based on the return, given that:<br></p><p>1. There are only two return types<br>2. One of them is a Void type<br>3. The other return supplies a value<br></p><p>Therefore, if one call assigns the return value and the other does not, Swift should figure out what to call unambiguously.<br></p><p>If I call &quot;toSort.sort()&quot; with no l-value to assign the return to, Swift should figure out that I&#39;m calling the variant that returns Void.<br></p><p>Conversely, if I call sort() and assign the result to something, Swift should assume I&#39;m _not_ calling the Void variant.<br></p><p>If Swift were able to do this, it might be feasible to use the same name for the in-place and not-in-place variants of things like sort() and not have things look ugly at the call-site.<br></p><p>Whether or not that is a good idea, is another discussion :)<br></p><p>Evan<br></p><p><br></p><p>&gt; On Feb 12, 2016, at 12:20 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Feb 11, 2016, at 11:26 PM, Greg Parker via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; 3. Add a new operator .= for in-place modification, to shorten the &quot;expr = expr.method()&quot; case.<br>&gt; <br>&gt; .= doesn’t really make sense in the context of Swift.  Proposal’s like the (obsolete and unlikely to happen) inplace proposal work by making the = part of the name.  This is important because methods (including the in place assignment operations) should be curryable.  <br>&gt; <br>&gt; IOW, the Equal is part of the name of the method, it isn’t part of the “operation of calling the method”.<br>&gt; <br>&gt; That said, as Dave mentioned before, we discussed this extensively in the Swift 2 timeframe because it introduces yet-another concept very similar but different to the existing “mutating” keyword, and doesn’t have obvious semantics for classes.  After trying very hard to make something like it work, we agreed that it was better to put the complexity of this back into the space of naming, rather than adding confusing new language features.<br>&gt; <br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a93de1d552d5ed51ab5e64f1538e0e20?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>richardjrossiii at gmail.com</string> &lt;richardjrossiii at gmail.com&gt;<p>February 12, 2016 at 02:00:00pm</p></header><div class="content"><p>I would be strongly against this.<br></p><p>Void is simply an empty tuple type, and it&#39;s extremely important that an empty tuple remain storable as a value (for example, if building a promises framework, being able to use Task&lt;Void&gt; to denote a task that has no consumable result).<br></p><p>I&#39;d also argue that if following (at least cocoa) naming conventions, the non-mutating function would be bySorting() or something similar, and not actually an issue of type inference.<br></p><p>Just my 2¢.<br>--<br>Richard<br></p><p>&gt; On Feb 12, 2016, at 2:11 PM, Evan Maloney via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; With a little tweak to Swift&#39;s type inference with respect to return values, you could provide two parallel signatures for in-place/not-in-place variants.<br>&gt; <br>&gt; Imagine a FakeSortable that provided two sort() functions, one in-place and one not:<br>&gt; <br>&gt; struct FakeSortable<br>&gt; {<br>&gt;    private var sortMe: [Int]<br>&gt; <br>&gt;    init() { sortMe = [3, 5, 4, 2, 1] }<br>&gt;    init(_ sort: FakeSortable) { sortMe = sort.sortMe }<br>&gt; <br>&gt;    mutating func sort()<br>&gt;    {<br>&gt;        print(&quot;sorting in place&quot;)<br>&gt; <br>&gt;        sortMe = [1, 2, 3, 4, 5]<br>&gt;    }<br>&gt; <br>&gt;    func sort() -&gt; FakeSortable<br>&gt;    {<br>&gt;        print(&quot;returning new FakeSortable&quot;)<br>&gt; <br>&gt;        var sort = FakeSortable(self)<br>&gt;        sort.sort() as Void<br>&gt;        return sort<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; The thing that makes it unwieldy is that Swift can&#39;t infer the return type correctly without explicit help.<br>&gt; <br>&gt; As a result, you have to call the in-place sort like this:<br>&gt; <br>&gt; var toSort = FakeSortable()<br>&gt; toSort.sort() as Void<br>&gt; <br>&gt; ...and you have to call the sort-that-returns-a-new-instance as:<br>&gt; <br>&gt; var another: FakeSortable = toSort.sort()<br>&gt; <br>&gt; or as:<br>&gt; <br>&gt; var another = toSort.sort() as FakeSortable<br>&gt; <br>&gt; It seems to be Swift should be able to disambiguate purely based on the return, given that:<br>&gt; <br>&gt; 1. There are only two return types<br>&gt; 2. One of them is a Void type<br>&gt; 3. The other return supplies a value<br>&gt; <br>&gt; Therefore, if one call assigns the return value and the other does not, Swift should figure out what to call unambiguously.<br>&gt; <br>&gt; If I call &quot;toSort.sort()&quot; with no l-value to assign the return to, Swift should figure out that I&#39;m calling the variant that returns Void.<br>&gt; <br>&gt; Conversely, if I call sort() and assign the result to something, Swift should assume I&#39;m _not_ calling the Void variant.<br>&gt; <br>&gt; If Swift were able to do this, it might be feasible to use the same name for the in-place and not-in-place variants of things like sort() and not have things look ugly at the call-site.<br>&gt; <br>&gt; Whether or not that is a good idea, is another discussion :)<br>&gt; <br>&gt; Evan<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Feb 12, 2016, at 12:20 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Feb 11, 2016, at 11:26 PM, Greg Parker via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; 3. Add a new operator .= for in-place modification, to shorten the &quot;expr = expr.method()&quot; case.<br>&gt;&gt; <br>&gt;&gt; .= doesn’t really make sense in the context of Swift.  Proposal’s like the (obsolete and unlikely to happen) inplace proposal work by making the = part of the name.  This is important because methods (including the in place assignment operations) should be curryable.  <br>&gt;&gt; <br>&gt;&gt; IOW, the Equal is part of the name of the method, it isn’t part of the “operation of calling the method”.<br>&gt;&gt; <br>&gt;&gt; That said, as Dave mentioned before, we discussed this extensively in the Swift 2 timeframe because it introduces yet-another concept very similar but different to the existing “mutating” keyword, and doesn’t have obvious semantics for classes.  After trying very hard to make something like it work, we agreed that it was better to put the complexity of this back into the space of naming, rather than adding confusing new language features.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>February 12, 2016 at 09:00:00pm</p></header><div class="content"><p>I kinda get where your coming from, but this really seems like a calling convention problem. You can have two functions that are nearly identical with the *only* difference being the modification of `self` versus returning a copy.<br></p><p>If we are really going to try and use a name, the suffix `InPlace` is atleast *always* consistent and never ambiguous, unlike nearly every attempt at using different pairs of noun and verb forms.<br></p><p>If we are willing to treat the calling syntax differently, then I think we can at least come up with a non-ambigous form. I think it even applies more generally throughout the language.<br></p><p>The two function signatures are this:<br></p><p>    func union(other: Self) -&gt; Self<br>    mutating func union(other: Self) -&gt; Self<br></p><p>However, the mutating version is now just syntactical short-hand for this:<br></p><p>    static func union(inout this: Self, _ other: Self) -&gt; Self<br></p><p>This changes the language to **not** allow a mutating function to be called with the “.” operator; after all, it’s really a static member now.<br></p><p>At the call site, you’d have the following:<br></p><p>    var a: Set&lt;Int&gt; = [1, 2]<br>    let b: Set&lt;Int&gt; = [3, 4]<br></p><p>    a.union(b)        // this is *always* the non-mutating one<br>    <br>    Set.union(&amp;a, b)  // normal syntax for static methods, mutates `a`<br>    a&amp;.union(b)       // streamlined calling syntax, mutates `a`<br></p><p>    b&amp;.union(a)       // error: Cannot using mutating member on immutable value ‘b’.<br></p><p>This model works with class types as well, but suffers from all of the same limitations today with regards to the ability to enforce member mutation.<br></p><p>This brings two language changes:<br></p><p>1. Any function can be declared with the mutating modifier. This is syntactic sugar for a static function with the first parameter being an `inout` of Self. This works for both value and reference types.<br>2. Any static function that has an unlabeled `inout` parameter of `Self` can be invoked with a short-hand syntax of `&amp;.` instead of the full static calling form.<br></p><p>Maybe there are some other limitations with this approach that I’m not thinking of at the moment.<br></p><p>-David<br></p><p>&gt; On Feb 12, 2016, at 9:20 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Feb 11, 2016, at 11:26 PM, Greg Parker via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; 3. Add a new operator .= for in-place modification, to shorten the &quot;expr = expr.method()&quot; case.<br>&gt; <br>&gt; .= doesn’t really make sense in the context of Swift.  Proposal’s like the (obsolete and unlikely to happen) inplace proposal work by making the = part of the name.  This is important because methods (including the in place assignment operations) should be curryable.  <br>&gt; <br>&gt; IOW, the Equal is part of the name of the method, it isn’t part of the “operation of calling the method”.<br>&gt; <br>&gt; That said, as Dave mentioned before, we discussed this extensively in the Swift 2 timeframe because it introduces yet-another concept very similar but different to the existing “mutating” keyword, and doesn’t have obvious semantics for classes.  After trying very hard to make something like it work, we agreed that it was better to put the complexity of this back into the space of naming, rather than adding confusing new language features.<br>&gt; <br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160212/5515970c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>February 13, 2016 at 05:00:00pm</p></header><div class="content"><p>+1 to &#39;&amp;.&#39; or a new member accessor for mutating types. We&#39;ve spent this<br>long arguing semantics about ing/ed just for &quot;union&quot;, we&#39;re not going to<br>find a generalised and concise solution using an English suffix.<br></p><p>I don&#39;t think the static method is necessary, just make mutating methods<br>require &#39;&amp;.&#39;.<br></p><p>Set.union would already have the type:<br>    (inout Set) -&gt; Set -&gt; Set<br>I think this is good.<br></p><p>+1 to adding mutating to reference types, thus allowing &#39;&amp;.&#39; on them. I&#39;ve<br>often thought it would be nice to have mutation checks on reference types.<br>Purely for better assurances about what my code can do.<br></p><p>On Saturday, 13 February 2016, David Owens II via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I kinda get where your coming from, but this really seems like a calling<br>&gt; convention problem. You can have two functions that are nearly identical<br>&gt; with the *only* difference being the modification of `self` versus<br>&gt; returning a copy.<br>&gt;<br>&gt; If we are really going to try and use a name, the suffix `InPlace` is<br>&gt; atleast *always* consistent and never ambiguous, unlike nearly every<br>&gt; attempt at using different pairs of noun and verb forms.<br>&gt;<br>&gt; If we are willing to treat the calling syntax differently, then I think we<br>&gt; can at least come up with a non-ambigous form. I think it even applies more<br>&gt; generally throughout the language.<br>&gt;<br>&gt; The two function signatures are this:<br>&gt;<br>&gt;     func union(other: Self) -&gt; Self<br>&gt;     mutating func union(other: Self) -&gt; Self<br>&gt;<br>&gt; However, the mutating version is now just syntactical short-hand for this:<br>&gt;<br>&gt;     static func union(inout this: Self, _ other: Self) -&gt; Self<br>&gt;<br>&gt; This changes the language to **not** allow a mutating function to be<br>&gt; called with the “.” operator; after all, it’s really a static member now.<br>&gt;<br>&gt; At the call site, you’d have the following:<br>&gt;<br>&gt;     var a: Set&lt;Int&gt; = [1, 2]<br>&gt;     let b: Set&lt;Int&gt; = [3, 4]<br>&gt;<br>&gt;     a.union(b)        // this is *always* the non-mutating one<br>&gt;<br>&gt;     Set.union(&amp;a, b)  // normal syntax for static methods, mutates `a`<br>&gt;     a&amp;.union(b)       // streamlined calling syntax, mutates `a`<br>&gt;<br>&gt;     b&amp;.union(a)       // error: Cannot using mutating member on immutable<br>&gt; value ‘b’.<br>&gt;<br>&gt; This model works with class types as well, but suffers from all of the<br>&gt; same limitations today with regards to the ability to enforce member<br>&gt; mutation.<br>&gt;<br>&gt; This brings two language changes:<br>&gt;<br>&gt; 1. Any function can be declared with the mutating modifier. This is<br>&gt; syntactic sugar for a static function with the first parameter being an<br>&gt; `inout` of Self. This works for both value and reference types.<br>&gt; 2. Any static function that has an unlabeled `inout` parameter of `Self`<br>&gt; can be invoked with a short-hand syntax of `&amp;.` instead of the full static<br>&gt; calling form.<br>&gt;<br>&gt; Maybe there are some other limitations with this approach that I’m not<br>&gt; thinking of at the moment.<br>&gt;<br>&gt; -David<br>&gt;<br>&gt; On Feb 12, 2016, at 9:20 AM, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt; On Feb 11, 2016, at 11:26 PM, Greg Parker via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt; 3. Add a new operator .= for in-place modification, to shorten the &quot;expr =<br>&gt; expr.method()&quot; case.<br>&gt;<br>&gt;<br>&gt; .= doesn’t really make sense in the context of Swift.  Proposal’s like the<br>&gt; (obsolete and unlikely to happen) inplace proposal work by making the =<br>&gt; part of the name.  This is important because methods (including the in<br>&gt; place assignment operations) should be curryable.<br>&gt;<br>&gt; IOW, the Equal is part of the name of the method, it isn’t part of the<br>&gt; “operation of calling the method”.<br>&gt;<br>&gt; That said, as Dave mentioned before, we discussed this extensively in the<br>&gt; Swift 2 timeframe because it introduces yet-another concept very similar<br>&gt; but different to the existing “mutating” keyword, and doesn’t have obvious<br>&gt; semantics for classes.  After trying very hard to make something like it<br>&gt; work, we agreed that it was better to put the complexity of this back into<br>&gt; the space of naming, rather than adding confusing new language features.<br>&gt;<br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160213/d003f490/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>February 15, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Feb 12, 2016, at 9:18 PM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt; <br>&gt; I kinda get where your coming from, but this really seems like a calling convention problem. You can have two functions that are nearly identical with the *only* difference being the modification of `self` versus returning a copy.<br>&gt; <br>&gt; If we are really going to try and use a name, the suffix `InPlace` is atleast *always* consistent and never ambiguous, unlike nearly every attempt at using different pairs of noun and verb forms.<br>&gt; <br>&gt; If we are willing to treat the calling syntax differently, then I think we can at least come up with a non-ambigous form. I think it even applies more generally throughout the language.<br>&gt; <br>&gt; The two function signatures are this:<br>&gt; <br>&gt;     func union(other: Self) -&gt; Self<br>&gt;     mutating func union(other: Self) -&gt; Self<br>&gt; <br>&gt; However, the mutating version is now just syntactical short-hand for this:<br>&gt; <br>&gt;     static func union(inout this: Self, _ other: Self) -&gt; Self<br>&gt; <br>&gt; This changes the language to **not** allow a mutating function to be called with the “.” operator; after all, it’s really a static member now.<br>&gt; <br>&gt; At the call site, you’d have the following:<br>&gt; <br>&gt;     var a: Set&lt;Int&gt; = [1, 2]<br>&gt;     let b: Set&lt;Int&gt; = [3, 4]<br>&gt; <br>&gt;     a.union(b)        // this is *always* the non-mutating one<br>&gt;     <br>&gt;     Set.union(&amp;a, b)  // normal syntax for static methods, mutates `a`<br>&gt;     a&amp;.union(b)       // streamlined calling syntax, mutates `a`<br>&gt; <br>&gt;     b&amp;.union(a)       // error: Cannot using mutating member on immutable value ‘b’.<br>&gt; <br>&gt; This model works with class types as well, but suffers from all of the same limitations today with regards to the ability to enforce member mutation.<br>&gt; <br>&gt; This brings two language changes:<br>&gt; <br>&gt; 1. Any function can be declared with the mutating modifier. This is syntactic sugar for a static function with the first parameter being an `inout` of Self. This works for both value and reference types.<br>&gt; 2. Any static function that has an unlabeled `inout` parameter of `Self` can be invoked with a short-hand syntax of `&amp;.` instead of the full static calling form.<br>&gt; <br>&gt; Maybe there are some other limitations with this approach that I’m not thinking of at the moment.<br></p><p>Can you write both a mutating implementation and a non-mutating implementation of the same function with this scheme? Being able to provide both is important for performance.<br></p><p><br>-- <br>Greg Parker     gparker at apple.com &lt;mailto:gparker at apple.com&gt;     Runtime Wrangler<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160215/67bb74a8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>February 16, 2016 at 11:00:00am</p></header><div class="content"><p>I don&#39;t see why not. <br></p><p>Another way to potentially model it is like this:<br></p><p>    protocol UnionType {<br>      func union(other: Self) -&gt; Self<br>      mutating func union(other: Self) -&gt; Self<br>    }<br></p><p>Internally, each of these is basically this:<br></p><p>    func union(this, other: Self) -&gt; Self<br>    func union(inout this, other: Self) -&gt; Self<br></p><p>The above is suggesting that member functions have an implicit self parameter as the first parameter.<br></p><p>For value-types, it may even be possible to generate the mutating version.<br></p><p> To call them:<br></p><p>    a.union(b)        // this is *always* the non-mutating one<br>    a&amp;.union(b)       // streamlined calling syntax, mutates `a`<br></p><p>-David<br></p><p>&gt; On Feb 15, 2016, at 11:11 AM, Greg Parker &lt;gparker at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 12, 2016, at 9:18 PM, David Owens II &lt;david at owensd.io &lt;mailto:david at owensd.io&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I kinda get where your coming from, but this really seems like a calling convention problem. You can have two functions that are nearly identical with the *only* difference being the modification of `self` versus returning a copy.<br>&gt;&gt; <br>&gt;&gt; If we are really going to try and use a name, the suffix `InPlace` is atleast *always* consistent and never ambiguous, unlike nearly every attempt at using different pairs of noun and verb forms.<br>&gt;&gt; <br>&gt;&gt; If we are willing to treat the calling syntax differently, then I think we can at least come up with a non-ambigous form. I think it even applies more generally throughout the language.<br>&gt;&gt; <br>&gt;&gt; The two function signatures are this:<br>&gt;&gt; <br>&gt;&gt;     func union(other: Self) -&gt; Self<br>&gt;&gt;     mutating func union(other: Self) -&gt; Self<br>&gt;&gt; <br>&gt;&gt; However, the mutating version is now just syntactical short-hand for this:<br>&gt;&gt; <br>&gt;&gt;     static func union(inout this: Self, _ other: Self) -&gt; Self<br>&gt;&gt; <br>&gt;&gt; This changes the language to **not** allow a mutating function to be called with the “.” operator; after all, it’s really a static member now.<br>&gt;&gt; <br>&gt;&gt; At the call site, you’d have the following:<br>&gt;&gt; <br>&gt;&gt;     var a: Set&lt;Int&gt; = [1, 2]<br>&gt;&gt;     let b: Set&lt;Int&gt; = [3, 4]<br>&gt;&gt; <br>&gt;&gt;     a.union(b)        // this is *always* the non-mutating one<br>&gt;&gt;     <br>&gt;&gt;     Set.union(&amp;a, b)  // normal syntax for static methods, mutates `a`<br>&gt;&gt;     a&amp;.union(b)       // streamlined calling syntax, mutates `a`<br>&gt;&gt; <br>&gt;&gt;     b&amp;.union(a)       // error: Cannot using mutating member on immutable value ‘b’.<br>&gt;&gt; <br>&gt;&gt; This model works with class types as well, but suffers from all of the same limitations today with regards to the ability to enforce member mutation.<br>&gt;&gt; <br>&gt;&gt; This brings two language changes:<br>&gt;&gt; <br>&gt;&gt; 1. Any function can be declared with the mutating modifier. This is syntactic sugar for a static function with the first parameter being an `inout` of Self. This works for both value and reference types.<br>&gt;&gt; 2. Any static function that has an unlabeled `inout` parameter of `Self` can be invoked with a short-hand syntax of `&amp;.` instead of the full static calling form.<br>&gt;&gt; <br>&gt;&gt; Maybe there are some other limitations with this approach that I’m not thinking of at the moment.<br>&gt; <br>&gt; Can you write both a mutating implementation and a non-mutating implementation of the same function with this scheme? Being able to provide both is important for performance.<br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Greg Parker     gparker at apple.com &lt;mailto:gparker at apple.com&gt;     Runtime Wrangler<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160216/bf9fddeb/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/aeab22e60ba7b7e2bd445775850448d1?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Radosław Pietruszewski</string> &lt;radexpl at gmail.com&gt;<p>February 13, 2016 at 09:00:00am</p></header><div class="content"><p>Would you mind elaborating why is the InPlace proposal and the like unlikely to happen? Having only looked through it briefly, it seemed like a great way to avoid tricky naming issues like this thread. (Though just a convention, I found it very useful in Ruby to have foo and foo! pairs to communicate mutability)<br></p><p>Apologies if this was explained before and I just missed the discussion...<br></p><p>Sent from my iPhone<br></p><p>&gt; On 12 Feb 2016, at 18:20, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Feb 11, 2016, at 11:26 PM, Greg Parker via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; 3. Add a new operator .= for in-place modification, to shorten the &quot;expr = expr.method()&quot; case.<br>&gt; <br>&gt; .= doesn’t really make sense in the context of Swift.  Proposal’s like the (obsolete and unlikely to happen) inplace proposal work by making the = part of the name.  This is important because methods (including the in place assignment operations) should be curryable.  <br>&gt; <br>&gt; IOW, the Equal is part of the name of the method, it isn’t part of the “operation of calling the method”.<br>&gt; <br>&gt; That said, as Dave mentioned before, we discussed this extensively in the Swift 2 timeframe because it introduces yet-another concept very similar but different to the existing “mutating” keyword, and doesn’t have obvious semantics for classes.  After trying very hard to make something like it work, we agreed that it was better to put the complexity of this back into the space of naming, rather than adding confusing new language features.<br>&gt; <br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
