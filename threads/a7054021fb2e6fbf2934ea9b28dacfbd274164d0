<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pre-Draft] Nil-coalescing and errors</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April  6, 2016 at 08:00:00am</p></header><div class="content"><p>Pyry Jahkola and I have been plugging away on the following which is preliminary enough not to qualify as an actual draft. He prefers the Mike Ash approach. I prefer the operator approach. So we have not actually settled on which one we would actually propose despite how I&#39;ve written this up.<br></p><p>I&#39;m putting this out there to try to gain a consensus on:<br></p><p>* Would this be a viable proposal?<br>* If so, which of the options would work best within Swift&#39;s design and philosophy <br></p><p>Thanks for your feedback.<br></p><p>-- Erica<br> &lt;https://gist.github.com/erica/5a26d523f3d6ffb74e34d179740596f7#introduction&gt;Introduction<br></p><p>Swift&#39;s try? keyword transforms error-throwing operations into optional values. We propose adding an error-throwing nil-coalescing operator to the Swift standard library. This operator will coerce optional results into Swift&#39;s error-handling system. <br></p><p>This proposal was discussed on the Swift Evolution list in the name &lt;https://gist.github.com/erica/link&gt; thread.<br></p><p> &lt;https://gist.github.com/erica/5a26d523f3d6ffb74e34d179740596f7#motivation&gt;Motivation<br></p><p>Any decision to expand Swift&#39;s set of standard operators should be taken thoughtfully and judiciously. Moving unaudited or deliberately non-error-handling nil-returning methods and failable initializers into Swift&#39;s error system should be a common enough use case to justify introducing a new operator.<br></p><p> &lt;https://gist.github.com/erica/5a26d523f3d6ffb74e34d179740596f7#detail-design&gt;Detail Design<br></p><p>We propose adding a new operator that works along the following lines:<br></p><p>infix operator ??? {}<br></p><p>func ???&lt;T&gt;(lhs: T?, @autoclosure error: () -&gt; ErrorType) throws -&gt; T {<br>    guard case let value? = lhs else { throw error() }<br>    return value<br>}<br>The use-case would look like this:<br></p><p>do {<br>    let error = Error(reason: &quot;Invalid string passed to Integer initializer&quot;)<br>    let value = try Int(&quot;NotANumber&quot;) ??? InitializerError.invalidString<br>    print(&quot;Value&quot;, value)<br>} catch { print(error) }<br> &lt;https://gist.github.com/erica/5a26d523f3d6ffb74e34d179740596f7#note&gt;Note<br></p><p>SE-0047 (warn unused result by default) and SE-0049 (move autoclosure) both affect many of the snippets in this proposal<br></p><p>Disadvantages to this approach:<br></p><p>It consumes a new operator, which developers must be trained to use<br>Unlike many other operators and specifically ??, this cannot be chained. There&#39;s no equivalent to a ?? b ?? c ?? dor a ?? (b ?? (c ?? d)).<br> &lt;https://gist.github.com/erica/5a26d523f3d6ffb74e34d179740596f7#alternatives-considered&gt;Alternatives Considered<br></p><p> &lt;https://gist.github.com/erica/5a26d523f3d6ffb74e34d179740596f7#extending-optional&gt;Extending Optional<br></p><p>The MikeAsh approach extends Optional to add an orThrow(ErrorType) method<br></p><p>extension Optional {<br>    func orThrow(@autoclosure error: () -&gt; ErrorType) throws -&gt; Wrapped {<br>        guard case let value? = self else { throw error() }<br>        return value<br>    }<br>}<br>Usage looks like this:<br></p><p>do {<br>    let value = try Int(&quot;NotANumber&quot;)<br>        .orThrow(InitializerError.invalidString)<br>    print(&quot;Value&quot;, value)<br>} catch { print(error) }<br>An alternative version of this call looks like this: optionalValue.or(throw: error). I am not a fan of using a verb as a first statement label.<br></p><p>Disadvantages:<br></p><p>Wordier than the operator, verging on claustrophobic, even using Swift&#39;s newline dot continuation.<br>Reading the code can be confusing. This requires chaining rather than separating error throwing into a clear separate component. <br>Advantages:<br></p><p>No new operator, which maintains Swift operator parsimony and avoids the introduction and training issues associated with new operators.<br>Implicit Optional promotion cannot take place. You avoid mistaken usage like nonOptional ??? error and nonOptional ?? raise(error).<br>As a StdLib method, autocompletion support is baked in.<br> &lt;https://gist.github.com/erica/5a26d523f3d6ffb74e34d179740596f7#introducing-a-stdlib-implementation-of-raiseerrortype&gt;Introducing a StdLib implementation of raise(ErrorType)<br></p><p>Swift could introduce a raise(ErrorType) -&gt; T global function:<br></p><p>func raise&lt;T&gt;(error: ErrorType) throws -&gt; T { throw error }<br></p><p>do {<br>    let value = try Int(&quot;NotANumber&quot;) ?? raise(InitializerError.invalidString)<br>    print(&quot;Value&quot;, value)<br>} catch { print(error) }<br>This is less than ideal:<br></p><p>This approach is similar to using &amp;&amp; as an if-true condition where an operator is abused for its side-effects.<br>It is wordier than the operator approach.<br>The error raising function promises to return a type but never will, which seems hackish.<br> &lt;https://gist.github.com/erica/5a26d523f3d6ffb74e34d179740596f7#overriding-&gt;Overriding ??<br></p><p>We also considered overriding ?? to accept an error as a RHS argument. This introduces a new way to interpret ?? as meaning, &quot;throw this error instead of substituting this value&quot;.<br></p><p>func ??&lt;T&gt;(lhs: T?, @autoclosure error: () -&gt; ErrorType) throws -&gt; T {<br>    guard case let value? = lhs else { throw error() }<br>    return value<br>}<br>Usage:<br></p><p>let value = try Int(&quot;NotANumber&quot;) ?? Error(reason: &quot;Invalid string passed to Integer initializer&quot;)<br>This approach overloads the semantics as well as the syntax of the coalescing operator. Instead of falling back to a RHS value, it raises the RHS error. The code remains simple and readable although the developer must take care to clarify through comments and naming which version of the operator is being used.<br></p><p>While using try in the ?? statement signals that a throwing call is in use, it is insufficient (especially when used in a throwing scope) to distinguish between the normal coalescing and new error-throwing behaviors.<br>Error types need not use the word &quot;Error&quot; in their construction or use. For example try value ?? e may not be immediately clear as an error-throwing intent.<br>Overloading ?? dilutes the impact and meaning of the original operator intent.<br> &lt;https://gist.github.com/erica/5a26d523f3d6ffb74e34d179740596f7#future-directions&gt;Future Directions<br></p><p>We briefly considered something along the lines of perl&#39;s die as an alternative to raise using fatalError.<br></p><p> &lt;https://gist.github.com/erica/5a26d523f3d6ffb74e34d179740596f7#acknowledgements&gt;Acknowledgements<br></p><p>Thanks Mike Ash, Jido, Dave Delong<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/a70564d0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>[Pre-Draft] Nil-coalescing and errors</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>April  6, 2016 at 10:00:00am</p></header><div class="content"><p>Interesting, but I’m unsure if all of it is significantly better than just using the guard that is effectively inside of the operator/func that is being proposed:<br></p><p>guard let value = Int(&quot;NotANumber&quot;) else { throw InitializerError.invalidString }<br></p><p>It is only a couple of characters longer and already works (it’s what I use currently). If guard allowed for a special single-expression variation so that you didn’t need to specify the ugly braces or something, it’d look prettier and be nice for a lot of other situations, too:<br></p><p>guard let value = Int(&quot;NotANumber&quot;) else: throw InitializerError.invalidString<br>guard someVal &lt; 10 else: return false<br>guard mustBeTrue() else: return<br>// etc<br></p><p>Not to derail this, but I sort of want this ability anywhere as a shorthand for a single-expression block.<br></p><p>if something &lt; 42: doThing()<br>for a in list: print(a)<br></p><p>But I imagine that’ll never fly. :P<br></p><p>l8r<br>Sean<br></p><p><br></p><p>&gt; On Apr 6, 2016, at 9:46 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Pyry Jahkola and I have been plugging away on the following which is preliminary enough not to qualify as an actual draft. He prefers the Mike Ash approach. I prefer the operator approach. So we have not actually settled on which one we would actually propose despite how I&#39;ve written this up.<br>&gt; <br>&gt; I&#39;m putting this out there to try to gain a consensus on:<br>&gt; <br>&gt; * Would this be a viable proposal?<br>&gt; * If so, which of the options would work best within Swift&#39;s design and philosophy <br>&gt; <br>&gt; Thanks for your feedback.<br>&gt; <br>&gt; -- Erica<br>&gt; Introduction<br>&gt; <br>&gt; Swift&#39;s try? keyword transforms error-throwing operations into optional values. We propose adding an error-throwing nil-coalescing operator to the Swift standard library. This operator will coerce optional results into Swift&#39;s error-handling system. <br>&gt; <br>&gt; This proposal was discussed on the Swift Evolution list in the name thread.<br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; Any decision to expand Swift&#39;s set of standard operators should be taken thoughtfully and judiciously. Moving unaudited or deliberately non-error-handling nil-returning methods and failable initializers into Swift&#39;s error system should be a common enough use case to justify introducing a new operator.<br>&gt; <br>&gt; Detail Design<br>&gt; <br>&gt; We propose adding a new operator that works along the following lines:<br>&gt; <br>&gt; infix operator ??? {}<br>&gt; <br>&gt; func ???&lt;T&gt;(lhs: T?, @autoclosure error: () -&gt; ErrorType) throws -&gt; T {<br>&gt;     guard case let value? = lhs else { throw error() }<br>&gt;     return value<br>&gt; }<br>&gt; <br>&gt; The use-case would look like this:<br>&gt; <br>&gt; do {<br>&gt;     let error = Error(reason: &quot;Invalid string passed to Integer initializer&quot;)<br>&gt;     let value = try Int(&quot;NotANumber&quot;) ??? InitializerError.invalidString<br>&gt;     print(&quot;Value&quot;, value)<br>&gt; } catch { print(error) }<br>&gt; <br>&gt; Note<br>&gt; <br>&gt; SE-0047 (warn unused result by default) and SE-0049 (move autoclosure) both affect many of the snippets in this proposal<br>&gt; <br>&gt; Disadvantages to this approach:<br>&gt; <br>&gt; 	• It consumes a new operator, which developers must be trained to use<br>&gt; 	• Unlike many other operators and specifically ??, this cannot be chained. There&#39;s no equivalent to a ?? b ?? c ?? dor a ?? (b ?? (c ?? d)).<br>&gt; Alternatives Considered<br>&gt; <br>&gt; Extending Optional<br>&gt; <br>&gt; The MikeAsh approach extends Optional to add an orThrow(ErrorType) method<br>&gt; <br>&gt; extension Optional {<br>&gt;     func orThrow(@autoclosure error: () -&gt; ErrorType) throws -&gt; Wrapped {<br>&gt;         guard case let value? = self else { throw error() }<br>&gt;         return value<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; Usage looks like this:<br>&gt; <br>&gt; do {<br>&gt;     let value = try Int(&quot;NotANumber&quot;)<br>&gt;         .orThrow(InitializerError.invalidString)<br>&gt;     print(&quot;Value&quot;, value)<br>&gt; } catch { print(error) }<br>&gt; <br>&gt; An alternative version of this call looks like this: optionalValue.or(throw: error). I am not a fan of using a verb as a first statement label.<br>&gt; <br>&gt; Disadvantages:<br>&gt; <br>&gt; 	• Wordier than the operator, verging on claustrophobic, even using Swift&#39;s newline dot continuation.<br>&gt; 	• Reading the code can be confusing. This requires chaining rather than separating error throwing into a clear separate component. <br>&gt; Advantages:<br>&gt; <br>&gt; 	• No new operator, which maintains Swift operator parsimony and avoids the introduction and training issues associated with new operators.<br>&gt; 	• Implicit Optional promotion cannot take place. You avoid mistaken usage like nonOptional ??? error and nonOptional ?? raise(error).<br>&gt; 	• As a StdLib method, autocompletion support is baked in.<br>&gt; Introducing a StdLib implementation of raise(ErrorType)<br>&gt; <br>&gt; Swift could introduce a raise(ErrorType) -&gt; T global function:<br>&gt; <br>&gt; func raise&lt;T&gt;(error: ErrorType) throws -&gt; T { throw error }<br>&gt; <br>&gt; do {<br>&gt;     let value = try Int(&quot;NotANumber&quot;) ?? raise(InitializerError.invalidString)<br>&gt;     print(&quot;Value&quot;, value)<br>&gt; } catch { print(error) }<br>&gt; <br>&gt; This is less than ideal:<br>&gt; <br>&gt; 	• This approach is similar to using &amp;&amp; as an if-true condition where an operator is abused for its side-effects.<br>&gt; 	• It is wordier than the operator approach.<br>&gt; 	• The error raising function promises to return a type but never will, which seems hackish.<br>&gt; Overriding ??<br>&gt; <br>&gt; We also considered overriding ?? to accept an error as a RHS argument. This introduces a new way to interpret ?? as meaning, &quot;throw this error instead of substituting this value&quot;.<br>&gt; <br>&gt; func ??&lt;T&gt;(lhs: T?, @autoclosure error: () -&gt; ErrorType) throws -&gt; T {<br>&gt;     guard case let value? = lhs else { throw error() }<br>&gt;     return value<br>&gt; }<br>&gt; <br>&gt; Usage:<br>&gt; <br>&gt; let value = try Int(&quot;NotANumber&quot;) ?? Error(reason: &quot;Invalid string passed to Integer initializer&quot;)<br>&gt; <br>&gt; This approach overloads the semantics as well as the syntax of the coalescing operator. Instead of falling back to a RHS value, it raises the RHS error. The code remains simple and readable although the developer must take care to clarify through comments and naming which version of the operator is being used.<br>&gt; <br>&gt; 	• While using try in the ?? statement signals that a throwing call is in use, it is insufficient (especially when used in a throwing scope) to distinguish between the normal coalescing and new error-throwing behaviors.<br>&gt; 	• Error types need not use the word &quot;Error&quot; in their construction or use. For example try value ?? e may not be immediately clear as an error-throwing intent.<br>&gt; 	• Overloading ?? dilutes the impact and meaning of the original operator intent.<br>&gt; Future Directions<br>&gt; <br>&gt; We briefly considered something along the lines of perl&#39;s die as an alternative to raise using fatalError.<br>&gt; <br>&gt; Acknowledgements<br>&gt; <br>&gt; Thanks Mike Ash, Jido, Dave Delong<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pre-Draft] Nil-coalescing and errors</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April  6, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Apr 6, 2016, at 9:00 AM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt; <br>&gt; Interesting, but I’m unsure if all of it is significantly better than just using the guard that is effectively inside of the operator/func that is being proposed:<br>&gt; <br>&gt; guard let value = Int(&quot;NotANumber&quot;) else { throw InitializerError.invalidString }<br>&gt; <br></p><p>That is a pretty damn compelling argument.<br></p><p>-- E<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Pre-Draft] Nil-coalescing and errors</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April  6, 2016 at 09:00:00am</p></header><div class="content"><p>&gt;&gt; Interesting, but I’m unsure if all of it is significantly better than just using the guard that is effectively inside of the operator/func that is being proposed:<br>&gt;&gt; <br>&gt;&gt; guard let value = Int(&quot;NotANumber&quot;) else { throw InitializerError.invalidString }<br>&gt;&gt; <br>&gt; <br>&gt; That is a pretty damn compelling argument.<br></p><p>For some cases, yes. For others…<br></p><p>	myInt = Int(&quot;NotANumber&quot;) ?? throw InitializerError.invalidString<br></p><p>On the other hand, all we really need is a generalized &quot;noneMap&quot; function marked as rethrowing, which can serve multiple purposes.<br></p><p>	myOtherInt = Int(&quot;NotANumber&quot;).noneMap(arc4random)<br>	myInt = try Int(&quot;NotANumber&quot;).noneMap { throw InitializerError.invalidString }<br></p><p>On the gripping hand: I think this is only a problem because `throw` is a statement, not an expression. Could it be changed to be an expression with an unspecified return type? I believe that would allow you to simply drop it into the right side of a ?? operator, and anywhere else you might want it (boolean operators, for instance).<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[Pre-Draft] Nil-coalescing and errors</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>April  6, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt;&gt;&gt; Interesting, but I’m unsure if all of it is significantly better than just using the guard that is effectively inside of the operator/func that is being proposed:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; guard let value = Int(&quot;NotANumber&quot;) else { throw InitializerError.invalidString }<br>&gt;&gt; <br>&gt;&gt; That is a pretty damn compelling argument.<br></p><p>Made me smile too. :-)<br></p><p>&gt; For some cases, yes. For others…<br></p><p>Right. Continuing that thought, Swift is not a language where there&#39;s exactly one way of doing everything. For `Optional` unwrapping, we have `if let`, `guard let`, `x.map(f)`, `x.flatMap(f)`, `x?.member`, `x ?? y`, and a bunch of others. The fact that you can already do almost the same thing with a statement doesn&#39;t rule out the occasional need to do the same thing in just an expression.<br></p><p>But like it was said, it&#39;s pretty easy to add this in a user-defined extension too, so it remains a question of whether people in general see `x ??? error` or `x.orThrow(error)` as a useful thing to have.<br></p><p>&gt; 	myInt = Int(&quot;NotANumber&quot;) ?? throw InitializerError.invalidString<br></p><p>The following works already:<br></p><p>	myInt = Int(&quot;NotANumber&quot;) ?? { throw InitializerError.invalidString }()<br></p><p>(Ping Erica, to the list of alternatives considered.)<br></p><p>&gt; On the other hand, all we really need is a generalized &quot;noneMap&quot; function marked as rethrowing, which can serve multiple purposes.<br>&gt; <br>&gt; 	myOtherInt = Int(&quot;NotANumber&quot;).noneMap(arc4random)<br>&gt; 	myInt = try Int(&quot;NotANumber&quot;).noneMap { throw InitializerError.invalidString }<br></p><p>If I got it right, you&#39;re after this extension:<br></p><p>	extension Optional {<br>	    func noneMap(ifNone: () throws -&gt; Wrapped) rethrows -&gt; Wrapped {<br>	        return try self ?? ifNone()<br>	    }<br>	}<br></p><p>Since we have `??` already, I feel `noneMap` isn&#39;t different enough to justify being added to the standard library.<br></p><p>&gt; On the gripping hand: I think this is only a problem because `throw` is a statement, not an expression. Could it be changed to be an expression with an unspecified return type? I believe that would allow you to simply drop it into the right side of a ?? operator, and anywhere else you might want it (boolean operators, for instance).<br></p><p>Why not. That&#39;s essentially making the `x ?? raise(error)` trick into a language feature. My guts say people wouldn&#39;t like how it looks. Would&#39;ve suggested that as another option otherwise.<br></p><p>All in all, I think the error handling model introduced in Swift 2.0 was pretty heavy on syntax compared to how much new functionality it made possible (and even now, we don&#39;t have catch exhaustiveness checking or asynchronous error handling, to name a few). I&#39;d rather improve Swift&#39;s error handling by introducing features on the library side and only inventing new syntax for things that can&#39;t be done in code.<br></p><p>— Pyry<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Pre-Draft] Nil-coalescing and errors</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>April  6, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Apr 6, 2016, at 9:21 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; Interesting, but I’m unsure if all of it is significantly better than just using the guard that is effectively inside of the operator/func that is being proposed:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; guard let value = Int(&quot;NotANumber&quot;) else { throw InitializerError.invalidString }<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; That is a pretty damn compelling argument.<br>&gt; <br>&gt; For some cases, yes. For others…<br>&gt; <br>&gt; 	myInt = Int(&quot;NotANumber&quot;) ?? throw InitializerError.invalidString<br>&gt; <br>&gt; On the other hand, all we really need is a generalized &quot;noneMap&quot; function marked as rethrowing, which can serve multiple purposes.<br>&gt; <br>&gt; 	myOtherInt = Int(&quot;NotANumber&quot;).noneMap(arc4random)<br>&gt; 	myInt = try Int(&quot;NotANumber&quot;).noneMap { throw InitializerError.invalidString }<br>&gt; <br>&gt; On the gripping hand: I think this is only a problem because `throw` is a statement, not an expression. Could it be changed to be an expression with an unspecified return type? I believe that would allow you to simply drop it into the right side of a ?? operator, and anywhere else you might want it (boolean operators, for instance).<br></p><p>For what it&#39;s worth, this is how it was originally designed.  Reducing it to a statement was a simplification to gain consensus.<br></p><p>John.<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Pre-Draft] Nil-coalescing and errors</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>April  6, 2016 at 05:00:00pm</p></header><div class="content"><p>I’m inclined to agree with this; the guard statement is fairly clear, though a slightly cleaner construct for throwing would be nice.<br>That said, it isn’t mutually exclusive with the MikeAsh alternative provided, which could still be a nice addition for those that prefer it (though it’s also a fairly easy one to add yourself through extension).<br></p><p>Coincidentally, the example in the operator part of the proposal illustrates part of why I argued against keeping failable initialisers as a type of error handling as it can be easy to result in odd cases when nil is used alternatively as an error condition and simply a “no result” case. But that’s another topic really.<br></p><p>&gt; On 6 Apr 2016, at 16:00, Sean Heber via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Interesting, but I’m unsure if all of it is significantly better than just using the guard that is effectively inside of the operator/func that is being proposed:<br>&gt; <br>&gt; guard let value = Int(&quot;NotANumber&quot;) else { throw InitializerError.invalidString }<br>&gt; <br>&gt; It is only a couple of characters longer and already works (it’s what I use currently). If guard allowed for a special single-expression variation so that you didn’t need to specify the ugly braces or something, it’d look prettier and be nice for a lot of other situations, too:<br>&gt; <br>&gt; guard let value = Int(&quot;NotANumber&quot;) else: throw InitializerError.invalidString<br>&gt; guard someVal &lt; 10 else: return false<br>&gt; guard mustBeTrue() else: return<br>&gt; // etc<br>&gt; <br>&gt; Not to derail this, but I sort of want this ability anywhere as a shorthand for a single-expression block.<br>&gt; <br>&gt; if something &lt; 42: doThing()<br>&gt; for a in list: print(a)<br>&gt; <br>&gt; But I imagine that’ll never fly. :P<br>&gt; <br>&gt; l8r<br>&gt; Sean<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Apr 6, 2016, at 9:46 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Pyry Jahkola and I have been plugging away on the following which is preliminary enough not to qualify as an actual draft. He prefers the Mike Ash approach. I prefer the operator approach. So we have not actually settled on which one we would actually propose despite how I&#39;ve written this up.<br>&gt;&gt; <br>&gt;&gt; I&#39;m putting this out there to try to gain a consensus on:<br>&gt;&gt; <br>&gt;&gt; * Would this be a viable proposal?<br>&gt;&gt; * If so, which of the options would work best within Swift&#39;s design and philosophy <br>&gt;&gt; <br>&gt;&gt; Thanks for your feedback.<br>&gt;&gt; <br>&gt;&gt; -- Erica<br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; Swift&#39;s try? keyword transforms error-throwing operations into optional values. We propose adding an error-throwing nil-coalescing operator to the Swift standard library. This operator will coerce optional results into Swift&#39;s error-handling system. <br>&gt;&gt; <br>&gt;&gt; This proposal was discussed on the Swift Evolution list in the name thread.<br>&gt;&gt; <br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; Any decision to expand Swift&#39;s set of standard operators should be taken thoughtfully and judiciously. Moving unaudited or deliberately non-error-handling nil-returning methods and failable initializers into Swift&#39;s error system should be a common enough use case to justify introducing a new operator.<br>&gt;&gt; <br>&gt;&gt; Detail Design<br>&gt;&gt; <br>&gt;&gt; We propose adding a new operator that works along the following lines:<br>&gt;&gt; <br>&gt;&gt; infix operator ??? {}<br>&gt;&gt; <br>&gt;&gt; func ???&lt;T&gt;(lhs: T?, @autoclosure error: () -&gt; ErrorType) throws -&gt; T {<br>&gt;&gt;    guard case let value? = lhs else { throw error() }<br>&gt;&gt;    return value<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; The use-case would look like this:<br>&gt;&gt; <br>&gt;&gt; do {<br>&gt;&gt;    let error = Error(reason: &quot;Invalid string passed to Integer initializer&quot;)<br>&gt;&gt;    let value = try Int(&quot;NotANumber&quot;) ??? InitializerError.invalidString<br>&gt;&gt;    print(&quot;Value&quot;, value)<br>&gt;&gt; } catch { print(error) }<br>&gt;&gt; <br>&gt;&gt; Note<br>&gt;&gt; <br>&gt;&gt; SE-0047 (warn unused result by default) and SE-0049 (move autoclosure) both affect many of the snippets in this proposal<br>&gt;&gt; <br>&gt;&gt; Disadvantages to this approach:<br>&gt;&gt; <br>&gt;&gt; 	• It consumes a new operator, which developers must be trained to use<br>&gt;&gt; 	• Unlike many other operators and specifically ??, this cannot be chained. There&#39;s no equivalent to a ?? b ?? c ?? dor a ?? (b ?? (c ?? d)).<br>&gt;&gt; Alternatives Considered<br>&gt;&gt; <br>&gt;&gt; Extending Optional<br>&gt;&gt; <br>&gt;&gt; The MikeAsh approach extends Optional to add an orThrow(ErrorType) method<br>&gt;&gt; <br>&gt;&gt; extension Optional {<br>&gt;&gt;    func orThrow(@autoclosure error: () -&gt; ErrorType) throws -&gt; Wrapped {<br>&gt;&gt;        guard case let value? = self else { throw error() }<br>&gt;&gt;        return value<br>&gt;&gt;    }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Usage looks like this:<br>&gt;&gt; <br>&gt;&gt; do {<br>&gt;&gt;    let value = try Int(&quot;NotANumber&quot;)<br>&gt;&gt;        .orThrow(InitializerError.invalidString)<br>&gt;&gt;    print(&quot;Value&quot;, value)<br>&gt;&gt; } catch { print(error) }<br>&gt;&gt; <br>&gt;&gt; An alternative version of this call looks like this: optionalValue.or(throw: error). I am not a fan of using a verb as a first statement label.<br>&gt;&gt; <br>&gt;&gt; Disadvantages:<br>&gt;&gt; <br>&gt;&gt; 	• Wordier than the operator, verging on claustrophobic, even using Swift&#39;s newline dot continuation.<br>&gt;&gt; 	• Reading the code can be confusing. This requires chaining rather than separating error throwing into a clear separate component. <br>&gt;&gt; Advantages:<br>&gt;&gt; <br>&gt;&gt; 	• No new operator, which maintains Swift operator parsimony and avoids the introduction and training issues associated with new operators.<br>&gt;&gt; 	• Implicit Optional promotion cannot take place. You avoid mistaken usage like nonOptional ??? error and nonOptional ?? raise(error).<br>&gt;&gt; 	• As a StdLib method, autocompletion support is baked in.<br>&gt;&gt; Introducing a StdLib implementation of raise(ErrorType)<br>&gt;&gt; <br>&gt;&gt; Swift could introduce a raise(ErrorType) -&gt; T global function:<br>&gt;&gt; <br>&gt;&gt; func raise&lt;T&gt;(error: ErrorType) throws -&gt; T { throw error }<br>&gt;&gt; <br>&gt;&gt; do {<br>&gt;&gt;    let value = try Int(&quot;NotANumber&quot;) ?? raise(InitializerError.invalidString)<br>&gt;&gt;    print(&quot;Value&quot;, value)<br>&gt;&gt; } catch { print(error) }<br>&gt;&gt; <br>&gt;&gt; This is less than ideal:<br>&gt;&gt; <br>&gt;&gt; 	• This approach is similar to using &amp;&amp; as an if-true condition where an operator is abused for its side-effects.<br>&gt;&gt; 	• It is wordier than the operator approach.<br>&gt;&gt; 	• The error raising function promises to return a type but never will, which seems hackish.<br>&gt;&gt; Overriding ??<br>&gt;&gt; <br>&gt;&gt; We also considered overriding ?? to accept an error as a RHS argument. This introduces a new way to interpret ?? as meaning, &quot;throw this error instead of substituting this value&quot;.<br>&gt;&gt; <br>&gt;&gt; func ??&lt;T&gt;(lhs: T?, @autoclosure error: () -&gt; ErrorType) throws -&gt; T {<br>&gt;&gt;    guard case let value? = lhs else { throw error() }<br>&gt;&gt;    return value<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Usage:<br>&gt;&gt; <br>&gt;&gt; let value = try Int(&quot;NotANumber&quot;) ?? Error(reason: &quot;Invalid string passed to Integer initializer&quot;)<br>&gt;&gt; <br>&gt;&gt; This approach overloads the semantics as well as the syntax of the coalescing operator. Instead of falling back to a RHS value, it raises the RHS error. The code remains simple and readable although the developer must take care to clarify through comments and naming which version of the operator is being used.<br>&gt;&gt; <br>&gt;&gt; 	• While using try in the ?? statement signals that a throwing call is in use, it is insufficient (especially when used in a throwing scope) to distinguish between the normal coalescing and new error-throwing behaviors.<br>&gt;&gt; 	• Error types need not use the word &quot;Error&quot; in their construction or use. For example try value ?? e may not be immediately clear as an error-throwing intent.<br>&gt;&gt; 	• Overloading ?? dilutes the impact and meaning of the original operator intent.<br>&gt;&gt; Future Directions<br>&gt;&gt; <br>&gt;&gt; We briefly considered something along the lines of perl&#39;s die as an alternative to raise using fatalError.<br>&gt;&gt; <br>&gt;&gt; Acknowledgements<br>&gt;&gt; <br>&gt;&gt; Thanks Mike Ash, Jido, Dave Delong<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Pre-Draft] Nil-coalescing and errors</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>April  6, 2016 at 10:00:00am</p></header><div class="content"><p>I think I&#39;m with Sean on this one. Optionals and throwing don&#39;t have enough to do with each other to actually come up with a specific operator or method for this. I can&#39;t help but see this as two ideas glued together:<br></p><p>- &quot;By this point in my execution I need a non-optional value, otherwise ______&quot;<br>- &quot;_____ happened, therefore execution has failed and I should throw an error&quot;<br></p><p>…and I&#39;m not sure these ideas coincide enough to be worth gluing together. There are a lot of other ways to get a non-optional value out of an optional (&#39;??&#39;, &#39;!&#39;, and &#39;guard let&#39; with some other action), and there are a lot of other ways to fail besides an optional being nil (status code came back as error, unexpected data, connection timeout).<br></p><p>I&#39;d like to see some real-world examples of this before we did anything with it.<br></p><p>Jordan<br></p><p><br>&gt; On Apr 6, 2016, at 8:00, Sean Heber via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Interesting, but I’m unsure if all of it is significantly better than just using the guard that is effectively inside of the operator/func that is being proposed:<br>&gt; <br>&gt; guard let value = Int(&quot;NotANumber&quot;) else { throw InitializerError.invalidString }<br>&gt; <br>&gt; It is only a couple of characters longer and already works (it’s what I use currently). If guard allowed for a special single-expression variation so that you didn’t need to specify the ugly braces or something, it’d look prettier and be nice for a lot of other situations, too:<br>&gt; <br>&gt; guard let value = Int(&quot;NotANumber&quot;) else: throw InitializerError.invalidString<br>&gt; guard someVal &lt; 10 else: return false<br>&gt; guard mustBeTrue() else: return<br>&gt; // etc<br>&gt; <br>&gt; Not to derail this, but I sort of want this ability anywhere as a shorthand for a single-expression block.<br>&gt; <br>&gt; if something &lt; 42: doThing()<br>&gt; for a in list: print(a)<br>&gt; <br>&gt; But I imagine that’ll never fly. :P<br>&gt; <br>&gt; l8r<br>&gt; Sean<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Apr 6, 2016, at 9:46 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Pyry Jahkola and I have been plugging away on the following which is preliminary enough not to qualify as an actual draft. He prefers the Mike Ash approach. I prefer the operator approach. So we have not actually settled on which one we would actually propose despite how I&#39;ve written this up.<br>&gt;&gt; <br>&gt;&gt; I&#39;m putting this out there to try to gain a consensus on:<br>&gt;&gt; <br>&gt;&gt; * Would this be a viable proposal?<br>&gt;&gt; * If so, which of the options would work best within Swift&#39;s design and philosophy <br>&gt;&gt; <br>&gt;&gt; Thanks for your feedback.<br>&gt;&gt; <br>&gt;&gt; -- Erica<br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; Swift&#39;s try? keyword transforms error-throwing operations into optional values. We propose adding an error-throwing nil-coalescing operator to the Swift standard library. This operator will coerce optional results into Swift&#39;s error-handling system. <br>&gt;&gt; <br>&gt;&gt; This proposal was discussed on the Swift Evolution list in the name thread.<br>&gt;&gt; <br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; Any decision to expand Swift&#39;s set of standard operators should be taken thoughtfully and judiciously. Moving unaudited or deliberately non-error-handling nil-returning methods and failable initializers into Swift&#39;s error system should be a common enough use case to justify introducing a new operator.<br>&gt;&gt; <br>&gt;&gt; Detail Design<br>&gt;&gt; <br>&gt;&gt; We propose adding a new operator that works along the following lines:<br>&gt;&gt; <br>&gt;&gt; infix operator ??? {}<br>&gt;&gt; <br>&gt;&gt; func ???&lt;T&gt;(lhs: T?, @autoclosure error: () -&gt; ErrorType) throws -&gt; T {<br>&gt;&gt;    guard case let value? = lhs else { throw error() }<br>&gt;&gt;    return value<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; The use-case would look like this:<br>&gt;&gt; <br>&gt;&gt; do {<br>&gt;&gt;    let error = Error(reason: &quot;Invalid string passed to Integer initializer&quot;)<br>&gt;&gt;    let value = try Int(&quot;NotANumber&quot;) ??? InitializerError.invalidString<br>&gt;&gt;    print(&quot;Value&quot;, value)<br>&gt;&gt; } catch { print(error) }<br>&gt;&gt; <br>&gt;&gt; Note<br>&gt;&gt; <br>&gt;&gt; SE-0047 (warn unused result by default) and SE-0049 (move autoclosure) both affect many of the snippets in this proposal<br>&gt;&gt; <br>&gt;&gt; Disadvantages to this approach:<br>&gt;&gt; <br>&gt;&gt; 	• It consumes a new operator, which developers must be trained to use<br>&gt;&gt; 	• Unlike many other operators and specifically ??, this cannot be chained. There&#39;s no equivalent to a ?? b ?? c ?? dor a ?? (b ?? (c ?? d)).<br>&gt;&gt; Alternatives Considered<br>&gt;&gt; <br>&gt;&gt; Extending Optional<br>&gt;&gt; <br>&gt;&gt; The MikeAsh approach extends Optional to add an orThrow(ErrorType) method<br>&gt;&gt; <br>&gt;&gt; extension Optional {<br>&gt;&gt;    func orThrow(@autoclosure error: () -&gt; ErrorType) throws -&gt; Wrapped {<br>&gt;&gt;        guard case let value? = self else { throw error() }<br>&gt;&gt;        return value<br>&gt;&gt;    }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Usage looks like this:<br>&gt;&gt; <br>&gt;&gt; do {<br>&gt;&gt;    let value = try Int(&quot;NotANumber&quot;)<br>&gt;&gt;        .orThrow(InitializerError.invalidString)<br>&gt;&gt;    print(&quot;Value&quot;, value)<br>&gt;&gt; } catch { print(error) }<br>&gt;&gt; <br>&gt;&gt; An alternative version of this call looks like this: optionalValue.or(throw: error). I am not a fan of using a verb as a first statement label.<br>&gt;&gt; <br>&gt;&gt; Disadvantages:<br>&gt;&gt; <br>&gt;&gt; 	• Wordier than the operator, verging on claustrophobic, even using Swift&#39;s newline dot continuation.<br>&gt;&gt; 	• Reading the code can be confusing. This requires chaining rather than separating error throwing into a clear separate component. <br>&gt;&gt; Advantages:<br>&gt;&gt; <br>&gt;&gt; 	• No new operator, which maintains Swift operator parsimony and avoids the introduction and training issues associated with new operators.<br>&gt;&gt; 	• Implicit Optional promotion cannot take place. You avoid mistaken usage like nonOptional ??? error and nonOptional ?? raise(error).<br>&gt;&gt; 	• As a StdLib method, autocompletion support is baked in.<br>&gt;&gt; Introducing a StdLib implementation of raise(ErrorType)<br>&gt;&gt; <br>&gt;&gt; Swift could introduce a raise(ErrorType) -&gt; T global function:<br>&gt;&gt; <br>&gt;&gt; func raise&lt;T&gt;(error: ErrorType) throws -&gt; T { throw error }<br>&gt;&gt; <br>&gt;&gt; do {<br>&gt;&gt;    let value = try Int(&quot;NotANumber&quot;) ?? raise(InitializerError.invalidString)<br>&gt;&gt;    print(&quot;Value&quot;, value)<br>&gt;&gt; } catch { print(error) }<br>&gt;&gt; <br>&gt;&gt; This is less than ideal:<br>&gt;&gt; <br>&gt;&gt; 	• This approach is similar to using &amp;&amp; as an if-true condition where an operator is abused for its side-effects.<br>&gt;&gt; 	• It is wordier than the operator approach.<br>&gt;&gt; 	• The error raising function promises to return a type but never will, which seems hackish.<br>&gt;&gt; Overriding ??<br>&gt;&gt; <br>&gt;&gt; We also considered overriding ?? to accept an error as a RHS argument. This introduces a new way to interpret ?? as meaning, &quot;throw this error instead of substituting this value&quot;.<br>&gt;&gt; <br>&gt;&gt; func ??&lt;T&gt;(lhs: T?, @autoclosure error: () -&gt; ErrorType) throws -&gt; T {<br>&gt;&gt;    guard case let value? = lhs else { throw error() }<br>&gt;&gt;    return value<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Usage:<br>&gt;&gt; <br>&gt;&gt; let value = try Int(&quot;NotANumber&quot;) ?? Error(reason: &quot;Invalid string passed to Integer initializer&quot;)<br>&gt;&gt; <br>&gt;&gt; This approach overloads the semantics as well as the syntax of the coalescing operator. Instead of falling back to a RHS value, it raises the RHS error. The code remains simple and readable although the developer must take care to clarify through comments and naming which version of the operator is being used.<br>&gt;&gt; <br>&gt;&gt; 	• While using try in the ?? statement signals that a throwing call is in use, it is insufficient (especially when used in a throwing scope) to distinguish between the normal coalescing and new error-throwing behaviors.<br>&gt;&gt; 	• Error types need not use the word &quot;Error&quot; in their construction or use. For example try value ?? e may not be immediately clear as an error-throwing intent.<br>&gt;&gt; 	• Overloading ?? dilutes the impact and meaning of the original operator intent.<br>&gt;&gt; Future Directions<br>&gt;&gt; <br>&gt;&gt; We briefly considered something along the lines of perl&#39;s die as an alternative to raise using fatalError.<br>&gt;&gt; <br>&gt;&gt; Acknowledgements<br>&gt;&gt; <br>&gt;&gt; Thanks Mike Ash, Jido, Dave Delong<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/d31d05e9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Pre-Draft] Nil-coalescing and errors</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>April  7, 2016 at 09:00:00am</p></header><div class="content"><p>Personally I would like Optional to gain `ifNil` (`??` would call<br>`ifNil`) and `ifNilThrow`, both of which have an auto closure argument<br>returning a value and throwing respectively. This would save adding an<br>extra operator and allow chaining to read better than `??` in some<br>circumstances, like when trailing closures are used, e.g:<br></p><p>    let value = array.map { ... }<br>                             .filter { ... }<br>                             .firstElement<br>                             .ifNil { ... }<br></p><p>Reads better than:<br></p><p>    let value = array.map { ... }<br>                             .filter { ... }<br>                             .firstElement ?? { ... }<br></p><p>Because the `??` tends to vanish and it looks like firstElement has a<br>trailing closure.<br></p><p>On Thursday, 7 April 2016, Jordan Rose via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I think I&#39;m with Sean on this one. Optionals and throwing don&#39;t have<br>&gt; enough to do with each other to actually come up with a specific operator<br>&gt; or method for this. I can&#39;t help but see this as two ideas glued together:<br>&gt;<br>&gt; - &quot;By this point in my execution I need a non-optional value, otherwise<br>&gt; ______&quot;<br>&gt; - &quot;_____ happened, therefore execution has failed and I should throw an<br>&gt; error&quot;<br>&gt;<br>&gt; …and I&#39;m not sure these ideas coincide enough to be *worth* gluing<br>&gt; together. There are a lot of other ways to get a non-optional value out of<br>&gt; an optional (&#39;??&#39;, &#39;!&#39;, and &#39;guard let&#39; with some other action), and there<br>&gt; are a lot of other ways to fail besides an optional being nil (status code<br>&gt; came back as error, unexpected data, connection timeout).<br>&gt;<br>&gt; I&#39;d like to see some real-world examples of this before we did anything<br>&gt; with it.<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt;<br>&gt; On Apr 6, 2016, at 8:00, Sean Heber via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt; Interesting, but I’m unsure if all of it is significantly better than just<br>&gt; using the guard that is effectively inside of the operator/func that is<br>&gt; being proposed:<br>&gt;<br>&gt; guard let value = Int(&quot;NotANumber&quot;) else { throw<br>&gt; InitializerError.invalidString }<br>&gt;<br>&gt; It is only a couple of characters longer and already works (it’s what I<br>&gt; use currently). If guard allowed for a special single-expression variation<br>&gt; so that you didn’t need to specify the ugly braces or something, it’d look<br>&gt; prettier and be nice for a lot of other situations, too:<br>&gt;<br>&gt; guard let value = Int(&quot;NotANumber&quot;) else: throw<br>&gt; InitializerError.invalidString<br>&gt; guard someVal &lt; 10 else: return false<br>&gt; guard mustBeTrue() else: return<br>&gt; // etc<br>&gt;<br>&gt; Not to derail this, but I sort of want this ability anywhere as a<br>&gt; shorthand for a single-expression block.<br>&gt;<br>&gt; if something &lt; 42: doThing()<br>&gt; for a in list: print(a)<br>&gt;<br>&gt; But I imagine that’ll never fly. :P<br>&gt;<br>&gt; l8r<br>&gt; Sean<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Apr 6, 2016, at 9:46 AM, Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt; Pyry Jahkola and I have been plugging away on the following which is<br>&gt; preliminary enough not to qualify as an actual draft. He prefers the Mike<br>&gt; Ash approach. I prefer the operator approach. So we have not actually<br>&gt; settled on which one we would actually propose despite how I&#39;ve written<br>&gt; this up.<br>&gt;<br>&gt; I&#39;m putting this out there to try to gain a consensus on:<br>&gt;<br>&gt; * Would this be a viable proposal?<br>&gt; * If so, which of the options would work best within Swift&#39;s design and<br>&gt; philosophy<br>&gt;<br>&gt; Thanks for your feedback.<br>&gt;<br>&gt; -- Erica<br>&gt; Introduction<br>&gt;<br>&gt; Swift&#39;s try? keyword transforms error-throwing operations into optional<br>&gt; values. We propose adding an error-throwing nil-coalescing operator to the<br>&gt; Swift standard library. This operator will coerce optional results into<br>&gt; Swift&#39;s error-handling system.<br>&gt;<br>&gt; This proposal was discussed on the Swift Evolution list in the name thread.<br>&gt;<br>&gt; Motivation<br>&gt;<br>&gt; Any decision to expand Swift&#39;s set of standard operators should be taken<br>&gt; thoughtfully and judiciously. Moving unaudited or deliberately<br>&gt; non-error-handling nil-returning methods and failable initializers into<br>&gt; Swift&#39;s error system should be a common enough use case to justify<br>&gt; introducing a new operator.<br>&gt;<br>&gt; Detail Design<br>&gt;<br>&gt; We propose adding a new operator that works along the following lines:<br>&gt;<br>&gt; infix operator ??? {}<br>&gt;<br>&gt; func ???&lt;T&gt;(lhs: T?, @autoclosure error: () -&gt; ErrorType) throws -&gt; T {<br>&gt;    guard case let value? = lhs else { throw error() }<br>&gt;    return value<br>&gt; }<br>&gt;<br>&gt; The use-case would look like this:<br>&gt;<br>&gt; do {<br>&gt;    let error = Error(reason: &quot;Invalid string passed to Integer<br>&gt; initializer&quot;)<br>&gt;    let value = try Int(&quot;NotANumber&quot;) ??? InitializerError.invalidString<br>&gt;    print(&quot;Value&quot;, value)<br>&gt; } catch { print(error) }<br>&gt;<br>&gt; Note<br>&gt;<br>&gt; SE-0047 (warn unused result by default) and SE-0049 (move autoclosure)<br>&gt; both affect many of the snippets in this proposal<br>&gt;<br>&gt; Disadvantages to this approach:<br>&gt;<br>&gt; • It consumes a new operator, which developers must be trained to use<br>&gt; • Unlike many other operators and specifically ??, this cannot be chained.<br>&gt; There&#39;s no equivalent to a ?? b ?? c ?? dor a ?? (b ?? (c ?? d)).<br>&gt; Alternatives Considered<br>&gt;<br>&gt; Extending Optional<br>&gt;<br>&gt; The MikeAsh approach extends Optional to add an orThrow(ErrorType) method<br>&gt;<br>&gt; extension Optional {<br>&gt;    func orThrow(@autoclosure error: () -&gt; ErrorType) throws -&gt; Wrapped {<br>&gt;        guard case let value? = self else { throw error() }<br>&gt;        return value<br>&gt;    }<br>&gt; }<br>&gt;<br>&gt; Usage looks like this:<br>&gt;<br>&gt; do {<br>&gt;    let value = try Int(&quot;NotANumber&quot;)<br>&gt;        .orThrow(InitializerError.invalidString)<br>&gt;    print(&quot;Value&quot;, value)<br>&gt; } catch { print(error) }<br>&gt;<br>&gt; An alternative version of this call looks like this:<br>&gt; optionalValue.or(throw: error). I am not a fan of using a verb as a first<br>&gt; statement label.<br>&gt;<br>&gt; Disadvantages:<br>&gt;<br>&gt; • Wordier than the operator, verging on claustrophobic, even using Swift&#39;s<br>&gt; newline dot continuation.<br>&gt; • Reading the code can be confusing. This requires chaining rather than<br>&gt; separating error throwing into a clear separate component.<br>&gt; Advantages:<br>&gt;<br>&gt; • No new operator, which maintains Swift operator parsimony and avoids the<br>&gt; introduction and training issues associated with new operators.<br>&gt; • Implicit Optional promotion cannot take place. You avoid mistaken usage<br>&gt; like nonOptional ??? error and nonOptional ?? raise(error).<br>&gt; • As a StdLib method, autocompletion support is baked in.<br>&gt; Introducing a StdLib implementation of raise(ErrorType)<br>&gt;<br>&gt; Swift could introduce a raise(ErrorType) -&gt; T global function:<br>&gt;<br>&gt; func raise&lt;T&gt;(error: ErrorType) throws -&gt; T { throw error }<br>&gt;<br>&gt; do {<br>&gt;    let value = try Int(&quot;NotANumber&quot;) ??<br>&gt; raise(InitializerError.invalidString)<br>&gt;    print(&quot;Value&quot;, value)<br>&gt; } catch { print(error) }<br>&gt;<br>&gt; This is less than ideal:<br>&gt;<br>&gt; • This approach is similar to using &amp;&amp; as an if-true condition where an<br>&gt; operator is abused for its side-effects.<br>&gt; • It is wordier than the operator approach.<br>&gt; • The error raising function promises to return a type but never will,<br>&gt; which seems hackish.<br>&gt; Overriding ??<br>&gt;<br>&gt; We also considered overriding ?? to accept an error as a RHS argument.<br>&gt; This introduces a new way to interpret ?? as meaning, &quot;throw this error<br>&gt; instead of substituting this value&quot;.<br>&gt;<br>&gt; func ??&lt;T&gt;(lhs: T?, @autoclosure error: () -&gt; ErrorType) throws -&gt; T {<br>&gt;    guard case let value? = lhs else { throw error() }<br>&gt;    return value<br>&gt; }<br>&gt;<br>&gt; Usage:<br>&gt;<br>&gt; let value = try Int(&quot;NotANumber&quot;) ?? Error(reason: &quot;Invalid string passed<br>&gt; to Integer initializer&quot;)<br>&gt;<br>&gt; This approach overloads the semantics as well as the syntax of the<br>&gt; coalescing operator. Instead of falling back to a RHS value, it raises the<br>&gt; RHS error. The code remains simple and readable although the developer must<br>&gt; take care to clarify through comments and naming which version of the<br>&gt; operator is being used.<br>&gt;<br>&gt; • While using try in the ?? statement signals that a throwing call is in<br>&gt; use, it is insufficient (especially when used in a throwing scope) to<br>&gt; distinguish between the normal coalescing and new error-throwing behaviors.<br>&gt; • Error types need not use the word &quot;Error&quot; in their construction or use.<br>&gt; For example try value ?? e may not be immediately clear as an<br>&gt; error-throwing intent.<br>&gt; • Overloading ?? dilutes the impact and meaning of the original operator<br>&gt; intent.<br>&gt; Future Directions<br>&gt;<br>&gt; We briefly considered something along the lines of perl&#39;s die as an<br>&gt; alternative to raise using fatalError.<br>&gt;<br>&gt; Acknowledgements<br>&gt;<br>&gt; Thanks Mike Ash, Jido, Dave Delong<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br></p><p>-- <br>-- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160407/7ccfd746/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c031541ed3d92869414857dfef853de?s=50"></div><header><strong>[Pre-Draft] Nil-coalescing and errors</strong> from <string>Yuta Koshizawa</string> &lt;koher at koherent.org&gt;<p>April  7, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; I&#39;d like to see some real-world examples of this before we did anything with it.<br></p><p>The following is my real-world example.<br></p><p>```<br>// Decodes a JSON with SwiftyJSON<br>do {<br>  let person: Person = try Person(<br>    firstName: json[&quot;firstName&quot;].string ??? Error(),<br>    lastName: json[&quot;lastName&quot;].string ??? Error(),<br>    age: json[&quot;age&quot;].int ??? Error()<br>  )<br>} catch _ {<br>  // Error handling<br>}<br>```<br></p><p>With `guard`, we have to repeat the parameter names meaninglessly.<br></p><p>```<br>do {<br>    guard let firstName = json[&quot;firstName&quot;].string else { throw Error() }<br>    guard let lastName = json[&quot;lastName&quot;].string else { throw Error() }<br>    guard let age = json[&quot;age&quot;].string else { throw Error() }<br>    let person: Person = Person(firstName: firstName, lastName:<br>lastName, age: age)<br>} catch _ {<br>  // Error handling<br>}<br>```<br></p><p>`guard` is a statement. `???` makes an expression. Expressions are<br>useful when we want to pass their return values as arguments directly.<br>I think `???` is valuable to get an unwrapped value or throw an error<br>as an expression.<br></p><p>-- Yuta<br></p><p>2016-04-07 2:45 GMT+09:00 Jordan Rose via swift-evolution<br>&lt;swift-evolution at swift.org&gt;:<br>&gt; I think I&#39;m with Sean on this one. Optionals and throwing don&#39;t have enough<br>&gt; to do with each other to actually come up with a specific operator or method<br>&gt; for this. I can&#39;t help but see this as two ideas glued together:<br>&gt;<br>&gt; - &quot;By this point in my execution I need a non-optional value, otherwise<br>&gt; ______&quot;<br>&gt; - &quot;_____ happened, therefore execution has failed and I should throw an<br>&gt; error&quot;<br>&gt;<br>&gt; …and I&#39;m not sure these ideas coincide enough to be worth gluing together.<br>&gt; There are a lot of other ways to get a non-optional value out of an optional<br>&gt; (&#39;??&#39;, &#39;!&#39;, and &#39;guard let&#39; with some other action), and there are a lot of<br>&gt; other ways to fail besides an optional being nil (status code came back as<br>&gt; error, unexpected data, connection timeout).<br>&gt;<br>&gt; I&#39;d like to see some real-world examples of this before we did anything with<br>&gt; it.<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt;<br>&gt; On Apr 6, 2016, at 8:00, Sean Heber via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Interesting, but I’m unsure if all of it is significantly better than just<br>&gt; using the guard that is effectively inside of the operator/func that is<br>&gt; being proposed:<br>&gt;<br>&gt; guard let value = Int(&quot;NotANumber&quot;) else { throw<br>&gt; InitializerError.invalidString }<br>&gt;<br>&gt; It is only a couple of characters longer and already works (it’s what I use<br>&gt; currently). If guard allowed for a special single-expression variation so<br>&gt; that you didn’t need to specify the ugly braces or something, it’d look<br>&gt; prettier and be nice for a lot of other situations, too:<br>&gt;<br>&gt; guard let value = Int(&quot;NotANumber&quot;) else: throw<br>&gt; InitializerError.invalidString<br>&gt; guard someVal &lt; 10 else: return false<br>&gt; guard mustBeTrue() else: return<br>&gt; // etc<br>&gt;<br>&gt; Not to derail this, but I sort of want this ability anywhere as a shorthand<br>&gt; for a single-expression block.<br>&gt;<br>&gt; if something &lt; 42: doThing()<br>&gt; for a in list: print(a)<br>&gt;<br>&gt; But I imagine that’ll never fly. :P<br>&gt;<br>&gt; l8r<br>&gt; Sean<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Apr 6, 2016, at 9:46 AM, Erica Sadun via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Pyry Jahkola and I have been plugging away on the following which is<br>&gt; preliminary enough not to qualify as an actual draft. He prefers the Mike<br>&gt; Ash approach. I prefer the operator approach. So we have not actually<br>&gt; settled on which one we would actually propose despite how I&#39;ve written this<br>&gt; up.<br>&gt;<br>&gt; I&#39;m putting this out there to try to gain a consensus on:<br>&gt;<br>&gt; * Would this be a viable proposal?<br>&gt; * If so, which of the options would work best within Swift&#39;s design and<br>&gt; philosophy<br>&gt;<br>&gt; Thanks for your feedback.<br>&gt;<br>&gt; -- Erica<br>&gt; Introduction<br>&gt;<br>&gt; Swift&#39;s try? keyword transforms error-throwing operations into optional<br>&gt; values. We propose adding an error-throwing nil-coalescing operator to the<br>&gt; Swift standard library. This operator will coerce optional results into<br>&gt; Swift&#39;s error-handling system.<br>&gt;<br>&gt; This proposal was discussed on the Swift Evolution list in the name thread.<br>&gt;<br>&gt; Motivation<br>&gt;<br>&gt; Any decision to expand Swift&#39;s set of standard operators should be taken<br>&gt; thoughtfully and judiciously. Moving unaudited or deliberately<br>&gt; non-error-handling nil-returning methods and failable initializers into<br>&gt; Swift&#39;s error system should be a common enough use case to justify<br>&gt; introducing a new operator.<br>&gt;<br>&gt; Detail Design<br>&gt;<br>&gt; We propose adding a new operator that works along the following lines:<br>&gt;<br>&gt; infix operator ??? {}<br>&gt;<br>&gt; func ???&lt;T&gt;(lhs: T?, @autoclosure error: () -&gt; ErrorType) throws -&gt; T {<br>&gt;    guard case let value? = lhs else { throw error() }<br>&gt;    return value<br>&gt; }<br>&gt;<br>&gt; The use-case would look like this:<br>&gt;<br>&gt; do {<br>&gt;    let error = Error(reason: &quot;Invalid string passed to Integer initializer&quot;)<br>&gt;    let value = try Int(&quot;NotANumber&quot;) ??? InitializerError.invalidString<br>&gt;    print(&quot;Value&quot;, value)<br>&gt; } catch { print(error) }<br>&gt;<br>&gt; Note<br>&gt;<br>&gt; SE-0047 (warn unused result by default) and SE-0049 (move autoclosure) both<br>&gt; affect many of the snippets in this proposal<br>&gt;<br>&gt; Disadvantages to this approach:<br>&gt;<br>&gt; • It consumes a new operator, which developers must be trained to use<br>&gt; • Unlike many other operators and specifically ??, this cannot be chained.<br>&gt; There&#39;s no equivalent to a ?? b ?? c ?? dor a ?? (b ?? (c ?? d)).<br>&gt; Alternatives Considered<br>&gt;<br>&gt; Extending Optional<br>&gt;<br>&gt; The MikeAsh approach extends Optional to add an orThrow(ErrorType) method<br>&gt;<br>&gt; extension Optional {<br>&gt;    func orThrow(@autoclosure error: () -&gt; ErrorType) throws -&gt; Wrapped {<br>&gt;        guard case let value? = self else { throw error() }<br>&gt;        return value<br>&gt;    }<br>&gt; }<br>&gt;<br>&gt; Usage looks like this:<br>&gt;<br>&gt; do {<br>&gt;    let value = try Int(&quot;NotANumber&quot;)<br>&gt;        .orThrow(InitializerError.invalidString)<br>&gt;    print(&quot;Value&quot;, value)<br>&gt; } catch { print(error) }<br>&gt;<br>&gt; An alternative version of this call looks like this: optionalValue.or(throw:<br>&gt; error). I am not a fan of using a verb as a first statement label.<br>&gt;<br>&gt; Disadvantages:<br>&gt;<br>&gt; • Wordier than the operator, verging on claustrophobic, even using Swift&#39;s<br>&gt; newline dot continuation.<br>&gt; • Reading the code can be confusing. This requires chaining rather than<br>&gt; separating error throwing into a clear separate component.<br>&gt; Advantages:<br>&gt;<br>&gt; • No new operator, which maintains Swift operator parsimony and avoids the<br>&gt; introduction and training issues associated with new operators.<br>&gt; • Implicit Optional promotion cannot take place. You avoid mistaken usage<br>&gt; like nonOptional ??? error and nonOptional ?? raise(error).<br>&gt; • As a StdLib method, autocompletion support is baked in.<br>&gt; Introducing a StdLib implementation of raise(ErrorType)<br>&gt;<br>&gt; Swift could introduce a raise(ErrorType) -&gt; T global function:<br>&gt;<br>&gt; func raise&lt;T&gt;(error: ErrorType) throws -&gt; T { throw error }<br>&gt;<br>&gt; do {<br>&gt;    let value = try Int(&quot;NotANumber&quot;) ??<br>&gt; raise(InitializerError.invalidString)<br>&gt;    print(&quot;Value&quot;, value)<br>&gt; } catch { print(error) }<br>&gt;<br>&gt; This is less than ideal:<br>&gt;<br>&gt; • This approach is similar to using &amp;&amp; as an if-true condition where an<br>&gt; operator is abused for its side-effects.<br>&gt; • It is wordier than the operator approach.<br>&gt; • The error raising function promises to return a type but never will, which<br>&gt; seems hackish.<br>&gt; Overriding ??<br>&gt;<br>&gt; We also considered overriding ?? to accept an error as a RHS argument. This<br>&gt; introduces a new way to interpret ?? as meaning, &quot;throw this error instead<br>&gt; of substituting this value&quot;.<br>&gt;<br>&gt; func ??&lt;T&gt;(lhs: T?, @autoclosure error: () -&gt; ErrorType) throws -&gt; T {<br>&gt;    guard case let value? = lhs else { throw error() }<br>&gt;    return value<br>&gt; }<br>&gt;<br>&gt; Usage:<br>&gt;<br>&gt; let value = try Int(&quot;NotANumber&quot;) ?? Error(reason: &quot;Invalid string passed to<br>&gt; Integer initializer&quot;)<br>&gt;<br>&gt; This approach overloads the semantics as well as the syntax of the<br>&gt; coalescing operator. Instead of falling back to a RHS value, it raises the<br>&gt; RHS error. The code remains simple and readable although the developer must<br>&gt; take care to clarify through comments and naming which version of the<br>&gt; operator is being used.<br>&gt;<br>&gt; • While using try in the ?? statement signals that a throwing call is in<br>&gt; use, it is insufficient (especially when used in a throwing scope) to<br>&gt; distinguish between the normal coalescing and new error-throwing behaviors.<br>&gt; • Error types need not use the word &quot;Error&quot; in their construction or use.<br>&gt; For example try value ?? e may not be immediately clear as an error-throwing<br>&gt; intent.<br>&gt; • Overloading ?? dilutes the impact and meaning of the original operator<br>&gt; intent.<br>&gt; Future Directions<br>&gt;<br>&gt; We briefly considered something along the lines of perl&#39;s die as an<br>&gt; alternative to raise using fatalError.<br>&gt;<br>&gt; Acknowledgements<br>&gt;<br>&gt; Thanks Mike Ash, Jido, Dave Delong<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Pre-Draft] Nil-coalescing and errors</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>April  7, 2016 at 08:00:00am</p></header><div class="content"><p>I agree with Sean, I ready use guard and don&#39;t see much use in a StdLib or operator alternative.<br></p><p>Sent from my iPad<br></p><p>&gt; On 06 Apr 2016, at 17:00, Sean Heber via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Interesting, but I’m unsure if all of it is significantly better than just using the guard that is effectively inside of the operator/func that is being proposed:<br>&gt; <br>&gt; guard let value = Int(&quot;NotANumber&quot;) else { throw InitializerError.invalidString }<br>&gt; <br>&gt; It is only a couple of characters longer and already works (it’s what I use currently). If guard allowed for a special single-expression variation so that you didn’t need to specify the ugly braces or something, it’d look prettier and be nice for a lot of other situations, too:<br>&gt; <br>&gt; guard let value = Int(&quot;NotANumber&quot;) else: throw InitializerError.invalidString<br>&gt; guard someVal &lt; 10 else: return false<br>&gt; guard mustBeTrue() else: return<br>&gt; // etc<br>&gt; <br>&gt; Not to derail this, but I sort of want this ability anywhere as a shorthand for a single-expression block.<br>&gt; <br>&gt; if something &lt; 42: doThing()<br>&gt; for a in list: print(a)<br>&gt; <br>&gt; But I imagine that’ll never fly. :P<br>&gt; <br>&gt; l8r<br>&gt; Sean<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Apr 6, 2016, at 9:46 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Pyry Jahkola and I have been plugging away on the following which is preliminary enough not to qualify as an actual draft. He prefers the Mike Ash approach. I prefer the operator approach. So we have not actually settled on which one we would actually propose despite how I&#39;ve written this up.<br>&gt;&gt; <br>&gt;&gt; I&#39;m putting this out there to try to gain a consensus on:<br>&gt;&gt; <br>&gt;&gt; * Would this be a viable proposal?<br>&gt;&gt; * If so, which of the options would work best within Swift&#39;s design and philosophy <br>&gt;&gt; <br>&gt;&gt; Thanks for your feedback.<br>&gt;&gt; <br>&gt;&gt; -- Erica<br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; Swift&#39;s try? keyword transforms error-throwing operations into optional values. We propose adding an error-throwing nil-coalescing operator to the Swift standard library. This operator will coerce optional results into Swift&#39;s error-handling system. <br>&gt;&gt; <br>&gt;&gt; This proposal was discussed on the Swift Evolution list in the name thread.<br>&gt;&gt; <br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; Any decision to expand Swift&#39;s set of standard operators should be taken thoughtfully and judiciously. Moving unaudited or deliberately non-error-handling nil-returning methods and failable initializers into Swift&#39;s error system should be a common enough use case to justify introducing a new operator.<br>&gt;&gt; <br>&gt;&gt; Detail Design<br>&gt;&gt; <br>&gt;&gt; We propose adding a new operator that works along the following lines:<br>&gt;&gt; <br>&gt;&gt; infix operator ??? {}<br>&gt;&gt; <br>&gt;&gt; func ???&lt;T&gt;(lhs: T?, @autoclosure error: () -&gt; ErrorType) throws -&gt; T {<br>&gt;&gt;    guard case let value? = lhs else { throw error() }<br>&gt;&gt;    return value<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; The use-case would look like this:<br>&gt;&gt; <br>&gt;&gt; do {<br>&gt;&gt;    let error = Error(reason: &quot;Invalid string passed to Integer initializer&quot;)<br>&gt;&gt;    let value = try Int(&quot;NotANumber&quot;) ??? InitializerError.invalidString<br>&gt;&gt;    print(&quot;Value&quot;, value)<br>&gt;&gt; } catch { print(error) }<br>&gt;&gt; <br>&gt;&gt; Note<br>&gt;&gt; <br>&gt;&gt; SE-0047 (warn unused result by default) and SE-0049 (move autoclosure) both affect many of the snippets in this proposal<br>&gt;&gt; <br>&gt;&gt; Disadvantages to this approach:<br>&gt;&gt; <br>&gt;&gt;    • It consumes a new operator, which developers must be trained to use<br>&gt;&gt;    • Unlike many other operators and specifically ??, this cannot be chained. There&#39;s no equivalent to a ?? b ?? c ?? dor a ?? (b ?? (c ?? d)).<br>&gt;&gt; Alternatives Considered<br>&gt;&gt; <br>&gt;&gt; Extending Optional<br>&gt;&gt; <br>&gt;&gt; The MikeAsh approach extends Optional to add an orThrow(ErrorType) method<br>&gt;&gt; <br>&gt;&gt; extension Optional {<br>&gt;&gt;    func orThrow(@autoclosure error: () -&gt; ErrorType) throws -&gt; Wrapped {<br>&gt;&gt;        guard case let value? = self else { throw error() }<br>&gt;&gt;        return value<br>&gt;&gt;    }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Usage looks like this:<br>&gt;&gt; <br>&gt;&gt; do {<br>&gt;&gt;    let value = try Int(&quot;NotANumber&quot;)<br>&gt;&gt;        .orThrow(InitializerError.invalidString)<br>&gt;&gt;    print(&quot;Value&quot;, value)<br>&gt;&gt; } catch { print(error) }<br>&gt;&gt; <br>&gt;&gt; An alternative version of this call looks like this: optionalValue.or(throw: error). I am not a fan of using a verb as a first statement label.<br>&gt;&gt; <br>&gt;&gt; Disadvantages:<br>&gt;&gt; <br>&gt;&gt;    • Wordier than the operator, verging on claustrophobic, even using Swift&#39;s newline dot continuation.<br>&gt;&gt;    • Reading the code can be confusing. This requires chaining rather than separating error throwing into a clear separate component. <br>&gt;&gt; Advantages:<br>&gt;&gt; <br>&gt;&gt;    • No new operator, which maintains Swift operator parsimony and avoids the introduction and training issues associated with new operators.<br>&gt;&gt;    • Implicit Optional promotion cannot take place. You avoid mistaken usage like nonOptional ??? error and nonOptional ?? raise(error).<br>&gt;&gt;    • As a StdLib method, autocompletion support is baked in.<br>&gt;&gt; Introducing a StdLib implementation of raise(ErrorType)<br>&gt;&gt; <br>&gt;&gt; Swift could introduce a raise(ErrorType) -&gt; T global function:<br>&gt;&gt; <br>&gt;&gt; func raise&lt;T&gt;(error: ErrorType) throws -&gt; T { throw error }<br>&gt;&gt; <br>&gt;&gt; do {<br>&gt;&gt;    let value = try Int(&quot;NotANumber&quot;) ?? raise(InitializerError.invalidString)<br>&gt;&gt;    print(&quot;Value&quot;, value)<br>&gt;&gt; } catch { print(error) }<br>&gt;&gt; <br>&gt;&gt; This is less than ideal:<br>&gt;&gt; <br>&gt;&gt;    • This approach is similar to using &amp;&amp; as an if-true condition where an operator is abused for its side-effects.<br>&gt;&gt;    • It is wordier than the operator approach.<br>&gt;&gt;    • The error raising function promises to return a type but never will, which seems hackish.<br>&gt;&gt; Overriding ??<br>&gt;&gt; <br>&gt;&gt; We also considered overriding ?? to accept an error as a RHS argument. This introduces a new way to interpret ?? as meaning, &quot;throw this error instead of substituting this value&quot;.<br>&gt;&gt; <br>&gt;&gt; func ??&lt;T&gt;(lhs: T?, @autoclosure error: () -&gt; ErrorType) throws -&gt; T {<br>&gt;&gt;    guard case let value? = lhs else { throw error() }<br>&gt;&gt;    return value<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Usage:<br>&gt;&gt; <br>&gt;&gt; let value = try Int(&quot;NotANumber&quot;) ?? Error(reason: &quot;Invalid string passed to Integer initializer&quot;)<br>&gt;&gt; <br>&gt;&gt; This approach overloads the semantics as well as the syntax of the coalescing operator. Instead of falling back to a RHS value, it raises the RHS error. The code remains simple and readable although the developer must take care to clarify through comments and naming which version of the operator is being used.<br>&gt;&gt; <br>&gt;&gt;    • While using try in the ?? statement signals that a throwing call is in use, it is insufficient (especially when used in a throwing scope) to distinguish between the normal coalescing and new error-throwing behaviors.<br>&gt;&gt;    • Error types need not use the word &quot;Error&quot; in their construction or use. For example try value ?? e may not be immediately clear as an error-throwing intent.<br>&gt;&gt;    • Overloading ?? dilutes the impact and meaning of the original operator intent.<br>&gt;&gt; Future Directions<br>&gt;&gt; <br>&gt;&gt; We briefly considered something along the lines of perl&#39;s die as an alternative to raise using fatalError.<br>&gt;&gt; <br>&gt;&gt; Acknowledgements<br>&gt;&gt; <br>&gt;&gt; Thanks Mike Ash, Jido, Dave Delong<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c031541ed3d92869414857dfef853de?s=50"></div><header><strong>[Pre-Draft] Nil-coalescing and errors</strong> from <string>Yuta Koshizawa</string> &lt;koher at koherent.org&gt;<p>April  7, 2016 at 10:00:00am</p></header><div class="content"><p>I agree with this and I like the operator approach.<br></p><p>Besides the proposed infix `???`, I also want the postfix one which<br>throws a `NilError` (something like `struct NilError: ErrorType {}`).<br>It is useful to handle multiple `nil`s at once when we are not<br>interested in the kind of the error.<br></p><p>```<br>// Decodes a JSON with SwiftyJSON<br>do {<br>  let person: Person = try Person(<br>    firstName: json[&quot;firstName&quot;].string???,<br>    lastName: json[&quot;lastName&quot;].string???,<br>    age: json[&quot;age&quot;].int???<br>  )<br>} catch _ {<br>  // Error handling<br>}<br>```<br></p><p>Considering the postfix one, the operator approach for the infix one<br>is consistent.<br></p><p>One more thing; I think `???` is too long. Instead, I propose `|?`.<br>For `foo: Foo?`, `try foo|?` can be read like `Foo` or `nil`. It<br>separates (`|`) nil (`?`) from the value and return `Foo`. I think it<br>makes sense.<br></p><p>-- Yuta<br></p><p>2016-04-06 23:46 GMT+09:00 Erica Sadun via swift-evolution<br>&lt;swift-evolution at swift.org&gt;:<br>&gt; Pyry Jahkola and I have been plugging away on the following which is<br>&gt; preliminary enough not to qualify as an actual draft. He prefers the Mike<br>&gt; Ash approach. I prefer the operator approach. So we have not actually<br>&gt; settled on which one we would actually propose despite how I&#39;ve written this<br>&gt; up.<br>&gt;<br>&gt; I&#39;m putting this out there to try to gain a consensus on:<br>&gt;<br>&gt; * Would this be a viable proposal?<br>&gt; * If so, which of the options would work best within Swift&#39;s design and<br>&gt; philosophy<br>&gt;<br>&gt; Thanks for your feedback.<br>&gt;<br>&gt; -- Erica<br>&gt;<br>&gt; Introduction<br>&gt;<br>&gt; Swift&#39;s try? keyword transforms error-throwing operations into optional<br>&gt; values. We propose adding an error-throwing nil-coalescing operator to the<br>&gt; Swift standard library. This operator will coerce optional results into<br>&gt; Swift&#39;s error-handling system.<br>&gt;<br>&gt; This proposal was discussed on the Swift Evolution list in the name thread.<br>&gt;<br>&gt; Motivation<br>&gt;<br>&gt; Any decision to expand Swift&#39;s set of standard operators should be taken<br>&gt; thoughtfully and judiciously. Moving unaudited or deliberately<br>&gt; non-error-handling nil-returning methods and failable initializers into<br>&gt; Swift&#39;s error system should be a common enough use case to justify<br>&gt; introducing a new operator.<br>&gt;<br>&gt; Detail Design<br>&gt;<br>&gt; We propose adding a new operator that works along the following lines:<br>&gt;<br>&gt; infix operator ??? {}<br>&gt;<br>&gt; func ???&lt;T&gt;(lhs: T?, @autoclosure error: () -&gt; ErrorType) throws -&gt; T {<br>&gt;     guard case let value? = lhs else { throw error() }<br>&gt;     return value<br>&gt; }<br>&gt;<br>&gt; The use-case would look like this:<br>&gt;<br>&gt; do {<br>&gt;     let error = Error(reason: &quot;Invalid string passed to Integer<br>&gt; initializer&quot;)<br>&gt;     let value = try Int(&quot;NotANumber&quot;) ??? InitializerError.invalidString<br>&gt;     print(&quot;Value&quot;, value)<br>&gt; } catch { print(error) }<br>&gt;<br>&gt; Note<br>&gt;<br>&gt; SE-0047 (warn unused result by default) and SE-0049 (move autoclosure) both<br>&gt; affect many of the snippets in this proposal<br>&gt;<br>&gt; Disadvantages to this approach:<br>&gt;<br>&gt; It consumes a new operator, which developers must be trained to use<br>&gt; Unlike many other operators and specifically ??, this cannot be chained.<br>&gt; There&#39;s no equivalent to a ?? b ?? c ?? dor a ?? (b ?? (c ?? d)).<br>&gt;<br>&gt; Alternatives Considered<br>&gt;<br>&gt; Extending Optional<br>&gt;<br>&gt; The MikeAsh approach extends Optional to add an orThrow(ErrorType) method<br>&gt;<br>&gt; extension Optional {<br>&gt;     func orThrow(@autoclosure error: () -&gt; ErrorType) throws -&gt; Wrapped {<br>&gt;         guard case let value? = self else { throw error() }<br>&gt;         return value<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; Usage looks like this:<br>&gt;<br>&gt; do {<br>&gt;     let value = try Int(&quot;NotANumber&quot;)<br>&gt;         .orThrow(InitializerError.invalidString)<br>&gt;     print(&quot;Value&quot;, value)<br>&gt; } catch { print(error) }<br>&gt;<br>&gt; An alternative version of this call looks like this: optionalValue.or(throw:<br>&gt; error). I am not a fan of using a verb as a first statement label.<br>&gt;<br>&gt; Disadvantages:<br>&gt;<br>&gt; Wordier than the operator, verging on claustrophobic, even using Swift&#39;s<br>&gt; newline dot continuation.<br>&gt; Reading the code can be confusing. This requires chaining rather than<br>&gt; separating error throwing into a clear separate component.<br>&gt;<br>&gt; Advantages:<br>&gt;<br>&gt; No new operator, which maintains Swift operator parsimony and avoids the<br>&gt; introduction and training issues associated with new operators.<br>&gt; Implicit Optional promotion cannot take place. You avoid mistaken usage like<br>&gt; nonOptional ??? error and nonOptional ?? raise(error).<br>&gt; As a StdLib method, autocompletion support is baked in.<br>&gt;<br>&gt; Introducing a StdLib implementation of raise(ErrorType)<br>&gt;<br>&gt; Swift could introduce a raise(ErrorType) -&gt; T global function:<br>&gt;<br>&gt; func raise&lt;T&gt;(error: ErrorType) throws -&gt; T { throw error }<br>&gt;<br>&gt; do {<br>&gt;     let value = try Int(&quot;NotANumber&quot;) ??<br>&gt; raise(InitializerError.invalidString)<br>&gt;     print(&quot;Value&quot;, value)<br>&gt; } catch { print(error) }<br>&gt;<br>&gt; This is less than ideal:<br>&gt;<br>&gt; This approach is similar to using &amp;&amp; as an if-true condition where an<br>&gt; operator is abused for its side-effects.<br>&gt; It is wordier than the operator approach.<br>&gt; The error raising function promises to return a type but never will, which<br>&gt; seems hackish.<br>&gt;<br>&gt; Overriding ??<br>&gt;<br>&gt; We also considered overriding ?? to accept an error as a RHS argument. This<br>&gt; introduces a new way to interpret ?? as meaning, &quot;throw this error instead<br>&gt; of substituting this value&quot;.<br>&gt;<br>&gt; func ??&lt;T&gt;(lhs: T?, @autoclosure error: () -&gt; ErrorType) throws -&gt; T {<br>&gt;     guard case let value? = lhs else { throw error() }<br>&gt;     return value<br>&gt; }<br>&gt;<br>&gt; Usage:<br>&gt;<br>&gt; let value = try Int(&quot;NotANumber&quot;) ?? Error(reason: &quot;Invalid string passed to<br>&gt; Integer initializer&quot;)<br>&gt;<br>&gt; This approach overloads the semantics as well as the syntax of the<br>&gt; coalescing operator. Instead of falling back to a RHS value, it raises the<br>&gt; RHS error. The code remains simple and readable although the developer must<br>&gt; take care to clarify through comments and naming which version of the<br>&gt; operator is being used.<br>&gt;<br>&gt; While using try in the ?? statement signals that a throwing call is in use,<br>&gt; it is insufficient (especially when used in a throwing scope) to distinguish<br>&gt; between the normal coalescing and new error-throwing behaviors.<br>&gt; Error types need not use the word &quot;Error&quot; in their construction or use. For<br>&gt; example try value ?? e may not be immediately clear as an error-throwing<br>&gt; intent.<br>&gt; Overloading ?? dilutes the impact and meaning of the original operator<br>&gt; intent.<br>&gt;<br>&gt; Future Directions<br>&gt;<br>&gt; We briefly considered something along the lines of perl&#39;s die as an<br>&gt; alternative to raise using fatalError.<br>&gt;<br>&gt; Acknowledgements<br>&gt;<br>&gt; Thanks Mike Ash, Jido, Dave Delong<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7abf2ce34651dd5e97cd97b16ce21bae?s=50"></div><header><strong>[Pre-Draft] Nil-coalescing and errors</strong> from <string>Guillaume Lessard</string> &lt;glessard at tffenterprises.com&gt;<p>April  7, 2016 at 10:00:00am</p></header><div class="content"><p>A different direction would be to add a non-autoclosure variant to ?? that explicitly takes a closure.<br></p><p>public func ??&lt;T&gt;(optional: T?, defaultValue: () throws -&gt; T) rethrows -&gt; T {<br>  switch optional {<br>  case .Some(let wrapped): return wrapped<br>  case .None: return try defaultValue()<br>  }<br>}<br></p><p>Then, the following works:<br></p><p>var v = Optional(7)<br>// v = nil<br>do {<br>  let i = try v ?? { throw NSError(domain: &quot;&quot;, code: 0, userInfo: [:]) }<br>  print(i)<br>}<br>catch {<br>  print(error)<br>}<br></p><p><br>Or, even more generally, allow functions and operators that take autoclosure parameters to be used with explicit closures? I shrugged my shoulders and wrote an overload when I hit that limitation, but I wonder whether it is necessary.<br></p><p>Cheers,<br>Guillaume Lessard<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
