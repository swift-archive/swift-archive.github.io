<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Pitch] Rename `x.dynamicType` to `x.Self`</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>April 13, 2016 at 06:00:00pm</p></header><div class="content"><p>It&#39;s been pitched before, but I don&#39;t think we&#39;ve had a dedicated thread to this idea. Erica has proposed making `Self` generally available within methods in types to refer to the dynamic type of the current receiver. One could think of `Self` as a special associated type member that exists in every type for this purpose. This also happens to be what you get when ask for the `dynamicType` member of a value. We could unify these concepts and get rid of the clunky `dynamicType` keyword, replacing it with `x.Self`.<br></p><p>There&#39;s another benefit to this syntax change. Looking to the future, one of the many features Doug pitched in his generics manifesto was to generalize protocol existentials, lifting our current restrictions on protocols &quot;with Self or associated types&quot; and allowing them to be used as dynamic types in addition to static generic constraints. Once you do this, you often want to &quot;open&quot; the type of the existential, so that you can refer to its Self and associated types in the types of other values. I think a natural way would be to let you directly use Self and associated type members of existentials as types themselves, for example:<br></p><p>	let a: Equatable = /*...*/<br>	let b: Equatable = /*...*/<br></p><p>	// This is not allowed, since Equatable requires two values with the same static type, but<br>	// a and b may have different dynamic types.<br>	a == b <br></p><p>	// However, we can dynamically cast one to the other&#39;s dynamic type:<br>	if let bAsA = b as? a.Self {<br>		return a == bAsA<br>	}<br></p><p>	let x: RangeReplaceableCollection = /*...*/<br>	let y: Collection = /*...*/<br></p><p>	// If y has the same dynamic Element type as x, append it to x<br>	var z: x.Self = x<br>	if let yAsX = y as? Any&lt;Collection where Element == x.Element&gt; {<br>		z.append(yAsX)<br>	}<br></p><p>`x.Self` then becomes just the first step in this direction.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b9904260218b6d7942782c2b2355f2aa?s=50"></div><header><strong>[Pitch] Rename `x.dynamicType` to `x.Self`</strong> from <string>William Dillon</string> &lt;william at housedillon.com&gt;<p>April 13, 2016 at 09:00:00pm</p></header><div class="content"><p>This would be great!<br></p><p>I use a nearly identical pattern in my networking framework that would be nice to streamline:<br></p><p>public func ==(lhs: NetworkAddress, rhs: NetworkAddress) -&gt; Bool {<br>    // Only addresses of the same protocol are considered equal.<br>    guard lhs.dynamicType == rhs.dynamicType else {<br>        return false<br>    }<br>    <br>    if lhs.dynamicType == IPv4NetworkAddress.self {<br>        return (lhs as! IPv4NetworkAddress) == (rhs as! IPv4NetworkAddress)<br>    }<br></p><p>    if lhs.dynamicType == IPv6NetworkAddress.self {<br>        return (lhs as! IPv6NetworkAddress) == (rhs as! IPv6NetworkAddress)<br>    }<br>    <br>    return false<br>}<br></p><p>- Will<br></p><p>&gt; On Apr 13, 2016, at 6:41 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; It&#39;s been pitched before, but I don&#39;t think we&#39;ve had a dedicated thread to this idea. Erica has proposed making `Self` generally available within methods in types to refer to the dynamic type of the current receiver. One could think of `Self` as a special associated type member that exists in every type for this purpose. This also happens to be what you get when ask for the `dynamicType` member of a value. We could unify these concepts and get rid of the clunky `dynamicType` keyword, replacing it with `x.Self`.<br>&gt; <br>&gt; There&#39;s another benefit to this syntax change. Looking to the future, one of the many features Doug pitched in his generics manifesto was to generalize protocol existentials, lifting our current restrictions on protocols &quot;with Self or associated types&quot; and allowing them to be used as dynamic types in addition to static generic constraints. Once you do this, you often want to &quot;open&quot; the type of the existential, so that you can refer to its Self and associated types in the types of other values. I think a natural way would be to let you directly use Self and associated type members of existentials as types themselves, for example:<br>&gt; <br>&gt; 	let a: Equatable = /*...*/<br>&gt; 	let b: Equatable = /*...*/<br>&gt; <br>&gt; 	// This is not allowed, since Equatable requires two values with the same static type, but<br>&gt; 	// a and b may have different dynamic types.<br>&gt; 	a == b <br>&gt; <br>&gt; 	// However, we can dynamically cast one to the other&#39;s dynamic type:<br>&gt; 	if let bAsA = b as? a.Self {<br>&gt; 		return a == bAsA<br>&gt; 	}<br>&gt; <br>&gt; 	let x: RangeReplaceableCollection = /*...*/<br>&gt; 	let y: Collection = /*...*/<br>&gt; <br>&gt; 	// If y has the same dynamic Element type as x, append it to x<br>&gt; 	var z: x.Self = x<br>&gt; 	if let yAsX = y as? Any&lt;Collection where Element == x.Element&gt; {<br>&gt; 		z.append(yAsX)<br>&gt; 	}<br>&gt; <br>&gt; `x.Self` then becomes just the first step in this direction.<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160413/e9f529c4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a32f0c9071fd24f75322395496dc6a32?s=50"></div><header><strong>[Pitch] Rename `x.dynamicType` to `x.Self`</strong> from <string>Eugene Gubin</string> &lt;hemet.mail at gmail.com&gt;<p>April 14, 2016 at 09:00:00am</p></header><div class="content"><p>I like this idea. I think, if we could use `self` to access instance of<br>self, we should be allowed to use `Self` to access type of self.<br></p><p>2016-04-14 8:46 GMT+04:00 William Dillon via swift-evolution &lt;<br>swift-evolution at swift.org&gt;:<br></p><p>&gt; This would be great!<br>&gt;<br>&gt; I use a nearly identical pattern in my networking framework that would be<br>&gt; nice to streamline:<br>&gt;<br>&gt; public func ==(lhs: NetworkAddress, rhs: NetworkAddress) -&gt; Bool {<br>&gt;     // Only addresses of the same protocol are considered equal.<br>&gt;     guard lhs.dynamicType == rhs.dynamicType else {<br>&gt;         return false<br>&gt;     }<br>&gt;<br>&gt;<br>&gt;     if lhs.dynamicType == IPv4NetworkAddress.self {<br>&gt;         return (lhs as! IPv4NetworkAddress) == (rhs as! IPv4NetworkAddress<br>&gt; )<br>&gt;     }<br>&gt;<br>&gt;     if lhs.dynamicType == IPv6NetworkAddress.self {<br>&gt;         return (lhs as! IPv6NetworkAddress) == (rhs as! IPv6NetworkAddress<br>&gt; )<br>&gt;     }<br>&gt;<br>&gt;<br>&gt;     return false<br>&gt; }<br>&gt;<br>&gt; - Will<br>&gt;<br>&gt; On Apr 13, 2016, at 6:41 PM, Joe Groff via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; It&#39;s been pitched before, but I don&#39;t think we&#39;ve had a dedicated thread<br>&gt; to this idea. Erica has proposed making `Self` generally available within<br>&gt; methods in types to refer to the dynamic type of the current receiver. One<br>&gt; could think of `Self` as a special associated type member that exists in<br>&gt; every type for this purpose. This also happens to be what you get when ask<br>&gt; for the `dynamicType` member of a value. We could unify these concepts and<br>&gt; get rid of the clunky `dynamicType` keyword, replacing it with `x.Self`.<br>&gt;<br>&gt; There&#39;s another benefit to this syntax change. Looking to the future, one<br>&gt; of the many features Doug pitched in his generics manifesto was to<br>&gt; generalize protocol existentials, lifting our current restrictions on<br>&gt; protocols &quot;with Self or associated types&quot; and allowing them to be used as<br>&gt; dynamic types in addition to static generic constraints. Once you do this,<br>&gt; you often want to &quot;open&quot; the type of the existential, so that you can refer<br>&gt; to its Self and associated types in the types of other values. I think a<br>&gt; natural way would be to let you directly use Self and associated type<br>&gt; members of existentials as types themselves, for example:<br>&gt;<br>&gt; let a: Equatable = /*...*/<br>&gt; let b: Equatable = /*...*/<br>&gt;<br>&gt; // This is not allowed, since Equatable requires two values with the same<br>&gt; static type, but<br>&gt; // a and b may have different dynamic types.<br>&gt; a == b<br>&gt;<br>&gt; // However, we can dynamically cast one to the other&#39;s dynamic type:<br>&gt; if let bAsA = b as? a.Self {<br>&gt; return a == bAsA<br>&gt; }<br>&gt;<br>&gt; let x: RangeReplaceableCollection = /*...*/<br>&gt; let y: Collection = /*...*/<br>&gt;<br>&gt; // If y has the same dynamic Element type as x, append it to x<br>&gt; var z: x.Self = x<br>&gt; if let yAsX = y as? Any&lt;Collection where Element == x.Element&gt; {<br>&gt; z.append(yAsX)<br>&gt; }<br>&gt;<br>&gt; `x.Self` then becomes just the first step in this direction.<br>&gt;<br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160414/562a82ea/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>[Pitch] Rename `x.dynamicType` to `x.Self`</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>April 14, 2016 at 11:00:00am</p></header><div class="content"><p>+1. Completely agree with what Eugene said.<br>On Thu, Apr 14, 2016 at 1:14 AM Eugene Gubin via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I like this idea. I think, if we could use `self` to access instance of<br>&gt; self, we should be allowed to use `Self` to access type of self.<br>&gt;<br>&gt; 2016-04-14 8:46 GMT+04:00 William Dillon via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt;<br>&gt;&gt; This would be great!<br>&gt;&gt;<br>&gt;&gt; I use a nearly identical pattern in my networking framework that would be<br>&gt;&gt; nice to streamline:<br>&gt;&gt;<br>&gt;&gt; public func ==(lhs: NetworkAddress, rhs: NetworkAddress) -&gt; Bool {<br>&gt;&gt;     // Only addresses of the same protocol are considered equal.<br>&gt;&gt;     guard lhs.dynamicType == rhs.dynamicType else {<br>&gt;&gt;         return false<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     if lhs.dynamicType == IPv4NetworkAddress.self {<br>&gt;&gt;         return (lhs as! IPv4NetworkAddress) == (rhs as!<br>&gt;&gt; IPv4NetworkAddress)<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;     if lhs.dynamicType == IPv6NetworkAddress.self {<br>&gt;&gt;         return (lhs as! IPv6NetworkAddress) == (rhs as!<br>&gt;&gt; IPv6NetworkAddress)<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     return false<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; - Will<br>&gt;&gt;<br>&gt;&gt; On Apr 13, 2016, at 6:41 PM, Joe Groff via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; It&#39;s been pitched before, but I don&#39;t think we&#39;ve had a dedicated thread<br>&gt;&gt; to this idea. Erica has proposed making `Self` generally available within<br>&gt;&gt; methods in types to refer to the dynamic type of the current receiver. One<br>&gt;&gt; could think of `Self` as a special associated type member that exists in<br>&gt;&gt; every type for this purpose. This also happens to be what you get when ask<br>&gt;&gt; for the `dynamicType` member of a value. We could unify these concepts and<br>&gt;&gt; get rid of the clunky `dynamicType` keyword, replacing it with `x.Self`.<br>&gt;&gt;<br>&gt;&gt; There&#39;s another benefit to this syntax change. Looking to the future, one<br>&gt;&gt; of the many features Doug pitched in his generics manifesto was to<br>&gt;&gt; generalize protocol existentials, lifting our current restrictions on<br>&gt;&gt; protocols &quot;with Self or associated types&quot; and allowing them to be used as<br>&gt;&gt; dynamic types in addition to static generic constraints. Once you do this,<br>&gt;&gt; you often want to &quot;open&quot; the type of the existential, so that you can refer<br>&gt;&gt; to its Self and associated types in the types of other values. I think a<br>&gt;&gt; natural way would be to let you directly use Self and associated type<br>&gt;&gt; members of existentials as types themselves, for example:<br>&gt;&gt;<br>&gt;&gt; let a: Equatable = /*...*/<br>&gt;&gt; let b: Equatable = /*...*/<br>&gt;&gt;<br>&gt;&gt; // This is not allowed, since Equatable requires two values with the same<br>&gt;&gt; static type, but<br>&gt;&gt; // a and b may have different dynamic types.<br>&gt;&gt; a == b<br>&gt;&gt;<br>&gt;&gt; // However, we can dynamically cast one to the other&#39;s dynamic type:<br>&gt;&gt; if let bAsA = b as? a.Self {<br>&gt;&gt; return a == bAsA<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; let x: RangeReplaceableCollection = /*...*/<br>&gt;&gt; let y: Collection = /*...*/<br>&gt;&gt;<br>&gt;&gt; // If y has the same dynamic Element type as x, append it to x<br>&gt;&gt; var z: x.Self = x<br>&gt;&gt; if let yAsX = y as? Any&lt;Collection where Element == x.Element&gt; {<br>&gt;&gt; z.append(yAsX)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; `x.Self` then becomes just the first step in this direction.<br>&gt;&gt;<br>&gt;&gt; -Joe<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160414/74a9f784/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Rename `x.dynamicType` to `x.Self`</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April 14, 2016 at 08:00:00am</p></header><div class="content"><p>Pull request updated with just the rename. This amounted to basically saying &quot;Self&quot; will replace<br>&quot;self.dynamicType&quot; and eliminate an outlier case for a keyword using camel case.<br></p><p>I did not include  any discussion of generalizing protocol existentials. I can add in<br>a future directions section if you think it appropriate.<br></p><p>-- E<br></p><p><br>&gt; On Apr 13, 2016, at 7:41 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; It&#39;s been pitched before, but I don&#39;t think we&#39;ve had a dedicated thread to this idea. Erica has proposed making `Self` generally available within methods in types to refer to the dynamic type of the current receiver. One could think of `Self` as a special associated type member that exists in every type for this purpose. This also happens to be what you get when ask for the `dynamicType` member of a value. We could unify these concepts and get rid of the clunky `dynamicType` keyword, replacing it with `x.Self`.<br>&gt; <br>&gt; There&#39;s another benefit to this syntax change. Looking to the future, one of the many features Doug pitched in his generics manifesto was to generalize protocol existentials, lifting our current restrictions on protocols &quot;with Self or associated types&quot; and allowing them to be used as dynamic types in addition to static generic constraints. Once you do this, you often want to &quot;open&quot; the type of the existential, so that you can refer to its Self and associated types in the types of other values. I think a natural way would be to let you directly use Self and associated type members of existentials as types themselves, for example:<br>&gt; <br>&gt; 	let a: Equatable = /*...*/<br>&gt; 	let b: Equatable = /*...*/<br>&gt; <br>&gt; 	// This is not allowed, since Equatable requires two values with the same static type, but<br>&gt; 	// a and b may have different dynamic types.<br>&gt; 	a == b <br>&gt; <br>&gt; 	// However, we can dynamically cast one to the other&#39;s dynamic type:<br>&gt; 	if let bAsA = b as? a.Self {<br>&gt; 		return a == bAsA<br>&gt; 	}<br>&gt; <br>&gt; 	let x: RangeReplaceableCollection = /*...*/<br>&gt; 	let y: Collection = /*...*/<br>&gt; <br>&gt; 	// If y has the same dynamic Element type as x, append it to x<br>&gt; 	var z: x.Self = x<br>&gt; 	if let yAsX = y as? Any&lt;Collection where Element == x.Element&gt; {<br>&gt; 		z.append(yAsX)<br>&gt; 	}<br>&gt; <br>&gt; `x.Self` then becomes just the first step in this direction.<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Pitch] Rename `x.dynamicType` to `x.Self`</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>April 14, 2016 at 05:00:00pm</p></header><div class="content"><p>+1, I also support. We already have Self in meaning of dynamicType as <br>result of method, for example:<br></p><p>class A {<br>     func some()-&gt;Self {<br>         //print(self.dynamicType) // btw: if we uncomment this - will get <br>run-time error wtf??<br>         return self<br>     }<br>}<br></p><p>class B:A {<br>}<br></p><p>var aa = B()<br></p><p>print(aa.some().dynamicType)<br></p><p>so why do we need to have this &quot;dynamicType&quot; instead of &quot;Self&quot;.<br>It seems to be natural to have<br></p><p>print(aa.some().Self)<br></p><p><br>On 14.04.2016 4:41, Joe Groff via swift-evolution wrote:<br>&gt; It&#39;s been pitched before, but I don&#39;t think we&#39;ve had a dedicated thread to this idea. Erica has proposed making `Self` generally available within methods in types to refer to the dynamic type of the current receiver. One could think of `Self` as a special associated type member that exists in every type for this purpose. This also happens to be what you get when ask for the `dynamicType` member of a value. We could unify these concepts and get rid of the clunky `dynamicType` keyword, replacing it with `x.Self`.<br>&gt;<br>&gt; There&#39;s another benefit to this syntax change. Looking to the future, one of the many features Doug pitched in his generics manifesto was to generalize protocol existentials, lifting our current restrictions on protocols &quot;with Self or associated types&quot; and allowing them to be used as dynamic types in addition to static generic constraints. Once you do this, you often want to &quot;open&quot; the type of the existential, so that you can refer to its Self and associated types in the types of other values. I think a natural way would be to let you directly use Self and associated type members of existentials as types themselves, for example:<br>&gt;<br>&gt; 	let a: Equatable = /*...*/<br>&gt; 	let b: Equatable = /*...*/<br>&gt;<br>&gt; 	// This is not allowed, since Equatable requires two values with the same static type, but<br>&gt; 	// a and b may have different dynamic types.<br>&gt; 	a == b<br>&gt;<br>&gt; 	// However, we can dynamically cast one to the other&#39;s dynamic type:<br>&gt; 	if let bAsA = b as? a.Self {<br>&gt; 		return a == bAsA<br>&gt; 	}<br>&gt;<br>&gt; 	let x: RangeReplaceableCollection = /*...*/<br>&gt; 	let y: Collection = /*...*/<br>&gt;<br>&gt; 	// If y has the same dynamic Element type as x, append it to x<br>&gt; 	var z: x.Self = x<br>&gt; 	if let yAsX = y as? Any&lt;Collection where Element == x.Element&gt; {<br>&gt; 		z.append(yAsX)<br>&gt; 	}<br>&gt;<br>&gt; `x.Self` then becomes just the first step in this direction.<br>&gt;<br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9ce70a6cb7175e7a5e5db5658186a31?s=50"></div><header><strong>[Pitch] Rename `x.dynamicType` to `x.Self`</strong> from <string>Brandon Knope</string> &lt;bknope at me.com&gt;<p>April 14, 2016 at 02:00:00pm</p></header><div class="content"><p>-1 from me. To me this is not *obvious* as to what &quot;Self&quot; it means. <br></p><p>And it seems possible to run into this: <br>self.someClass.Self<br></p><p>Just looks confusing to me. What&#39;s wrong with using &quot;Type&quot; or something more obvious?<br></p><p>Sent from my iPad<br></p><p>&gt; On Apr 14, 2016, at 10:28 AM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; +1, I also support. We already have Self in meaning of dynamicType as result of method, for example:<br>&gt; <br>&gt; class A {<br>&gt;    func some()-&gt;Self {<br>&gt;        //print(self.dynamicType) // btw: if we uncomment this - will get run-time error wtf??<br>&gt;        return self<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; class B:A {<br>&gt; }<br>&gt; <br>&gt; var aa = B()<br>&gt; <br>&gt; print(aa.some().dynamicType)<br>&gt; <br>&gt; so why do we need to have this &quot;dynamicType&quot; instead of &quot;Self&quot;.<br>&gt; It seems to be natural to have<br>&gt; <br>&gt; print(aa.some().Self)<br>&gt; <br>&gt; <br>&gt;&gt; On 14.04.2016 4:41, Joe Groff via swift-evolution wrote:<br>&gt;&gt; It&#39;s been pitched before, but I don&#39;t think we&#39;ve had a dedicated thread to this idea. Erica has proposed making `Self` generally available within methods in types to refer to the dynamic type of the current receiver. One could think of `Self` as a special associated type member that exists in every type for this purpose. This also happens to be what you get when ask for the `dynamicType` member of a value. We could unify these concepts and get rid of the clunky `dynamicType` keyword, replacing it with `x.Self`.<br>&gt;&gt; <br>&gt;&gt; There&#39;s another benefit to this syntax change. Looking to the future, one of the many features Doug pitched in his generics manifesto was to generalize protocol existentials, lifting our current restrictions on protocols &quot;with Self or associated types&quot; and allowing them to be used as dynamic types in addition to static generic constraints. Once you do this, you often want to &quot;open&quot; the type of the existential, so that you can refer to its Self and associated types in the types of other values. I think a natural way would be to let you directly use Self and associated type members of existentials as types themselves, for example:<br>&gt;&gt; <br>&gt;&gt;    let a: Equatable = /*...*/<br>&gt;&gt;    let b: Equatable = /*...*/<br>&gt;&gt; <br>&gt;&gt;    // This is not allowed, since Equatable requires two values with the same static type, but<br>&gt;&gt;    // a and b may have different dynamic types.<br>&gt;&gt;    a == b<br>&gt;&gt; <br>&gt;&gt;    // However, we can dynamically cast one to the other&#39;s dynamic type:<br>&gt;&gt;    if let bAsA = b as? a.Self {<br>&gt;&gt;        return a == bAsA<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;    let x: RangeReplaceableCollection = /*...*/<br>&gt;&gt;    let y: Collection = /*...*/<br>&gt;&gt; <br>&gt;&gt;    // If y has the same dynamic Element type as x, append it to x<br>&gt;&gt;    var z: x.Self = x<br>&gt;&gt;    if let yAsX = y as? Any&lt;Collection where Element == x.Element&gt; {<br>&gt;&gt;        z.append(yAsX)<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; `x.Self` then becomes just the first step in this direction.<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Pitch] Rename `x.dynamicType` to `x.Self`</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>April 15, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Apr 14, 2016, at 11:59 AM, Brandon Knope &lt;bknope at me.com&gt; wrote:<br>&gt; <br>&gt; -1 from me. To me this is not *obvious* as to what &quot;Self&quot; it means. <br>&gt; <br>&gt; And it seems possible to run into this: <br>&gt; self.someClass.Self<br>&gt; <br>&gt; Just looks confusing to me. What&#39;s wrong with using &quot;Type&quot; or something more obvious?<br></p><p>That&#39;s a fair point. On the other hand, I think we&#39;re pretty consistent now about using CapitalizedCamelCase for types and lowerCamelCase for non-types, so while we could rename Self to SelfType, that feels a bit redundant to me if you&#39;ve already internalized &quot;caps == types&quot;.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9ce70a6cb7175e7a5e5db5658186a31?s=50"></div><header><strong>[Pitch] Rename `x.dynamicType` to `x.Self`</strong> from <string>Brandon Knope</string> &lt;bknope at me.com&gt;<p>April 15, 2016 at 03:00:00pm</p></header><div class="content"><p>I&#39;m just concerned about the obviousness of it. If what we are doing is just grabbing the type, why couldn&#39;t it be:<br></p><p>someClass.Type (like in the generic system)<br></p><p>I&#39;m open to Self, but I just want to make sure we exhaust all avenues that are more obvious at a glance:<br></p><p>.Self.Type<br>.ThisType<br>.SelfType<br>.Type<br></p><p>SelfType is redundant but it also more obvious at first look. <br></p><p>Maybe it doesn&#39;t matter and I am caring about the looks of it too much. Because so many people seem to support .Self in this thread, it might just be me and something I need to accept :P<br></p><p>Brandon <br></p><p><br></p><p>&gt; On Apr 15, 2016, at 1:19 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 14, 2016, at 11:59 AM, Brandon Knope &lt;bknope at me.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; -1 from me. To me this is not *obvious* as to what &quot;Self&quot; it means. <br>&gt;&gt; <br>&gt;&gt; And it seems possible to run into this: <br>&gt;&gt; self.someClass.Self<br>&gt;&gt; <br>&gt;&gt; Just looks confusing to me. What&#39;s wrong with using &quot;Type&quot; or something more obvious?<br>&gt; <br>&gt; That&#39;s a fair point. On the other hand, I think we&#39;re pretty consistent now about using CapitalizedCamelCase for types and lowerCamelCase for non-types, so while we could rename Self to SelfType, that feels a bit redundant to me if you&#39;ve already internalized &quot;caps == types&quot;.<br>&gt; <br>&gt; -Joe<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Pitch] Rename `x.dynamicType` to `x.Self`</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>April 14, 2016 at 09:00:00pm</p></header><div class="content"><p>+1 <br></p><p>can’t wait for the Generics 4.0:<br></p><p>++++ typealias StringDictionary&lt;Value&gt; = Dictionary&lt;String, Value&gt;<br>++++ Parameterized extensions<br>+++  func containsAll&lt;S: Sequence&gt;(elements: S) -&gt; Bool <br>       where Sequence.Iterator.Element == Element<br>++++++++++ Higher-kinded types<br>+++  Generalized existentials<br>     Generic protocols<br>The ConstructibleFrom&lt;X&gt; looks a bit like something I played with this afternoon:<br></p><p>public protocol LiteralCreatable {<br>    associatedtype LiteralType<br>    init(literalValue : LiteralType)<br>}<br>public protocol NilLiteralConvertible : LiteralCreatable {<br>    associatedtype LiteralType = ()<br>}<br>public protocol StringLiteralCreatable : LiteralCreatable {<br>    associatedtype LiteralType = String<br>}<br>public protocol IntLiteralCreatable : LiteralCreatable {<br>    associatedtype LiteralType = Int<br>}<br></p><p>Cheers,<br>L/<br></p><p><br>&gt; On Apr 14, 2016, at 3:41 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; It&#39;s been pitched before, but I don&#39;t think we&#39;ve had a dedicated thread to this idea. Erica has proposed making `Self` generally available within methods in types to refer to the dynamic type of the current receiver. One could think of `Self` as a special associated type member that exists in every type for this purpose. This also happens to be what you get when ask for the `dynamicType` member of a value. We could unify these concepts and get rid of the clunky `dynamicType` keyword, replacing it with `x.Self`.<br>&gt; <br>&gt; There&#39;s another benefit to this syntax change. Looking to the future, one of the many features Doug pitched in his generics manifesto was to generalize protocol existentials, lifting our current restrictions on protocols &quot;with Self or associated types&quot; and allowing them to be used as dynamic types in addition to static generic constraints. Once you do this, you often want to &quot;open&quot; the type of the existential, so that you can refer to its Self and associated types in the types of other values. I think a natural way would be to let you directly use Self and associated type members of existentials as types themselves, for example:<br>&gt; <br>&gt; 	let a: Equatable = /*...*/<br>&gt; 	let b: Equatable = /*...*/<br>&gt; <br>&gt; 	// This is not allowed, since Equatable requires two values with the same static type, but<br>&gt; 	// a and b may have different dynamic types.<br>&gt; 	a == b <br>&gt; <br>&gt; 	// However, we can dynamically cast one to the other&#39;s dynamic type:<br>&gt; 	if let bAsA = b as? a.Self {<br>&gt; 		return a == bAsA<br>&gt; 	}<br>&gt; <br>&gt; 	let x: RangeReplaceableCollection = /*...*/<br>&gt; 	let y: Collection = /*...*/<br>&gt; <br>&gt; 	// If y has the same dynamic Element type as x, append it to x<br>&gt; 	var z: x.Self = x<br>&gt; 	if let yAsX = y as? Any&lt;Collection where Element == x.Element&gt; {<br>&gt; 		z.append(yAsX)<br>&gt; 	}<br>&gt; <br>&gt; `x.Self` then becomes just the first step in this direction.<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160414/ea5fb97c/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>[Pitch] Rename `x.dynamicType` to `x.Self`</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>April 14, 2016 at 10:00:00pm</p></header><div class="content"><p>I do not understand why we can’t do<br></p><p>  type(self)<br></p><p>or even<br></p><p> #type(self)<br></p><p>Personally, I find .Self business to be quite confusing and idiosyncratic. Having a generic #type() directive would be a general improvement for the language design and it would also open up future possibilities such as<br></p><p> extension A where A.B == #type(A.C.property1) {<br></p><p>}<br></p><p>and other potentially useful things. <br></p><p><br></p><p>&gt; On 14 Apr 2016, at 03:41, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; It&#39;s been pitched before, but I don&#39;t think we&#39;ve had a dedicated thread to this idea. Erica has proposed making `Self` generally available within methods in types to refer to the dynamic type of the current receiver. One could think of `Self` as a special associated type member that exists in every type for this purpose. This also happens to be what you get when ask for the `dynamicType` member of a value. We could unify these concepts and get rid of the clunky `dynamicType` keyword, replacing it with `x.Self`.<br>&gt; <br>&gt; There&#39;s another benefit to this syntax change. Looking to the future, one of the many features Doug pitched in his generics manifesto was to generalize protocol existentials, lifting our current restrictions on protocols &quot;with Self or associated types&quot; and allowing them to be used as dynamic types in addition to static generic constraints. Once you do this, you often want to &quot;open&quot; the type of the existential, so that you can refer to its Self and associated types in the types of other values. I think a natural way would be to let you directly use Self and associated type members of existentials as types themselves, for example:<br>&gt; <br>&gt; 	let a: Equatable = /*...*/<br>&gt; 	let b: Equatable = /*...*/<br>&gt; <br>&gt; 	// This is not allowed, since Equatable requires two values with the same static type, but<br>&gt; 	// a and b may have different dynamic types.<br>&gt; 	a == b <br>&gt; <br>&gt; 	// However, we can dynamically cast one to the other&#39;s dynamic type:<br>&gt; 	if let bAsA = b as? a.Self {<br>&gt; 		return a == bAsA<br>&gt; 	}<br>&gt; <br>&gt; 	let x: RangeReplaceableCollection = /*...*/<br>&gt; 	let y: Collection = /*...*/<br>&gt; <br>&gt; 	// If y has the same dynamic Element type as x, append it to x<br>&gt; 	var z: x.Self = x<br>&gt; 	if let yAsX = y as? Any&lt;Collection where Element == x.Element&gt; {<br>&gt; 		z.append(yAsX)<br>&gt; 	}<br>&gt; <br>&gt; `x.Self` then becomes just the first step in this direction.<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Pitch] Rename `x.dynamicType` to `x.Self`</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>April 14, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Apr 14, 2016, at 1:11 PM, Taras Zakharko &lt;taras.zakharko at uzh.ch&gt; wrote:<br>&gt; <br>&gt; I do not understand why we can’t do<br>&gt; <br>&gt;  type(self)<br>&gt; <br>&gt; or even<br>&gt; <br>&gt; #type(self)<br>&gt; <br>&gt; Personally, I find .Self business to be quite confusing and idiosyncratic. Having a generic #type() directive would be a general improvement for the language design and it would also open up future possibilities such as<br>&gt; <br>&gt; extension A where A.B == #type(A.C.property1) {<br>&gt; <br>&gt; }<br>&gt; <br>&gt; and other potentially useful things. <br></p><p>Swift&#39;s type system has static and dynamic manifestations, and you&#39;re conflating them here. #type in a situation like `where A.B == #type(A.C.property1)` would have to produce the static type of property, whereas `x.dynamicType` today produces the dynamic type of a class or existential.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>[Pitch] Rename `x.dynamicType` to `x.Self`</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>April 14, 2016 at 11:00:00pm</p></header><div class="content"><p>I do not think that I was conflating these two aspects. Using #type(self) would return the particular type of the current instance (dynamic type) while using #type(A.var) would return the declared (static) type of the property. Now, <br></p><p>  let a = A()<br>  #type(a.var) <br></p><p>would again return the actual (dynamic) type of var<br></p><p>In essence, I don’t see why we need to separate the mechanisms for querying these types when the distinction can be made on the grounds whether we are querying the type of a particular value/instance or a particular (not instantiated) declaration. <br></p><p>— Taras<br></p><p>P.S. Does Swift today even have the means of querying the static type of a variable once it has been instantiated, i.e. can I programmatically  find out that  x has been declared as P in this scope:<br></p><p>let x : P = TypeThatConformsToP()<br></p><p>If you really want to differentiate between these two then we’d need two separate mechanisms, e.g. #statictype(), #dynamictype(), with #dynamictype() referring to the  instantiated value and $statictype() referring to the variable declaration.<br></p><p><br></p><p>&gt; On 14 Apr 2016, at 22:59, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Apr 14, 2016, at 1:11 PM, Taras Zakharko &lt;taras.zakharko at uzh.ch&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I do not understand why we can’t do<br>&gt;&gt; <br>&gt;&gt; type(self)<br>&gt;&gt; <br>&gt;&gt; or even<br>&gt;&gt; <br>&gt;&gt; #type(self)<br>&gt;&gt; <br>&gt;&gt; Personally, I find .Self business to be quite confusing and idiosyncratic. Having a generic #type() directive would be a general improvement for the language design and it would also open up future possibilities such as<br>&gt;&gt; <br>&gt;&gt; extension A where A.B == #type(A.C.property1) {<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; and other potentially useful things. <br>&gt; <br>&gt; Swift&#39;s type system has static and dynamic manifestations, and you&#39;re conflating them here. #type in a situation like `where A.B == #type(A.C.property1)` would have to produce the static type of property, whereas `x.dynamicType` today produces the dynamic type of a class or existential.<br>&gt; <br>&gt; -Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160414/08772c05/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>[Pitch] Rename `x.dynamicType` to `x.Self`</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>April 15, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; I do not think that I was conflating these two aspects. Using #type(self) would return the particular type of the current instance (dynamic type) while using #type(A.var) would return the declared (static) type of the property.<br></p><p>Taras, to me personally, #something suggests evaluation at compilation time, so I would be *extremely* surprised if #type would return a dynamic type, and #dynamictype is just an abomination, in every way worse than something.dynamicType.<br></p><p>A.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>[Pitch] Rename `x.dynamicType` to `x.Self`</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>April 15, 2016 at 12:00:00pm</p></header><div class="content"><p>True, that makes sense. I was simply trying to explore different possibilities of how these things could be represented in the syntax. What about #type(d) for static (declaration) type and type(v) for dynamic (value/instance) type? Or would that be potentially confusing as well? <br></p><p>The reason why I dislike .dynamicType etc. declarations is because they introduce another ‘magic’ properties to instances. I think that this functionality is very important and that it should be represented by the standard library instead. If Swift had a universal base type, one could say that the magic properties are just part of that base type (and by extension, part of the standard library), however, right now, they are injected by the compiler. I’d rather have a standard function like <br></p><p>type: (Any)-&gt;AnyType <br></p><p>for this purpose. Hell, I would even say that dynamicType(self) is an improvement over self.dynamicType :)<br></p><p><br>— Taras <br></p><p>&gt; On 15 Apr 2016, at 09:54, Andrey Tarantsov &lt;andrey at tarantsov.com&gt; wrote:<br>&gt; <br>&gt;&gt; I do not think that I was conflating these two aspects. Using #type(self) would return the particular type of the current instance (dynamic type) while using #type(A.var) would return the declared (static) type of the property.<br>&gt; <br>&gt; Taras, to me personally, #something suggests evaluation at compilation time, so I would be *extremely* surprised if #type would return a dynamic type, and #dynamictype is just an abomination, in every way worse than something.dynamicType.<br>&gt; <br>&gt; A.<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Pitch] Rename `x.dynamicType` to `x.Self`</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>April 15, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Apr 15, 2016, at 3:19 AM, Taras Zakharko &lt;taras.zakharko at uzh.ch&gt; wrote:<br>&gt; <br>&gt; True, that makes sense. I was simply trying to explore different possibilities of how these things could be represented in the syntax. What about #type(d) for static (declaration) type and type(v) for dynamic (value/instance) type? Or would that be potentially confusing as well? <br>&gt; <br>&gt; The reason why I dislike .dynamicType etc. declarations is because they introduce another ‘magic’ properties to instances. I think that this functionality is very important and that it should be represented by the standard library instead. If Swift had a universal base type, one could say that the magic properties are just part of that base type (and by extension, part of the standard library), however, right now, they are injected by the compiler. I’d rather have a standard function like <br>&gt; <br>&gt; type: (Any)-&gt;AnyType <br>&gt; <br>&gt; for this purpose. Hell, I would even say that dynamicType(self) is an improvement over self.dynamicType :)<br></p><p>The way I see it, my proposed change reduces the total amount of magic. Associated types *are* members of their parent type, and `Self` is a special case of an associated type.<br></p><p>-Joe<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Pitch] Rename `x.dynamicType` to `x.Self`</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>April 15, 2016 at 10:00:00am</p></header><div class="content"><p>+1 nice addition<br></p><p>  -- Howard.<br></p><p>On 14 April 2016 at 11:41, Joe Groff via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; It&#39;s been pitched before, but I don&#39;t think we&#39;ve had a dedicated thread<br>&gt; to this idea. Erica has proposed making `Self` generally available within<br>&gt; methods in types to refer to the dynamic type of the current receiver. One<br>&gt; could think of `Self` as a special associated type member that exists in<br>&gt; every type for this purpose. This also happens to be what you get when ask<br>&gt; for the `dynamicType` member of a value. We could unify these concepts and<br>&gt; get rid of the clunky `dynamicType` keyword, replacing it with `x.Self`.<br>&gt;<br>&gt; There&#39;s another benefit to this syntax change. Looking to the future, one<br>&gt; of the many features Doug pitched in his generics manifesto was to<br>&gt; generalize protocol existentials, lifting our current restrictions on<br>&gt; protocols &quot;with Self or associated types&quot; and allowing them to be used as<br>&gt; dynamic types in addition to static generic constraints. Once you do this,<br>&gt; you often want to &quot;open&quot; the type of the existential, so that you can refer<br>&gt; to its Self and associated types in the types of other values. I think a<br>&gt; natural way would be to let you directly use Self and associated type<br>&gt; members of existentials as types themselves, for example:<br>&gt;<br>&gt;         let a: Equatable = /*...*/<br>&gt;         let b: Equatable = /*...*/<br>&gt;<br>&gt;         // This is not allowed, since Equatable requires two values with<br>&gt; the same static type, but<br>&gt;         // a and b may have different dynamic types.<br>&gt;         a == b<br>&gt;<br>&gt;         // However, we can dynamically cast one to the other&#39;s dynamic<br>&gt; type:<br>&gt;         if let bAsA = b as? a.Self {<br>&gt;                 return a == bAsA<br>&gt;         }<br>&gt;<br>&gt;         let x: RangeReplaceableCollection = /*...*/<br>&gt;         let y: Collection = /*...*/<br>&gt;<br>&gt;         // If y has the same dynamic Element type as x, append it to x<br>&gt;         var z: x.Self = x<br>&gt;         if let yAsX = y as? Any&lt;Collection where Element == x.Element&gt; {<br>&gt;                 z.append(yAsX)<br>&gt;         }<br>&gt;<br>&gt; `x.Self` then becomes just the first step in this direction.<br>&gt;<br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160415/2f32ad4b/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
