<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c0196d32c5877957590e3b9f6e74df09?s=50"></div><header><strong>Mutex/queue access in Swift 3</strong> from <string>Ron Olson</string> &lt;tachoknight at gmail.com&gt;<p>September 23, 2016 at 10:00:00am</p></header><div class="content"><p>Hey all-<br></p><p>I used Erica&#39;s queue example <br>(http://ericasadun.com/2016/03/08/swift-queue-fun/) to implement a queue <br>in a multi-threaded Swift app (quick aside, is it &#39;correct&#39; to say <br>multithreaded when using DispatchQueue?). I spawn a number of objects on <br>a .concurrent DispatchQueue and they all throw strings into the queue, <br>where the main thread pops from the queue and prints it out.<br></p><p>In C/C++ I&#39;d create a mutex and use that for pushing and popping. In <br>Swift 3 I did wrapped the methods in a serial queue:<br></p><p>let serialQueue = DispatchQueue(label: &quot;log.queue&quot;)<br></p><p>// http://ericasadun.com/2016/03/08/swift-queue-fun/<br>public struct Queue&lt;T&gt;: ExpressibleByArrayLiteral {<br>     /// backing array store<br>     public private(set) var elements: Array&lt;T&gt; = []<br></p><p>     /// introduce a new element to the queue in O(1) time<br>     public mutating func push(_ value: T) {<br>         serialQueue.sync {<br>             elements.append(value)<br>         }<br>     }<br></p><p>     /// remove the front of the queue in O(`count` time<br>     public mutating func pop() -&gt; T? {<br>         var retValue: T? = nil<br></p><p>         serialQueue.sync {<br>             if isEmpty == false {<br>                 retValue = elements.removeFirst()<br>             }<br>         }<br></p><p>         return retValue<br>     }<br></p><p>     /// test whether the queue is empty<br>     public var isEmpty: Bool { return elements.isEmpty }<br></p><p>     /// queue size, computed property<br>     public var count: Int {<br>         var count: Int = 0<br></p><p>         serialQueue.sync {<br>             count = elements.count<br>         }<br>         return count<br>     }<br></p><p>     /// offer `ArrayLiteralConvertible` support<br>     public init(arrayLiteral elements: T...) {<br>         serialQueue.sync {<br>             self.elements = elements<br>         }<br>     }<br>}<br></p><p>This is working; I have tested it with 50, uh, threads, and have had <br>zero problems. So I&#39;m content to go on my merry way and use it, but <br>wanted to get some thoughts about whether this is the &#39;right&#39; way and if <br>there is something more Swift-y/libDispatch-y that I should use instead.<br></p><p>Thanks for any info,<br></p><p>Ron<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160923/d39cff9f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[swift-users] Mutex/queue access in Swift 3</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>September 23, 2016 at 05:00:00pm</p></header><div class="content"><p>Do you care about the order in which your queue is filled?<br>Do you have multiple queues - I’m asking because your serial queue is not part of Queue&lt;T&gt;?!<br>You could add your DispatchQueue right into Queue&lt;T&gt;. It depends on your situation and your goal but sometime you could optimise your code with something like self._queue.async(flags: .barrier) { … }.<br></p><p>This required a concurrent dispatch queue, it will not block (like sync does) but it won’t run asynchronously with any other task in your dispatch queue (flags: .barrier).<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 23. September 2016 um 17:34:56, Ron Olson via swift-users (swift-users at swift.org) schrieb:<br></p><p>Hey all-<br></p><p>I used Erica&#39;s queue example (http://ericasadun.com/2016/03/08/swift-queue-fun/) to implement a queue in a multi-threaded Swift app (quick aside, is it &#39;correct&#39; to say multithreaded when using DispatchQueue?). I spawn a number of objects on a .concurrent DispatchQueue and they all throw strings into the queue, where the main thread pops from the queue and prints it out.<br></p><p>In C/C++ I&#39;d create a mutex and use that for pushing and popping. In Swift 3 I did wrapped the methods in a serial queue:<br></p><p>let serialQueue = DispatchQueue(label: &quot;log.queue&quot;)<br></p><p>// http://ericasadun.com/2016/03/08/swift-queue-fun/<br>public struct Queue&lt;T&gt;: ExpressibleByArrayLiteral {<br>/// backing array store<br>public private(set) var elements: Array&lt;T&gt; = []<br></p><p>/// introduce a new element to the queue in O(1) time<br>public mutating func push(_ value: T) {<br>    serialQueue.sync {<br>        elements.append(value)<br>    }<br>}<br></p><p>/// remove the front of the queue in O(`count` time<br>public mutating func pop() -&gt; T? {<br>    var retValue: T? = nil<br></p><p>    serialQueue.sync {<br>        if isEmpty == false {<br>            retValue = elements.removeFirst()<br>        }<br>    }<br></p><p>    return retValue<br>}<br></p><p>/// test whether the queue is empty<br>public var isEmpty: Bool { return elements.isEmpty }<br></p><p>/// queue size, computed property<br>public var count: Int {<br>    var count: Int = 0<br></p><p>    serialQueue.sync {<br>        count = elements.count<br>    }<br>    return count<br>}<br></p><p>/// offer `ArrayLiteralConvertible` support<br>public init(arrayLiteral elements: T...) {<br>    serialQueue.sync {<br>        self.elements = elements<br>    }<br>}<br>}<br></p><p>This is working; I have tested it with 50, uh, threads, and have had zero problems. So I&#39;m content to go on my merry way and use it, but wanted to get some thoughts about whether this is the &#39;right&#39; way and if there is something more Swift-y/libDispatch-y that I should use instead.<br></p><p>Thanks for any info,<br></p><p>Ron<br></p><p>_______________________________________________<br>swift-users mailing list<br>swift-users at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-users<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160923/e1bf4b2d/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
