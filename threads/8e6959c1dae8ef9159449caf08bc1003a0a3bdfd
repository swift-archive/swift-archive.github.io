<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[SHORT Review] SE-0132: Rationalizing Sequence end-operation names</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July 26, 2016 at 01:00:00pm</p></header><div class="content"><p>on Mon Jul 25 2016, Garth Snyder &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; A warm -0.5 from me, meaning that I agree that this issue is important<br>&gt; to address, and that I concur with many of the particulars. (I agree<br>&gt; that removing is way better than drop, for example.)<br>&gt;<br>&gt; However, I suspect that this approach may open more Pandora’s boxes<br>&gt; than it closes. Most of my discomfort centers on the idea of<br>&gt; incomplete ranges. This seems like a major thing to introduce to the<br>&gt; language, and although I like the concept, it raises questions that<br>&gt; deserve to be addressed independently. Incomplete ranges shouldn’t be<br>&gt; allowed to just sneak in the back door as part of an API cleanup in<br>&gt; one particular area.<br></p><p>I don&#39;t view it as a sneak.  They&#39;d be hard to justify adding without<br>APIs that use them, so I don&#39;t see them coming in as a separate<br>proposal.<br></p><p>&gt;<br>&gt;<br>&gt; Really, it seems like ranges could do with some attention in their own<br>&gt; right. In their current form, they feel like largely pragmatic<br>&gt; constructions that aren&#39;t yet fully baked. <br></p><p>They&#39;re as baked as the current language definition makes practical.<br></p><p>&gt; A lot of elaborations have already been piled onto them, and they’re<br>&gt; responsible for a lot of API-level complexity. But as yet, they’re not<br>&gt; capable of representing, e.g., intervals that are open or half-open on<br>&gt; the left.<br></p><p>Because we don&#39;t have important use-cases for those.  The ranges that we<br>do have serve important roles.  Just as we wouldn&#39;t add incomplete<br>ranges without APIs to go with them, we also wouldn&#39;t add<br>open-on-the-left ranges if they didn&#39;t have an important role to play in<br>the standard library or common user programs.<br></p><p>&gt; Incomplete ranges seem to push the idea of ranges even further in the<br>&gt; direction of abstract predicates or mathematically general models of<br>&gt; intervals. For example, SE-0132 suggests<br>&gt;<br>&gt;     ..&lt; 3<br>&gt;<br>&gt; as a syntax for an upper-bounded range. <br></p><p>Not really; it&#39;s a range *expression*, that&#39;s intended to be reified<br>with respect to a collection.<br></p><p>&gt; But wouldn’t<br>&gt;<br>&gt;    &lt; 3<br>&gt;<br>&gt; be a more natural syntax for this? <br>&gt;<br>&gt; From a logical perspective, you’re not really creating a range so much<br>&gt; as expressing the condition that something is less than 3, which<br>&gt; happens to be encoded by a range. If we had incomplete ranges,<br>&gt; wouldn’t you want to be able to use them naturally in, e.g., case<br>&gt; statements?<br>&gt;<br>&gt;     switch (value) {<br>&gt;         case &lt; 3: <br>&gt;             // Small value<br>&gt;         case 3…5:<br>&gt;             // Medium value<br>&gt;         case &gt; 5:<br>&gt;             // Large value<br>&gt;     }<br></p><p>Interesting idea, but it seems like it opens a whole can of complexity.<br>As a consequence, are we talking about supporting a[% 2 == 0] to get the<br>even-numbered elements of an array?<br></p><p>&gt; Doesn’t it seem odd that &lt; 3 is representable as a range but &gt; 5 is<br>&gt; not?<br></p><p>These range expressions are not intended to stand alone.<br></p><p>&gt; (I’ve shown all these with reasonable spacing, but IIRC, the odd<br>&gt; no-space-around-range-operators rule is still in effect. <br></p><p>There&#39;s no rule, just convention.<br></p><p>&gt; That would be worth addressing, too, if ranges are really going to be<br>&gt; first-class citizens.)<br>&gt;<br>&gt;&gt; Matthew Johnson: I think this proposal pushes a bit too hard on<br>&gt;&gt; consistency of “first / last” vs “prefix / suffix”.  Specifically, I<br>&gt;&gt; think first(n) and last(n) are significantly more clear than<br>&gt;&gt; prefix(n) and suffix(n) (and removingFirst(n) / removingLast(n)<br>&gt;&gt; instead of removingPrefix(n) / removingSuffix(n).  I think the<br>&gt;&gt; former are immediately clear.  The latter, while consistent in terms<br>&gt;&gt; of matching semantics with a naming convention suffer in terms of<br>&gt;&gt; clarity at the call site.  I do not think it is immediately clear<br>&gt;&gt; that the parameter specifies the *length* of the prefix or suffix.<br>&gt;<br>&gt; Agreed. According to the API standards, a method removePrefix() seem<br>&gt; like it should accept a prefix as an argument.<br></p><p>Actually not.  The API guidelines say that if the thing can function as<br>a direct object of the verb, you don&#39;t put a noun before it.  That would<br>be<br></p><p>    x.remove(somePrefix)<br></p><p>&gt;&gt; Matthew Johnson: Another comment is that you have generally moved<br>&gt;&gt; index based methods to subscripts rather than named methods.  Why<br>&gt;&gt; didn’t you take this all the way and change `replaceSubrange` to be<br>&gt;&gt; a subscript setter?<br>&gt;<br>&gt; That’s a good point also.<br>&gt;<br>&gt;&gt; * How much effort did you put into your review? A glance, a quick<br>&gt; reading, or an in-depth study?<br>&gt;<br>&gt; A complete reading of the proposal, but without existing knowledge of<br>&gt; the subtleties of Range implementation.<br>&gt;<br>&gt; Garth<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>Dave<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
