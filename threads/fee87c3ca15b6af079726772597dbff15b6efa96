<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Is there an underlying reason why optional protocol requirements need @objc?</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>March  4, 2016 at 08:00:00am</p></header><div class="content"><p>on Fri Mar 04 2016, Simon Pilkington &lt;swift-dev-AT-swift.org&gt; wrote:<br></p><p>&gt; This seems like a strange/unrelated restriction on what is quite a useful feature.<br></p><p>...or an abomination.  What sense does “optional requirement” make,<br>after all?!<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Is there an underlying reason why optional protocol requirements need @objc?</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>March  4, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Mar 4, 2016, at 9:25 AM, Dave Abrahams via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Fri Mar 04 2016, Simon Pilkington &lt;swift-dev-AT-swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; This seems like a strange/unrelated restriction on what is quite a useful feature.<br>&gt; <br>&gt; ...or an abomination.  What sense does “optional requirement” make,<br>&gt; after all?!<br>&gt; <br></p><p>However oxymoronic,  I kind of get the point. If you want default no-op behaviors, with<br>the option to override, which is what optional Objective-C requirements really are, just <br>create protocol extensions.<br></p><p>extension MyProtocol {<br>   func optionalMember() {} // nothing to do <br>}<br></p><p>This guarantees that the member exists, can be called by all consumers, but that there&#39;s a <br>default in place that frees the conforming type from actually having to implement anything<br>unless it really wants to.<br></p><p>-- E<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>Is there an underlying reason why optional protocol requirements need @objc?</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>March  4, 2016 at 05:00:00pm</p></header><div class="content"><p>Well one missed aspect is that the delegator can test if the delegate<br>responds to the method and modify its logic to adjust to the reality (which<br>could have reasonable optimization hanging off it). If you depend on<br>default no-op you don&#39;t get that ability (at least as &quot;easily&quot;). ...it of<br>course is intertwined with the runtime capabilities of objective-c.<br></p><p><br>On Fri, Mar 4, 2016 at 9:16 AM Erica Sadun via swift-dev &lt;<br>swift-dev at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Mar 4, 2016, at 9:25 AM, Dave Abrahams via swift-dev &lt;<br>&gt; swift-dev at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; on Fri Mar 04 2016, Simon Pilkington &lt;swift-dev-AT-swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt; This seems like a strange/unrelated restriction on what is quite a<br>&gt; useful feature.<br>&gt; &gt;<br>&gt; &gt; ...or an abomination.  What sense does “optional requirement” make,<br>&gt; &gt; after all?!<br>&gt; &gt;<br>&gt;<br>&gt; However oxymoronic,  I kind of get the point. If you want default no-op<br>&gt; behaviors, with<br>&gt; the option to override, which is what optional Objective-C requirements<br>&gt; really are, just<br>&gt; create protocol extensions.<br>&gt;<br>&gt; extension MyProtocol {<br>&gt;    func optionalMember() {} // nothing to do<br>&gt; }<br>&gt;<br>&gt; This guarantees that the member exists, can be called by all consumers,<br>&gt; but that there&#39;s a<br>&gt; default in place that frees the conforming type from actually having to<br>&gt; implement anything<br>&gt; unless it really wants to.<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160304/3d28fed2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Is there an underlying reason why optional protocol requirements need @objc?</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>March  4, 2016 at 09:00:00am</p></header><div class="content"><p>on Fri Mar 04 2016, Shawn Erickson &lt;shawnce-AT-gmail.com&gt; wrote:<br></p><p>&gt; Well one missed aspect is that the delegator can test if the delegate<br>&gt; responds to the method and modify its logic to adjust to the reality (which<br>&gt; could have reasonable optimization hanging off it). If you depend on<br>&gt; default no-op you don&#39;t get that ability (at least as &quot;easily&quot;). ...it of<br>&gt; course is intertwined with the runtime capabilities of objective-c.<br></p><p>All that testing puts too much burden on the client, IMO.  It&#39;s much<br>better to provide customization points with default behaviors that work<br>sensibly when not overridden.<br></p><p>&gt;<br>&gt; On Fri, Mar 4, 2016 at 9:16 AM Erica Sadun via swift-dev &lt;<br>&gt; swift-dev at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; On Mar 4, 2016, at 9:25 AM, Dave Abrahams via swift-dev &lt;<br>&gt;&gt; swift-dev at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; on Fri Mar 04 2016, Simon Pilkington &lt;swift-dev-AT-swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; This seems like a strange/unrelated restriction on what is quite a<br>&gt;&gt; useful feature.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; ...or an abomination.  What sense does “optional requirement” make,<br>&gt;&gt; &gt; after all?!<br>&gt;&gt; &gt;<br>&gt;&gt;<br>&gt;&gt; However oxymoronic,  I kind of get the point. If you want default no-op<br>&gt;&gt; behaviors, with<br>&gt;&gt; the option to override, which is what optional Objective-C requirements<br>&gt;&gt; really are, just<br>&gt;&gt; create protocol extensions.<br>&gt;&gt;<br>&gt;&gt; extension MyProtocol {<br>&gt;&gt;    func optionalMember() {} // nothing to do<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; This guarantees that the member exists, can be called by all consumers,<br>&gt;&gt; but that there&#39;s a<br>&gt;&gt; default in place that frees the conforming type from actually having to<br>&gt;&gt; implement anything<br>&gt;&gt; unless it really wants to.<br>&gt;&gt;<br>&gt;&gt; -- E<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>Is there an underlying reason why optional protocol requirements need @objc?</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>March  4, 2016 at 06:00:00pm</p></header><div class="content"><p>(Sorry I hate top posting but fighting with Google inbox to avoid it)<br></p><p>In delegation patterns it can be very helpful in terms of optimization<br>(performance and memory) if the delegator can interrogate a delegate to<br>know if certain delegation points are needed or not. I have code that has<br>done this interrogation at delegate registration allowing potentially<br>complex code paths and/or state maintenance to be avoided. It also could do<br>impl caching to improve dispatch (did not support after registration<br>&quot;reconfiguring&quot; delegates in this model purposely).<br></p><p>Under objective-c leveraging optional protocol methods and runtime checks<br>for responds to those was one built-in way for that. It also could add<br>boilerplate code to check before dispatch that was potentially error prone<br>and cumbersome. ...hence why I often did the check and configuration at<br>registration in my code often avoiding peppering code with dispatch checks.<br></p><p>Anyway not attempting to state anything for against this question about<br>optional requirements in swift protocols. ...a handful of reasonable<br>patterns exist in swift that allows one to achieve the same thing in safer<br>and likely more performant ways.<br></p><p>-Shawn<br></p><p><br>On Fri, Mar 4, 2016 at 9:38 AM Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; on Fri Mar 04 2016, Shawn Erickson &lt;shawnce-AT-gmail.com&gt; wrote:<br>&gt;<br>&gt; &gt; Well one missed aspect is that the delegator can test if the delegate<br>&gt; &gt; responds to the method and modify its logic to adjust to the reality<br>&gt; (which<br>&gt; &gt; could have reasonable optimization hanging off it). If you depend on<br>&gt; &gt; default no-op you don&#39;t get that ability (at least as &quot;easily&quot;). ...it of<br>&gt; &gt; course is intertwined with the runtime capabilities of objective-c.<br>&gt;<br>&gt; All that testing puts too much burden on the client, IMO.  It&#39;s much<br>&gt; better to provide customization points with default behaviors that work<br>&gt; sensibly when not overridden.<br>&gt;<br>&gt; &gt;<br>&gt; &gt; On Fri, Mar 4, 2016 at 9:16 AM Erica Sadun via swift-dev &lt;<br>&gt; &gt; swift-dev at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt; On Mar 4, 2016, at 9:25 AM, Dave Abrahams via swift-dev &lt;<br>&gt; &gt;&gt; swift-dev at swift.org&gt; wrote:<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; on Fri Mar 04 2016, Simon Pilkington &lt;swift-dev-AT-swift.org&gt; wrote:<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt;&gt; This seems like a strange/unrelated restriction on what is quite a<br>&gt; &gt;&gt; useful feature.<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; ...or an abomination.  What sense does “optional requirement” make,<br>&gt; &gt;&gt; &gt; after all?!<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; However oxymoronic,  I kind of get the point. If you want default no-op<br>&gt; &gt;&gt; behaviors, with<br>&gt; &gt;&gt; the option to override, which is what optional Objective-C requirements<br>&gt; &gt;&gt; really are, just<br>&gt; &gt;&gt; create protocol extensions.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; extension MyProtocol {<br>&gt; &gt;&gt;    func optionalMember() {} // nothing to do<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; This guarantees that the member exists, can be called by all consumers,<br>&gt; &gt;&gt; but that there&#39;s a<br>&gt; &gt;&gt; default in place that frees the conforming type from actually having to<br>&gt; &gt;&gt; implement anything<br>&gt; &gt;&gt; unless it really wants to.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; -- E<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-dev mailing list<br>&gt; &gt;&gt; swift-dev at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt; &gt;&gt;<br>&gt;<br>&gt; --<br>&gt; -Dave<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160304/d8e480fc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Is there an underlying reason why optional protocol requirements need @objc?</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>March  4, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Mar 4, 2016, at 10:09 AM, Shawn Erickson via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; (Sorry I hate top posting but fighting with Google inbox to avoid it)<br>&gt; <br>&gt; In delegation patterns it can be very helpful in terms of optimization (performance and memory) if the delegator can interrogate a delegate to know if certain delegation points are needed or not. I have code that has done this interrogation at delegate registration allowing potentially complex code paths and/or state maintenance to be avoided. It also could do impl caching to improve dispatch (did not support after registration &quot;reconfiguring&quot; delegates in this model purposely).<br>&gt; <br>&gt; Under objective-c leveraging optional protocol methods and runtime checks for responds to those was one built-in way for that. It also could add boilerplate code to check before dispatch that was potentially error prone and cumbersome. ...hence why  I often did the check and configuration at registration in my code often avoiding peppering code with dispatch checks.<br>&gt; <br>&gt; Anyway not attempting to state anything for against this question about optional requirements in swift protocols. ...a handful of reasonable patterns exist in swift that allows one to achieve the same thing in safer and likely more performant ways.<br></p><p>Folks, this is obviously a language design discussion.  Please do this sort of thing on swift-evolution.  I’ve moved swift-dev to BCC.<br></p><p>John.<br></p><p>&gt; <br>&gt; -Shawn<br>&gt; <br>&gt; <br>&gt; On Fri, Mar 4, 2016 at 9:38 AM Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt; on Fri Mar 04 2016, Shawn Erickson &lt;shawnce-AT-gmail.com&gt; wrote:<br>&gt; <br>&gt; &gt; Well one missed aspect is that the delegator can test if the delegate<br>&gt; &gt; responds to the method and modify its logic to adjust to the reality (which<br>&gt; &gt; could have reasonable optimization hanging off it). If you depend on<br>&gt; &gt; default no-op you don&#39;t get that ability (at least as &quot;easily&quot;). ...it of<br>&gt; &gt; course is intertwined with the runtime capabilities of objective-c.<br>&gt; <br>&gt; All that testing puts too much burden on the client, IMO.  It&#39;s much<br>&gt; better to provide customization points with default behaviors that work<br>&gt; sensibly when not overridden.<br>&gt; <br>&gt; &gt;<br>&gt; &gt; On Fri, Mar 4, 2016 at 9:16 AM Erica Sadun via swift-dev &lt;<br>&gt; &gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt; On Mar 4, 2016, at 9:25 AM, Dave Abrahams via swift-dev &lt;<br>&gt; &gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; on Fri Mar 04 2016, Simon Pilkington &lt;swift-dev-AT-swift.org&gt; wrote:<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt;&gt; This seems like a strange/unrelated restriction on what is quite a<br>&gt; &gt;&gt; useful feature.<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; ...or an abomination.  What sense does “optional requirement” make,<br>&gt; &gt;&gt; &gt; after all?!<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; However oxymoronic,  I kind of get the point. If you want default no-op<br>&gt; &gt;&gt; behaviors, with<br>&gt; &gt;&gt; the option to override, which is what optional Objective-C requirements<br>&gt; &gt;&gt; really are, just<br>&gt; &gt;&gt; create protocol extensions.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; extension MyProtocol {<br>&gt; &gt;&gt;    func optionalMember() {} // nothing to do<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; This guarantees that the member exists, can be called by all consumers,<br>&gt; &gt;&gt; but that there&#39;s a<br>&gt; &gt;&gt; default in place that frees the conforming type from actually having to<br>&gt; &gt;&gt; implement anything<br>&gt; &gt;&gt; unless it really wants to.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; -- E<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-dev mailing list<br>&gt; &gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt; &gt;&gt;<br>&gt; <br>&gt; --<br>&gt; -Dave<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160304/f57dfde8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[swift-dev] Is there an underlying reason why optional protocol requirements need @objc?</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March  4, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Mar 4, 2016, at 10:49 AM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Mar 4, 2016, at 10:09 AM, Shawn Erickson via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; (Sorry I hate top posting but fighting with Google inbox to avoid it)<br>&gt;&gt; <br>&gt;&gt; In delegation patterns it can be very helpful in terms of optimization (performance and memory) if the delegator can interrogate a delegate to know if certain delegation points are needed or not. I have code that has done this interrogation at delegate registration allowing potentially complex code paths and/or state maintenance to be avoided. It also could do impl caching to improve dispatch (did not support after registration &quot;reconfiguring&quot; delegates in this model purposely).<br>&gt;&gt; <br>&gt;&gt; Under objective-c leveraging optional protocol methods and runtime checks for responds to those was one built-in way for that. It also could add boilerplate code to check before dispatch that was potentially error prone and cumbersome. ...hence why  I often did the check and configuration at registration in my code often avoiding peppering code with dispatch checks.<br>&gt;&gt; <br>&gt;&gt; Anyway not attempting to state anything for against this question about optional requirements in swift protocols. ...a handful of reasonable patterns exist in swift that allows one to achieve the same thing in safer and likely more performant ways.<br>&gt; <br>&gt; Folks, this is obviously a language design discussion.  Please do this sort of thing on swift-evolution.  I’ve moved swift-dev to BCC.<br></p><p>Even without language support, you can model optional protocol conformances as optional property requirements, with pretty much the exact same behavior on the user side that we give officially optional requirements:<br></p><p>protocol OptionalMethod {<br>  var optionalMethod: Optional&lt;() -&gt; ()&gt; { get }<br>}<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160304/b849e7af/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[swift-dev] Is there an underlying reason why optional protocol requirements need @objc?</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>March  4, 2016 at 08:00:00pm</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On Mar 4, 2016, at 1:24 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Mar 4, 2016, at 10:49 AM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Mar 4, 2016, at 10:09 AM, Shawn Erickson via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; (Sorry I hate top posting but fighting with Google inbox to avoid it)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In delegation patterns it can be very helpful in terms of optimization (performance and memory) if the delegator can interrogate a delegate to know if certain delegation points are needed or not. I have code that has done this interrogation at delegate registration allowing potentially complex code paths and/or state maintenance to be avoided. It also could do impl caching to improve dispatch (did not support after registration &quot;reconfiguring&quot; delegates in this model purposely).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Under objective-c leveraging optional protocol methods and runtime checks for responds to those was one built-in way for that. It also could add boilerplate code to check before dispatch that was potentially error prone and cumbersome. ...hence why  I often did the check and configuration at registration in my code often avoiding peppering code with dispatch checks.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Anyway not attempting to state anything for against this question about optional requirements in swift protocols. ...a handful of reasonable patterns exist in swift that allows one to achieve the same thing in safer and likely more performant ways.<br>&gt;&gt; <br>&gt;&gt; Folks, this is obviously a language design discussion.  Please do this sort of thing on swift-evolution.  I’ve moved swift-dev to BCC.<br>&gt; <br>&gt; Even without language support, you can model optional protocol conformances as optional property requirements, with pretty much the exact same behavior on the user side that we give officially optional requirements:<br>&gt; <br>&gt; protocol OptionalMethod {<br>&gt;   var optionalMethod: Optional&lt;() -&gt; ()&gt; { get }<br>&gt; }<br></p><p>One issue with this modeling is argument labels. You can&#39;t really have a bunch of properties name &quot;tableView&quot;. <br></p><p><br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160304/135bf092/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[swift-dev] Is there an underlying reason why optional protocol requirements need @objc?</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March  5, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; On Mar 4, 2016, at 8:32 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt; On Mar 4, 2016, at 1:24 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 4, 2016, at 10:49 AM, John McCall via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mar 4, 2016, at 10:09 AM, Shawn Erickson via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; (Sorry I hate top posting but fighting with Google inbox to avoid it)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In delegation patterns it can be very helpful in terms of optimization (performance and memory) if the delegator can interrogate a delegate to know if certain delegation points are needed or not. I have code that has done this interrogation at delegate registration allowing potentially complex code paths and/or state maintenance to be avoided. It also could do impl caching to improve dispatch (did not support after registration &quot;reconfiguring&quot; delegates in this model purposely).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Under objective-c leveraging optional protocol methods and runtime checks for responds to those was one built-in way for that. It also could add boilerplate code to check before dispatch that was potentially error prone and cumbersome. ...hence why  I often did the check and configuration at registration in my code often avoiding peppering code with dispatch checks.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Anyway not attempting to state anything for against this question about optional requirements in swift protocols. ...a handful of reasonable patterns exist in swift that allows one to achieve the same thing in safer and likely more performant ways.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Folks, this is obviously a language design discussion.  Please do this sort of thing on swift-evolution.  I’ve moved swift-dev to BCC.<br>&gt;&gt; <br>&gt;&gt; Even without language support, you can model optional protocol conformances as optional property requirements, with pretty much the exact same behavior on the user side that we give officially optional requirements:<br>&gt;&gt; <br>&gt;&gt; protocol OptionalMethod {<br>&gt;&gt;   var optionalMethod: Optional&lt;() -&gt; ()&gt; { get }<br>&gt;&gt; }<br>&gt; <br>&gt; One issue with this modeling is argument labels. You can&#39;t really have a bunch of properties name &quot;tableView&quot;. <br></p><p>We could conceivably allow for properties with closure types to have compound names. That would also benefit the optional binding `if let tableView(_:blah:) = delegate.tableView(_:blah:) { ... }`.<br></p><p>-Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160305/d625de5f/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d1af757c2ce75a92193ad0c34bc62af1?s=50"></div><header><strong>[swift-dev] Is there an underlying reason why optional protocol requirements need @objc?</strong> from <string>Dietmar Planitzer</string> &lt;dplanitzer at q.com&gt;<p>March  6, 2016 at 02:00:00pm</p></header><div class="content"><p>I’ve played around with your idea a bit and I have some questions (please see below). Here is the code that I wrote up in playground (but I also ran all experiments outside the playground):<br></p><p>protocol Delegate {<br>    var optionalMethod: Optional&lt;() -&gt; Int&gt; { get }<br>}<br></p><p><br>class Foo {<br>    <br>    var delegate : Delegate?<br>    <br>    func doIt() {<br>        if let d = delegate {<br>            let i: Int = d.optionalMethod?() ?? 0<br>            <br>            print(i)<br>        }<br>    }<br>}<br></p><p><br>class Bar : Delegate {<br>    <br>    init() {<br>//        optionalMethod = { self.p }   [A]<br>    }<br>    <br>    deinit {<br>        print(&quot;dead&quot;)<br>    }<br>    <br>    var p = 1<br>    <br>//    var optionalMethod = Optional({ return 1 })<br></p><p>    var optionalMethod: Optional&lt;() -&gt; Int&gt; = nil<br>}<br></p><p><br>class Bar1 : Bar {<br>    <br>//    override var optionalMethod: Optional&lt;() -&gt; Int&gt; = { 1 } <br>    <br>}<br></p><p><br>do {<br>    let f = Foo()<br>    f.delegate = Bar()<br>    f.doIt()<br>}<br></p><p><br>Assuming that this is what you had in mind as a replacement for optional protocol conformances, here are some questions:<br></p><p>1) How would forward compatibility work with this approach? Eg we may create a class or struct as part of our v1 framework API and the class/struct may support a delegate protocol with a non-optional method. But based on feedback from the field we want to change the non-optional delegate method to an optional one in v2. The goal is to create a new version of the framework which will not break existing apps which were built against the v1 API. To me it looks like that I could not do this with your approach without breaking existing apps since the v1 protocol definition:<br></p><p>protocol Delegate {<br>    var foo: Optional&lt;() -&gt; Int&gt; { get }<br>}<br></p><p>would change to this:<br></p><p>protocol Delegate {<br>    var foo: Int { get }<br>}<br></p><p>which implies that the call site needs to be different. The same problem exists the other way around: an optional requirement may change to a non-optional requirement. The extra complication here is that the delegating entity needs to be able to treat a method which is declared as non-optional in the protocol, as effectively optional at runtime in order to provide backward compatibility until the optionality can be phased out for good.<br></p><p><br>2) The example above shows class Bar, which adopts the delegate protocol and class Bar1 which subclasses Bar. Now Bar1 wants to override the “optionalMethod” in order to return a different value. But overriding doesn’t work because “optionalMethod” in Bar is now a stored property. To make this more concrete, assume that we are developing a media app for a mobile device and that the UI of this app is organized into tabs. Eg one tab for videos, another one for things that you shared, another one for folders, etc. All those pages have the same underlying principle in common: set up a db query, run the query asynchronously, wait for the query result while managing a progress spinner and finally post-process the results and show them in a table view. One of the things we want to support is drag &amp; drop. The drag &amp; drop delegation methods are all optional conformances and our common base view controller provides a generic implementation which makes sense for 90% of all pages. It’s just 1 or 2 pages that want to do drag &amp; drop a bit differently and thus the view controller subclasses for those tabs should be able to just override the inherited d &amp; d methods (the optional methods).<br></p><p>In your model, the only way I see this kind of work is when I do [A] (see code above) and the subclass would store different closures in the property. But this then introduces other issues.<br></p><p><br>Here are my thoughts and observations on this:<br></p><p>a) I have a problem with the inconsistency that this approach introduces when you compare how to adopt a non-optional requirement vs an optional requirement:<br></p><p>protocol Delegate {<br>   var requiredProperty: Int { get}<br>}<br></p><p><br>class Foo : Delegate {<br></p><p>   var requiredProperty = 1<br></p><p>}<br></p><p>So things are simple and intuitive if the method / property is non-optional. But if it is optional then I need to write this:<br></p><p>protocol Delegate {<br>   var optionalProperty: Optional&lt;() -&gt; Int&gt; { get}<br>}<br></p><p><br>class Foo : Delegate {<br></p><p>   var optionalProperty = Optional({1})<br></p><p>}<br></p><p>or this:<br></p><p>class Foo : Delegate {<br></p><p>   var optionalProperty:  Optional&lt;() -&gt; Int&gt;  =  {1}<br></p><p>}<br></p><p>I really do not like that we put the burden of adopting optional methods on the adopter rather than the implementor of the delegating class. For every hour that is spent on implementing the delegating class, potentially hundreds and more hours will be spent writing code that adopts the delegate (think framework provided delegate protocols). So it clearly makes more sense to put the burden on the implementor of the delegating class rather than the individual adopters.<br></p><p><br>b) the solution doesn’t scale well beyond trivial code because you can not simply write this:<br></p><p>class Foo : Delegate {<br></p><p>    var value = 1<br></p><p>    var optionalMethod = Optional({ value })<br>}<br></p><p>because “self” in the closure does not refer to Foo. But even if it would, you would have to prefix “value” with “self” because it’s now inside a closure rather than a regular method / property body. Now one possible workaround for this would be this:<br></p><p>class Foo : Delegate {<br></p><p>   init() {<br>      optionalMethod = { self.value}<br>   }<br>}<br></p><p>which however puts code that has nothing got to do with initialization inside the initializer.<br></p><p><br>c) it makes it easy to create retain cycles because the optional method is now a closure. The adopter object has a strong reference to the closure. If the closure now captures the adopter’s  self, and we forget to mark the capture as unowned, then we’ve created a retain cycle and the adopter object won’t get freed. You can uncomment [A] in the example above to see this problem.<br></p><p><br>d) so given (b) and (c) maybe we can rewrite the optional method like this:<br></p><p>class Foo : Delegate {<br></p><p>   init() {<br>      optionalMethod = optionalMethodImpl<br>   }<br></p><p><br>   var optionalMethod: Optional&lt;() -&gt; Int&gt; = nil<br></p><p>   func optionalMethodImpl() -&gt; Int {<br>      return 1<br>   }<br>}<br></p><p>which fixes (b) but apparently doesn’t fix (c) since the Foo object still does not get deallocated.<br></p><p><br>Overall I prefer ObjC’s solution for optional protocol requirements over this because it would:<br></p><p>I) allow us to ensure that we can provide forward compatibility exactly the way we need it without compromising performance or safety<br></p><p>II) give us syntax that is easy to understand for the language user, is consistent with non-optional requirements and does not force us to compromise the design of our APIs<br></p><p>III) because of (II) consistency between fulfilling non-optional and optional requirements, it is less likely to write buggy code and refactoring from optional to non-optional and the other way around is less time consuming and safer<br></p><p><br>Regards,<br></p><p>Dietmar Planitzer<br></p><p><br>&gt; On Mar 4, 2016, at 13:24, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 4, 2016, at 10:49 AM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 4, 2016, at 10:09 AM, Shawn Erickson via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; (Sorry I hate top posting but fighting with Google inbox to avoid it)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In delegation patterns it can be very helpful in terms of optimization (performance and memory) if the delegator can interrogate a delegate to know if certain delegation points are needed or not. I have code that has done this interrogation at delegate registration allowing potentially complex code paths and/or state maintenance to be avoided. It also could do impl caching to improve dispatch (did not support after registration &quot;reconfiguring&quot; delegates in this model purposely).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Under objective-c leveraging optional protocol methods and runtime checks for responds to those was one built-in way for that. It also could add boilerplate code to check before dispatch that was potentially error prone and cumbersome. ...hence why  I often did the check and configuration at registration in my code often avoiding peppering code with dispatch checks.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Anyway not attempting to state anything for against this question about optional requirements in swift protocols. ...a handful of reasonable patterns exist in swift that allows one to achieve the same thing in safer and likely more performant ways.<br>&gt;&gt; <br>&gt;&gt; Folks, this is obviously a language design discussion.  Please do this sort of thing on swift-evolution.  I’ve moved swift-dev to BCC.<br>&gt; <br>&gt; Even without language support, you can model optional protocol conformances as optional property requirements, with pretty much the exact same behavior on the user side that we give officially optional requirements:<br>&gt; <br>&gt; protocol OptionalMethod {<br>&gt;   var optionalMethod: Optional&lt;() -&gt; ()&gt; { get }<br>&gt; }<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[swift-dev] Is there an underlying reason why optional protocol requirements need @objc?</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March  7, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Mar 6, 2016, at 2:57 PM, Dietmar Planitzer &lt;dplanitzer at q.com&gt; wrote:<br>&gt; <br>&gt; I’ve played around with your idea a bit and I have some questions (please see below). Here is the code that I wrote up in playground (but I also ran all experiments outside the playground):<br>&gt; <br>&gt; protocol Delegate {<br>&gt;    var optionalMethod: Optional&lt;() -&gt; Int&gt; { get }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; class Foo {<br>&gt; <br>&gt;    var delegate : Delegate?<br>&gt; <br>&gt;    func doIt() {<br>&gt;        if let d = delegate {<br>&gt;            let i: Int = d.optionalMethod?() ?? 0<br>&gt; <br>&gt;            print(i)<br>&gt;        }<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; class Bar : Delegate {<br>&gt; <br>&gt;    init() {<br>&gt; //        optionalMethod = { self.p }   [A]<br>&gt;    }<br>&gt; <br>&gt;    deinit {<br>&gt;        print(&quot;dead&quot;)<br>&gt;    }<br>&gt; <br>&gt;    var p = 1<br>&gt; <br>&gt; //    var optionalMethod = Optional({ return 1 })<br>&gt; <br>&gt;    var optionalMethod: Optional&lt;() -&gt; Int&gt; = nil<br>&gt; }<br>&gt; <br>&gt; <br>&gt; class Bar1 : Bar {<br>&gt; <br>&gt; //    override var optionalMethod: Optional&lt;() -&gt; Int&gt; = { 1 } <br>&gt; <br>&gt; }<br>&gt; <br>&gt; <br>&gt; do {<br>&gt;    let f = Foo()<br>&gt;    f.delegate = Bar()<br>&gt;    f.doIt()<br>&gt; }<br>&gt; <br>&gt; <br>&gt; Assuming that this is what you had in mind as a replacement for optional protocol conformances, here are some questions:<br>&gt; <br>&gt; 1) How would forward compatibility work with this approach? Eg we may create a class or struct as part of our v1 framework API and the class/struct may support a delegate protocol with a non-optional method. But based on feedback from the field we want to change the non-optional delegate method to an optional one in v2. The goal is to create a new version of the framework which will not break existing apps which were built against the v1 API. To me it looks like that I could not do this with your approach without breaking existing apps since the v1 protocol definition:<br>&gt; <br>&gt; protocol Delegate {<br>&gt;    var foo: Optional&lt;() -&gt; Int&gt; { get }<br>&gt; }<br>&gt; <br>&gt; would change to this:<br>&gt; <br>&gt; protocol Delegate {<br>&gt;    var foo: Int { get }<br>&gt; }<br>&gt; <br>&gt; which implies that the call site needs to be different. The same problem exists the other way around: an optional requirement may change to a non-optional requirement. The extra complication here is that the delegating entity needs to be able to treat a method which is declared as non-optional in the protocol, as effectively optional at runtime in order to provide backward compatibility until the optionality can be phased out for good.<br></p><p>You can&#39;t resiliently change a required protocol requirement to an optional one, since this would break existing clients of the protocol that assume the existence of the method. You could at best add a default implementation.<br></p><p>&gt; <br>&gt; 2) The example above shows class Bar, which adopts the delegate protocol and class Bar1 which subclasses Bar. Now Bar1 wants to override the “optionalMethod” in order to return a different value. But overriding doesn’t work because “optionalMethod” in Bar is now a stored property. To make this more concrete, assume that we are developing a media app for a mobile device and that the UI of this app is organized into tabs. Eg one tab for videos, another one for things that you shared, another one for folders, etc. All those pages have the same underlying principle in common: set up a db query, run the query asynchronously, wait for the query result while managing a progress spinner and finally post-process the results and show them in a table view. One of the things we want to support is drag &amp; drop. The drag &amp; drop delegation methods are all optional conformances and our common base view controller provides a generic implementation which makes sense for 90% of all pages. It’s just 1 or 2 pages that want to do drag &amp; drop a bit differently and thus the view controller subclasses for those tabs should be able to just override the inherited d &amp; d methods (the optional methods).<br>&gt; <br>&gt; In your model, the only way I see this kind of work is when I do [A] (see code above) and the subclass would store different closures in the property. But this then introduces other issues.<br>&gt; <br>&gt; <br>&gt; Here are my thoughts and observations on this:<br>&gt; <br>&gt; a) I have a problem with the inconsistency that this approach introduces when you compare how to adopt a non-optional requirement vs an optional requirement:<br>&gt; <br>&gt; protocol Delegate {<br>&gt;   var requiredProperty: Int { get}<br>&gt; }<br>&gt; <br>&gt; <br>&gt; class Foo : Delegate {<br>&gt; <br>&gt;   var requiredProperty = 1<br>&gt; <br>&gt; }<br>&gt; <br>&gt; So things are simple and intuitive if the method / property is non-optional. But if it is optional then I need to write this:<br>&gt; <br>&gt; protocol Delegate {<br>&gt;   var optionalProperty: Optional&lt;() -&gt; Int&gt; { get}<br>&gt; }<br>&gt; <br>&gt; <br>&gt; class Foo : Delegate {<br>&gt; <br>&gt;   var optionalProperty = Optional({1})<br>&gt; <br>&gt; }<br>&gt; <br>&gt; or this:<br>&gt; <br>&gt; class Foo : Delegate {<br>&gt; <br>&gt;   var optionalProperty:  Optional&lt;() -&gt; Int&gt;  =  {1}<br>&gt; <br>&gt; }<br>&gt; <br>&gt; I really do not like that we put the burden of adopting optional methods on the adopter rather than the implementor of the delegating class. For every hour that is spent on implementing the delegating class, potentially hundreds and more hours will be spent writing code that adopts the delegate (think framework provided delegate protocols). So it clearly makes more sense to put the burden on the implementor of the delegating class rather than the individual adopters.<br></p><p>In principle it could be possible to satisfy get-only property requirements with `func` declarations, and vice versa.<br></p><p>&gt; <br>&gt; b) the solution doesn’t scale well beyond trivial code because you can not simply write this:<br>&gt; <br>&gt; class Foo : Delegate {<br>&gt; <br>&gt;    var value = 1<br>&gt; <br>&gt;    var optionalMethod = Optional({ value })<br>&gt; }<br>&gt; <br>&gt; because “self” in the closure does not refer to Foo. But even if it would, you would have to prefix “value” with “self” because it’s now inside a closure rather than a regular method / property body. Now one possible workaround for this would be this:<br>&gt; <br>&gt; class Foo : Delegate {<br>&gt; <br>&gt;   init() {<br>&gt;      optionalMethod = { self.value}<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; which however puts code that has nothing got to do with initialization inside the initializer.<br>&gt; <br>&gt; <br>&gt; c) it makes it easy to create retain cycles because the optional method is now a closure. The adopter object has a strong reference to the closure. If the closure now captures the adopter’s  self, and we forget to mark the capture as unowned, then we’ve created a retain cycle and the adopter object won’t get freed. You can uncomment [A] in the example above to see this problem.<br>&gt; <br>&gt; <br>&gt; d) so given (b) and (c) maybe we can rewrite the optional method like this:<br>&gt; <br>&gt; class Foo : Delegate {<br>&gt; <br>&gt;   init() {<br>&gt;      optionalMethod = optionalMethodImpl<br>&gt;   }<br>&gt; <br>&gt; <br>&gt;   var optionalMethod: Optional&lt;() -&gt; Int&gt; = nil<br>&gt; <br>&gt;   func optionalMethodImpl() -&gt; Int {<br>&gt;      return 1<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; which fixes (b) but apparently doesn’t fix (c) since the Foo object still does not get deallocated.<br>&gt; <br>&gt; <br>&gt; Overall I prefer ObjC’s solution for optional protocol requirements over this because it would:<br>&gt; <br>&gt; I) allow us to ensure that we can provide forward compatibility exactly the way we need it without compromising performance or safety<br>&gt; <br>&gt; II) give us syntax that is easy to understand for the language user, is consistent with non-optional requirements and does not force us to compromise the design of our APIs<br>&gt; <br>&gt; III) because of (II) consistency between fulfilling non-optional and optional requirements, it is less likely to write buggy code and refactoring from optional to non-optional and the other way around is less time consuming and safer<br></p><p>Fair points.<br></p><p>-Joe<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-dev] Is there an underlying reason why optional protocol requirements need @objc?</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March  4, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; In delegation patterns it can be very helpful in terms of optimization (performance and memory) if the delegator can interrogate a delegate to know if certain delegation points are needed or not. I have code that has done this interrogation at delegate registration allowing potentially complex code paths and/or state maintenance to be avoided.<br></p><p>You can always add another delegation point along the lines of `shouldDoTheExpensiveThing()`. Or introduce a FooDelegateWithExpensiveThing protocol which conforms to FooDelegate, and test at runtime to see if your delegate is a FooDelegateWithExpensiveThing.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
