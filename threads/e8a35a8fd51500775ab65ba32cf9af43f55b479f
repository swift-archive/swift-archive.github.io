<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/086bb08723e687750d2fece2f66777fd?s=50"></div><header><strong>Make access control private by default.</strong> from <string>Knut Lorenzen</string> &lt;lo.knut at gmail.com&gt;<p>May 15, 2016 at 08:00:00pm</p></header><div class="content"><p>I think internal as default is bad, because it discourages encapsulation.<br></p><p>Building scalable software components relies on hiding implementation details to create layers of abstraction. It’s a fundamental principle of object-oriented software design. Most other OOP languages have private default.<br></p><p>The linked doc doesn’t explain the advantages of internal as default in detail:<br></p><p>&gt; By default, most entities in a source file have internal access. This optimizes for the most common case—a single-target <br>&gt; application project—while not accidentally revealing entities to clients of a framework module.<br></p><p>Optimizes for what? Build time? Brevity?<br></p><p>Knut<br></p><p>&gt; Have your read<br>&gt; https://github.com/apple/swift/blob/master/docs/AccessControl.rst?<br>&gt; <br>&gt; I prefer the current rationale behind &quot;internal&quot; by default.<br>&gt; <br>&gt; Stephen<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Make access control private by default.</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>May 19, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On May 15, 2016, at 12:15 PM, Knut Lorenzen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; I think internal as default is bad, because it discourages encapsulation.<br>&gt; <br>&gt; Building scalable software components relies on hiding implementation details to create layers of abstraction. It’s a fundamental principle of object-oriented software design. Most other OOP languages have private default.<br></p><p>That is not at all true.  The dynamic OOP languages do not, as a rule, have any access control at all.  Java and C# default to package access, which is analogous to internal.  C++ is, as always, complicated and different.<br></p><p>&gt; The linked doc doesn’t explain the advantages of internal as default in detail:<br>&gt; <br>&gt;&gt; By default, most entities in a source file have internal access. This optimizes for the most common case—a single-target <br>&gt;&gt; application project—while not accidentally revealing entities to clients of a framework module.<br>&gt; <br>&gt; Optimizes for what? Build time? Brevity?<br></p><p>Convenience.  Programs are free to completely ignore access control if they want.  That&#39;s also pretty good for teachability.<br></p><p>Access control matters most for people organizing their code into libraries.  Ultimately, we expect libraries to be packaged as independent modules (that can still be built directly into your application without dynamic cost, of course).  An internal declaration is private to the module, and so the default rule still provides encapsulation by default at the library boundary.  But not all code is library code, and we don&#39;t want to burden application development with having to specify access control everywhere.<br></p><p>John.<br></p><p>&gt; <br>&gt; Knut<br>&gt; <br>&gt;&gt; Have your read<br>&gt;&gt; https://github.com/apple/swift/blob/master/docs/AccessControl.rst?<br>&gt;&gt; <br>&gt;&gt; I prefer the current rationale behind &quot;internal&quot; by default.<br>&gt;&gt; <br>&gt;&gt; Stephen<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/086bb08723e687750d2fece2f66777fd?s=50"></div><header><strong>Make access control private by default.</strong> from <string>Knut Lorenzen</string> &lt;lo.knut at gmail.com&gt;<p>May 23, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On 19 May 2016, at 19:18, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt; That is not at all true.  The dynamic OOP languages do not, as a rule, have any access control at all.  Java and C# default to package access, which is analogous to internal.  C++ is, as always, complicated and different.<br></p><p>Class members are private by default in both Java and C#. As are ivars and selectors in Objective-C (the latter having to be redeclared in the header file for module-wide access). Swift definitely gives greater default scope to class members in comparison to other OOP languages.<br></p><p>&gt; Convenience.  Programs are free to completely ignore access control if they want.  <br></p><p>Convenience can also be lead to shortsightedness and poor code structure. Programmers will be tempted to modify a property or call a function from anywhere just because can, instead of thinking twice because they need mark it as internal first.<br></p><p>And when reading someone else&#39;s code, it is hard to tell the scope of properties and functions if they are internal by default. One has to tediously examine them one by one for project-wide use.<br></p><p>&gt; That&#39;s also pretty good for teachability.<br></p><p>How so? I think especially beginners need to learn the importance of encapsulation. Hiding implementation details in order to create layers of abstraction is a fundamental concept of software design.<br></p><p>&gt; and so the default rule still provides encapsulation by default at the library boundary.  But not all code is library code, and we don&#39;t want to burden application development with having to specify access control everywhere.<br></p><p>Following that rationale, why does private even exist? Seems inconsistent<br></p><p><br>Knut<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/73a38bb7bc9528e31098defe30e68ea4?s=50"></div><header><strong>Make access control private by default.</strong> from <string>Jean-Daniel Dupas</string> &lt;mailing at xenonium.com&gt;<p>May 23, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; Le 23 mai 2016 à 23:21, Knut Lorenzen via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; <br>&gt;&gt; On 19 May 2016, at 19:18, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; That is not at all true.  The dynamic OOP languages do not, as a rule, have any access control at all.  Java and C# default to package access, which is analogous to internal.  C++ is, as always, complicated and different.<br>&gt; <br>&gt; Class members are private by default in both Java and C#. As are ivars and selectors in Objective-C (the latter having to be redeclared in the header file for module-wide access). Swift definitely gives greater default scope to class members in comparison to other OOP languages.<br></p><p>On Java, they are package-private, not private by default, which is closer to module visibility of swift than private.<br></p><p><br>&gt; <br>&gt; Knut<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>Make access control private by default.</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>May 23, 2016 at 07:00:00pm</p></header><div class="content"><p>I was just about to mention this too. I think it&#39;s interesting that<br>one can write a simple application in Swift without having to worry<br>(much) about visibility of elements. Please note I&#39;m talking about<br>applications not frameworks.<br></p><p>I also agree this is good for teachability because you can worry about<br>more important aspects of programming (functionality and structure)<br>than just the correct visibility (that makes no difference to a<br>student until they move to coding a framework themselves). I<br>understand Knut&#39;s point in clarity but that&#39;s the same with the<br>languages mentioned and many more: one visibility is the default in<br>each language and as developers we have to understand and know that<br>for our language of choice and we shouldn&#39;t be required anything more<br>explicit than that (you&#39;re not required in Java to declare defaults).<br></p><p>But I also agree that, to some extent, private may not make sense if<br>the default visibility is already not visible outside the current<br>module but should that be an excuse to just drop it? I, on the other<br>hand, miss the protected visibility but I understand it&#39;s lack<br>conforms to the programming model proposed for the language (I know I<br>should use delegates instead of it).<br></p><p>So, in my opinion, if anything is to be changed regarding visibility<br>it would be to drop the private visibility at all but not change the<br>default visibility to private because only what is visible outside<br>(public) is what matters to be declared, right?<br></p><p>On 23 May 2016 at 18:45, Jean-Daniel Dupas via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Le 23 mai 2016 à 23:21, Knut Lorenzen via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; On 19 May 2016, at 19:18, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; That is not at all true.  The dynamic OOP languages do not, as a rule, have any access control at all.  Java and C# default to package access, which is analogous to internal.  C++ is, as always, complicated and different.<br>&gt;&gt;<br>&gt;&gt; Class members are private by default in both Java and C#. As are ivars and selectors in Objective-C (the latter having to be redeclared in the header file for module-wide access). Swift definitely gives greater default scope to class members in comparison to other OOP languages.<br>&gt;<br>&gt; On Java, they are package-private, not private by default, which is closer to module visibility of swift than private.<br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt; Knut<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Make access control private by default.</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>May 23, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On May 23, 2016, at 3:43 PM, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I was just about to mention this too. I think it&#39;s interesting that<br>&gt; one can write a simple application in Swift without having to worry<br>&gt; (much) about visibility of elements. Please note I&#39;m talking about<br>&gt; applications not frameworks.<br></p><p>I&#39;m glad this is working for you, because this is exactly the intent.<br></p><p>&gt; I also agree this is good for teachability because you can worry about<br>&gt; more important aspects of programming (functionality and structure)<br>&gt; than just the correct visibility (that makes no difference to a<br>&gt; student until they move to coding a framework themselves).<br></p><p>Right.  I think the phrase Chris likes to pull out here is &quot;progressive disclosure&quot;:<br>the language should allow you to focus on learning one lesson at a time.<br>Making students write &quot;public&quot; everywhere doesn&#39;t make understand good<br>code structure and encapsulation; it just forces them to learn a magic word.<br></p><p>In fact — and here I&#39;ll confess to not being up-to-date on CS pedagogy<br>research, and if I&#39;m mistaken I would be happy to be corrected — intuitively I find<br>it improbable that you can really teach encapsulation to intro students at all.<br>I mean, sure, you can teach the terminology and mechanics, and you can<br>mandate a particular code style for their assignments, but they won&#39;t really<br>understand the value until they&#39;ve experienced the problems of code that<br>*isn&#39;t* well-abstracted.<br></p><p>&gt; But I also agree that, to some extent, private may not make sense if<br>&gt; the default visibility is already not visible outside the current<br>&gt; module but should that be an excuse to just drop it?<br></p><p>It makes sense for programmers to be able to develop strong abstractions<br>within a module.  We&#39;re not going to drop private.<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Make access control private by default.</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 24, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On May 24, 2016, at 4:23 AM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 23, 2016, at 3:43 PM, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I was just about to mention this too. I think it&#39;s interesting that<br>&gt;&gt; one can write a simple application in Swift without having to worry<br>&gt;&gt; (much) about visibility of elements. Please note I&#39;m talking about<br>&gt;&gt; applications not frameworks.<br>&gt; <br>&gt; I&#39;m glad this is working for you, because this is exactly the intent.<br>&gt; <br>&gt;&gt; I also agree this is good for teachability because you can worry about<br>&gt;&gt; more important aspects of programming (functionality and structure)<br>&gt;&gt; than just the correct visibility (that makes no difference to a<br>&gt;&gt; student until they move to coding a framework themselves).<br>&gt; <br>&gt; Right.  I think the phrase Chris likes to pull out here is &quot;progressive disclosure&quot;:<br>&gt; the language should allow you to focus on learning one lesson at a time.<br>&gt; Making students write &quot;public&quot; everywhere doesn&#39;t make understand good<br>&gt; code structure and encapsulation; it just forces them to learn a magic word.<br>&gt; <br>&gt; In fact — and here I&#39;ll confess to not being up-to-date on CS pedagogy<br>&gt; research, and if I&#39;m mistaken I would be happy to be corrected — intuitively I find<br>&gt; it improbable that you can really teach encapsulation to intro students at all.<br>&gt; I mean, sure, you can teach the terminology and mechanics, and you can<br>&gt; mandate a particular code style for their assignments, but they won&#39;t really<br>&gt; understand the value until they&#39;ve experienced the problems of code that<br>&gt; *isn&#39;t* well-abstracted.<br></p><p>+1 share the view. Over the years I have seen a lot of IMHO poorly abstracted code that on the outside was following the view that if &quot;if it is inside, then it is good OO&quot;. Teaching encapsulation is hard, and I do join the chorus saying that the problem starts was initializers (I do *pray* that swift does not give in to the partial-inits/auto-inits proposals I&#39;ve seen floating). I understand more and more, in my day to day professional life, why people would look to FP for a solution: the mount of damages contained in an bad method at least has a clear boundary.<br></p><p><br>&gt; <br>&gt;&gt; But I also agree that, to some extent, private may not make sense if<br>&gt;&gt; the default visibility is already not visible outside the current<br>&gt;&gt; module but should that be an excuse to just drop it?<br>&gt; <br>&gt; It makes sense for programmers to be able to develop strong abstractions<br>&gt; within a module.  We&#39;re not going to drop private.<br>&gt; <br>&gt; John.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
