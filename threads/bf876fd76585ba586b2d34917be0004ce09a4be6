<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d569462ac92d4619342b1c5ff305043?s=50"></div><header><strong>Tuple subtype problem</strong> from <string>frogcjn at 163.com</string> &lt;frogcjn at 163.com&gt;<p>February 16, 2016 at 02:00:00pm</p></header><div class="content"><p>Another problem about sub-typing system in Swift is tuple.<br></p><p>Why tuple does not support sub-typing feature?<br></p><p>for example:<br></p><p>class A{<br></p><p>}<br></p><p>class B:A {<br></p><p>}<br></p><p>let tupleB:(B,B) = (B(),B())<br>let tupleA:(A,A) = tupleB<br></p><p><br>This should be allowed in Swift. But a compiler typing-check error.<br></p><p>Thanks!<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160216/bf874be6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>Tuple subtype problem</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>February 16, 2016 at 12:00:00am</p></header><div class="content"><p>Hi Cao,<br></p><p>You’re right, this should be fixed some day. The constraint system understands the subtyping relation here. The diagnostic is generated by the rewriting pass, which currently has no way to express tuple conversions in the AST since its slightly tricky.<br></p><p>A tuple conversion needs to be able to wrap each component of a tuple in its own expression, since subtyping conversions can get pretty hairy and involve multiple nested Exprs. Think if a conversion as a lambda form, like \(x,y)-&gt;(f(x),g(y)), that we’re applying to some tuple value that results from evaluating some other expression.<br></p><p>The way to do this in the AST is with OpaqueValueExprs, which are already used for opening protocol existentials:<br></p><p>(open_existential_expr<br>    (opaque_value 1)    ;; first sub-expression — establish a binding for the existential payload and type<br>    (apply_expr … (opaque_value 1))    ;; second sub-expression — do something with the payload — the result of this expression is the result of the whole OpenExistentialExpr<br>    (load_expr someVar))    ;; third sub-expression — this is something that evaluates to an existential type, and is bound to the opaque value in the first expression<br></p><p>There needs to be a new TupleConversionExpr or similar that also uses OpaqueValueExpr in the same manner, except now we have several opaque values, one for each component of the tuple being destructured:<br></p><p>(tuple_conversion_expr<br>    (tuple_expr     ;; first sub-expression — establish bindings for components of a tuple value — this is sort of like the left hand side of ‘.’ in a lambda expression \(x,y).(f(x),g(y))<br>        (opaque_value 1)<br>        (opaque_value 2))<br>    (tuple_expr    ;; second sub-expression — define result of conversion in terms of the bindings<br>        (upcast_expr (opaque_value 1) A)<br>        (upcast_expr (opaque_value 2) A))<br>    (load_expr tupleB))    ;; third sub-expression — input tuple for conversion, must have same number of components as the input pattern<br></p><p>Then SILGen needs to know how to lower these, by evaluating the input expression, loading its components as individual values, binding them to the unique OpaqueValueExprs in the first expression, and finally evaluating the result to yield the ultimate result of the tuple conversion.<br></p><p>It would be great if someone could take a look at this :)<br></p><p>Slava<br></p><p>&gt; On Feb 15, 2016, at 10:47 PM, Cao Jiannan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Another problem about sub-typing system in Swift is tuple.<br>&gt; <br>&gt; Why tuple does not support sub-typing feature?<br>&gt; <br>&gt; for example:<br>&gt; <br>&gt; class A{<br>&gt; <br>&gt; }<br>&gt; <br>&gt; class B:A {<br>&gt; <br>&gt; }<br>&gt; <br>&gt; let tupleB:(B,B) = (B(),B())<br>&gt; let tupleA:(A,A) = tupleB<br>&gt; <br>&gt; <br>&gt; This should be allowed in Swift. But a compiler typing-check error.<br>&gt; <br>&gt; Thanks!<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160216/7429beb7/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
