<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Review] SE-0065 A New Model for Collections and Indices</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April 13, 2016 at 03:00:00pm</p></header><div class="content"><p>on Wed Apr 13 2016, plx &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;     On Apr 12, 2016, at 5:25 PM, Dave Abrahams via swift-evolution<br>&gt;     &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;     on Tue Apr 12 2016, plx<br>&gt;     &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;         Aside: `indices` being irregular can be a benefit in the context of<br>&gt;         auto-complete.<br>&gt;<br>&gt;         * What is your evaluation of the proposal?<br>&gt;<br>&gt;         +1, very much.<br>&gt;<br>&gt;         As a change from the current model, it’s an across-the-board improvement<br>&gt;         for me,<br>&gt;         at least.<br>&gt;<br>&gt;         In a bigger-picture sense I think Swift would be better off by going<br>&gt;         *further*<br>&gt;         on certain aspects, but have said all that before.<br>&gt;<br>&gt;         * Is the problem being addressed significant enough to warrant a change<br>&gt;         to<br>&gt;         Swift?<br>&gt;<br>&gt;         It is, again very much so.<br>&gt;<br>&gt;         * Does this proposal fit well with the feel and direction of Swift?<br>&gt;<br>&gt;         Depends on the framing of the question.<br>&gt;<br>&gt;         Compared to the previous model, it’s an unqualified YES.<br>&gt;<br>&gt;         As a general proposition, I think this design is a local optimum for<br>&gt;         overall<br>&gt;         Swift-ness, but even so it’s creating a little un-Swifty pocket. It’s<br>&gt;         “un-Swifty” in at least two ways:<br>&gt;<br>&gt;         # 1: Relatively Unsafe, Pointer-Like Semantics<br>&gt;<br>&gt;         Indices—unsurprisingly!—behave quite a bit like pointers, and similarly<br>&gt;         expose<br>&gt;         *numerous* crashing combinations of `(value,operation)`:<br>&gt;<br>&gt;         - self[endIndex]<br>&gt;         - self[startIndex] // &lt;- when empty<br>&gt;         - successor(of: endIndex)<br>&gt;         - predecessor(of: startIndex)<br>&gt;<br>&gt;         …etc., which is *very much* reminiscent of the hazards of pointers.<br>&gt;         (Technically<br>&gt;         “undefined” not “crashing”, but being realistic “crashing&quot; is usually<br>&gt;         accurate).<br>&gt;<br>&gt;     No, these are unspecified in the general case, not undefined. Unless<br>&gt;     you&#39;re working with, e.g. `UnsafeMutableBufferPointer` (or you have a<br>&gt;     data race), there&#39;s no undefined behavior. The big problem with<br>&gt;     pointers isn&#39;t what happens when they crash; it&#39;s what happens when they<br>&gt;     *don&#39;t*.<br>&gt;<br>&gt;         Although Swift uses `Optional` to mitigate the hazards of `nil` pointers<br>&gt;         (etc.),<br>&gt;         you’re still left to your own devices for handling indices.<br>&gt;<br>&gt;     `Optional` is not “mitigating hazards;” it&#39;s encoding the possibility of<br>&gt;     null in the type system. It&#39;s non-optional things that mitigate hazards.<br>&gt;<br>&gt;         This isn’t news to anyone here, I’m sure, and may even be unavoidable;<br>&gt;         I’m just<br>&gt;         pointing it out as an uncharacteristically-unsafe area in Swift’s<br>&gt;         standard APIs,<br>&gt;         and closer to how `!` and IOUs behave than otherwise typical.<br>&gt;<br>&gt;     Any time there&#39;s a required relationship between two things, e.g. a<br>&gt;     receiver and an argument, you have a precondition. The existence of a<br>&gt;     precondition does not make something unsafe at all in the sense that<br>&gt;     Swift uses the term. Safety in swift is about type and memory safety in<br>&gt;     the absence of data races, not about having APIs that respond sensibly<br>&gt;     to every possible combination of arguments. Int.max + 1 will trap, but<br>&gt;     that doesn&#39;t make addition unsafe.<br>&gt;<br>&gt;     Saying that it&#39;s close to how `!` behaves is not at all far from the<br>&gt;     truth, because `!` has a precondition that its argument is non-nil.<br>&gt;<br>&gt; I meant it as a much more exact analogy.<br>&gt;<br>&gt; In a collections-move-indices world, you *could* handle indices as pointers have<br>&gt; been handled, bringing in support from the type-system:<br>&gt;<br>&gt; enum SaferIndex&lt;T:Comparable&gt; {<br>&gt; case Position(T)<br>&gt; case End<br>&gt; }<br>&gt;<br>&gt; …(yes, this is more-or-less `Optional` by another name).<br>&gt;<br>&gt; The assumption above is `T` would be today’s “Index” types, w/o the value used<br>&gt; for `endIndex` (e.g. 0..&lt;self.count for an array, the non-`endIndex` values of<br>&gt; `DictionaryIndex` and `SetIndex`, and so on).<br></p><p>No, you can&#39;t, at least not usefully.  An Index that&#39;s at the end of one<br>collection is in the middle of another, or with a suitably-modified version<br>of the same collection.  <br></p><p>  var x = [1, 2]<br>  let i = x.index(1, stepsFrom: x.startIndex)<br>  x.removeLast()<br>  x[i]           // fatal error: Index out of range<br></p><p>The converse is also true: subscripting on a collection&#39;s endIndex is<br>sometimes just fine, even with no mutation in sight.<br></p><p>  let a = (0..&lt;10).reversed()<br>  print(Array(a))      // “[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]”<br></p><p>  let b = a.prefix(9)<br>  print(Array(b))      // “[9, 8, 7, 6, 5, 4, 3, 2, 1]”<br></p><p>  print(a[b.endIndex]) // “0” (correct, supported behavior)<br></p><p>Of course,<br></p><p>  b[b.endIndex]        // As a matter of QOI: fatal error: out of bounds: index &gt;= endIndex<br></p><p>&gt;<br>&gt; It would’ve been awkward to do this under the previous status quo—e.g. even for<br>&gt; arrays your indices would have to have a back-reference to get the count, and<br>&gt; thus couldn’t be plain integers—but the collection will now always be present to<br>&gt; provide such info.<br>&gt;<br>&gt; Cons:<br>&gt;<br>&gt; - more overhead than “bare” indices<br>&gt; - doesn’t address invalidation (but what does, really?)<br>&gt;<br>&gt; Pros:<br>&gt;<br>&gt; - easier in some ways to handle things like e.g 0…Int.max<br>&gt; - the endIndex equivalent *never* invalidates <br>&gt; - compile-time help for end-index checking<br>&gt;<br>&gt; Overall this *would* bring the treatment of indices closer to that for `?`—e.g.,<br>&gt; redefine the core type to omit the `nil`-like value, <br></p><p>Sorry, but that&#39;s the opposite of what `?` is doing: it *adds* a nil<br>value.  <br></p><p>Seriously, just because Swift has Optionals and they&#39;re useful for<br>safety in some scenarios (compared with allowing everything to be<br>nullable) does not mean that it&#39;s going to be “Swiftier” to apply a<br>similar pattern everywhere.<br></p><p>&gt; use an enum to reintroduce that value when necessary—than to `!`.<br>&gt;<br>&gt; I don’t think the above is an *improvement* over the proposal, but it’s a route<br>&gt; that could have been taken.<br></p><p>I believe it would be hard to make such a design work at all, and if you<br>could make it work I think you&#39;d end up with exactly the problem this<br>proposal aims to solve: references inside indices.  So, I don&#39;t think<br>it&#39;s even a possibility, really.<br></p><p>&gt;<br>&gt;<br>&gt;         To help illustrate the claim, here’s a strawman “safe” API—for<br>&gt;         illustration<br>&gt;         only, not advocacy!—that would be safer and thus perhaps more “Swift-y”:<br>&gt;<br>&gt;     I think there&#39;s a prevalent misunderstanding (IOW, I don&#39;t mean to<br>&gt;     single out this post or this poster) about what “safe” means in Swift<br>&gt;     and what the features of a Swifty API are and should be. This<br>&gt;     is a big topic worthy of much more time than I can devote here, but<br>&gt;     here&#39;s a thought to start with:<br>&gt;<br>&gt;     A Swifty API helps you reason effectively about the correctness of your<br>&gt;     code, and in part that means we provide enough preconditions on<br>&gt;     arguments to avoid complicating result types, and code to handle<br>&gt;     results, with optional-ness.<br>&gt;<br>&gt;     -- <br>&gt;     Dave<br>&gt;<br>&gt;     _______________________________________________<br>&gt;     swift-evolution mailing list<br>&gt;     swift-evolution at swift.org<br>&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Review] SE-0065 A New Model for Collections and Indices</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>April 13, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Apr 13, 2016, at 5:36 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Wed Apr 13 2016, plx &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;    On Apr 12, 2016, at 5:25 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;    &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;    on Tue Apr 12 2016, plx<br>&gt;&gt;    &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;        Aside: `indices` being irregular can be a benefit in the context of<br>&gt;&gt;        auto-complete.<br>&gt;&gt; <br>&gt;&gt;        * What is your evaluation of the proposal?<br>&gt;&gt; <br>&gt;&gt;        +1, very much.<br>&gt;&gt; <br>&gt;&gt;        As a change from the current model, it’s an across-the-board improvement<br>&gt;&gt;        for me,<br>&gt;&gt;        at least.<br>&gt;&gt; <br>&gt;&gt;        In a bigger-picture sense I think Swift would be better off by going<br>&gt;&gt;        *further*<br>&gt;&gt;        on certain aspects, but have said all that before.<br>&gt;&gt; <br>&gt;&gt;        * Is the problem being addressed significant enough to warrant a change<br>&gt;&gt;        to<br>&gt;&gt;        Swift?<br>&gt;&gt; <br>&gt;&gt;        It is, again very much so.<br>&gt;&gt; <br>&gt;&gt;        * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt; <br>&gt;&gt;        Depends on the framing of the question.<br>&gt;&gt; <br>&gt;&gt;        Compared to the previous model, it’s an unqualified YES.<br>&gt;&gt; <br>&gt;&gt;        As a general proposition, I think this design is a local optimum for<br>&gt;&gt;        overall<br>&gt;&gt;        Swift-ness, but even so it’s creating a little un-Swifty pocket. It’s<br>&gt;&gt;        “un-Swifty” in at least two ways:<br>&gt;&gt; <br>&gt;&gt;        # 1: Relatively Unsafe, Pointer-Like Semantics<br>&gt;&gt; <br>&gt;&gt;        Indices—unsurprisingly!—behave quite a bit like pointers, and similarly<br>&gt;&gt;        expose<br>&gt;&gt;        *numerous* crashing combinations of `(value,operation)`:<br>&gt;&gt; <br>&gt;&gt;        - self[endIndex]<br>&gt;&gt;        - self[startIndex] // &lt;- when empty<br>&gt;&gt;        - successor(of: endIndex)<br>&gt;&gt;        - predecessor(of: startIndex)<br>&gt;&gt; <br>&gt;&gt;        …etc., which is *very much* reminiscent of the hazards of pointers.<br>&gt;&gt;        (Technically<br>&gt;&gt;        “undefined” not “crashing”, but being realistic “crashing&quot; is usually<br>&gt;&gt;        accurate).<br>&gt;&gt; <br>&gt;&gt;    No, these are unspecified in the general case, not undefined. Unless<br>&gt;&gt;    you&#39;re working with, e.g. `UnsafeMutableBufferPointer` (or you have a<br>&gt;&gt;    data race), there&#39;s no undefined behavior. The big problem with<br>&gt;&gt;    pointers isn&#39;t what happens when they crash; it&#39;s what happens when they<br>&gt;&gt;    *don&#39;t*.<br>&gt;&gt; <br>&gt;&gt;        Although Swift uses `Optional` to mitigate the hazards of `nil` pointers<br>&gt;&gt;        (etc.),<br>&gt;&gt;        you’re still left to your own devices for handling indices.<br>&gt;&gt; <br>&gt;&gt;    `Optional` is not “mitigating hazards;” it&#39;s encoding the possibility of<br>&gt;&gt;    null in the type system. It&#39;s non-optional things that mitigate hazards.<br>&gt;&gt; <br>&gt;&gt;        This isn’t news to anyone here, I’m sure, and may even be unavoidable;<br>&gt;&gt;        I’m just<br>&gt;&gt;        pointing it out as an uncharacteristically-unsafe area in Swift’s<br>&gt;&gt;        standard APIs,<br>&gt;&gt;        and closer to how `!` and IOUs behave than otherwise typical.<br>&gt;&gt; <br>&gt;&gt;    Any time there&#39;s a required relationship between two things, e.g. a<br>&gt;&gt;    receiver and an argument, you have a precondition. The existence of a<br>&gt;&gt;    precondition does not make something unsafe at all in the sense that<br>&gt;&gt;    Swift uses the term. Safety in swift is about type and memory safety in<br>&gt;&gt;    the absence of data races, not about having APIs that respond sensibly<br>&gt;&gt;    to every possible combination of arguments. Int.max + 1 will trap, but<br>&gt;&gt;    that doesn&#39;t make addition unsafe.<br>&gt;&gt; <br>&gt;&gt;    Saying that it&#39;s close to how `!` behaves is not at all far from the<br>&gt;&gt;    truth, because `!` has a precondition that its argument is non-nil.<br>&gt;&gt; <br>&gt;&gt; I meant it as a much more exact analogy.<br>&gt;&gt; <br>&gt;&gt; In a collections-move-indices world, you *could* handle indices as pointers have<br>&gt;&gt; been handled, bringing in support from the type-system:<br>&gt;&gt; <br>&gt;&gt; enum SaferIndex&lt;T:Comparable&gt; {<br>&gt;&gt; case Position(T)<br>&gt;&gt; case End<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; …(yes, this is more-or-less `Optional` by another name).<br>&gt;&gt; <br>&gt;&gt; The assumption above is `T` would be today’s “Index” types, w/o the value used<br>&gt;&gt; for `endIndex` (e.g. 0..&lt;self.count for an array, the non-`endIndex` values of<br>&gt;&gt; `DictionaryIndex` and `SetIndex`, and so on).<br>&gt; <br>&gt; No, you can&#39;t, at least not usefully.  An Index that&#39;s at the end of one<br>&gt; collection is in the middle of another, or with a suitably-modified version<br>&gt; of the same collection.  <br></p><p>Sure, in certain concrete scenarios it’s possible for one collection’s indices to have such relationships to some other collection.<br></p><p>But, what of it? <br></p><p>In a generic context you can’t assume this; in a concrete context you naturally have more information.<br></p><p>Slices would become problematic, I’ll grant.<br></p><p>&gt;  var x = [1, 2]<br>&gt;  let i = x.index(1, stepsFrom: x.startIndex)<br>&gt;  x.removeLast()<br>&gt;  x[i]           // fatal error: Index out of range<br></p><p>Indices can become invalid; this imposes preconditions. I don’t get it.<br></p><p>&gt; <br>&gt; The converse is also true: subscripting on a collection&#39;s endIndex is<br>&gt; sometimes just fine, even with no mutation in sight.<br>&gt; <br>&gt;  let a = (0..&lt;10).reversed()<br>&gt;  print(Array(a))      // “[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]”<br>&gt; <br>&gt;  let b = a.prefix(9)<br>&gt;  print(Array(b))      // “[9, 8, 7, 6, 5, 4, 3, 2, 1]”<br>&gt; <br>&gt;  print(a[b.endIndex]) // “0” (correct, supported behavior)<br></p><p>I believe we are back to “subscripting one collection with *another* collection&#39;s `endIndex`, no?<br></p><p>Are there any circumstances where a collection *can* be usefully-subscripted with its *own* `endIndex`?<br></p><p>&gt; <br>&gt; Of course,<br>&gt; <br>&gt;  b[b.endIndex]        // As a matter of QOI: fatal error: out of bounds: index &gt;= endIndex<br>&gt; <br>&gt;&gt; <br>&gt;&gt; It would’ve been awkward to do this under the previous status quo—e.g. even for<br>&gt;&gt; arrays your indices would have to have a back-reference to get the count, and<br>&gt;&gt; thus couldn’t be plain integers—but the collection will now always be present to<br>&gt;&gt; provide such info.<br>&gt;&gt; <br>&gt;&gt; Cons:<br>&gt;&gt; <br>&gt;&gt; - more overhead than “bare” indices<br>&gt;&gt; - doesn’t address invalidation (but what does, really?)<br>&gt;&gt; <br>&gt;&gt; Pros:<br>&gt;&gt; <br>&gt;&gt; - easier in some ways to handle things like e.g 0…Int.max<br>&gt;&gt; - the endIndex equivalent *never* invalidates <br>&gt;&gt; - compile-time help for end-index checking<br>&gt;&gt; <br>&gt;&gt; Overall this *would* bring the treatment of indices closer to that for `?`—e.g.,<br>&gt;&gt; redefine the core type to omit the `nil`-like value, <br>&gt; <br>&gt; Sorry, but that&#39;s the opposite of what `?` is doing: it *adds* a nil<br>&gt; value.  <br></p><p>…I must have been unclear.<br></p><p>Step 1: Define T* = { &quot;all memory addresses” (nil included) }<br>Step 2: Define T = T* \ { nil } (e.g. &quot;non-null pointers&quot;)<br></p><p>…is what I was trying to summarize via “redefine the core type to omit the `nil`-like value” (which is the important part here).<br></p><p>Anyways, having `endIndex` directly inhabit the same type as the “good” indices has some pros and some cons; it’s not an IMHO one-sided situation as with `nil`.<br></p><p>On the one hand, in my own experience so far, it’s definitely been the case that most custom collections I’d done have had indices that’re effectively the `SaferIndex` above; it’s been rather rare that there’s been a natural “1 past the rest” value to use of the same type as is used to describe the position of a “good” index.<br></p><p>&gt; Seriously, just because Swift has Optionals and they&#39;re useful for<br>&gt; safety in some scenarios (compared with allowing everything to be<br>&gt; nullable) does not mean that it&#39;s going to be “Swiftier” to apply a<br>&gt; similar pattern everywhere.<br>&gt; <br>&gt;&gt; use an enum to reintroduce that value when necessary—than to `!`.<br>&gt;&gt; <br>&gt;&gt; I don’t think the above is an *improvement* over the proposal, but it’s a route<br>&gt;&gt; that could have been taken.<br>&gt; <br>&gt; I believe it would be hard to make such a design work at all, and if you<br>&gt; could make it work I think you&#39;d end up with exactly the problem this<br>&gt; proposal aims to solve: references inside indices.  So, I don&#39;t think<br>&gt; it&#39;s even a possibility, really.<br></p><p>I can’t say I see the impossibility. I definitely have experienced the clunkiness.<br></p><p>This is getting too involved for a hypothetical I was explaining, but not advocating.<br></p><p>This proposal and the new design is a good design!<br></p><p>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;        To help illustrate the claim, here’s a strawman “safe” API—for<br>&gt;&gt;        illustration<br>&gt;&gt;        only, not advocacy!—that would be safer and thus perhaps more “Swift-y”:<br>&gt;&gt; <br>&gt;&gt;    I think there&#39;s a prevalent misunderstanding (IOW, I don&#39;t mean to<br>&gt;&gt;    single out this post or this poster) about what “safe” means in Swift<br>&gt;&gt;    and what the features of a Swifty API are and should be. This<br>&gt;&gt;    is a big topic worthy of much more time than I can devote here, but<br>&gt;&gt;    here&#39;s a thought to start with:<br>&gt;&gt; <br>&gt;&gt;    A Swifty API helps you reason effectively about the correctness of your<br>&gt;&gt;    code, and in part that means we provide enough preconditions on<br>&gt;&gt;    arguments to avoid complicating result types, and code to handle<br>&gt;&gt;    results, with optional-ness.<br>&gt;&gt; <br>&gt;&gt;    -- <br>&gt;&gt;    Dave<br>&gt;&gt; <br>&gt;&gt;    _______________________________________________<br>&gt;&gt;    swift-evolution mailing list<br>&gt;&gt;    swift-evolution at swift.org<br>&gt;&gt;    https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; -- <br>&gt; Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Review] SE-0065 A New Model for Collections and Indices</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>April 13, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Apr 13, 2016, at 5:36 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Wed Apr 13 2016, plx &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; Seriously, just because Swift has Optionals and they&#39;re useful for<br>&gt; safety in some scenarios (compared with allowing everything to be<br>&gt; nullable) does not mean that it&#39;s going to be “Swiftier” to apply a<br>&gt; similar pattern everywhere.<br></p><p>This reminds me of something I was going to ask about earlier and forgot. <br></p><p>Coming from other languages, I’ve definitely brought with me an assumption that “make invalid states unrepresentable (except where unavoidable)” is the right way to go, with deviations from that rule requiring scrutiny.<br></p><p>Is that outlook actually something the core team considers “Swift-y” or not, though? <br></p><p>The connection to the point you’re making here and the question is that adopting this design style *will* lead to lots of optionals in lots of places.<br></p><p>&gt; <br>&gt;&gt; use an enum to reintroduce that value when necessary—than to `!`.<br>&gt;&gt; <br>&gt;&gt; I don’t think the above is an *improvement* over the proposal, but it’s a route<br>&gt;&gt; that could have been taken.<br>&gt; <br>&gt; I believe it would be hard to make such a design work at all, and if you<br>&gt; could make it work I think you&#39;d end up with exactly the problem this<br>&gt; proposal aims to solve: references inside indices.  So, I don&#39;t think<br>&gt; it&#39;s even a possibility, really.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;        To help illustrate the claim, here’s a strawman “safe” API—for<br>&gt;&gt;        illustration<br>&gt;&gt;        only, not advocacy!—that would be safer and thus perhaps more “Swift-y”:<br>&gt;&gt; <br>&gt;&gt;    I think there&#39;s a prevalent misunderstanding (IOW, I don&#39;t mean to<br>&gt;&gt;    single out this post or this poster) about what “safe” means in Swift<br>&gt;&gt;    and what the features of a Swifty API are and should be. This<br>&gt;&gt;    is a big topic worthy of much more time than I can devote here, but<br>&gt;&gt;    here&#39;s a thought to start with:<br>&gt;&gt; <br>&gt;&gt;    A Swifty API helps you reason effectively about the correctness of your<br>&gt;&gt;    code, and in part that means we provide enough preconditions on<br>&gt;&gt;    arguments to avoid complicating result types, and code to handle<br>&gt;&gt;    results, with optional-ness.<br>&gt;&gt; <br>&gt;&gt;    -- <br>&gt;&gt;    Dave<br>&gt;&gt; <br>&gt;&gt;    _______________________________________________<br>&gt;&gt;    swift-evolution mailing list<br>&gt;&gt;    swift-evolution at swift.org<br>&gt;&gt;    https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; -- <br>&gt; Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160413/1eb7d4c5/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
