<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8ae34e6aaf28c0e1fe929f36897d107e?s=50"></div><header><strong>Proposal: Automatic Wrapper Synthesis / &quot;deriving&quot;</strong> from <string>Harlan Haskins</string> &lt;harlan at harlanhaskins.com&gt;<p>December  5, 2015 at 01:00:00am</p></header><div class="content"><p>I feel like, if we implement automatic derivation for structs that wrap one value, we can just as easily implement automatic derivation for all product types for which the children conform to the protocols in question, and there’s a provided implementation for derivation by combining values.<br></p><p>Consider Hashable. A very common implementation of hashValue is xor-ing all the members’ hash values together.<br>We could actually implement this right now given Swift’s reflection system (if we were able to conditionally cast to Hashable or any protocol with a Self requirement).<br></p><p>Consider this:<br></p><p>struct HashableDerivable deriving Hashable {<br>    let string: String // because String is already Hashable<br>    let integer: Int   // and Int is Hashable<br>    // then HashableDerivable is trivially Hashable.<br>}<br></p><p>/// This implementation is absolutely derivable at compile time.<br>extension HashableDerivable: Hashable {<br>    var hashValue: Int {<br>        return string.hashValue ^ integer.hashValue<br>    }<br>}<br>func ==(lhs: HashableDerivable, rhs: HashableDerivable) -&gt; Bool {<br>    return lhs.string == rhs.string &amp;&amp; lhs.integer == rhs.integer<br>}<br></p><p>// one can also use Reflection to derive this at runtime<br></p><p>extension Mirror {<br>    func canDeriveHashable() -&gt; Bool {<br>        if self.subjectType is Hashable { return true } // this is currently a compiler error<br>        for child in self.children {<br>            let mirror = Mirror(reflecting: child)<br>            if !mirror.canDeriveHashable() { return false }<br>        }<br>        return true<br>    }<br>    func deriveHashValue() -&gt; Int {<br>        if !self.canDeriveHashable() { fatalError(&quot;Boy, I wish this didn&#39;t have to happen at runtime.&quot;) }<br>        guard let firstChild = self.children.first as? Hashable /* also an error */ else { fatalError(&quot;no children&quot;) }<br>        return self.children.dropFirst().reduce(firstChild.hashValue) { (hash, _: (_: String?, value: Any)) -&gt; T in<br>            return hash ^ (value as! Hashable).hashValue<br>        }<br>    }<br>}<br></p><p>Of course, this is something that can be done at compile time, which would make protocol conformance really, really simple.<br></p><p>We already do this, using the Mirror API, for CustomStringConvertible.<br>&gt; &gt; On Dec 4, 2015, at 4:26 PM, John McCall &lt;rjmccall at apple.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt; &gt; <br>&gt; &gt;&gt; On Dec 4, 2015, at 1:19 PM, plx &lt;plxswift at icloud.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt; &gt;&gt; # A `wrapper` / `deriving` Construct<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; I&#39;m sure a construct along these lines has been requested numerous times and is hopefully already on the roadmap.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; The point of this email is to put out a reasonably-*concrete* sketch as a way of soliciting community feedback on the specifics of how such a construct might look-and-work within Swift; hopefully I’ve gone far-enough to be interesting, but not too much further than that.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; ## Design Sketch<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; It ought to be possible to write something like this:<br>&gt; &gt;&gt; <br>&gt; &gt;&gt;   // an example:<br>&gt; &gt;&gt;   struct SectionIndex<br>&gt; &gt;&gt;     wrapping Int<br>&gt; &gt;&gt;     as index<br>&gt; &gt;&gt;     satisfying precondition { $0 &gt;= 0 }<br>&gt; &gt;&gt;     deriving Equatable, Comparable, Hashable {<br>&gt; &gt;&gt;     // declaration can continue in here<br>&gt; &gt;&gt;   }<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; ...which, when compiled, would be &quot;expanded&quot; along these lines:<br>&gt; &gt;&gt; <br>&gt; &gt;&gt;   struct SectionIndex {<br>&gt; &gt;&gt; <br>&gt; &gt;&gt;     // would have been `wrappedValue` w/out the `as index` clause<br>&gt; &gt;&gt;     let index: Int<br>&gt; &gt;&gt; <br>&gt; &gt;&gt;     init(_ index: Int) {<br>&gt; &gt;&gt;       precondition(index &gt;= 0) <br>&gt; &gt;&gt;       // ^ would have been assert(index &gt;= 0) <br>&gt; &gt;&gt;       //   had we used `satisfying { $0 &gt;= 0 }`,<br>&gt; &gt;&gt;       //   and omitted entirely had we omitted a `satisfying` clause<br>&gt; &gt;&gt;       self.index = index<br>&gt; &gt;&gt;     }<br>&gt; &gt;&gt; <br>&gt; &gt;&gt;   }<br>&gt; &gt;&gt; <br>&gt; &gt;&gt;   extension SectionIndex : Equatable {<br>&gt; &gt;&gt;   }<br>&gt; &gt;&gt; <br>&gt; &gt;&gt;   // synthesized unless explicitly written-out<br>&gt; &gt;&gt;   func ==(lhs: SectionIndex, rhs: SectionIndex) -&gt; Bool {<br>&gt; &gt;&gt;     return lhs.index == rhs.index<br>&gt; &gt;&gt;   }<br>&gt; &gt;&gt; <br>&gt; &gt;&gt;   // same for Comparable, Hashable, all done in the obvious way    <br>&gt; &gt;&gt; <br>&gt; &gt;&gt;   // there’s a lot of utility in synthesizing something like this,<br>&gt; &gt;&gt;   //  I can expand on it if necessary:<br>&gt; &gt;&gt;   extension SectionIndex: ValueWrapperType {<br>&gt; &gt;&gt;     typealias WrappedType = Int<br>&gt; &gt;&gt;   }<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; ...where each method/init/subscript/etc in the derived protocols gets synthesized at compile-time, if not explicitly implemented; similarly, if not explicitly-declared, the derived protocols&#39; typealiases can be synthesized in obvious ways, and it seems acceptable to simply fail to compile (and inform the user of the need to make an explicit-declaration) in cases where such synthesis is impossible.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; I think this enough to sketch the way the feature would look and how it would work. <br>&gt; &gt; <br>&gt; &gt; I’m not sure what work is being done by “wrapping X as Y” here; it seems like just another way of expressing a stored property.<br>&gt; &gt; <br>&gt; &gt; I think we’re all interested in a “deriving” proposal.  However, the key problem that a serious proposal would have to address is not picking the syntax, but describing how derivation would actually work.  We’d prefer not to just hard-code rules in the compiler for specific protocols.<br>&gt; &gt; <br>&gt; &gt; For example, derivation presumably involves recursively invoking the given operation on each of the stored properties (what does “on” mean? which parameters are changed, and which are passed through?) and then merging the results (how?).<br>&gt; &gt; <br>&gt; &gt; John.<br>&gt; <br>&gt; Apologies for leaving too much out.<br>&gt; <br>&gt; I meant to propose that the `deriving` in this place would enforce the wrapper type only wrapped a single stored value, warranting the distinct syntax; I seem to have edited-out both an explicit statement that this assumed a single-stored-property and to have omitted a comment in the `//declaration can continue in here` that no additional stored-properties could be declared (analogous to the rules current applied within extensions).<br>&gt; <br>&gt; Yes, constraining a `deriving` construct to only support wrappers containing a single stored property would, on the one hand, be somewhat limiting, but on the other hand it would seemingly allow trivial solutions to the issues you bring up:<br>&gt; <br>&gt; - `on` is unambiguous as there’s only one thing it can be “on&quot;<br>&gt; - there’s no ordering-of-operations to have to worry about<br>&gt; - there’s no merging-of-results to have to worry about<br>&gt; - i’m guessing there’s no parameters needing to getting changed (but I’m not 100% on what you mean here)<br>&gt; - there’s no associated-type incoherency to worry about (unless user error introduces it)<br>&gt; <br>&gt; …there’s least one tricky case (if you want the wrapper to replace one of the wrapped type’s typealiases with a wrapper).<br>&gt; <br>&gt; …and at least for me, there’s enough value in that simplified wrapper-synthesis / deriving-type construct to take the time to check community interest. <br>&gt; <br>&gt; Thanks for taking the time to read and send feedback.<br>&gt; <br>&gt; PS:<br>&gt; <br>&gt; On the other hand, if this becomes writable:<br>&gt; <br>&gt;     protocol WrapperType {<br>&gt;        typealias WrappedValue<br>&gt;        var wrappedValue: { get }<br>&gt;     }<br>&gt; <br>&gt;     extension WrapperType : Equatable where WrappedValue: Equatable {<br>&gt;     }<br>&gt; <br>&gt;     func ==&lt;W:WrapperType where W.WrappedValue:Equatable&gt;(lhs: W, rhs: W) -&gt; Bool {<br>&gt;       return lhs.wrappedValue == rhs.wrappedValue<br>&gt;     }<br>&gt; <br>&gt; …etc., then it’s possible (albeit moderately unpleasant) to just write suitable glue logic out longhand on an as-needed basis (and with the caveat that all types wrapping T would potentially adopt all of T’s protocols even when potentially undesirable).<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/7d638166/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>Proposal: Automatic Wrapper Synthesis / &quot;deriving&quot;</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>December  5, 2015 at 09:00:00am</p></header><div class="content"><p>I definitely got off on the wrong foot by using `deriving`; what I was trying to ask for is more of a stronger typealias (perhaps `newtype`-esque is the right analogy?), which — at least for my purposes — would *ideally* have the following capabilities / rules:<br></p><p>- when Y is a wrapper around an X, Y has only a single, “synthesized&quot; stored property (of type X)<br>- the user can control the name of the stored property by one of these mechanisms (which one is used is moot to me):<br>  - override the name of the synthesized stored property<br>  - indicate another name and have an accessor auto-generated<br>- every protocol adopted by X *can* be auto-synthesized for Y <br>  - but the user has to explicitly request each specific protocol be synthesized…<br>  - …because it’s very important that it be possible to *not* adopt every one of X’s protocols<br>- the user can optionally provide some predicate (of type (X) -&gt; Bool), which then:<br>  - is included as an assert/precondition inside a synthesized `init(_ x: X)` <br>  - is perhaps/can-be used inside some synthesized `init?(_ x: X)` (this is trickier at present, and might be better as a static func)<br>  - is ideally available on some methods like `func isInvariantSatisfied() -&gt; Bool; static func isWrappableValue(x: X) -&gt; Bool` (e.g. for debugging/testing)<br>  - …are essentially for documentation and some very modest runtime verification<br>- there’s some standard/principled way to do type-erasure &quot;back down to X” as-needed<br></p><p>Only supporting single-value-wrappers should make the needed syntheses essentially trivial as far as I can tell; the only obviously non-trivial aspect is that, in practice, it’d seem likely that you’d want to occasionally “override” the typealiases from X with wrappers thereof; e.g. if you had a type Y wrapping Set&lt;Foo&gt;, you might want Y’s `Index` to be a wrapper around `SetIndex&lt;Foo&gt;` and *not just* `SetIndex&lt;Foo&gt;`; this doesn’t seem overly-complicated semantically but it isn’t “trivial”, either, and would perhaps need additional syntax support to read nicely in-use.<br></p><p>Here are a few concrete example motivating the above requests:<br></p><p>## UI-Level Section/Item Indices<br></p><p>It’s a nice — albeit minor — improvement to work with Int-wrappers like `SectionIndex` and `ItemIndex` rather than as primitive, interchangeable `Int` everywhere. It’s particularly handy if trying to write reasonably-generic implementations of the common UI-level datasource/delegate protocols.<br></p><p>For this:<br></p><p>- it’s nice to have the wrapped value accessible as `index` (as opposed to e.g. `wrappedValue` or `storage`, etc.)<br>- it’s nice to *not* wind up with the arithmetic operations from `Int`:<br>  - accidental use of e.g. `*` or `+` or `-` (etc.) on `SectionIndex` or `ItemIndex` is *probably* an error!<br>- it’s nice to *not* wind up as `IntegerLiteralConvertible`:<br>  - hard-coded literal indices are rarely advisable in application code!<br>  - being `IntegerLiteralConvertible` reintroduces transposition-error risk!<br>- it’s nice to have the constructors assert that the wrapped indices aren’t:<br>  - == NSNotFound<br>  - negative <br></p><p>…and although this can be done by hand, it’s an example of a use that *could* be synthesized.<br></p><p>## URL Segregation<br></p><p>It can be moderately useful to have a bunch of lightweight URL-wrapper types to avoid transposition errors and also to ensure appropriate handling (e.g. using the appropriate URL session); picture, say, `IconImageURL`, `HeroImageURL`, `DetailImageURL`, `APIEndpointURL` (etc.).<br></p><p>If you *did* go this route, some standard way of doing &quot;type-erasure” down to the underlying type can be useful:<br></p><p>    class ActiveTransferMonitor {<br>      private var activeTransfers: [URL:TransferMetrics] = [:]<br></p><p>      func didBeginTransfer&lt;T:ValueWrapperType where T.WrappedValue: URL&gt;(transferURL: T) {<br>        self.activeTransfers[transferURL.URL] = TransferMetrics()<br>      }<br>    }<br></p><p>…but this is the example I feel least strongly about (it’s just here to motivate the “standard type-erasure mechanism” aspect).<br></p><p>## Bluetooth<br></p><p>For Bluetooth LE, you have peripherals, which have *services*, which contain *characteristics*, which can have associated *descriptors*. Each service, characteristic, or descriptor is identified by a unique identifier, which is modeled in CoreBluetooth as instances of the `CBUUID` class.<br></p><p>It’s handy here for correctness to have distinct wrapper types, let’s call them `ServiceUUID`, `CharacteristicUUID`, and `DescriptorUUID`, both to guard against simple transposition errors and to make some internal APIs more self-documenting.<br></p><p>It’s handy here for readability to have the wrapped UUID be accessible as, e.g. `.UUID`, and not as some generic `.wrappedValue`:<br>  <br>    extension CBPeripheral {<br>      <br>      func locatePrimaryService(serviceIdentifier: ServiceUUID) -&gt; CBService? {<br>        return self.services?.firstElementSatisfying() {<br>          $0.UUID.isEqual(serviceIdentifier.UUID)<br>        }<br>      }<br>  <br>    }<br></p><p>At present, the easiest way to get these all setup was as-follows:<br></p><p>- create a protocol like `BluetoothEntityUUIDType` that:<br>  - also adopts the protocols it should<br>  - has as many default implementations as possible<br>- create a struct for `ServiceUUID` that:<br>  - wraps a single CBUUID instance <br>  - conforms to `BluetoothEntityUUIDType`<br>  - manually adds any missing conformances / logic<br>- create files for `CharacteristicUUID` and `DescriptorUUID`<br>  - copy-and-paste the definition of `ServiceUUID` into the `CharacteristicUUID` file<br>  - find-and-replace `Service` with `Characteristic`<br>  - copy-and-paste the definition of `ServiceUUID` into the `DescriptorUUID` file<br>  - find-and-replace `Service` with `Descriptor`<br>  - edit the `init` (etc.) for `DescriptorUUID ` to add asserts that the passed-in `CBUUID` is one of 6 allowed, pre-defined CBUUIDs applicable to CBDescriptor<br></p><p>…it works, it’s not too terrible as a one-off, but it’s also tedious and runs the risk of implementation drift (especially due to `CBDescriptor` having validation logic the others don’t) in the event that the initial copy-paste-edit cycle needs to be repeated.<br></p><p>Likewise, there’s small things that are nice utilities to tack-onto the various identifier types (utilities to check if they are some well-known ID) that risk getting accidentally blown away if the copy-paste-edit cycle gets repeated; these *can* be defined in other files, but that in turn *can* require “unnatural” choice of visibility (in some cases).<br></p><p>## Closing Comments<br></p><p>For anyone who read this far, thanks for taking the time. I hope the concrete examples helps shed some light on both the motivation and the intended scope for this feature request.<br></p><p>The common theme in the examples is that in the individual use, the amount of wrapping is small enough that:<br></p><p>- it can be done by hand<br>- there are not enough wrappers to really justify writing a code-gen tool…<br>- …especially since (in practice) many of the wrappers benefit from small “customization” here-and-there<br>- there are readability-and-correctness benefits to having the wrappers available<br></p><p>…but I think having wrapper-synthesis — or a functional equivalent — as an easily-accessible part of the language would open the door more broadly to writing in this style, in ways which aren&#39;t always cost-or-time-effective today.<br></p><p>Finally, as I keep mentioning, it’s entirely possible that improvements to the type system will make protocols + default method implementations able to get this features’ benefits without requiring any additional support from the language or tooling; I’d be happy-enough with that outcome also.<br></p><p>Thanks again for the time and feedback. If there’s enough community interest I can prepare a formal proposal, otherwise I’ve said everything I have to say on this idea.<br></p><p>## PS: Product-Type Handling<br></p><p>I honestly think that handling product types with deriving is hard-enough it’s not really worth trying to do; there’s certainly some limited value in being able to synthesize (component-wise) `Equatable` and so on, but once you get past the very foundational protocols like `Equatable` / `Comparable` / `Hashable` / `CustomStringConvertible` / `CustomDebugStringConvertible` you start hitting tricky problems it’s not clear .<br></p><p>EG: how do you synthesize a CollectionType implementation for, e.g., a product of two `CollectionType` types? Sure, you can safely bet the type of the synthesized Element is going to be the product of the component elements, but how do you plan to synthesize the implementation of a proper `ForwardIndexType` from the product of the component collections&#39; `ForwardIndexType`s? There’s a lot of ways to do this, with different resulting iteration ordering and different performance/resource tradeoffs, and it’s hard to do auto-synthesis here that doesn’t either just “pick a winner” (and leave you hanging if you wanted a different implementation) or wind up introducing a mini-language to let you indicate which variant it should synthesize.<br></p><p>Moreover, note that even for, e.g., `Hashable`, there are actually at least a couple common strategies I often see.<br></p><p>One is the `xor`-everything strategy, except:<br></p><p>- it’s IMHO a good idea to rotate some of the constituent hashes to avoid accidentally hashing a lot of stuff to zero<br>- you don’t always want to hash *everything*<br>- you may want/need to hash transformed/normalized forms of constituent values, not the “raw” values<br></p><p>Another is the “forward to a good identifier” strategy, e.g.:<br></p><p>- you have a type like `struct ContentMetadata { let identifier: ContentIdentifier; let metadata: [String:MetadataItem] }`<br>- a good `hashValue` here can be had by simply forwarding the hashValue for `identifier`<br></p><p>…and at least IMHO, in a perfect world, if you *were* to introduce automatic synthesis of `Hashable` for product types, I’d want to be able to indicate which implementation-strategy should be used.<br></p><p>Which, honestly, seems hard to do without baking in special handling for Hashable, and by extension without each synthesis-supporting protocol getting special treatment (and thus leaving “third party” protocols a bit hamstrung in terms of being availble-for-synthesis themselves).<br></p><p>Even mere `Comparable` has similar amounts of fiddly detail — you probably want lexicographic, but in what ordering? do you want any of the constituent types&#39; orderings flipped? — and so on and so forth.<br></p><p>&gt; On Dec 5, 2015, at 12:46 AM, Harlan Haskins &lt;harlan at harlanhaskins.com&gt; wrote:<br>&gt; <br>&gt; I feel like, if we implement automatic derivation for structs that wrap one value, we can just as easily implement automatic derivation for all product types for which the children conform to the protocols in question, and there’s a provided implementation for derivation by combining values.<br>&gt; <br>&gt; Consider Hashable. A very common implementation of hashValue is xor-ing all the members’ hash values together.<br>&gt; We could actually implement this right now given Swift’s reflection system (if we were able to conditionally cast to Hashable or any protocol with a Self requirement).<br>&gt; <br>&gt; Consider this:<br>&gt; <br>&gt; struct HashableDerivable deriving Hashable {<br>&gt;     let string: String // because String is already Hashable<br>&gt;     let integer: Int   // and Int is Hashable<br>&gt;     // then HashableDerivable is trivially Hashable.<br>&gt; }<br>&gt; <br>&gt; /// This implementation is absolutely derivable at compile time.<br>&gt; extension HashableDerivable: Hashable {<br>&gt;     var hashValue: Int {<br>&gt;         return string.hashValue ^ integer.hashValue<br>&gt;     }<br>&gt; }<br>&gt; func ==(lhs: HashableDerivable, rhs: HashableDerivable) -&gt; Bool {<br>&gt;     return lhs.string == rhs.string &amp;&amp; lhs.integer == rhs.integer<br>&gt; }<br>&gt; <br>&gt; // one can also use Reflection to derive this at runtime<br>&gt; <br>&gt; extension Mirror {<br>&gt;     func canDeriveHashable() -&gt; Bool {<br>&gt;         if self.subjectType is Hashable { return true } // this is currently a compiler error<br>&gt;         for child in self.children {<br>&gt;             let mirror = Mirror(reflecting: child)<br>&gt;             if !mirror.canDeriveHashable() { return false }<br>&gt;         }<br>&gt;         return true<br>&gt;     }<br>&gt;     func deriveHashValue() -&gt; Int {<br>&gt;         if !self.canDeriveHashable() { fatalError(&quot;Boy, I wish this didn&#39;t have to happen at runtime.&quot;) }<br>&gt;         guard let firstChild = self.children.first as? Hashable /* also an error */ else { fatalError(&quot;no children&quot;) }<br>&gt;         return self.children.dropFirst().reduce(firstChild.hashValue) { (hash, _: (_: String?, value: Any)) -&gt; T in<br>&gt;             return hash ^ (value as! Hashable).hashValue<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; Of course, this is something that can be done at compile time, which would make protocol conformance really, really simple.<br>&gt; <br>&gt; We already do this, using the Mirror API, for CustomStringConvertible.<br>&gt;&gt; &gt; On Dec 4, 2015, at 4:26 PM, John McCall &lt;rjmccall at apple.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt; &gt; <br>&gt;&gt; &gt;&gt; On Dec 4, 2015, at 1:19 PM, plx &lt;plxswift at icloud.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt; # A `wrapper` / `deriving` Construct<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; I&#39;m sure a construct along these lines has been requested numerous times and is hopefully already on the roadmap.<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; The point of this email is to put out a reasonably-*concrete* sketch as a way of soliciting community feedback on the specifics of how such a construct might look-and-work within Swift; hopefully I’ve gone far-enough to be interesting, but not too much further than that.<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; ## Design Sketch<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; It ought to be possible to write something like this:<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt;   // an example:<br>&gt;&gt; &gt;&gt;   struct SectionIndex<br>&gt;&gt; &gt;&gt;     wrapping Int<br>&gt;&gt; &gt;&gt;     as index<br>&gt;&gt; &gt;&gt;     satisfying precondition { $0 &gt;= 0 }<br>&gt;&gt; &gt;&gt;     deriving Equatable, Comparable, Hashable {<br>&gt;&gt; &gt;&gt;     // declaration can continue in here<br>&gt;&gt; &gt;&gt;   }<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; ...which, when compiled, would be &quot;expanded&quot; along these lines:<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt;   struct SectionIndex {<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt;     // would have been `wrappedValue` w/out the `as index` clause<br>&gt;&gt; &gt;&gt;     let index: Int<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt;     init(_ index: Int) {<br>&gt;&gt; &gt;&gt;       precondition(index &gt;= 0) <br>&gt;&gt; &gt;&gt;       // ^ would have been assert(index &gt;= 0) <br>&gt;&gt; &gt;&gt;       //   had we used `satisfying { $0 &gt;= 0 }`,<br>&gt;&gt; &gt;&gt;       //   and omitted entirely had we omitted a `satisfying` clause<br>&gt;&gt; &gt;&gt;       self.index = index<br>&gt;&gt; &gt;&gt;     }<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt;   }<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt;   extension SectionIndex : Equatable {<br>&gt;&gt; &gt;&gt;   }<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt;   // synthesized unless explicitly written-out<br>&gt;&gt; &gt;&gt;   func ==(lhs: SectionIndex, rhs: SectionIndex) -&gt; Bool {<br>&gt;&gt; &gt;&gt;     return lhs.index == rhs.index<br>&gt;&gt; &gt;&gt;   }<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt;   // same for Comparable, Hashable, all done in the obvious way    <br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt;   // there’s a lot of utility in synthesizing something like this,<br>&gt;&gt; &gt;&gt;   //  I can expand on it if necessary:<br>&gt;&gt; &gt;&gt;   extension SectionIndex: ValueWrapperType {<br>&gt;&gt; &gt;&gt;     typealias WrappedType = Int<br>&gt;&gt; &gt;&gt;   }<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; ...where each method/init/subscript/etc in the derived protocols gets synthesized at compile-time, if not explicitly implemented; similarly, if not explicitly-declared, the derived protocols&#39; typealiases can be synthesized in obvious ways, and it seems acceptable to simply fail to compile (and inform the user of the need to make an explicit-declaration) in cases where such synthesis is impossible.<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; I think this enough to sketch the way the feature would look and how it would work. <br>&gt;&gt; &gt; <br>&gt;&gt; &gt; I’m not sure what work is being done by “wrapping X as Y” here; it seems like just another way of expressing a stored property.<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; I think we’re all interested in a “deriving” proposal.  However, the key problem that a serious proposal would have to address is not picking the syntax, but describing how derivation would actually work.  We’d prefer not to just hard-code rules in the compiler for specific protocols.<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; For example, derivation presumably involves recursively invoking the given operation on each of the stored properties (what does “on” mean? which parameters are changed, and which are passed through?) and then merging the results (how?).<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; John.<br>&gt;&gt; <br>&gt;&gt; Apologies for leaving too much out.<br>&gt;&gt; <br>&gt;&gt; I meant to propose that the `deriving` in this place would enforce the wrapper type only wrapped a single stored value, warranting the distinct syntax; I seem to have edited-out both an explicit statement that this assumed a single-stored-property and to have omitted a comment in the `//declaration can continue in here` that no additional stored-properties could be declared (analogous to the rules current applied within extensions).<br>&gt;&gt; <br>&gt;&gt; Yes, constraining a `deriving` construct to only support wrappers containing a single stored property would, on the one hand, be somewhat limiting, but on the other hand it would seemingly allow trivial solutions to the issues you bring up:<br>&gt;&gt; <br>&gt;&gt; - `on` is unambiguous as there’s only one thing it can be “on&quot;<br>&gt;&gt; - there’s no ordering-of-operations to have to worry about<br>&gt;&gt; - there’s no merging-of-results to have to worry about<br>&gt;&gt; - i’m guessing there’s no parameters needing to getting changed (but I’m not 100% on what you mean here)<br>&gt;&gt; - there’s no associated-type incoherency to worry about (unless user error introduces it)<br>&gt;&gt; <br>&gt;&gt; …there’s least one tricky case (if you want the wrapper to replace one of the wrapped type’s typealiases with a wrapper).<br>&gt;&gt; <br>&gt;&gt; …and at least for me, there’s enough value in that simplified wrapper-synthesis / deriving-type construct to take the time to check community interest. <br>&gt;&gt; <br>&gt;&gt; Thanks for taking the time to read and send feedback.<br>&gt;&gt; <br>&gt;&gt; PS:<br>&gt;&gt; <br>&gt;&gt; On the other hand, if this becomes writable:<br>&gt;&gt; <br>&gt;&gt;     protocol WrapperType {<br>&gt;&gt;        typealias WrappedValue<br>&gt;&gt;        var wrappedValue: { get }<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     extension WrapperType : Equatable where WrappedValue: Equatable {<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     func ==&lt;W:WrapperType where W.WrappedValue:Equatable&gt;(lhs: W, rhs: W) -&gt; Bool {<br>&gt;&gt;       return lhs.wrappedValue == rhs.wrappedValue<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; …etc., then it’s possible (albeit moderately unpleasant) to just write suitable glue logic out longhand on an as-needed basis (and with the caveat that all types wrapping T would potentially adopt all of T’s protocols even when potentially undesirable).<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/8da52390/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: Automatic Wrapper Synthesis / &quot;deriving&quot;</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December  5, 2015 at 10:00:00am</p></header><div class="content"><p>I would also like to see a feature that supports concisely wrapping a type akin to Haskell’s newtype.  However I wonder if it might be worthwhile to give consideration a more general feature that also supports composition and forwarding more generally, with “newtype” being the simplest, most straightforward use of the feature.  <br></p><p><br>&gt; On Dec 5, 2015, at 9:57 AM, plx &lt;plxswift at icloud.com&gt; wrote:<br>&gt; <br>&gt; I definitely got off on the wrong foot by using `deriving`; what I was trying to ask for is more of a stronger typealias (perhaps `newtype`-esque is the right analogy?), which — at least for my purposes — would *ideally* have the following capabilities / rules:<br>&gt; <br>&gt; - when Y is a wrapper around an X, Y has only a single, “synthesized&quot; stored property (of type X)<br>&gt; - the user can control the name of the stored property by one of these mechanisms (which one is used is moot to me):<br>&gt;   - override the name of the synthesized stored property<br>&gt;   - indicate another name and have an accessor auto-generated<br>&gt; - every protocol adopted by X *can* be auto-synthesized for Y <br>&gt;   - but the user has to explicitly request each specific protocol be synthesized…<br>&gt;   - …because it’s very important that it be possible to *not* adopt every one of X’s protocols<br>&gt; - the user can optionally provide some predicate (of type (X) -&gt; Bool), which then:<br>&gt;   - is included as an assert/precondition inside a synthesized `init(_ x: X)` <br>&gt;   - is perhaps/can-be used inside some synthesized `init?(_ x: X)` (this is trickier at present, and might be better as a static func)<br>&gt;   - is ideally available on some methods like `func isInvariantSatisfied() -&gt; Bool; static func isWrappableValue(x: X) -&gt; Bool` (e.g. for debugging/testing)<br>&gt;   - …are essentially for documentation and some very modest runtime verification<br>&gt; - there’s some standard/principled way to do type-erasure &quot;back down to X” as-needed<br>&gt; <br>&gt; Only supporting single-value-wrappers should make the needed syntheses essentially trivial as far as I can tell; the only obviously non-trivial aspect is that, in practice, it’d seem likely that you’d want to occasionally “override” the typealiases from X with wrappers thereof; e.g. if you had a type Y wrapping Set&lt;Foo&gt;, you might want Y’s `Index` to be a wrapper around `SetIndex&lt;Foo&gt;` and *not just* `SetIndex&lt;Foo&gt;`; this doesn’t seem overly-complicated semantically but it isn’t “trivial”, either, and would perhaps need additional syntax support to read nicely in-use.<br>&gt; <br>&gt; Here are a few concrete example motivating the above requests:<br>&gt; <br>&gt; ## UI-Level Section/Item Indices<br>&gt; <br>&gt; It’s a nice — albeit minor — improvement to work with Int-wrappers like `SectionIndex` and `ItemIndex` rather than as primitive, interchangeable `Int` everywhere. It’s particularly handy if trying to write reasonably-generic implementations of the common UI-level datasource/delegate protocols.<br>&gt; <br>&gt; For this:<br>&gt; <br>&gt; - it’s nice to have the wrapped value accessible as `index` (as opposed to e.g. `wrappedValue` or `storage`, etc.)<br>&gt; - it’s nice to *not* wind up with the arithmetic operations from `Int`:<br>&gt;   - accidental use of e.g. `*` or `+` or `-` (etc.) on `SectionIndex` or `ItemIndex` is *probably* an error!<br>&gt; - it’s nice to *not* wind up as `IntegerLiteralConvertible`:<br>&gt;   - hard-coded literal indices are rarely advisable in application code!<br>&gt;   - being `IntegerLiteralConvertible` reintroduces transposition-error risk!<br>&gt; - it’s nice to have the constructors assert that the wrapped indices aren’t:<br>&gt;   - == NSNotFound<br>&gt;   - negative <br>&gt; <br>&gt; …and although this can be done by hand, it’s an example of a use that *could* be synthesized.<br>&gt; <br>&gt; ## URL Segregation<br>&gt; <br>&gt; It can be moderately useful to have a bunch of lightweight URL-wrapper types to avoid transposition errors and also to ensure appropriate handling (e.g. using the appropriate URL session); picture, say, `IconImageURL`, `HeroImageURL`, `DetailImageURL`, `APIEndpointURL` (etc.).<br>&gt; <br>&gt; If you *did* go this route, some standard way of doing &quot;type-erasure” down to the underlying type can be useful:<br>&gt; <br>&gt;     class ActiveTransferMonitor {<br>&gt;       private var activeTransfers: [URL:TransferMetrics] = [:]<br>&gt; <br>&gt;       func didBeginTransfer&lt;T:ValueWrapperType where T.WrappedValue: URL&gt;(transferURL: T) {<br>&gt;         self.activeTransfers[transferURL.URL] = TransferMetrics()<br>&gt;       }<br>&gt;     }<br>&gt; <br>&gt; …but this is the example I feel least strongly about (it’s just here to motivate the “standard type-erasure mechanism” aspect).<br>&gt; <br>&gt; ## Bluetooth<br>&gt; <br>&gt; For Bluetooth LE, you have peripherals, which have *services*, which contain *characteristics*, which can have associated *descriptors*. Each service, characteristic, or descriptor is identified by a unique identifier, which is modeled in CoreBluetooth as instances of the `CBUUID` class.<br>&gt; <br>&gt; It’s handy here for correctness to have distinct wrapper types, let’s call them `ServiceUUID`, `CharacteristicUUID`, and `DescriptorUUID`, both to guard against simple transposition errors and to make some internal APIs more self-documenting.<br>&gt; <br>&gt; It’s handy here for readability to have the wrapped UUID be accessible as, e.g. `.UUID`, and not as some generic `.wrappedValue`:<br>&gt;   <br>&gt;     extension CBPeripheral {<br>&gt;       <br>&gt;       func locatePrimaryService(serviceIdentifier: ServiceUUID) -&gt; CBService? {<br>&gt;         return self.services?.firstElementSatisfying() {<br>&gt;           $0.UUID.isEqual(serviceIdentifier.UUID)<br>&gt;         }<br>&gt;       }<br>&gt;   <br>&gt;     }<br>&gt; <br>&gt; At present, the easiest way to get these all setup was as-follows:<br>&gt; <br>&gt; - create a protocol like `BluetoothEntityUUIDType` that:<br>&gt;   - also adopts the protocols it should<br>&gt;   - has as many default implementations as possible<br>&gt; - create a struct for `ServiceUUID` that:<br>&gt;   - wraps a single CBUUID instance <br>&gt;   - conforms to `BluetoothEntityUUIDType`<br>&gt;   - manually adds any missing conformances / logic<br>&gt; - create files for `CharacteristicUUID` and `DescriptorUUID`<br>&gt;   - copy-and-paste the definition of `ServiceUUID` into the `CharacteristicUUID` file<br>&gt;   - find-and-replace `Service` with `Characteristic`<br>&gt;   - copy-and-paste the definition of `ServiceUUID` into the `DescriptorUUID` file<br>&gt;   - find-and-replace `Service` with `Descriptor`<br>&gt;   - edit the `init` (etc.) for `DescriptorUUID ` to add asserts that the passed-in `CBUUID` is one of 6 allowed, pre-defined CBUUIDs applicable to CBDescriptor<br>&gt; <br>&gt; …it works, it’s not too terrible as a one-off, but it’s also tedious and runs the risk of implementation drift (especially due to `CBDescriptor` having validation logic the others don’t) in the event that the initial copy-paste-edit cycle needs to be repeated.<br>&gt; <br>&gt; Likewise, there’s small things that are nice utilities to tack-onto the various identifier types (utilities to check if they are some well-known ID) that risk getting accidentally blown away if the copy-paste-edit cycle gets repeated; these *can* be defined in other files, but that in turn *can* require “unnatural” choice of visibility (in some cases).<br>&gt; <br>&gt; ## Closing Comments<br>&gt; <br>&gt; For anyone who read this far, thanks for taking the time. I hope the concrete examples helps shed some light on both the motivation and the intended scope for this feature request.<br>&gt; <br>&gt; The common theme in the examples is that in the individual use, the amount of wrapping is small enough that:<br>&gt; <br>&gt; - it can be done by hand<br>&gt; - there are not enough wrappers to really justify writing a code-gen tool…<br>&gt; - …especially since (in practice) many of the wrappers benefit from small “customization” here-and-there<br>&gt; - there are readability-and-correctness benefits to having the wrappers available<br>&gt; <br>&gt; …but I think having wrapper-synthesis — or a functional equivalent — as an easily-accessible part of the language would open the door more broadly to writing in this style, in ways which aren&#39;t always cost-or-time-effective today.<br>&gt; <br>&gt; Finally, as I keep mentioning, it’s entirely possible that improvements to the type system will make protocols + default method implementations able to get this features’ benefits without requiring any additional support from the language or tooling; I’d be happy-enough with that outcome also.<br>&gt; <br>&gt; Thanks again for the time and feedback. If there’s enough community interest I can prepare a formal proposal, otherwise I’ve said everything I have to say on this idea.<br>&gt; <br>&gt; ## PS: Product-Type Handling<br>&gt; <br>&gt; I honestly think that handling product types with deriving is hard-enough it’s not really worth trying to do; there’s certainly some limited value in being able to synthesize (component-wise) `Equatable` and so on, but once you get past the very foundational protocols like `Equatable` / `Comparable` / `Hashable` / `CustomStringConvertible` / `CustomDebugStringConvertible` you start hitting tricky problems it’s not clear .<br>&gt; <br>&gt; EG: how do you synthesize a CollectionType implementation for, e.g., a product of two `CollectionType` types? Sure, you can safely bet the type of the synthesized Element is going to be the product of the component elements, but how do you plan to synthesize the implementation of a proper `ForwardIndexType` from the product of the component collections&#39; `ForwardIndexType`s? There’s a lot of ways to do this, with different resulting iteration ordering and different performance/resource tradeoffs, and it’s hard to do auto-synthesis here that doesn’t either just “pick a winner” (and leave you hanging if you wanted a different implementation) or wind up introducing a mini-language to let you indicate which variant it should synthesize.<br>&gt; <br>&gt; Moreover, note that even for, e.g., `Hashable`, there are actually at least a couple common strategies I often see.<br>&gt; <br>&gt; One is the `xor`-everything strategy, except:<br>&gt; <br>&gt; - it’s IMHO a good idea to rotate some of the constituent hashes to avoid accidentally hashing a lot of stuff to zero<br>&gt; - you don’t always want to hash *everything*<br>&gt; - you may want/need to hash transformed/normalized forms of constituent values, not the “raw” values<br>&gt; <br>&gt; Another is the “forward to a good identifier” strategy, e.g.:<br>&gt; <br>&gt; - you have a type like `struct ContentMetadata { let identifier: ContentIdentifier; let metadata: [String:MetadataItem] }`<br>&gt; - a good `hashValue` here can be had by simply forwarding the hashValue for `identifier`<br>&gt; <br>&gt; …and at least IMHO, in a perfect world, if you *were* to introduce automatic synthesis of `Hashable` for product types, I’d want to be able to indicate which implementation-strategy should be used.<br>&gt; <br>&gt; Which, honestly, seems hard to do without baking in special handling for Hashable, and by extension without each synthesis-supporting protocol getting special treatment (and thus leaving “third party” protocols a bit hamstrung in terms of being availble-for-synthesis themselves).<br>&gt; <br>&gt; Even mere `Comparable` has similar amounts of fiddly detail — you probably want lexicographic, but in what ordering? do you want any of the constituent types&#39; orderings flipped? — and so on and so forth.<br>&gt; <br>&gt;&gt; On Dec 5, 2015, at 12:46 AM, Harlan Haskins &lt;harlan at harlanhaskins.com &lt;mailto:harlan at harlanhaskins.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I feel like, if we implement automatic derivation for structs that wrap one value, we can just as easily implement automatic derivation for all product types for which the children conform to the protocols in question, and there’s a provided implementation for derivation by combining values.<br>&gt;&gt; <br>&gt;&gt; Consider Hashable. A very common implementation of hashValue is xor-ing all the members’ hash values together.<br>&gt;&gt; We could actually implement this right now given Swift’s reflection system (if we were able to conditionally cast to Hashable or any protocol with a Self requirement).<br>&gt;&gt; <br>&gt;&gt; Consider this:<br>&gt;&gt; <br>&gt;&gt; struct HashableDerivable deriving Hashable {<br>&gt;&gt;     let string: String // because String is already Hashable<br>&gt;&gt;     let integer: Int   // and Int is Hashable<br>&gt;&gt;     // then HashableDerivable is trivially Hashable.<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; /// This implementation is absolutely derivable at compile time.<br>&gt;&gt; extension HashableDerivable: Hashable {<br>&gt;&gt;     var hashValue: Int {<br>&gt;&gt;         return string.hashValue ^ integer.hashValue<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; func ==(lhs: HashableDerivable, rhs: HashableDerivable) -&gt; Bool {<br>&gt;&gt;     return lhs.string == rhs.string &amp;&amp; lhs.integer == rhs.integer<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // one can also use Reflection to derive this at runtime<br>&gt;&gt; <br>&gt;&gt; extension Mirror {<br>&gt;&gt;     func canDeriveHashable() -&gt; Bool {<br>&gt;&gt;         if self.subjectType is Hashable { return true } // this is currently a compiler error<br>&gt;&gt;         for child in self.children {<br>&gt;&gt;             let mirror = Mirror(reflecting: child)<br>&gt;&gt;             if !mirror.canDeriveHashable() { return false }<br>&gt;&gt;         }<br>&gt;&gt;         return true<br>&gt;&gt;     }<br>&gt;&gt;     func deriveHashValue() -&gt; Int {<br>&gt;&gt;         if !self.canDeriveHashable() { fatalError(&quot;Boy, I wish this didn&#39;t have to happen at runtime.&quot;) }<br>&gt;&gt;         guard let firstChild = self.children.first as? Hashable /* also an error */ else { fatalError(&quot;no children&quot;) }<br>&gt;&gt;         return self.children.dropFirst().reduce(firstChild.hashValue) { (hash, _: (_: String?, value: Any)) -&gt; T in<br>&gt;&gt;             return hash ^ (value as! Hashable).hashValue<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Of course, this is something that can be done at compile time, which would make protocol conformance really, really simple.<br>&gt;&gt; <br>&gt;&gt; We already do this, using the Mirror API, for CustomStringConvertible.<br>&gt;&gt;&gt; &gt; On Dec 4, 2015, at 4:26 PM, John McCall &lt;rjmccall at apple.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt; &gt;&gt; On Dec 4, 2015, at 1:19 PM, plx &lt;plxswift at icloud.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt; # A `wrapper` / `deriving` Construct<br>&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt; &gt;&gt; I&#39;m sure a construct along these lines has been requested numerous times and is hopefully already on the roadmap.<br>&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt; &gt;&gt; The point of this email is to put out a reasonably-*concrete* sketch as a way of soliciting community feedback on the specifics of how such a construct might look-and-work within Swift; hopefully I’ve gone far-enough to be interesting, but not too much further than that.<br>&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt; &gt;&gt; ## Design Sketch<br>&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt; &gt;&gt; It ought to be possible to write something like this:<br>&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt; &gt;&gt;   // an example:<br>&gt;&gt;&gt; &gt;&gt;   struct SectionIndex<br>&gt;&gt;&gt; &gt;&gt;     wrapping Int<br>&gt;&gt;&gt; &gt;&gt;     as index<br>&gt;&gt;&gt; &gt;&gt;     satisfying precondition { $0 &gt;= 0 }<br>&gt;&gt;&gt; &gt;&gt;     deriving Equatable, Comparable, Hashable {<br>&gt;&gt;&gt; &gt;&gt;     // declaration can continue in here<br>&gt;&gt;&gt; &gt;&gt;   }<br>&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt; &gt;&gt; ...which, when compiled, would be &quot;expanded&quot; along these lines:<br>&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt; &gt;&gt;   struct SectionIndex {<br>&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt; &gt;&gt;     // would have been `wrappedValue` w/out the `as index` clause<br>&gt;&gt;&gt; &gt;&gt;     let index: Int<br>&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt; &gt;&gt;     init(_ index: Int) {<br>&gt;&gt;&gt; &gt;&gt;       precondition(index &gt;= 0) <br>&gt;&gt;&gt; &gt;&gt;       // ^ would have been assert(index &gt;= 0) <br>&gt;&gt;&gt; &gt;&gt;       //   had we used `satisfying { $0 &gt;= 0 }`,<br>&gt;&gt;&gt; &gt;&gt;       //   and omitted entirely had we omitted a `satisfying` clause<br>&gt;&gt;&gt; &gt;&gt;       self.index = index<br>&gt;&gt;&gt; &gt;&gt;     }<br>&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt; &gt;&gt;   }<br>&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt; &gt;&gt;   extension SectionIndex : Equatable {<br>&gt;&gt;&gt; &gt;&gt;   }<br>&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt; &gt;&gt;   // synthesized unless explicitly written-out<br>&gt;&gt;&gt; &gt;&gt;   func ==(lhs: SectionIndex, rhs: SectionIndex) -&gt; Bool {<br>&gt;&gt;&gt; &gt;&gt;     return lhs.index == rhs.index<br>&gt;&gt;&gt; &gt;&gt;   }<br>&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt; &gt;&gt;   // same for Comparable, Hashable, all done in the obvious way    <br>&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt; &gt;&gt;   // there’s a lot of utility in synthesizing something like this,<br>&gt;&gt;&gt; &gt;&gt;   //  I can expand on it if necessary:<br>&gt;&gt;&gt; &gt;&gt;   extension SectionIndex: ValueWrapperType {<br>&gt;&gt;&gt; &gt;&gt;     typealias WrappedType = Int<br>&gt;&gt;&gt; &gt;&gt;   }<br>&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt; &gt;&gt; ...where each method/init/subscript/etc in the derived protocols gets synthesized at compile-time, if not explicitly implemented; similarly, if not explicitly-declared, the derived protocols&#39; typealiases can be synthesized in obvious ways, and it seems acceptable to simply fail to compile (and inform the user of the need to make an explicit-declaration) in cases where such synthesis is impossible.<br>&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt; &gt;&gt; I think this enough to sketch the way the feature would look and how it would work. <br>&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt; &gt; I’m not sure what work is being done by “wrapping X as Y” here; it seems like just another way of expressing a stored property.<br>&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt; &gt; I think we’re all interested in a “deriving” proposal.  However, the key problem that a serious proposal would have to address is not picking the syntax, but describing how derivation would actually work.  We’d prefer not to just hard-code rules in the compiler for specific protocols.<br>&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt; &gt; For example, derivation presumably involves recursively invoking the given operation on each of the stored properties (what does “on” mean? which parameters are changed, and which are passed through?) and then merging the results (how?).<br>&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt; &gt; John.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Apologies for leaving too much out.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I meant to propose that the `deriving` in this place would enforce the wrapper type only wrapped a single stored value, warranting the distinct syntax; I seem to have edited-out both an explicit statement that this assumed a single-stored-property and to have omitted a comment in the `//declaration can continue in here` that no additional stored-properties could be declared (analogous to the rules current applied within extensions).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, constraining a `deriving` construct to only support wrappers containing a single stored property would, on the one hand, be somewhat limiting, but on the other hand it would seemingly allow trivial solutions to the issues you bring up:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - `on` is unambiguous as there’s only one thing it can be “on&quot;<br>&gt;&gt;&gt; - there’s no ordering-of-operations to have to worry about<br>&gt;&gt;&gt; - there’s no merging-of-results to have to worry about<br>&gt;&gt;&gt; - i’m guessing there’s no parameters needing to getting changed (but I’m not 100% on what you mean here)<br>&gt;&gt;&gt; - there’s no associated-type incoherency to worry about (unless user error introduces it)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; …there’s least one tricky case (if you want the wrapper to replace one of the wrapped type’s typealiases with a wrapper).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; …and at least for me, there’s enough value in that simplified wrapper-synthesis / deriving-type construct to take the time to check community interest. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks for taking the time to read and send feedback.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; PS:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On the other hand, if this becomes writable:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     protocol WrapperType {<br>&gt;&gt;&gt;        typealias WrappedValue<br>&gt;&gt;&gt;        var wrappedValue: { get }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     extension WrapperType : Equatable where WrappedValue: Equatable {<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     func ==&lt;W:WrapperType where W.WrappedValue:Equatable&gt;(lhs: W, rhs: W) -&gt; Bool {<br>&gt;&gt;&gt;       return lhs.wrappedValue == rhs.wrappedValue<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; …etc., then it’s possible (albeit moderately unpleasant) to just write suitable glue logic out longhand on an as-needed basis (and with the caveat that all types wrapping T would potentially adopt all of T’s protocols even when potentially undesirable).<br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/77d78447/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
