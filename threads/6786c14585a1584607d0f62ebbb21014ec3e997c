<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/32ed5b32826658f01df18fa220fa090e?s=50"></div><header><strong>Simplified Conversion of Integer Types</strong> from <string>Haravikk</string> &lt;me at haravikk.com&gt;<p>January 15, 2016 at 10:00:00am</p></header><div class="content"><p>Something that’s still an annoyance to me in Swift is conversion between different integer types, both by size and signed vs. unsigned, as many mismatches result in errors requiring either refactoring to one common type, or boiler-plate to cast the values. This is annoying, and the end result seems to be that most people just use a regular Int for everything, including cases where negative values aren’t required or are even invalid (requiring code to check for these, or handle any faults).<br></p><p>This can be highlighted with the following simple example:<br></p><p>var a:Int64 = 12345<br>let b:Int16 = 123<br>a += b<br></p><p>The last line currently results in an error that the two types differ, which is really just an annoyance as there’s clearly ample room for the addition to proceed successfully. Requiring me to instead do a += Int64(b) which seems unnecessary.<br></p><p>I’d like to propose that Swift implicitly cast values to an integer type with a larger size (so in this case there is no error as an Int64 is larger than an Int16). However, in the opposite case an error would occur, but could be suppressed with the overflow operator (allowing simple casts to small sizes), for example:<br></p><p>var a:Int16 = 123<br>var b:Int64 = 12345<br>a &amp;+= b<br></p><p>Lastly there’s the case of unsigned vs signed integers, in which case similar rules should apply, i.e- a UInt32 can be safely cast to an Int64, but would require the overflow operator to cast implicitly to Int32 (as it can’t represent the full range of positive values that UInt32 can). The trickier case is what to do with conversion of signed to unsigned types, since they could contain negative values that can’t be represented at any size, but I’d say allowing the developer to permit overflow in these cases is fine too.<br></p><p>Essentially what I want is a better system for converting between integer types, as my preference is to use the type that most efficiently stores the range of values that I require, particularly in arrays, but I keep finding myself having to add extra code around these which slows down development and makes for messier looking code, even though most of the time I’m taking a smaller type and manipulating it within a larger one.<br></p><p>Anyway, I’m wondering what others think? I know it may seem fairly minor, but I seem to have a tendency to work with numbers a lot, and always having to think about what I need to convert each variable to or from just slows me down.<br></p><p>- Haravikk<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: smime.p7s<br>Type: application/pkcs7-signature<br>Size: 1567 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160115/6786997c/attachment.p7s&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Simplified Conversion of Integer Types</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 15, 2016 at 09:00:00am</p></header><div class="content"><p>On Jan 15, 2016, at 2:46 AM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Something that’s still an annoyance to me in Swift is conversion between different integer types, both by size and signed vs. unsigned, as many mismatches result in errors requiring either refactoring to one common type, or boiler-plate to cast the values.<br></p><p>Yes, it is.<br></p><p>&gt; I’d like to propose that Swift implicitly cast values to an integer type with a larger size (so in this case there is no error as an Int64 is larger than an Int16).<br></p><p>This is also my desire.<br></p><p>DaveA and Max have a tentative plan to improve integer semantics in these phases:<br></p><p>1. Improve the comparison and shift operators to not require symmetry.  You should be able to do “someUInt == someInt” and get a proper value comparison.<br></p><p>2. Improve the numerics related protocols to enable writing generic code over different width types.<br></p><p>3. Introduce subtyping relationships between the integers and the floats so that we can implicit promotions from smaller to wider types.  This can either be done with a general language feature to introduce subtyping of structs/enums or by hacking it into the compiler, different folks have different opinions on how this will work, and it isn’t designed yet.<br></p><p>The first two are a strong goal for swift 3, the later is &quot;nice to have” if it fits since it is “just” sugar and there is a lot of other stuff going on.  We are also interested in introducing a proper BigInt type, but that is even “nicer to have” for Swift 3.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Simplified Conversion of Integer Types</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>January 19, 2016 at 05:00:00pm</p></header><div class="content"><p>+1 for all three, and +1 for introducing sub-typing for structs and enums, for those times when you want sub-typing *and* value semantics.<br></p><p>- Dave Sweeris<br></p><p>&gt; On Jan 15, 2016, at 09:51, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Jan 15, 2016, at 2:46 AM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Something that’s still an annoyance to me in Swift is conversion between different integer types, both by size and signed vs. unsigned, as many mismatches result in errors requiring either refactoring to one common type, or boiler-plate to cast the values.<br>&gt; <br>&gt; Yes, it is.<br>&gt; <br>&gt;&gt; I’d like to propose that Swift implicitly cast values to an integer type with a larger size (so in this case there is no error as an Int64 is larger than an Int16).<br>&gt; <br>&gt; This is also my desire.<br>&gt; <br>&gt; DaveA and Max have a tentative plan to improve integer semantics in these phases:<br>&gt; <br>&gt; 1. Improve the comparison and shift operators to not require symmetry.  You should be able to do “someUInt == someInt” and get a proper value comparison.<br>&gt; <br>&gt; 2. Improve the numerics related protocols to enable writing generic code over different width types.<br>&gt; <br>&gt; 3. Introduce subtyping relationships between the integers and the floats so that we can implicit promotions from smaller to wider types.  This can either be done with a general language feature to introduce subtyping of structs/enums or by hacking it into the compiler, different folks have different opinions on how this will work, and it isn’t designed yet.<br>&gt; <br>&gt; The first two are a strong goal for swift 3, the later is &quot;nice to have” if it fits since it is “just” sugar and there is a lot of other stuff going on.  We are also interested in introducing a proper BigInt type, but that is even “nicer to have” for Swift 3.<br>&gt; <br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Simplified Conversion of Integer Types</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January 20, 2016 at 12:00:00pm</p></header><div class="content"><p>Same as Dave &quot;+1 for all three, and +1 for introducing sub-typing for<br>structs and enums, for those times when you want sub-typing *and* value<br>semantics.&quot;<br></p><p>On Wednesday, 20 January 2016, Dave via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; +1 for all three, and +1 for introducing sub-typing for structs and enums,<br>&gt; for those times when you want sub-typing *and* value semantics.<br>&gt;<br>&gt; - Dave Sweeris<br>&gt;<br>&gt; &gt; On Jan 15, 2016, at 09:51, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; On Jan 15, 2016, at 2:46 AM, Haravikk via swift-evolution &lt;<br>&gt; swift-evolution at swift.org &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Something that’s still an annoyance to me in Swift is conversion<br>&gt; between different integer types, both by size and signed vs. unsigned, as<br>&gt; many mismatches result in errors requiring either refactoring to one common<br>&gt; type, or boiler-plate to cast the values.<br>&gt; &gt;<br>&gt; &gt; Yes, it is.<br>&gt; &gt;<br>&gt; &gt;&gt; I’d like to propose that Swift implicitly cast values to an integer<br>&gt; type with a larger size (so in this case there is no error as an Int64 is<br>&gt; larger than an Int16).<br>&gt; &gt;<br>&gt; &gt; This is also my desire.<br>&gt; &gt;<br>&gt; &gt; DaveA and Max have a tentative plan to improve integer semantics in<br>&gt; these phases:<br>&gt; &gt;<br>&gt; &gt; 1. Improve the comparison and shift operators to not require symmetry.<br>&gt; You should be able to do “someUInt == someInt” and get a proper value<br>&gt; comparison.<br>&gt; &gt;<br>&gt; &gt; 2. Improve the numerics related protocols to enable writing generic code<br>&gt; over different width types.<br>&gt; &gt;<br>&gt; &gt; 3. Introduce subtyping relationships between the integers and the floats<br>&gt; so that we can implicit promotions from smaller to wider types.  This can<br>&gt; either be done with a general language feature to introduce subtyping of<br>&gt; structs/enums or by hacking it into the compiler, different folks have<br>&gt; different opinions on how this will work, and it isn’t designed yet.<br>&gt; &gt;<br>&gt; &gt; The first two are a strong goal for swift 3, the later is &quot;nice to have”<br>&gt; if it fits since it is “just” sugar and there is a lot of other stuff going<br>&gt; on.  We are also interested in introducing a proper BigInt type, but that<br>&gt; is even “nicer to have” for Swift 3.<br>&gt; &gt;<br>&gt; &gt; -Chris<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br>-- <br>  -- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160120/a86d9638/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Simplified Conversion of Integer Types</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>January 19, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jan 15, 2016, at 9:51 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; On Jan 15, 2016, at 2:46 AM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Something that’s still an annoyance to me in Swift is conversion between different integer types, both by size and signed vs. unsigned, as many mismatches result in errors requiring either refactoring to one common type, or boiler-plate to cast the values.<br>&gt; <br>&gt; Yes, it is.<br>&gt; <br>&gt;&gt; I’d like to propose that Swift implicitly cast values to an integer type with a larger size (so in this case there is no error as an Int64 is larger than an Int16).<br>&gt; <br>&gt; This is also my desire.<br>&gt; <br>&gt; DaveA and Max have a tentative plan to improve integer semantics in these phases:<br>&gt; <br>&gt; 1. Improve the comparison and shift operators to not require symmetry.  You should be able to do “someUInt == someInt” and get a proper value comparison.<br>&gt; <br>&gt; 2. Improve the numerics related protocols to enable writing generic code over different width types.<br>&gt; <br>&gt; 3. Introduce subtyping relationships between the integers and the floats so that we can implicit promotions from smaller to wider types.  This can either be done with a general language feature to introduce subtyping of structs/enums or by hacking it into the compiler, different folks have different opinions on how this will work, and it isn’t designed yet.<br>&gt; <br>&gt; The first two are a strong goal for swift 3, the later is &quot;nice to have” if it fits since it is “just” sugar and there is a lot of other stuff going on.  We are also interested in introducing a proper BigInt type, but that is even “nicer to have” for Swift 3.<br></p><p>Random thoughts here:<br></p><p>Integer promotions are nice for arithmetic, but they can mask bugs for “reinterpret” style conversions.  You don’t want an Int32 to Double/UnsafePointer reinterpretation to implicitly promote to Int64; you want it to be a compiler error.  But that’s a special-case limitation that can reasonably be directly addressed on those APIs.<br></p><p>It&#39;s probably reasonably to have general rules that allow integer arithmetic to just promote to the wider type, but I don’t think we can do common-type promotion without special knowledge of type rank.<br></p><p>My understanding is that numerics people don’t love implicit promotions between floating-point types.  Float promotions and conversions are comparatively expensive, and they can introduce subtle rounding bugs; the standard advice is that programmers should be writing their code to avoid them.<br></p><p>Integer-to-float promotions have similar performance issues as float promotions, and IntN -&gt; FloatN is technically lossy.<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Simplified Conversion of Integer Types</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 19, 2016 at 09:00:00pm</p></header><div class="content"><p>On Jan 19, 2016, at 6:57 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt; The first two are a strong goal for swift 3, the later is &quot;nice to have” if it fits since it is “just” sugar and there is a lot of other stuff going on.  We are also interested in introducing a proper BigInt type, but that is even “nicer to have” for Swift 3.<br>&gt; <br>&gt; Random thoughts here:<br>&gt; <br>&gt; Integer promotions are nice for arithmetic, but they can mask bugs for “reinterpret” style conversions.  You don’t want an Int32 to Double/UnsafePointer reinterpretation to implicitly promote to Int64; you want it to be a compiler error. But that’s a special-case limitation that can reasonably be directly addressed on those APIs.<br>&gt; <br>&gt; It&#39;s probably reasonably to have general rules that allow integer arithmetic to just promote to the wider type, but I don’t think we can do common-type promotion without special knowledge of type rank.<br>&gt; <br>&gt; My understanding is that numerics people don’t love implicit promotions between floating-point types.  Float promotions and conversions are comparatively expensive, and they can introduce subtle rounding bugs; the standard advice is that programmers should be writing their code to avoid them.<br>&gt; <br>&gt; Integer-to-float promotions have similar performance issues as float promotions, and IntN -&gt; FloatN is technically lossy.<br></p><p>We should discuss this in more detail when and if it comes up and fits into Swift 3.<br></p><p>I’m imagining a real ranking scheme for integer types, involving value preserving promotions from smaller to larger types.  For floating point, it would be Float-&gt;Double-&gt;CGFloat, even though Double-&gt;CGFloat is lossy on 32-bit targets.  The key to making this work great in swift is to only introduce a promotion if the destination type is already in the system, and to “punish” the promotion by adding a cost to the solution (thus preferencing cheaper solutions).  <br></p><p>I’m aware of at least some of the reasons that numerics people dislike promotions (some of which don’t translate to Swift, like when people write “somefloat+4.0” when they should have written “somefloat+4.0f”), and I believe that this approach would solve them.<br></p><p>We will need specific design and iteration on this approach though (again, when there is time to do the implementation and evaluation) because at this point it is just a hand wavy idea.<br></p><p>-Chris<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
