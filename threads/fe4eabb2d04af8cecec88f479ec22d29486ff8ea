<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Reconsidering SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>January 26, 2016 at 04:00:00pm</p></header><div class="content"><p>on Tue Jan 26 2016, Tian Zhang &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I’m also curious how most people fix “guard var” or “if var”?<br>&gt; Especially for checking a class object for protocol conformation and<br>&gt; set variable on the object?<br>&gt;<br>&gt; like in this case,<br>&gt;<br>&gt;&gt; if var vc = vc as? ControlPanelConfigurationProtocol {<br>&gt;&gt;         vc.servicePresentationObject = service<br>&gt;&gt;         vc.presentAsPanel = true<br>&gt;&gt; }<br>&gt;<br>&gt; become<br>&gt;<br>&gt;&gt; if let vc = vc as? ControlPanelConfigurationProtocol {<br>&gt;&gt;         var vc = vc<br>&gt;&gt; <br>&gt;&gt;         vc.servicePresentationObject = service<br>&gt;&gt;         vc.presentAsPanel = true<br>&gt;&gt; }<br></p><p><br>If vc has class type, you don&#39;t need the var at all.<br></p><p>&gt; I saw a few people suggest to create a method on the protocol like<br>&gt; “configureObject(...)” with all potential args and have the object to<br>&gt; figure it out but doing so I feel we’re losing the benefits offered by<br>&gt; property observation for the underlying object. Using pattern “if let”<br>&gt; with a “var” in the block just to make the property mutable again<br>&gt; feels really strange.<br>&gt;<br>&gt; Best Wishes,<br>&gt; Tian<br>&gt;&gt; An alternative would certainly be interesting but I would prefer to<br>&gt;&gt; take it one step at a time and avoid being hasty so we can come up<br>&gt;&gt; with something really great. What did most of your var fixes look<br>&gt;&gt; like, by the way? Did you end up changing the layout of your value<br>&gt;&gt; types or did you decide to add more vars?<br>&gt;&gt; <br>&gt;&gt; David<br>&gt;&gt; <br>&gt;&gt; &gt; On Jan 24, 2016, at 7:19 PM, Zach Waldowski via swift-evolution<br>&gt;&gt; &gt; &lt;swift-evolution at swift.org<br>&gt;&gt; &gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; -1<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; Having already adopted the syntax in my projects in anticipation of 2.2,<br>&gt;&gt; &gt; the increase in clarity at the expense of terseness is appreciated. A<br>&gt;&gt; &gt; proposal should not be discussing an alternative, not a rollback.<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; Cheers!<br>&gt;&gt; &gt; Zachary Waldowski<br>&gt;&gt; &gt; zach at waldowski.me &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; On Fri, Jan 22, 2016, at 12:26 PM, David Farler via swift-evolution<br>&gt;&gt; &gt; wrote:<br>&gt;&gt; &gt;&gt; Hello everyone,<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; I&#39;d like to reconsider SE-0003 for Swift 3 and propose cancelling the<br>&gt;&gt; &gt;&gt; change in its entirety. After collecting feedback since Swift&#39;s open<br>&gt;&gt; &gt;&gt; source launch, I no longer feel this is a good move and there are a few<br>&gt;&gt; &gt;&gt; reasons why.<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; There are two main patterns that the removal penalizes:<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; - Get-Modify-Reassign<br>&gt;&gt; &gt;&gt; - Get-Modify-Return<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; I&#39;ve found that many of the problems with this proposal stem from the<br>&gt;&gt; &gt;&gt; uses before and after the &quot;Modify&quot; part, before returning or reassigning<br>&gt;&gt; &gt;&gt; with the new value.<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; I&#39;ve seen a few common responses to the var removal. Consider a<br>&gt;&gt; &gt;&gt; `Rectangle` struct:<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; struct Rectangle {<br>&gt;&gt; &gt;&gt; var origin: (x: Double, y: Double)<br>&gt;&gt; &gt;&gt; var size: (width: Double, height: Double)<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; Even with mutable variables `origin` and `size`, this pattern would be<br>&gt;&gt; &gt;&gt; impossible:<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; var selection = getRectangularSelection()<br>&gt;&gt; &gt;&gt; if var rect = selection?.rect {<br>&gt;&gt; &gt;&gt; // Mutate `rect` ...<br>&gt;&gt; &gt;&gt; selection.rect = rect<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; So, one might shadow the variable, which is not ideal:<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; var selection = getRectangularSelection()<br>&gt;&gt; &gt;&gt; if let rect = selection?.rect {<br>&gt;&gt; &gt;&gt; var rect = rect // Not so great<br>&gt;&gt; &gt;&gt; // Mutate `rect` ...<br>&gt;&gt; &gt;&gt; selection.rect = rect<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; Or, you might make a transformation function on `Rect`:<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; struct Rectangle {<br>&gt;&gt; &gt;&gt; var origin: (x: Double, y: Double)<br>&gt;&gt; &gt;&gt; var size: (width: Double, height: Double)<br>&gt;&gt; &gt;&gt; func withOrigin(x: Double, y: Double) -&gt; Rect {<br>&gt;&gt; &gt;&gt;   var r = self<br>&gt;&gt; &gt;&gt;   r.origin = (x, y)<br>&gt;&gt; &gt;&gt;   return r<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; This is a much better solution than shadowing but you would need one of<br>&gt;&gt; &gt;&gt; these for any property that you want to mutate and I think you&#39;ll agree<br>&gt;&gt; &gt;&gt; that it doesn&#39;t scale with the language we have today. This response begs<br>&gt;&gt; &gt;&gt; for a kind of initializer that takes all of the fields of the original<br>&gt;&gt; &gt;&gt; struct except any that you want to override:<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; if let rect = selection?.rect.with(origin: newOrigin) {<br>&gt;&gt; &gt;&gt; // ...<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; Straw syntax, but maybe you&#39;ll see something along these lines on<br>&gt;&gt; &gt;&gt; swift-evolution in the future, which would provide a clear alternative to<br>&gt;&gt; &gt;&gt; direct mutation patterns. Even then, I think having complementary<br>&gt;&gt; &gt;&gt; patterns in the language isn&#39;t a bad thing.<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; These problems come up with the other variable bindings but the one that<br>&gt;&gt; &gt;&gt; ended up bothering me the most was `guard var`:<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; func transform(selection: Rect?) {<br>&gt;&gt; &gt;&gt; guard let rect = selection else { return }<br>&gt;&gt; &gt;&gt; var _rect = rect<br>&gt;&gt; &gt;&gt; // Mutate `_rect` ...<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; One of the guard statement&#39;s main purposes is to conditionally bind a<br>&gt;&gt; &gt;&gt; value as a peer in its own scope, not an inner scope like if statements.<br>&gt;&gt; &gt;&gt; Not having var makes the guard statement much weaker.<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; There is certainly a bit of confusion about the nuances between value and<br>&gt;&gt; &gt;&gt; reference semantics, who owns a value and when, how effects are<br>&gt;&gt; &gt;&gt; propagated back to values, but I think we can attack the problem with<br>&gt;&gt; &gt;&gt; more finesse.<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; Value types are one of the attractive features of Swift – because of<br>&gt;&gt; &gt;&gt; their semantics, mutating algorithms are written in a familiar style but<br>&gt;&gt; &gt;&gt; keeping effects limited to your unique reference. I don&#39;t think we should<br>&gt;&gt; &gt;&gt; give that up now to address confusion about semantics, out of principle,<br>&gt;&gt; &gt;&gt; or in anticipation of new language features. I propose cancelling this<br>&gt;&gt; &gt;&gt; change for Swift 3 and continue to allow `var` in the grammar everywhere<br>&gt;&gt; &gt;&gt; it occurs in Swift 2.2.<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; Regards,<br>&gt;&gt; &gt;&gt; David<br>&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d9dbc0dfeb74eab8dd9bbd9cbd84680?s=50"></div><header><strong>Reconsidering SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>Jose Cheyo Jimenez</string> &lt;cheyo at masters3d.com&gt;<p>January 26, 2016 at 08:00:00pm</p></header><div class="content"><p>Would it be confusing if `guard var ` or  `if var ` was only allowed for<br>value types?<br></p><p><br>On Tuesday, January 26, 2016, Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; on Tue Jan 26 2016, Tian Zhang &lt;swift-evolution at swift.org &lt;javascript:;&gt;&gt;<br>&gt; wrote:<br>&gt;<br>&gt; &gt; I’m also curious how most people fix “guard var” or “if var”?<br>&gt; &gt; Especially for checking a class object for protocol conformation and<br>&gt; &gt; set variable on the object?<br>&gt; &gt;<br>&gt; &gt; like in this case,<br>&gt; &gt;<br>&gt; &gt;&gt; if var vc = vc as? ControlPanelConfigurationProtocol {<br>&gt; &gt;&gt;         vc.servicePresentationObject = service<br>&gt; &gt;&gt;         vc.presentAsPanel = true<br>&gt; &gt;&gt; }<br>&gt; &gt;<br>&gt; &gt; become<br>&gt; &gt;<br>&gt; &gt;&gt; if let vc = vc as? ControlPanelConfigurationProtocol {<br>&gt; &gt;&gt;         var vc = vc<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;         vc.servicePresentationObject = service<br>&gt; &gt;&gt;         vc.presentAsPanel = true<br>&gt; &gt;&gt; }<br>&gt;<br>&gt;<br>&gt; If vc has class type, you don&#39;t need the var at all.<br>&gt;<br>&gt; &gt; I saw a few people suggest to create a method on the protocol like<br>&gt; &gt; “configureObject(...)” with all potential args and have the object to<br>&gt; &gt; figure it out but doing so I feel we’re losing the benefits offered by<br>&gt; &gt; property observation for the underlying object. Using pattern “if let”<br>&gt; &gt; with a “var” in the block just to make the property mutable again<br>&gt; &gt; feels really strange.<br>&gt; &gt;<br>&gt; &gt; Best Wishes,<br>&gt; &gt; Tian<br>&gt; &gt;&gt; An alternative would certainly be interesting but I would prefer to<br>&gt; &gt;&gt; take it one step at a time and avoid being hasty so we can come up<br>&gt; &gt;&gt; with something really great. What did most of your var fixes look<br>&gt; &gt;&gt; like, by the way? Did you end up changing the layout of your value<br>&gt; &gt;&gt; types or did you decide to add more vars?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; David<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt; On Jan 24, 2016, at 7:19 PM, Zach Waldowski via swift-evolution<br>&gt; &gt;&gt; &gt; &lt;swift-evolution at swift.org<br>&gt; &gt;&gt; &gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; -1<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; Having already adopted the syntax in my projects in anticipation of<br>&gt; 2.2,<br>&gt; &gt;&gt; &gt; the increase in clarity at the expense of terseness is appreciated. A<br>&gt; &gt;&gt; &gt; proposal should not be discussing an alternative, not a rollback.<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; Cheers!<br>&gt; &gt;&gt; &gt; Zachary Waldowski<br>&gt; &gt;&gt; &gt; zach at waldowski.me &lt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; On Fri, Jan 22, 2016, at 12:26 PM, David Farler via swift-evolution<br>&gt; &gt;&gt; &gt; wrote:<br>&gt; &gt;&gt; &gt;&gt; Hello everyone,<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; I&#39;d like to reconsider SE-0003 for Swift 3 and propose cancelling the<br>&gt; &gt;&gt; &gt;&gt; change in its entirety. After collecting feedback since Swift&#39;s open<br>&gt; &gt;&gt; &gt;&gt; source launch, I no longer feel this is a good move and there are a<br>&gt; few<br>&gt; &gt;&gt; &gt;&gt; reasons why.<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; There are two main patterns that the removal penalizes:<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; - Get-Modify-Reassign<br>&gt; &gt;&gt; &gt;&gt; - Get-Modify-Return<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; I&#39;ve found that many of the problems with this proposal stem from the<br>&gt; &gt;&gt; &gt;&gt; uses before and after the &quot;Modify&quot; part, before returning or<br>&gt; reassigning<br>&gt; &gt;&gt; &gt;&gt; with the new value.<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; I&#39;ve seen a few common responses to the var removal. Consider a<br>&gt; &gt;&gt; &gt;&gt; `Rectangle` struct:<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; struct Rectangle {<br>&gt; &gt;&gt; &gt;&gt; var origin: (x: Double, y: Double)<br>&gt; &gt;&gt; &gt;&gt; var size: (width: Double, height: Double)<br>&gt; &gt;&gt; &gt;&gt; }<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; Even with mutable variables `origin` and `size`, this pattern would<br>&gt; be<br>&gt; &gt;&gt; &gt;&gt; impossible:<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; var selection = getRectangularSelection()<br>&gt; &gt;&gt; &gt;&gt; if var rect = selection?.rect {<br>&gt; &gt;&gt; &gt;&gt; // Mutate `rect` ...<br>&gt; &gt;&gt; &gt;&gt; selection.rect = rect<br>&gt; &gt;&gt; &gt;&gt; }<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; So, one might shadow the variable, which is not ideal:<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; var selection = getRectangularSelection()<br>&gt; &gt;&gt; &gt;&gt; if let rect = selection?.rect {<br>&gt; &gt;&gt; &gt;&gt; var rect = rect // Not so great<br>&gt; &gt;&gt; &gt;&gt; // Mutate `rect` ...<br>&gt; &gt;&gt; &gt;&gt; selection.rect = rect<br>&gt; &gt;&gt; &gt;&gt; }<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; Or, you might make a transformation function on `Rect`:<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; struct Rectangle {<br>&gt; &gt;&gt; &gt;&gt; var origin: (x: Double, y: Double)<br>&gt; &gt;&gt; &gt;&gt; var size: (width: Double, height: Double)<br>&gt; &gt;&gt; &gt;&gt; func withOrigin(x: Double, y: Double) -&gt; Rect {<br>&gt; &gt;&gt; &gt;&gt;   var r = self<br>&gt; &gt;&gt; &gt;&gt;   r.origin = (x, y)<br>&gt; &gt;&gt; &gt;&gt;   return r<br>&gt; &gt;&gt; &gt;&gt; }<br>&gt; &gt;&gt; &gt;&gt; }<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; This is a much better solution than shadowing but you would need one<br>&gt; of<br>&gt; &gt;&gt; &gt;&gt; these for any property that you want to mutate and I think you&#39;ll<br>&gt; agree<br>&gt; &gt;&gt; &gt;&gt; that it doesn&#39;t scale with the language we have today. This response<br>&gt; begs<br>&gt; &gt;&gt; &gt;&gt; for a kind of initializer that takes all of the fields of the<br>&gt; original<br>&gt; &gt;&gt; &gt;&gt; struct except any that you want to override:<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; if let rect = selection?.rect.with(origin: newOrigin) {<br>&gt; &gt;&gt; &gt;&gt; // ...<br>&gt; &gt;&gt; &gt;&gt; }<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; Straw syntax, but maybe you&#39;ll see something along these lines on<br>&gt; &gt;&gt; &gt;&gt; swift-evolution in the future, which would provide a clear<br>&gt; alternative to<br>&gt; &gt;&gt; &gt;&gt; direct mutation patterns. Even then, I think having complementary<br>&gt; &gt;&gt; &gt;&gt; patterns in the language isn&#39;t a bad thing.<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; These problems come up with the other variable bindings but the one<br>&gt; that<br>&gt; &gt;&gt; &gt;&gt; ended up bothering me the most was `guard var`:<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; func transform(selection: Rect?) {<br>&gt; &gt;&gt; &gt;&gt; guard let rect = selection else { return }<br>&gt; &gt;&gt; &gt;&gt; var _rect = rect<br>&gt; &gt;&gt; &gt;&gt; // Mutate `_rect` ...<br>&gt; &gt;&gt; &gt;&gt; }<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; One of the guard statement&#39;s main purposes is to conditionally bind a<br>&gt; &gt;&gt; &gt;&gt; value as a peer in its own scope, not an inner scope like if<br>&gt; statements.<br>&gt; &gt;&gt; &gt;&gt; Not having var makes the guard statement much weaker.<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; There is certainly a bit of confusion about the nuances between<br>&gt; value and<br>&gt; &gt;&gt; &gt;&gt; reference semantics, who owns a value and when, how effects are<br>&gt; &gt;&gt; &gt;&gt; propagated back to values, but I think we can attack the problem with<br>&gt; &gt;&gt; &gt;&gt; more finesse.<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; Value types are one of the attractive features of Swift – because of<br>&gt; &gt;&gt; &gt;&gt; their semantics, mutating algorithms are written in a familiar style<br>&gt; but<br>&gt; &gt;&gt; &gt;&gt; keeping effects limited to your unique reference. I don&#39;t think we<br>&gt; should<br>&gt; &gt;&gt; &gt;&gt; give that up now to address confusion about semantics, out of<br>&gt; principle,<br>&gt; &gt;&gt; &gt;&gt; or in anticipation of new language features. I propose cancelling<br>&gt; this<br>&gt; &gt;&gt; &gt;&gt; change for Swift 3 and continue to allow `var` in the grammar<br>&gt; everywhere<br>&gt; &gt;&gt; &gt;&gt; it occurs in Swift 2.2.<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; Regards,<br>&gt; &gt;&gt; &gt;&gt; David<br>&gt; &gt;&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt; &gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;&gt; &gt; _______________________________________________<br>&gt; &gt;&gt; &gt; swift-evolution mailing list<br>&gt; &gt;&gt; &gt; swift-evolution at swift.org &lt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt; &gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; --<br>&gt; -Dave<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160126/14a49c23/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4a300fb6ff17dc07df9be5e863e0c98a?s=50"></div><header><strong>Reconsidering SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>Nate Birkholz</string> &lt;nbirkholz at gmail.com&gt;<p>January 26, 2016 at 08:00:00pm</p></header><div class="content"><p>Seems in line with other compiler warnings.<br></p><p>Sent from my iPhone, please excuse brevity and errors<br></p><p>&gt; On Jan 26, 2016, at 8:30 PM, J. Cheyo Jimenez via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Would it be confusing if `guard var ` or  `if var ` was only allowed for value types? <br>&gt; <br>&gt; <br>&gt;&gt; On Tuesday, January 26, 2016, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; on Tue Jan 26 2016, Tian Zhang &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt; I’m also curious how most people fix “guard var” or “if var”?<br>&gt;&gt; &gt; Especially for checking a class object for protocol conformation and<br>&gt;&gt; &gt; set variable on the object?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; like in this case,<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; if var vc = vc as? ControlPanelConfigurationProtocol {<br>&gt;&gt; &gt;&gt;         vc.servicePresentationObject = service<br>&gt;&gt; &gt;&gt;         vc.presentAsPanel = true<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; become<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; if let vc = vc as? ControlPanelConfigurationProtocol {<br>&gt;&gt; &gt;&gt;         var vc = vc<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;         vc.servicePresentationObject = service<br>&gt;&gt; &gt;&gt;         vc.presentAsPanel = true<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; If vc has class type, you don&#39;t need the var at all.<br>&gt;&gt; <br>&gt;&gt; &gt; I saw a few people suggest to create a method on the protocol like<br>&gt;&gt; &gt; “configureObject(...)” with all potential args and have the object to<br>&gt;&gt; &gt; figure it out but doing so I feel we’re losing the benefits offered by<br>&gt;&gt; &gt; property observation for the underlying object. Using pattern “if let”<br>&gt;&gt; &gt; with a “var” in the block just to make the property mutable again<br>&gt;&gt; &gt; feels really strange.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Best Wishes,<br>&gt;&gt; &gt; Tian<br>&gt;&gt; &gt;&gt; An alternative would certainly be interesting but I would prefer to<br>&gt;&gt; &gt;&gt; take it one step at a time and avoid being hasty so we can come up<br>&gt;&gt; &gt;&gt; with something really great. What did most of your var fixes look<br>&gt;&gt; &gt;&gt; like, by the way? Did you end up changing the layout of your value<br>&gt;&gt; &gt;&gt; types or did you decide to add more vars?<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; David<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt; On Jan 24, 2016, at 7:19 PM, Zach Waldowski via swift-evolution<br>&gt;&gt; &gt;&gt; &gt; &lt;swift-evolution at swift.org<br>&gt;&gt; &gt;&gt; &gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; -1<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; Having already adopted the syntax in my projects in anticipation of 2.2,<br>&gt;&gt; &gt;&gt; &gt; the increase in clarity at the expense of terseness is appreciated. A<br>&gt;&gt; &gt;&gt; &gt; proposal should not be discussing an alternative, not a rollback.<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; Cheers!<br>&gt;&gt; &gt;&gt; &gt; Zachary Waldowski<br>&gt;&gt; &gt;&gt; &gt; zach at waldowski.me &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; On Fri, Jan 22, 2016, at 12:26 PM, David Farler via swift-evolution<br>&gt;&gt; &gt;&gt; &gt; wrote:<br>&gt;&gt; &gt;&gt; &gt;&gt; Hello everyone,<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; I&#39;d like to reconsider SE-0003 for Swift 3 and propose cancelling the<br>&gt;&gt; &gt;&gt; &gt;&gt; change in its entirety. After collecting feedback since Swift&#39;s open<br>&gt;&gt; &gt;&gt; &gt;&gt; source launch, I no longer feel this is a good move and there are a few<br>&gt;&gt; &gt;&gt; &gt;&gt; reasons why.<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; There are two main patterns that the removal penalizes:<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; - Get-Modify-Reassign<br>&gt;&gt; &gt;&gt; &gt;&gt; - Get-Modify-Return<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; I&#39;ve found that many of the problems with this proposal stem from the<br>&gt;&gt; &gt;&gt; &gt;&gt; uses before and after the &quot;Modify&quot; part, before returning or reassigning<br>&gt;&gt; &gt;&gt; &gt;&gt; with the new value.<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; I&#39;ve seen a few common responses to the var removal. Consider a<br>&gt;&gt; &gt;&gt; &gt;&gt; `Rectangle` struct:<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; struct Rectangle {<br>&gt;&gt; &gt;&gt; &gt;&gt; var origin: (x: Double, y: Double)<br>&gt;&gt; &gt;&gt; &gt;&gt; var size: (width: Double, height: Double)<br>&gt;&gt; &gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; Even with mutable variables `origin` and `size`, this pattern would be<br>&gt;&gt; &gt;&gt; &gt;&gt; impossible:<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; var selection = getRectangularSelection()<br>&gt;&gt; &gt;&gt; &gt;&gt; if var rect = selection?.rect {<br>&gt;&gt; &gt;&gt; &gt;&gt; // Mutate `rect` ...<br>&gt;&gt; &gt;&gt; &gt;&gt; selection.rect = rect<br>&gt;&gt; &gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; So, one might shadow the variable, which is not ideal:<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; var selection = getRectangularSelection()<br>&gt;&gt; &gt;&gt; &gt;&gt; if let rect = selection?.rect {<br>&gt;&gt; &gt;&gt; &gt;&gt; var rect = rect // Not so great<br>&gt;&gt; &gt;&gt; &gt;&gt; // Mutate `rect` ...<br>&gt;&gt; &gt;&gt; &gt;&gt; selection.rect = rect<br>&gt;&gt; &gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; Or, you might make a transformation function on `Rect`:<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; struct Rectangle {<br>&gt;&gt; &gt;&gt; &gt;&gt; var origin: (x: Double, y: Double)<br>&gt;&gt; &gt;&gt; &gt;&gt; var size: (width: Double, height: Double)<br>&gt;&gt; &gt;&gt; &gt;&gt; func withOrigin(x: Double, y: Double) -&gt; Rect {<br>&gt;&gt; &gt;&gt; &gt;&gt;   var r = self<br>&gt;&gt; &gt;&gt; &gt;&gt;   r.origin = (x, y)<br>&gt;&gt; &gt;&gt; &gt;&gt;   return r<br>&gt;&gt; &gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; This is a much better solution than shadowing but you would need one of<br>&gt;&gt; &gt;&gt; &gt;&gt; these for any property that you want to mutate and I think you&#39;ll agree<br>&gt;&gt; &gt;&gt; &gt;&gt; that it doesn&#39;t scale with the language we have today. This response begs<br>&gt;&gt; &gt;&gt; &gt;&gt; for a kind of initializer that takes all of the fields of the original<br>&gt;&gt; &gt;&gt; &gt;&gt; struct except any that you want to override:<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; if let rect = selection?.rect.with(origin: newOrigin) {<br>&gt;&gt; &gt;&gt; &gt;&gt; // ...<br>&gt;&gt; &gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; Straw syntax, but maybe you&#39;ll see something along these lines on<br>&gt;&gt; &gt;&gt; &gt;&gt; swift-evolution in the future, which would provide a clear alternative to<br>&gt;&gt; &gt;&gt; &gt;&gt; direct mutation patterns. Even then, I think having complementary<br>&gt;&gt; &gt;&gt; &gt;&gt; patterns in the language isn&#39;t a bad thing.<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; These problems come up with the other variable bindings but the one that<br>&gt;&gt; &gt;&gt; &gt;&gt; ended up bothering me the most was `guard var`:<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; func transform(selection: Rect?) {<br>&gt;&gt; &gt;&gt; &gt;&gt; guard let rect = selection else { return }<br>&gt;&gt; &gt;&gt; &gt;&gt; var _rect = rect<br>&gt;&gt; &gt;&gt; &gt;&gt; // Mutate `_rect` ...<br>&gt;&gt; &gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; One of the guard statement&#39;s main purposes is to conditionally bind a<br>&gt;&gt; &gt;&gt; &gt;&gt; value as a peer in its own scope, not an inner scope like if statements.<br>&gt;&gt; &gt;&gt; &gt;&gt; Not having var makes the guard statement much weaker.<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; There is certainly a bit of confusion about the nuances between value and<br>&gt;&gt; &gt;&gt; &gt;&gt; reference semantics, who owns a value and when, how effects are<br>&gt;&gt; &gt;&gt; &gt;&gt; propagated back to values, but I think we can attack the problem with<br>&gt;&gt; &gt;&gt; &gt;&gt; more finesse.<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; Value types are one of the attractive features of Swift – because of<br>&gt;&gt; &gt;&gt; &gt;&gt; their semantics, mutating algorithms are written in a familiar style but<br>&gt;&gt; &gt;&gt; &gt;&gt; keeping effects limited to your unique reference. I don&#39;t think we should<br>&gt;&gt; &gt;&gt; &gt;&gt; give that up now to address confusion about semantics, out of principle,<br>&gt;&gt; &gt;&gt; &gt;&gt; or in anticipation of new language features. I propose cancelling this<br>&gt;&gt; &gt;&gt; &gt;&gt; change for Swift 3 and continue to allow `var` in the grammar everywhere<br>&gt;&gt; &gt;&gt; &gt;&gt; it occurs in Swift 2.2.<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; Regards,<br>&gt;&gt; &gt;&gt; &gt;&gt; David<br>&gt;&gt; &gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt; &gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt; &gt; swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt; &gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160126/79ebb580/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Reconsidering SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>January 27, 2016 at 08:00:00pm</p></header><div class="content"><p>That doesn&#39;t make sense to me. If it&#39;s sometimes necessary to reassign a struct containing a single reference, then surely it may be necessary to reassign a single reference not contained in a struct.<br></p><p>Jordan<br></p><p>&gt; On Jan 26, 2016, at 20:37 , Nate Birkholz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Seems in line with other compiler warnings.<br>&gt; <br>&gt; Sent from my iPhone, please excuse brevity and errors<br>&gt; <br>&gt; On Jan 26, 2016, at 8:30 PM, J. Cheyo Jimenez via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Would it be confusing if `guard var ` or  `if var ` was only allowed for value types? <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Tuesday, January 26, 2016, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; on Tue Jan 26 2016, Tian Zhang &lt;swift-evolution at swift.org &lt;javascript:;&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt; I’m also curious how most people fix “guard var” or “if var”?<br>&gt;&gt; &gt; Especially for checking a class object for protocol conformation and<br>&gt;&gt; &gt; set variable on the object?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; like in this case,<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; if var vc = vc as? ControlPanelConfigurationProtocol {<br>&gt;&gt; &gt;&gt;         vc.servicePresentationObject = service<br>&gt;&gt; &gt;&gt;         vc.presentAsPanel = true<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; become<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; if let vc = vc as? ControlPanelConfigurationProtocol {<br>&gt;&gt; &gt;&gt;         var vc = vc<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;         vc.servicePresentationObject = service<br>&gt;&gt; &gt;&gt;         vc.presentAsPanel = true<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; If vc has class type, you don&#39;t need the var at all.<br>&gt;&gt; <br>&gt;&gt; &gt; I saw a few people suggest to create a method on the protocol like<br>&gt;&gt; &gt; “configureObject(...)” with all potential args and have the object to<br>&gt;&gt; &gt; figure it out but doing so I feel we’re losing the benefits offered by<br>&gt;&gt; &gt; property observation for the underlying object. Using pattern “if let”<br>&gt;&gt; &gt; with a “var” in the block just to make the property mutable again<br>&gt;&gt; &gt; feels really strange.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Best Wishes,<br>&gt;&gt; &gt; Tian<br>&gt;&gt; &gt;&gt; An alternative would certainly be interesting but I would prefer to<br>&gt;&gt; &gt;&gt; take it one step at a time and avoid being hasty so we can come up<br>&gt;&gt; &gt;&gt; with something really great. What did most of your var fixes look<br>&gt;&gt; &gt;&gt; like, by the way? Did you end up changing the layout of your value<br>&gt;&gt; &gt;&gt; types or did you decide to add more vars?<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; David<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt; On Jan 24, 2016, at 7:19 PM, Zach Waldowski via swift-evolution<br>&gt;&gt; &gt;&gt; &gt; &lt;swift-evolution at swift.org &lt;http://swift.org/&gt;<br>&gt;&gt; &gt;&gt; &gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; -1<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; Having already adopted the syntax in my projects in anticipation of 2.2,<br>&gt;&gt; &gt;&gt; &gt; the increase in clarity at the expense of terseness is appreciated. A<br>&gt;&gt; &gt;&gt; &gt; proposal should not be discussing an alternative, not a rollback.<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; Cheers!<br>&gt;&gt; &gt;&gt; &gt; Zachary Waldowski<br>&gt;&gt; &gt;&gt; &gt; zach at waldowski.me &lt;http://waldowski.me/&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; On Fri, Jan 22, 2016, at 12:26 PM, David Farler via swift-evolution<br>&gt;&gt; &gt;&gt; &gt; wrote:<br>&gt;&gt; &gt;&gt; &gt;&gt; Hello everyone,<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; I&#39;d like to reconsider SE-0003 for Swift 3 and propose cancelling the<br>&gt;&gt; &gt;&gt; &gt;&gt; change in its entirety. After collecting feedback since Swift&#39;s open<br>&gt;&gt; &gt;&gt; &gt;&gt; source launch, I no longer feel this is a good move and there are a few<br>&gt;&gt; &gt;&gt; &gt;&gt; reasons why.<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; There are two main patterns that the removal penalizes:<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; - Get-Modify-Reassign<br>&gt;&gt; &gt;&gt; &gt;&gt; - Get-Modify-Return<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; I&#39;ve found that many of the problems with this proposal stem from the<br>&gt;&gt; &gt;&gt; &gt;&gt; uses before and after the &quot;Modify&quot; part, before returning or reassigning<br>&gt;&gt; &gt;&gt; &gt;&gt; with the new value.<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; I&#39;ve seen a few common responses to the var removal. Consider a<br>&gt;&gt; &gt;&gt; &gt;&gt; `Rectangle` struct:<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; struct Rectangle {<br>&gt;&gt; &gt;&gt; &gt;&gt; var origin: (x: Double, y: Double)<br>&gt;&gt; &gt;&gt; &gt;&gt; var size: (width: Double, height: Double)<br>&gt;&gt; &gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; Even with mutable variables `origin` and `size`, this pattern would be<br>&gt;&gt; &gt;&gt; &gt;&gt; impossible:<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; var selection = getRectangularSelection()<br>&gt;&gt; &gt;&gt; &gt;&gt; if var rect = selection?.rect {<br>&gt;&gt; &gt;&gt; &gt;&gt; // Mutate `rect` ...<br>&gt;&gt; &gt;&gt; &gt;&gt; selection.rect = rect<br>&gt;&gt; &gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; So, one might shadow the variable, which is not ideal:<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; var selection = getRectangularSelection()<br>&gt;&gt; &gt;&gt; &gt;&gt; if let rect = selection?.rect {<br>&gt;&gt; &gt;&gt; &gt;&gt; var rect = rect // Not so great<br>&gt;&gt; &gt;&gt; &gt;&gt; // Mutate `rect` ...<br>&gt;&gt; &gt;&gt; &gt;&gt; selection.rect = rect<br>&gt;&gt; &gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; Or, you might make a transformation function on `Rect`:<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; struct Rectangle {<br>&gt;&gt; &gt;&gt; &gt;&gt; var origin: (x: Double, y: Double)<br>&gt;&gt; &gt;&gt; &gt;&gt; var size: (width: Double, height: Double)<br>&gt;&gt; &gt;&gt; &gt;&gt; func withOrigin(x: Double, y: Double) -&gt; Rect {<br>&gt;&gt; &gt;&gt; &gt;&gt;   var r = self<br>&gt;&gt; &gt;&gt; &gt;&gt;   r.origin = (x, y)<br>&gt;&gt; &gt;&gt; &gt;&gt;   return r<br>&gt;&gt; &gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; This is a much better solution than shadowing but you would need one of<br>&gt;&gt; &gt;&gt; &gt;&gt; these for any property that you want to mutate and I think you&#39;ll agree<br>&gt;&gt; &gt;&gt; &gt;&gt; that it doesn&#39;t scale with the language we have today. This response begs<br>&gt;&gt; &gt;&gt; &gt;&gt; for a kind of initializer that takes all of the fields of the original<br>&gt;&gt; &gt;&gt; &gt;&gt; struct except any that you want to override:<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; if let rect = selection?.rect.with(origin: newOrigin) {<br>&gt;&gt; &gt;&gt; &gt;&gt; // ...<br>&gt;&gt; &gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; Straw syntax, but maybe you&#39;ll see something along these lines on<br>&gt;&gt; &gt;&gt; &gt;&gt; swift-evolution in the future, which would provide a clear alternative to<br>&gt;&gt; &gt;&gt; &gt;&gt; direct mutation patterns. Even then, I think having complementary<br>&gt;&gt; &gt;&gt; &gt;&gt; patterns in the language isn&#39;t a bad thing.<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; These problems come up with the other variable bindings but the one that<br>&gt;&gt; &gt;&gt; &gt;&gt; ended up bothering me the most was `guard var`:<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; func transform(selection: Rect?) {<br>&gt;&gt; &gt;&gt; &gt;&gt; guard let rect = selection else { return }<br>&gt;&gt; &gt;&gt; &gt;&gt; var _rect = rect<br>&gt;&gt; &gt;&gt; &gt;&gt; // Mutate `_rect` ...<br>&gt;&gt; &gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; One of the guard statement&#39;s main purposes is to conditionally bind a<br>&gt;&gt; &gt;&gt; &gt;&gt; value as a peer in its own scope, not an inner scope like if statements.<br>&gt;&gt; &gt;&gt; &gt;&gt; Not having var makes the guard statement much weaker.<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; There is certainly a bit of confusion about the nuances between value and<br>&gt;&gt; &gt;&gt; &gt;&gt; reference semantics, who owns a value and when, how effects are<br>&gt;&gt; &gt;&gt; &gt;&gt; propagated back to values, but I think we can attack the problem with<br>&gt;&gt; &gt;&gt; &gt;&gt; more finesse.<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; Value types are one of the attractive features of Swift – because of<br>&gt;&gt; &gt;&gt; &gt;&gt; their semantics, mutating algorithms are written in a familiar style but<br>&gt;&gt; &gt;&gt; &gt;&gt; keeping effects limited to your unique reference. I don&#39;t think we should<br>&gt;&gt; &gt;&gt; &gt;&gt; give that up now to address confusion about semantics, out of principle,<br>&gt;&gt; &gt;&gt; &gt;&gt; or in anticipation of new language features. I propose cancelling this<br>&gt;&gt; &gt;&gt; &gt;&gt; change for Swift 3 and continue to allow `var` in the grammar everywhere<br>&gt;&gt; &gt;&gt; &gt;&gt; it occurs in Swift 2.2.<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; Regards,<br>&gt;&gt; &gt;&gt; &gt;&gt; David<br>&gt;&gt; &gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;http://swift.org/&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt; &gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt; &gt; swift-evolution at swift.org &lt;http://swift.org/&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt; &gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt;&gt; &gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/7513ad3f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d9dbc0dfeb74eab8dd9bbd9cbd84680?s=50"></div><header><strong>Reconsidering SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>Jose Cheyo Jimenez</string> &lt;cheyo at masters3d.com&gt;<p>January 27, 2016 at 08:00:00pm</p></header><div class="content"><p>Reassigning of class objects probably occurs less than<br>mutations of structs inside `if var` or `guard var`.<br>The main reason for the removal of `if var` or `guard var`, AFAIK, is that<br>people get confuse about references.  Perhaps just limiting their use for<br>value types could then clear up the confusion.<br>example of warning.<br>&quot;&#39;if var&#39; is restricted to value types, did you mean &#39;if let&#39;?&quot;<br></p><p>One of the issues is that now all comma separated optionals need to be<br>value types or offer alternative syntax.<br></p><p>if var value1 = value1, ref1 = ref1 {} /// This would not work<br></p><p>if var value1 = value1, let ref1 = ref1 {} /// Possible solution, notice<br>the `let`<br></p><p><br></p><p><br></p><p><br></p><p><br></p><p>On Wed, Jan 27, 2016 at 8:05 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br></p><p>&gt; That doesn&#39;t make sense to me. If it&#39;s sometimes necessary to reassign a<br>&gt; struct containing a single reference, then surely it may be necessary to<br>&gt; reassign a single reference not contained in a struct.<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt; On Jan 26, 2016, at 20:37 , Nate Birkholz via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Seems in line with other compiler warnings.<br>&gt;<br>&gt; Sent from my iPhone, please excuse brevity and errors<br>&gt;<br>&gt; On Jan 26, 2016, at 8:30 PM, J. Cheyo Jimenez via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Would it be confusing if `guard var ` or  `if var ` was only allowed for<br>&gt; value types?<br>&gt;<br>&gt;<br>&gt; On Tuesday, January 26, 2016, Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; on Tue Jan 26 2016, Tian Zhang &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; &gt; I’m also curious how most people fix “guard var” or “if var”?<br>&gt;&gt; &gt; Especially for checking a class object for protocol conformation and<br>&gt;&gt; &gt; set variable on the object?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; like in this case,<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; if var vc = vc as? ControlPanelConfigurationProtocol {<br>&gt;&gt; &gt;&gt;         vc.servicePresentationObject = service<br>&gt;&gt; &gt;&gt;         vc.presentAsPanel = true<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; become<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; if let vc = vc as? ControlPanelConfigurationProtocol {<br>&gt;&gt; &gt;&gt;         var vc = vc<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;         vc.servicePresentationObject = service<br>&gt;&gt; &gt;&gt;         vc.presentAsPanel = true<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; If vc has class type, you don&#39;t need the var at all.<br>&gt;&gt;<br>&gt;&gt; &gt; I saw a few people suggest to create a method on the protocol like<br>&gt;&gt; &gt; “configureObject(...)” with all potential args and have the object to<br>&gt;&gt; &gt; figure it out but doing so I feel we’re losing the benefits offered by<br>&gt;&gt; &gt; property observation for the underlying object. Using pattern “if let”<br>&gt;&gt; &gt; with a “var” in the block just to make the property mutable again<br>&gt;&gt; &gt; feels really strange.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Best Wishes,<br>&gt;&gt; &gt; Tian<br>&gt;&gt; &gt;&gt; An alternative would certainly be interesting but I would prefer to<br>&gt;&gt; &gt;&gt; take it one step at a time and avoid being hasty so we can come up<br>&gt;&gt; &gt;&gt; with something really great. What did most of your var fixes look<br>&gt;&gt; &gt;&gt; like, by the way? Did you end up changing the layout of your value<br>&gt;&gt; &gt;&gt; types or did you decide to add more vars?<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; David<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt; On Jan 24, 2016, at 7:19 PM, Zach Waldowski via swift-evolution<br>&gt;&gt; &gt;&gt; &gt; &lt;swift-evolution at swift.org<br>&gt;&gt; &gt;&gt; &gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; -1<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; Having already adopted the syntax in my projects in anticipation of<br>&gt;&gt; 2.2,<br>&gt;&gt; &gt;&gt; &gt; the increase in clarity at the expense of terseness is appreciated. A<br>&gt;&gt; &gt;&gt; &gt; proposal should not be discussing an alternative, not a rollback.<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; Cheers!<br>&gt;&gt; &gt;&gt; &gt; Zachary Waldowski<br>&gt;&gt; &gt;&gt; &gt; zach at waldowski.me &lt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; On Fri, Jan 22, 2016, at 12:26 PM, David Farler via swift-evolution<br>&gt;&gt; &gt;&gt; &gt; wrote:<br>&gt;&gt; &gt;&gt; &gt;&gt; Hello everyone,<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; I&#39;d like to reconsider SE-0003 for Swift 3 and propose cancelling<br>&gt;&gt; the<br>&gt;&gt; &gt;&gt; &gt;&gt; change in its entirety. After collecting feedback since Swift&#39;s open<br>&gt;&gt; &gt;&gt; &gt;&gt; source launch, I no longer feel this is a good move and there are a<br>&gt;&gt; few<br>&gt;&gt; &gt;&gt; &gt;&gt; reasons why.<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; There are two main patterns that the removal penalizes:<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; - Get-Modify-Reassign<br>&gt;&gt; &gt;&gt; &gt;&gt; - Get-Modify-Return<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; I&#39;ve found that many of the problems with this proposal stem from<br>&gt;&gt; the<br>&gt;&gt; &gt;&gt; &gt;&gt; uses before and after the &quot;Modify&quot; part, before returning or<br>&gt;&gt; reassigning<br>&gt;&gt; &gt;&gt; &gt;&gt; with the new value.<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; I&#39;ve seen a few common responses to the var removal. Consider a<br>&gt;&gt; &gt;&gt; &gt;&gt; `Rectangle` struct:<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; struct Rectangle {<br>&gt;&gt; &gt;&gt; &gt;&gt; var origin: (x: Double, y: Double)<br>&gt;&gt; &gt;&gt; &gt;&gt; var size: (width: Double, height: Double)<br>&gt;&gt; &gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; Even with mutable variables `origin` and `size`, this pattern would<br>&gt;&gt; be<br>&gt;&gt; &gt;&gt; &gt;&gt; impossible:<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; var selection = getRectangularSelection()<br>&gt;&gt; &gt;&gt; &gt;&gt; if var rect = selection?.rect {<br>&gt;&gt; &gt;&gt; &gt;&gt; // Mutate `rect` ...<br>&gt;&gt; &gt;&gt; &gt;&gt; selection.rect = rect<br>&gt;&gt; &gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; So, one might shadow the variable, which is not ideal:<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; var selection = getRectangularSelection()<br>&gt;&gt; &gt;&gt; &gt;&gt; if let rect = selection?.rect {<br>&gt;&gt; &gt;&gt; &gt;&gt; var rect = rect // Not so great<br>&gt;&gt; &gt;&gt; &gt;&gt; // Mutate `rect` ...<br>&gt;&gt; &gt;&gt; &gt;&gt; selection.rect = rect<br>&gt;&gt; &gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; Or, you might make a transformation function on `Rect`:<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; struct Rectangle {<br>&gt;&gt; &gt;&gt; &gt;&gt; var origin: (x: Double, y: Double)<br>&gt;&gt; &gt;&gt; &gt;&gt; var size: (width: Double, height: Double)<br>&gt;&gt; &gt;&gt; &gt;&gt; func withOrigin(x: Double, y: Double) -&gt; Rect {<br>&gt;&gt; &gt;&gt; &gt;&gt;   var r = self<br>&gt;&gt; &gt;&gt; &gt;&gt;   r.origin = (x, y)<br>&gt;&gt; &gt;&gt; &gt;&gt;   return r<br>&gt;&gt; &gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; This is a much better solution than shadowing but you would need<br>&gt;&gt; one of<br>&gt;&gt; &gt;&gt; &gt;&gt; these for any property that you want to mutate and I think you&#39;ll<br>&gt;&gt; agree<br>&gt;&gt; &gt;&gt; &gt;&gt; that it doesn&#39;t scale with the language we have today. This<br>&gt;&gt; response begs<br>&gt;&gt; &gt;&gt; &gt;&gt; for a kind of initializer that takes all of the fields of the<br>&gt;&gt; original<br>&gt;&gt; &gt;&gt; &gt;&gt; struct except any that you want to override:<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; if let rect = selection?.rect.with(origin: newOrigin) {<br>&gt;&gt; &gt;&gt; &gt;&gt; // ...<br>&gt;&gt; &gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; Straw syntax, but maybe you&#39;ll see something along these lines on<br>&gt;&gt; &gt;&gt; &gt;&gt; swift-evolution in the future, which would provide a clear<br>&gt;&gt; alternative to<br>&gt;&gt; &gt;&gt; &gt;&gt; direct mutation patterns. Even then, I think having complementary<br>&gt;&gt; &gt;&gt; &gt;&gt; patterns in the language isn&#39;t a bad thing.<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; These problems come up with the other variable bindings but the one<br>&gt;&gt; that<br>&gt;&gt; &gt;&gt; &gt;&gt; ended up bothering me the most was `guard var`:<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; func transform(selection: Rect?) {<br>&gt;&gt; &gt;&gt; &gt;&gt; guard let rect = selection else { return }<br>&gt;&gt; &gt;&gt; &gt;&gt; var _rect = rect<br>&gt;&gt; &gt;&gt; &gt;&gt; // Mutate `_rect` ...<br>&gt;&gt; &gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; One of the guard statement&#39;s main purposes is to conditionally bind<br>&gt;&gt; a<br>&gt;&gt; &gt;&gt; &gt;&gt; value as a peer in its own scope, not an inner scope like if<br>&gt;&gt; statements.<br>&gt;&gt; &gt;&gt; &gt;&gt; Not having var makes the guard statement much weaker.<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; There is certainly a bit of confusion about the nuances between<br>&gt;&gt; value and<br>&gt;&gt; &gt;&gt; &gt;&gt; reference semantics, who owns a value and when, how effects are<br>&gt;&gt; &gt;&gt; &gt;&gt; propagated back to values, but I think we can attack the problem<br>&gt;&gt; with<br>&gt;&gt; &gt;&gt; &gt;&gt; more finesse.<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; Value types are one of the attractive features of Swift – because of<br>&gt;&gt; &gt;&gt; &gt;&gt; their semantics, mutating algorithms are written in a familiar<br>&gt;&gt; style but<br>&gt;&gt; &gt;&gt; &gt;&gt; keeping effects limited to your unique reference. I don&#39;t think we<br>&gt;&gt; should<br>&gt;&gt; &gt;&gt; &gt;&gt; give that up now to address confusion about semantics, out of<br>&gt;&gt; principle,<br>&gt;&gt; &gt;&gt; &gt;&gt; or in anticipation of new language features. I propose cancelling<br>&gt;&gt; this<br>&gt;&gt; &gt;&gt; &gt;&gt; change for Swift 3 and continue to allow `var` in the grammar<br>&gt;&gt; everywhere<br>&gt;&gt; &gt;&gt; &gt;&gt; it occurs in Swift 2.2.<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; Regards,<br>&gt;&gt; &gt;&gt; &gt;&gt; David<br>&gt;&gt; &gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt; &gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt; &gt; swift-evolution at swift.org &lt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt; &gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; -Dave<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/c4d65a49/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Reconsidering SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January 28, 2016 at 03:00:00pm</p></header><div class="content"><p>I am fine with eliminating var in constructs like if etc. I hardly use it<br>and if I need it it is easy to assign to a var. Likely to eliminate sill<br>cut and past errors also, in addition to genuine misunderstand of what is<br>happening.<br></p><p>On Thursday, 28 January 2016, J. Cheyo Jimenez via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Reassigning of class objects probably occurs less than<br>&gt; mutations of structs inside `if var` or `guard var`.<br>&gt; The main reason for the removal of `if var` or `guard var`, AFAIK, is<br>&gt; that people get confuse about references.  Perhaps just limiting their use<br>&gt; for value types could then clear up the confusion.<br>&gt; example of warning.<br>&gt; &quot;&#39;if var&#39; is restricted to value types, did you mean &#39;if let&#39;?&quot;<br>&gt;<br>&gt; One of the issues is that now all comma separated optionals need to be<br>&gt; value types or offer alternative syntax.<br>&gt;<br>&gt; if var value1 = value1, ref1 = ref1 {} /// This would not work<br>&gt;<br>&gt; if var value1 = value1, let ref1 = ref1 {} /// Possible solution, notice<br>&gt; the `let`<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Wed, Jan 27, 2016 at 8:05 PM, Jordan Rose &lt;jordan_rose at apple.com<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;jordan_rose at apple.com&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt;&gt; That doesn&#39;t make sense to me. If it&#39;s sometimes necessary to reassign a<br>&gt;&gt; struct containing a single reference, then surely it may be necessary to<br>&gt;&gt; reassign a single reference not contained in a struct.<br>&gt;&gt;<br>&gt;&gt; Jordan<br>&gt;&gt;<br>&gt;&gt; On Jan 26, 2016, at 20:37 , Nate Birkholz via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Seems in line with other compiler warnings.<br>&gt;&gt;<br>&gt;&gt; Sent from my iPhone, please excuse brevity and errors<br>&gt;&gt;<br>&gt;&gt; On Jan 26, 2016, at 8:30 PM, J. Cheyo Jimenez via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Would it be confusing if `guard var ` or  `if var ` was only allowed for<br>&gt;&gt; value types?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Tuesday, January 26, 2016, Dave Abrahams via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; on Tue Jan 26 2016, Tian Zhang &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; I’m also curious how most people fix “guard var” or “if var”?<br>&gt;&gt;&gt; &gt; Especially for checking a class object for protocol conformation and<br>&gt;&gt;&gt; &gt; set variable on the object?<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; like in this case,<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; if var vc = vc as? ControlPanelConfigurationProtocol {<br>&gt;&gt;&gt; &gt;&gt;         vc.servicePresentationObject = service<br>&gt;&gt;&gt; &gt;&gt;         vc.presentAsPanel = true<br>&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; become<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; if let vc = vc as? ControlPanelConfigurationProtocol {<br>&gt;&gt;&gt; &gt;&gt;         var vc = vc<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;         vc.servicePresentationObject = service<br>&gt;&gt;&gt; &gt;&gt;         vc.presentAsPanel = true<br>&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If vc has class type, you don&#39;t need the var at all.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; I saw a few people suggest to create a method on the protocol like<br>&gt;&gt;&gt; &gt; “configureObject(...)” with all potential args and have the object to<br>&gt;&gt;&gt; &gt; figure it out but doing so I feel we’re losing the benefits offered by<br>&gt;&gt;&gt; &gt; property observation for the underlying object. Using pattern “if let”<br>&gt;&gt;&gt; &gt; with a “var” in the block just to make the property mutable again<br>&gt;&gt;&gt; &gt; feels really strange.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Best Wishes,<br>&gt;&gt;&gt; &gt; Tian<br>&gt;&gt;&gt; &gt;&gt; An alternative would certainly be interesting but I would prefer to<br>&gt;&gt;&gt; &gt;&gt; take it one step at a time and avoid being hasty so we can come up<br>&gt;&gt;&gt; &gt;&gt; with something really great. What did most of your var fixes look<br>&gt;&gt;&gt; &gt;&gt; like, by the way? Did you end up changing the layout of your value<br>&gt;&gt;&gt; &gt;&gt; types or did you decide to add more vars?<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; David<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt; On Jan 24, 2016, at 7:19 PM, Zach Waldowski via swift-evolution<br>&gt;&gt;&gt; &gt;&gt; &gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt; &gt;&gt; &gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; &gt; -1<br>&gt;&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; &gt; Having already adopted the syntax in my projects in anticipation of<br>&gt;&gt;&gt; 2.2,<br>&gt;&gt;&gt; &gt;&gt; &gt; the increase in clarity at the expense of terseness is appreciated.<br>&gt;&gt;&gt; A<br>&gt;&gt;&gt; &gt;&gt; &gt; proposal should not be discussing an alternative, not a rollback.<br>&gt;&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; &gt; Cheers!<br>&gt;&gt;&gt; &gt;&gt; &gt; Zachary Waldowski<br>&gt;&gt;&gt; &gt;&gt; &gt; zach at waldowski.me &lt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; &gt; On Fri, Jan 22, 2016, at 12:26 PM, David Farler via swift-evolution<br>&gt;&gt;&gt; &gt;&gt; &gt; wrote:<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; Hello everyone,<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; I&#39;d like to reconsider SE-0003 for Swift 3 and propose cancelling<br>&gt;&gt;&gt; the<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; change in its entirety. After collecting feedback since Swift&#39;s<br>&gt;&gt;&gt; open<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; source launch, I no longer feel this is a good move and there are<br>&gt;&gt;&gt; a few<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; reasons why.<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; There are two main patterns that the removal penalizes:<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; - Get-Modify-Reassign<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; - Get-Modify-Return<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; I&#39;ve found that many of the problems with this proposal stem from<br>&gt;&gt;&gt; the<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; uses before and after the &quot;Modify&quot; part, before returning or<br>&gt;&gt;&gt; reassigning<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; with the new value.<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; I&#39;ve seen a few common responses to the var removal. Consider a<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; `Rectangle` struct:<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; struct Rectangle {<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; var origin: (x: Double, y: Double)<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; var size: (width: Double, height: Double)<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; Even with mutable variables `origin` and `size`, this pattern<br>&gt;&gt;&gt; would be<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; impossible:<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; var selection = getRectangularSelection()<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; if var rect = selection?.rect {<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; // Mutate `rect` ...<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; selection.rect = rect<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; So, one might shadow the variable, which is not ideal:<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; var selection = getRectangularSelection()<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; if let rect = selection?.rect {<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; var rect = rect // Not so great<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; // Mutate `rect` ...<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; selection.rect = rect<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; Or, you might make a transformation function on `Rect`:<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; struct Rectangle {<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; var origin: (x: Double, y: Double)<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; var size: (width: Double, height: Double)<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; func withOrigin(x: Double, y: Double) -&gt; Rect {<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;   var r = self<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;   r.origin = (x, y)<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;   return r<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; This is a much better solution than shadowing but you would need<br>&gt;&gt;&gt; one of<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; these for any property that you want to mutate and I think you&#39;ll<br>&gt;&gt;&gt; agree<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; that it doesn&#39;t scale with the language we have today. This<br>&gt;&gt;&gt; response begs<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; for a kind of initializer that takes all of the fields of the<br>&gt;&gt;&gt; original<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; struct except any that you want to override:<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; if let rect = selection?.rect.with(origin: newOrigin) {<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; // ...<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; Straw syntax, but maybe you&#39;ll see something along these lines on<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; swift-evolution in the future, which would provide a clear<br>&gt;&gt;&gt; alternative to<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; direct mutation patterns. Even then, I think having complementary<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; patterns in the language isn&#39;t a bad thing.<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; These problems come up with the other variable bindings but the<br>&gt;&gt;&gt; one that<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; ended up bothering me the most was `guard var`:<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; func transform(selection: Rect?) {<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; guard let rect = selection else { return }<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; var _rect = rect<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; // Mutate `_rect` ...<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; One of the guard statement&#39;s main purposes is to conditionally<br>&gt;&gt;&gt; bind a<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; value as a peer in its own scope, not an inner scope like if<br>&gt;&gt;&gt; statements.<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; Not having var makes the guard statement much weaker.<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; There is certainly a bit of confusion about the nuances between<br>&gt;&gt;&gt; value and<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; reference semantics, who owns a value and when, how effects are<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; propagated back to values, but I think we can attack the problem<br>&gt;&gt;&gt; with<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; more finesse.<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; Value types are one of the attractive features of Swift – because<br>&gt;&gt;&gt; of<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; their semantics, mutating algorithms are written in a familiar<br>&gt;&gt;&gt; style but<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; keeping effects limited to your unique reference. I don&#39;t think we<br>&gt;&gt;&gt; should<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; give that up now to address confusion about semantics, out of<br>&gt;&gt;&gt; principle,<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; or in anticipation of new language features. I propose cancelling<br>&gt;&gt;&gt; this<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; change for Swift 3 and continue to allow `var` in the grammar<br>&gt;&gt;&gt; everywhere<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; it occurs in Swift 2.2.<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; Regards,<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; David<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt;&gt; &gt; swift-evolution at swift.org &lt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; &gt;&gt; &gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br></p><p>-- <br>  -- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/a8b680f6/attachment-0001.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Reconsidering SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>January 28, 2016 at 10:00:00am</p></header><div class="content"><p>I still don&#39;t understand how value types and reference types are different here. Here&#39;s a contrived &quot;confusion&quot; example (but we have seen similar real-world code):<br></p><p>for var element in array {<br>  if element.isNotUpToMyStandards {<br>    element = makeANewElement()<br>    // &#39;element&#39; is not stored back into &#39;array&#39;, but was meant to be.<br>  }<br>}<br></p><p>This code, or rather the behavior the developer intended, is perfectly reasonable. But it&#39;s exactly the same code whether there&#39;s a value type or a reference type involved. I get that there are other examples where this is not the case, but I can&#39;t see how those would be any less confusing by adding this rule.<br></p><p>But maybe I&#39;m just too familiar with Swift, and so have trouble putting myself in the shoes of a new learner.<br></p><p>Jordan<br></p><p><br>&gt; On Jan 27, 2016, at 20:45 , J. Cheyo Jimenez &lt;cheyo at masters3d.com&gt; wrote:<br>&gt; <br>&gt; Reassigning of class objects probably occurs less than mutations of structs inside `if var` or `guard var`.<br>&gt; The main reason for the removal of `if var` or `guard var`, AFAIK, is that people get confuse about references.  Perhaps just limiting their use for value types could then clear up the confusion. <br>&gt; example of warning. <br>&gt; &quot;&#39;if var&#39; is restricted to value types, did you mean &#39;if let&#39;?&quot;<br>&gt; <br>&gt; One of the issues is that now all comma separated optionals need to be value types or offer alternative syntax. <br>&gt; <br>&gt; if var value1 = value1, ref1 = ref1 {} /// This would not work<br>&gt; <br>&gt; if var value1 = value1, let ref1 = ref1 {} /// Possible solution, notice the `let`<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; On Wed, Jan 27, 2016 at 8:05 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt; That doesn&#39;t make sense to me. If it&#39;s sometimes necessary to reassign a struct containing a single reference, then surely it may be necessary to reassign a single reference not contained in a struct.<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt;&gt; On Jan 26, 2016, at 20:37 , Nate Birkholz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Seems in line with other compiler warnings.<br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone, please excuse brevity and errors<br>&gt;&gt; <br>&gt;&gt; On Jan 26, 2016, at 8:30 PM, J. Cheyo Jimenez via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Would it be confusing if `guard var ` or  `if var ` was only allowed for value types? <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Tuesday, January 26, 2016, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Tue Jan 26 2016, Tian Zhang &lt;swift-evolution at swift.org &lt;&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; I’m also curious how most people fix “guard var” or “if var”?<br>&gt;&gt;&gt; &gt; Especially for checking a class object for protocol conformation and<br>&gt;&gt;&gt; &gt; set variable on the object?<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; like in this case,<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; if var vc = vc as? ControlPanelConfigurationProtocol {<br>&gt;&gt;&gt; &gt;&gt;         vc.servicePresentationObject = service<br>&gt;&gt;&gt; &gt;&gt;         vc.presentAsPanel = true<br>&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; become<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; if let vc = vc as? ControlPanelConfigurationProtocol {<br>&gt;&gt;&gt; &gt;&gt;         var vc = vc<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;         vc.servicePresentationObject = service<br>&gt;&gt;&gt; &gt;&gt;         vc.presentAsPanel = true<br>&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If vc has class type, you don&#39;t need the var at all.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; I saw a few people suggest to create a method on the protocol like<br>&gt;&gt;&gt; &gt; “configureObject(...)” with all potential args and have the object to<br>&gt;&gt;&gt; &gt; figure it out but doing so I feel we’re losing the benefits offered by<br>&gt;&gt;&gt; &gt; property observation for the underlying object. Using pattern “if let”<br>&gt;&gt;&gt; &gt; with a “var” in the block just to make the property mutable again<br>&gt;&gt;&gt; &gt; feels really strange.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Best Wishes,<br>&gt;&gt;&gt; &gt; Tian<br>&gt;&gt;&gt; &gt;&gt; An alternative would certainly be interesting but I would prefer to<br>&gt;&gt;&gt; &gt;&gt; take it one step at a time and avoid being hasty so we can come up<br>&gt;&gt;&gt; &gt;&gt; with something really great. What did most of your var fixes look<br>&gt;&gt;&gt; &gt;&gt; like, by the way? Did you end up changing the layout of your value<br>&gt;&gt;&gt; &gt;&gt; types or did you decide to add more vars?<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; David<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt; On Jan 24, 2016, at 7:19 PM, Zach Waldowski via swift-evolution<br>&gt;&gt;&gt; &gt;&gt; &gt; &lt;swift-evolution at swift.org &lt;http://swift.org/&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; &gt; -1<br>&gt;&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; &gt; Having already adopted the syntax in my projects in anticipation of 2.2,<br>&gt;&gt;&gt; &gt;&gt; &gt; the increase in clarity at the expense of terseness is appreciated. A<br>&gt;&gt;&gt; &gt;&gt; &gt; proposal should not be discussing an alternative, not a rollback.<br>&gt;&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; &gt; Cheers!<br>&gt;&gt;&gt; &gt;&gt; &gt; Zachary Waldowski<br>&gt;&gt;&gt; &gt;&gt; &gt; zach at waldowski.me &lt;http://waldowski.me/&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; &gt; On Fri, Jan 22, 2016, at 12:26 PM, David Farler via swift-evolution<br>&gt;&gt;&gt; &gt;&gt; &gt; wrote:<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; Hello everyone,<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; I&#39;d like to reconsider SE-0003 for Swift 3 and propose cancelling the<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; change in its entirety. After collecting feedback since Swift&#39;s open<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; source launch, I no longer feel this is a good move and there are a few<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; reasons why.<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; There are two main patterns that the removal penalizes:<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; - Get-Modify-Reassign<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; - Get-Modify-Return<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; I&#39;ve found that many of the problems with this proposal stem from the<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; uses before and after the &quot;Modify&quot; part, before returning or reassigning<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; with the new value.<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; I&#39;ve seen a few common responses to the var removal. Consider a<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; `Rectangle` struct:<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; struct Rectangle {<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; var origin: (x: Double, y: Double)<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; var size: (width: Double, height: Double)<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; Even with mutable variables `origin` and `size`, this pattern would be<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; impossible:<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; var selection = getRectangularSelection()<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; if var rect = selection?.rect {<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; // Mutate `rect` ...<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; selection.rect = rect<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; So, one might shadow the variable, which is not ideal:<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; var selection = getRectangularSelection()<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; if let rect = selection?.rect {<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; var rect = rect // Not so great<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; // Mutate `rect` ...<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; selection.rect = rect<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; Or, you might make a transformation function on `Rect`:<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; struct Rectangle {<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; var origin: (x: Double, y: Double)<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; var size: (width: Double, height: Double)<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; func withOrigin(x: Double, y: Double) -&gt; Rect {<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;   var r = self<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;   r.origin = (x, y)<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;   return r<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; This is a much better solution than shadowing but you would need one of<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; these for any property that you want to mutate and I think you&#39;ll agree<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; that it doesn&#39;t scale with the language we have today. This response begs<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; for a kind of initializer that takes all of the fields of the original<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; struct except any that you want to override:<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; if let rect = selection?.rect.with(origin: newOrigin) {<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; // ...<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; Straw syntax, but maybe you&#39;ll see something along these lines on<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; swift-evolution in the future, which would provide a clear alternative to<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; direct mutation patterns. Even then, I think having complementary<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; patterns in the language isn&#39;t a bad thing.<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; These problems come up with the other variable bindings but the one that<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; ended up bothering me the most was `guard var`:<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; func transform(selection: Rect?) {<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; guard let rect = selection else { return }<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; var _rect = rect<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; // Mutate `_rect` ...<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; One of the guard statement&#39;s main purposes is to conditionally bind a<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; value as a peer in its own scope, not an inner scope like if statements.<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; Not having var makes the guard statement much weaker.<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; There is certainly a bit of confusion about the nuances between value and<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; reference semantics, who owns a value and when, how effects are<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; propagated back to values, but I think we can attack the problem with<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; more finesse.<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; Value types are one of the attractive features of Swift – because of<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; their semantics, mutating algorithms are written in a familiar style but<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; keeping effects limited to your unique reference. I don&#39;t think we should<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; give that up now to address confusion about semantics, out of principle,<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; or in anticipation of new language features. I propose cancelling this<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; change for Swift 3 and continue to allow `var` in the grammar everywhere<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; it occurs in Swift 2.2.<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; Regards,<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; David<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;http://swift.org/&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt;&gt; &gt; swift-evolution at swift.org &lt;http://swift.org/&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;&gt;<br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/61615c23/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4a300fb6ff17dc07df9be5e863e0c98a?s=50"></div><header><strong>Reconsidering SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>Nate Birkholz</string> &lt;nbirkholz at gmail.com&gt;<p>January 28, 2016 at 10:00:00am</p></header><div class="content"><p>Interestingly for me, my first &quot;real&quot; language was Swift (unless you count<br>fortran in the 80s) so the behaviors of Swift are &quot;normal&quot; to me, but I<br>still made the mistake of thinking var == object mutability  when coming<br>back to Swift last month after a year of Objective-C. I get the confusion.<br>But I also think the removal of the expressiveness of &quot;if var foo {}&quot; is a<br>shame and would like to see an alternate plan.<br></p><p>I can live without var parameters because it&#39;s just a bit of a trick,<br>really, however convenient.<br></p><p><br></p><p>On Thu, Jan 28, 2016 at 10:05 AM, Jordan Rose via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I *still* don&#39;t understand how value types and reference types are<br>&gt; different here. Here&#39;s a contrived &quot;confusion&quot; example (but we have seen<br>&gt; similar real-world code):<br>&gt;<br>&gt; for var element in array {<br>&gt;   if element.isNotUpToMyStandards {<br>&gt;     element = makeANewElement()<br>&gt;     // &#39;element&#39; is not stored back into &#39;array&#39;, but was meant to be.<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; This code, or rather the behavior the developer intended, is perfectly<br>&gt; reasonable. But it&#39;s exactly the same code whether there&#39;s a value type or<br>&gt; a reference type involved. I get that there are other examples where this<br>&gt; is *not* the case, but I can&#39;t see how *those* would be any *less* confusing<br>&gt; by adding this rule.<br>&gt;<br>&gt; But maybe I&#39;m just too familiar with Swift, and so have trouble putting<br>&gt; myself in the shoes of a new learner.<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt;<br>&gt; On Jan 27, 2016, at 20:45 , J. Cheyo Jimenez &lt;cheyo at masters3d.com&gt; wrote:<br>&gt;<br>&gt; Reassigning of class objects probably occurs less than<br>&gt; mutations of structs inside `if var` or `guard var`.<br>&gt; The main reason for the removal of `if var` or `guard var`, AFAIK, is<br>&gt; that people get confuse about references.  Perhaps just limiting their use<br>&gt; for value types could then clear up the confusion.<br>&gt; example of warning.<br>&gt; &quot;&#39;if var&#39; is restricted to value types, did you mean &#39;if let&#39;?&quot;<br>&gt;<br>&gt; One of the issues is that now all comma separated optionals need to be<br>&gt; value types or offer alternative syntax.<br>&gt;<br>&gt; if var value1 = value1, ref1 = ref1 {} /// This would not work<br>&gt;<br>&gt; if var value1 = value1, let ref1 = ref1 {} /// Possible solution, notice<br>&gt; the `let`<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Wed, Jan 27, 2016 at 8:05 PM, Jordan Rose &lt;jordan_rose at apple.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; That doesn&#39;t make sense to me. If it&#39;s sometimes necessary to reassign a<br>&gt;&gt; struct containing a single reference, then surely it may be necessary to<br>&gt;&gt; reassign a single reference not contained in a struct.<br>&gt;&gt;<br>&gt;&gt; Jordan<br>&gt;&gt;<br>&gt;&gt; On Jan 26, 2016, at 20:37 , Nate Birkholz via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Seems in line with other compiler warnings.<br>&gt;&gt;<br>&gt;&gt; Sent from my iPhone, please excuse brevity and errors<br>&gt;&gt;<br>&gt;&gt; On Jan 26, 2016, at 8:30 PM, J. Cheyo Jimenez via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Would it be confusing if `guard var ` or  `if var ` was only allowed for<br>&gt;&gt; value types?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Tuesday, January 26, 2016, Dave Abrahams via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; on Tue Jan 26 2016, Tian Zhang &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; I’m also curious how most people fix “guard var” or “if var”?<br>&gt;&gt;&gt; &gt; Especially for checking a class object for protocol conformation and<br>&gt;&gt;&gt; &gt; set variable on the object?<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; like in this case,<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; if var vc = vc as? ControlPanelConfigurationProtocol {<br>&gt;&gt;&gt; &gt;&gt;         vc.servicePresentationObject = service<br>&gt;&gt;&gt; &gt;&gt;         vc.presentAsPanel = true<br>&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; become<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; if let vc = vc as? ControlPanelConfigurationProtocol {<br>&gt;&gt;&gt; &gt;&gt;         var vc = vc<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;         vc.servicePresentationObject = service<br>&gt;&gt;&gt; &gt;&gt;         vc.presentAsPanel = true<br>&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If vc has class type, you don&#39;t need the var at all.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; I saw a few people suggest to create a method on the protocol like<br>&gt;&gt;&gt; &gt; “configureObject(...)” with all potential args and have the object to<br>&gt;&gt;&gt; &gt; figure it out but doing so I feel we’re losing the benefits offered by<br>&gt;&gt;&gt; &gt; property observation for the underlying object. Using pattern “if let”<br>&gt;&gt;&gt; &gt; with a “var” in the block just to make the property mutable again<br>&gt;&gt;&gt; &gt; feels really strange.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Best Wishes,<br>&gt;&gt;&gt; &gt; Tian<br>&gt;&gt;&gt; &gt;&gt; An alternative would certainly be interesting but I would prefer to<br>&gt;&gt;&gt; &gt;&gt; take it one step at a time and avoid being hasty so we can come up<br>&gt;&gt;&gt; &gt;&gt; with something really great. What did most of your var fixes look<br>&gt;&gt;&gt; &gt;&gt; like, by the way? Did you end up changing the layout of your value<br>&gt;&gt;&gt; &gt;&gt; types or did you decide to add more vars?<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; David<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt; On Jan 24, 2016, at 7:19 PM, Zach Waldowski via swift-evolution<br>&gt;&gt;&gt; &gt;&gt; &gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt; &gt;&gt; &gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; &gt; -1<br>&gt;&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; &gt; Having already adopted the syntax in my projects in anticipation of<br>&gt;&gt;&gt; 2.2,<br>&gt;&gt;&gt; &gt;&gt; &gt; the increase in clarity at the expense of terseness is appreciated.<br>&gt;&gt;&gt; A<br>&gt;&gt;&gt; &gt;&gt; &gt; proposal should not be discussing an alternative, not a rollback.<br>&gt;&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; &gt; Cheers!<br>&gt;&gt;&gt; &gt;&gt; &gt; Zachary Waldowski<br>&gt;&gt;&gt; &gt;&gt; &gt; zach at waldowski.me &lt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; &gt; On Fri, Jan 22, 2016, at 12:26 PM, David Farler via swift-evolution<br>&gt;&gt;&gt; &gt;&gt; &gt; wrote:<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; Hello everyone,<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; I&#39;d like to reconsider SE-0003 for Swift 3 and propose cancelling<br>&gt;&gt;&gt; the<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; change in its entirety. After collecting feedback since Swift&#39;s<br>&gt;&gt;&gt; open<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; source launch, I no longer feel this is a good move and there are<br>&gt;&gt;&gt; a few<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; reasons why.<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; There are two main patterns that the removal penalizes:<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; - Get-Modify-Reassign<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; - Get-Modify-Return<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; I&#39;ve found that many of the problems with this proposal stem from<br>&gt;&gt;&gt; the<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; uses before and after the &quot;Modify&quot; part, before returning or<br>&gt;&gt;&gt; reassigning<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; with the new value.<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; I&#39;ve seen a few common responses to the var removal. Consider a<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; `Rectangle` struct:<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; struct Rectangle {<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; var origin: (x: Double, y: Double)<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; var size: (width: Double, height: Double)<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; Even with mutable variables `origin` and `size`, this pattern<br>&gt;&gt;&gt; would be<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; impossible:<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; var selection = getRectangularSelection()<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; if var rect = selection?.rect {<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; // Mutate `rect` ...<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; selection.rect = rect<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; So, one might shadow the variable, which is not ideal:<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; var selection = getRectangularSelection()<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; if let rect = selection?.rect {<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; var rect = rect // Not so great<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; // Mutate `rect` ...<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; selection.rect = rect<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; Or, you might make a transformation function on `Rect`:<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; struct Rectangle {<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; var origin: (x: Double, y: Double)<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; var size: (width: Double, height: Double)<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; func withOrigin(x: Double, y: Double) -&gt; Rect {<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;   var r = self<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;   r.origin = (x, y)<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;   return r<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; This is a much better solution than shadowing but you would need<br>&gt;&gt;&gt; one of<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; these for any property that you want to mutate and I think you&#39;ll<br>&gt;&gt;&gt; agree<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; that it doesn&#39;t scale with the language we have today. This<br>&gt;&gt;&gt; response begs<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; for a kind of initializer that takes all of the fields of the<br>&gt;&gt;&gt; original<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; struct except any that you want to override:<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; if let rect = selection?.rect.with(origin: newOrigin) {<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; // ...<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; Straw syntax, but maybe you&#39;ll see something along these lines on<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; swift-evolution in the future, which would provide a clear<br>&gt;&gt;&gt; alternative to<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; direct mutation patterns. Even then, I think having complementary<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; patterns in the language isn&#39;t a bad thing.<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; These problems come up with the other variable bindings but the<br>&gt;&gt;&gt; one that<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; ended up bothering me the most was `guard var`:<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; func transform(selection: Rect?) {<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; guard let rect = selection else { return }<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; var _rect = rect<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; // Mutate `_rect` ...<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; One of the guard statement&#39;s main purposes is to conditionally<br>&gt;&gt;&gt; bind a<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; value as a peer in its own scope, not an inner scope like if<br>&gt;&gt;&gt; statements.<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; Not having var makes the guard statement much weaker.<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; There is certainly a bit of confusion about the nuances between<br>&gt;&gt;&gt; value and<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; reference semantics, who owns a value and when, how effects are<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; propagated back to values, but I think we can attack the problem<br>&gt;&gt;&gt; with<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; more finesse.<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; Value types are one of the attractive features of Swift – because<br>&gt;&gt;&gt; of<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; their semantics, mutating algorithms are written in a familiar<br>&gt;&gt;&gt; style but<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; keeping effects limited to your unique reference. I don&#39;t think we<br>&gt;&gt;&gt; should<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; give that up now to address confusion about semantics, out of<br>&gt;&gt;&gt; principle,<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; or in anticipation of new language features. I propose cancelling<br>&gt;&gt;&gt; this<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; change for Swift 3 and continue to allow `var` in the grammar<br>&gt;&gt;&gt; everywhere<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; it occurs in Swift 2.2.<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; Regards,<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; David<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt;&gt; &gt; swift-evolution at swift.org &lt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; &gt;&gt; &gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p><p><br>-- <br>Nate Birkholz<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/aafa4d77/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d9dbc0dfeb74eab8dd9bbd9cbd84680?s=50"></div><header><strong>Reconsidering SE-0003 Removing var from Function Parameters and Pattern Matching</strong> from <string>Jose Cheyo Jimenez</string> &lt;cheyo at masters3d.com&gt;<p>January 28, 2016 at 04:00:00pm</p></header><div class="content"><p>The curse of knowledge. :)<br></p><p>I don&#39;t mind &#39;for var&#39; to be gone or var in functions.<br>The suggestion of &#39;if bind&#39; seems interesting but then I think it may<br>become a little too magical. A combination of the two ideas would<br>be something like:<br></p><p>let x:Int? = 1<br></p><p>if bind x {<br>    var x = x<br>    x += 2<br>    methodWithSideEffets(x)<br>}<br></p><p>same as :<br></p><p>if let x = x {<br>    var x = x<br>       x += 2<br>    methodWithSideEffets(x)<br>}<br></p><p>vs<br></p><p>if var x = x {<br>   x += 2<br>    methodWithSideEffets(x)<br>}<br></p><p><br>On Thursday, January 28, 2016, Jordan Rose &lt;jordan_rose at apple.com<br>&lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;jordan_rose at apple.com&#39;);&gt;&gt; wrote:<br></p><p>&gt; I *still* don&#39;t understand how value types and reference types are<br>&gt; different here. Here&#39;s a contrived &quot;confusion&quot; example (but we have seen<br>&gt; similar real-world code):<br>&gt;<br>&gt; for var element in array {<br>&gt;   if element.isNotUpToMyStandards {<br>&gt;     element = makeANewElement()<br>&gt;     // &#39;element&#39; is not stored back into &#39;array&#39;, but was meant to be.<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; This code, or rather the behavior the developer intended, is perfectly<br>&gt; reasonable. But it&#39;s exactly the same code whether there&#39;s a value type or<br>&gt; a reference type involved. I get that there are other examples where this<br>&gt; is *not* the case, but I can&#39;t see how *those* would be any *less* confusing<br>&gt; by adding this rule.<br>&gt;<br>&gt; But maybe I&#39;m just too familiar with Swift, and so have trouble putting<br>&gt; myself in the shoes of a new learner.<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt;<br>&gt; On Jan 27, 2016, at 20:45 , J. Cheyo Jimenez &lt;cheyo at masters3d.com&gt; wrote:<br>&gt;<br>&gt; Reassigning of class objects probably occurs less than<br>&gt; mutations of structs inside `if var` or `guard var`.<br>&gt; The main reason for the removal of `if var` or `guard var`, AFAIK, is<br>&gt; that people get confuse about references.  Perhaps just limiting their use<br>&gt; for value types could then clear up the confusion.<br>&gt; example of warning.<br>&gt; &quot;&#39;if var&#39; is restricted to value types, did you mean &#39;if let&#39;?&quot;<br>&gt;<br>&gt; One of the issues is that now all comma separated optionals need to be<br>&gt; value types or offer alternative syntax.<br>&gt;<br>&gt; if var value1 = value1, ref1 = ref1 {} /// This would not work<br>&gt;<br>&gt; if var value1 = value1, let ref1 = ref1 {} /// Possible solution, notice<br>&gt; the `let`<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Wed, Jan 27, 2016 at 8:05 PM, Jordan Rose &lt;jordan_rose at apple.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; That doesn&#39;t make sense to me. If it&#39;s sometimes necessary to reassign a<br>&gt;&gt; struct containing a single reference, then surely it may be necessary to<br>&gt;&gt; reassign a single reference not contained in a struct.<br>&gt;&gt;<br>&gt;&gt; Jordan<br>&gt;&gt;<br>&gt;&gt; On Jan 26, 2016, at 20:37 , Nate Birkholz via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Seems in line with other compiler warnings.<br>&gt;&gt;<br>&gt;&gt; Sent from my iPhone, please excuse brevity and errors<br>&gt;&gt;<br>&gt;&gt; On Jan 26, 2016, at 8:30 PM, J. Cheyo Jimenez via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Would it be confusing if `guard var ` or  `if var ` was only allowed for<br>&gt;&gt; value types?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Tuesday, January 26, 2016, Dave Abrahams via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; on Tue Jan 26 2016, Tian Zhang &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; I’m also curious how most people fix “guard var” or “if var”?<br>&gt;&gt;&gt; &gt; Especially for checking a class object for protocol conformation and<br>&gt;&gt;&gt; &gt; set variable on the object?<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; like in this case,<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; if var vc = vc as? ControlPanelConfigurationProtocol {<br>&gt;&gt;&gt; &gt;&gt;         vc.servicePresentationObject = service<br>&gt;&gt;&gt; &gt;&gt;         vc.presentAsPanel = true<br>&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; become<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; if let vc = vc as? ControlPanelConfigurationProtocol {<br>&gt;&gt;&gt; &gt;&gt;         var vc = vc<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;         vc.servicePresentationObject = service<br>&gt;&gt;&gt; &gt;&gt;         vc.presentAsPanel = true<br>&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If vc has class type, you don&#39;t need the var at all.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; I saw a few people suggest to create a method on the protocol like<br>&gt;&gt;&gt; &gt; “configureObject(...)” with all potential args and have the object to<br>&gt;&gt;&gt; &gt; figure it out but doing so I feel we’re losing the benefits offered by<br>&gt;&gt;&gt; &gt; property observation for the underlying object. Using pattern “if let”<br>&gt;&gt;&gt; &gt; with a “var” in the block just to make the property mutable again<br>&gt;&gt;&gt; &gt; feels really strange.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Best Wishes,<br>&gt;&gt;&gt; &gt; Tian<br>&gt;&gt;&gt; &gt;&gt; An alternative would certainly be interesting but I would prefer to<br>&gt;&gt;&gt; &gt;&gt; take it one step at a time and avoid being hasty so we can come up<br>&gt;&gt;&gt; &gt;&gt; with something really great. What did most of your var fixes look<br>&gt;&gt;&gt; &gt;&gt; like, by the way? Did you end up changing the layout of your value<br>&gt;&gt;&gt; &gt;&gt; types or did you decide to add more vars?<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; David<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt; On Jan 24, 2016, at 7:19 PM, Zach Waldowski via swift-evolution<br>&gt;&gt;&gt; &gt;&gt; &gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt; &gt;&gt; &gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; &gt; -1<br>&gt;&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; &gt; Having already adopted the syntax in my projects in anticipation of<br>&gt;&gt;&gt; 2.2,<br>&gt;&gt;&gt; &gt;&gt; &gt; the increase in clarity at the expense of terseness is appreciated.<br>&gt;&gt;&gt; A<br>&gt;&gt;&gt; &gt;&gt; &gt; proposal should not be discussing an alternative, not a rollback.<br>&gt;&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; &gt; Cheers!<br>&gt;&gt;&gt; &gt;&gt; &gt; Zachary Waldowski<br>&gt;&gt;&gt; &gt;&gt; &gt; zach at waldowski.me &lt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; &gt; On Fri, Jan 22, 2016, at 12:26 PM, David Farler via swift-evolution<br>&gt;&gt;&gt; &gt;&gt; &gt; wrote:<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; Hello everyone,<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; I&#39;d like to reconsider SE-0003 for Swift 3 and propose cancelling<br>&gt;&gt;&gt; the<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; change in its entirety. After collecting feedback since Swift&#39;s<br>&gt;&gt;&gt; open<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; source launch, I no longer feel this is a good move and there are<br>&gt;&gt;&gt; a few<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; reasons why.<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; There are two main patterns that the removal penalizes:<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; - Get-Modify-Reassign<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; - Get-Modify-Return<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; I&#39;ve found that many of the problems with this proposal stem from<br>&gt;&gt;&gt; the<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; uses before and after the &quot;Modify&quot; part, before returning or<br>&gt;&gt;&gt; reassigning<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; with the new value.<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; I&#39;ve seen a few common responses to the var removal. Consider a<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; `Rectangle` struct:<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; struct Rectangle {<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; var origin: (x: Double, y: Double)<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; var size: (width: Double, height: Double)<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; Even with mutable variables `origin` and `size`, this pattern<br>&gt;&gt;&gt; would be<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; impossible:<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; var selection = getRectangularSelection()<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; if var rect = selection?.rect {<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; // Mutate `rect` ...<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; selection.rect = rect<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; So, one might shadow the variable, which is not ideal:<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; var selection = getRectangularSelection()<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; if let rect = selection?.rect {<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; var rect = rect // Not so great<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; // Mutate `rect` ...<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; selection.rect = rect<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; Or, you might make a transformation function on `Rect`:<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; struct Rectangle {<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; var origin: (x: Double, y: Double)<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; var size: (width: Double, height: Double)<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; func withOrigin(x: Double, y: Double) -&gt; Rect {<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;   var r = self<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;   r.origin = (x, y)<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;   return r<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; This is a much better solution than shadowing but you would need<br>&gt;&gt;&gt; one of<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; these for any property that you want to mutate and I think you&#39;ll<br>&gt;&gt;&gt; agree<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; that it doesn&#39;t scale with the language we have today. This<br>&gt;&gt;&gt; response begs<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; for a kind of initializer that takes all of the fields of the<br>&gt;&gt;&gt; original<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; struct except any that you want to override:<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; if let rect = selection?.rect.with(origin: newOrigin) {<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; // ...<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; Straw syntax, but maybe you&#39;ll see something along these lines on<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; swift-evolution in the future, which would provide a clear<br>&gt;&gt;&gt; alternative to<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; direct mutation patterns. Even then, I think having complementary<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; patterns in the language isn&#39;t a bad thing.<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; These problems come up with the other variable bindings but the<br>&gt;&gt;&gt; one that<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; ended up bothering me the most was `guard var`:<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; func transform(selection: Rect?) {<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; guard let rect = selection else { return }<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; var _rect = rect<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; // Mutate `_rect` ...<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; One of the guard statement&#39;s main purposes is to conditionally<br>&gt;&gt;&gt; bind a<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; value as a peer in its own scope, not an inner scope like if<br>&gt;&gt;&gt; statements.<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; Not having var makes the guard statement much weaker.<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; There is certainly a bit of confusion about the nuances between<br>&gt;&gt;&gt; value and<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; reference semantics, who owns a value and when, how effects are<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; propagated back to values, but I think we can attack the problem<br>&gt;&gt;&gt; with<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; more finesse.<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; Value types are one of the attractive features of Swift – because<br>&gt;&gt;&gt; of<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; their semantics, mutating algorithms are written in a familiar<br>&gt;&gt;&gt; style but<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; keeping effects limited to your unique reference. I don&#39;t think we<br>&gt;&gt;&gt; should<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; give that up now to address confusion about semantics, out of<br>&gt;&gt;&gt; principle,<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; or in anticipation of new language features. I propose cancelling<br>&gt;&gt;&gt; this<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; change for Swift 3 and continue to allow `var` in the grammar<br>&gt;&gt;&gt; everywhere<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; it occurs in Swift 2.2.<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; Regards,<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; David<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt;&gt; &gt; swift-evolution at swift.org &lt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; &gt;&gt; &gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/7528645b/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
