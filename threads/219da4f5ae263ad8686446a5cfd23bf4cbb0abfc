<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Idea] How to eliminate &#39;optional&#39; protocol requirements</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>April  7, 2016 at 05:00:00pm</p></header><div class="content"><p>Hi all,<br></p><p>Optional protocol requirements in Swift have the restriction that they only work in @objc protocols, a topic that’s come up a number &lt;http://thread.gmane.org/gmane.comp.lang.swift.devel/1316/focus=8804&gt; of times &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/13347/focus=13480&gt;. The start of these threads imply that optional requirements should be available for all protocols in Swift. While this direction is implementable, each time this is discussed there is significant feedback that optional requirements are not a feature we want in Swift. They overlap almost completely with default implementations of protocol requirements, which is a more general feature, and people seem to feel that designs based around default implementations and refactoring of protocol hierarchies are overall better.<br></p><p>The main concern with removing optional requirements from Swift is their impact on Cocoa: Objective-C protocols, especially for delegates and data sources, make heavy use of optional requirements. Moreover, there are no default implementations for any of these optional requirements: each caller effectively checks for the presence of the method explicitly, and implements its own logic if the method isn’t there.<br></p><p>A Non-Workable Solution: Import as optional property requirements<br>One suggestion that’s come up to map an optional requirement to a property with optional type, were “nil” indicates that the requirement was not satisfied. For example, <br></p><p>@protocol NSTableViewDelegate<br>@optional<br>- (nullable NSView *)tableView:(NSTableView *)tableView viewForTableColumn:(NSTableColumn *)tableColumn row:(NSInteger)row;<br>- (CGFloat)tableView:(NSTableView *)tableView heightOfRow:(NSInteger)row;<br>@end<br></p><p>currently comes in as<br></p><p>@objc protocol NSTableViewDelegate {<br>  optional func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView?<br>  optional func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat<br>}<br></p><p>would come in as:<br></p><p>@objc protocol NSTableViewDelegate {<br>  var tableView: ((NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView?)? { get }<br>  var tableView: ((NSTableView, heightOfRow: Int) -&gt; CGFloat)? { get }<br>}<br></p><p>with a default implementation of “nil” for each. However, this isn’t practical for a number of reasons:<br></p><p>a) We would end up overloading the property name “tableView” a couple dozen times, which doesn’t actually work.<br></p><p>b) You can no longer refer to the member with a compound name, e.g., “delegate.tableView(_:viewFor:row:)” no longer works, because the name of the property is “tableView”.<br></p><p>c) Implementers of the protocol now need to provide a read-only property that returns a closure. So instead of<br></p><p>class MyDelegate : NSTableViewDelegate {<br>  func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView? { … }<br>}<br></p><p>one would have to write something like<br></p><p>class MyDelegate : NSTableViewDelegate {<br>  var tableView: ((NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView?)? = {<br>    … except you can’t refer to self in here unless you make it lazy ...<br>  }<br>}<br></p><p>d) We’ve seriously considered eliminating argument labels on function types, because they’re a complexity in the type system that doesn’t serve much of a purpose.<br></p><p>One could perhaps work around (a), (b), and (d) by allowing compound (function-like) names like tableView(_:viewFor:row:) for properties, and work around (c) by allowing a method to satisfy the requirement for a read-only property, but at this point you’ve invented more language hacks than the existing @objc-only optional requirements. So, I don’t think there is a solution here.<br></p><p>Proposed Solution: Caller-side default implementations<br></p><p>Default implementations and optional requirements differ most on the caller side. For example, let’s use NSTableView delegate as it’s imported today:<br></p><p>func useDelegate(delegate: NSTableViewDelegate) {<br>  if let getView = delegate.tableView(_:viewFor:row:) { // since the requirement is optional, a reference to the method produces a value of optional function type<br>    // I can call getView here<br>  }<br></p><p>  if let getHeight = delegate.tableView(_:heightOfRow:) {<br>    // I can call getHeight here<br>  }<br>}<br></p><p>With my proposal, we’d have some compiler-synthesized attribute (let’s call it @__caller_default_implementation) that gets places on Objective-C optional requirements when they get imported, e.g.,<br></p><p>@objc protocol NSTableViewDelegate {<br>  @__caller_default_implementation func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView?<br>  @__caller_default_implementation func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat<br>}<br></p><p>And “optional” disappears from the language. Now, there’s no optionality left, so our useDelegate example tries to just do correct calls:<br></p><p>func useDelegate(delegate: NSTableViewDelegate) -&gt; NSView? {<br>  let view = delegate.tableView(tableView, viewFor: column, row: row)<br>  let height = delegate.tableView(tableView, heightOfRow: row)<br>}<br></p><p>Of course, the code above will fail if the actual delegate doesn’t implement both methods. We need some kind of default implementation to fall back on in that case. I propose that the code above produce a compiler error on both lines *unless* there is a “default implementation” visible. So, to make the code above compile without error, one would have to add:<br></p><p>extension NSTableViewDelegate {<br>  @nonobjc func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView? { return nil }<br>  <br>  @nonobjc func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat { return 17 }<br>} <br></p><p>Now, the useDelegate example compiles. If the actual delegate implements the optional requirement, we’ll use that implementation. Otherwise, the caller will use the default (Swift-only) implementation it sees. From an implementation standpoint, the compiler would effectively produce the following for the first of these calls:<br></p><p>if delegate.responds(to: #selector(NSTableViewDelegate.tableView(_:viewFor:row:))) {<br>  // call the @objc instance method with the selector tableView:viewForTableColumn:row:<br>} else {<br>  // call the Swift-only implementation of tableView(_:viewFor:row:) in the protocol extension above<br>}<br></p><p>There are a number of reasons why I like this approach:<br></p><p>1) It eliminates the notion of ‘optional’ requirements from the language. For classes that are adopting the NSTableViewDelegate protocol, it is as if these requirements had default implementations.<br></p><p>2) Only the callers to these requirements have to deal with the lack of default implementations. This was already the case for optional requirements, so it’s not an extra burden in principle, and it’s generally going to be easier to write one defaulted implementation than deal with it in several different places. Additionally, most of these callers are probably in the Cocoa frameworks, not application code, so the overall impact should be small.<br></p><p>Thoughts?<br></p><p>	- Doug<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160407/219dabfc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[Idea] How to eliminate &#39;optional&#39; protocol requirements</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>April  7, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Apr 7, 2016, at 6:12 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&lt;snip&gt;<br>&gt; With my proposal, we’d have some compiler-synthesized attribute (let’s call it @__caller_default_implementation) that gets places on Objective-C optional requirements when they get imported, e.g.,<br>&gt; <br>&gt; @objc protocol NSTableViewDelegate {<br>&gt;   @__caller_default_implementation func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView?<br>&gt;   @__caller_default_implementation func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat<br>&gt; }<br></p><p>If I understand correctly:<br></p><p>1. Optional methods in protocols imported from objective C gain a special flag when imported as Swift methods<br>2. Such methods can be unimplemented (such that the message will fail, or responds(to:) returns false) in objective-c code and bridged swift instances.<br>3. To implement that protocol in swift, you must have implementations of every protocol method, including optional ones<br>4. This means that there may be manual work around bridging protocols with optional messages into swift.<br>5. If the method implementation is marked @nonobjc it will fulfill the swift requirement that there be a method implementation, but that implementation will not be exposed to Objective-C<br>6. Swift code can call such a @nonobjc implementation, while Objective-C code will consider there to be nothing there.<br>7 An implementation that is only be applied to the swift variant is possibly fine in extensions while generates a warning within a swift class, or perhaps requires an explicit @nonobjc attribute.<br></p><p>I like it, except for the requirement for a manual implementation in Swift before you can support the protocol. <br></p><p>I looked at whether the protocol members might be implemented by returning the nil/zero/false value you would get if you sent the message to nil. <br></p><p>Cursory search quickly hit NSAccessibilityElement, which has an optional “accessibilityIdentifier” method returning a non-nil NSString. I suspect that the method also requires the string to be non-empty. Thus, a default implementation that represents the right thing to represent in a generated default implementation would likely be brittle.<br></p><p>I could also see an imported protocol where *any* default implementation of the optional method would not meet the requirements of an actual implementation of the method (not being versed in this particular interface, I’ll just straw man that the identifier is required to be unique within an application)<br></p><p>Thus I wonder if there may be some other way to support the idea of two distinct protocols, the protocol as defined in Objective C, and the protocol as defined in Swift.<br></p><p>Options that sprang to mind:<br>- the methods which return optional values have a default implementation that returns nil. Methods which return non-optional values will have the Swift protocol modified to return an Optional value, which they will do by default. So for example, Still on NSAccessibilityElement,<br></p><p>	-(BOOL)isAccessibilityFocused<br></p><p>would be imported as<br></p><p>	func isAccessibilityFocused() -&gt; Bool?<br></p><p>with a default implementation returning nil. To actually implement the objective C protocol’s optional method, you must implement the version with the correct nullability variant, so in this case:<br></p><p>     @objc func isAccessiblityFocused() -&gt; Bool { return focused }<br></p><p>(Of course, this means that a non-optional result value would need to satisfy an optional result valued variant in a protocol)<br></p><p>- similar to the above, but rather than overriding result values to support a default variant, overload ErrorType. Imported variants which throw will by default throw a bridging-specific ErrorType when called from Swift. Optional methods which do not throw will have a throwing variant generated on the Swift side. <br></p><p>Again similar to the above, to satisfy the objective-C protocol requirement your implementation would need to be non-throwing.<br></p><p>I like this better in terms of capturing to the best of ones ability the ‘spirit’ of optional methods and behavior in swift. However, this seems like it will result in more deviation between the Swift and Objective-C protocol method signatures.<br></p><p>Comments?<br></p><p>-DW<br></p><p>&gt; <br>&gt; And “optional” disappears from the language. Now, there’s no optionality left, so our useDelegate example tries to just do correct calls:<br>&gt; <br>&gt; func useDelegate(delegate: NSTableViewDelegate) -&gt; NSView? {<br>&gt;   let view = delegate.tableView(tableView, viewFor: column, row: row)<br>&gt;   let height = delegate.tableView(tableView, heightOfRow: row)<br>&gt; }<br>&gt; <br>&gt; Of course, the code above will fail if the actual delegate doesn’t implement both methods. We need some kind of default implementation to fall back on in that case. I propose that the code above produce a compiler error on both lines *unless* there is a “default implementation” visible. So, to make the code above compile without error, one would have to add:<br>&gt; <br>&gt; extension NSTableViewDelegate {<br>&gt;   @nonobjc func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView? { return nil }<br>&gt;   <br>&gt;   @nonobjc func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat { return 17 }<br>&gt; } <br>&gt; <br>&gt; Now, the useDelegate example compiles. If the actual delegate implements the optional requirement, we’ll use that implementation. Otherwise, the caller will use the default (Swift-only) implementation it sees. From an implementation standpoint, the compiler would effectively produce the following for the first of these calls:<br>&gt; <br>&gt; if delegate.responds(to: #selector(NSTableViewDelegate.tableView(_:viewFor:row:))) {<br>&gt;   // call the @objc instance method with the selector tableView:viewForTableColumn:row:<br>&gt; } else {<br>&gt;   // call the Swift-only implementation of tableView(_:viewFor:row:) in the protocol extension above<br>&gt; }<br>&gt; <br>&gt; There are a number of reasons why I like this approach:<br>&gt; <br>&gt; 1) It eliminates the notion of ‘optional’ requirements from the language. For classes that are adopting the NSTableViewDelegate protocol, it is as if these requirements had default implementations.<br>&gt; <br>&gt; 2) Only the callers to these requirements have to deal with the lack of default implementations. This was already the case for optional requirements, so it’s not an extra burden in principle, and it’s generally going to be easier to write one defaulted implementation than deal with it in several different places. Additionally, most of these callers are probably in the Cocoa frameworks, not application code, so the overall impact should be small.<br>&gt; <br>&gt; Thoughts?<br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160407/60015faf/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[Idea] How to eliminate &#39;optional&#39; protocol requirements</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>April  8, 2016 at 07:00:00am</p></header><div class="content"><p>Proposal sounds nice, but shouldn&#39;t it go hand in hand with the review of dispatching rules for protocol extensions (i.e.: dynamic dispatch by default unless overridden by a user declaration/annotation or when the compiler is sure no side effects will occur... ProtocolA and InstanceAImplementingProtocolA must behave the same when calling a method)?<br>In a type safe language, the lack of safety current complex dispatching rules bring seems odd not to address :/. Sorry for the aside rant.<br></p><p>[[iOS messageWithData:ideas] broadcast]<br></p><p>&gt; On 8 Apr 2016, at 01:12, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi all,<br>&gt; <br>&gt; Optional protocol requirements in Swift have the restriction that they only work in @objc protocols, a topic that’s come up a number of times. The start of these threads imply that optional requirements should be available for all protocols in Swift. While this direction is implementable, each time this is discussed there is significant feedback that optional requirements are not a feature we want in Swift. They overlap almost completely with default implementations of protocol requirements, which is a more general feature, and people seem to feel that designs based around default implementations and refactoring of protocol hierarchies are overall better.<br>&gt; <br>&gt; The main concern with removing optional requirements from Swift is their impact on Cocoa: Objective-C protocols, especially for delegates and data sources, make heavy use of optional requirements. Moreover, there are no default implementations for any of these optional requirements: each caller effectively checks for the presence of the method explicitly, and implements its own logic if the method isn’t there.<br>&gt; <br>&gt; A Non-Workable Solution: Import as optional property requirements<br>&gt; One suggestion that’s come up to map an optional requirement to a property with optional type, were “nil” indicates that the requirement was not satisfied. For example, <br>&gt; <br>&gt; @protocol NSTableViewDelegate<br>&gt; @optional<br>&gt; - (nullable NSView *)tableView:(NSTableView *)tableView viewForTableColumn:(NSTableColumn *)tableColumn row:(NSInteger)row;<br>&gt; - (CGFloat)tableView:(NSTableView *)tableView heightOfRow:(NSInteger)row;<br>&gt; @end<br>&gt; <br>&gt; currently comes in as<br>&gt; <br>&gt; @objc protocol NSTableViewDelegate {<br>&gt;   optional func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView?<br>&gt;   optional func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat<br>&gt; }<br>&gt; <br>&gt; would come in as:<br>&gt; <br>&gt; @objc protocol NSTableViewDelegate {<br>&gt;   var tableView: ((NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView?)? { get }<br>&gt;   var tableView: ((NSTableView, heightOfRow: Int) -&gt; CGFloat)? { get }<br>&gt; }<br>&gt; <br>&gt; with a default implementation of “nil” for each. However, this isn’t practical for a number of reasons:<br>&gt; <br>&gt; a) We would end up overloading the property name “tableView” a couple dozen times, which doesn’t actually work.<br>&gt; <br>&gt; b) You can no longer refer to the member with a compound name, e.g., “delegate.tableView(_:viewFor:row:)” no longer works, because the name of the property is “tableView”.<br>&gt; <br>&gt; c) Implementers of the protocol now need to provide a read-only property that returns a closure. So instead of<br>&gt; <br>&gt; class MyDelegate : NSTableViewDelegate {<br>&gt;   func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView? { … }<br>&gt; }<br>&gt; <br>&gt; one would have to write something like<br>&gt; <br>&gt; class MyDelegate : NSTableViewDelegate {<br>&gt;   var tableView: ((NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView?)? = {<br>&gt;     … except you can’t refer to self in here unless you make it lazy ...<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; d) We’ve seriously considered eliminating argument labels on function types, because they’re a complexity in the type system that doesn’t serve much of a purpose.<br>&gt; <br>&gt; One could perhaps work around (a), (b), and (d) by allowing compound (function-like) names like tableView(_:viewFor:row:) for properties, and work around (c) by allowing a method to satisfy the requirement for a read-only property, but at this point you’ve invented more language hacks than the existing @objc-only optional requirements. So, I don’t think there is a solution here.<br>&gt; <br>&gt; Proposed Solution: Caller-side default implementations<br>&gt; <br>&gt; Default implementations and optional requirements differ most on the caller side. For example, let’s use NSTableView delegate as it’s imported today:<br>&gt; <br>&gt; func useDelegate(delegate: NSTableViewDelegate) {<br>&gt;   if let getView = delegate.tableView(_:viewFor:row:) { // since the requirement is optional, a reference to the method produces a value of optional function type<br>&gt;     // I can call getView here<br>&gt;   }<br>&gt; <br>&gt;   if let getHeight = delegate.tableView(_:heightOfRow:) {<br>&gt;     // I can call getHeight here<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; With my proposal, we’d have some compiler-synthesized attribute (let’s call it @__caller_default_implementation) that gets places on Objective-C optional requirements when they get imported, e.g.,<br>&gt; <br>&gt; @objc protocol NSTableViewDelegate {<br>&gt;   @__caller_default_implementation func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView?<br>&gt;   @__caller_default_implementation func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat<br>&gt; }<br>&gt; <br>&gt; And “optional” disappears from the language. Now, there’s no optionality left, so our useDelegate example tries to just do correct calls:<br>&gt; <br>&gt; func useDelegate(delegate: NSTableViewDelegate) -&gt; NSView? {<br>&gt;   let view = delegate.tableView(tableView, viewFor: column, row: row)<br>&gt;   let height = delegate.tableView(tableView, heightOfRow: row)<br>&gt; }<br>&gt; <br>&gt; Of course, the code above will fail if the actual delegate doesn’t implement both methods. We need some kind of default implementation to fall back on in that case. I propose that the code above produce a compiler error on both lines *unless* there is a “default implementation” visible. So, to make the code above compile without error, one would have to add:<br>&gt; <br>&gt; extension NSTableViewDelegate {<br>&gt;   @nonobjc func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView? { return nil }<br>&gt;   <br>&gt;   @nonobjc func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat { return 17 }<br>&gt; } <br>&gt; <br>&gt; Now, the useDelegate example compiles. If the actual delegate implements the optional requirement, we’ll use that implementation. Otherwise, the caller will use the default (Swift-only) implementation it sees. From an implementation standpoint, the compiler would effectively produce the following for the first of these calls:<br>&gt; <br>&gt; if delegate.responds(to: #selector(NSTableViewDelegate.tableView(_:viewFor:row:))) {<br>&gt;   // call the @objc instance method with the selector tableView:viewForTableColumn:row:<br>&gt; } else {<br>&gt;   // call the Swift-only implementation of tableView(_:viewFor:row:) in the protocol extension above<br>&gt; }<br>&gt; <br>&gt; There are a number of reasons why I like this approach:<br>&gt; <br>&gt; 1) It eliminates the notion of ‘optional’ requirements from the language. For classes that are adopting the NSTableViewDelegate protocol, it is as if these requirements had default implementations.<br>&gt; <br>&gt; 2) Only the callers to these requirements have to deal with the lack of default implementations. This was already the case for optional requirements, so it’s not an extra burden in principle, and it’s generally going to be easier to write one defaulted implementation than deal with it in several different places. Additionally, most of these callers are probably in the Cocoa frameworks, not application code, so the overall impact should be small.<br>&gt; <br>&gt; Thoughts?<br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160408/9c520192/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>[Idea] How to eliminate &#39;optional&#39; protocol requirements</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>April  8, 2016 at 03:00:00pm</p></header><div class="content"><p>I want to reiterate that I have objective-c code, others have objc code,<br>and the cocoa, etc. frameworks have code that depend on optional protocol<br>for things like (but not limited to) delegates. This is of course obvious<br>but what seems to get lost in the discussion is that you can&#39;t always<br>replace the non-existence of an implementation of an optional protocol<br>method with a default implementation.<br></p><p>I have code that probes a delegate when registered and based on the what<br>subset of the optional protocol methods it handles configures its runtime<br>state to optimize itself to that reality. For example it may avoid<br>allocating and maintaining potentially complex state if one or more methods<br>are not implemented by the delegate (since no one is interested in it). If<br>we just blindly provide default implementation for optional methods then<br>this optimization couldn&#39;t take place.<br></p><p>I know others - including I believe Apple framework code - do similar<br>optimizations based on what methods an object implements.<br></p><p>I think we should maintain the optional concept in support of bridging<br>existing objc code into swift (confined to @objc)... unless a way to bridge<br>things can be defined that avoids the loss of optimization potential I<br>outlined above.<br></p><p>Optional protocols don&#39;t need to be expanded into Swift itself since I<br>believe alternate methods and patterns exists to solve the same type of<br>need.<br></p><p>-Shawn<br></p><p>On Thu, Apr 7, 2016 at 5:12 PM Douglas Gregor via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hi all,<br>&gt;<br>&gt; Optional protocol requirements in Swift have the restriction that they<br>&gt; only work in @objc protocols, a topic that’s come up a number<br>&gt; &lt;http://thread.gmane.org/gmane.comp.lang.swift.devel/1316/focus=8804&gt; of<br>&gt; times<br>&gt; &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/13347/focus=13480&gt;.<br>&gt; The start of these threads imply that optional requirements should be<br>&gt; available for all protocols in Swift. While this direction is<br>&gt; implementable, each time this is discussed there is significant feedback<br>&gt; that optional requirements are not a feature we want in Swift. They overlap<br>&gt; almost completely with default implementations of protocol requirements,<br>&gt; which is a more general feature, and people seem to feel that designs based<br>&gt; around default implementations and refactoring of protocol hierarchies are<br>&gt; overall better.<br>&gt;<br>&gt; The main concern with removing optional requirements from Swift is their<br>&gt; impact on Cocoa: Objective-C protocols, especially for delegates and data<br>&gt; sources, make heavy use of optional requirements. Moreover, there are no<br>&gt; default implementations for any of these optional requirements: each caller<br>&gt; effectively checks for the presence of the method explicitly, and<br>&gt; implements its own logic if the method isn’t there.<br>&gt;<br>&gt; *A Non-Workable Solution: Import as optional property requirements*<br>&gt; One suggestion that’s come up to map an optional requirement to a property<br>&gt; with optional type, were “nil” indicates that the requirement was not<br>&gt; satisfied. For example,<br>&gt;<br>&gt; @protocol NSTableViewDelegate<br>&gt; @optional<br>&gt; - (nullable NSView *)tableView:(NSTableView *)tableView<br>&gt; viewForTableColumn:(NSTableColumn *)tableColumn row:(NSInteger)row;<br>&gt; - (CGFloat)tableView:(NSTableView *)tableView heightOfRow:(NSInteger)row;<br>&gt; @end<br>&gt;<br>&gt;<br>&gt; currently comes in as<br>&gt;<br>&gt; @objc protocol NSTableViewDelegate {<br>&gt;   optional func tableView(_: NSTableView, viewFor: NSTableColumn, row:<br>&gt; Int) -&gt; NSView?<br>&gt;   optional func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat<br>&gt; }<br>&gt;<br>&gt; would come in as:<br>&gt;<br>&gt; @objc protocol NSTableViewDelegate {<br>&gt;   var tableView: ((NSTableView, viewFor: NSTableColumn, row: Int) -&gt;<br>&gt; NSView?)? { get }<br>&gt;   var tableView: ((NSTableView, heightOfRow: Int) -&gt; CGFloat)? { get }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; with a default implementation of “nil” for each. However, this isn’t<br>&gt; practical for a number of reasons:<br>&gt;<br>&gt; a) We would end up overloading the property name “tableView” a couple<br>&gt; dozen times, which doesn’t actually work.<br>&gt;<br>&gt; b) You can no longer refer to the member with a compound name, e.g.,<br>&gt; “delegate.tableView(_:viewFor:row:)” no longer works, because the name of<br>&gt; the property is “tableView”.<br>&gt;<br>&gt; c) Implementers of the protocol now need to provide a read-only property<br>&gt; that returns a closure. So instead of<br>&gt;<br>&gt; class MyDelegate : NSTableViewDelegate {<br>&gt;   func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int) -&gt;<br>&gt; NSView? { … }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; one would have to write something like<br>&gt;<br>&gt; class MyDelegate : NSTableViewDelegate {<br>&gt;   var tableView: ((NSTableView, viewFor: NSTableColumn, row: Int) -&gt;<br>&gt; NSView?)? = {<br>&gt;     … except you can’t refer to self in here unless you make it lazy ...<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; d) We’ve seriously considered eliminating argument labels on function<br>&gt; types, because they’re a complexity in the type system that doesn’t serve<br>&gt; much of a purpose.<br>&gt;<br>&gt; One could perhaps work around (a), (b), and (d) by allowing compound<br>&gt; (function-like) names like tableView(_:viewFor:row:) for properties, and<br>&gt; work around (c) by allowing a method to satisfy the requirement for a<br>&gt; read-only property, but at this point you’ve invented more language hacks<br>&gt; than the existing @objc-only optional requirements. So, I don’t think there<br>&gt; is a solution here.<br>&gt;<br>&gt; *Proposed Solution: Caller-side default implementations*<br>&gt;<br>&gt; Default implementations and optional requirements differ most on the<br>&gt; caller side. For example, let’s use NSTableView delegate as it’s imported<br>&gt; today:<br>&gt;<br>&gt; func useDelegate(delegate: NSTableViewDelegate) {<br>&gt;   if let getView = delegate.tableView(_:viewFor:row:) { // since the<br>&gt; requirement is optional, a reference to the method produces a value of<br>&gt; optional function type<br>&gt;     // I can call getView here<br>&gt;   }<br>&gt;<br>&gt;   if let getHeight = delegate.tableView(_:heightOfRow:) {<br>&gt;     // I can call getHeight here<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; With my proposal, we’d have some compiler-synthesized attribute (let’s<br>&gt; call it @__caller_default_implementation) that gets places on Objective-C<br>&gt; optional requirements when they get imported, e.g.,<br>&gt;<br>&gt; @objc protocol NSTableViewDelegate {<br>&gt;   @__caller_default_implementation func tableView(_: NSTableView, viewFor:<br>&gt; NSTableColumn, row: Int) -&gt; NSView?<br>&gt;   @__caller_default_implementation func tableView(_: NSTableView,<br>&gt; heightOfRow: Int) -&gt; CGFloat<br>&gt; }<br>&gt;<br>&gt; And “optional” disappears from the language. Now, there’s no optionality<br>&gt; left, so our useDelegate example tries to just do correct calls:<br>&gt;<br>&gt; func useDelegate(delegate: NSTableViewDelegate) -&gt; NSView? {<br>&gt;   let view = delegate.tableView(tableView, viewFor: column, row: row)<br>&gt;   let height = delegate.tableView(tableView, heightOfRow: row)<br>&gt; }<br>&gt;<br>&gt; Of course, the code above will fail if the actual delegate doesn’t<br>&gt; implement both methods. We need some kind of default implementation to fall<br>&gt; back on in that case. I propose that the code above produce a compiler<br>&gt; error on both lines *unless* there is a “default implementation” visible.<br>&gt; So, to make the code above compile without error, one would have to add:<br>&gt;<br>&gt; extension NSTableViewDelegate {<br>&gt;   @nonobjc func tableView(_: NSTableView, viewFor: NSTableColumn, row:<br>&gt; Int) -&gt; NSView? { return nil }<br>&gt;<br>&gt;   @nonobjc func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat {<br>&gt; return 17 }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Now, the useDelegate example compiles. If the actual delegate implements<br>&gt; the optional requirement, we’ll use that implementation. Otherwise, the<br>&gt; caller will use the default (Swift-only) implementation it sees. From an<br>&gt; implementation standpoint, the compiler would effectively produce the<br>&gt; following for the first of these calls:<br>&gt;<br>&gt; if delegate.responds(to:<br>&gt; #selector(NSTableViewDelegate.tableView(_:viewFor:row:))) {<br>&gt;   // call the @objc instance method with the selector<br>&gt; tableView:viewForTableColumn:row:<br>&gt; } else {<br>&gt;   // call the Swift-only implementation of tableView(_:viewFor:row:) in<br>&gt; the protocol extension above<br>&gt; }<br>&gt;<br>&gt;<br>&gt; There are a number of reasons why I like this approach:<br>&gt;<br>&gt; 1) It eliminates the notion of ‘optional’ requirements from the language.<br>&gt; For classes that are adopting the NSTableViewDelegate protocol, it is as if<br>&gt; these requirements had default implementations.<br>&gt;<br>&gt; 2) Only the callers to these requirements have to deal with the lack of<br>&gt; default implementations. This was already the case for optional<br>&gt; requirements, so it’s not an extra burden in principle, and it’s generally<br>&gt; going to be easier to write one defaulted implementation than deal with it<br>&gt; in several different places. Additionally, most of these callers are<br>&gt; probably in the Cocoa frameworks, not application code, so the overall<br>&gt; impact should be small.<br>&gt;<br>&gt; Thoughts?<br>&gt;<br>&gt; - Doug<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160408/a0b65edb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Idea] How to eliminate &#39;optional&#39; protocol requirements</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>April 12, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Apr 8, 2016, at 8:53 AM, Shawn Erickson &lt;shawnce at gmail.com&gt; wrote:<br>&gt; <br>&gt; I want to reiterate that I have objective-c code, others have objc code, and the cocoa, etc. frameworks have code that depend on optional protocol for things like (but not limited to) delegates. This is of course obvious but what seems to get lost in the discussion is that you can&#39;t always replace the non-existence of an implementation of an optional protocol method with a default implementation.<br>&gt; <br>&gt; I have code that probes a delegate when registered and based on the what subset of the optional protocol methods it handles configures its runtime state to optimize itself to that reality. For example it may avoid allocating and maintaining potentially complex state if one or more methods are not implemented by the delegate (since no one is interested in it). If we just blindly provide default  implementation for optional methods then this optimization couldn&#39;t take place.<br>&gt; <br>&gt; I know others - including I believe Apple framework code - do similar optimizations based on what methods an object implements.<br></p><p>Just to be very clear (which I think my initial post wasn’t) my proposal does *not* break this optimization when a Swift class is conforming to an @objc protocol: even if a default is present, it won’t be visible to the Objective-C runtime at all.<br></p><p>My proposal *does* make it significantly harder to implement a check for “did the type implement this method?”, because one will effectively have to use -respondsToSelector:. For Cocoa-defined delegates, that doesn’t matter at all: apps generally implement requirements of delegates/data sources, but almost never go through the protocol to use those methods/properties. It’s the frameworks that do the calling, and of course they’re already using -respondsToSelector: checks.<br></p><p>The main effect is in Swift code that uses @objc optionals and tests for the absence of an implementation to perform some optimization. The tenor of the previous thread seems to indicate that this probably isn’t common, because there are probably better ways to model these cases in Swift—whether it’s with multiple protocols or something that specifically describes the policy (e.g., http://thread.gmane.org/gmane.comp.lang.swift.evolution/13347/focus=13480).<br></p><p><br>&gt; I think we should maintain the optional concept in support of bridging existing objc code into swift (confined to @objc)... unless a way to bridge things can be defined that avoids the loss of optimization potential I outlined above.<br></p><p>The direction I’m trying to go is not to have half of a feature—something that seems like it should be general, but is tied to @objc—in the language. We get a very large number of requests to make “optional” work for Swift protocols, because it’s a confusing limitation and there is a ton of overlap with default implementations. It would be far better to remove the feature.<br></p><p>&gt; <br>&gt; Optional protocols don&#39;t need to be expanded into Swift itself since I believe alternate methods and patterns exists to solve the same type of need.<br></p><p>Given that you don’t feel that optional requirements need to work in Swift-only protocols, and what I’ve said above about compatibility with Cocoa, do you still think we need to keep ‘@objc optional’ as a notion in the language?<br></p><p>	- Doug<br></p><p>&gt; <br>&gt; -Shawn<br>&gt; <br>&gt; On Thu, Apr 7, 2016 at 5:12 PM Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Hi all,<br>&gt; <br>&gt; Optional protocol requirements in Swift have the restriction that they only work in @objc protocols, a topic that’s come up a number &lt;http://thread.gmane.org/gmane.comp.lang.swift.devel/1316/focus=8804&gt; of times &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/13347/focus=13480&gt;. The start of these threads imply that optional requirements should be available for all protocols in Swift. While this direction is implementable, each time this is discussed there is significant feedback that optional requirements are not a feature we want in Swift. They overlap almost completely with default implementations of protocol requirements, which is a more general feature, and people seem to feel that designs based around default implementations and refactoring of protocol hierarchies are overall better.<br>&gt; <br>&gt; The main concern with removing optional requirements from Swift is their impact on Cocoa: Objective-C protocols, especially for delegates and data sources, make heavy use of optional requirements. Moreover, there are no default implementations for any of these optional requirements: each caller effectively checks for the presence of the method explicitly, and implements its own logic if the method isn’t there.<br>&gt; <br>&gt; A Non-Workable Solution: Import as optional property requirements<br>&gt; One suggestion that’s come up to map an optional requirement to a property with optional type, were “nil” indicates that the requirement was not satisfied. For example, <br>&gt; <br>&gt; @protocol NSTableViewDelegate<br>&gt; @optional<br>&gt; - (nullable NSView *)tableView:(NSTableView *)tableView viewForTableColumn:(NSTableColumn *)tableColumn row:(NSInteger)row;<br>&gt; - (CGFloat)tableView:(NSTableView *)tableView heightOfRow:(NSInteger)row;<br>&gt; @end<br>&gt; <br>&gt; currently comes in as<br>&gt; <br>&gt; @objc protocol NSTableViewDelegate {<br>&gt;   optional func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView?<br>&gt;   optional func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat<br>&gt; }<br>&gt; <br>&gt; would come in as:<br>&gt; <br>&gt; @objc protocol NSTableViewDelegate {<br>&gt;   var tableView: ((NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView?)? { get }<br>&gt;   var tableView: ((NSTableView, heightOfRow: Int) -&gt; CGFloat)? { get }<br>&gt; }<br>&gt; <br>&gt; with a default implementation of “nil” for each. However, this isn’t practical for a number of reasons:<br>&gt; <br>&gt; a) We would end up overloading the property name “tableView” a couple dozen times, which doesn’t actually work.<br>&gt; <br>&gt; b) You can no longer refer to the member with a compound name, e.g., “delegate.tableView(_:viewFor:row:)” no longer works, because the name of the property is “tableView”.<br>&gt; <br>&gt; c) Implementers of the protocol now need to provide a read-only property that returns a closure. So instead of<br>&gt; <br>&gt; class MyDelegate : NSTableViewDelegate {<br>&gt;   func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView? { … }<br>&gt; }<br>&gt; <br>&gt; one would have to write something like<br>&gt; <br>&gt; class MyDelegate : NSTableViewDelegate {<br>&gt;   var tableView: ((NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView?)? = {<br>&gt;     … except you can’t refer to self in here unless you make it lazy ...<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; d) We’ve seriously considered eliminating argument labels on function types, because they’re a complexity in the type system that doesn’t serve much of a purpose.<br>&gt; <br>&gt; One could perhaps work around (a), (b), and (d) by allowing compound (function-like) names like tableView(_:viewFor:row:) for properties, and work around (c) by allowing a method to satisfy the requirement for a read-only property, but at this point you’ve invented more language hacks than the existing @objc-only optional requirements. So, I don’t think there is a solution here.<br>&gt; <br>&gt; Proposed Solution: Caller-side default implementations<br>&gt; <br>&gt; Default implementations and optional requirements differ most on the caller side. For example, let’s use NSTableView delegate as it’s imported today:<br>&gt; <br>&gt; func useDelegate(delegate: NSTableViewDelegate) {<br>&gt;   if let getView = delegate.tableView(_:viewFor:row:) { // since the requirement is optional, a reference to the method produces a value of optional function type<br>&gt;     // I can call getView here<br>&gt;   }<br>&gt; <br>&gt;   if let getHeight = delegate.tableView(_:heightOfRow:) {<br>&gt;     // I can call getHeight here<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; With my proposal, we’d have some compiler-synthesized attribute (let’s call it @__caller_default_implementation) that gets places on Objective-C optional requirements when they get imported, e.g.,<br>&gt; <br>&gt; @objc protocol NSTableViewDelegate {<br>&gt;   @__caller_default_implementation func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView?<br>&gt;   @__caller_default_implementation func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat<br>&gt; }<br>&gt; <br>&gt; And “optional” disappears from the language. Now, there’s no optionality left, so our useDelegate example tries to just do correct calls:<br>&gt; <br>&gt; func useDelegate(delegate: NSTableViewDelegate) -&gt; NSView? {<br>&gt;   let view = delegate.tableView(tableView, viewFor: column, row: row)<br>&gt;   let height = delegate.tableView(tableView, heightOfRow: row)<br>&gt; }<br>&gt; <br>&gt; Of course, the code above will fail if the actual delegate doesn’t implement both methods. We need some kind of default implementation to fall back on in that case. I propose that the code above produce a compiler error on both lines *unless* there is a “default implementation” visible. So, to make the code above compile without error, one would have to add:<br>&gt; <br>&gt; extension NSTableViewDelegate {<br>&gt;   @nonobjc func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView? { return nil }<br>&gt;   <br>&gt;   @nonobjc func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat { return 17 }<br>&gt; } <br>&gt; <br>&gt; Now, the useDelegate example compiles. If the actual delegate implements the optional requirement, we’ll use that implementation. Otherwise, the caller will use the default (Swift-only) implementation it sees. From an implementation standpoint, the compiler would effectively produce the following for the first of these calls:<br>&gt; <br>&gt; if delegate.responds(to: #selector(NSTableViewDelegate.tableView(_:viewFor:row:))) {<br>&gt;   // call the @objc instance method with the selector tableView:viewForTableColumn:row:<br>&gt; } else {<br>&gt;   // call the Swift-only implementation of tableView(_:viewFor:row:) in the protocol extension above<br>&gt; }<br>&gt; <br>&gt; There are a number of reasons why I like this approach:<br>&gt; <br>&gt; 1) It eliminates the notion of ‘optional’ requirements from the language. For classes that are adopting the NSTableViewDelegate protocol, it is as if these requirements had default implementations.<br>&gt; <br>&gt; 2) Only the callers to these requirements have to deal with the lack of default implementations. This was already the case for optional requirements, so it’s not an extra burden in principle, and it’s generally going to be easier to write one defaulted implementation than deal with it in several different places. Additionally, most of these callers are probably in the Cocoa frameworks, not application code, so the overall impact should be small.<br>&gt; <br>&gt; Thoughts?<br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160412/22f84a2b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Idea] How to eliminate &#39;optional&#39; protocol requirements</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>April 13, 2016 at 02:00:00am</p></header><div class="content"><p>What about this? I’m unfamiliar with the details of objc-swift interoperability, so I’m not actually sure it could work this way, nor am I certain that I’m not just “rephrasing” something that’s already been suggested.<br>protocol SomeProtocol {<br>    //Non-optional stuff goes here<br>}<br>extension SomeProtocol {<br>    //Optional stuff goes here<br>    func blah() {<br>        //Default implementation goes here<br>    }<br>}<br></p><p>protocol SomeSubProtocol : SomeProtocol {<br>    //The same optional stuff goes here again<br>    func blah()<br>}<br></p><p>func foo&lt;T : SomeProtocol&gt; (x:T) {<br>    if let x = x as? SomeSubProtocol {<br>        x.blah() //Is custom implementation because we know x is SomeOtherProtocol<br>    } else {<br>        x.blah() //Is default implementation because we know it&#39;s not<br>    }<br>    ...<br>}<br></p><p>(It seems like there ought to be a less repetitive way to do the branch. The problem is that any expression would necessarily have to evaluate to two different types, depending on whether T conforms to the sub protocol.)<br></p><p>Anyway, does that correctly model the relationship between optional requirements and their protocols? I’ve used optional protocol requirements just enough to use UIKit and such, but I find the whole self-contradictional &quot;optional requirement” thing confusing enough that I’ve never really felt like I understand them. There’s a fair chance that I’m missing their point.<br></p><p>If that is the correct model, is there a way to automatically create all the objc “subprotocols&quot; as they’re being imported into swift? If so, would it be beneficial to maybe “nest” the protocols to prevent UIKit from declaring 50 million “top level” protocols?<br>protocol SomeProtocol {<br>    protocol SomeOtherProtocol { // the &quot; : SomeProtocol&quot; part is implied<br>        func blah() -&gt; Int<br>    }<br>    //Non-optional stuff goes here<br>}<br>extension SomeProtocol {<br>    //Optional stuff goes here<br>    func blah() -&gt; Int {<br>        return 5<br>    }<br>}<br>func blah&lt;T : SomeProtocol&gt; (x:T) -&gt; Int {<br>    if let x = x as? SomeProtocol.SomeOtherProtocol {…}<br>}<br></p><p>- Dave Sweeris<br></p><p>&gt; On Apr 13, 2016, at 12:47 AM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 8, 2016, at 8:53 AM, Shawn Erickson &lt;shawnce at gmail.com &lt;mailto:shawnce at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I want to reiterate that I have objective-c code, others have objc code, and the cocoa, etc. frameworks have code that depend on optional protocol for things like (but not limited to) delegates. This is of course obvious but what seems to get lost in the discussion is that you can&#39;t always replace the non-existence of an implementation of an optional protocol method with a default implementation.<br>&gt;&gt; <br>&gt;&gt; I have code that probes a delegate when registered and based on the what subset of the optional protocol methods it handles configures its runtime state to optimize itself to that reality. For example it may avoid allocating and maintaining potentially complex state if one or more methods are not implemented by the delegate (since no one is interested in it). If we just blindly provide default  implementation for optional methods then this optimization couldn&#39;t take place.<br>&gt;&gt; <br>&gt;&gt; I know others - including I believe Apple framework code - do similar optimizations based on what methods an object implements.<br>&gt; <br>&gt; Just to be very clear (which I think my initial post wasn’t) my proposal does *not* break this optimization when a Swift class is conforming to an @objc protocol: even if a default is present, it won’t be visible to the Objective-C runtime at all.<br>&gt; <br>&gt; My proposal *does* make it significantly harder to implement a check for “did the type implement this method?”, because one will effectively have to use -respondsToSelector:. For Cocoa-defined delegates, that doesn’t matter at all: apps generally implement requirements of delegates/data sources, but almost never go through the protocol to use those methods/properties. It’s the frameworks that do the calling, and of course they’re already using -respondsToSelector: checks.<br>&gt; <br>&gt; The main effect is in Swift code that uses @objc optionals and tests for the absence of an implementation to perform some optimization. The tenor of the previous thread seems to indicate that this probably isn’t common, because there are probably better ways to model these cases in Swift—whether it’s with multiple protocols or something that specifically describes the policy (e.g., http://thread.gmane.org/gmane.comp.lang.swift.evolution/13347/focus=13480 &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/13347/focus=13480&gt;).<br>&gt; <br>&gt; <br>&gt;&gt; I think we should maintain the optional concept in support of bridging existing objc code into swift (confined to @objc)... unless a way to bridge things can be defined that avoids the loss of optimization potential I outlined above.<br>&gt; <br>&gt; The direction I’m trying to go is not to have half of a feature—something that seems like it should be general, but is tied to @objc—in the language. We get a very large number of requests to make “optional” work for Swift protocols, because it’s a confusing limitation and there is a ton of overlap with default implementations. It would be far better to remove the feature.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Optional protocols don&#39;t need to be expanded into Swift itself since I believe alternate methods and patterns exists to solve the same type of need.<br>&gt; <br>&gt; Given that you don’t feel that optional requirements need to work in Swift-only protocols, and what I’ve said above about compatibility with Cocoa, do you still think we need to keep ‘@objc optional’ as a notion in the language?<br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt;&gt; <br>&gt;&gt; -Shawn<br>&gt;&gt; <br>&gt;&gt; On Thu, Apr 7, 2016 at 5:12 PM Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; Optional protocol requirements in Swift have the restriction that they only work in @objc protocols, a topic that’s come up a number &lt;http://thread.gmane.org/gmane.comp.lang.swift.devel/1316/focus=8804&gt; of times &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/13347/focus=13480&gt;. The start of these threads imply that optional requirements should be available for all protocols in Swift. While this direction is implementable, each time this is discussed there is significant feedback that optional requirements are not a feature we want in Swift. They overlap almost completely with default implementations of protocol requirements, which is a more general feature, and people seem to feel that designs based around default implementations and refactoring of protocol hierarchies are overall better.<br>&gt;&gt; <br>&gt;&gt; The main concern with removing optional requirements from Swift is their impact on Cocoa: Objective-C protocols, especially for delegates and data sources, make heavy use of optional requirements. Moreover, there are no default implementations for any of these optional requirements: each caller effectively checks for the presence of the method explicitly, and implements its own logic if the method isn’t there.<br>&gt;&gt; <br>&gt;&gt; A Non-Workable Solution: Import as optional property requirements<br>&gt;&gt; One suggestion that’s come up to map an optional requirement to a property with optional type, were “nil” indicates that the requirement was not satisfied. For example, <br>&gt;&gt; <br>&gt;&gt; @protocol NSTableViewDelegate<br>&gt;&gt; @optional<br>&gt;&gt; - (nullable NSView *)tableView:(NSTableView *)tableView viewForTableColumn:(NSTableColumn *)tableColumn row:(NSInteger)row;<br>&gt;&gt; - (CGFloat)tableView:(NSTableView *)tableView heightOfRow:(NSInteger)row;<br>&gt;&gt; @end<br>&gt;&gt; <br>&gt;&gt; currently comes in as<br>&gt;&gt; <br>&gt;&gt; @objc protocol NSTableViewDelegate {<br>&gt;&gt;   optional func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView?<br>&gt;&gt;   optional func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; would come in as:<br>&gt;&gt; <br>&gt;&gt; @objc protocol NSTableViewDelegate {<br>&gt;&gt;   var tableView: ((NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView?)? { get }<br>&gt;&gt;   var tableView: ((NSTableView, heightOfRow: Int) -&gt; CGFloat)? { get }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; with a default implementation of “nil” for each. However, this isn’t practical for a number of reasons:<br>&gt;&gt; <br>&gt;&gt; a) We would end up overloading the property name “tableView” a couple dozen times, which doesn’t actually work.<br>&gt;&gt; <br>&gt;&gt; b) You can no longer refer to the member with a compound name, e.g., “delegate.tableView(_:viewFor:row:)” no longer works, because the name of the property is “tableView”.<br>&gt;&gt; <br>&gt;&gt; c) Implementers of the protocol now need to provide a read-only property that returns a closure. So instead of<br>&gt;&gt; <br>&gt;&gt; class MyDelegate : NSTableViewDelegate {<br>&gt;&gt;   func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView? { … }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; one would have to write something like<br>&gt;&gt; <br>&gt;&gt; class MyDelegate : NSTableViewDelegate {<br>&gt;&gt;   var tableView: ((NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView?)? = {<br>&gt;&gt;     … except you can’t refer to self in here unless you make it lazy ...<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; d) We’ve seriously considered eliminating argument labels on function types, because they’re a complexity in the type system that doesn’t serve much of a purpose.<br>&gt;&gt; <br>&gt;&gt; One could perhaps work around (a), (b), and (d) by allowing compound (function-like) names like tableView(_:viewFor:row:) for properties, and work around (c) by allowing a method to satisfy the requirement for a read-only property, but at this point you’ve invented more language hacks than the existing @objc-only optional requirements. So, I don’t think there is a solution here.<br>&gt;&gt; <br>&gt;&gt; Proposed Solution: Caller-side default implementations<br>&gt;&gt; <br>&gt;&gt; Default implementations and optional requirements differ most on the caller side. For example, let’s use NSTableView delegate as it’s imported today:<br>&gt;&gt; <br>&gt;&gt; func useDelegate(delegate: NSTableViewDelegate) {<br>&gt;&gt;   if let getView = delegate.tableView(_:viewFor:row:) { // since the requirement is optional, a reference to the method produces a value of optional function type<br>&gt;&gt;     // I can call getView here<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;   if let getHeight = delegate.tableView(_:heightOfRow:) {<br>&gt;&gt;     // I can call getHeight here<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; With my proposal, we’d have some compiler-synthesized attribute (let’s call it @__caller_default_implementation) that gets places on Objective-C optional requirements when they get imported, e.g.,<br>&gt;&gt; <br>&gt;&gt; @objc protocol NSTableViewDelegate {<br>&gt;&gt;   @__caller_default_implementation func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView?<br>&gt;&gt;   @__caller_default_implementation func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; And “optional” disappears from the language. Now, there’s no optionality left, so our useDelegate example tries to just do correct calls:<br>&gt;&gt; <br>&gt;&gt; func useDelegate(delegate: NSTableViewDelegate) -&gt; NSView? {<br>&gt;&gt;   let view = delegate.tableView(tableView, viewFor: column, row: row)<br>&gt;&gt;   let height = delegate.tableView(tableView, heightOfRow: row)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Of course, the code above will fail if the actual delegate doesn’t implement both methods. We need some kind of default implementation to fall back on in that case. I propose that the code above produce a compiler error on both lines *unless* there is a “default implementation” visible. So, to make the code above compile without error, one would have to add:<br>&gt;&gt; <br>&gt;&gt; extension NSTableViewDelegate {<br>&gt;&gt;   @nonobjc func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView? { return nil }<br>&gt;&gt;   <br>&gt;&gt;   @nonobjc func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat { return 17 }<br>&gt;&gt; } <br>&gt;&gt; <br>&gt;&gt; Now, the useDelegate example compiles. If the actual delegate implements the optional requirement, we’ll use that implementation. Otherwise, the caller will use the default (Swift-only) implementation it sees. From an implementation standpoint, the compiler would effectively produce the following for the first of these calls:<br>&gt;&gt; <br>&gt;&gt; if delegate.responds(to: #selector(NSTableViewDelegate.tableView(_:viewFor:row:))) {<br>&gt;&gt;   // call the @objc instance method with the selector tableView:viewForTableColumn:row:<br>&gt;&gt; } else {<br>&gt;&gt;   // call the Swift-only implementation of tableView(_:viewFor:row:) in the protocol extension above<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; There are a number of reasons why I like this approach:<br>&gt;&gt; <br>&gt;&gt; 1) It eliminates the notion of ‘optional’ requirements from the language. For classes that are adopting the NSTableViewDelegate protocol, it is as if these requirements had default implementations.<br>&gt;&gt; <br>&gt;&gt; 2) Only the callers to these requirements have to deal with the lack of default implementations. This was already the case for optional requirements, so it’s not an extra burden in principle, and it’s generally going to be easier to write one defaulted implementation than deal with it in several different places. Additionally, most of these callers are probably in the Cocoa frameworks, not application code, so the overall impact should be small.<br>&gt;&gt; <br>&gt;&gt; Thoughts?<br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160413/f7e036dd/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d1af757c2ce75a92193ad0c34bc62af1?s=50"></div><header><strong>[Idea] How to eliminate &#39;optional&#39; protocol requirements</strong> from <string>Dietmar Planitzer</string> &lt;dplanitzer at q.com&gt;<p>April  8, 2016 at 11:00:00pm</p></header><div class="content"><p>The biggest missing part with this model is that we are still not able to enable macro-level optimizations in the delegating type by checking whether the delegate does provide his own implementation of an optional method or doesn’t. However, this is an important advantage of the ObjC model that we should not lose.<br></p><p>Maybe it’s time to take a big step back and ignore the question of how to implement things for a moment and to instead focus on the question of what the conceptual differences are between ObjC protocols with optional methods and Swift protocols with default implementations. There are two relevant viewpoints here:<br></p><p>1) From the viewpoint of a protocol adaptor:<br></p><p>ObjC:<br></p><p>1a) adopter may provide his own implementation of the protocol method, but he is no required to.<br></p><p>1b) adopter can see in the protocol declaration for which methods he must provide an implementation. Those methods do not have the “optional” keyword in front of them while optional methods do.<br></p><p>Swift:<br></p><p>1c) same as (1a).<br></p><p>1d) opening a binary-only Swift file in Xcode with a protocol definition in it which contains methods with default implementations will not give any indication of which method has a default implementation and which doesn’t. It’s only possible to see a difference on the syntax level if you have access to the sources.<br></p><p>So from the viewpoint of the protocol adopter, there isn’t much of a difference. The only relevant difference is that its always possible in ObjC to tell whether a protocol method must be implemented by the adopter or whether a method already has a default behavior. We shouldn’t actually have to change anything on the syntax-level in Swift to fix this problem. It should be sufficient to improve the Swift interface generator in Xcode so that it gives an indication whether a protocol method has a default implementation or doesn’t. Eg if we want to ensure that the generated interface is valid syntax then we could do this:<br></p><p>protocol Foo {<br></p><p>   func void bar() -&gt; Int  /* has default */<br></p><p>}<br></p><p>or if we say that it is fine that the generated interface is not valid syntax (I think it already shows &quot;= default” for function arguments with a default value which I don’t think is valid syntax), then we could do this:<br></p><p>protocol Foo {<br></p><p>   func void bar() -&gt; Int {…}<br></p><p>}<br></p><p><br>Now on to the other side of the equation.<br></p><p>2) From the viewpoint of the protocol provider (the person who defines the protocol and the type that will invoke the protocol methods):<br></p><p>ObjC:<br></p><p>2a) provider has freedom in deciding where to put the default implementation and he can put the default implementation in a single place or spread it out if necessary over multiple places. So has the freedom to choose whatever makes the most sense for the problem at hand.<br></p><p>2b) provider can detect whether the adopter provides his own protocol method implementation without compromising the definition of the protocol (compromising here means making return values optional when they should not be optional based on the natural definition of the API). This enables the provider to implement macro-level optimizations (eg table view can understand whether fixed or variable row heights are desired).<br></p><p>Swift:<br></p><p>2c) provider is forced to put the default implementation in a specific place.<br></p><p>2d) provider has no way to detect whether the adopter has provided his own implementation of the protocol method.<br></p><p><br>I do think that (2a) would be nice to have but we can probably do without it if it helps us to make progress with this topic. However, the ability to detect whether a protocol adopter provides his own implementation of a protocol method which comes with a default is a useful and important feature which helps us in optimizing the implementation of types and which allows us to keep the API surface smaller than it would be without this ability. Just go and compare eg UITableView to the Android ListView / RecyclerView to see the consequences of not having that ability and how it inflates the API surface (and keep in mind that the Android equivalents provide a fraction of the UITableView functionality).<br></p><p>The important point about (2b) is actually that we are able to detect whether an “override” (I’ll just call this overriding for now) of the default implementation exists or does not exist. In ObjC we make this distinction by checking whether an implementation of the method exists at all. But we don’t have to do it that way. An alternative approach could be based on a check that sees whether the dispatch table of the delegate contains a pointer to the default implementation of the protocol method or to some other method. So conceptually what we want is an operation like this:<br></p><p>func void useDelegate(delegate: NSTableViewDelegate) {<br></p><p>   if has_override(delegate, tableView(_:, heightOfRow:)) {<br>      // ask the delegate how many rows it has<br>      // allocate the geometry cache<br>      // fill in the geometry cache by calling tableView(_:, heightForRow:) for each row<br>   } else {<br>      // nothing to do here<br>   }<br>}<br></p><p>Which would get the job done but doesn’t look good. Maybe someone has a better idea of how the syntax such an operator could look. <br></p><p>So my point here is that what we care about is the ability to detect whether the adopter provides an implementation of a protocol method which comes with a default implementation. The point is not that Swift protocols should work the exact same way that ObjC protocols have been working under the hood. But I do think that we want to eventually get to a point where the @objc attribute disappears and that we get a truly unified language on the syntactical level. An approach where:<br></p><p>I) we accept that the default behavior of a protocol method has to be provided by the protocol itself<br></p><p>II) the language is extended with a mechanism that makes it possible for a protocol provider to detect whether the adopter has “overridden” the default implementation<br></p><p>III) we improve the Xcode Swift interface generator so that it gives a clear indication whether a protocol method does come with a default implementation<br></p><p>would give us all the relevant advantages of ObjC-style optional protocol methods and it should allow us to create a unified syntax where there is no longer a visible difference between an optional protocol method that was imported from ObjC and a native Swift protocol with default implementations.<br></p><p><br>Regards,<br></p><p>Dietmar Planitzer<br></p><p><br>&gt; On Apr 7, 2016, at 17:12, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi all,<br>&gt; <br>&gt; Optional protocol requirements in Swift have the restriction that they only work in @objc protocols, a topic that’s come up a number of times. The start of these threads imply that optional requirements should be available for all protocols in Swift. While this direction is implementable, each time this is discussed there is significant feedback that optional requirements are not a feature we want in Swift. They overlap almost completely with default implementations of protocol requirements, which is a more general feature, and people seem to feel that designs based around default implementations and refactoring of protocol hierarchies are overall better.<br>&gt; <br>&gt; The main concern with removing optional requirements from Swift is their impact on Cocoa: Objective-C protocols, especially for delegates and data sources, make heavy use of optional requirements. Moreover, there are no default implementations for any of these optional requirements: each caller effectively checks for the presence of the method explicitly, and implements its own logic if the method isn’t there.<br>&gt; <br>&gt; A Non-Workable Solution: Import as optional property requirements<br>&gt; One suggestion that’s come up to map an optional requirement to a property with optional type, were “nil” indicates that the requirement was not satisfied. For example, <br>&gt; <br>&gt; @protocol NSTableViewDelegate<br>&gt; @optional<br>&gt; - (nullable NSView *)tableView:(NSTableView *)tableView viewForTableColumn:(NSTableColumn *)tableColumn row:(NSInteger)row;<br>&gt; - (CGFloat)tableView:(NSTableView *)tableView heightOfRow:(NSInteger)row;<br>&gt; @end<br>&gt; <br>&gt; currently comes in as<br>&gt; <br>&gt; @objc protocol NSTableViewDelegate {<br>&gt;   optional func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView?<br>&gt;   optional func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat<br>&gt; }<br>&gt; <br>&gt; would come in as:<br>&gt; <br>&gt; @objc protocol NSTableViewDelegate {<br>&gt;   var tableView: ((NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView?)? { get }<br>&gt;   var tableView: ((NSTableView, heightOfRow: Int) -&gt; CGFloat)? { get }<br>&gt; }<br>&gt; <br>&gt; with a default implementation of “nil” for each. However, this isn’t practical for a number of reasons:<br>&gt; <br>&gt; a) We would end up overloading the property name “tableView” a couple dozen times, which doesn’t actually work.<br>&gt; <br>&gt; b) You can no longer refer to the member with a compound name, e.g., “delegate.tableView(_:viewFor:row:)” no longer works, because the name of the property is “tableView”.<br>&gt; <br>&gt; c) Implementers of the protocol now need to provide a read-only property that returns a closure. So instead of<br>&gt; <br>&gt; class MyDelegate : NSTableViewDelegate {<br>&gt;   func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView? { … }<br>&gt; }<br>&gt; <br>&gt; one would have to write something like<br>&gt; <br>&gt; class MyDelegate : NSTableViewDelegate {<br>&gt;   var tableView: ((NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView?)? = {<br>&gt;     … except you can’t refer to self in here unless you make it lazy ...<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; d) We’ve seriously considered eliminating argument labels on function types, because they’re a complexity in the type system that doesn’t serve much of a purpose.<br>&gt; <br>&gt; One could perhaps work around (a), (b), and (d) by allowing compound (function-like) names like tableView(_:viewFor:row:) for properties, and work around (c) by allowing a method to satisfy the requirement for a read-only property, but at this point you’ve invented more language hacks than the existing @objc-only optional requirements. So, I don’t think there is a solution here.<br>&gt; <br>&gt; Proposed Solution: Caller-side default implementations<br>&gt; <br>&gt; Default implementations and optional requirements differ most on the caller side. For example, let’s use NSTableView delegate as it’s imported today:<br>&gt; <br>&gt; func useDelegate(delegate: NSTableViewDelegate) {<br>&gt;   if let getView = delegate.tableView(_:viewFor:row:) { // since the requirement is optional, a reference to the method produces a value of optional function type<br>&gt;     // I can call getView here<br>&gt;   }<br>&gt; <br>&gt;   if let getHeight = delegate.tableView(_:heightOfRow:) {<br>&gt;     // I can call getHeight here<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; With my proposal, we’d have some compiler-synthesized attribute (let’s call it @__caller_default_implementation) that gets places on Objective-C optional requirements when they get imported, e.g.,<br>&gt; <br>&gt; @objc protocol NSTableViewDelegate {<br>&gt;   @__caller_default_implementation func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView?<br>&gt;   @__caller_default_implementation func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat<br>&gt; }<br>&gt; <br>&gt; And “optional” disappears from the language. Now, there’s no optionality left, so our useDelegate example tries to just do correct calls:<br>&gt; <br>&gt; func useDelegate(delegate: NSTableViewDelegate) -&gt; NSView? {<br>&gt;   let view = delegate.tableView(tableView, viewFor: column, row: row)<br>&gt;   let height = delegate.tableView(tableView, heightOfRow: row)<br>&gt; }<br>&gt; <br>&gt; Of course, the code above will fail if the actual delegate doesn’t implement both methods. We need some kind of default implementation to fall back on in that case. I propose that the code above produce a compiler error on both lines *unless* there is a “default implementation” visible. So, to make the code above compile without error, one would have to add:<br>&gt; <br>&gt; extension NSTableViewDelegate {<br>&gt;   @nonobjc func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView? { return nil }<br>&gt;   <br>&gt;   @nonobjc func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat { return 17 }<br>&gt; } <br>&gt; <br>&gt; Now, the useDelegate example compiles. If the actual delegate implements the optional requirement, we’ll use that implementation. Otherwise, the caller will use the default (Swift-only) implementation it sees. From an implementation standpoint, the compiler would effectively produce the following for the first of these calls:<br>&gt; <br>&gt; if delegate.responds(to: #selector(NSTableViewDelegate.tableView(_:viewFor:row:))) {<br>&gt;   // call the @objc instance method with the selector tableView:viewForTableColumn:row:<br>&gt; } else {<br>&gt;   // call the Swift-only implementation of tableView(_:viewFor:row:) in the protocol extension above<br>&gt; }<br>&gt; <br>&gt; There are a number of reasons why I like this approach:<br>&gt; <br>&gt; 1) It eliminates the notion of ‘optional’ requirements from the language. For classes that are adopting the NSTableViewDelegate protocol, it is as if these requirements had default implementations.<br>&gt; <br>&gt; 2) Only the callers to these requirements have to deal with the lack of default implementations. This was already the case for optional requirements, so it’s not an extra burden in principle, and it’s generally going to be easier to write one defaulted implementation than deal with it in several different places. Additionally, most of these callers are probably in the Cocoa frameworks, not application code, so the overall impact should be small.<br>&gt; <br>&gt; Thoughts?<br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>[Idea] How to eliminate &#39;optional&#39; protocol requirements</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>April  9, 2016 at 02:00:00pm</p></header><div class="content"><p>Thanks for the excellent writeup and thought on this.<br></p><p>I strongly believe - as a protocol adaptor - that having the ability to<br>know if a default implementation is provided in the interface I see. It<br>would also be helpful if documentation (header docs) about the<br>characteristics of the default implement would be visible is so provided by<br>author. This wild help guide me in understanding if I need to bother with<br>overriding the default.<br></p><p>I also strongly believe - as a protocol provider - being able to know if an<br>adaptor has overridden the default implementation can be helpful in how I<br>able to implement and optimize my code as well as how I can define my<br>protocol (keeping it clean).<br></p><p>Note multiple default implementation could exist depending on scoping done<br>by where clauses against associated types, right?<br>That adds some complexity to this but it seems like it could be expressed<br>at a minimum via header docs exposed to adopters.<br></p><p>-Shawn<br></p><p>On Fri, Apr 8, 2016 at 11:04 PM Dietmar Planitzer via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; The biggest missing part with this model is that we are still not able to<br>&gt; enable macro-level optimizations in the delegating type by checking whether<br>&gt; the delegate does provide his own implementation of an optional method or<br>&gt; doesn’t. However, this is an important advantage of the ObjC model that we<br>&gt; should not lose.<br>&gt;<br>&gt; Maybe it’s time to take a big step back and ignore the question of how to<br>&gt; implement things for a moment and to instead focus on the question of what<br>&gt; the conceptual differences are between ObjC protocols with optional methods<br>&gt; and Swift protocols with default implementations. There are two relevant<br>&gt; viewpoints here:<br>&gt;<br>&gt; 1) From the viewpoint of a protocol adaptor:<br>&gt;<br>&gt; ObjC:<br>&gt;<br>&gt; 1a) adopter may provide his own implementation of the protocol method, but<br>&gt; he is no required to.<br>&gt;<br>&gt; 1b) adopter can see in the protocol declaration for which methods he must<br>&gt; provide an implementation. Those methods do not have the “optional” keyword<br>&gt; in front of them while optional methods do.<br>&gt;<br>&gt; Swift:<br>&gt;<br>&gt; 1c) same as (1a).<br>&gt;<br>&gt; 1d) opening a binary-only Swift file in Xcode with a protocol definition<br>&gt; in it which contains methods with default implementations will not give any<br>&gt; indication of which method has a default implementation and which doesn’t.<br>&gt; It’s only possible to see a difference on the syntax level if you have<br>&gt; access to the sources.<br>&gt;<br>&gt; So from the viewpoint of the protocol adopter, there isn’t much of a<br>&gt; difference. The only relevant difference is that its always possible in<br>&gt; ObjC to tell whether a protocol method must be implemented by the adopter<br>&gt; or whether a method already has a default behavior. We shouldn’t actually<br>&gt; have to change anything on the syntax-level in Swift to fix this problem.<br>&gt; It should be sufficient to improve the Swift interface generator in Xcode<br>&gt; so that it gives an indication whether a protocol method has a default<br>&gt; implementation or doesn’t. Eg if we want to ensure that the generated<br>&gt; interface is valid syntax then we could do this:<br>&gt;<br>&gt; protocol Foo {<br>&gt;<br>&gt;    func void bar() -&gt; Int  /* has default */<br>&gt;<br>&gt; }<br>&gt;<br>&gt; or if we say that it is fine that the generated interface is not valid<br>&gt; syntax (I think it already shows &quot;= default” for function arguments with a<br>&gt; default value which I don’t think is valid syntax), then we could do this:<br>&gt;<br>&gt; protocol Foo {<br>&gt;<br>&gt;    func void bar() -&gt; Int {…}<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Now on to the other side of the equation.<br>&gt;<br>&gt; 2) From the viewpoint of the protocol provider (the person who defines the<br>&gt; protocol and the type that will invoke the protocol methods):<br>&gt;<br>&gt; ObjC:<br>&gt;<br>&gt; 2a) provider has freedom in deciding where to put the default<br>&gt; implementation and he can put the default implementation in a single place<br>&gt; or spread it out if necessary over multiple places. So has the freedom to<br>&gt; choose whatever makes the most sense for the problem at hand.<br>&gt;<br>&gt; 2b) provider can detect whether the adopter provides his own protocol<br>&gt; method implementation without compromising the definition of the protocol<br>&gt; (compromising here means making return values optional when they should not<br>&gt; be optional based on the natural definition of the API). This enables the<br>&gt; provider to implement macro-level optimizations (eg table view can<br>&gt; understand whether fixed or variable row heights are desired).<br>&gt;<br>&gt; Swift:<br>&gt;<br>&gt; 2c) provider is forced to put the default implementation in a specific<br>&gt; place.<br>&gt;<br>&gt; 2d) provider has no way to detect whether the adopter has provided his own<br>&gt; implementation of the protocol method.<br>&gt;<br>&gt;<br>&gt; I do think that (2a) would be nice to have but we can probably do without<br>&gt; it if it helps us to make progress with this topic. However, the ability to<br>&gt; detect whether a protocol adopter provides his own implementation of a<br>&gt; protocol method which comes with a default is a useful and important<br>&gt; feature which helps us in optimizing the implementation of types and which<br>&gt; allows us to keep the API surface smaller than it would be without this<br>&gt; ability. Just go and compare eg UITableView to the Android ListView /<br>&gt; RecyclerView to see the consequences of not having that ability and how it<br>&gt; inflates the API surface (and keep in mind that the Android equivalents<br>&gt; provide a fraction of the UITableView functionality).<br>&gt;<br>&gt; The important point about (2b) is actually that we are able to detect<br>&gt; whether an “override” (I’ll just call this overriding for now) of the<br>&gt; default implementation exists or does not exist. In ObjC we make this<br>&gt; distinction by checking whether an implementation of the method exists at<br>&gt; all. But we don’t have to do it that way. An alternative approach could be<br>&gt; based on a check that sees whether the dispatch table of the delegate<br>&gt; contains a pointer to the default implementation of the protocol method or<br>&gt; to some other method. So conceptually what we want is an operation like<br>&gt; this:<br>&gt;<br>&gt; func void useDelegate(delegate: NSTableViewDelegate) {<br>&gt;<br>&gt;    if has_override(delegate, tableView(_:, heightOfRow:)) {<br>&gt;       // ask the delegate how many rows it has<br>&gt;       // allocate the geometry cache<br>&gt;       // fill in the geometry cache by calling tableView(_:,<br>&gt; heightForRow:) for each row<br>&gt;    } else {<br>&gt;       // nothing to do here<br>&gt;    }<br>&gt; }<br>&gt;<br>&gt; Which would get the job done but doesn’t look good. Maybe someone has a<br>&gt; better idea of how the syntax such an operator could look.<br>&gt;<br>&gt; So my point here is that what we care about is the ability to detect<br>&gt; whether the adopter provides an implementation of a protocol method which<br>&gt; comes with a default implementation. The point is not that Swift protocols<br>&gt; should work the exact same way that ObjC protocols have been working under<br>&gt; the hood. But I do think that we want to eventually get to a point where<br>&gt; the @objc attribute disappears and that we get a truly unified language on<br>&gt; the syntactical level. An approach where:<br>&gt;<br>&gt; I) we accept that the default behavior of a protocol method has to be<br>&gt; provided by the protocol itself<br>&gt;<br>&gt; II) the language is extended with a mechanism that makes it possible for a<br>&gt; protocol provider to detect whether the adopter has “overridden” the<br>&gt; default implementation<br>&gt;<br>&gt; III) we improve the Xcode Swift interface generator so that it gives a<br>&gt; clear indication whether a protocol method does come with a default<br>&gt; implementation<br>&gt;<br>&gt; would give us all the relevant advantages of ObjC-style optional protocol<br>&gt; methods and it should allow us to create a unified syntax where there is no<br>&gt; longer a visible difference between an optional protocol method that was<br>&gt; imported from ObjC and a native Swift protocol with default implementations.<br>&gt;<br>&gt;<br>&gt; Regards,<br>&gt;<br>&gt; Dietmar Planitzer<br>&gt;<br>&gt;<br>&gt; &gt; On Apr 7, 2016, at 17:12, Douglas Gregor via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Hi all,<br>&gt; &gt;<br>&gt; &gt; Optional protocol requirements in Swift have the restriction that they<br>&gt; only work in @objc protocols, a topic that’s come up a number of times. The<br>&gt; start of these threads imply that optional requirements should be available<br>&gt; for all protocols in Swift. While this direction is implementable, each<br>&gt; time this is discussed there is significant feedback that optional<br>&gt; requirements are not a feature we want in Swift. They overlap almost<br>&gt; completely with default implementations of protocol requirements, which is<br>&gt; a more general feature, and people seem to feel that designs based around<br>&gt; default implementations and refactoring of protocol hierarchies are overall<br>&gt; better.<br>&gt; &gt;<br>&gt; &gt; The main concern with removing optional requirements from Swift is their<br>&gt; impact on Cocoa: Objective-C protocols, especially for delegates and data<br>&gt; sources, make heavy use of optional requirements. Moreover, there are no<br>&gt; default implementations for any of these optional requirements: each caller<br>&gt; effectively checks for the presence of the method explicitly, and<br>&gt; implements its own logic if the method isn’t there.<br>&gt; &gt;<br>&gt; &gt; A Non-Workable Solution: Import as optional property requirements<br>&gt; &gt; One suggestion that’s come up to map an optional requirement to a<br>&gt; property with optional type, were “nil” indicates that the requirement was<br>&gt; not satisfied. For example,<br>&gt; &gt;<br>&gt; &gt; @protocol NSTableViewDelegate<br>&gt; &gt; @optional<br>&gt; &gt; - (nullable NSView *)tableView:(NSTableView *)tableView<br>&gt; viewForTableColumn:(NSTableColumn *)tableColumn row:(NSInteger)row;<br>&gt; &gt; - (CGFloat)tableView:(NSTableView *)tableView heightOfRow:(NSInteger)row;<br>&gt; &gt; @end<br>&gt; &gt;<br>&gt; &gt; currently comes in as<br>&gt; &gt;<br>&gt; &gt; @objc protocol NSTableViewDelegate {<br>&gt; &gt;   optional func tableView(_: NSTableView, viewFor: NSTableColumn, row:<br>&gt; Int) -&gt; NSView?<br>&gt; &gt;   optional func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; would come in as:<br>&gt; &gt;<br>&gt; &gt; @objc protocol NSTableViewDelegate {<br>&gt; &gt;   var tableView: ((NSTableView, viewFor: NSTableColumn, row: Int) -&gt;<br>&gt; NSView?)? { get }<br>&gt; &gt;   var tableView: ((NSTableView, heightOfRow: Int) -&gt; CGFloat)? { get }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; with a default implementation of “nil” for each. However, this isn’t<br>&gt; practical for a number of reasons:<br>&gt; &gt;<br>&gt; &gt; a) We would end up overloading the property name “tableView” a couple<br>&gt; dozen times, which doesn’t actually work.<br>&gt; &gt;<br>&gt; &gt; b) You can no longer refer to the member with a compound name, e.g.,<br>&gt; “delegate.tableView(_:viewFor:row:)” no longer works, because the name of<br>&gt; the property is “tableView”.<br>&gt; &gt;<br>&gt; &gt; c) Implementers of the protocol now need to provide a read-only property<br>&gt; that returns a closure. So instead of<br>&gt; &gt;<br>&gt; &gt; class MyDelegate : NSTableViewDelegate {<br>&gt; &gt;   func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int) -&gt;<br>&gt; NSView? { … }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; one would have to write something like<br>&gt; &gt;<br>&gt; &gt; class MyDelegate : NSTableViewDelegate {<br>&gt; &gt;   var tableView: ((NSTableView, viewFor: NSTableColumn, row: Int) -&gt;<br>&gt; NSView?)? = {<br>&gt; &gt;     … except you can’t refer to self in here unless you make it lazy ...<br>&gt; &gt;   }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; d) We’ve seriously considered eliminating argument labels on function<br>&gt; types, because they’re a complexity in the type system that doesn’t serve<br>&gt; much of a purpose.<br>&gt; &gt;<br>&gt; &gt; One could perhaps work around (a), (b), and (d) by allowing compound<br>&gt; (function-like) names like tableView(_:viewFor:row:) for properties, and<br>&gt; work around (c) by allowing a method to satisfy the requirement for a<br>&gt; read-only property, but at this point you’ve invented more language hacks<br>&gt; than the existing @objc-only optional requirements. So, I don’t think there<br>&gt; is a solution here.<br>&gt; &gt;<br>&gt; &gt; Proposed Solution: Caller-side default implementations<br>&gt; &gt;<br>&gt; &gt; Default implementations and optional requirements differ most on the<br>&gt; caller side. For example, let’s use NSTableView delegate as it’s imported<br>&gt; today:<br>&gt; &gt;<br>&gt; &gt; func useDelegate(delegate: NSTableViewDelegate) {<br>&gt; &gt;   if let getView = delegate.tableView(_:viewFor:row:) { // since the<br>&gt; requirement is optional, a reference to the method produces a value of<br>&gt; optional function type<br>&gt; &gt;     // I can call getView here<br>&gt; &gt;   }<br>&gt; &gt;<br>&gt; &gt;   if let getHeight = delegate.tableView(_:heightOfRow:) {<br>&gt; &gt;     // I can call getHeight here<br>&gt; &gt;   }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; With my proposal, we’d have some compiler-synthesized attribute (let’s<br>&gt; call it @__caller_default_implementation) that gets places on Objective-C<br>&gt; optional requirements when they get imported, e.g.,<br>&gt; &gt;<br>&gt; &gt; @objc protocol NSTableViewDelegate {<br>&gt; &gt;   @__caller_default_implementation func tableView(_: NSTableView,<br>&gt; viewFor: NSTableColumn, row: Int) -&gt; NSView?<br>&gt; &gt;   @__caller_default_implementation func tableView(_: NSTableView,<br>&gt; heightOfRow: Int) -&gt; CGFloat<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; And “optional” disappears from the language. Now, there’s no optionality<br>&gt; left, so our useDelegate example tries to just do correct calls:<br>&gt; &gt;<br>&gt; &gt; func useDelegate(delegate: NSTableViewDelegate) -&gt; NSView? {<br>&gt; &gt;   let view = delegate.tableView(tableView, viewFor: column, row: row)<br>&gt; &gt;   let height = delegate.tableView(tableView, heightOfRow: row)<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; Of course, the code above will fail if the actual delegate doesn’t<br>&gt; implement both methods. We need some kind of default implementation to fall<br>&gt; back on in that case. I propose that the code above produce a compiler<br>&gt; error on both lines *unless* there is a “default implementation” visible.<br>&gt; So, to make the code above compile without error, one would have to add:<br>&gt; &gt;<br>&gt; &gt; extension NSTableViewDelegate {<br>&gt; &gt;   @nonobjc func tableView(_: NSTableView, viewFor: NSTableColumn, row:<br>&gt; Int) -&gt; NSView? { return nil }<br>&gt; &gt;<br>&gt; &gt;   @nonobjc func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat {<br>&gt; return 17 }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; Now, the useDelegate example compiles. If the actual delegate implements<br>&gt; the optional requirement, we’ll use that implementation. Otherwise, the<br>&gt; caller will use the default (Swift-only) implementation it sees. From an<br>&gt; implementation standpoint, the compiler would effectively produce the<br>&gt; following for the first of these calls:<br>&gt; &gt;<br>&gt; &gt; if delegate.responds(to:<br>&gt; #selector(NSTableViewDelegate.tableView(_:viewFor:row:))) {<br>&gt; &gt;   // call the @objc instance method with the selector<br>&gt; tableView:viewForTableColumn:row:<br>&gt; &gt; } else {<br>&gt; &gt;   // call the Swift-only implementation of tableView(_:viewFor:row:) in<br>&gt; the protocol extension above<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; There are a number of reasons why I like this approach:<br>&gt; &gt;<br>&gt; &gt; 1) It eliminates the notion of ‘optional’ requirements from the<br>&gt; language. For classes that are adopting the NSTableViewDelegate protocol,<br>&gt; it is as if these requirements had default implementations.<br>&gt; &gt;<br>&gt; &gt; 2) Only the callers to these requirements have to deal with the lack of<br>&gt; default implementations. This was already the case for optional<br>&gt; requirements, so it’s not an extra burden in principle, and it’s generally<br>&gt; going to be easier to write one defaulted implementation than deal with it<br>&gt; in several different places. Additionally, most of these callers are<br>&gt; probably in the Cocoa frameworks, not application code, so the overall<br>&gt; impact should be small.<br>&gt; &gt;<br>&gt; &gt; Thoughts?<br>&gt; &gt;<br>&gt; &gt;       - Doug<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160409/5a6876ff/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Idea] How to eliminate &#39;optional&#39; protocol requirements</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April 11, 2016 at 02:00:00am</p></header><div class="content"><p>&gt; And “optional” disappears from the language. Now, there’s no optionality left, so our useDelegate example tries to just do correct calls:<br>&gt; <br>&gt; func useDelegate(delegate: NSTableViewDelegate) -&gt; NSView? {<br>&gt;   let view = delegate.tableView(tableView, viewFor: column, row: row)<br>&gt;   let height = delegate.tableView(tableView, heightOfRow: row)<br>&gt; }<br>&gt; <br>&gt; Of course, the code above will fail if the actual delegate doesn’t implement both methods. We need some kind of default implementation to fall back on in that case. I propose that the code above produce a compiler error on both lines *unless* there is a “default implementation” visible. So, to make the code above compile without error, one would have to add:<br>&gt; <br>&gt; extension NSTableViewDelegate {<br>&gt;   @nonobjc func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView? { return nil }<br>&gt;   <br>&gt;   @nonobjc func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat { return 17 }<br>&gt; } <br></p><p>Okay, but NSTableViewDelegate is being imported from Objective-C. Suppose it doesn&#39;t ship with an extension that provides default values. What then? Are you unable to import AppKit? Do you have to write the extension yourself? (Even if you don&#39;t need it?)<br></p><p>And if you want to implement the exact semantics of `NSTableView`, including the fact that a table view whose delegate does not implement `tableView(_:heightOfRow:)` uses a fast path, what do you do?<br></p><p>* * *<br></p><p>Personally, I&#39;m coming around to permitting optional methods in all types. Consider, for instance, WKWebView, which has a couple pairs like this:<br></p><p>	var canGoForward: Bool { get }<br>	func goForward()<br></p><p>You shouldn&#39;t be calling `goForward()` except on a WKWebView which `canGoForward`. So why are these pieces of information not conveyed together? Wouldn&#39;t it be better if WKWebView simply offered:<br></p><p>	optional func goForward()<br></p><p>And you couldn&#39;t call `goForward()` without checking or asserting that you&#39;re allowed to go forward at the moment?<br></p><p>Obviously that would require that you be able to *change* whether a given method was permitted or not based on circumstances. That would be a substantial expansion of the current `optional` feature, and overall, the whole thing simply doesn&#39;t seem important enough to prioritize.<br></p><p>But fundamentally, I don&#39;t think there&#39;s anything less coherent about saying &quot;this member may not always exist&quot; with an optional member than there is about saying &quot;this property&#39;s value may not always exist&quot; with an Optional value. &quot;Subtypes may or may not support this thing, but if they do, this is what it&#39;ll look like&quot; is a perfectly sensible thing to want from a type.<br></p><p>(Although we&#39;ll need to find a different name than &quot;optional&quot;, that&#39;s for sure.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Idea] How to eliminate &#39;optional&#39; protocol requirements</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>April 11, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Apr 7, 2016, at 5:12 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; One could perhaps work around (a), (b), and (d) by allowing compound (function-like) names like tableView(_:viewFor:row:) for properties, and work around (c) by allowing a method to satisfy the requirement for a read-only property, but at this point you’ve invented more language hacks than the existing @objc-only optional requirements. So, I don’t think there is a solution here.<br></p><p>To me, compound names for closure properties and satisfying property requirements with methods aren&#39;t hacks, they&#39;re missing features we ought to support anyway. I strongly prefer implementing those over your proposed solution. It sounds to me like a lot of people using optional protocol requirements *want* the locality of control flow visible in the caller, for optimization or other purposes, and your proposed solution makes this incredibly obscure and magical.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Idea] How to eliminate &#39;optional&#39; protocol requirements</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>April 11, 2016 at 12:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Apr 11, 2016, at 12:15 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 7, 2016, at 5:12 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; One could perhaps work around (a), (b), and (d) by allowing compound (function-like) names like tableView(_:viewFor:row:) for properties, and work around (c) by allowing a method to satisfy the requirement for a read-only property, but at this point you’ve invented more language hacks than the existing @objc-only optional requirements. So, I don’t think there is a solution here.<br>&gt; <br>&gt; To me, compound names for closure properties and satisfying property requirements with methods aren&#39;t hacks, they&#39;re missing features we ought to support anyway. I strongly prefer implementing those over your proposed solution. It sounds to me like a lot of people using optional protocol requirements *want* the locality of control flow visible in the caller, for optimization or other purposes, and your proposed solution makes this incredibly obscure and magical.<br></p><p>Do you have the same thought for optional closure properties?  If so and heightForRow was an optional closure property it would satisfy all use cases elegantly.  It could have a default implementation that returns nil.  When non-uniform heights are required a normal method implementation can be provided.  Delegates that have uniform row heights some of the time, but not all of the time, would also be supported by implementing the property.<br></p><p>If we decide to favor this approach it would be really nice to be able to import Cocoa delegate protocols this way.  Is that something that might be feasible?<br></p><p>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Idea] How to eliminate &#39;optional&#39; protocol requirements</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>April 13, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Apr 11, 2016, at 10:30 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt;&gt; On Apr 11, 2016, at 12:15 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Apr 7, 2016, at 5:12 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One could perhaps work around (a), (b), and (d) by allowing compound (function-like) names like tableView(_:viewFor:row:) for properties, and work around (c) by allowing a method to satisfy the requirement for a read-only property, but at this point you’ve invented more language hacks than the existing @objc-only optional requirements. So, I don’t think there is a solution here.<br>&gt;&gt; <br>&gt;&gt; To me, compound names for closure properties and satisfying property requirements with methods aren&#39;t hacks, they&#39;re missing features we ought to support anyway. I strongly prefer implementing those over your proposed solution. It sounds to me like a lot of people using optional protocol requirements *want* the locality of control flow visible in the caller, for optimization or other purposes, and your proposed solution makes this incredibly obscure and magical.<br>&gt; <br>&gt; Do you have the same thought for optional closure properties?  If so and heightForRow was an optional closure property it would satisfy all use cases elegantly.  It could have a default implementation that returns nil.  When non-uniform heights are required a normal method implementation can be provided.  Delegates that have uniform row heights some of the time, but not all of the time, would also be supported by implementing the property.<br></p><p>There are still some issues here:<br></p><p>1) It doesn’t handle optional read/write properties at all, because the setter signature would be different. Perhaps some future lens design would make this possible. For now, the workaround would have to be importing the setter as a second optional closure property, I guess. (The current system is similarly broken).<br></p><p>2) For an @objc protocol, you won’t actually be able to fully implement the optional closure property with a property of optional type, because “return nil” in the getter is not the same as “-respondsToSelector: returns false”. Indeed, the getter result type/setter parameter type should be non-optional, so we would (at best) need a special rule that optional closure properties of @objc protocols can only be implemented by non-optional properties of closure type or by methods.<br></p><p>&gt; If we decide to favor this approach it would be really nice to be able to import Cocoa delegate protocols this way.  Is that something that might be feasible?<br></p><p><br>Yes. If we favor this approach, it should be fairly direct to make imported Objective-C protocols work this way.<br></p><p>	- Doug<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>[Idea] How to eliminate &#39;optional&#39; protocol requirements</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>April 13, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Apr 11, 2016, at 12:15 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; To me, compound names for closure properties and satisfying property requirements with methods aren&#39;t hacks, they&#39;re missing features we ought to support anyway.<br></p><p>Hello,<br></p><p>I may have missed the point, but it looks like you say that optional delegate methods could be replaced by closures.<br></p><p>If this is the case, then I recently faced an issue with closures as a replacement for optional delegate methods, and the issue was with the responsibility of weak reference of the delegate.<br></p><p>So instead of:<br>	<br>	protocol CDelegate : class { func f() }<br>	class C {<br>		weak var delegate: CDelegate?<br>		func doIt() {<br>			delegate?.f()<br>		}<br>	}<br></p><p>We’d have:<br></p><p>	class C {<br>		var f: (() -&gt; ())?<br>		func doIt() {<br>			f?()<br>		}<br>	}<br></p><p>Is it what you were referring to?<br></p><p>If so, then the trouble is for the code that sets the closure. It has to perform the weak self/strongSelf dance:<br></p><p>	c = C()<br>	c.f = { [weak self] in<br>		guard let strongSelf = self else { return }<br>		strongSelf….<br>	}<br></p><p>I find it awfully awfully heavy. The caller has 1. to remember about weakifying self, and 2. extract strongSelf from the weak self.<br></p><p>Of course, if you were talking about something else, you can discard my comment.<br></p><p>Gwendal Roué<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Idea] How to eliminate &#39;optional&#39; protocol requirements</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>April 15, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Apr 13, 2016, at 11:42 AM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Apr 11, 2016, at 10:30 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt;&gt; On Apr 11, 2016, at 12:15 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Apr 7, 2016, at 5:12 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One could perhaps work around (a), (b), and (d) by allowing compound (function-like) names like tableView(_:viewFor:row:) for properties, and work around (c) by allowing a method to satisfy the requirement for a read-only property, but at this point you’ve invented more language hacks than the existing @objc-only optional requirements. So, I don’t think there is a solution here.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To me, compound names for closure properties and satisfying property requirements with methods aren&#39;t hacks, they&#39;re missing features we ought to support anyway. I strongly prefer implementing those over your proposed solution. It sounds to me like a lot of people using optional protocol requirements *want* the locality of control flow visible in the caller, for optimization or other purposes, and your proposed solution makes this incredibly obscure and magical.<br>&gt;&gt; <br>&gt;&gt; Do you have the same thought for optional closure properties?  If so and heightForRow was an optional closure property it would satisfy all use cases elegantly.  It could have a default implementation that returns nil.  When non-uniform heights are required a normal method implementation can be provided.  Delegates that have uniform row heights some of the time, but not all of the time, would also be supported by implementing the property.<br>&gt; <br>&gt; There are still some issues here:<br>&gt; <br>&gt; 1) It doesn’t handle optional read/write properties at all, because the setter signature would be different. Perhaps some future lens design would make this possible. For now, the workaround would have to be importing the setter as a second optional closure property, I guess. (The current system is similarly broken).<br></p><p>I was only thinking about methods, not properties.  :)  How common are optional, writeable property requirements?  I don’t have a good guess off the top of my head, but my hunch is that they are not that common.  If they aren’t, maybe a workaround would be acceptable (at least until a lens design comes along in the future).<br></p><p>&gt; <br>&gt; 2) For an @objc protocol, you won’t actually be able to fully implement the optional closure property with a property of optional type, because “return nil” in the getter is not the same as “-respondsToSelector: returns false”. Indeed, the getter result type/setter parameter type should be non-optional, so we would (at best) need a special rule that optional closure properties of @objc protocols can only be implemented by non-optional properties of closure type or by methods.<br></p><p>This is related to why I asked about feasibility.  I know that “return nil” is not that same as a “respondsToSelector:” implementation that returns false if the property was implemented to return nil.  Some magic would need to handle that translation to make it work with existing Objective-C protocols.  This would automate what I have done in Objective-C several times by implementing respondsToSelector manually to hide protocol method implementations when necessary.  <br></p><p>The advantage of going this route is that Swift implementations of the legacy Cocoa protocols will still function as expected in Cocoa while fitting the Swift model much better than optional protocol requirements.<br></p><p>&gt; <br>&gt;&gt; If we decide to favor this approach it would be really nice to be able to import Cocoa delegate protocols this way. Is that something that might be feasible?<br>&gt; <br>&gt; <br>&gt; Yes. If we favor this approach, it should be fairly direct to make imported Objective-C protocols work this way.<br>&gt; <br>&gt; 	- Doug<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160415/d76fa8b5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Idea] How to eliminate &#39;optional&#39; protocol requirements</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>April 15, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Apr 15, 2016, at 3:55 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 13, 2016, at 11:42 AM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Apr 11, 2016, at 10:30 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Apr 11, 2016, at 12:15 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Apr 7, 2016, at 5:12 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; One could perhaps work around (a), (b), and (d) by allowing compound (function-like) names like tableView(_:viewFor:row:) for properties, and work around (c) by allowing a method to satisfy the requirement for a read-only property, but at this point you’ve invented more language hacks than the existing @objc-only optional requirements. So, I don’t think there is a solution here.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; To me, compound names for closure properties and satisfying property requirements with methods aren&#39;t hacks, they&#39;re missing features we ought to support anyway. I strongly prefer implementing those over your proposed solution. It sounds to me like a lot of people using optional protocol requirements *want* the locality of control flow visible in the caller, for optimization or other purposes, and your proposed solution makes this incredibly obscure and magical.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Do you have the same thought for optional closure properties?  If so and heightForRow was an optional closure property it would satisfy all use cases elegantly.  It could have a default implementation that returns nil.  When non-uniform heights are required a normal method implementation can be provided.  Delegates that have uniform row heights some of the time, but not all of the time, would also be supported by implementing the property.<br>&gt;&gt; <br>&gt;&gt; There are still some issues here:<br>&gt;&gt; <br>&gt;&gt; 1) It doesn’t handle optional read/write properties at all, because the setter signature would be different. Perhaps some future lens design would make this possible. For now, the workaround would have to be importing the setter as a second optional closure property, I guess. (The current system is similarly broken).<br>&gt; <br>&gt; I was only thinking about methods, not properties.  :)  How common are optional, writeable property requirements?  I don’t have a good guess off the top of my head, but my hunch is that they are not that common.<br></p><p>They are *very* rare. Aside from UITextInputTraits &lt;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UITextInputTraits_Protocol/&gt;, I see three in OS X and four in iOS.<br></p><p>&gt;&gt; 2) For an @objc protocol, you won’t actually be able to fully implement the optional closure property with a property of optional type, because “return nil” in the getter is not the same as “-respondsToSelector: returns false”. Indeed, the getter result type/setter parameter type should be non-optional, so we would (at best) need a special rule that optional closure properties of @objc protocols can only be implemented by non-optional properties of closure type or by methods.<br>&gt; <br>&gt; This is related to why I asked about feasibility.  I know that “return nil” is not that same as a “respondsToSelector:” implementation that returns false if the property was implemented to return nil.  Some magic would need to handle that translation to make it work with existing Objective-C protocols.  This would automate what I have done in Objective-C several times by implementing respondsToSelector manually to hide protocol method implementations when necessary.  <br>&gt; <br>&gt; The advantage of going this route is that Swift implementations of the legacy Cocoa protocols will still function as expected in Cocoa while fitting the Swift model much better than optional protocol requirements.<br></p><p>Both Joe’s suggestion and my proposal need hackery to do the right thing for Objective-C interoperability, and both are feasible. I feel like my proposal is more honest about the hackery going on :)<br></p><p>	- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160415/a7367e72/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Idea] How to eliminate &#39;optional&#39; protocol requirements</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>April 15, 2016 at 06:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Apr 15, 2016, at 6:03 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Apr 15, 2016, at 3:55 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Apr 13, 2016, at 11:42 AM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Apr 11, 2016, at 10:30 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Apr 11, 2016, at 12:15 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Apr 7, 2016, at 5:12 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; One could perhaps work around (a), (b), and (d) by allowing compound (function-like) names like tableView(_:viewFor:row:) for properties, and work around (c) by allowing a method to satisfy the requirement for a read-only property, but at this point you’ve invented more language hacks than the existing @objc-only optional requirements. So, I don’t think there is a solution here.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; To me, compound names for closure properties and satisfying property requirements with methods aren&#39;t hacks, they&#39;re missing features we ought to support anyway. I strongly prefer implementing those over your proposed solution. It sounds to me like a lot of people using optional protocol requirements *want* the locality of control flow visible in the caller, for optimization or other purposes, and your proposed solution makes this incredibly obscure and magical.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Do you have the same thought for optional closure properties?  If so and heightForRow was an optional closure property it would satisfy all use cases elegantly.  It could have a default implementation that returns nil.  When non-uniform heights are required a normal method implementation can be provided.  Delegates that have uniform row heights some of the time, but not all of the time, would also be supported by implementing the property.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are still some issues here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1) It doesn’t handle optional read/write properties at all, because the setter signature would be different. Perhaps some future lens design would make this possible. For now, the workaround would have to be importing the setter as a second optional closure property, I guess. (The current system is similarly broken).<br>&gt;&gt; <br>&gt;&gt; I was only thinking about methods, not properties.  :)  How common are optional, writeable property requirements?  I don’t have a good guess off the top of my head, but my hunch is that they are not that common.<br>&gt; <br>&gt; They are *very* rare. Aside from UITextInputTraits, I see three in OS X and four in iOS.<br>&gt; <br>&gt;&gt;&gt; 2) For an @objc protocol, you won’t actually be able to fully implement the optional closure property with a property of optional type, because “return nil” in the getter is not the same as “-respondsToSelector: returns false”. Indeed, the getter result type/setter parameter type should be non-optional, so we would (at best) need a special rule that optional closure properties of @objc protocols can only be implemented by non-optional properties of closure type or by methods.<br>&gt;&gt; <br>&gt;&gt; This is related to why I asked about feasibility.  I know that “return nil” is not that same as a “respondsToSelector:” implementation that returns false if the property was implemented to return nil.  Some magic would need to handle that translation to make it work with existing Objective-C protocols.  This would automate what I have done in Objective-C several times by implementing respondsToSelector manually to hide protocol method implementations when necessary.  <br>&gt;&gt; <br>&gt;&gt; The advantage of going this route is that Swift implementations of the legacy Cocoa protocols will still function as expected in Cocoa while fitting the Swift model much better than optional protocol requirements.<br>&gt; <br>&gt; Both Joe’s suggestion and my proposal need hackery to do the right thing for Objective-C interoperability, and both are feasible. I feel like my proposal is more honest about the hackery going on :)<br></p><p>Hmm.  I agree that it&#39;s a little bit of hackers, but I don&#39;t think it&#39;s really dishonest to translate &quot;return nil&quot; into &quot;respondsToSelector:&quot; false and more than it is to make any other mapping from one system to another.  <br></p><p>The main reason I prefer that approach is that it enables functionality that has been occasionally useful in Objective-C and is not otherwise possible in Swift - namely the ability to implement the protocol in a general purpose class and make a decision at initialization time whether you need a particular feature (such as dynamic row sizing) or not.  Your approach doesn&#39;t allow for this.<br></p><p>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160415/6061981c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Idea] How to eliminate &#39;optional&#39; protocol requirements</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>April 15, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Apr 15, 2016, at 4:15 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On Apr 15, 2016, at 6:03 PM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Apr 15, 2016, at 3:55 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Apr 13, 2016, at 11:42 AM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Apr 11, 2016, at 10:30 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Apr 11, 2016, at 12:15 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Apr 7, 2016, at 5:12 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; One could perhaps work around (a), (b), and (d) by allowing compound (function-like) names like tableView(_:viewFor:row:) for properties, and work around (c) by allowing a method to satisfy the requirement for a read-only property, but at this point you’ve invented more language hacks than the existing @objc-only optional requirements. So, I don’t think there is a solution here.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; To me, compound names for closure properties and satisfying property requirements with methods aren&#39;t hacks, they&#39;re missing features we ought to support anyway. I strongly prefer implementing those over your proposed solution. It sounds to me like a lot of people using optional protocol requirements *want* the locality of control flow visible in the caller, for optimization or other purposes, and your proposed solution makes this incredibly obscure and magical.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Do you have the same thought for optional closure properties?  If so and heightForRow was an optional closure property it would satisfy all use cases elegantly.  It could have a default implementation that returns nil.  When non-uniform heights are required a normal method implementation can be provided.  Delegates that have uniform row heights some of the time, but not all of the time, would also be supported by implementing the property.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There are still some issues here:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1) It doesn’t handle optional read/write properties at all, because the setter signature would be different. Perhaps some future lens design would make this possible. For now, the workaround would have to be importing the setter as a second optional closure property, I guess. (The current system is similarly broken).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I was only thinking about methods, not properties.  :)  How common are optional, writeable property requirements?  I don’t have a good guess off the top of my head, but my hunch is that they are not that common.<br>&gt;&gt; <br>&gt;&gt; They are *very* rare. Aside from UITextInputTraits &lt;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UITextInputTraits_Protocol/&gt;, I see three in OS X and four in iOS.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; 2) For an @objc protocol, you won’t actually be able to fully implement the optional closure property with a property of optional type, because “return nil” in the getter is not the same as “-respondsToSelector: returns false”. Indeed, the getter result type/setter parameter type should be non-optional, so we would (at best) need a special rule that optional closure properties of @objc protocols can only be implemented by non-optional properties of closure type or by methods.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is related to why I asked about feasibility.  I know that “return nil” is not that same as a “respondsToSelector:” implementation that returns false if the property was implemented to return nil.  Some magic would need to handle that translation to make it work with existing Objective-C protocols.  This would automate what I have done in Objective-C several times by implementing respondsToSelector manually to hide protocol method implementations when necessary.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The advantage of going this route is that Swift implementations of the legacy Cocoa protocols will still function as expected in Cocoa while fitting the Swift model much better than optional protocol requirements.<br>&gt;&gt; <br>&gt;&gt; Both Joe’s suggestion and my proposal need hackery to do the right thing for Objective-C interoperability, and both are feasible. I feel like my proposal is more honest about the hackery going on :)<br>&gt; <br>&gt; Hmm.  I agree that it&#39;s a little bit of hackers, but I don&#39;t think it&#39;s really dishonest to translate &quot;return nil&quot; into &quot;respondsToSelector:&quot; false and more than it is to make any other mapping from one system to another.  <br>&gt; <br>&gt; The main reason I prefer that approach is that it enables functionality that has been occasionally useful in Objective-C and is not otherwise possible in Swift - namely the ability to implement the protocol in a general purpose class and make a decision at initialization time whether you need a particular feature (such as dynamic row sizing) or not.  Your approach doesn&#39;t allow for this.<br></p><p>My approach requires you to use a different design—either split into multiple protocols (which is probably the best answer in most of these cases) or introduce a different kind of API contract. My claim is that these solutions are more natural in Swift than “check if a particular requirement was actually implemented”.<br></p><p>	- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160415/b268f38f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Idea] How to eliminate &#39;optional&#39; protocol requirements</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>April 15, 2016 at 06:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Apr 15, 2016, at 6:17 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 15, 2016, at 4:15 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt;&gt; On Apr 15, 2016, at 6:03 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Apr 15, 2016, at 3:55 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Apr 13, 2016, at 11:42 AM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Apr 11, 2016, at 10:30 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Apr 11, 2016, at 12:15 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Apr 7, 2016, at 5:12 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; One could perhaps work around (a), (b), and (d) by allowing compound (function-like) names like tableView(_:viewFor:row:) for properties, and work around (c) by allowing a method to satisfy the requirement for a read-only property, but at this point you’ve invented more language hacks than the existing @objc-only optional requirements. So, I don’t think there is a solution here.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; To me, compound names for closure properties and satisfying property requirements with methods aren&#39;t hacks, they&#39;re missing features we ought to support anyway. I strongly prefer implementing those over your proposed solution. It sounds to me like a lot of people using optional protocol requirements *want* the locality of control flow visible in the caller, for optimization or other purposes, and your proposed solution makes this incredibly obscure and magical.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Do you have the same thought for optional closure properties?  If so and heightForRow was an optional closure property it would satisfy all use cases elegantly.  It could have a default implementation that returns nil.  When non-uniform heights are required a normal method implementation can be provided.  Delegates that have uniform row heights some of the time, but not all of the time, would also be supported by implementing the property.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There are still some issues here:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 1) It doesn’t handle optional read/write properties at all, because the setter signature would be different. Perhaps some future lens design would make this possible. For now, the workaround would have to be importing the setter as a second optional closure property, I guess. (The current system is similarly broken).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I was only thinking about methods, not properties.  :)  How common are optional, writeable property requirements?  I don’t have a good guess off the top of my head, but my hunch is that they are not that common.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; They are *very* rare. Aside from UITextInputTraits, I see three in OS X and four in iOS.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2) For an @objc protocol, you won’t actually be able to fully implement the optional closure property with a property of optional type, because “return nil” in the getter is not the same as “-respondsToSelector: returns false”. Indeed, the getter result type/setter parameter type should be non-optional, so we would (at best) need a special rule that optional closure properties of @objc protocols can only be implemented by non-optional properties of closure type or by methods.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is related to why I asked about feasibility.  I know that “return nil” is not that same as a “respondsToSelector:” implementation that returns false if the property was implemented to return nil.  Some magic would need to handle that translation to make it work with existing Objective-C protocols.  This would automate what I have done in Objective-C several times by implementing respondsToSelector manually to hide protocol method implementations when necessary.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The advantage of going this route is that Swift implementations of the legacy Cocoa protocols will still function as expected in Cocoa while fitting the Swift model much better than optional protocol requirements.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Both Joe’s suggestion and my proposal need hackery to do the right thing for Objective-C interoperability, and both are feasible. I feel like my proposal is more honest about the hackery going on :)<br>&gt;&gt; <br>&gt;&gt; Hmm.  I agree that it&#39;s a little bit of hackers, but I don&#39;t think it&#39;s really dishonest to translate &quot;return nil&quot; into &quot;respondsToSelector:&quot; false and more than it is to make any other mapping from one system to another.  <br>&gt;&gt; <br>&gt;&gt; The main reason I prefer that approach is that it enables functionality that has been occasionally useful in Objective-C and is not otherwise possible in Swift - namely the ability to implement the protocol in a general purpose class and make a decision at initialization time whether you need a particular feature (such as dynamic row sizing) or not.  Your approach doesn&#39;t allow for this.<br>&gt; <br>&gt; My approach requires you to use a different design—either split into multiple protocols (which is probably the best answer in most of these cases) or introduce a different kind of API contract. My claim is that these solutions are more natural in Swift than “check if a particular requirement was actually implemented”.<br></p><p>I completely agree with you.  However, unless Apple plans to do that with all of their frameworks over the next couple years it is not enough.  We want Swift to play nice with the frameworks as they exist today, don&#39;t we?<br></p><p>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160415/1a0573de/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Idea] How to eliminate &#39;optional&#39; protocol requirements</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>April 15, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Apr 15, 2016, at 4:27 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On Apr 15, 2016, at 6:17 PM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Apr 15, 2016, at 4:15 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Apr 15, 2016, at 6:03 PM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Apr 15, 2016, at 3:55 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Apr 13, 2016, at 11:42 AM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Apr 11, 2016, at 10:30 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Apr 11, 2016, at 12:15 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Apr 7, 2016, at 5:12 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; One could perhaps work around (a), (b), and (d) by allowing compound (function-like) names like tableView(_:viewFor:row:) for properties, and work around (c) by allowing a method to satisfy the requirement for a read-only property, but at this point you’ve invented more language hacks than the existing @objc-only optional requirements. So, I don’t think there is a solution here.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To me, compound names for closure properties and satisfying property requirements with methods aren&#39;t hacks, they&#39;re missing features we ought to support anyway. I strongly prefer implementing those over your proposed solution. It sounds to me like a lot of people using optional protocol requirements *want* the locality of control flow visible in the caller, for optimization or other purposes, and your proposed solution makes this incredibly obscure and magical.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Do you have the same thought for optional closure properties?  If so and heightForRow was an optional closure property it would satisfy all use cases elegantly.  It could have a default implementation that returns nil.  When non-uniform heights are required a normal method implementation can be provided.  Delegates that have uniform row heights some of the time, but not all of the time, would also be supported by implementing the property.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; There are still some issues here:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 1) It doesn’t handle optional read/write properties at all, because the setter signature would be different. Perhaps some future lens design would make this possible. For now, the workaround would have to be importing the setter as a second optional closure property, I guess. (The current system is similarly broken).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I was only thinking about methods, not properties.  :)  How common are optional, writeable property requirements?  I don’t have a good guess off the top of my head, but my hunch is that they are not that common. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; They are *very* rare. Aside from UITextInputTraits &lt;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UITextInputTraits_Protocol/&gt;, I see three in OS X and four in iOS.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 2) For an @objc protocol, you won’t actually be able to fully implement the optional closure property with a property of optional type, because “return nil” in the getter is not the same as “-respondsToSelector: returns false”. Indeed, the getter result type/setter parameter type should be non-optional, so we would (at best) need a special rule that optional closure properties of @objc protocols can only be implemented by non-optional properties of closure type or by methods.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This is related to why I asked about feasibility.  I know that “return nil” is not that same as a “respondsToSelector:” implementation that returns false if the property was implemented to return nil.  Some magic would need to handle that translation to make it work with existing Objective-C protocols.  This would automate what I have done in Objective-C several times by implementing respondsToSelector manually to hide protocol method implementations when necessary.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The advantage of going this route is that Swift implementations of the legacy Cocoa protocols will still function as expected in Cocoa while fitting the Swift model much better than optional protocol requirements.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Both Joe’s suggestion and my proposal need hackery to do the right thing for Objective-C interoperability, and both are feasible. I feel like my proposal is more honest about the hackery going on :)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hmm.  I agree that it&#39;s a little bit of hackers, but I don&#39;t think it&#39;s really dishonest to translate &quot;return nil&quot; into &quot;respondsToSelector:&quot; false and more than it is to make any other mapping from one system to another.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The main reason I prefer that approach is that it enables functionality that has been occasionally useful in Objective-C and is not otherwise possible in Swift - namely the ability to implement the protocol in a general purpose class and make a decision at initialization time whether you need a particular feature (such as dynamic row sizing) or not.  Your approach doesn&#39;t allow for this.<br>&gt;&gt; <br>&gt;&gt; My approach requires you to use a different design—either split into multiple protocols (which is probably the best answer in most of these cases) or introduce a different kind of API contract. My claim is that these solutions are more natural in Swift than “check if a particular requirement was actually implemented”.<br>&gt; <br>&gt; I completely agree with you.  However, unless Apple plans to do that with all of their frameworks over the next couple years it is not enough.  We want Swift to play nice with the frameworks as they exist today, don&#39;t we?<br></p><p>That’s the other part of my argument: if it is true that Swift code only needs to conform to ObjC protocols with optional requirements, but Swift code does not need to invoke optional requirements of ObjC protocols except very rarely, then it’s okay for calling-an-optional-requirement not to be part of the Swift language.<br></p><p>	- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160415/d8953a65/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Idea] How to eliminate &#39;optional&#39; protocol requirements</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April 15, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; That’s the other part of my argument: if it is true that Swift code only needs to conform to ObjC protocols with optional requirements, but Swift code does not need to invoke optional requirements of ObjC protocols except very rarely, then it’s okay for calling-an-optional-requirement not to be part of the Swift language.<br></p><p>How much of a complication is the `methodName?` behavior? If you&#39;re confident that `optional` is the wrong choice for protocols designed in the future, perhaps you could just make it impossible to declare a new optional requirement in Swift, but leave the calling behavior as-is?<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Idea] How to eliminate &#39;optional&#39; protocol requirements</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>April 18, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Apr 15, 2016, at 5:24 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; That’s the other part of my argument: if it is true that Swift code only needs to conform to ObjC protocols with optional requirements, but Swift code does not need to invoke optional requirements of ObjC protocols except very rarely, then it’s okay for calling-an-optional-requirement not to be part of the Swift language.<br>&gt; <br>&gt; How much of a complication is the `methodName?` behavior?<br></p><p>It’s a semi-complicated path through the type checker, but it’s not awful to maintain. There’s a bit of a “fix it or remove it” issue here, because it doesn’t work for settable properties, even though there are very few such things. <br></p><p>&gt; If you&#39;re confident that `optional` is the wrong choice for protocols designed in the future, perhaps you could just make it impossible to declare a new optional requirement in Swift, but leave the calling behavior as-is?<br></p><p>Sure, we can make it arbitrarily hard to use. For example, calling it @objc_optional or similar would reinforce that it’s an Objective-C compatibility feature rather than an intended Swift feature.<br></p><p>	- Doug<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Idea] How to eliminate &#39;optional&#39; protocol requirements</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>April 15, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Apr 15, 2016, at 4:03 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; Both Joe’s suggestion and my proposal need hackery to do the right thing for Objective-C interoperability, and both are feasible. I feel like my proposal is more honest about the hackery going on :)<br></p><p>Since there&#39;s a hack involved more or less any way you slice it, the most honest way to admit to the hackery might be to keep the status quo, but just demote &quot;optional&quot; to an &quot;@objcOptional&quot; attribute or something similar that keeps the current behavior.<br></p><p>-Joe<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[Idea] How to eliminate &#39;optional&#39; protocol requirements</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>April 11, 2016 at 11:00:00am</p></header><div class="content"><p>I think we have the following asks:<br>- support methods on a protocol that may or may not be implemented by a confirming type<br>- support statically (per type) detection of whether one of these methods have been implemented so that you can have consistent behavior while interacting with a particular type<br>- static methods may or may not be attractive to implement via additional subtype protocol conformance (depending on how many independent optional methods exist)<br>- support dynamically (based on internal logic and state) support a particular method, for instance with UI event dispatching<br>- Ability to determine if a method is available on a type outside of calling it to detect default functionality<br>- compatibility (where appropriate) with existing objc protocols with optional methods<br></p><p>Obviously, optional as it exists today only solves some of these asks. Some of these may not deserve to be (or be suitably improved upon by being) language features. Some of these are possible today in a form through Objective C interop, but this are not available on other platforms<br></p><p>-DW<br></p><p><br>Sent with my Thumbs<br></p><p>&gt; On Apr 11, 2016, at 11:15 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 7, 2016, at 5:12 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; One could perhaps work around (a), (b), and (d) by allowing compound (function-like) names like tableView(_:viewFor:row:) for properties, and work around (c) by allowing a method to satisfy the requirement for a read-only property, but at this point you’ve invented more language hacks than the existing @objc-only optional requirements. So, I don’t think there is a solution here.<br>&gt; <br>&gt; To me, compound names for closure properties and satisfying property requirements with methods aren&#39;t hacks, they&#39;re missing features we ought to support anyway. I strongly prefer implementing those over your proposed solution. It sounds to me like a lot of people using optional protocol requirements *want* the locality of control flow visible in the caller, for optimization or other purposes, and your proposed solution makes this incredibly obscure and magical.<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Idea] How to eliminate &#39;optional&#39; protocol requirements</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>April 12, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Apr 11, 2016, at 10:15 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 7, 2016, at 5:12 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; One could perhaps work around (a), (b), and (d) by allowing compound (function-like) names like tableView(_:viewFor:row:) for properties, and work around (c) by allowing a method to satisfy the requirement for a read-only property, but at this point you’ve invented more language hacks than the existing @objc-only optional requirements. So, I don’t think there is a solution here.<br>&gt; <br>&gt; To me, compound names for closure properties and satisfying property requirements with methods aren&#39;t hacks, they&#39;re missing features we ought to support anyway. I strongly prefer implementing those over your proposed solution.<br></p><p>I haven’t seen these come up in any discussion that wasn’t about mapping Objective-C optional requirements to something else in Swift. What other use cases are you envisioning?<br></p><p>&gt;  It sounds to me like a lot of people using optional protocol requirements *want* the locality of control flow visible in the caller, for optimization or other purposes,<br></p><p>Most of the requests I see for this feature are of the form “this works for @objc protocols, so it should work everywhere,” and most of the push-back I’ve seen against removing ‘optional’ is a concern over interaction with Cocoa. I haven’t gotten the sense that optional requirements are considered to be the best design for any particular task in Swift.<br></p><p>&gt; and your proposed solution makes this incredibly obscure and magical.<br></p><p><br>That’s fair. The mechanism I’m talking about *is* a bit hard to explain—we would need to rely on the diagnostic for cases where one tries to call a method that is caller-defaulted from Swift code, e.g.,<br></p><p>	error: method ‘foo(bar:wibble:)’ may not be implemented by the adopting class; add a default implementation via an extension to protocol ‘Foo&#39;<br></p><p>This would only affect optional requirements of protocols imported from Objective-C. My hypothesis is that those just aren’t used in Swift app code.<br></p><p>	- Doug<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Idea] How to eliminate &#39;optional&#39; protocol requirements</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>April 13, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Apr 12, 2016, at 11:24 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 11, 2016, at 10:15 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Apr 7, 2016, at 5:12 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One could perhaps work around (a), (b), and (d) by allowing compound (function-like) names like tableView(_:viewFor:row:) for properties, and work around (c) by allowing a method to satisfy the requirement for a read-only property, but at this point you’ve invented more language hacks than the existing @objc-only optional requirements. So, I don’t think there is a solution here.<br>&gt;&gt; <br>&gt;&gt; To me, compound names for closure properties and satisfying property requirements with methods aren&#39;t hacks, they&#39;re missing features we ought to support anyway. I strongly prefer implementing those over your proposed solution.<br>&gt; <br>&gt; I haven’t seen these come up in any discussion that wasn’t about mapping Objective-C optional requirements to something else in Swift. What other use cases are you envisioning?<br></p><p>The desire for labeled closure variables has come up a few times. For instance, it would provide a way to give local label names to closure arguments. In C, you can say:<br></p><p>	void doStuff(void (*onCompletion)(void *result, void *error)) {<br>		if (auto x = /*doStuff*/) {<br>			onCompletion(/*result*/ x, /*error*/ nullptr);<br>		} else {<br>			onCompletion(/*result*/ nullptr, /*error*/ getLastError());<br>		}<br>		onCompletion(/*result*/ x, /*error*/ y);<br>	}<br></p><p>where `result` and `error` don&#39;t affect the type, but describe the use of the parameters to the completion closure. It&#39;d be nice to do the same in Swift:<br></p><p>	func doStuff(onCompletion completed(result:error:): (AnyObject?, AnyObject?) -&gt; ()) {<br>		/*doStuff*/<br>		completed(result: x, error: nil)<br>	}<br></p><p>There&#39;s also the case of using if let to test for presence of a method, where you&#39;d really like to keep the labels on the local binding:<br></p><p>	if let doStuff(to:with:) = object.doStuff(to:with:) {<br>		...<br>	}<br></p><p>We currently lean on the vestige of labeled-tuples-as-function-arguments to do this, but I think we ultimately want to get away from that.<br></p><p>-Joe<br></p><p>&gt;&gt; It sounds to me like a lot of people using optional protocol requirements *want* the locality of control flow visible in the caller, for optimization or other purposes,<br>&gt; <br>&gt; Most of the requests I see for this feature are of the form “this works for @objc protocols, so it should work everywhere,” and most of the push-back I’ve seen against removing ‘optional’ is a concern over interaction with Cocoa. I haven’t gotten the sense that optional requirements are considered to be the best design for any particular task in Swift.<br>&gt; <br>&gt;&gt; and your proposed solution makes this incredibly obscure and magical.<br>&gt; <br>&gt; <br>&gt; That’s fair. The mechanism I’m talking about *is* a bit hard to explain—we would need to rely on the diagnostic for cases where one tries to call a method that is caller-defaulted from Swift code, e.g.,<br>&gt; <br>&gt; 	error: method ‘foo(bar:wibble:)’ may not be implemented by the adopting class; add a default implementation via an extension to protocol ‘Foo&#39;<br>&gt; <br>&gt; This would only affect optional requirements of protocols imported from Objective-C. My hypothesis is that those just aren’t used in Swift app code.<br>&gt; <br>&gt; 	- Doug<br>&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
