<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0fc40f95a5c6b063df44b3bc136d764b?s=50"></div><header><strong>[Pre-proposal] Standard Protocol for Bitwise Shifts and Binary-based Integers</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.com&gt;<p>January 18, 2016 at 12:00:00pm</p></header><div class="content"><p>So I recently discovered that the shift operators no longer appear to be defined anywhere, i.e- they seem to only be implemented by convention rather than being required by a protocol, which doesn’t seem ideal. The problem with this is that I wanted to implement some bitwise operations but there’s no longer an obvious place to do this, and I ended up having to implement my own concept of a BitwiseIntegerType, as you can see in the example below:<br></p><p>protocol BitwiseIntegerType : BitwiseOperationsType, IntegerType {<br>    init(_ value:Int)<br>    init(_ value:UInt)<br></p><p>    func &lt;&lt; (lhs:Self, rhs:Self) -&gt; Self<br>    func &gt;&gt; (lhs:Self, rhs:Self) -&gt; Self<br>    func &lt;&lt;= (inout lhs:Self, rhs:Self)<br>    func &gt;&gt;= (inout lhs:Self, rhs:Self)<br>}<br></p><p>extension BitwiseIntegerType {<br>    static var allOnes:Self { return ~Self.allZeros }<br>    static var numberOfBits:UInt { return UInt(sizeof(Self) * 8) }<br></p><p>    static var mostSignificantBit:Self { return Self.allOnes &lt;&lt; Self(Self.numberOfBits - 1) }<br></p><p>    var leadingZeros:UInt {<br>        if self == Self.allZeros { return Self.numberOfBits }<br></p><p>        var value = self<br>        var width = Self.numberOfBits<br>        var mask = Self.allOnes<br>        var zeros:UInt = 0<br></p><p>        while (value &amp; Self.mostSignificantBit) == Self.allZeros {<br>            if (value &amp; mask) == Self.allZeros {<br>                zeros += width<br>                value &lt;&lt;= Self(width)<br>            } else {<br>                width /= 2<br>                mask &lt;&lt;= Self(width)<br>            }<br>        }<br></p><p>        return zeros<br>    }<br>}<br></p><p>extension Int : BitwiseIntegerType {}<br>extension Int8 : BitwiseIntegerType {}<br>extension Int16 : BitwiseIntegerType {}<br>extension Int32 : BitwiseIntegerType {}<br>extension Int64 : BitwiseIntegerType {}<br></p><p>extension UInt : BitwiseIntegerType {}<br>extension UInt8 : BitwiseIntegerType {}<br>extension UInt16 : BitwiseIntegerType {}<br>extension UInt32 : BitwiseIntegerType {}<br>extension UInt64 : BitwiseIntegerType {}<br></p><p>Int64.mostSignificantBit    // -9223372036854775808<br>1234567.leadingZeros        // 43<br></p><p>I think that the best solution would be to add the shift operators to BitwiseOperationsType, while declaring a BitwiseIntegerType similar to what I’ve done above that groups BitwiseOperationsType with IntegerType to create a distinction between binary-based integers and integers that could be based on some other mechanism in future, as well as to declare the required initializers from Int and UInt types. This gives more flexibility in defining higher level protocol extensions that rely on the full range of bitwise operations, without having to move any of it further up (iirc some of these operators used to be in IntegerType).<br></p><p>Either way, the shift operators are currently declared by convention, which I don’t think is right, as they should surely be declared as a requirement somewhere.<br></p><p>Also, ignore the actual implementation of leadingZeros, it may not be the most efficient method, it’s just a useful illustration of something that can be done with the protocol declarations, I’ve also omitted warnings and such to keep things simple.<br></p><p>Just wondering what others think? One other issue I’m unsure about is that the required Int and Uint initialiizers should probably be of the truncatingBitPattern type for bitwise operations, but I wasn’t sure how to handle adding that to the types that don’t currently have these initializers (i.e- the 64-bit types that don’t need them since they can’t currently be initialized from anything bigger).<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160118/3e38485b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>[Pre-proposal] Standard Protocol for Bitwise Shifts and Binary-based Integers</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>January 18, 2016 at 10:00:00am</p></header><div class="content"><p>I saw it mentioned somewhere that the standard library team wants to allow<br>smaller types to be used, like &lt;&lt;(lhs: UInt64, rhs: UInt8). I&#39;m not sure<br>exactly how that would fit in here.<br></p><p>On Mon, Jan 18, 2016 at 4:45 AM, Haravikk via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; So I recently discovered that the shift operators no longer appear to be<br>&gt; defined anywhere, i.e- they seem to only be implemented by convention<br>&gt; rather than being required by a protocol, which doesn’t seem ideal. The<br>&gt; problem with this is that I wanted to implement some bitwise operations but<br>&gt; there’s no longer an obvious place to do this, and I ended up having to<br>&gt; implement my own concept of a BitwiseIntegerType, as you can see in the<br>&gt; example below:<br>&gt;<br>&gt; protocol BitwiseIntegerType : BitwiseOperationsType, IntegerType {<br>&gt;     init(_ value:Int)<br>&gt;     init(_ value:UInt)<br>&gt;<br>&gt;     func &lt;&lt; (lhs:Self, rhs:Self) -&gt; Self<br>&gt;     func &gt;&gt; (lhs:Self, rhs:Self) -&gt; Self<br>&gt;     func &lt;&lt;= (inout lhs:Self, rhs:Self)<br>&gt;     func &gt;&gt;= (inout lhs:Self, rhs:Self)<br>&gt; }<br>&gt;<br>&gt; extension BitwiseIntegerType {<br>&gt;     static var allOnes:Self { return ~Self.allZeros }<br>&gt;     static var numberOfBits:UInt { return UInt(sizeof(Self) * 8) }<br>&gt;<br>&gt;     static var mostSignificantBit:Self { return Self.allOnes &lt;&lt; Self(Self.numberOfBits<br>&gt; - 1) }<br>&gt;<br>&gt;     var leadingZeros:UInt {<br>&gt;         if self == Self.allZeros { return Self.numberOfBits }<br>&gt;<br>&gt;         var value = self<br>&gt;         var width = Self.numberOfBits<br>&gt;         var mask = Self.allOnes<br>&gt;         var zeros:UInt = 0<br>&gt;<br>&gt;         while (value &amp; Self.mostSignificantBit) == Self.allZeros {<br>&gt;             if (value &amp; mask) == Self.allZeros {<br>&gt;                 zeros += width<br>&gt;                 value &lt;&lt;= Self(width)<br>&gt;             } else {<br>&gt;                 width /= 2<br>&gt;                 mask &lt;&lt;= Self(width)<br>&gt;             }<br>&gt;         }<br>&gt;<br>&gt;         return zeros<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; extension Int : BitwiseIntegerType {}<br>&gt; extension Int8 : BitwiseIntegerType {}<br>&gt; extension Int16 : BitwiseIntegerType {}<br>&gt; extension Int32 : BitwiseIntegerType {}<br>&gt; extension Int64 : BitwiseIntegerType {}<br>&gt;<br>&gt; extension UInt : BitwiseIntegerType {}<br>&gt; extension UInt8 : BitwiseIntegerType {}<br>&gt; extension UInt16 : BitwiseIntegerType {}<br>&gt; extension UInt32 : BitwiseIntegerType {}<br>&gt; extension UInt64 : BitwiseIntegerType {}<br>&gt;<br>&gt; Int64.mostSignificantBit    // -9223372036854775808<br>&gt; 1234567.leadingZeros        // 43<br>&gt;<br>&gt; I think that the best solution would be to add the shift operators to<br>&gt; BitwiseOperationsType, while declaring a BitwiseIntegerType similar to what<br>&gt; I’ve done above that groups BitwiseOperationsType with IntegerType to<br>&gt; create a distinction between binary-based integers and integers that could<br>&gt; be based on some other mechanism in future, as well as to declare the<br>&gt; required initializers from Int and UInt types. This gives more flexibility<br>&gt; in defining higher level protocol extensions that rely on the full range of<br>&gt; bitwise operations, without having to move any of it further up (iirc some<br>&gt; of these operators used to be in IntegerType).<br>&gt;<br>&gt; Either way, the shift operators are currently declared by convention,<br>&gt; which I don’t think is right, as they should surely be declared as a<br>&gt; requirement somewhere.<br>&gt;<br>&gt; Also, ignore the actual implementation of leadingZeros, it may not be the<br>&gt; most efficient method, it’s just a useful illustration of something that<br>&gt; can be done with the protocol declarations, I’ve also omitted warnings and<br>&gt; such to keep things simple.<br>&gt;<br>&gt; Just wondering what others think? One other issue I’m unsure about is that<br>&gt; the required Int and Uint initialiizers should probably be of the<br>&gt; truncatingBitPattern type for bitwise operations, but I wasn’t sure how to<br>&gt; handle adding that to the types that don’t currently have these<br>&gt; initializers (i.e- the 64-bit types that don’t need them since they can’t<br>&gt; currently be initialized from anything bigger).<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160118/064b0146/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0fc40f95a5c6b063df44b3bc136d764b?s=50"></div><header><strong>[Pre-proposal] Standard Protocol for Bitwise Shifts and Binary-based Integers</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.com&gt;<p>January 18, 2016 at 07:00:00pm</p></header><div class="content"><p>Hmm. Well, Int is fairly common, and encompasses more than we’re ever likely to need for shifts, so it may make sense to use Self &lt;&lt; Int as the baseline for the shifts. As for supporting smaller types, I’m not sure how it could be done in the protocol as a specific requirement unless it was something like:<br></p><p>protocol BitwiseIntegerType : BitwiseOperationsType, IntegerType {<br>    ...<br>    func &lt;&lt; (lhs:Self, rhs:SignedIntegerType) -&gt; Self<br>    func &lt;&lt; (lhs:Self, rhs:UnsignedIntegerType) -&gt; Self<br>}<br></p><p>Since those types can be easily converted to the maximum supported size and then processed accordingly, but that seems much the same as requiring a right-hand-side of Self to me, except that it requires two variations per operator.<br></p><p>I posted another discussion around simplifying casting of integers, specifically allowing implicit casts of any integer type so long as the type you’re casting to has a larger range; in other words, anywhere you can put an Int32 you could put an Int16, Int8, UInt16 or UInt8, but not a UInt32 or anything larger, as these could potentially lose information so should have a warning as normal (forcing the developer to do something explicitly).<br></p><p>Handling of integers is definitely tricky!<br></p><p>&gt; On 18 Jan 2016, at 18:11, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt; <br>&gt; I saw it mentioned somewhere that the standard library team wants to allow smaller types to be used, like &lt;&lt;(lhs: UInt64, rhs: UInt8). I&#39;m not sure exactly how that would fit in here.<br>&gt; <br>&gt; On Mon, Jan 18, 2016 at 4:45 AM, Haravikk via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; So I recently discovered that the shift operators no longer appear to be defined anywhere, i.e- they seem to only be implemented by convention rather than being required by a protocol, which doesn’t seem ideal. The problem with this is that I wanted to implement some bitwise operations but there’s no longer an obvious place to do this, and I ended up having to implement my own concept of a BitwiseIntegerType, as you can see in the example below:<br>&gt; <br>&gt; protocol BitwiseIntegerType : BitwiseOperationsType, IntegerType {<br>&gt;     init(_ value:Int)<br>&gt;     init(_ value:UInt)<br>&gt; <br>&gt;     func &lt;&lt; (lhs:Self, rhs:Self) -&gt; Self<br>&gt;     func &gt;&gt; (lhs:Self, rhs:Self) -&gt; Self<br>&gt;     func &lt;&lt;= (inout lhs:Self, rhs:Self)<br>&gt;     func &gt;&gt;= (inout lhs:Self, rhs:Self)<br>&gt; }<br>&gt; <br>&gt; extension BitwiseIntegerType {<br>&gt;     static var allOnes:Self { return ~Self.allZeros }<br>&gt;     static var numberOfBits:UInt { return UInt(sizeof(Self) * 8) }<br>&gt; <br>&gt;     static var mostSignificantBit:Self { return Self.allOnes &lt;&lt; Self(Self.numberOfBits - 1) }<br>&gt; <br>&gt;     var leadingZeros:UInt {<br>&gt;         if self == Self.allZeros { return Self.numberOfBits }<br>&gt; <br>&gt;         var value = self<br>&gt;         var width = Self.numberOfBits<br>&gt;         var mask = Self.allOnes<br>&gt;         var zeros:UInt = 0<br>&gt; <br>&gt;         while (value &amp; Self.mostSignificantBit) == Self.allZeros {<br>&gt;             if (value &amp; mask) == Self.allZeros {<br>&gt;                 zeros += width<br>&gt;                 value &lt;&lt;= Self(width)<br>&gt;             } else {<br>&gt;                 width /= 2<br>&gt;                 mask &lt;&lt;= Self(width)<br>&gt;             }<br>&gt;         }<br>&gt; <br>&gt;         return zeros<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; extension Int : BitwiseIntegerType {}<br>&gt; extension Int8 : BitwiseIntegerType {}<br>&gt; extension Int16 : BitwiseIntegerType {}<br>&gt; extension Int32 : BitwiseIntegerType {}<br>&gt; extension Int64 : BitwiseIntegerType {}<br>&gt; <br>&gt; extension UInt : BitwiseIntegerType {}<br>&gt; extension UInt8 : BitwiseIntegerType {}<br>&gt; extension UInt16 : BitwiseIntegerType {}<br>&gt; extension UInt32 : BitwiseIntegerType {}<br>&gt; extension UInt64 : BitwiseIntegerType {}<br>&gt; <br>&gt; Int64.mostSignificantBit    // -9223372036854775808<br>&gt; 1234567.leadingZeros        // 43<br>&gt; <br>&gt; I think that the best solution would be to add the shift operators to BitwiseOperationsType, while declaring a BitwiseIntegerType similar to what I’ve done above that groups BitwiseOperationsType with IntegerType to create a distinction between binary-based integers and integers that could be based on some other mechanism in future, as well as to declare the required initializers from Int and UInt types. This gives more flexibility in defining higher level protocol extensions that rely on the full range of bitwise operations, without having to move any of it further up (iirc some of these operators used to be in IntegerType).<br>&gt; <br>&gt; Either way, the shift operators are currently declared by convention, which I don’t think is right, as they should surely be declared as a requirement somewhere.<br>&gt; <br>&gt; Also, ignore the actual implementation of leadingZeros, it may not be the most efficient method, it’s just a useful illustration of something that can be done with the protocol declarations, I’ve also omitted warnings and such to keep things simple.<br>&gt; <br>&gt; Just wondering what others think? One other issue I’m unsure about is that the required Int and Uint initialiizers should probably be of the truncatingBitPattern type for bitwise operations, but I wasn’t sure how to handle adding that to the types that don’t currently have these initializers (i.e- the 64-bit types that don’t need them since they can’t currently be initialized from anything bigger).<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160118/8d14e6da/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>[Pre-proposal] Standard Protocol for Bitwise Shifts and Binary-based Integers</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>January 19, 2016 at 10:00:00am</p></header><div class="content"><p>I support this idea. Probably worth mentioning that Dave Abrahams has been<br>working on integers, specifically (<br>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002445.html<br>):<br></p><p>&gt; Related:  I have been working for some time on a rewrite of all the integer types and protocols.  (sic)  Another important goal is to make the *integer protocols actually useful for writing generic code*, instead of what they are today: implementation artifacts used only for code sharing.  As another *litmus test* of the usefulness of the resulting protocols, the plan is to implement BigInt in terms of the generic operations defined on integers, and make BigInt itself conform to those protocols.<br></p><p>I&#39;ve come across this issue making a BigInt library myself, I found that I<br>wanted shift operations in the implementation of my library, but they<br>weren&#39;t on any protocols. I&#39;m hoping it will be necessary to add it to the<br>protocols for the mentioned *litmus test*.<br></p><p>Also (<br>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/003652.html<br>):<br></p><p>&gt; Again I&#39;ll mention that the prototype (sic) I&#39;m already working on to *replace<br>the integer protocols* and types already supports any integer type<br>appearing on the RHS of a *shift operation.*<br></p><p>Looking at the code I can&#39;t find any shift operators in protocols, but I<br>may have missed it. Perhaps we need to check if it&#39;s still in the plan.<br></p><p><br>On Tue, Jan 19, 2016 at 6:47 AM, Haravikk via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hmm. Well, Int is fairly common, and encompasses more than we’re ever<br>&gt; likely to need for shifts, so it may make sense to use Self &lt;&lt; Int as the<br>&gt; baseline for the shifts. As for supporting smaller types, I’m not sure how<br>&gt; it could be done in the protocol as a specific requirement unless it was<br>&gt; something like:<br>&gt;<br>&gt; protocol BitwiseIntegerType : BitwiseOperationsType, IntegerType {<br>&gt;     ...<br>&gt;     func &lt;&lt; (lhs:Self, rhs:SignedIntegerType) -&gt; Self<br>&gt;     func &lt;&lt; (lhs:Self, rhs:UnsignedIntegerType) -&gt; Self<br>&gt; }<br>&gt;<br>&gt; Since those types can be easily converted to the maximum supported size<br>&gt; and then processed accordingly, but that seems much the same as requiring a<br>&gt; right-hand-side of Self to me, except that it requires two variations per<br>&gt; operator.<br>&gt;<br>&gt; I posted another discussion around simplifying casting of integers,<br>&gt; specifically allowing implicit casts of any integer type so long as the<br>&gt; type you’re casting to has a larger range; in other words, anywhere you can<br>&gt; put an Int32 you could put an Int16, Int8, UInt16 or UInt8, but not a<br>&gt; UInt32 or anything larger, as these could potentially lose information so<br>&gt; should have a warning as normal (forcing the developer to do something<br>&gt; explicitly).<br>&gt;<br>&gt; Handling of integers is definitely tricky!<br>&gt;<br>&gt; On 18 Jan 2016, at 18:11, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt;<br>&gt; I saw it mentioned somewhere that the standard library team wants to allow<br>&gt; smaller types to be used, like &lt;&lt;(lhs: UInt64, rhs: UInt8). I&#39;m not sure<br>&gt; exactly how that would fit in here.<br>&gt;<br>&gt; On Mon, Jan 18, 2016 at 4:45 AM, Haravikk via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; So I recently discovered that the shift operators no longer appear to be<br>&gt;&gt; defined anywhere, i.e- they seem to only be implemented by convention<br>&gt;&gt; rather than being required by a protocol, which doesn’t seem ideal. The<br>&gt;&gt; problem with this is that I wanted to implement some bitwise operations but<br>&gt;&gt; there’s no longer an obvious place to do this, and I ended up having to<br>&gt;&gt; implement my own concept of a BitwiseIntegerType, as you can see in the<br>&gt;&gt; example below:<br>&gt;&gt;<br>&gt;&gt; protocol BitwiseIntegerType : BitwiseOperationsType, IntegerType {<br>&gt;&gt;     init(_ value:Int)<br>&gt;&gt;     init(_ value:UInt)<br>&gt;&gt;<br>&gt;&gt;     func &lt;&lt; (lhs:Self, rhs:Self) -&gt; Self<br>&gt;&gt;     func &gt;&gt; (lhs:Self, rhs:Self) -&gt; Self<br>&gt;&gt;     func &lt;&lt;= (inout lhs:Self, rhs:Self)<br>&gt;&gt;     func &gt;&gt;= (inout lhs:Self, rhs:Self)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; extension BitwiseIntegerType {<br>&gt;&gt;     static var allOnes:Self { return ~Self.allZeros }<br>&gt;&gt;     static var numberOfBits:UInt { return UInt(sizeof(Self) * 8) }<br>&gt;&gt;<br>&gt;&gt;     static var mostSignificantBit:Self { return Self.allOnes &lt;&lt; Self(Self.numberOfBits<br>&gt;&gt; - 1) }<br>&gt;&gt;<br>&gt;&gt;     var leadingZeros:UInt {<br>&gt;&gt;         if self == Self.allZeros { return Self.numberOfBits }<br>&gt;&gt;<br>&gt;&gt;         var value = self<br>&gt;&gt;         var width = Self.numberOfBits<br>&gt;&gt;         var mask = Self.allOnes<br>&gt;&gt;         var zeros:UInt = 0<br>&gt;&gt;<br>&gt;&gt;         while (value &amp; Self.mostSignificantBit) == Self.allZeros {<br>&gt;&gt;             if (value &amp; mask) == Self.allZeros {<br>&gt;&gt;                 zeros += width<br>&gt;&gt;                 value &lt;&lt;= Self(width)<br>&gt;&gt;             } else {<br>&gt;&gt;                 width /= 2<br>&gt;&gt;                 mask &lt;&lt;= Self(width)<br>&gt;&gt;             }<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt;         return zeros<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; extension Int : BitwiseIntegerType {}<br>&gt;&gt; extension Int8 : BitwiseIntegerType {}<br>&gt;&gt; extension Int16 : BitwiseIntegerType {}<br>&gt;&gt; extension Int32 : BitwiseIntegerType {}<br>&gt;&gt; extension Int64 : BitwiseIntegerType {}<br>&gt;&gt;<br>&gt;&gt; extension UInt : BitwiseIntegerType {}<br>&gt;&gt; extension UInt8 : BitwiseIntegerType {}<br>&gt;&gt; extension UInt16 : BitwiseIntegerType {}<br>&gt;&gt; extension UInt32 : BitwiseIntegerType {}<br>&gt;&gt; extension UInt64 : BitwiseIntegerType {}<br>&gt;&gt;<br>&gt;&gt; Int64.mostSignificantBit    // -9223372036854775808<br>&gt;&gt; 1234567.leadingZeros        // 43<br>&gt;&gt;<br>&gt;&gt; I think that the best solution would be to add the shift operators to<br>&gt;&gt; BitwiseOperationsType, while declaring a BitwiseIntegerType similar to what<br>&gt;&gt; I’ve done above that groups BitwiseOperationsType with IntegerType to<br>&gt;&gt; create a distinction between binary-based integers and integers that could<br>&gt;&gt; be based on some other mechanism in future, as well as to declare the<br>&gt;&gt; required initializers from Int and UInt types. This gives more flexibility<br>&gt;&gt; in defining higher level protocol extensions that rely on the full range of<br>&gt;&gt; bitwise operations, without having to move any of it further up (iirc some<br>&gt;&gt; of these operators used to be in IntegerType).<br>&gt;&gt;<br>&gt;&gt; Either way, the shift operators are currently declared by convention,<br>&gt;&gt; which I don’t think is right, as they should surely be declared as a<br>&gt;&gt; requirement somewhere.<br>&gt;&gt;<br>&gt;&gt; Also, ignore the actual implementation of leadingZeros, it may not be the<br>&gt;&gt; most efficient method, it’s just a useful illustration of something that<br>&gt;&gt; can be done with the protocol declarations, I’ve also omitted warnings and<br>&gt;&gt; such to keep things simple.<br>&gt;&gt;<br>&gt;&gt; Just wondering what others think? One other issue I’m unsure about is<br>&gt;&gt; that the required Int and Uint initialiizers should probably be of the<br>&gt;&gt; truncatingBitPattern type for bitwise operations, but I wasn’t sure how to<br>&gt;&gt; handle adding that to the types that don’t currently have these<br>&gt;&gt; initializers (i.e- the 64-bit types that don’t need them since they can’t<br>&gt;&gt; currently be initialized from anything bigger).<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160119/78acb576/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
