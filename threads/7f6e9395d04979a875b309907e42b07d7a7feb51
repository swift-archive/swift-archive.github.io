<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fbb2eb7db6aecac77ec563869540a874?s=50"></div><header><strong>[Proposal] Add an API to Unmanaged to get the instance it holds &quot;@guaranteed&quot;</strong> from <string>Arnold</string> &lt;aschwaighofer at apple.com&gt;<p>March 14, 2016 at 08:00:00am</p></header><div class="content"><p>Hi,<br></p><p>I would like to propose adding an additional method to the standard library’s ‘Unmanaged’ wrapper to mark values as having a guaranteed lifetime by another reference to it.<br></p><p>Currently, there is no way to opt out of ARC even if we know the lifetime of a value is guaranteed by another reference to it. We can pass around values in the wrapper without incurring reference counting but as soon as we take the instance out of the wrapper we will incur reference counting.<br></p><p>func doSomething(u: Unmanaged&lt;Owned&gt;) {<br>    // Incurs refcount increment before the call and decrement after for self.<br>    u.takeUnretainedValue().doSomeWork()<br></p><p>The addition of this API will allow selectively disabling ARC for the scope of the lifetime of the value returned by this API call.<br></p><p>  func doSomething(u: Unmanaged&lt;Owned&gt;) {<br>    // Incurs refcount increment before the call and decrement after for self<br>    // that can be removed by the compiler based on the assertion made.<br>    u.takeGuaranteedValue().doSomeWork()<br> <br></p><p>Add an API to Unmanaged to get the instance it holds &quot;@guaranteed&quot;<br></p><p>Proposal: SE-0000 Add an API to Unmanaged to get the instance it holds guaranteed &lt;https://github.com/aschwaighofer/swift-evolution/blob/unmanaged_unsafe_guaranteed_proposal/proposals/0000-unsafe-guaranteed.md&gt;<br>Author(s): Arnold Schwaighofer &lt;https://github.com/aschwaighofer&gt;<br>Status: Awaiting Review<br>Review manager: TBD<br> &lt;https://github.com/aschwaighofer/swift-evolution/blob/unmanaged_unsafe_guaranteed_proposal/proposals/0000-unsafe-guaranteed.md#introduction&gt;Introduction<br></p><p>The standard library Unmanged&lt;Instance&gt; struct provides an instance wrapper that does not participate in ARC; it allows the user to make manual retain/release calls and get at the contained instance at balanced/unbalanced retain counts.<br></p><p>This proposal suggests to add another method to Unmanaged that will allow making an assertion about the guaranteed lifetime of the instance returned.<br></p><p>This assertion will help the compiler remove ARC operations.<br></p><p>public struct Unmanaged&lt;Instance : AnyObject&gt; {<br></p><p>  // Get the value of the unmanaged referenced as a managed reference without<br>  // consuming an unbalanced retain of it. Asserts that some other owner<br>  // guarantees the lifetime of the value for the lifetime of the return managed<br>  // reference. You are responsible for making sure that this assertion holds<br>  // true.<br>  //<br>  // NOTE:<br>  // Be aware that storing the returned managed reference in an L-Value extends<br>  // the lifetime this assertion must hold true for by the lifetime of the<br>  // L-Value.<br>  //   var owningReference = Instance()<br>  //   var lValue : Instance<br>  //   withFixedLifetime(owningReference) {<br>  //     lValue = Unmanaged.passUnretained(owningReference).takeGuaranteedValue()<br>  //   }<br>  //   lValue.doSomething() // Bug: owningReference lifetime has ended earlier.<br></p><p>  public func takeGuaranteedValue() -&gt; Instance {<br>    let result = _value<br>    return Builtin.unsafeGuaranteed(result)<br>  }<br>Prototype: link to a prototype implementation &lt;https://github.com/aschwaighofer/swift/tree/unsafe_guaranteed_prototype&gt;<br> &lt;https://github.com/aschwaighofer/swift-evolution/blob/unmanaged_unsafe_guaranteed_proposal/proposals/0000-unsafe-guaranteed.md#motivation&gt;Motivation<br></p><p>A user can often make assertions that an instance is kept alive by another reference to it for the duration of some scope.<br></p><p>Consider the following example:<br></p><p>class Owned {<br>  func doSomeWork() {}<br>}<br></p><p>public class Owner {<br>  var ref: Owned<br></p><p>  init() { ref = Owned() }<br></p><p>  public func doWork() {<br>    doSomething(ref)<br>  }<br></p><p>  func doSomething(o: Owned) {<br>     o.doSomeWork()<br>  }<br>}<br>In this context the lifetime of Owner always exceeds o: Ownee. However, there is currently no way to tell the compiler about such an assertion. We can pass reference counted values in an Unmanged container without incurring reference count changes.<br></p><p>public class Owner {<br></p><p>  public func doWork() {<br>    // No reference count for passing the parameter.<br>    doSomething(Unmanaged.passUnretained(ref))<br>  }<br></p><p>  func doSomething(u: Unmanaged&lt;Owned&gt;) {<br>    // ...<br>  }<br>}<br>We can get at the contained instance by means of takeUnretainedValue() which will return a balanced retained value: the value is returned at +1 for release by the caller. However, when it comes to accessing the contained instance we incur reference counting.<br></p><p>  func doSomething(u: Unmanaged&lt;Owned&gt;) {<br>    // Incurs refcount increment before the call and decrement after for self.<br>    u.takeUnretainedValue().doSomeWork()<br>  }<br>With the proposed API call the user could make the assertion that u&#39;s contained instance&#39;s lifetime is guaranteed by another reference to it.<br></p><p>  func doSomething(u: Unmanaged&lt;Owned&gt;) {<br>    // Incurs refcount increment before the call and decrement after for self<br>    // that can be removed by the compiler based on the assertion made.<br>    u.takeGuaranteedValue().doSomeWork()<br>  }<br>The compiler can easily remove the reference counts marked by this method call with local reasoning.<br></p><p> &lt;https://github.com/aschwaighofer/swift-evolution/blob/unmanaged_unsafe_guaranteed_proposal/proposals/0000-unsafe-guaranteed.md#impact-on-existing-code&gt;Impact on existing code<br></p><p>This is a new API that does not replace an existing method. No existing code should be affected.<br></p><p> &lt;https://github.com/aschwaighofer/swift-evolution/blob/unmanaged_unsafe_guaranteed_proposal/proposals/0000-unsafe-guaranteed.md#alternatives-considered&gt;Alternatives considered<br></p><p>A somewhat related proposal would be to allow for class types to completely opt out of ARC forcing the programmer to perform manual reference counting. The scope of such a proposal would be much bigger making it questionable for Swift 3 inclusion. I believe that the two approaches are complementary and don&#39;t completely supplant each other. This proposal&#39;s approach allows for selectively opting out of ARC while providing a high notational burdon when wide spread over the application (wrapping and unwrapping of Unmanaged). Opting completely out of ARC is an all-in solution, which on the other hand does not have the high notational burden.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160314/7f6eeb51/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Proposal] Add an API to Unmanaged to get the instance it holds &quot;@guaranteed&quot;</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>March 14, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Mar 14, 2016, at 8:00 AM, Arnold Schwaighofer &lt;aschwaighofer at apple.com&gt; wrote:<br>&gt; I would like to propose adding an additional method to the standard library’s ‘Unmanaged’ wrapper to mark values as having a guaranteed lifetime by another reference to it.<br>&gt; <br>&gt; Currently, there is no way to opt out of ARC even if we know the lifetime of a value is guaranteed by another reference to it. We can pass around values in the wrapper without incurring reference counting but as soon as we take the instance out of the wrapper we will incur reference counting.<br>&gt; <br>&gt; func doSomething(u: Unmanaged&lt;Owned&gt;) {<br>&gt;     // Incurs refcount increment before the call and decrement after for self.<br>&gt;     u.takeUnretainedValue().doSomeWork()<br>&gt; <br>&gt; The addition of this API will allow selectively disabling ARC for the scope of the lifetime of the value returned by this API call.<br></p><p>Calling this method makes a semantic guarantee that the returned reference is being kept alive somehow for a certain period of time.  So, the obvious questions here are:<br></p><p>1. What are the bounds of that period of time?<br>2. How can the user actually satisfy this guarantee?<br>3. What happens if they’re wrong?<br></p><p>#1 is totally unclear in your proposal.  Usually we do this sort of scoping thing with a callback, rather than a property, for exactly the reason that it lets us naturally bound the extent of the guarantee.  The library’s implementation of that function would then use some builtin functions to bound how long the guarantee lasts.  If we decide that that’s too awkward to actually use, we could burn this into the language as a custom result convention and invent some language rules for the guaranteed extents of such a result based on how the expression is used; that would permit more APIs to opt in to a +0 guaranteed result, but the language rules would probably be pretty ad hoc.  <br></p><p>#2 is also uncertain.  In ObjC ARC, we have a concept of an “object with precise lifetime semantics”.  (Here, “object” is used in the C/C++ sense of “variable”, not the reference-type-OO sense of “class instance”.)  Globals always have precise lifetime semantics, locals can opt in with an attribute, and members depend on their container.  So one possible answer is to say that the value must be precisely referenced somehow, perhaps by the system.  That does require doing some leg work in the proposal (to import the concept of precise lifetime), the language (to allow locals to be made precise), and and the compiler/optimizer (to honor precise guarantees).<br></p><p>It sounds like the only reasonable answer for #3 is “it’s undefined behavior”.  That argues for putting “unsafe” somewhere in the name, although perhaps that’s already covered by the proposal to rename Unmanaged to UnsafeReference.<br></p><p>John.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160314/54f3f1dc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fbb2eb7db6aecac77ec563869540a874?s=50"></div><header><strong>[Proposal] Add an API to Unmanaged to get the instance it holds &quot;@guaranteed&quot;</strong> from <string>Arnold</string> &lt;aschwaighofer at apple.com&gt;<p>March 14, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Mar 14, 2016, at 11:53 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Mar 14, 2016, at 8:00 AM, Arnold Schwaighofer &lt;aschwaighofer at apple.com&gt; wrote:<br>&gt;&gt; I would like to propose adding an additional method to the standard library’s ‘Unmanaged’ wrapper to mark values as having a guaranteed lifetime by another reference to it.<br>&gt;&gt; <br>&gt;&gt; Currently, there is no way to opt out of ARC even if we know the lifetime of a value is guaranteed by another reference to it. We can pass around values in the wrapper without incurring reference counting but as soon as we take the instance out of the wrapper we will incur reference counting.<br>&gt;&gt; <br>&gt;&gt; func doSomething(u: Unmanaged&lt;Owned&gt;<br>&gt;&gt; ) {<br>&gt;&gt;     <br>&gt;&gt; // Incurs refcount increment before the call and decrement after for self.<br>&gt;&gt; <br>&gt;&gt;     u<br>&gt;&gt; .takeUnretainedValue().doSomeWork()<br>&gt;&gt; <br>&gt;&gt; The addition of this API will allow selectively disabling ARC for the scope of the lifetime of the value returned by this API call.<br>&gt; <br>&gt; Calling this method makes a semantic guarantee that the returned reference is being kept alive somehow for a certain period of time.  So, the obvious questions here are:<br>&gt; <br>&gt; 1. What are the bounds of that period of time?<br></p><p>I mention in the API doc that this is for the duration of lifetime the returned value.<br></p><p>  var x = takeUnretainedValue()<br>  var y = x<br></p><p>In this example this would be for the lifetime for the value in x which extends to the lifetime of y.<br></p><p>I will try to address your comments on needing more precise language here (precise lifetime), i.e for locals we need to fix the lifetime, classes, globals.<br></p><p><br>&gt; 2. How can the user actually satisfy this guarantee?<br></p><p>By “fixing the lifetime” of the value is one way or by relying on lifetime relation ships, see the class example I give. The fact that we are calling a method on &quot;self: Owner&quot; guarantees that the reference in “ref: Ownee” was not ultimately released (Admittedly, this is relying on self being passed @guaranteed). The user must know that nobody will store to “ref” in-between.<br></p><p>Your point is that this needs clear language.<br></p><p>&quot;<br>// Get the value of the unmanaged referenced as a managed reference without<br>// consuming an unbalanced retain of it. Asserts that some other owner <br>// guarantees the lifetime of the value for the lifetime of the return managed<br>// reference. You are responsible for making sure that this assertion holds<br>// true.<br>//<br>// NOTE:<br>// Be aware that storing the returned managed reference in an L-Value extends<br>// the lifetime this assertion must hold true for by the lifetime of the  <br>// L-Value.<br>//   var owningReference = Instance()  <br>//   var lValue : Instance<br>//   withFixedLifetime(owningReference) { <br>//     lValue = Unmanaged.passUnretained(owningReference).takeGuaranteedValue()<br>//   }<br>//   lValue.doSomething() // Bug: owningReference lifetime has ended earlier.<br>&quot;<br></p><p>&gt; 3. What happens if they’re wrong?<br></p><p>Undefined behavior. This is an unsafe extension. Users can shoot themselves in the foot today using Unmanaged by calling release() on it.<br></p><p>&gt; <br>&gt; #1 is totally unclear in your proposal.  Usually we do this sort of scoping thing with a callback, rather than a property, for exactly the reason that it lets us naturally bound the extent of the guarantee.  The library’s implementation of that function would then use some builtin functions to bound how long the guarantee lasts.  If we decide that that’s too awkward to actually use, we could burn this into the language as a custom result convention and invent some language rules for the guaranteed extents of such a result based on how the expression is used; that would permit more APIs to opt in to a +0 guaranteed result, but the language rules would probably be pretty ad hoc.  <br></p><p><br>I am not sure you can bound it this that way. I think we want this assertion to be propagated through l-values.<br></p><p><br>var outlive: Ownee<br>var owningReference: Ownee<br></p><p>withFixedLifetime(owningReference) {<br>  Unamanged.passUnretained(owningReference).withGuaranteedValue {<br>     escape($0, to: &amp;outlive)<br>}<br></p><p>I think we should just define this as undefined behavior.<br>  <br>&gt; <br>&gt; #2 is also uncertain.  In ObjC ARC, we have a concept of an “object with precise lifetime semantics”.  (Here, “object” is used in the C/C++ sense of “variable”, not the reference-type-OO sense of “class instance”.)  Globals always have precise lifetime semantics, locals can opt in with an attribute, and members depend on their container.  So one possible answer is to say that the value must be precisely referenced somehow, perhaps by the system.  That does require doing some leg work in the proposal (to import the concept of precise lifetime), the language (to allow locals to be made precise), and and the compiler/optimizer (to honor precise guarantees).<br></p><p>We have the withFixedLifetime API in the standard library today.<br></p><p>withFixedLifetime(ownningReference) {<br>}<br></p><p>Users can rely on that a stored reference in a class is not ultimately released during a method call on that class instance if they can guaranteed that nobody stores to that reference.<br></p><p>The compiler honor withFixedLifetime today (if not that is a bug).<br></p><p>Your point is that this needs to be made clear.<br></p><p>&gt; <br>&gt; It sounds like the only reasonable answer for #3 is “it’s undefined behavior”.  That argues for putting “unsafe” somewhere in the name, although perhaps that’s already covered by the proposal to rename Unmanaged to UnsafeReference.<br></p><p>I believe, Unmanaged is already unsafe. I have put unsafe in the name of the SIL builtin, I am happy to propagate this to the API call.<br></p><p>&gt; <br>&gt; John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Proposal] Add an API to Unmanaged to get the instance it holds &quot;@guaranteed&quot;</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>March 14, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Mar 14, 2016, at 12:51 PM, Arnold Schwaighofer &lt;aschwaighofer at apple.com&gt; wrote:<br>&gt;&gt; On Mar 14, 2016, at 11:53 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 14, 2016, at 8:00 AM, Arnold Schwaighofer &lt;aschwaighofer at apple.com&gt; wrote:<br>&gt;&gt;&gt; I would like to propose adding an additional method to the standard library’s ‘Unmanaged’ wrapper to mark values as having a guaranteed lifetime by another reference to it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Currently, there is no way to opt out of ARC even if we know the lifetime of a value is guaranteed by another reference to it. We can pass around values in the wrapper without incurring reference counting but as soon as we take the instance out of the wrapper we will incur reference counting.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func doSomething(u: Unmanaged&lt;Owned&gt;<br>&gt;&gt;&gt; ) {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Incurs refcount increment before the call and decrement after for self.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    u<br>&gt;&gt;&gt; .takeUnretainedValue().doSomeWork()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The addition of this API will allow selectively disabling ARC for the scope of the lifetime of the value returned by this API call.<br>&gt;&gt; <br>&gt;&gt; Calling this method makes a semantic guarantee that the returned reference is being kept alive somehow for a certain period of time.  So, the obvious questions here are:<br>&gt;&gt; <br>&gt;&gt; 1. What are the bounds of that period of time?<br>&gt; <br>&gt; I mention in the API doc that this is for the duration of lifetime the returned value.<br>&gt; <br>&gt;  var x = takeUnretainedValue()<br>&gt;  var y = x<br>&gt; <br>&gt; In this example this would be for the lifetime for the value in x which extends to the lifetime of y.<br></p><p>What if I return it or assign it to non-local memory?<br></p><p>I feel like you’re trying to define this by optimizer behavior.  That’s not a workable language rule; programmers are not going to reason about SSA values.<br></p><p>&gt; I will try to address your comments on needing more precise language here (precise lifetime), i.e for locals we need to fix the lifetime, classes, globals.<br>&gt; <br>&gt; <br>&gt;&gt; 2. How can the user actually satisfy this guarantee?<br>&gt; <br>&gt; By “fixing the lifetime” of the value is one way or by relying on lifetime relation ships, see the class example I give. The fact that we are calling a method on &quot;self: Owner&quot; guarantees that the reference in “ref: Ownee” was not ultimately released (Admittedly, this is relying on self being passed @guaranteed). The user must know that nobody will store to “ref” in-between.<br>&gt; <br>&gt; Your point is that this needs clear language.<br>&gt; <br>&gt; &quot;<br>&gt; // Get the value of the unmanaged referenced as a managed reference without<br>&gt; // consuming an unbalanced retain of it. Asserts that some other owner <br>&gt; // guarantees the lifetime of the value for the lifetime of the return managed<br>&gt; // reference. You are responsible for making sure that this assertion holds<br>&gt; // true.<br>&gt; //<br>&gt; // NOTE:<br>&gt; // Be aware that storing the returned managed reference in an L-Value extends<br>&gt; // the lifetime this assertion must hold true for by the lifetime of the  <br>&gt; // L-Value.<br>&gt; //   var owningReference = Instance()  <br>&gt; //   var lValue : Instance<br>&gt; //   withFixedLifetime(owningReference) { <br>&gt; //     lValue = Unmanaged.passUnretained(owningReference).takeGuaranteedValue()<br>&gt; //   }<br>&gt; //   lValue.doSomething() // Bug: owningReference lifetime has ended earlier.<br>&gt; &quot;<br>&gt; <br>&gt;&gt; 3. What happens if they’re wrong?<br>&gt; <br>&gt; Undefined behavior. This is an unsafe extension. Users can shoot themselves in the foot today using Unmanaged by calling release() on it.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; #1 is totally unclear in your proposal.  Usually we do this sort of scoping thing with a callback, rather than a property, for exactly the reason that it lets us naturally bound the extent of the guarantee.  The library’s implementation of that function would then use some builtin functions to bound how long the guarantee lasts.  If we decide that that’s too awkward to actually use, we could burn this into the language as a custom result convention and invent some language rules for the guaranteed extents of such a result based on how the expression is used; that would permit more APIs to opt in to a +0 guaranteed result, but the language rules would probably be pretty ad hoc.  <br>&gt; <br>&gt; <br>&gt; I am not sure you can bound it this that way. I think we want this assertion to be propagated through l-values.<br>&gt; <br>&gt; <br>&gt; var outlive: Ownee<br>&gt; var owningReference: Ownee<br>&gt; <br>&gt; withFixedLifetime(owningReference) {<br>&gt;  Unamanged.passUnretained(owningReference).withGuaranteedValue {<br>&gt;     escape($0, to: &amp;outlive)<br>&gt; }<br>&gt; <br>&gt; I think we should just define this as undefined behavior.<br></p><p>Why?  It doesn’t seem harmful.  It’s just that the guarantee doesn’t apply.<br></p><p>…to be clear, I certainly hope that the intended optimization strategy here isn’t just to unconditionally remove any retains and releases visible within the guaranteed block.  You can still at best remove them in pairs.  The effect on the optimizer here is just that uses that are known to occur within a guaranteed block can be ignored for the purposes of eliminating imprecise retain/release pairs.<br></p><p>&gt;&gt; #2 is also uncertain.  In ObjC ARC, we have a concept of an “object with precise lifetime semantics”.  (Here, “object” is used in the C/C++ sense of “variable”, not the reference-type-OO sense of “class instance”.)  Globals always have precise lifetime semantics, locals can opt in with an attribute, and members depend on their container.  So one possible answer is to say that the value must be precisely referenced somehow, perhaps by the system.  That does require doing some leg work in the proposal (to import the concept of precise lifetime), the language (to allow locals to be made precise), and and the compiler/optimizer (to honor precise guarantees).<br>&gt; <br>&gt; We have the withFixedLifetime API in the standard library today.<br>&gt; <br>&gt; withFixedLifetime(ownningReference) {<br>&gt; }<br>&gt; <br>&gt; Users can rely on that a stored reference in a class is not ultimately released during a method call on that class instance if they can guaranteed that nobody stores to that reference.<br>&gt; <br>&gt; The compiler honor withFixedLifetime today (if not that is a bug).<br>&gt; <br>&gt; Your point is that this needs to be made clear.<br></p><p>Yeah, I think withFixedLifetime is probably not a good enough tool; at the very least, you need to reason about indirect references.  (e.g. if the object is held by an array element or a class property, then the array/instance itself needs to be held precisely, etc.)  It’s probably better for local values than a precise-lifetime attribute on local variables, though, assuming withFixedLifetime works for value types, and assuming it doesn’t actually cause reference-counting traffic itself.<br></p><p>&gt;&gt; It sounds like the only reasonable answer for #3 is “it’s undefined behavior”.  That argues for putting “unsafe” somewhere in the name, although perhaps that’s already covered by the proposal to rename Unmanaged to UnsafeReference.<br>&gt; <br>&gt; I believe, Unmanaged is already unsafe. I have put unsafe in the name of the SIL builtin, I am happy to propagate this to the API call.<br></p><p>Unmanaged is already unsafe.  Like I said, there’s an extant proposal to rename it to something like UnsafeReference.  I was raising this issue to see whether swift-evolution has a sense of whether that’s good enough or whether we should call attention to the additional unsafely of this API.<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fbb2eb7db6aecac77ec563869540a874?s=50"></div><header><strong>[Proposal] Add an API to Unmanaged to get the instance it holds &quot;@guaranteed&quot;</strong> from <string>Arnold</string> &lt;aschwaighofer at apple.com&gt;<p>March 14, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Mar 14, 2016, at 1:29 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Mar 14, 2016, at 12:51 PM, Arnold Schwaighofer &lt;aschwaighofer at apple.com&gt; wrote:<br>&gt;&gt;&gt; On Mar 14, 2016, at 11:53 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mar 14, 2016, at 8:00 AM, Arnold Schwaighofer &lt;aschwaighofer at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; I would like to propose adding an additional method to the standard library’s ‘Unmanaged’ wrapper to mark values as having a guaranteed lifetime by another reference to it.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Currently, there is no way to opt out of ARC even if we know the lifetime of a value is guaranteed by another reference to it. We can pass around values in the wrapper without incurring reference counting but as soon as we take the instance out of the wrapper we will incur reference counting.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func doSomething(u: Unmanaged&lt;Owned&gt;<br>&gt;&gt;&gt;&gt; ) {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // Incurs refcount increment before the call and decrement after for self.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   u<br>&gt;&gt;&gt;&gt; .takeUnretainedValue().doSomeWork()<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The addition of this API will allow selectively disabling ARC for the scope of the lifetime of the value returned by this API call.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Calling this method makes a semantic guarantee that the returned reference is being kept alive somehow for a certain period of time.  So, the obvious questions here are:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. What are the bounds of that period of time?<br>&gt;&gt; <br>&gt;&gt; I mention in the API doc that this is for the duration of lifetime the returned value.<br>&gt;&gt; <br>&gt;&gt; var x = takeUnretainedValue()<br>&gt;&gt; var y = x<br>&gt;&gt; <br>&gt;&gt; In this example this would be for the lifetime for the value in x which extends to the lifetime of y.<br>&gt; <br>&gt; What if I return it or assign it to non-local memory?<br></p><p>See my comment about the l-value.<br></p><p>&gt; <br>&gt; I feel like you’re trying to define this by optimizer behavior.  That’s not a workable language rule; programmers are not going to reason about SSA values.<br></p><p>I did mentioned that this applies to storing the value in an l-value. <br></p><p>But I think you are saying to define this in terms of a “precise lifetime language”. I will try to talk in person to flesh out the language.<br></p><p><br>&gt; <br>&gt;&gt; I will try to address your comments on needing more precise language here (precise lifetime), i.e for locals we need to fix the lifetime, classes, globals.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; 2. How can the user actually satisfy this guarantee?<br>&gt;&gt; <br>&gt;&gt; By “fixing the lifetime” of the value is one way or by relying on lifetime relation ships, see the class example I give. The fact that we are calling a method on &quot;self: Owner&quot; guarantees that the reference in “ref: Ownee” was not ultimately released (Admittedly, this is relying on self being passed @guaranteed). The user must know that nobody will store to “ref” in-between.<br>&gt;&gt; <br>&gt;&gt; Your point is that this needs clear language.<br>&gt;&gt; <br>&gt;&gt; &quot;<br>&gt;&gt; // Get the value of the unmanaged referenced as a managed reference without<br>&gt;&gt; // consuming an unbalanced retain of it. Asserts that some other owner <br>&gt;&gt; // guarantees the lifetime of the value for the lifetime of the return managed<br>&gt;&gt; // reference. You are responsible for making sure that this assertion holds<br>&gt;&gt; // true.<br>&gt;&gt; //<br></p><p><br>Comment about the l-value:<br></p><p><br>&gt;&gt; // NOTE:<br>&gt;&gt; // Be aware that storing the returned managed reference in an L-Value extends<br>&gt;&gt; // the lifetime this assertion must hold true for by the lifetime of the  <br>&gt;&gt; // L-Value.<br>&gt;&gt; //   var owningReference = Instance()  <br>&gt;&gt; //   var lValue : Instance<br>&gt;&gt; //   withFixedLifetime(owningReference) { <br>&gt;&gt; //     lValue = Unmanaged.passUnretained(owningReference).takeGuaranteedValue()<br>&gt;&gt; //   }<br>&gt;&gt; //   lValue.doSomething() // Bug: owningReference lifetime has ended earlier.<br>&gt;&gt; &quot;<br>&gt;&gt; <br>&gt;&gt;&gt; 3. What happens if they’re wrong?<br>&gt;&gt; <br>&gt;&gt; Undefined behavior. This is an unsafe extension. Users can shoot themselves in the foot today using Unmanaged by calling release() on it.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; #1 is totally unclear in your proposal.  Usually we do this sort of scoping thing with a callback, rather than a property, for exactly the reason that it lets us naturally bound the extent of the guarantee.  The library’s implementation of that function would then use some builtin functions to bound how long the guarantee lasts.  If we decide that that’s too awkward to actually use, we could burn this into the language as a custom result convention and invent some language rules for the guaranteed extents of such a result based on how the expression is used; that would permit more APIs to opt in to a +0 guaranteed result, but the language rules would probably be pretty ad hoc.  <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I am not sure you can bound it this that way. I think we want this assertion to be propagated through l-values.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; var outlive: Ownee<br>&gt;&gt; var owningReference: Ownee<br>&gt;&gt; <br>&gt;&gt; withFixedLifetime(owningReference) {<br>&gt;&gt; Unamanged.passUnretained(owningReference).withGuaranteedValue {<br>&gt;&gt;    escape($0, to: &amp;outlive)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I think we should just define this as undefined behavior.<br>&gt; <br>&gt; Why?  It doesn’t seem harmful.  It’s just that the guarantee doesn’t apply.<br></p><p>Yes the guarantee does not apply, the user has escaped “the returned value to an l-value that outlives the “owningReference”.<br>&gt; <br>&gt; …to be clear, I certainly hope that the intended optimization strategy here isn’t just to unconditionally remove any retains and releases visible within the guaranteed block.  You can still at best remove them in pairs.  The effect on the optimizer here is just that uses that are known to occur within a guaranteed block can be ignored for the purposes of eliminating imprecise retain/release pairs.<br></p><p><br>Yes, only paired removal. Just like we can do with @guaranteed parameters today.<br></p><p><br>But imagine the “escape” function has been inlined. The optimizer will see:<br></p><p>Unamanged.passUnretained(owningReference).withGuaranteedValue {<br>   outlive = $0<br>}<br></p><p>This is not different to<br></p><p>Unamanged.passUnretained(owningReference).withGuaranteedValue {<br>   let x = $0<br>   x.doSomething()<br>}<br></p><p>And we want to optimize the latter.<br></p><p>The closure syntax does not add any guarantee.<br></p><p>&gt; <br>&gt;&gt;&gt; #2 is also uncertain.  In ObjC ARC, we have a concept of an “object with precise lifetime semantics”.  (Here, “object” is used in the C/C++ sense of “variable”, not the reference-type-OO sense of “class instance”.)  Globals always have precise lifetime semantics, locals can opt in with an attribute, and members depend on their container.  So one possible answer is to say that the value must be precisely referenced somehow, perhaps by the system. That does require doing some leg work in the proposal (to import the concept of precise lifetime), the language (to allow locals to be made precise), and and the compiler/optimizer (to honor precise guarantees).<br>&gt;&gt; <br>&gt;&gt; We have the withFixedLifetime API in the standard library today.<br>&gt;&gt; <br>&gt;&gt; withFixedLifetime(ownningReference) {<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Users can rely on that a stored reference in a class is not ultimately released during a method call on that class instance if they can guaranteed that nobody stores to that reference.<br>&gt;&gt; <br>&gt;&gt; The compiler honor withFixedLifetime today (if not that is a bug).<br>&gt;&gt; <br>&gt;&gt; Your point is that this needs to be made clear.<br>&gt; <br>&gt; Yeah, I think withFixedLifetime is probably not a good enough tool; at the very least, you need to reason about indirect references.  (e.g. if the object is held by an array element or a class property, then the array/instance itself needs to be held precisely, etc.)  It’s probably better for local values than a precise-lifetime attribute on local variables, though, assuming withFixedLifetime works for value types, and assuming it doesn’t actually cause reference-counting traffic itself.<br></p><p>withFixedLifetime just inserts the SIL builtin fix_lifetime (assuming optimization happens).<br></p><p>fix_lifetime<br>```````````` <br>                                                                   <br></p><p>Acts as a use of a value operand, or of the value in memory referenced by an                                                     <br>address operand. Optimizations may not move operations that would destroy the                                                    <br>value, such as ``release_value``, ``strong_release``, ``copy_addr [take]``, or                                                   <br>``destroy_addr``, past this instruction.<br></p><p><br>This guarantee is strong enough to guarantee the “owningReference” lifetime.<br></p><p>&gt; <br>&gt;&gt;&gt; It sounds like the only reasonable answer for #3 is “it’s undefined behavior”.  That argues for putting “unsafe” somewhere in the name, although perhaps that’s already covered by the proposal to rename Unmanaged to UnsafeReference.<br>&gt;&gt; <br>&gt;&gt; I believe, Unmanaged is already unsafe. I have put unsafe in the name of the SIL builtin, I am happy to propagate this to the API call.<br>&gt; <br>&gt; Unmanaged is already unsafe.  Like I said, there’s an extant proposal to rename it to something like UnsafeReference.  I was raising this issue to see whether swift-evolution has a sense of whether that’s good enough or whether we should call attention to the additional unsafely of this API.<br></p><p>Ok.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fbb2eb7db6aecac77ec563869540a874?s=50"></div><header><strong>[Proposal] Add an API to Unmanaged to get the instance it holds &quot;@guaranteed&quot;</strong> from <string>Arnold</string> &lt;aschwaighofer at apple.com&gt;<p>March 14, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Mar 14, 2016, at 3:08 PM, Arnold Schwaighofer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Mar 14, 2016, at 1:29 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 14, 2016, at 12:51 PM, Arnold Schwaighofer &lt;aschwaighofer at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; On Mar 14, 2016, at 11:53 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Mar 14, 2016, at 8:00 AM, Arnold Schwaighofer &lt;aschwaighofer at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; I would like to propose adding an additional method to the standard library’s ‘Unmanaged’ wrapper to mark values as having a guaranteed lifetime by another reference to it.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Currently, there is no way to opt out of ARC even if we know the lifetime of a value is guaranteed by another reference to it. We can pass around values in the wrapper without incurring reference counting but as soon as we take the instance out of the wrapper we will incur reference counting.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func doSomething(u: Unmanaged&lt;Owned&gt;<br>&gt;&gt;&gt;&gt;&gt; ) {<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // Incurs refcount increment before the call and decrement after for self.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  u<br>&gt;&gt;&gt;&gt;&gt; .takeUnretainedValue().doSomeWork()<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The addition of this API will allow selectively disabling ARC for the scope of the lifetime of the value returned by this API call.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Calling this method makes a semantic guarantee that the returned reference is being kept alive somehow for a certain period of time.  So, the obvious questions here are:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. What are the bounds of that period of time?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I mention in the API doc that this is for the duration of lifetime the returned value.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var x = takeUnretainedValue()<br>&gt;&gt;&gt; var y = x<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In this example this would be for the lifetime for the value in x which extends to the lifetime of y.<br>&gt;&gt; <br>&gt;&gt; What if I return it or assign it to non-local memory?<br>&gt; <br>&gt; See my comment about the l-value.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; I feel like you’re trying to define this by optimizer behavior.  That’s not a workable language rule; programmers are not going to reason about SSA values.<br>&gt; <br>&gt; I did mentioned that this applies to storing the value in an l-value. <br>&gt; <br>&gt; But I think you are saying to define this in terms of a “precise lifetime language”. I will try to talk in person to flesh out the language.<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; I will try to address your comments on needing more precise language here (precise lifetime), i.e for locals we need to fix the lifetime, classes, globals.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2. How can the user actually satisfy this guarantee?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; By “fixing the lifetime” of the value is one way or by relying on lifetime relation ships, see the class example I give. The fact that we are calling a method on &quot;self: Owner&quot; guarantees that the reference in “ref: Ownee” was not ultimately released (Admittedly, this is relying on self being passed @guaranteed). The user must know that nobody will store to “ref” in-between.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Your point is that this needs clear language.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &quot;<br>&gt;&gt;&gt; // Get the value of the unmanaged referenced as a managed reference without<br>&gt;&gt;&gt; // consuming an unbalanced retain of it. Asserts that some other owner <br>&gt;&gt;&gt; // guarantees the lifetime of the value for the lifetime of the return managed<br>&gt;&gt;&gt; // reference. You are responsible for making sure that this assertion holds<br>&gt;&gt;&gt; // true.<br>&gt;&gt;&gt; //<br>&gt; <br>&gt; <br>&gt; Comment about the l-value:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; // NOTE:<br>&gt;&gt;&gt; // Be aware that storing the returned managed reference in an L-Value extends<br>&gt;&gt;&gt; // the lifetime this assertion must hold true for by the lifetime of the  <br>&gt;&gt;&gt; // L-Value.<br>&gt;&gt;&gt; //   var owningReference = Instance()  <br>&gt;&gt;&gt; //   var lValue : Instance<br>&gt;&gt;&gt; //   withFixedLifetime(owningReference) { <br>&gt;&gt;&gt; //     lValue = Unmanaged.passUnretained(owningReference).takeGuaranteedValue()<br>&gt;&gt;&gt; //   }<br>&gt;&gt;&gt; //   lValue.doSomething() // Bug: owningReference lifetime has ended earlier.<br>&gt;&gt;&gt; &quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 3. What happens if they’re wrong?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Undefined behavior. This is an unsafe extension. Users can shoot themselves in the foot today using Unmanaged by calling release() on it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; #1 is totally unclear in your proposal.  Usually we do this sort of scoping thing with a callback, rather than a property, for exactly the reason that it lets us naturally bound the extent of the guarantee.  The library’s implementation of that function would then use some builtin functions to bound how long the guarantee lasts.  If we decide that that’s too awkward to actually use, we could burn this into the language as a custom result convention and invent some language rules for the guaranteed extents of such a result based on how the expression is used; that would permit more APIs to opt in to a +0 guaranteed result, but the language rules would probably be pretty ad hoc.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I am not sure you can bound it this that way. I think we want this assertion to be propagated through l-values.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var outlive: Ownee<br>&gt;&gt;&gt; var owningReference: Ownee<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; withFixedLifetime(owningReference) {<br>&gt;&gt;&gt; Unamanged.passUnretained(owningReference).withGuaranteedValue {<br>&gt;&gt;&gt;   escape($0, to: &amp;outlive)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think we should just define this as undefined behavior.<br>&gt;&gt; <br>&gt;&gt; Why?  It doesn’t seem harmful.  It’s just that the guarantee doesn’t apply.<br>&gt; <br>&gt; Yes the guarantee does not apply, the user has escaped “the returned value to an l-value that outlives the “owningReference”.<br>&gt;&gt; <br>&gt;&gt; …to be clear, I certainly hope that the intended optimization strategy here isn’t just to unconditionally remove any retains and releases visible within the guaranteed block.  You can still at best remove them in pairs.  The effect on the optimizer here is just that uses that are known to occur within a guaranteed block can be ignored for the purposes of eliminating imprecise retain/release pairs.<br>&gt; <br>&gt; <br>&gt; Yes, only paired removal. Just like we can do with @guaranteed parameters today.<br>&gt; <br>&gt; <br>&gt; But imagine the “escape” function has been inlined. The optimizer will see:<br>&gt; <br>&gt; Unamanged.passUnretained(owningReference).withGuaranteedValue {<br>&gt;   outlive = $0<br>&gt; }<br>&gt; <br>&gt; This is not different to<br>&gt; <br>&gt; Unamanged.passUnretained(owningReference).withGuaranteedValue {<br>&gt;   let x = $0<br>&gt;   x.doSomething()<br>&gt; }<br>&gt; <br>&gt; And we want to optimize the latter.<br>&gt; <br>&gt; The closure syntax does not add any guarantee.<br></p><p>Let me retract this, I think I understand how you see the semantics of withGuaranteedValue:<br></p><p><br>  tmp = Builtin.unsafeGuaranteed(_unmanaged_ref) returns a managed reference<br>  closure(tmp) // consumes a managed reference<br>  Builtin.endUnsafeGuaranteed(tmp) // ends the lifetime for which the guarantee must hold.<br></p><p>I agree that would make the awkward language of transitively having to guarantee the lifetime through l-values unnecessary.<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[Proposal] Add an API to Unmanaged to get the instance it holds &quot;@guaranteed&quot;</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>March 14, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Mar 14, 2016, at 1:29 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; We have the withFixedLifetime API in the standard library today.<br>&gt;&gt; <br>&gt;&gt; withFixedLifetime(ownningReference) {<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Users can rely on that a stored reference in a class is not ultimately released during a method call on that class instance if they can guaranteed that nobody stores to that reference.<br>&gt;&gt; <br>&gt;&gt; The compiler honor withFixedLifetime today (if not that is a bug).<br>&gt;&gt; <br>&gt;&gt; Your point is that this needs to be made clear.<br>&gt; <br>&gt; Yeah, I think withFixedLifetime is probably not a good enough tool; at the very least, you need to reason about indirect references.  (e.g. if the object is held by an array element or a class property, then the array/instance itself needs to be held precisely, etc.)  It’s probably better for local values than a precise-lifetime attribute on local variables, though, assuming withFixedLifetime works for value types, and assuming it doesn’t actually cause reference-counting traffic itself.<br></p><p><br>The compiler should not be allowed to extend any object lifetimes past a fixed-lifetime marker.<br></p><p>I think it is necessary for the user of the proposed unsafe API to provide a fixed lifetime scope on an owning object, which may have levels of indirection. It’s also necessary for the user to avoid mutating any references that participate in that ownership chain within the fixed lifetime scope.<br></p><p>I don’t think this is an API that we want to promote. In the long run, I imagine a safe/automatic approach (a stored property can be obtained @guaranteed if it’s parent is transitively @guaranteed and is immutable). But that requires some language support and meanwhile we need a backdoor for bypassing ARC in special circumstances.<br></p><p>Andy<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160314/9b08735f/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Proposal] Add an API to Unmanaged to get the instance it holds &quot;@guaranteed&quot;</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>March 15, 2016 at 04:00:00pm</p></header><div class="content"><p>on Mon Mar 14 2016, John McCall &lt;rjmccall-AT-apple.com&gt; wrote:<br></p><p>&gt;&gt; In this example this would be for the lifetime for the value in x which extends to the lifetime of y.<br>&gt;<br>&gt; What if I return it or assign it to non-local memory?<br>&gt;<br>&gt; I feel like you’re trying to define this by optimizer behavior.<br>&gt; That’s not a workable language rule; programmers are not going to<br>&gt; reason about SSA values.<br></p><p>Thank you, John.  That is the problem I usually have with evaluating<br>most optimizer proposals.<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fbb2eb7db6aecac77ec563869540a874?s=50"></div><header><strong>[Proposal] Add an API to Unmanaged to get the instance it holds &quot;@guaranteed&quot;</strong> from <string>Arnold</string> &lt;aschwaighofer at apple.com&gt;<p>March 15, 2016 at 06:00:00pm</p></header><div class="content"><p>Updated proposal: use a method that accepts a closure to delineate the required guaranteed lifetime for which the assertion by the programmer holds.<br>And, hopefully, no optimizer language speak.<br></p><p><br>Add an API to Unmanaged to get the instance it holds @guaranteed<br></p><p>Proposal: SE-0000 Add an API to Unmanaged to get the instance it holds guaranteed &lt;https://github.com/aschwaighofer/swift-evolution/blob/unmanaged_unsafe_guaranteed_proposal/proposals/0000-unsafe-guaranteed.md&gt;<br>Author(s): Arnold Schwaighofer &lt;https://github.com/aschwaighofer&gt;<br>Status: Draft<br>Review manager: TBD<br> &lt;https://github.com/aschwaighofer/swift-evolution/blob/unmanaged_unsafe_guaranteed_proposal/proposals/0000-unsafe-guaranteed.md#introduction&gt;Introduction<br></p><p>The standard library Unmanged&lt;Instance&gt; struct provides an instance wrapper that does not participate in ARC; it allows the user to make manual retain/release calls and get at the contained instance at balanced/unbalanced retain counts.<br></p><p>This proposal suggests to add another method withUnsafeGuaranteedValue to Unmanaged that accepts a closure. Calling this method is akin to making an assertion about the guaranteed lifetime of the instance for the delinated scope of the method invocation. The closure is passed the unmanaged reference as a managed reference.<br></p><p>  func doSomething(u : Unmanged&lt;Owned&gt;) {<br>    // The programmer asserts that there exists another managed reference of the<br>    // unmanaged reference stored in &#39;u&#39; and that the lifetime of the referenced<br>    // instance is guaranteed to extend beyond the &#39;withUnsafeGuaranteedValue&#39;<br>    // invocation.<br>    u.withUnsafeGuaranteedValue {<br>      $0.doSomething()<br>    }<br>  }<br>This assertion will help the compiler remove ARC operations.<br></p><p>public struct Unmanaged&lt;Instance : AnyObject&gt; {<br></p><p>  // Get the value of the unmanaged referenced as a managed reference without<br>  // consuming an unbalanced retain of it and pass it to the closure. Asserts<br>  // that there is some other reference (&#39;the owning reference&#39;) to the<br>  // unmanaged reference that guarantees the lifetime of the unmanaged reference<br>  // for the duration of the &#39;withUnsafeGuaranteedValue&#39; call.<br>  //<br>  // NOTE: You are responsible for ensuring this by making the owning reference&#39;s<br>  // lifetime fixed for the duration of the &#39;withUnsafeGuaranteedValue&#39; call.<br>  //<br>  // Violation of this will incur undefined behavior.<br>  //<br>  // A lifetime of a reference &#39;the instance&#39; is fixed over a point in the<br>  // programm if:<br>  //<br>  // * There is another managed reference to the same instance &#39;the instance&#39;<br>  //   whose life time is fixed over the point in the program by means of<br>  //  &#39;withExtendedLifetime&#39; closing over this point.<br>  //<br>  //   var owningReference = Instance()<br>  //   ...<br>  //   withExtendedLifetime(owningReference) {<br>  //       point($0)<br>  //   }<br>  //<br>  // Or if:<br>  //<br>  // * There is a class, or struct instance (&#39;owner&#39;) whose lifetime is fixed at<br>  //   the point and which has a stored property that references &#39;the instance&#39;<br>  //   for the duration of the fixed lifetime of the &#39;owner&#39;.<br>  //<br>  //  class Owned {<br>  //  }<br>  //<br>  //  class Owner {<br>  //    final var owned : Owned<br>  //<br>  //    func foo() {<br>  //        withExtendedLifetime(self) {<br>  //            doSomething(...)<br>  //        } // Assuming: No stores to owned occur for the dynamic lifetime of<br>  //          //           the withExtendedLifetime invocation.<br>  //    }<br>  //<br>  //    func doSomething() {<br>  //       // both &#39;self&#39; and &#39;owned&#39;&#39;s lifetime is fixed over this point.<br>  //       point(self, owned)<br>  //    }<br>  //  }<br>  //<br>  // The last rule applies transitively through a chains of stored references<br>  // and nested structs.<br>  //<br>  // Examples:<br>  //<br>  //   var owningReference = Instance()<br>  //   ...<br>  //   withExtendedLifetime(owningReference) {<br>  //     let u = Unmanaged.passUnretained(owningReference)<br>  //     for i in 0 ..&lt; 100 {<br>  //       u.withUnsafeGuaranteedValue {<br>  //         $0.doSomething()<br>  //       }<br>  //     }<br>  //   }<br>  //<br>  //  class Owner {<br>  //    final var owned : Owned<br>  //<br>  //    func foo() {<br>  //        withExtendedLifetime(self) {<br>  //            doSomething(Unmanaged.passUnretained(owned))<br>  //        }<br>  //    }<br>  //<br>  //    func doSomething(u : Unmanged&lt;Owned&gt;) {<br>  //      u.withUnsafeGuaranteedValue {<br>  //        $0.doSomething()<br>  //      }<br>  //    }<br>  //  }<br>  public func withUnsafeGuaranteedValue&lt;Result&gt;(<br>    @noescape closure: (Instance) throws -&gt; Result<br>  ) rethrows {<br>    let instance = _value<br>    let (guaranteedInstance, token) = Builtin.unsafeGuaranteed(instance)<br>    try closure(guaranteedInstance)<br>    Builtin.unsafeGuaranteedEnd(token)<br>  }<br>Prototype: link to a prototype implementation &lt;https://github.com/aschwaighofer/swift/tree/unsafe_guaranteed_prototype&gt;<br> &lt;https://github.com/aschwaighofer/swift-evolution/blob/unmanaged_unsafe_guaranteed_proposal/proposals/0000-unsafe-guaranteed.md#motivation&gt;Motivation<br></p><p>A user can often make assertions that an instance is kept alive by another reference to it for the duration of some scope.<br></p><p>Consider the following example:<br></p><p>class Owned {<br>  func doSomeWork() {}<br>}<br></p><p>public class Owner {<br>  var ref: Owned<br></p><p>  init() { ref = Owned() }<br></p><p>  public func doWork() {<br>    withExtendedLifetime(self) {<br>      doSomething(ref)<br>    }<br>  }<br></p><p>  func doSomething(o: Owned) {<br>     o.doSomeWork()<br>  }<br>}<br>In this context the lifetime of Owner always exceeds o: Ownee. However, there is currently no way to tell the compiler about such an assertion. We can pass reference counted values in an Unmanged container without incurring reference count changes.<br></p><p>public class Owner {<br></p><p>  public func doWork() {<br>    // No reference count for passing the parameter.<br>    doSomething(Unmanaged.passUnretained(ref))<br>  }<br></p><p>  func doSomething(u: Unmanaged&lt;Owned&gt;) {<br>    // ...<br>  }<br>}<br>We can get at the contained instance by means of takeUnretainedValue() which will return a balanced retained value: the value is returned at +1 for release by the caller. However, when it comes to accessing the contained instance we incur reference counting.<br></p><p>  func doSomething(u: Unmanaged&lt;Owned&gt;) {<br>    // Incurs refcount increment before the call and decrement after for self.<br>    u.takeUnretainedValue().doSomeWork()<br>  }<br>With the proposed API call the user could make the assertion that u&#39;s contained instance&#39;s lifetime is guaranteed by another reference to it.<br></p><p>  func doSomething(u: Unmanaged&lt;Owned&gt;) {<br>    // Incurs refcount increment before the call and decrement after for self<br>    // that can be removed by the compiler based on the assertion made.<br>    u.withUnsafeGuaranteedValue {<br>      $0.doSomeWork()<br>    }<br>  }<br>The compiler can easily remove the reference counts marked by this method call with local reasoning.<br></p><p> &lt;https://github.com/aschwaighofer/swift-evolution/blob/unmanaged_unsafe_guaranteed_proposal/proposals/0000-unsafe-guaranteed.md#impact-on-existing-code&gt;Impact on existing code<br></p><p>This is a new API that does not replace an existing method. No existing code should be affected.<br></p><p> &lt;https://github.com/aschwaighofer/swift-evolution/blob/unmanaged_unsafe_guaranteed_proposal/proposals/0000-unsafe-guaranteed.md#alternatives-considered&gt;Alternatives considered<br></p><p>A somewhat related proposal would be to allow for class types to completely opt out of ARC forcing the programmer to perform manual reference counting. The scope of such a proposal would be much bigger making it questionable for Swift 3 inclusion. I believe that the two approaches are complementary and don&#39;t completely supplant each other. This proposal&#39;s approach allows for selectively opting out of ARC while providing a high notational burdon when wide spread over the application (wrapping and unwrapping of Unmanaged). Opting completely out of ARC is an all-in solution, which on the other hand does not have the high notational burden.<br></p><p><br>&gt; On Mar 15, 2016, at 4:06 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Mon Mar 14 2016, John McCall &lt;rjmccall-AT-apple.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; In this example this would be for the lifetime for the value in x which extends to the lifetime of y.<br>&gt;&gt; <br>&gt;&gt; What if I return it or assign it to non-local memory?<br>&gt;&gt; <br>&gt;&gt; I feel like you’re trying to define this by optimizer behavior.<br>&gt;&gt; That’s not a workable language rule; programmers are not going to<br>&gt;&gt; reason about SSA values.<br>&gt; <br>&gt; Thank you, John.  That is the problem I usually have with evaluating<br>&gt; most optimizer proposals.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160315/e7e82daa/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/78dda0d326b6c8eff7c2679f55346a7f?s=50"></div><header><strong>[Proposal] Add an API to Unmanaged to get the instance it holds &quot;@guaranteed&quot;</strong> from <string>Alex Migicovsky</string> &lt;migi at apple.com&gt;<p>March 15, 2016 at 06:00:00pm</p></header><div class="content"><p>Hi Arnold,<br></p><p>This seems like a great optimization tool. The only question I have is about the method name. With the name `withUnsafeGuaranteedValue` we’re moving the term “guaranteed” into API in addition to it being an implementation detail of the compiler as far as I could tell. Is “guaranteed&quot; the best name for this?<br></p><p>- Alex<br></p><p>&gt; On Mar 15, 2016, at 6:01 PM, Arnold Schwaighofer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Updated proposal: use a method that accepts a closure to delineate the required guaranteed lifetime for which the assertion by the programmer holds.<br>&gt; And, hopefully, no optimizer language speak.<br>&gt; <br>&gt; <br>&gt; Add an API to Unmanaged to get the instance it holds @guaranteed<br>&gt; <br>&gt; Proposal: SE-0000 Add an API to Unmanaged to get the instance it holds guaranteed &lt;https://github.com/aschwaighofer/swift-evolution/blob/unmanaged_unsafe_guaranteed_proposal/proposals/0000-unsafe-guaranteed.md&gt;<br>&gt; Author(s): Arnold Schwaighofer &lt;https://github.com/aschwaighofer&gt;<br>&gt; Status: Draft<br>&gt; Review manager: TBD<br>&gt;  &lt;https://github.com/aschwaighofer/swift-evolution/blob/unmanaged_unsafe_guaranteed_proposal/proposals/0000-unsafe-guaranteed.md#introduction&gt;Introduction<br>&gt; <br>&gt; The standard library Unmanged&lt;Instance&gt; struct provides an instance wrapper that does not participate in ARC; it allows the user to make manual retain/release calls and get at the contained instance at balanced/unbalanced retain counts.<br>&gt; <br>&gt; This proposal suggests to add another method withUnsafeGuaranteedValue to Unmanaged that accepts a closure. Calling this method is akin to making an assertion about the guaranteed lifetime of the instance for the delinated scope of the method invocation. The closure is passed the unmanaged reference as a managed reference.<br>&gt; <br>&gt;   func doSomething(u : Unmanged&lt;Owned&gt;) {<br>&gt;     // The programmer asserts that there exists another managed reference of the<br>&gt;     // unmanaged reference stored in &#39;u&#39; and that the lifetime of the referenced<br>&gt;     // instance is guaranteed to extend beyond the &#39;withUnsafeGuaranteedValue&#39;<br>&gt;     // invocation.<br>&gt;     u.withUnsafeGuaranteedValue {<br>&gt;       $0.doSomething()<br>&gt;     }<br>&gt;   }<br>&gt; This assertion will help the compiler remove ARC operations.<br>&gt; <br>&gt; public struct Unmanaged&lt;Instance : AnyObject&gt; {<br>&gt; <br>&gt;   // Get the value of the unmanaged referenced as a managed reference without<br>&gt;   // consuming an unbalanced retain of it and pass it to the closure. Asserts<br>&gt;   // that there is some other reference (&#39;the owning reference&#39;) to the<br>&gt;   // unmanaged reference that guarantees the lifetime of the unmanaged reference<br>&gt;   // for the duration of the &#39;withUnsafeGuaranteedValue&#39; call.<br>&gt;   //<br>&gt;   // NOTE: You are responsible for ensuring this by making the owning reference&#39;s<br>&gt;   // lifetime fixed for the duration of the &#39;withUnsafeGuaranteedValue&#39; call.<br>&gt;   //<br>&gt;   // Violation of this will incur undefined behavior.<br>&gt;   //<br>&gt;   // A lifetime of a reference &#39;the instance&#39; is fixed over a point in the<br>&gt;   // programm if:<br>&gt;   //<br>&gt;   // * There is another managed reference to the same instance &#39;the instance&#39;<br>&gt;   //   whose life time is fixed over the point in the program by means of<br>&gt;   //  &#39;withExtendedLifetime&#39; closing over this point.<br>&gt;   //<br>&gt;   //   var owningReference = Instance()<br>&gt;   //   ...<br>&gt;   //   withExtendedLifetime(owningReference) {<br>&gt;   //       point($0)<br>&gt;   //   }<br>&gt;   //<br>&gt;   // Or if:<br>&gt;   //<br>&gt;   // * There is a class, or struct instance (&#39;owner&#39;) whose lifetime is fixed at<br>&gt;   //   the point and which has a stored property that references &#39;the instance&#39;<br>&gt;   //   for the duration of the fixed lifetime of the &#39;owner&#39;.<br>&gt;   //<br>&gt;   //  class Owned {<br>&gt;   //  }<br>&gt;   //<br>&gt;   //  class Owner {<br>&gt;   //    final var owned : Owned<br>&gt;   //<br>&gt;   //    func foo() {<br>&gt;   //        withExtendedLifetime(self) {<br>&gt;   //            doSomething(...)<br>&gt;   //        } // Assuming: No stores to owned occur for the dynamic lifetime of<br>&gt;   //          //           the withExtendedLifetime invocation.<br>&gt;   //    }<br>&gt;   //<br>&gt;   //    func doSomething() {<br>&gt;   //       // both &#39;self&#39; and &#39;owned&#39;&#39;s lifetime is fixed over this point.<br>&gt;   //       point(self, owned)<br>&gt;   //    }<br>&gt;   //  }<br>&gt;   //<br>&gt;   // The last rule applies transitively through a chains of stored references<br>&gt;   // and nested structs.<br>&gt;   //<br>&gt;   // Examples:<br>&gt;   //<br>&gt;   //   var owningReference = Instance()<br>&gt;   //   ...<br>&gt;   //   withExtendedLifetime(owningReference) {<br>&gt;   //     let u = Unmanaged.passUnretained(owningReference)<br>&gt;   //     for i in 0 ..&lt; 100 {<br>&gt;   //       u.withUnsafeGuaranteedValue {<br>&gt;   //         $0.doSomething()<br>&gt;   //       }<br>&gt;   //     }<br>&gt;   //   }<br>&gt;   //<br>&gt;   //  class Owner {<br>&gt;   //    final var owned : Owned<br>&gt;   //<br>&gt;   //    func foo() {<br>&gt;   //        withExtendedLifetime(self) {<br>&gt;   //            doSomething(Unmanaged.passUnretained(owned))<br>&gt;   //        }<br>&gt;   //    }<br>&gt;   //<br>&gt;   //    func doSomething(u : Unmanged&lt;Owned&gt;) {<br>&gt;   //      u.withUnsafeGuaranteedValue {<br>&gt;   //        $0.doSomething()<br>&gt;   //      }<br>&gt;   //    }<br>&gt;   //  }<br>&gt;   public func withUnsafeGuaranteedValue&lt;Result&gt;(<br>&gt;     @noescape closure: (Instance) throws -&gt; Result<br>&gt;   ) rethrows {<br>&gt;     let instance = _value<br>&gt;     let (guaranteedInstance, token) = Builtin.unsafeGuaranteed(instance)<br>&gt;     try closure(guaranteedInstance)<br>&gt;     Builtin.unsafeGuaranteedEnd(token)<br>&gt;   }<br>&gt; Prototype: link to a prototype implementation &lt;https://github.com/aschwaighofer/swift/tree/unsafe_guaranteed_prototype&gt;<br>&gt;  &lt;https://github.com/aschwaighofer/swift-evolution/blob/unmanaged_unsafe_guaranteed_proposal/proposals/0000-unsafe-guaranteed.md#motivation&gt;Motivation<br>&gt; <br>&gt; A user can often make assertions that an instance is kept alive by another reference to it for the duration of some scope.<br>&gt; <br>&gt; Consider the following example:<br>&gt; <br>&gt; class Owned {<br>&gt;   func doSomeWork() {}<br>&gt; }<br>&gt; <br>&gt; public class Owner {<br>&gt;   var ref: Owned<br>&gt; <br>&gt;   init() { ref = Owned() }<br>&gt; <br>&gt;   public func doWork() {<br>&gt;     withExtendedLifetime(self) {<br>&gt;       doSomething(ref)<br>&gt;     }<br>&gt;   }<br>&gt; <br>&gt;   func doSomething(o: Owned) {<br>&gt;      o.doSomeWork()<br>&gt;   }<br>&gt; }<br>&gt; In this context the lifetime of Owner always exceeds o: Ownee. However, there is currently no way to tell the compiler about such an assertion. We can pass reference counted values in an Unmanged container without incurring reference count changes.<br>&gt; <br>&gt; public class Owner {<br>&gt; <br>&gt;   public func doWork() {<br>&gt;     // No reference count for passing the parameter.<br>&gt;     doSomething(Unmanaged.passUnretained(ref))<br>&gt;   }<br>&gt; <br>&gt;   func doSomething(u: Unmanaged&lt;Owned&gt;) {<br>&gt;     // ...<br>&gt;   }<br>&gt; }<br>&gt; We can get at the contained instance by means of takeUnretainedValue() which will return a balanced retained value: the value is returned at +1 for release by the caller. However, when it comes to accessing the contained instance we incur reference counting.<br>&gt; <br>&gt;   func doSomething(u: Unmanaged&lt;Owned&gt;) {<br>&gt;     // Incurs refcount increment before the call and decrement after for self.<br>&gt;     u.takeUnretainedValue().doSomeWork()<br>&gt;   }<br>&gt; With the proposed API call the user could make the assertion that u&#39;s contained instance&#39;s lifetime is guaranteed by another reference to it.<br>&gt; <br>&gt;   func doSomething(u: Unmanaged&lt;Owned&gt;) {<br>&gt;     // Incurs refcount increment before the call and decrement after for self<br>&gt;     // that can be removed by the compiler based on the assertion made.<br>&gt;     u.withUnsafeGuaranteedValue {<br>&gt;       $0.doSomeWork()<br>&gt;     }<br>&gt;   }<br>&gt; The compiler can easily remove the reference counts marked by this method call with local reasoning.<br>&gt; <br>&gt;  &lt;https://github.com/aschwaighofer/swift-evolution/blob/unmanaged_unsafe_guaranteed_proposal/proposals/0000-unsafe-guaranteed.md#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; This is a new API that does not replace an existing method. No existing code should be affected.<br>&gt; <br>&gt;  &lt;https://github.com/aschwaighofer/swift-evolution/blob/unmanaged_unsafe_guaranteed_proposal/proposals/0000-unsafe-guaranteed.md#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt; A somewhat related proposal would be to allow for class types to completely opt out of ARC forcing the programmer to perform manual reference counting. The scope of such a proposal would be much bigger making it questionable for Swift 3 inclusion. I believe that the two approaches are complementary and don&#39;t completely supplant each other. This proposal&#39;s approach allows for selectively opting out of ARC while providing a high notational burdon when wide spread over the application (wrapping and unwrapping of Unmanaged). Opting completely out of ARC is an all-in solution, which on the other hand does not have the high notational burden.<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 15, 2016, at 4:06 PM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Mon Mar 14 2016, John McCall &lt;rjmccall-AT-apple.com &lt;http://rjmccall-at-apple.com/&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; In this example this would be for the lifetime for the value in x which extends to the lifetime of y.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What if I return it or assign it to non-local memory?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I feel like you’re trying to define this by optimizer behavior.<br>&gt;&gt;&gt; That’s not a workable language rule; programmers are not going to<br>&gt;&gt;&gt; reason about SSA values.<br>&gt;&gt; <br>&gt;&gt; Thank you, John.  That is the problem I usually have with evaluating<br>&gt;&gt; most optimizer proposals.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160315/293cfc3d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fbb2eb7db6aecac77ec563869540a874?s=50"></div><header><strong>[Proposal] Add an API to Unmanaged to get the instance it holds &quot;@guaranteed&quot;</strong> from <string>Arnold</string> &lt;aschwaighofer at apple.com&gt;<p>March 15, 2016 at 06:00:00pm</p></header><div class="content"><p>Hi Alex,<br></p><p>Probably not, The name is a strawman. I guess I could not resist the optimizer speak after all. The programmer is asserting he guarantees the lifetime by other means. I expect if this proposal moves forward the standard library team will decide on the right name for this method.<br></p><p>assertLifetimeGuarantee, withAssertedLifetime, unsafePassWithAssertedLifetime, ... ?<br></p><p><br></p><p>&gt; On Mar 15, 2016, at 6:14 PM, Alex Migicovsky &lt;migi at apple.com&gt; wrote:<br>&gt; <br>&gt; Hi Arnold,<br>&gt; <br>&gt; This seems like a great optimization tool. The only question I have is about the method name. With the name `withUnsafeGuaranteedValue` we’re moving the term “guaranteed” into API in addition to it being an implementation detail of the compiler as far as I could tell. Is “guaranteed&quot; the best name for this?<br>&gt; <br>&gt; - Alex<br>&gt; <br>&gt;&gt; On Mar 15, 2016, at 6:01 PM, Arnold Schwaighofer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Updated proposal: use a method that accepts a closure to delineate the required guaranteed lifetime for which the assertion by the programmer holds.<br>&gt;&gt; And, hopefully, no optimizer language speak.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Add an API to Unmanaged to get the instance it holds @guaranteed<br>&gt;&gt; Proposal: SE-0000 Add an API to Unmanaged to get the instance it holds guaranteed<br>&gt;&gt; Author(s): Arnold Schwaighofer<br>&gt;&gt; Status: Draft<br>&gt;&gt; Review manager: TBD<br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; The standard library Unmanged&lt;Instance&gt; struct provides an instance wrapper that does not participate in ARC; it allows the user to make manual retain/release calls and get at the contained instance at balanced/unbalanced retain counts.<br>&gt;&gt; <br>&gt;&gt; This proposal suggests to add another method withUnsafeGuaranteedValue to Unmanaged that accepts a closure. Calling this method is akin to making an assertion about the guaranteed lifetime of the instance for the delinated scope of the method invocation. The closure is passed the unmanaged reference as a managed reference.<br>&gt;&gt; <br>&gt;&gt;   func doSomething(u : Unmanged&lt;Owned&gt;) {<br>&gt;&gt;     // The programmer asserts that there exists another managed reference of the<br>&gt;&gt;     // unmanaged reference stored in &#39;u&#39; and that the lifetime of the referenced<br>&gt;&gt;     // instance is guaranteed to extend beyond the &#39;withUnsafeGuaranteedValue&#39;<br>&gt;&gt;     // invocation.<br>&gt;&gt;     u.withUnsafeGuaranteedValue {<br>&gt;&gt;       $0.doSomething()<br>&gt;&gt;     }<br>&gt;&gt;   }<br>&gt;&gt; This assertion will help the compiler remove ARC operations.<br>&gt;&gt; <br>&gt;&gt; public struct Unmanaged&lt;Instance : AnyObject&gt; {<br>&gt;&gt; <br>&gt;&gt;   // Get the value of the unmanaged referenced as a managed reference without<br>&gt;&gt;   // consuming an unbalanced retain of it and pass it to the closure. Asserts<br>&gt;&gt;   // that there is some other reference (&#39;the owning reference&#39;) to the<br>&gt;&gt;   // unmanaged reference that guarantees the lifetime of the unmanaged reference<br>&gt;&gt;   // for the duration of the &#39;withUnsafeGuaranteedValue&#39; call.<br>&gt;&gt;   //<br>&gt;&gt;   // NOTE: You are responsible for ensuring this by making the owning reference&#39;s<br>&gt;&gt;   // lifetime fixed for the duration of the &#39;withUnsafeGuaranteedValue&#39; call.<br>&gt;&gt;   //<br>&gt;&gt;   // Violation of this will incur undefined behavior.<br>&gt;&gt;   //<br>&gt;&gt;   // A lifetime of a reference &#39;the instance&#39; is fixed over a point in the<br>&gt;&gt;   // programm if:<br>&gt;&gt;   //<br>&gt;&gt;   // * There is another managed reference to the same instance &#39;the instance&#39;<br>&gt;&gt;   //   whose life time is fixed over the point in the program by means of<br>&gt;&gt;   //  &#39;withExtendedLifetime&#39; closing over this point.<br>&gt;&gt;   //<br>&gt;&gt;   //   var owningReference = Instance()<br>&gt;&gt;   //   ...<br>&gt;&gt;   //   withExtendedLifetime(owningReference) {<br>&gt;&gt;   //       point($0)<br>&gt;&gt;   //   }<br>&gt;&gt;   //<br>&gt;&gt;   // Or if:<br>&gt;&gt;   //<br>&gt;&gt;   // * There is a class, or struct instance (&#39;owner&#39;) whose lifetime is fixed at<br>&gt;&gt;   //   the point and which has a stored property that references &#39;the instance&#39;<br>&gt;&gt;   //   for the duration of the fixed lifetime of the &#39;owner&#39;.<br>&gt;&gt;   //<br>&gt;&gt;   //  class Owned {<br>&gt;&gt;   //  }<br>&gt;&gt;   //<br>&gt;&gt;   //  class Owner {<br>&gt;&gt;   //    final var owned : Owned<br>&gt;&gt;   //<br>&gt;&gt;   //    func foo() {<br>&gt;&gt;   //        withExtendedLifetime(self) {<br>&gt;&gt;   //            doSomething(...)<br>&gt;&gt;   //        } // Assuming: No stores to owned occur for the dynamic lifetime of<br>&gt;&gt;   //          //           the withExtendedLifetime invocation.<br>&gt;&gt;   //    }<br>&gt;&gt;   //<br>&gt;&gt;   //    func doSomething() {<br>&gt;&gt;   //       // both &#39;self&#39; and &#39;owned&#39;&#39;s lifetime is fixed over this point.<br>&gt;&gt;   //       point(self, owned)<br>&gt;&gt;   //    }<br>&gt;&gt;   //  }<br>&gt;&gt;   //<br>&gt;&gt;   // The last rule applies transitively through a chains of stored references<br>&gt;&gt;   // and nested structs.<br>&gt;&gt;   //<br>&gt;&gt;   // Examples:<br>&gt;&gt;   //<br>&gt;&gt;   //   var owningReference = Instance()<br>&gt;&gt;   //   ...<br>&gt;&gt;   //   withExtendedLifetime(owningReference) {<br>&gt;&gt;   //     let u = Unmanaged.passUnretained(owningReference)<br>&gt;&gt;   //     for i in 0 ..&lt; 100 {<br>&gt;&gt;   //       u.withUnsafeGuaranteedValue {<br>&gt;&gt;   //         $0.doSomething()<br>&gt;&gt;   //       }<br>&gt;&gt;   //     }<br>&gt;&gt;   //   }<br>&gt;&gt;   //<br>&gt;&gt;   //  class Owner {<br>&gt;&gt;   //    final var owned : Owned<br>&gt;&gt;   //<br>&gt;&gt;   //    func foo() {<br>&gt;&gt;   //        withExtendedLifetime(self) {<br>&gt;&gt;   //            doSomething(Unmanaged.passUnretained(owned))<br>&gt;&gt;   //        }<br>&gt;&gt;   //    }<br>&gt;&gt;   //<br>&gt;&gt;   //    func doSomething(u : Unmanged&lt;Owned&gt;) {<br>&gt;&gt;   //      u.withUnsafeGuaranteedValue {<br>&gt;&gt;   //        $0.doSomething()<br>&gt;&gt;   //      }<br>&gt;&gt;   //    }<br>&gt;&gt;   //  }<br>&gt;&gt;   public func withUnsafeGuaranteedValue&lt;Result&gt;(<br>&gt;&gt;     @noescape closure: (Instance) throws -&gt; Result<br>&gt;&gt;   ) rethrows {<br>&gt;&gt;     let instance = _value<br>&gt;&gt;     let (guaranteedInstance, token) = Builtin.unsafeGuaranteed(instance)<br>&gt;&gt;     try closure(guaranteedInstance)<br>&gt;&gt;     Builtin.unsafeGuaranteedEnd(token)<br>&gt;&gt;   }<br>&gt;&gt; Prototype: link to a prototype implementation<br>&gt;&gt; <br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; A user can often make assertions that an instance is kept alive by another reference to it for the duration of some scope.<br>&gt;&gt; <br>&gt;&gt; Consider the following example:<br>&gt;&gt; <br>&gt;&gt; class Owned {<br>&gt;&gt;   func doSomeWork() {}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; public class Owner {<br>&gt;&gt;   var ref: Owned<br>&gt;&gt; <br>&gt;&gt;   init() { ref = Owned() }<br>&gt;&gt; <br>&gt;&gt;   public func doWork() {<br>&gt;&gt;     withExtendedLifetime(self) {<br>&gt;&gt;       doSomething(ref)<br>&gt;&gt;     }<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;   func doSomething(o: Owned) {<br>&gt;&gt;      o.doSomeWork()<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; In this context the lifetime of Owner always exceeds o: Ownee. However, there is currently no way to tell the compiler about such an assertion. We can pass reference counted values in an Unmanged container without incurring reference count changes.<br>&gt;&gt; <br>&gt;&gt; public class Owner {<br>&gt;&gt; <br>&gt;&gt;   public func doWork() {<br>&gt;&gt;     // No reference count for passing the parameter.<br>&gt;&gt;     doSomething(Unmanaged.passUnretained(ref))<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;   func doSomething(u: Unmanaged&lt;Owned&gt;) {<br>&gt;&gt;     // ...<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; We can get at the contained instance by means of takeUnretainedValue() which will return a balanced retained value: the value is returned at +1 for release by the caller. However, when it comes to accessing the contained instance we incur reference counting.<br>&gt;&gt; <br>&gt;&gt;   func doSomething(u: Unmanaged&lt;Owned&gt;) {<br>&gt;&gt;     // Incurs refcount increment before the call and decrement after for self.<br>&gt;&gt;     u.takeUnretainedValue().doSomeWork()<br>&gt;&gt;   }<br>&gt;&gt; With the proposed API call the user could make the assertion that u&#39;s contained instance&#39;s lifetime is guaranteed by another reference to it.<br>&gt;&gt; <br>&gt;&gt;   func doSomething(u: Unmanaged&lt;Owned&gt;) {<br>&gt;&gt;     // Incurs refcount increment before the call and decrement after for self<br>&gt;&gt;     // that can be removed by the compiler based on the assertion made.<br>&gt;&gt;     u.withUnsafeGuaranteedValue {<br>&gt;&gt;       $0.doSomeWork()<br>&gt;&gt;     }<br>&gt;&gt;   }<br>&gt;&gt; The compiler can easily remove the reference counts marked by this method call with local reasoning.<br>&gt;&gt; <br>&gt;&gt; Impact on existing code<br>&gt;&gt; <br>&gt;&gt; This is a new API that does not replace an existing method. No existing code should be affected.<br>&gt;&gt; <br>&gt;&gt; Alternatives considered<br>&gt;&gt; <br>&gt;&gt; A somewhat related proposal would be to allow for class types to completely opt out of ARC forcing the programmer to perform manual reference counting. The scope of such a proposal would be much bigger making it questionable for Swift 3 inclusion. I believe that the two approaches are complementary and don&#39;t completely supplant each other. This proposal&#39;s approach allows for selectively opting out of ARC while providing a high notational burdon when wide spread over the application (wrapping and unwrapping of Unmanaged). Opting completely out of ARC is an all-in solution, which on the other hand does not have the high notational burden.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 15, 2016, at 4:06 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Mon Mar 14 2016, John McCall &lt;rjmccall-AT-apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In this example this would be for the lifetime for the value in x which extends to the lifetime of y.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What if I return it or assign it to non-local memory?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I feel like you’re trying to define this by optimizer behavior.<br>&gt;&gt;&gt;&gt; That’s not a workable language rule; programmers are not going to<br>&gt;&gt;&gt;&gt; reason about SSA values.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thank you, John.  That is the problem I usually have with evaluating<br>&gt;&gt;&gt; most optimizer proposals.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160315/653c48e4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/78dda0d326b6c8eff7c2679f55346a7f?s=50"></div><header><strong>[Proposal] Add an API to Unmanaged to get the instance it holds &quot;@guaranteed&quot;</strong> from <string>Alex Migicovsky</string> &lt;migi at apple.com&gt;<p>March 15, 2016 at 06:00:00pm</p></header><div class="content"><p>Hehe :-)<br></p><p>I’ll hold off suggestions until we need to cross that road!<br></p><p>- Alex<br></p><p>&gt; On Mar 15, 2016, at 6:28 PM, Arnold &lt;aschwaighofer at apple.com&gt; wrote:<br>&gt; <br>&gt; Hi Alex,<br>&gt; <br>&gt; Probably not, The name is a strawman. I guess I could not resist the optimizer speak after all. The programmer is asserting he guarantees the lifetime by other means. I expect if this proposal moves forward the standard library team will decide on the right name for this method.<br>&gt; <br>&gt; assertLifetimeGuarantee, withAssertedLifetime, unsafePassWithAssertedLifetime, ... ?<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Mar 15, 2016, at 6:14 PM, Alex Migicovsky &lt;migi at apple.com &lt;mailto:migi at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Hi Arnold,<br>&gt;&gt; <br>&gt;&gt; This seems like a great optimization tool. The only question I have is about the method name. With the name `withUnsafeGuaranteedValue` we’re moving the term “guaranteed” into API in addition to it being an implementation detail of the compiler as far as I could tell. Is “guaranteed&quot; the best name for this?<br>&gt;&gt; <br>&gt;&gt; - Alex<br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 15, 2016, at 6:01 PM, Arnold Schwaighofer via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Updated proposal: use a method that accepts a closure to delineate the required guaranteed lifetime for which the assertion by the programmer holds.<br>&gt;&gt;&gt; And, hopefully, no optimizer language speak.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Add an API to Unmanaged to get the instance it holds @guaranteed<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposal: SE-0000 Add an API to Unmanaged to get the instance it holds guaranteed &lt;https://github.com/aschwaighofer/swift-evolution/blob/unmanaged_unsafe_guaranteed_proposal/proposals/0000-unsafe-guaranteed.md&gt;<br>&gt;&gt;&gt; Author(s): Arnold Schwaighofer &lt;https://github.com/aschwaighofer&gt;<br>&gt;&gt;&gt; Status: Draft<br>&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt;  &lt;https://github.com/aschwaighofer/swift-evolution/blob/unmanaged_unsafe_guaranteed_proposal/proposals/0000-unsafe-guaranteed.md#introduction&gt;Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The standard library Unmanged&lt;Instance&gt; struct provides an instance wrapper that does not participate in ARC; it allows the user to make manual retain/release calls and get at the contained instance at balanced/unbalanced retain counts.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This proposal suggests to add another method withUnsafeGuaranteedValue to Unmanaged that accepts a closure. Calling this method is akin to making an assertion about the guaranteed lifetime of the instance for the delinated scope of the method invocation. The closure is passed the unmanaged reference as a managed reference.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   func doSomething(u : Unmanged&lt;Owned&gt;) {<br>&gt;&gt;&gt;     // The programmer asserts that there exists another managed reference of the<br>&gt;&gt;&gt;     // unmanaged reference stored in &#39;u&#39; and that the lifetime of the referenced<br>&gt;&gt;&gt;     // instance is guaranteed to extend beyond the &#39;withUnsafeGuaranteedValue&#39;<br>&gt;&gt;&gt;     // invocation.<br>&gt;&gt;&gt;     u.withUnsafeGuaranteedValue {<br>&gt;&gt;&gt;       $0.doSomething()<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; This assertion will help the compiler remove ARC operations.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public struct Unmanaged&lt;Instance : AnyObject&gt; {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   // Get the value of the unmanaged referenced as a managed reference without<br>&gt;&gt;&gt;   // consuming an unbalanced retain of it and pass it to the closure. Asserts<br>&gt;&gt;&gt;   // that there is some other reference (&#39;the owning reference&#39;) to the<br>&gt;&gt;&gt;   // unmanaged reference that guarantees the lifetime of the unmanaged reference<br>&gt;&gt;&gt;   // for the duration of the &#39;withUnsafeGuaranteedValue&#39; call.<br>&gt;&gt;&gt;   //<br>&gt;&gt;&gt;   // NOTE: You are responsible for ensuring this by making the owning reference&#39;s<br>&gt;&gt;&gt;   // lifetime fixed for the duration of the &#39;withUnsafeGuaranteedValue&#39; call.<br>&gt;&gt;&gt;   //<br>&gt;&gt;&gt;   // Violation of this will incur undefined behavior.<br>&gt;&gt;&gt;   //<br>&gt;&gt;&gt;   // A lifetime of a reference &#39;the instance&#39; is fixed over a point in the<br>&gt;&gt;&gt;   // programm if:<br>&gt;&gt;&gt;   //<br>&gt;&gt;&gt;   // * There is another managed reference to the same instance &#39;the instance&#39;<br>&gt;&gt;&gt;   //   whose life time is fixed over the point in the program by means of<br>&gt;&gt;&gt;   //  &#39;withExtendedLifetime&#39; closing over this point.<br>&gt;&gt;&gt;   //<br>&gt;&gt;&gt;   //   var owningReference = Instance()<br>&gt;&gt;&gt;   //   ...<br>&gt;&gt;&gt;   //   withExtendedLifetime(owningReference) {<br>&gt;&gt;&gt;   //       point($0)<br>&gt;&gt;&gt;   //   }<br>&gt;&gt;&gt;   //<br>&gt;&gt;&gt;   // Or if:<br>&gt;&gt;&gt;   //<br>&gt;&gt;&gt;   // * There is a class, or struct instance (&#39;owner&#39;) whose lifetime is fixed at<br>&gt;&gt;&gt;   //   the point and which has a stored property that references &#39;the instance&#39;<br>&gt;&gt;&gt;   //   for the duration of the fixed lifetime of the &#39;owner&#39;.<br>&gt;&gt;&gt;   //<br>&gt;&gt;&gt;   //  class Owned {<br>&gt;&gt;&gt;   //  }<br>&gt;&gt;&gt;   //<br>&gt;&gt;&gt;   //  class Owner {<br>&gt;&gt;&gt;   //    final var owned : Owned<br>&gt;&gt;&gt;   //<br>&gt;&gt;&gt;   //    func foo() {<br>&gt;&gt;&gt;   //        withExtendedLifetime(self) {<br>&gt;&gt;&gt;   //            doSomething(...)<br>&gt;&gt;&gt;   //        } // Assuming: No stores to owned occur for the dynamic lifetime of<br>&gt;&gt;&gt;   //          //           the withExtendedLifetime invocation.<br>&gt;&gt;&gt;   //    }<br>&gt;&gt;&gt;   //<br>&gt;&gt;&gt;   //    func doSomething() {<br>&gt;&gt;&gt;   //       // both &#39;self&#39; and &#39;owned&#39;&#39;s lifetime is fixed over this point.<br>&gt;&gt;&gt;   //       point(self, owned)<br>&gt;&gt;&gt;   //    }<br>&gt;&gt;&gt;   //  }<br>&gt;&gt;&gt;   //<br>&gt;&gt;&gt;   // The last rule applies transitively through a chains of stored references<br>&gt;&gt;&gt;   // and nested structs.<br>&gt;&gt;&gt;   //<br>&gt;&gt;&gt;   // Examples:<br>&gt;&gt;&gt;   //<br>&gt;&gt;&gt;   //   var owningReference = Instance()<br>&gt;&gt;&gt;   //   ...<br>&gt;&gt;&gt;   //   withExtendedLifetime(owningReference) {<br>&gt;&gt;&gt;   //     let u = Unmanaged.passUnretained(owningReference)<br>&gt;&gt;&gt;   //     for i in 0 ..&lt; 100 {<br>&gt;&gt;&gt;   //       u.withUnsafeGuaranteedValue {<br>&gt;&gt;&gt;   //         $0.doSomething()<br>&gt;&gt;&gt;   //       }<br>&gt;&gt;&gt;   //     }<br>&gt;&gt;&gt;   //   }<br>&gt;&gt;&gt;   //<br>&gt;&gt;&gt;   //  class Owner {<br>&gt;&gt;&gt;   //    final var owned : Owned<br>&gt;&gt;&gt;   //<br>&gt;&gt;&gt;   //    func foo() {<br>&gt;&gt;&gt;   //        withExtendedLifetime(self) {<br>&gt;&gt;&gt;   //            doSomething(Unmanaged.passUnretained(owned))<br>&gt;&gt;&gt;   //        }<br>&gt;&gt;&gt;   //    }<br>&gt;&gt;&gt;   //<br>&gt;&gt;&gt;   //    func doSomething(u : Unmanged&lt;Owned&gt;) {<br>&gt;&gt;&gt;   //      u.withUnsafeGuaranteedValue {<br>&gt;&gt;&gt;   //        $0.doSomething()<br>&gt;&gt;&gt;   //      }<br>&gt;&gt;&gt;   //    }<br>&gt;&gt;&gt;   //  }<br>&gt;&gt;&gt;   public func withUnsafeGuaranteedValue&lt;Result&gt;(<br>&gt;&gt;&gt;     @noescape closure: (Instance) throws -&gt; Result<br>&gt;&gt;&gt;   ) rethrows {<br>&gt;&gt;&gt;     let instance = _value<br>&gt;&gt;&gt;     let (guaranteedInstance, token) = Builtin.unsafeGuaranteed(instance)<br>&gt;&gt;&gt;     try closure(guaranteedInstance)<br>&gt;&gt;&gt;     Builtin.unsafeGuaranteedEnd(token)<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; Prototype: link to a prototype implementation &lt;https://github.com/aschwaighofer/swift/tree/unsafe_guaranteed_prototype&gt;<br>&gt;&gt;&gt;  &lt;https://github.com/aschwaighofer/swift-evolution/blob/unmanaged_unsafe_guaranteed_proposal/proposals/0000-unsafe-guaranteed.md#motivation&gt;Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A user can often make assertions that an instance is kept alive by another reference to it for the duration of some scope.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Consider the following example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class Owned {<br>&gt;&gt;&gt;   func doSomeWork() {}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public class Owner {<br>&gt;&gt;&gt;   var ref: Owned<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   init() { ref = Owned() }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   public func doWork() {<br>&gt;&gt;&gt;     withExtendedLifetime(self) {<br>&gt;&gt;&gt;       doSomething(ref)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   func doSomething(o: Owned) {<br>&gt;&gt;&gt;      o.doSomeWork()<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; In this context the lifetime of Owner always exceeds o: Ownee. However, there is currently no way to tell the compiler about such an assertion. We can pass reference counted values in an Unmanged container without incurring reference count changes.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public class Owner {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   public func doWork() {<br>&gt;&gt;&gt;     // No reference count for passing the parameter.<br>&gt;&gt;&gt;     doSomething(Unmanaged.passUnretained(ref))<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   func doSomething(u: Unmanaged&lt;Owned&gt;) {<br>&gt;&gt;&gt;     // ...<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; We can get at the contained instance by means of takeUnretainedValue() which will return a balanced retained value: the value is returned at +1 for release by the caller. However, when it comes to accessing the contained instance we incur reference counting.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   func doSomething(u: Unmanaged&lt;Owned&gt;) {<br>&gt;&gt;&gt;     // Incurs refcount increment before the call and decrement after for self.<br>&gt;&gt;&gt;     u.takeUnretainedValue().doSomeWork()<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; With the proposed API call the user could make the assertion that u&#39;s contained instance&#39;s lifetime is guaranteed by another reference to it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   func doSomething(u: Unmanaged&lt;Owned&gt;) {<br>&gt;&gt;&gt;     // Incurs refcount increment before the call and decrement after for self<br>&gt;&gt;&gt;     // that can be removed by the compiler based on the assertion made.<br>&gt;&gt;&gt;     u.withUnsafeGuaranteedValue {<br>&gt;&gt;&gt;       $0.doSomeWork()<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; The compiler can easily remove the reference counts marked by this method call with local reasoning.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/aschwaighofer/swift-evolution/blob/unmanaged_unsafe_guaranteed_proposal/proposals/0000-unsafe-guaranteed.md#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a new API that does not replace an existing method. No existing code should be affected.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/aschwaighofer/swift-evolution/blob/unmanaged_unsafe_guaranteed_proposal/proposals/0000-unsafe-guaranteed.md#alternatives-considered&gt;Alternatives considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A somewhat related proposal would be to allow for class types to completely opt out of ARC forcing the programmer to perform manual reference counting. The scope of such a proposal would be much bigger making it questionable for Swift 3 inclusion. I believe that the two approaches are complementary and don&#39;t completely supplant each other. This proposal&#39;s approach allows for selectively opting out of ARC while providing a high notational burdon when wide spread over the application (wrapping and unwrapping of Unmanaged). Opting completely out of ARC is an all-in solution, which on the other hand does not have the high notational burden.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mar 15, 2016, at 4:06 PM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Mon Mar 14 2016, John McCall &lt;rjmccall-AT-apple.com &lt;http://rjmccall-at-apple.com/&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In this example this would be for the lifetime for the value in x which extends to the lifetime of y.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; What if I return it or assign it to non-local memory?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I feel like you’re trying to define this by optimizer behavior.<br>&gt;&gt;&gt;&gt;&gt; That’s not a workable language rule; programmers are not going to<br>&gt;&gt;&gt;&gt;&gt; reason about SSA values.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thank you, John.  That is the problem I usually have with evaluating<br>&gt;&gt;&gt;&gt; most optimizer proposals.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160315/c0d032f1/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal] Add an API to Unmanaged to get the instance it holds &quot;@guaranteed&quot;</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March 16, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; Probably not, The name is a strawman. I guess I could not resist the optimizer speak after all. The programmer is asserting he guarantees the lifetime by other means. I expect if this proposal moves forward the standard library team will decide on the right name for this method.<br>&gt; <br>&gt; assertLifetimeGuarantee, withAssertedLifetime, unsafePassWithAssertedLifetime, ... ?<br></p><p>withUnsafeUnownedValue? I think that conveys the danger—you&#39;ve been passed a value which you don&#39;t own, so something else had better keep it alive—even if it&#39;s not technically accurate.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
