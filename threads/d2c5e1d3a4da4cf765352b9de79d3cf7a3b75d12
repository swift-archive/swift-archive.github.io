<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/46439321e8b5b5ba0944eef50e18c3a3?s=50"></div><header><strong>How to be DRY on ranges and closed ranges?</strong> from <string>Jean-Denis Muys</string> &lt;jdmuys at gmail.com&gt;<p>October 12, 2016 at 12:00:00pm</p></header><div class="content"><p>Hi,<br></p><p>I defined this:<br></p><p>func random(from r: Range&lt;Int&gt;) -&gt; Int {<br>    let from = r.lowerBound<br>    let to =  r.upperBound<br>    <br>    let rnd = arc4random_uniform(UInt32(to-from))<br>    return from + Int(rnd)<br>}<br></p><p>so that I can do:<br></p><p>let testRandomValue = random(from: 4..&lt;8)<br></p><p>But this will not let me do:<br></p><p>let otherTestRandomValue = random(from: 4...10)<br></p><p>The error message is a bit cryptic:<br></p><p>“No ‘…’ candidate produce the expected contextual result type ‘Range&lt;Int&gt;’”<br></p><p>What is happening is that 4…10 is not a Range, but a ClosedRange.<br></p><p>Of course I can overload my function above to add a version that takes a ClosedRange.<br></p><p>But this is not very DRY.<br></p><p>What would be a more idiomatic way?<br></p><p>Thanks,<br></p><p>Jean-Denis<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20161012/d2c55d12/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>How to be DRY on ranges and closed ranges?</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>October 12, 2016 at 03:00:00pm</p></header><div class="content"><p>I’ve been bitten by that quite a few times. I’m not a fan of the new distinction between Range and ClosedRange. I understand the reasoning behind them, but the new model is creating more problems for me than the it solves.<br></p><p>David.<br></p><p>&gt; On 12 Oct 2016, at 12:21, Jean-Denis Muys via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi,<br>&gt; <br>&gt; I defined this:<br>&gt; <br>&gt; func random(from r: Range&lt;Int&gt;) -&gt; Int {<br>&gt;     let from = r.lowerBound<br>&gt;     let to =  r.upperBound<br>&gt;     <br>&gt;     let rnd = arc4random_uniform(UInt32(to-from))<br>&gt;     return from + Int(rnd)<br>&gt; }<br>&gt; <br>&gt; so that I can do:<br>&gt; <br>&gt; let testRandomValue = random(from: 4..&lt;8)<br>&gt; <br>&gt; But this will not let me do:<br>&gt; <br>&gt; let otherTestRandomValue = random(from: 4...10)<br>&gt; <br>&gt; The error message is a bit cryptic:<br>&gt; <br>&gt; “No ‘…’ candidate produce the expected contextual result type ‘Range&lt;Int&gt;’”<br>&gt; <br>&gt; What is happening is that 4…10 is not a Range, but a ClosedRange.<br>&gt; <br>&gt; Of course I can overload my function above to add a version that takes a ClosedRange.<br>&gt; <br>&gt; But this is not very DRY.<br>&gt; <br>&gt; What would be a more idiomatic way?<br>&gt; <br>&gt; Thanks,<br>&gt; <br>&gt; Jean-Denis<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20161012/a7300d80/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9f3e3f9871fd088e42df4509aa724367?s=50"></div><header><strong>How to be DRY on ranges and closed ranges?</strong> from <string>Adriano Ferreira</string> &lt;adriano.ferreira at me.com&gt;<p>October 12, 2016 at 04:00:00pm</p></header><div class="content"><p>Hi there!<br></p><p>Ole Begeman offers here &lt;https://oleb.net/blog/2016/09/swift-3-ranges/&gt; (take a look at the bottom of the page) an interesting consideration about converting between half-open and closed ranges.<br></p><p>As of now, it seems the way to go is by overloading…<br></p><p><br>import Foundation<br></p><p>func random(from range: Range&lt;Int&gt;) -&gt; Int {<br>    let lowerBound = range.lowerBound<br>    let upperBound = range.upperBound<br>    <br>    return lowerBound + Int(arc4random_uniform(UInt32(upperBound - lowerBound)))<br>}<br></p><p>func random(from range: ClosedRange&lt;Int&gt;) -&gt; Int {<br>    let lowerBound = range.lowerBound<br>    let upperBound = range.upperBound<br>    <br>    return lowerBound + Int(arc4random_uniform(UInt32(upperBound - lowerBound + 1)))<br>}<br></p><p>let r1 = random(from: 4 ..&lt; 8)<br>let r2 = random(from: 6 ... 8)<br></p><p><br>Cheers,<br></p><p>— A<br></p><p>&gt; On Oct 12, 2016, at 6:21 AM, Jean-Denis Muys via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi,<br>&gt; <br>&gt; I defined this:<br>&gt; <br>&gt; func random(from r: Range&lt;Int&gt;) -&gt; Int {<br>&gt;     let from = r.lowerBound<br>&gt;     let to =  r.upperBound<br>&gt;     <br>&gt;     let rnd = arc4random_uniform(UInt32(to-from))<br>&gt;     return from + Int(rnd)<br>&gt; }<br>&gt; <br>&gt; so that I can do:<br>&gt; <br>&gt; let testRandomValue = random(from: 4..&lt;8)<br>&gt; <br>&gt; But this will not let me do:<br>&gt; <br>&gt; let otherTestRandomValue = random(from: 4...10)<br>&gt; <br>&gt; The error message is a bit cryptic:<br>&gt; <br>&gt; “No ‘…’ candidate produce the expected contextual result type ‘Range&lt;Int&gt;’”<br>&gt; <br>&gt; What is happening is that 4…10 is not a Range, but a ClosedRange.<br>&gt; <br>&gt; Of course I can overload my function above to add a version that takes a ClosedRange.<br>&gt; <br>&gt; But this is not very DRY.<br>&gt; <br>&gt; What would be a more idiomatic way?<br>&gt; <br>&gt; Thanks,<br>&gt; <br>&gt; Jean-Denis<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20161012/efeaf694/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e7e554db1f80d7d6041d92edd5145698?s=50"></div><header><strong>How to be DRY on ranges and closed ranges?</strong> from <string>Hooman Mehr</string> &lt;hooman at mac.com&gt;<p>October 12, 2016 at 04:00:00pm</p></header><div class="content"><p>I recommend having explicit precondition and reducing repetition like this:<br></p><p>import Foundation<br></p><p>func random(from range: CountableRange&lt;Int&gt;) -&gt; Int {<br>    <br>    precondition(range.count &gt; 0,<br>                 &quot;The range can&#39;t be empty.&quot;)<br></p><p>    return random(from: CountableClosedRange(range))<br>}<br></p><p>func random(from range: CountableClosedRange&lt;Int&gt;) -&gt; Int {<br>    <br>    let lowerBound = range.lowerBound<br>    let upperBound = range.upperBound<br>    <br>    precondition(upperBound - lowerBound &lt; Int(UInt32.max),<br>                 &quot;The range \(range) is too wide. It shouldn&#39;t be wider than \(UInt32.max).&quot;)<br>    <br>    return lowerBound + Int(arc4random_uniform(UInt32(upperBound - lowerBound + 1)))<br>}<br></p><p>let r1 = random(from: 4 ..&lt; 8)<br>let r2 = random(from: 6 ... 8)<br></p><p>Once we have the new improved Integer protocols &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0104-improved-integers.md&gt; in place, you will be able to make it generic to support all integer types. (It is possible now, but too messy to be worth doing.)<br></p><p><br>&gt; On Oct 12, 2016, at 1:23 PM, Adriano Ferreira via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; Hi there!<br>&gt; <br>&gt; Ole Begeman offers here &lt;https://oleb.net/blog/2016/09/swift-3-ranges/&gt; (take a look at the bottom of the page) an interesting consideration about converting between half-open and closed ranges.<br>&gt; <br>&gt; As of now, it seems the way to go is by overloading…<br>&gt; <br>&gt; <br>&gt; import Foundation<br>&gt; <br>&gt; func random(from range: Range&lt;Int&gt;) -&gt; Int {<br>&gt;     let lowerBound = range.lowerBound<br>&gt;     let upperBound = range.upperBound<br>&gt;     <br>&gt;     return lowerBound + Int(arc4random_uniform(UInt32(upperBound - lowerBound)))<br>&gt; }<br>&gt; <br>&gt; func random(from range: ClosedRange&lt;Int&gt;) -&gt; Int {<br>&gt;     let lowerBound = range.lowerBound<br>&gt;     let upperBound = range.upperBound<br>&gt;     <br>&gt;     return lowerBound + Int(arc4random_uniform(UInt32(upperBound - lowerBound + 1)))<br>&gt; }<br>&gt; <br>&gt; let r1 = random(from: 4 ..&lt; 8)<br>&gt; let r2 = random(from: 6 ... 8)<br>&gt; <br>&gt; <br>&gt; Cheers,<br>&gt; <br>&gt; — A<br>&gt; <br>&gt;&gt; On Oct 12, 2016, at 6:21 AM, Jean-Denis Muys via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi,<br>&gt;&gt; <br>&gt;&gt; I defined this:<br>&gt;&gt; <br>&gt;&gt; func random(from r: Range&lt;Int&gt;) -&gt; Int {<br>&gt;&gt;     let from = r.lowerBound<br>&gt;&gt;     let to =  r.upperBound<br>&gt;&gt;     <br>&gt;&gt;     let rnd = arc4random_uniform(UInt32(to-from))<br>&gt;&gt;     return from + Int(rnd)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; so that I can do:<br>&gt;&gt; <br>&gt;&gt; let testRandomValue = random(from: 4..&lt;8)<br>&gt;&gt; <br>&gt;&gt; But this will not let me do:<br>&gt;&gt; <br>&gt;&gt; let otherTestRandomValue = random(from: 4...10)<br>&gt;&gt; <br>&gt;&gt; The error message is a bit cryptic:<br>&gt;&gt; <br>&gt;&gt; “No ‘…’ candidate produce the expected contextual result type ‘Range&lt;Int&gt;’”<br>&gt;&gt; <br>&gt;&gt; What is happening is that 4…10 is not a Range, but a ClosedRange.<br>&gt;&gt; <br>&gt;&gt; Of course I can overload my function above to add a version that takes a ClosedRange.<br>&gt;&gt; <br>&gt;&gt; But this is not very DRY.<br>&gt;&gt; <br>&gt;&gt; What would be a more idiomatic way?<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; <br>&gt;&gt; Jean-Denis<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20161012/02537f2f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8149b5bd66abbc94babfda2995153481?s=50"></div><header><strong>How to be DRY on ranges and closed ranges?</strong> from <string>Nevin Brackett-Rozinsky</string> &lt;nevin.brackettrozinsky at gmail.com&gt;<p>October 12, 2016 at 07:00:00pm</p></header><div class="content"><p>You could also create a “Range” protocol with “lowerBound” and “upperBound”<br>properties. Conform all the range types to it, and make your function take<br>generic over the protocol.<br></p><p>Nevin<br></p><p><br>On Wed, Oct 12, 2016 at 7:21 PM, Hooman Mehr via swift-users &lt;<br>swift-users at swift.org&gt; wrote:<br></p><p>&gt; I recommend having explicit precondition and reducing repetition like this:<br>&gt;<br>&gt; import Foundation<br>&gt;<br>&gt; func random(from range: CountableRange&lt;Int&gt;) -&gt; Int {<br>&gt;<br>&gt;     precondition(range.count &gt; 0,<br>&gt;                  &quot;The range can&#39;t be empty.&quot;)<br>&gt;<br>&gt;     return random(from: CountableClosedRange(range))<br>&gt; }<br>&gt;<br>&gt; func random(from range: CountableClosedRange&lt;Int&gt;) -&gt; Int {<br>&gt;<br>&gt;     let lowerBound = range.lowerBound<br>&gt;     let upperBound = range.upperBound<br>&gt;<br>&gt;     precondition(upperBound - lowerBound &lt; Int(UInt32.max),<br>&gt;                  &quot;The range \(range) is too wide. It shouldn&#39;t be wider<br>&gt; than \(UInt32.max).&quot;)<br>&gt;<br>&gt;     return lowerBound + Int(arc4random_uniform(UInt32(upperBound -<br>&gt; lowerBound + 1)))<br>&gt; }<br>&gt;<br>&gt; let r1 = random(from: 4 ..&lt; 8)<br>&gt; let r2 = random(from: 6 ... 8)<br>&gt;<br>&gt; Once we have the new improved Integer protocols<br>&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0104-improved-integers.md&gt; in<br>&gt; place, you will be able to make it generic to support all integer types.<br>&gt; (It is possible now, but too messy to be worth doing.)<br>&gt;<br>&gt;<br>&gt; On Oct 12, 2016, at 1:23 PM, Adriano Ferreira via swift-users &lt;<br>&gt; swift-users at swift.org&gt; wrote:<br>&gt;<br>&gt; Hi there!<br>&gt;<br>&gt; Ole Begeman offers here &lt;https://oleb.net/blog/2016/09/swift-3-ranges/&gt; (take<br>&gt; a look at the bottom of the page) an interesting consideration about<br>&gt; converting between half-open and closed ranges.<br>&gt;<br>&gt; As of now, it seems the way to go is by overloading…<br>&gt;<br>&gt;<br>&gt; import Foundation<br>&gt;<br>&gt; func random(from range: Range&lt;Int&gt;) -&gt; Int {<br>&gt;     let lowerBound = range.lowerBound<br>&gt;     let upperBound = range.upperBound<br>&gt;<br>&gt;     return lowerBound + Int(arc4random_uniform(UInt32(upperBound -<br>&gt; lowerBound)))<br>&gt; }<br>&gt;<br>&gt; func random(from range: ClosedRange&lt;Int&gt;) -&gt; Int {<br>&gt;     let lowerBound = range.lowerBound<br>&gt;     let upperBound = range.upperBound<br>&gt;<br>&gt;     return lowerBound + Int(arc4random_uniform(UInt32(upperBound -<br>&gt; lowerBound + 1)))<br>&gt; }<br>&gt;<br>&gt; let r1 = random(from: 4 ..&lt; 8)<br>&gt; let r2 = random(from: 6 ... 8)<br>&gt;<br>&gt;<br>&gt; Cheers,<br>&gt;<br>&gt; — A<br>&gt;<br>&gt; On Oct 12, 2016, at 6:21 AM, Jean-Denis Muys via swift-users &lt;<br>&gt; swift-users at swift.org&gt; wrote:<br>&gt;<br>&gt; Hi,<br>&gt;<br>&gt; I defined this:<br>&gt;<br>&gt; func random(from r: Range&lt;Int&gt;) -&gt; Int {<br>&gt;     let from = r.lowerBound<br>&gt;     let to =  r.upperBound<br>&gt;<br>&gt;     let rnd = arc4random_uniform(UInt32(to-from))<br>&gt;     return from + Int(rnd)<br>&gt; }<br>&gt;<br>&gt; so that I can do:<br>&gt;<br>&gt; let testRandomValue = random(from: 4..&lt;8)<br>&gt;<br>&gt; But this will not let me do:<br>&gt;<br>&gt; let otherTestRandomValue = random(from: 4...10)<br>&gt;<br>&gt; The error message is a bit cryptic:<br>&gt;<br>&gt; “No ‘…’ candidate produce the expected contextual result type ‘Range&lt;Int&gt;’”<br>&gt;<br>&gt; What is happening is that 4…10 is not a Range, but a ClosedRange.<br>&gt;<br>&gt; Of course I can overload my function above to add a version that takes a<br>&gt; ClosedRange.<br>&gt;<br>&gt; But this is not very DRY.<br>&gt;<br>&gt; What would be a more idiomatic way?<br>&gt;<br>&gt; Thanks,<br>&gt;<br>&gt; Jean-Denis<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20161012/6d069416/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4dbaecb52d6f4b228bde8ea586b2fbe3?s=50"></div><header><strong>How to be DRY on ranges and closed ranges?</strong> from <string>Hooman Mehr</string> &lt;hooman.mehr at gmail.com&gt;<p>October 12, 2016 at 04:00:00pm</p></header><div class="content"><p>I recommend having explicit precondition and reducing repetition like this:<br></p><p>import Foundation<br></p><p>func random(from range: CountableRange&lt;Int&gt;) -&gt; Int {<br>    <br>    precondition(range.count &gt; 0,<br>                 &quot;The range can&#39;t be empty.&quot;)<br></p><p>    return random(from: CountableClosedRange(range))<br>}<br></p><p>func random(from range: CountableClosedRange&lt;Int&gt;) -&gt; Int {<br>    <br>    let lowerBound = range.lowerBound<br>    let upperBound = range.upperBound<br>    <br>    precondition(upperBound - lowerBound &lt; Int(UInt32.max),<br>                 &quot;The range \(range) is too wide. It shouldn&#39;t be wider than \(UInt32.max).&quot;)<br>    <br>    return lowerBound + Int(arc4random_uniform(UInt32(upperBound - lowerBound + 1)))<br>}<br></p><p>let r1 = random(from: 4 ..&lt; 8)<br>let r2 = random(from: 6 ... 8)<br></p><p>Once we have the new improved Integer protocols &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0104-improved-integers.md&gt; in place, you will be able to make it generic to support all integer types. (It is possible now, but too messy to be worth doing.)<br></p><p><br>&gt; On Oct 12, 2016, at 1:23 PM, Adriano Ferreira via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi there!<br>&gt; <br>&gt; Ole Begeman offers here &lt;https://oleb.net/blog/2016/09/swift-3-ranges/&gt; (take a look at the bottom of the page) an interesting consideration about converting between half-open and closed ranges.<br>&gt; <br>&gt; As of now, it seems the way to go is by overloading…<br>&gt; <br>&gt; <br>&gt; import Foundation<br>&gt; <br>&gt; func random(from range: Range&lt;Int&gt;) -&gt; Int {<br>&gt;     let lowerBound = range.lowerBound<br>&gt;     let upperBound = range.upperBound<br>&gt;     <br>&gt;     return lowerBound + Int(arc4random_uniform(UInt32(upperBound - lowerBound)))<br>&gt; }<br>&gt; <br>&gt; func random(from range: ClosedRange&lt;Int&gt;) -&gt; Int {<br>&gt;     let lowerBound = range.lowerBound<br>&gt;     let upperBound = range.upperBound<br>&gt;     <br>&gt;     return lowerBound + Int(arc4random_uniform(UInt32(upperBound - lowerBound + 1)))<br>&gt; }<br>&gt; <br>&gt; let r1 = random(from: 4 ..&lt; 8)<br>&gt; let r2 = random(from: 6 ... 8)<br>&gt; <br>&gt; <br>&gt; Cheers,<br>&gt; <br>&gt; — A<br>&gt; <br>&gt;&gt; On Oct 12, 2016, at 6:21 AM, Jean-Denis Muys via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi,<br>&gt;&gt; <br>&gt;&gt; I defined this:<br>&gt;&gt; <br>&gt;&gt; func random(from r: Range&lt;Int&gt;) -&gt; Int {<br>&gt;&gt;     let from = r.lowerBound<br>&gt;&gt;     let to =  r.upperBound<br>&gt;&gt;     <br>&gt;&gt;     let rnd = arc4random_uniform(UInt32(to-from))<br>&gt;&gt;     return from + Int(rnd)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; so that I can do:<br>&gt;&gt; <br>&gt;&gt; let testRandomValue = random(from: 4..&lt;8)<br>&gt;&gt; <br>&gt;&gt; But this will not let me do:<br>&gt;&gt; <br>&gt;&gt; let otherTestRandomValue = random(from: 4...10)<br>&gt;&gt; <br>&gt;&gt; The error message is a bit cryptic:<br>&gt;&gt; <br>&gt;&gt; “No ‘…’ candidate produce the expected contextual result type ‘Range&lt;Int&gt;’”<br>&gt;&gt; <br>&gt;&gt; What is happening is that 4…10 is not a Range, but a ClosedRange.<br>&gt;&gt; <br>&gt;&gt; Of course I can overload my function above to add a version that takes a ClosedRange.<br>&gt;&gt; <br>&gt;&gt; But this is not very DRY.<br>&gt;&gt; <br>&gt;&gt; What would be a more idiomatic way?<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; <br>&gt;&gt; Jean-Denis<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20161012/1430d8b0/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e7e554db1f80d7d6041d92edd5145698?s=50"></div><header><strong>How to be DRY on ranges and closed ranges?</strong> from <string>Hooman Mehr</string> &lt;hooman at mac.com&gt;<p>October 12, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Oct 12, 2016, at 3:21 AM, Jean-Denis Muys via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; But this is not very DRY.<br>&gt; <br>&gt; What would be a more idiomatic way?<br>&gt; <br></p><p>The more idiomatic way is to look at API design in a new way. Note these points:<br></p><p>1. `Countable` variant is preferred when you want to deal with integer ranges as it more closely matches the element type.<br>2. Both countable range variants share a common protocol conformance already: `RandomAccessCollection`<br>3. Swift API design prefers member functions to free functions.<br></p><p>Hence a more idiomatic (Swifty) API would probably be something like this:<br></p><p>extension RandomAccessCollection {<br>    <br>    func random() -&gt; Iterator.Element? {<br>        <br>        guard count &gt; 0 else { return nil }<br>        <br>        let offset = arc4random_uniform(numericCast(count))<br>        <br>        let i = index(startIndex, offsetBy: numericCast(offset))<br>        <br>        return self[i]<br>    }<br>}<br></p><p>Using the above, both cases work and there is no repetition:<br></p><p>(4..&lt;10).random()<br>(4...9).random()<br></p><p>It also makes a lot more possible: <br></p><p>let people = [&quot;David&quot;, &quot;Chris&quot;, &quot;Joe&quot;, &quot;Jordan&quot;, &quot;Tony&quot;]<br>let winner = people.random()<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20161012/bf96961d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d0efc09d023fa0569a2479c9dcfd4620?s=50"></div><header><strong>How to be DRY on ranges and closed ranges?</strong> from <string>Ole Begemann</string> &lt;ole at oleb.net&gt;<p>October 13, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; The more idiomatic way is to look at API design in a new way. Note these<br>&gt; points:<br>&gt;<br>&gt; 1. `Countable` variant is preferred when you want to deal with integer<br>&gt; ranges as it more closely matches the element type.<br>&gt; 2. Both countable range variants share a common protocol conformance<br>&gt; already: `RandomAccessCollection`<br>&gt; 3. Swift API design prefers member functions to free functions.<br>&gt;<br>&gt; Hence a more idiomatic (Swifty) API would probably be something like this:<br></p><p>Thanks for sharing this solution, Hooman, I really like it. I think <br>you&#39;re making a great point about considering the appropriate <br>abstraction for an algorithm, which is why I blogged about this: <br>https://oleb.net/blog/2016/10/generic-range-algorithms/<br></p><p>I hope you don&#39;t mind.<br></p><p>Ole<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
