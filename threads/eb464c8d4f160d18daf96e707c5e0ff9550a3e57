<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Review] SE-0045: Add scan, prefix(while:), drop(while:), and iterate to the stdlib</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>April 28, 2016 at 11:00:00am</p></header><div class="content"><p>Hello Swift community,<br></p><p>The review of &quot;SE-0045: Add scan, prefix(while:), drop(while:), and iterate to the stdlib&quot; begins now and runs through May 3. The proposal is available here:<br></p><p>	https://github.com/apple/swift-evolution/blob/master/proposals/0045-scan-takewhile-dropwhile.md<br></p><p>Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br></p><p>	https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>or, if you would like to keep your feedback private, directly to the review manager.<br></p><p>What goes into a review?<br></p><p>The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br></p><p>	* What is your evaluation of the proposal?<br>	* Is the problem being addressed significant enough to warrant a change to Swift?<br>	* Does this proposal fit well with the feel and direction of Swift?<br>	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>More information about the Swift evolution process is available at<br></p><p>	https://github.com/apple/swift-evolution/blob/master/process.md<br></p><p>Thank you,<br></p><p>-Chris Lattner<br>Review Manager<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0045: Add scan, prefix(while:), drop(while:), and iterate to the stdlib</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>April 28, 2016 at 11:00:00am</p></header><div class="content"><p>One thing I&#39;ve been thinking about with regards to the existing `reduce` operation is whether it would be better expressed in Swift as taking its closure as (inout State, Element) -&gt; Void rather than (State, Element) -&gt; State. Doing so would avoid many of the accidentally-quadratic issues with the current formulation of reduce:<br></p><p>	arrayOfArrays.reduce([], combine: +) // quadratic temporary arrays<br>	arrayOfArrays.inPlaceReduce([], combine: +=) // can be linear by appending arrays in-place<br></p><p>Thanks to the scoped semantics of `inout`, there&#39;s no hazard of the mutable state reference being escaped, so the inout form is isomorphic to the traditional pure form of reduce.<br></p><p>Now `scan`-ing to generate an array of intermediate arrays is inherently quadratic, since each intermediate array shows up as a distinct copy in the resulting collection. However, if someone used `scan` to produce a sequence of tree data structures instead of flat arrays, it could still be interesting to share structure among the intermediate states collected by `scan` by performing an in-place operation to generate new values instead of an out-of-place operation. It might be interesting to consider a similar signature change to `scan` for these same reasons.<br></p><p>-Joe<br></p><p>&gt; On Apr 28, 2016, at 11:11 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;SE-0045: Add scan, prefix(while:), drop(while:), and iterate to the stdlib&quot; begins now and runs through May 3. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0045-scan-takewhile-dropwhile.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0045: Add scan, prefix(while:), drop(while:), and iterate to the stdlib</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>April 29, 2016 at 02:00:00pm</p></header><div class="content"><p>On Thu, Apr 28, 2016, at 11:48 AM, Joe Groff via swift-evolution wrote:<br>&gt; One thing I&#39;ve been thinking about with regards to the existing `reduce` operation is whether it would be better expressed in Swift as taking its closure as (inout State, Element) -&gt; Void rather than (State, Element) -&gt; State. Doing so would avoid many of the accidentally-quadratic issues with the current formulation of reduce:<br>&gt; <br>&gt; 	arrayOfArrays.reduce([], combine: +) // quadratic temporary arrays<br>&gt; 	arrayOfArrays.inPlaceReduce([], combine: +=) // can be linear by appending arrays in-place<br>&gt; <br>&gt; Thanks to the scoped semantics of `inout`, there&#39;s no hazard of the mutable state reference being escaped, so the inout form is isomorphic to the traditional pure form of reduce.<br>&gt; <br>&gt; Now `scan`-ing to generate an array of intermediate arrays is inherently quadratic, since each intermediate array shows up as a distinct copy in the resulting collection. However, if someone used `scan` to produce a sequence of tree data structures instead of flat arrays, it could still be interesting to share structure among the intermediate states collected by `scan` by performing an in-place operation to generate new values instead of an out-of-place operation. It might be interesting to consider a similar signature change to `scan` for these same reasons.<br></p><p>That&#39;s an interesting idea. Taking the state as an inout parameter seems useful, but it does mean breaking with precedent from other languages and I do worry slightly about the ergonomics (not all operations have mutating counterparts, though you could also say that there&#39;s mutating methods that don&#39;t have trivial non-mutating versions too).<br></p><p>That said, regarding using `scan` to produce a sequence of tree data structures, I&#39;d expect non-mutating operations to be able to share state just as effectively as COW mutating operations.<br></p><p>-Kevin<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8e77369a540cf4d35924683e176c7a9c?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0045: Add scan, prefix(while:), drop(while:), and iterate to the stdlib</strong> from <string>Mark Lacey</string> &lt;mark.lacey at apple.com&gt;<p>April 28, 2016 at 12:00:00pm</p></header><div class="content"><p>I haven’t read through the complete proposal in detail, but regarding the ‘scan’ operation I would like to point out that the definition given in the example matches the semantics of what is usually called ‘prescan&#39; or &#39;exclusive scan&#39;, whereas ‘scan’ (aka ‘inclusive scan’ or ‘prefix sum’) would not include the identity element, and each position of the result would include applying the operator to the elements up to and including the element in the same position of the source array, e.g.:<br></p><p>  (1..&lt;6).scan(combine: +) // [1, 3, 6, 10, 15, 21]<br></p><p>Sources:<br>  https://www.cs.cmu.edu/~guyb/papers/Ble93.pdf<br>  https://en.wikipedia.org/wiki/Prefix_sum<br></p><p>Mark<br></p><p><br>&gt; On Apr 28, 2016, at 11:11 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;SE-0045: Add scan, prefix(while:), drop(while:), and iterate to the stdlib&quot; begins now and runs through May 3. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0045-scan-takewhile-dropwhile.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution-announce mailing list<br>&gt; swift-evolution-announce at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution-announce<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160428/70e361b8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0045: Add scan, prefix(while:), drop(while:), and iterate to the stdlib</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>April 29, 2016 at 02:00:00pm</p></header><div class="content"><p>On Thu, Apr 28, 2016, at 12:30 PM, Mark Lacey via swift-evolution wrote:<br>&gt; I haven’t read through the complete proposal in detail, but regarding<br>&gt; the ‘scan’ operation I would like to point out that the definition<br>&gt; given in the example matches the semantics of what is usually called<br>&gt; ‘prescan&#39; or &#39;exclusive scan&#39;, whereas ‘scan’ (aka ‘inclusive scan’ or<br>&gt; ‘prefix sum’) would not include the identity element, and each<br>&gt; position of the result would include applying the operator to the<br>&gt; elements up to and including the element in the same position of the<br>&gt; source array, e.g.:<br>&gt;<br>&gt; (1..&lt;6).scan(combine: +) // [1, 3, 6, 10, 15, 21]<br>&gt;<br>&gt; Sources:<br>&gt; https://www.cs.cmu.edu/~guyb/papers/Ble93.pdf<br>&gt; https://en.wikipedia.org/wiki/Prefix_sum<br> <br>Interesting, I was not aware of the distinction here. The `scan` method<br>as proposed here matches the behavior of Haskell&#39;s `scanl` method<br>(http://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:scanl)<br>.<br> <br>I&#39;m in favor of keeping the behavior as-is, because the &quot;inclusive scan&quot;<br>behavior can be recovered trivially by calling `.dropFirst()` on the<br>resulting sequence, whereas recovering prescan from inclusive scan is<br>not so trivial.<br> <br>-Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160429/e35a5b81/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0045: Add scan, prefix(while:), drop(while:), and iterate to the stdlib</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>April 28, 2016 at 02:00:00pm</p></header><div class="content"><p>I’m passing on some feedback from a contributor who preferred to remain anonymous / offlist and emailed the review manager.  These are not my personal comments:<br></p><p>On Apr 28, 2016, at 11:11 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; Proposal:<br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0045-scan-takewhile-dropwhile.md<br>&gt; <br></p><p>I would really like a different name for scan. While it’s the term of art for Haskell and co, it really seems meaningless to regular programmers (why is “scanning” the way you produce an array of intermediate reduces?), and it would be better to follow the pattern already established elsewhere in the library to give friendlier names e.g. flatMap instead of bind, reduce instead of fold.<br></p><p>I think Python calls it accumulate: http://docs.python.org/3/library/itertools.html#itertools.accumulate<br></p><p>While this isn’t great either, because you can think of reduce as “accumulating” a value, I still think it’ll be easy for people to understand the difference and remember which is which (since reducing sounds like boiling down, accumulating more like gathering multiple things and sounds similar to “cumulative”).<br></p><p>I also think it would be nice for both scan and reduce to have overloads that take the first value as the initial (and return an optional) but that’s probably a separate proposal.<br></p><p>Other than that, I think these will all make very useful additions to the library.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0045: Add scan, prefix(while:), drop(while:), and iterate to the stdlib</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>April 29, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; I would really like a different name for scan. While it’s the term of art for Haskell and co, it really seems meaningless to regular programmers (why is “scanning” the way you produce an array of intermediate reduces?), and it would be better to follow the pattern already established elsewhere in the library to give friendlier names e.g. flatMap instead of bind, reduce instead of fold.<br>&gt; <br>&gt; I think Python calls it accumulate: http://docs.python.org/3/library/itertools.html#itertools.accumulate &lt;http://docs.python.org/3/library/itertools.html#itertools.accumulate&gt;<br></p><p>FWIW, Clojure calls it `reductions &lt;http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/reductions&gt;` which aligns pretty nicely with the `reduce` counterpart.<br></p><p>&gt; I also think it would be nice for both scan and reduce to have overloads that take the first value as the initial (and return an optional) but that’s probably a separate proposal.<br></p><p>+1<br></p><p>— Pyry<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160429/78318041/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0045: Add scan, prefix(while:), drop(while:), and iterate to the stdlib</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>April 29, 2016 at 02:00:00pm</p></header><div class="content"><p>On Thu, Apr 28, 2016, at 02:13 PM, Pyry Jahkola via swift-evolution wrote:<br>&gt;&gt; I would really like a different name for scan. While it’s the term of<br>&gt;&gt; art for Haskell and co, it really seems meaningless to regular<br>&gt;&gt; programmers (why is “scanning” the way you produce an array of<br>&gt;&gt; intermediate reduces?), and it would be better to follow the pattern<br>&gt;&gt; already established elsewhere in the library to give friendlier names<br>&gt;&gt; e.g. flatMap instead of bind, reduce instead of fold.<br>&gt;&gt;<br>&gt;&gt; I think Python calls it accumulate:<br>&gt;&gt; http://docs.python.org/3/library/itertools.html#itertools.accumulate<br>&gt;<br>&gt; FWIW, Clojure calls it `reductions[1]` which aligns pretty nicely with<br>&gt; the `reduce` counterpart.<br> <br>I like it.<br> <br>-Kevin Ballard<br></p><p>Links:<br></p><p>  1. http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/reductions<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160429/84610262/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Review] SE-0045: Add scan, prefix(while:), drop(while:), and iterate to the stdlib</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April 28, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; 	* What is your evaluation of the proposal?<br></p><p>Great and necessary. I particularly like that the combination of `iterate(1, apply: { $0 * 2 }).prefix(while: { $0 &lt; 100_000 })` mimics the abilities of the old C-style for loop.<br></p><p>Bikeshedding time!<br></p><p>* * *<br></p><p>I really like the `reduce`/`reductions` pairing instead of `reduce`/`scan`; it does a really good job of explaining the relationship between the two functions. I also think the `startingWith` label may be a good idea, although if we do that, we might want to change the second label to `combiningWith`.<br></p><p>* * *<br></p><p>I believe that `prefix(while:)` and `dropFirst(while:)` would be most consistent with the current standard library, but frankly, I consider that an indictment of the current names.<br></p><p>`skip` is better than `drop`, but they are both pigs; one&#39;s just wearing lipstick. The whole area of APIs which grab subsets of Sequences or Collections could use some renaming. It is rife with both inconsistencies (`prefix(_:)` and `dropFirst(_:)` are inverses, but look unrelated) and names which appear to mutate but don&#39;t (all the `drop` APIs). These APIs are currently grandfathered in with the term-of-art rule, which I normally agree with, but I think the results here are so bad that we can&#39;t let them stand.<br></p><p>I would suggest that we systematically rename these APIs to achieve a consistent, non-verb-based pattern which the new APIs can slot into nicely:<br></p><p>	first								// Currently first<br>	prefix(_: Int)						// Currently prefix(_:)<br>	prefix(while: Element -&gt; Bool)			// Proposed as prefix(while:)<br>	<br>	afterFirst() or afterFirst				// Currently dropFirst()<br>	afterPrefix(_: Int)					// Currently dropFirst(_:)<br>	afterPrefix(while: Element -&gt; Bool)		// Proposed as drop(while:)<br></p><p>	last								// Currently last<br>	suffix(_: Int)						// Currently suffix(_:)<br>	suffix(while: Element -&gt; Bool)			// Unproposed<br>	<br>	beforeLast() or beforeLast			// Currently dropLast()<br>	beforeSuffix(_: Int)					// Currently dropLast(_:)<br>	beforeSuffix(while: Element -&gt; Bool)	// Unproposed<br></p><p>	before(to: Index)					// Currently prefix(upTo:)<br>	before(through: Index)				// Currently prefix(through:)<br>	<br>	after(to: Index)						// Unproposed?<br>	after(through: Index)				// suffix(from:)?<br></p><p>Several of these APIs are listed as &quot;unproposed&quot;; they are neither in the current standard library, nor in this proposal. I am not suggesting we add them, but simply showing how they would be named if they *were* provided.<br></p><p>If the core team wants to protect `dropFirst` and `dropLast` as terms of art, I think our best alternative is to make `first` and `last` nullary methods, and rename the `prefix` methods to `first` and `suffix` to `last`. It seems like the decision to make `first` and `last` properties was a little bit uncertain to begin with; I think the naming issues here tip the scales.<br></p><p>In any case, though, the core team might prefer to consider this relatively large renaming as a separate proposal. If so, as I said, I think `prefix(while:)` and `dropFirst(while:)` are the best matches for the current APIs.<br></p><p>* * *<br></p><p>I think `iterate` is the best basic approach to the name. My own prototypes used `induce` since the sequence was produced by induction from a starting value and transformation function, but this approach was too clever by half: people were confused by the name until it was explained, and then they thought it was clever but had trouble remembering it.<br></p><p>There is precedent in the current standard library for using an imperative verb to lazily construct a list: the `repeatElement(_:count:)` function. However, if we don&#39;t like that for this case, an alternative is to use the noun `iteration`. And if we&#39;re going with the noun, well, that suggests that what we really want to define is not a function, but a type:<br></p><p>	struct Iteration&lt;T&gt;: Sequence {<br>		init(start startingValue: T, apply transformation: T -&gt; T)<br>	}<br></p><p>This reads fairly well in common uses:<br></p><p>	for i in Iteration(start: 1, apply: { $0 * 2 }) { … }<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes. As I mentioned before, the combination of `iterate` and `prefix(while:)` is particularly important.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes; these fill important holes in our ability to create and manipulate sequences.<br></p><p>&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>Most languages I&#39;ve used which have these features give them terrible names; these names help make them less accessible. I&#39;m hoping that Swift will do better.<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>Read the review a few times, independently re-invented about half of it in various discussions and explorations of the C-style for loop removal.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Review] SE-0045: Add scan, prefix(while:), drop(while:), and iterate to the stdlib</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April 29, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Apr 28, 2016, at 10:15 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; I believe that `prefix(while:)` and `dropFirst(while:)` would be most consistent with the current standard library, but frankly, I consider that an indictment of the current names.<br>&gt; `skip` is better than `drop`, but they are both pigs; one&#39;s just wearing lipstick.<br></p><p>This is a great place to bring up &quot;terms of art&quot;, again. When looking to other languages as our muse, trying to adapt syntax into Swift&#39;s tortured guidance system is less successful than retaining those terms, which have already been extensively bikeshedded in their original development. I much prefer takeWhile dropWhile, etc.<br></p><p>-- E<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/15ed660cd9d971062f9dd5084932a698?s=50"></div><header><strong>[Review] SE-0045: Add scan, prefix(while:), drop(while:), and iterate to the stdlib</strong> from <string>David Rönnqvist</string> &lt;david.ronnqvist at gmail.com&gt;<p>April 29, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; 	* What is your evaluation of the proposal?<br></p><p>+1 This is a useful addition.<br></p><p>As other have already pointed out, I also feel that `scan` is the least intuitive name among these and that the `reduce`/`reductions` pairing would do a good job at explaining the relation between the two.<br></p><p>If I’ve understood the evolution process correctly, the broader naming of existing prefix, suffix, split, dropFirst, dropLast, etc. functions is not in scope of this proposal. Given that, I feel that the main goal regarding naming the proposed functions is to fit in well with the existing name. I feel that there is a small “term of art” argument to be made for takeWhile/dropWhile, but also that prefix(while:)/drop(while:) is a closer match to Swifts naming of similar existing functions. I don’t have strong preferences for either of these naming and would be absolutely fine with either.<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes, these are good building blocks for other functionality and are useful additions to the standard library <br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes, in both naming and functionality it fits well with existing functions for operating on sequences and collections <br></p><p>&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>I wonder if something like Haskell’s [`span`][1] (returning a tuple of `prefix(while:)` and `drop(while:)` would be a good addition alongside these. It also doesn’t have a very intuitive name, so in that case we would have to come up with something better. <br></p><p>[1]: http://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:span <br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>Read of the proposal, read the evolution proposal thread, and a small study of similar features in other languages.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0045: Add scan, prefix(while:), drop(while:), and iterate to the stdlib</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>April 29, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Apr 29, 2016, at 9:44 AM, David Rönnqvist via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; 	* What is your evaluation of the proposal?<br></p><p>+1 in general, with some reservations about naming.<br></p><p>&gt; <br>&gt; +1 This is a useful addition.<br>&gt; <br>&gt; As other have already pointed out, I also feel that `scan` is the least intuitive name among these and that the `reduce`/`reductions` pairing would do a good job at explaining the relation between the two.<br></p><p><br>I agree that scan is not a great name and reductions is much more clear.<br></p><p>&gt; <br>&gt; If I’ve understood the evolution process correctly, the broader naming of existing prefix, suffix, split, dropFirst, dropLast, etc. functions is not in scope of this proposal. Given that, I feel that the main goal regarding naming the proposed functions is to fit in well with the existing name. I feel that there is a small “term of art” argument to be made for takeWhile/dropWhile, but also that prefix(while:)/drop(while:) is a closer match to Swifts naming of similar existing functions. I don’t have strong preferences for either of these naming and would be absolutely fine with either.<br></p><p>I think the “term of art” argument for “take” rather than “prefix” is significant.  I would much prefer that name be used.  It is immediately clear, while “prefix&quot; isn’t nearly as clear IMO. <br></p><p>It would be fine with me if we accept this proposal as-is and have a future proposal to address the broader naming issue.<br></p><p>&gt; <br>&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; <br>&gt; Yes, these are good building blocks for other functionality and are useful additions to the standard library <br>&gt; <br>&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; <br>&gt; Yes, in both naming and functionality it fits well with existing functions for operating on sequences and collections <br>&gt; <br>&gt;&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; <br>&gt; I wonder if something like Haskell’s [`span`][1] (returning a tuple of `prefix(while:)` and `drop(while:)` would be a good addition alongside these. It also doesn’t have a very intuitive name, so in that case we would have to come up with something better. <br>&gt; <br>&gt; [1]: http://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:span <br>&gt; <br>&gt;&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; Read of the proposal, read the evolution proposal thread, and a small study of similar features in other languages.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Review] SE-0045: Add scan, prefix(while:), drop(while:), and iterate to the stdlib</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>April 29, 2016 at 02:00:00pm</p></header><div class="content"><p>On Thu, Apr 28, 2016, at 11:11 AM, Chris Lattner via swift-evolution wrote:<br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;SE-0045: Add scan, prefix(while:), drop(while:), and iterate to the stdlib&quot; begins now and runs through May 3. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0045-scan-takewhile-dropwhile.md<br></p><p>The proposal has been updated as per feedback from the core team (https://github.com/apple/swift-evolution/pull/275). This includes removing some last vestiges of Swift 2 naming as well as replacing `iterate(_:apply:)` with an overloaded function `unfold(_:applying:)`.<br></p><p>-Kevin Ballard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Review] SE-0045: Add scan, prefix(while:), drop(while:), and iterate to the stdlib</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May  1, 2016 at 04:00:00am</p></header><div class="content"><p>&gt; The proposal has been updated as per feedback from the core team (https://github.com/apple/swift-evolution/pull/275). This includes removing some last vestiges of Swift 2 naming as well as replacing `iterate(_:apply:)` with an overloaded function `unfold(_:applying:)`.<br></p><p>The proposal says this:<br></p><p>	public func unfold&lt;T, State&gt;(_ initialState: State, applying: State -&gt; (T, State)?) -&gt; UnfoldSequence&lt;T&gt;<br>	public func unfold&lt;T&gt;(_ initialElement: T, apply: T -&gt; T) -&gt; UnfoldSequence&lt;T&gt;<br></p><p>However, the comment implies that the second one should instead be this:<br></p><p>	public func unfold&lt;T&gt;(_ initialElement: T, applying: T -&gt; T?) -&gt; UnfoldSequence&lt;T&gt;<br></p><p>I&#39;m not sure I like having these be overloaded on only the return type of the closure. Maybe we could do something like this?<br></p><p>	public func unfold&lt;T, State&gt;(fromState initialState: State, applying: State -&gt; (T, State)?) -&gt; UnfoldSequence&lt;T&gt;<br>	public func unfold&lt;T&gt;(fromFirst initialElement: T, apply: T -&gt; T) -&gt; UnfoldSequence&lt;T&gt;<br></p><p>That way you&#39;re calling either `unfold(fromState:applying:)` or `unfold(fromFirst:applying:)`. (Some further bikeshedding might be needed here—it&#39;s late and I&#39;m tired.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Review] SE-0045: Add scan, prefix(while:), drop(while:), and iterate to the stdlib</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>May  1, 2016 at 11:00:00am</p></header><div class="content"><p>On Sun, May 1, 2016, at 04:13 AM, Brent Royal-Gordon wrote:<br>&gt; &gt; The proposal has been updated as per feedback from the core team (https://github.com/apple/swift-evolution/pull/275). This includes removing some last vestiges of Swift 2 naming as well as replacing `iterate(_:apply:)` with an overloaded function `unfold(_:applying:)`.<br>&gt; <br>&gt; The proposal says this:<br>&gt; <br>&gt; 	public func unfold&lt;T, State&gt;(_ initialState: State, applying: State -&gt; (T, State)?) -&gt; UnfoldSequence&lt;T&gt;<br>&gt; 	public func unfold&lt;T&gt;(_ initialElement: T, apply: T -&gt; T) -&gt; UnfoldSequence&lt;T&gt;<br>&gt; <br>&gt; However, the comment implies that the second one should instead be this:<br>&gt; <br>&gt; 	public func unfold&lt;T&gt;(_ initialElement: T, applying: T -&gt; T?) -&gt; UnfoldSequence&lt;T&gt;<br></p><p>Oops, you&#39;re right, that was a mistake.<br></p><p>-Kevin<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Review] SE-0045: Add scan, prefix(while:), drop(while:), and iterate to the stdlib</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>May 13, 2016 at 12:00:00pm</p></header><div class="content"><p>On May 1, 2016, at 5:13 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; The proposal has been updated as per feedback from the core team (https://github.com/apple/swift-evolution/pull/275). This includes removing some last vestiges of Swift 2 naming as well as replacing `iterate(_:apply:)` with an overloaded function `unfold(_:applying:)`.<br>&gt; <br>&gt; The proposal says this:<br>&gt; <br>&gt; 	public func unfold&lt;T, State&gt;(_ initialState: State, applying: State -&gt; (T, State)?) -&gt; UnfoldSequence&lt;T&gt;<br>&gt; 	public func unfold&lt;T&gt;(_ initialElement: T, apply: T -&gt; T) -&gt; UnfoldSequence&lt;T&gt;<br>&gt; <br>&gt; However, the comment implies that the second one should instead be this:<br>&gt; <br>&gt; 	public func unfold&lt;T&gt;(_ initialElement: T, applying: T -&gt; T?) -&gt; UnfoldSequence&lt;T&gt;<br>&gt; <br>&gt; I&#39;m not sure I like having these be overloaded on only the return type of the closure. Maybe we could do something like this?<br>&gt; <br>&gt; 	public func unfold&lt;T, State&gt;(fromState initialState: State, applying: State -&gt; (T, State)?) -&gt; UnfoldSequence&lt;T&gt;<br>&gt; 	public func unfold&lt;T&gt;(fromFirst initialElement: T, apply: T -&gt; T) -&gt; UnfoldSequence&lt;T&gt;<br>&gt; <br>&gt; That way you&#39;re calling either `unfold(fromState:applying:)` or `unfold(fromFirst:applying:)`. (Some further bikeshedding might be needed here—it&#39;s late and I&#39;m tired.)<br></p><p>I really don&#39;t want to see this discussion die as I have a vested interest in getting this functionality into<br>Swift 3. So let me suggest that<br></p><p>`sequence(_:, next:) -&gt; AdHocSequence`<br></p><p>might be a Swift acceptable solution.  We&#39;re not going to see fold/unfold pair happen. It&#39;s a given that<br>`reduce` is a fixed point in Swift space and `sequence` well describes what this should be doing.<br></p><p>So is it possible to push forward with `sequence`, whose only negative seems to be that it&#39;s not as well<br>loved as `unfold`?<br></p><p>-- Erica<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/07e13f7a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Review] SE-0045: Add scan, prefix(while:), drop(while:), and iterate to the stdlib</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>May 13, 2016 at 12:00:00pm</p></header><div class="content"><p>On Fri, May 13, 2016, at 11:08 AM, Erica Sadun wrote:<br>&gt; On May 1, 2016, at 5:13 AM, Brent Royal-Gordon via swift-evolution &lt;swift-<br>&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; The proposal has been updated as per feedback from the core team<br>&gt;&gt;&gt; (https://github.com/apple/swift-evolution/pull/275). This includes<br>&gt;&gt;&gt; removing some last vestiges of Swift 2 naming as well as replacing<br>&gt;&gt;&gt; `iterate(_:apply:)` with an overloaded function<br>&gt;&gt;&gt; `unfold(_:applying:)`.<br>&gt;&gt;<br>&gt;&gt; The proposal says this:<br>&gt;&gt;<br>&gt;&gt;  public func unfold&lt;T, State&gt;(_ initialState: State, applying: State<br>&gt;&gt;  -&gt; (T, State)?) -&gt; UnfoldSequence&lt;T&gt;<br>&gt;&gt;  public func unfold&lt;T&gt;(_ initialElement: T, apply: T -&gt; T) -&gt;<br>&gt;&gt;  UnfoldSequence&lt;T&gt;<br>&gt;&gt;<br>&gt;&gt; However, the comment implies that the second one should instead<br>&gt;&gt; be this:<br>&gt;&gt;<br>&gt;&gt;  public func unfold&lt;T&gt;(_ initialElement: T, applying: T -&gt; T?) -&gt;<br>&gt;&gt;  UnfoldSequence&lt;T&gt;<br>&gt;&gt;<br>&gt;&gt; I&#39;m not sure I like having these be overloaded on only the return<br>&gt;&gt; type of the closure. Maybe we could do something like this?<br>&gt;&gt;<br>&gt;&gt;  public func unfold&lt;T, State&gt;(fromState initialState: State,<br>&gt;&gt;  applying: State -&gt; (T, State)?) -&gt; UnfoldSequence&lt;T&gt;<br>&gt;&gt;  public func unfold&lt;T&gt;(fromFirst initialElement: T, apply: T -&gt; T) -&gt;<br>&gt;&gt;  UnfoldSequence&lt;T&gt;<br>&gt;&gt;<br>&gt;&gt; That way you&#39;re calling either `unfold(fromState:applying:)` or<br>&gt;&gt; `unfold(fromFirst:applying:)`. (Some further bikeshedding might be<br>&gt;&gt; needed here—it&#39;s late and I&#39;m tired.)<br>&gt;<br>&gt; I really don&#39;t want to see this discussion die as I have a vested<br>&gt; interest in getting this functionality into<br>&gt; Swift 3. So let me suggest that<br>&gt;<br>&gt; `sequence(_:, next:) -&gt; AdHocSequence`<br>&gt;<br>&gt; might be a Swift acceptable solution.  We&#39;re not going to see<br>&gt; fold/unfold pair happen. It&#39;s a given that<br>&gt; `reduce` is a fixed point in Swift space and `sequence` well describes<br>&gt; what this should be doing.<br>&gt;<br>&gt; So is it possible to push forward with `sequence`, whose only negative<br>&gt; seems to be that it&#39;s not as well<br>&gt; loved as `unfold`?<br> <br>I do like `sequence`, though I&#39;m not sold on the name AdHocSequence<br>(just from that name it&#39;s hard to figure out what it does). An<br>alternative is `expand`, which is nice because it pairs with `reduce`,<br>but it&#39;s less obvious that it produces a sequence and the name isn&#39;t as<br>good with the stateful version.<br> <br>As for return type name, we could go ahead and use UnfoldSequence&lt;T&gt;<br>anyway even though the function isn&#39;t named `unfold`, because this name<br>will make sense to people who do know what unfold is, and I&#39;m not<br>convinced we can have a meaningful name for people who don&#39;t (since<br>SequenceSequence is too silly).<br> <br>So given that, I&#39;ll suggest the following:<br> <br>func sequence&lt;T&gt;(initial: T, next: T -&gt; T?) -&gt; UnfoldSequence&lt;T&gt;<br>func sequence&lt;T, State&gt;(state: State, next: (inout State) -&gt; T?) -&gt;<br>UnfoldSequence&lt;T&gt;<br> <br>I&#39;m suggesting `sequence(initial:next:)` instead of the previously-<br>suggested `sequence(from:applying:)` because the term &quot;from&quot; could<br>equally well mean the first element or the state, whereas &quot;initial&quot;<br>should make it more obvious that this value is the first element of the<br>resulting sequence. And I&#39;m using &quot;next&quot; as suggested by Erica because<br>the function does return the next element, and it&#39;s similar to the<br>IteratorProtocol method. I&#39;ve also chosen to change the stateful version<br>to use an inout parameter, as previously suggested, because it&#39;s<br>equivalent to the State -&gt; (T, State)? in functionality but is less<br>likely to produce unwanted COW copies.<br> <br>-Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/6087ca3b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[Review] SE-0045: Add scan, prefix(while:), drop(while:), and iterate to the stdlib</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>May 14, 2016 at 03:00:00pm</p></header><div class="content"><p>Would there be any issue with the return type being AnySequence? It’s used in other areas:<br></p><p>LazySequence &amp; FlattenSequence’s<br>dropFirst(n: Int) -&gt; AnySequence&lt;Generator.Element&gt;<br>dropLast(n: Int) -&gt; AnySequence&lt;Generator.Element&gt;<br></p><p>No need to introduce another type, and it’s straight forward to implement with AnySequence.<br></p><p><br>&gt; On 14 May 2016, at 5:07 AM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Fri, May 13, 2016, at 11:08 AM, Erica Sadun wrote:<br>&gt;&gt; On May 1, 2016, at 5:13 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; The proposal has been updated as per feedback from the core team (https://github.com/apple/swift-evolution/pull/275 &lt;https://github.com/apple/swift-evolution/pull/275&gt;). This includes removing some last vestiges of Swift 2 naming as well as replacing `iterate(_:apply:)` with an overloaded function `unfold(_:applying:)`.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; The proposal says this:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;  public func unfold&lt;T, State&gt;(_ initialState: State, applying: State -&gt; (T, State)?) -&gt; UnfoldSequence&lt;T&gt;<br>&gt;&gt;&gt;  public func unfold&lt;T&gt;(_ initialElement: T, apply: T -&gt; T) -&gt; UnfoldSequence&lt;T&gt;<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; However, the comment implies that the second one should instead be this:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;  public func unfold&lt;T&gt;(_ initialElement: T, applying: T -&gt; T?) -&gt; UnfoldSequence&lt;T&gt;<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; I&#39;m not sure I like having these be overloaded on only the return type of the closure. Maybe we could do something like this?<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;  public func unfold&lt;T, State&gt;(fromState initialState: State, applying: State -&gt; (T, State)?) -&gt; UnfoldSequence&lt;T&gt;<br>&gt;&gt;&gt;  public func unfold&lt;T&gt;(fromFirst initialElement: T, apply: T -&gt; T) -&gt; UnfoldSequence&lt;T&gt;<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; That way you&#39;re calling either `unfold(fromState:applying:)` or `unfold(fromFirst:applying:)`. (Some further bikeshedding might be needed here—it&#39;s late and I&#39;m tired.)<br>&gt;&gt; <br>&gt;&gt;  <br>&gt;&gt; I really don&#39;t want to see this discussion die as I have a vested interest in getting this functionality into<br>&gt;&gt; Swift 3. So let me suggest that<br>&gt;&gt;  <br>&gt;&gt; `sequence(_:, next:) -&gt; AdHocSequence`<br>&gt;&gt;  <br>&gt;&gt; might be a Swift acceptable solution.  We&#39;re not going to see fold/unfold pair happen. It&#39;s a given that<br>&gt;&gt; `reduce` is a fixed point in Swift space and `sequence` well describes what this should be doing.<br>&gt;&gt;  <br>&gt;&gt; So is it possible to push forward with `sequence`, whose only negative seems to be that it&#39;s not as well<br>&gt;&gt; loved as `unfold`?<br>&gt;  <br>&gt; I do like `sequence`, though I&#39;m not sold on the name AdHocSequence (just from that name it&#39;s hard to figure out what it does). An alternative is `expand`, which is nice because it pairs with `reduce`, but it&#39;s less obvious that it produces a sequence and the name isn&#39;t as good with the stateful version.<br>&gt;  <br>&gt; As for return type name, we could go ahead and use UnfoldSequence&lt;T&gt; anyway even though the function isn&#39;t named `unfold`, because this name will make sense to people who do know what unfold is, and I&#39;m not convinced we can have a meaningful name for people who don&#39;t (since SequenceSequence is too silly).<br>&gt;  <br>&gt; So given that, I&#39;ll suggest the following:<br>&gt;  <br>&gt;   func sequence&lt;T&gt;(initial: T, next: T -&gt; T?) -&gt; UnfoldSequence&lt;T&gt;<br>&gt;   func sequence&lt;T, State&gt;(state: State, next: (inout State) -&gt; T?) -&gt; UnfoldSequence&lt;T&gt;<br>&gt;  <br>&gt; I&#39;m suggesting `sequence(initial:next:)` instead of the previously-suggested `sequence(from:applying:)` because the term &quot;from&quot; could equally well mean the first element or the state, whereas &quot;initial&quot; should make it more obvious that this value is the first element of the resulting sequence. And I&#39;m using &quot;next&quot; as suggested by Erica because the function does return the next element, and it&#39;s similar to the IteratorProtocol method. I&#39;ve also chosen to change the stateful version to use an inout parameter, as previously suggested, because it&#39;s equivalent to the State -&gt; (T, State)? in functionality but is less likely to produce unwanted COW copies.<br>&gt;  <br>&gt; -Kevin Ballard<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160514/760d1ed4/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Review] SE-0045: Add scan, prefix(while:), drop(while:), and iterate to the stdlib</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>May 14, 2016 at 01:00:00pm</p></header><div class="content"><p>AnySequence is specifically used to erase the type of an underlying<br>sequence, and I&#39;m guessing that using it here will make it harder to<br>optimize loops that use this.<br> <br>-Kevin Ballard<br> <br>On Fri, May 13, 2016, at 10:20 PM, Patrick Smith wrote:<br>&gt; Would there be any issue with the return type being AnySequence? It’s<br>&gt; used in other areas:<br>&gt;<br>&gt; LazySequence &amp; FlattenSequence’s<br>&gt; dropFirst(n: Int) -&gt; AnySequence&lt;Generator.Element&gt;<br>&gt; dropLast(n: Int) -&gt; AnySequence&lt;Generator.Element&gt;<br>&gt;<br>&gt; No need to introduce another type, and it’s straight forward to<br>&gt; implement with AnySequence.<br>&gt;<br>&gt;<br>&gt;&gt; On 14 May 2016, at 5:07 AM, Kevin Ballard via swift-evolution &lt;swift-<br>&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Fri, May 13, 2016, at 11:08 AM, Erica Sadun wrote:<br>&gt;&gt;&gt; On May 1, 2016, at 5:13 AM, Brent Royal-Gordon via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; The proposal has been updated as per feedback from the core team<br>&gt;&gt;&gt;&gt;&gt; (https://github.com/apple/swift-evolution/pull/275). This includes<br>&gt;&gt;&gt;&gt;&gt; removing some last vestiges of Swift 2 naming as well as replacing<br>&gt;&gt;&gt;&gt;&gt; `iterate(_:apply:)` with an overloaded function<br>&gt;&gt;&gt;&gt;&gt; `unfold(_:applying:)`.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The proposal says this:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; public func unfold&lt;T, State&gt;(_ initialState: State, applying: State<br>&gt;&gt;&gt;&gt; -&gt; (T, State)?) -&gt; UnfoldSequence&lt;T&gt;<br>&gt;&gt;&gt;&gt; public func unfold&lt;T&gt;(_ initialElement: T, apply: T -&gt; T) -&gt;<br>&gt;&gt;&gt;&gt; UnfoldSequence&lt;T&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; However, the comment implies that the second one should instead be<br>&gt;&gt;&gt;&gt; this:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; public func unfold&lt;T&gt;(_ initialElement: T, applying: T -&gt; T?) -&gt;<br>&gt;&gt;&gt;&gt; UnfoldSequence&lt;T&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I&#39;m not sure I like having these be overloaded on only the return<br>&gt;&gt;&gt;&gt; type of the closure. Maybe we could do something like this?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; public func unfold&lt;T, State&gt;(fromState initialState: State,<br>&gt;&gt;&gt;&gt; applying: State -&gt; (T, State)?) -&gt; UnfoldSequence&lt;T&gt;<br>&gt;&gt;&gt;&gt; public func unfold&lt;T&gt;(fromFirst initialElement: T, apply: T -&gt; T)<br>&gt;&gt;&gt;&gt; -&gt; UnfoldSequence&lt;T&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; That way you&#39;re calling either `unfold(fromState:applying:)` or<br>&gt;&gt;&gt;&gt; `unfold(fromFirst:applying:)`. (Some further bikeshedding might be<br>&gt;&gt;&gt;&gt; needed here—it&#39;s late and I&#39;m tired.)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I really don&#39;t want to see this discussion die as I have a vested<br>&gt;&gt;&gt; interest in getting this functionality into<br>&gt;&gt;&gt; Swift 3. So let me suggest that<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; `sequence(_:, next:) -&gt; AdHocSequence`<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; might be a Swift acceptable solution.  We&#39;re not going to see<br>&gt;&gt;&gt; fold/unfold pair happen. It&#39;s a given that<br>&gt;&gt;&gt; `reduce` is a fixed point in Swift space and `sequence` well<br>&gt;&gt;&gt; describes what this should be doing.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; So is it possible to push forward with `sequence`, whose only<br>&gt;&gt;&gt; negative seems to be that it&#39;s not as well<br>&gt;&gt;&gt; loved as `unfold`?<br>&gt;&gt;<br>&gt;&gt; I do like `sequence`, though I&#39;m not sold on the name AdHocSequence<br>&gt;&gt; (just from that name it&#39;s hard to figure out what it does). An<br>&gt;&gt; alternative is `expand`, which is nice because it pairs with<br>&gt;&gt; `reduce`, but it&#39;s less obvious that it produces a sequence and the<br>&gt;&gt; name isn&#39;t as good with the stateful version.<br>&gt;&gt;<br>&gt;&gt; As for return type name, we could go ahead and use UnfoldSequence&lt;T&gt;<br>&gt;&gt; anyway even though the function isn&#39;t named `unfold`, because this<br>&gt;&gt; name will make sense to people who do know what unfold is, and I&#39;m<br>&gt;&gt; not convinced we can have a meaningful name for people who don&#39;t<br>&gt;&gt; (since SequenceSequence is too silly).<br>&gt;&gt;<br>&gt;&gt; So given that, I&#39;ll suggest the following:<br>&gt;&gt;<br>&gt;&gt; func sequence&lt;T&gt;(initial: T, next: T -&gt; T?) -&gt; UnfoldSequence&lt;T&gt;<br>&gt;&gt; func sequence&lt;T, State&gt;(state: State, next: (inout State) -&gt; T?) -&gt;<br>&gt;&gt; UnfoldSequence&lt;T&gt;<br>&gt;&gt;<br>&gt;&gt; I&#39;m suggesting `sequence(initial:next:)` instead of the previously-<br>&gt;&gt; suggested `sequence(from:applying:)` because the term &quot;from&quot; could<br>&gt;&gt; equally well mean the first element or the state, whereas &quot;initial&quot;<br>&gt;&gt; should make it more obvious that this value is the first element of<br>&gt;&gt; the resulting sequence. And I&#39;m using &quot;next&quot; as suggested by Erica<br>&gt;&gt; because the function does return the next element, and it&#39;s similar<br>&gt;&gt; to the IteratorProtocol method. I&#39;ve also chosen to change the<br>&gt;&gt; stateful version to use an inout parameter, as previously suggested,<br>&gt;&gt; because it&#39;s equivalent to the State -&gt; (T, State)? in functionality<br>&gt;&gt; but is less likely to produce unwanted COW copies.<br>&gt;&gt;<br>&gt;&gt; -Kevin Ballard<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br> <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160514/43ba994d/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
